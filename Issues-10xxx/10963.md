# Issue 10963: Axioms and more functorial constructions

archive/issues_010884.json:
```json
{
    "body": "This ticket implements:\n\n- Support for full subcategories defined by an axiom (Finite,\n  Infinite, Facade, Commutative, Associative, Unital, Inverse,\n  Distributive, NoZeroDivisors, Division, FiniteDimensional,\n  Connected, WithBasis, Irreducible), and joins thereof:\n\n```\n    sage: Groups() & Sets().Finite()\n    Category of finite groups\n\n    sage: Algebras(QQ).Finite() & Monoids().Commutative()\n    Category of finite commutative algebras over Rational Field\n\n    sage: (Monoids() & CommutativeAdditiveGroups()).Distributive()\n    Category of rings\n\n    sage: Rings().Division() & Sets().Finite()\n    Category of finite fields\n```\n\n- New categories:\n  - AdditiveSemigroups, AdditiveMonoids, AdditiveGroups\n  - DistributiveMagmasAndAdditiveMagmas\n  - MagmaticAlgebras (will replace Algebras in #15043)\n  - AssociativeAlgebras\n  - UnitalAlgebras\n  - Algebras of additive semigroups and monoids\n\n- More mathematical rules:\n  - A subquotient of a finite set is a finite set\n  - The algebra of a finite set is finite dimensional\n  - The algebra of a commutative magma is commutative\n  - A finite division ring is a field\n  - ...\n\n- Documentation:\n  - More documentation for IsomorphicObjects\n  - Complete revamping of sage.categories.primer\n  - Misc\n\n- Use SubcategoryMethods to put the functorial constructions where\n  they belong. E.g. DualObjects, TensorProducts, and Graded are now\n  only defined for subcategories of Modules.\n\n- More lazy imports, removed a bunch of unused imports, ...\n\nThis ticket is dedicated to the town of Megantic where I was so warmly welcomed and a good chunk of this ticket got implemented!\n\n\nDepends on #11224\n\nDepends on #8327\n\nDepends on #10193\n\nDepends on #12895\n\nDepends on #14516\n\nDepends on #14722\n\nDepends on #13589\n\nDepends on #14471\n\nDepends on #15069\n\nDepends on #15094\n\nDepends on #11688\n\nDepends on #13394\n\nDepends on #15150\n\nDepends on #15506\n\nDepends on #15757\n\nDepends on #15759\n\nDepends on #16244\n\nDepends on #16269\n\n**Assignee:** stumpc5\n\n**CC:**  sage-combinat @simon-king-jena @saliola @anneschilling @vbraun @nbruin @zabrocki\n\n**Keywords:** days54\n\n**Branch:** [c16f18b56c2b5470088bbcf110ddbb15be6caf0c](https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c)\n\n**Work Issues:** To be merged simultaneously with #15801\n\n**Reviewer:** Volker Braun, Nils Bruin, Peter Bruin, Fr\u00e9d\u00e9ric Chapoton, Darij Grinberg, Florent Hivert, Simon King, Travis Scrimshaw\n\n**Author:** Nicolas M. Thi\u00e9ry\n\nIssue created by migration from https://trac.sagemath.org/ticket/10963\n\n",
    "closed_at": "2014-05-19T10:24:46Z",
    "created_at": "2011-03-18T16:36:48Z",
    "labels": [
        "component: categories",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.3",
    "title": "Axioms and more functorial constructions",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/10963",
    "user": "https://github.com/nthiery"
}
```
This ticket implements:

- Support for full subcategories defined by an axiom (Finite,
  Infinite, Facade, Commutative, Associative, Unital, Inverse,
  Distributive, NoZeroDivisors, Division, FiniteDimensional,
  Connected, WithBasis, Irreducible), and joins thereof:

```
    sage: Groups() & Sets().Finite()
    Category of finite groups

    sage: Algebras(QQ).Finite() & Monoids().Commutative()
    Category of finite commutative algebras over Rational Field

    sage: (Monoids() & CommutativeAdditiveGroups()).Distributive()
    Category of rings

    sage: Rings().Division() & Sets().Finite()
    Category of finite fields
```

- New categories:
  - AdditiveSemigroups, AdditiveMonoids, AdditiveGroups
  - DistributiveMagmasAndAdditiveMagmas
  - MagmaticAlgebras (will replace Algebras in #15043)
  - AssociativeAlgebras
  - UnitalAlgebras
  - Algebras of additive semigroups and monoids

- More mathematical rules:
  - A subquotient of a finite set is a finite set
  - The algebra of a finite set is finite dimensional
  - The algebra of a commutative magma is commutative
  - A finite division ring is a field
  - ...

- Documentation:
  - More documentation for IsomorphicObjects
  - Complete revamping of sage.categories.primer
  - Misc

- Use SubcategoryMethods to put the functorial constructions where
  they belong. E.g. DualObjects, TensorProducts, and Graded are now
  only defined for subcategories of Modules.

- More lazy imports, removed a bunch of unused imports, ...

This ticket is dedicated to the town of Megantic where I was so warmly welcomed and a good chunk of this ticket got implemented!


Depends on #11224

Depends on #8327

Depends on #10193

Depends on #12895

Depends on #14516

Depends on #14722

Depends on #13589

Depends on #14471

Depends on #15069

Depends on #15094

Depends on #11688

Depends on #13394

Depends on #15150

Depends on #15506

Depends on #15757

Depends on #15759

Depends on #16244

Depends on #16269

**Assignee:** stumpc5

**CC:**  sage-combinat @simon-king-jena @saliola @anneschilling @vbraun @nbruin @zabrocki

**Keywords:** days54

**Branch:** [c16f18b56c2b5470088bbcf110ddbb15be6caf0c](https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c)

**Work Issues:** To be merged simultaneously with #15801

**Reviewer:** Volker Braun, Nils Bruin, Peter Bruin, Frédéric Chapoton, Darij Grinberg, Florent Hivert, Simon King, Travis Scrimshaw

**Author:** Nicolas M. Thiéry

Issue created by migration from https://trac.sagemath.org/ticket/10963





---

archive/issue_comments_108745.json:
```json
{
    "body": "**Dependencies:** #11224",
    "created_at": "2011-04-24T00:23:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108745",
    "user": "https://github.com/nthiery"
}
```

**Dependencies:** #11224



---

archive/issue_comments_108746.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,6 +1,20 @@\n-The patch under development on the Sage-Combinat queue implements:\n+The patch under finalization on the Sage-Combinat queue implements:\n \n-- The algebra of a finite enumerated set is a finite dimensional algebra\n-- Commutative additive semigroup and monoid algebras\n+- Support for full subcategories defined by a predicate on the objects\n+  (Finite, Infinite, FiniteDimensional, Commutative, Graded, Facade),\n+  and joins thereof:\n+\n+```\n+    sage: Category.join([Groups(), Sets().Finite()])\n+    Category of finite groups\n+    sage: Category.join([Algebras(QQ).Finite(), Monoids().Commutative()])\n+    Join of Category of commutative algebras over Rational Field and Category of finite monoids\n+```\n+\n+- More mathematical rules:\n+  - A subquotient of a finite set is a finite set\n+  - The algebra of a finite set is finite dimensional\n+  - The algebra of a commutative magma is commutative\n+- Algebras of commutative additive semigroups and monoids\n - More documentation for IsomorphicObjects and other doc improvements\n \n``````\n",
    "created_at": "2011-04-24T05:06:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108746",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,6 +1,20 @@
-The patch under development on the Sage-Combinat queue implements:
+The patch under finalization on the Sage-Combinat queue implements:
 
-- The algebra of a finite enumerated set is a finite dimensional algebra
-- Commutative additive semigroup and monoid algebras
+- Support for full subcategories defined by a predicate on the objects
+  (Finite, Infinite, FiniteDimensional, Commutative, Graded, Facade),
+  and joins thereof:
+
+```
+    sage: Category.join([Groups(), Sets().Finite()])
+    Category of finite groups
+    sage: Category.join([Algebras(QQ).Finite(), Monoids().Commutative()])
+    Join of Category of commutative algebras over Rational Field and Category of finite monoids
+```
+
+- More mathematical rules:
+  - A subquotient of a finite set is a finite set
+  - The algebra of a finite set is finite dimensional
+  - The algebra of a commutative magma is commutative
+- Algebras of commutative additive semigroups and monoids
 - More documentation for IsomorphicObjects and other doc improvements
 
``````




---

archive/issue_comments_108747.json:
```json
{
    "body": "**Changing assignee** from @nthiery to stumpc5.",
    "created_at": "2011-06-10T11:59:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108747",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

**Changing assignee** from @nthiery to stumpc5.



---

archive/issue_comments_108748.json:
```json
{
    "body": "<a id='comment:3'></a>\nHi Nicolas,\n\nHow far is this patch -- I just saw that the UCF patch depends on this.\n\nI didn't actually figure out how it depends, I just get a trivial rebase, and then an import loop which wasn't easily fixable. The problem was my use of CombinatorialFreeModule...\n\nThx, Christian",
    "created_at": "2011-06-10T11:59:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108748",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:3'></a>
Hi Nicolas,

How far is this patch -- I just saw that the UCF patch depends on this.

I didn't actually figure out how it depends, I just get a trivial rebase, and then an import loop which wasn't easily fixable. The problem was my use of CombinatorialFreeModule...

Thx, Christian



---

archive/issue_comments_108749.json:
```json
{
    "body": "**Changing dependencies** from \"#11224\" to \"#11224, #8327\".",
    "created_at": "2011-10-11T13:40:58Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108749",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

**Changing dependencies** from "#11224" to "#11224, #8327".



---

archive/issue_comments_108750.json:
```json
{
    "body": "<a id='comment:6'></a>\nIt turns out that many hunks of that patch fail to apply, when one starts with sage-4.8.alpha0 plus the new cython spkg from #11761 plus the rebased patch from #8327. So, there are further dependencies from the combinat queue. Could you try to find out which they are, and post them here?",
    "created_at": "2011-11-15T22:05:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108750",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
It turns out that many hunks of that patch fail to apply, when one starts with sage-4.8.alpha0 plus the new cython spkg from #11761 plus the rebased patch from #8327. So, there are further dependencies from the combinat queue. Could you try to find out which they are, and post them here?



---

archive/issue_events_085454.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-11-15T22:05:45Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85454"
}
```



---

archive/issue_comments_108751.json:
```json
{
    "body": "**Work Issues:** Find dependencies",
    "created_at": "2011-11-15T22:05:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108751",
    "user": "https://github.com/simon-king-jena"
}
```

**Work Issues:** Find dependencies



---

archive/issue_comments_108752.json:
```json
{
    "body": "**Changing work issues** from \"Find dependencies\" to \"Find dependencies. Finite dimensional vector spaces\".",
    "created_at": "2011-11-15T23:04:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108752",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "Find dependencies" to "Find dependencies. Finite dimensional vector spaces".



---

archive/issue_comments_108753.json:
```json
{
    "body": "<a id='comment:7'></a>\nWorking with the combinat queue, I could do some first tests. What I find very strange is the fact that the category of vector spaces coincides with the category of finite-dimensional vector spaces:\n\n```\nsage: VectorSpaces(QQ).FiniteDimensional() is VectorSpaces(QQ)\nTrue\n```\n\nIs that really intended? I thought that the idea of this ticket is to create new categories dynamically. Hence, even though there previously was no specific implementation of the category of finite dimensional vector spaces, the construction `VectorSpaces(QQ).FiniteDimensional()` would automatically create one. Or am I misunderstanding something?",
    "created_at": "2011-11-15T23:04:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108753",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Working with the combinat queue, I could do some first tests. What I find very strange is the fact that the category of vector spaces coincides with the category of finite-dimensional vector spaces:

```
sage: VectorSpaces(QQ).FiniteDimensional() is VectorSpaces(QQ)
True
```

Is that really intended? I thought that the idea of this ticket is to create new categories dynamically. Hence, even though there previously was no specific implementation of the category of finite dimensional vector spaces, the construction `VectorSpaces(QQ).FiniteDimensional()` would automatically create one. Or am I misunderstanding something?



---

archive/issue_comments_108754.json:
```json
{
    "body": "<a id='comment:10'></a>\nWould you mind actually uploading the patch in question here?",
    "created_at": "2012-11-27T13:34:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108754",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:10'></a>
Would you mind actually uploading the patch in question here?



---

archive/issue_comments_108755.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -18,3 +18,4 @@\n - Algebras of commutative additive semigroups and monoids\n - More documentation for IsomorphicObjects and other doc improvements\n \n+See http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch and follow ups.\n``````\n",
    "created_at": "2013-02-28T16:41:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108755",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -18,3 +18,4 @@
 - Algebras of commutative additive semigroups and monoids
 - More documentation for IsomorphicObjects and other doc improvements
 
+See http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch and follow ups.
``````




---

archive/issue_comments_108756.json:
```json
{
    "body": "<a id='comment:12'></a>\nLittle update: after two good weeks of work, here is the status of the patch in the Sage-Combinat queue:\n- 100% doctested\n- Passes all long tests (with the patches above it; well, there is a failure in sage_object.pyx, but it is caused by an above tests)\n- Reasonably documented, but needs a pass of proof reading and an overview documentation\n- Has not yet been tested for performance; but creating an instance of each of the categories in sage.categories (120 of them) takes less than 0.1s, so nothing horrible a priori.\n- Needs some discussions for good naming conventions and later directions. I have made a precise list which I'll post later on.\n- Has some trivial dependencies on unrelated patches that are close to positive review; I need to figure out the exact list.\n\nIn short: getting ready for review next week!",
    "created_at": "2013-06-14T02:33:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108756",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:12'></a>
Little update: after two good weeks of work, here is the status of the patch in the Sage-Combinat queue:
- 100% doctested
- Passes all long tests (with the patches above it; well, there is a failure in sage_object.pyx, but it is caused by an above tests)
- Reasonably documented, but needs a pass of proof reading and an overview documentation
- Has not yet been tested for performance; but creating an instance of each of the categories in sage.categories (120 of them) takes less than 0.1s, so nothing horrible a priori.
- Needs some discussions for good naming conventions and later directions. I have made a precise list which I'll post later on.
- Has some trivial dependencies on unrelated patches that are close to positive review; I need to figure out the exact list.

In short: getting ready for review next week!



---

archive/issue_comments_108757.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327\" to \"#11224, #8327, #10193 #12895, #14516, #14722\".",
    "created_at": "2013-06-20T16:02:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108757",
    "user": "https://github.com/nthiery"
}
```

**Changing dependencies** from "#11224, #8327" to "#11224, #8327, #10193 #12895, #14516, #14722".



---

archive/issue_comments_108758.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193 #12895, #14516, #14722\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589\".",
    "created_at": "2013-06-20T16:07:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108758",
    "user": "https://github.com/nthiery"
}
```

**Changing dependencies** from "#11224, #8327, #10193 #12895, #14516, #14722" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589".



---

archive/issue_comments_108759.json:
```json
{
    "body": "**Changing work issues** from \"Find dependencies. Finite dimensional vector spaces\" to \"\".",
    "created_at": "2013-06-20T16:07:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108759",
    "user": "https://github.com/nthiery"
}
```

**Changing work issues** from "Find dependencies. Finite dimensional vector spaces" to "".



---

archive/issue_comments_108760.json:
```json
{
    "body": "<a id='comment:15'></a>\nJust for the record: I currently have applied\n\n```\ntrac_12876_category_abstract_classes_for_hom.patch\ntrac11935_weak_pickling_by_construction-nt.patch\ntrac_11935-weak_pickling_by_construction-review-ts.patch\ntrac_12895-subcategory-methods-nt.patch\ntrac_12895-review.patch\ntrac_10193-graded_sets-rebased.patch\ntrac_10193-graded_sets-review-ts.patch\ntrac_13589-categories-c3_under_control-nt.patch\ntrac13589_cmp_key_attribute.patch\ntrac13589_improve_startuptime.patch\ntrac_12630_quivers_v2.patch\ntrac12630_refactor_code.2.patch\ntrac_14722-lazy_import_at_startup-nt.patch\ntrac_14266_ascii_art_13_05_15_EliX-jbp.patch\ntrac_14266-ascii_art-review-ts.patch\ntrac_14266_terminal_width.patch\ntrac_14402-tensor_product_infinite_crystals-ts.patch\ntrac_14143-alcove-path-al.3.patch\ntrac_14413-elementary_crystals-bs.patch\ntrac_14516-crystals_speedup-ts.patch\n```\non top of sage-5.10.rc1 (I think these are all dependencies).\n\nSo, as soon as Nicolas told me how to get the patch from git and what is meant by \"and follow-ups\", I can start reviewing!",
    "created_at": "2013-06-20T16:32:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108760",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:15'></a>
Just for the record: I currently have applied

```
trac_12876_category_abstract_classes_for_hom.patch
trac11935_weak_pickling_by_construction-nt.patch
trac_11935-weak_pickling_by_construction-review-ts.patch
trac_12895-subcategory-methods-nt.patch
trac_12895-review.patch
trac_10193-graded_sets-rebased.patch
trac_10193-graded_sets-review-ts.patch
trac_13589-categories-c3_under_control-nt.patch
trac13589_cmp_key_attribute.patch
trac13589_improve_startuptime.patch
trac_12630_quivers_v2.patch
trac12630_refactor_code.2.patch
trac_14722-lazy_import_at_startup-nt.patch
trac_14266_ascii_art_13_05_15_EliX-jbp.patch
trac_14266-ascii_art-review-ts.patch
trac_14266_terminal_width.patch
trac_14402-tensor_product_infinite_crystals-ts.patch
trac_14143-alcove-path-al.3.patch
trac_14413-elementary_crystals-bs.patch
trac_14516-crystals_speedup-ts.patch
```
on top of sage-5.10.rc1 (I think these are all dependencies).

So, as soon as Nicolas told me how to get the patch from git and what is meant by "and follow-ups", I can start reviewing!



---

archive/issue_comments_108761.json:
```json
{
    "body": "<a id='comment:16'></a>\nWith these list I gave above, the patch does not apply. Some of it might be to blame the latest version of my `trac13589_improve_startuptime.patch`. So, let's try to remove this. But there seem to be further dependencies.",
    "created_at": "2013-06-20T16:49:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108761",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:16'></a>
With these list I gave above, the patch does not apply. Some of it might be to blame the latest version of my `trac13589_improve_startuptime.patch`. So, let's try to remove this. But there seem to be further dependencies.



---

archive/issue_comments_108762.json:
```json
{
    "body": "<a id='comment:17'></a>\nEven when I remove `trac13589_improve_startuptime.patch`, I still get 4 mismatches and 1 noise in category.py, 4 mismatches in category_singleton.pyx, and 1 mismatch and 2 noises in c3_controlled.pyx",
    "created_at": "2013-06-20T16:52:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108762",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:17'></a>
Even when I remove `trac13589_improve_startuptime.patch`, I still get 4 mismatches and 1 noise in category.py, 4 mismatches in category_singleton.pyx, and 1 mismatch and 2 noises in c3_controlled.pyx



---

archive/issue_comments_108763.json:
```json
{
    "body": "<a id='comment:18'></a>\nBack at work. These patches on top of sage-5.11.b3 do apply:\n\n```\ntrac_14516-crystals_speedup-ts.2.patch\ntrac_14722-lazy_import_at_startup-nt.patch\ntrac_13589-categories-c3_under_control-nt.patch\ntrac_10963-more_functorial_constructions-nt.patch\n```\n(the last patch applies with a little fuzz)\n\nHowever, if we decide to include the two additional patches from #13589, then the last patch needs to be rebased.\n\nFor now, I'll try without the two additional patches, since they only concern performance (and seem to have disappointingly little effect).",
    "created_at": "2013-06-26T13:06:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108763",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'></a>
Back at work. These patches on top of sage-5.11.b3 do apply:

```
trac_14516-crystals_speedup-ts.2.patch
trac_14722-lazy_import_at_startup-nt.patch
trac_13589-categories-c3_under_control-nt.patch
trac_10963-more_functorial_constructions-nt.patch
```
(the last patch applies with a little fuzz)

However, if we decide to include the two additional patches from #13589, then the last patch needs to be rebased.

For now, I'll try without the two additional patches, since they only concern performance (and seem to have disappointingly little effect).



---

archive/issue_comments_108764.json:
```json
{
    "body": "**Reviewer:** Simon King",
    "created_at": "2013-06-26T13:06:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108764",
    "user": "https://github.com/simon-king-jena"
}
```

**Reviewer:** Simon King



---

archive/issue_events_085455.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-06-26T13:06:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85455"
}
```



---

archive/issue_events_085456.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-06-26T13:06:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85456"
}
```



---

archive/issue_comments_108765.json:
```json
{
    "body": "<a id='comment:19'></a>\nHi Simon!\n\nGreat that the patches apply.\n\nI am happy to handle the rebase on top of the extra patches for #13589. I also have some modifications in primer.py that I need to finish merging it. I'll try to finish this today. I guess there is enough to review elsewhere to keep you busy until then :-)\n\nThanks a lot!\n\nCheers,\n                                  Nicolas",
    "created_at": "2013-06-26T13:30:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108765",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:19'></a>
Hi Simon!

Great that the patches apply.

I am happy to handle the rebase on top of the extra patches for #13589. I also have some modifications in primer.py that I need to finish merging it. I'll try to finish this today. I guess there is enough to review elsewhere to keep you busy until then :-)

Thanks a lot!

Cheers,
                                  Nicolas



---

archive/issue_comments_108766.json:
```json
{
    "body": "**Work Issues:** Rebase wrt. #13589",
    "created_at": "2013-07-02T14:42:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108766",
    "user": "https://github.com/simon-king-jena"
}
```

**Work Issues:** Rebase wrt. #13589



---

archive/issue_comments_108767.json:
```json
{
    "body": "<a id='comment:21'></a>\nJust to make sure I understand correctly: During `__init__` of a group algebra, only the coercion from the group is registered, since the coercion from the base ring is registered during `__init_extra__`, which is obtained from the category?",
    "created_at": "2013-07-02T14:57:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108767",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:21'></a>
Just to make sure I understand correctly: During `__init__` of a group algebra, only the coercion from the group is registered, since the coercion from the base ring is registered during `__init_extra__`, which is obtained from the category?



---

archive/issue_comments_108768.json:
```json
{
    "body": "<a id='comment:22'></a>\nReplying to [SimonKing](#comment%3A21):\n> Just to make sure I understand correctly: During `__init__` of a group algebra, only the coercion from the group is registered, since the coercion from the base ring is registered during `__init_extra__`, which is obtained from the category?\n\nYes indeed!\n\nThere is nothing specific to do for GroupAlgebras about this feature, since it's already provided by Algebras.",
    "created_at": "2013-07-02T15:01:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108768",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:22'></a>
Replying to [SimonKing](#comment%3A21):
> Just to make sure I understand correctly: During `__init__` of a group algebra, only the coercion from the group is registered, since the coercion from the base ring is registered during `__init_extra__`, which is obtained from the category?

Yes indeed!

There is nothing specific to do for GroupAlgebras about this feature, since it's already provided by Algebras.



---

archive/issue_comments_108769.json:
```json
{
    "body": "<a id='comment:23'></a>\nThere is now a category of non-associative algebras. But that's misleading, because it certainly contains all associative algebras too, isn't it? I'd say that \"non-associative non-unital (non-commutative) (non-finite-dimensional) algebras\" should simply be \"algebras\".\n\nIn other words, I am against mentioning the *absence* of an axiom in the category name. Only the *presence* of an axiom must play a role.",
    "created_at": "2013-07-02T15:04:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108769",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:23'></a>
There is now a category of non-associative algebras. But that's misleading, because it certainly contains all associative algebras too, isn't it? I'd say that "non-associative non-unital (non-commutative) (non-finite-dimensional) algebras" should simply be "algebras".

In other words, I am against mentioning the *absence* of an axiom in the category name. Only the *presence* of an axiom must play a role.



---

archive/issue_comments_108770.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [SimonKing](#comment%3A23):\n> There is now a category of non-associative algebras. But that's misleading, because it certainly contains all associative algebras too, isn't it? I'd say that \"non-associative non-unital (non-commutative) (non-finite-dimensional) algebras\" should simply be \"algebras\".\n> \n> In other words, I am against mentioning the *absence* of an axiom in the category name. Only the *presence* of an axiom must play a role.\n\nYeah, that's been a recurrent issue. I agree that this is not nice,\neven though it's relatively common practice in maths to label as\n\"non-foo things\" the larger field of study where one is interested in\nthings that are \"not necessarily foo\". For non associative non unital\nalgebras, Florent mentionned yesterday that \"magmatic algebras\" was\nfairly standard, and I am happy to go with it. Do you have a better\nname for \"non unital algebras\"? I am not really keen on\n\"NotNecessarilyUnitalAlgebras\".\n\nCheers,",
    "created_at": "2013-07-02T15:26:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108770",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:24'></a>
Replying to [SimonKing](#comment%3A23):
> There is now a category of non-associative algebras. But that's misleading, because it certainly contains all associative algebras too, isn't it? I'd say that "non-associative non-unital (non-commutative) (non-finite-dimensional) algebras" should simply be "algebras".
> 
> In other words, I am against mentioning the *absence* of an axiom in the category name. Only the *presence* of an axiom must play a role.

Yeah, that's been a recurrent issue. I agree that this is not nice,
even though it's relatively common practice in maths to label as
"non-foo things" the larger field of study where one is interested in
things that are "not necessarily foo". For non associative non unital
algebras, Florent mentionned yesterday that "magmatic algebras" was
fairly standard, and I am happy to go with it. Do you have a better
name for "non unital algebras"? I am not really keen on
"NotNecessarilyUnitalAlgebras".

Cheers,



---

archive/issue_comments_108771.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [nthiery](#comment%3A24):\n> Do you have a better\n> name for \"non unital algebras\"? I am not really keen on\n> \"NotNecessarilyUnitalAlgebras\".\n\nYes. A not necessarily unital not necessarily associative not necessarily finite-dimensional not necessarily noetherian not necessarily ... is commonly known as an **algebra**.\n\nIn other words, I suggest to name the categories exactly parallel to the axioms it provides. Actually, before reading your patch, I thought that you aim to *automatically* create a category of \"associative algebras\", given the category of algebras and the axiom \"associative\".\n\nHence, I think it should be\n\n```\n                  algebras\n                /        \\\n associative algebras   unital algebras\n               \\          /\n        associative unital algebras\n```\nand similar for commutative algebras, commutative associative algebras, commutative associative unital algebras, and so on.",
    "created_at": "2013-07-02T15:45:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108771",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:25'></a>
Replying to [nthiery](#comment%3A24):
> Do you have a better
> name for "non unital algebras"? I am not really keen on
> "NotNecessarilyUnitalAlgebras".

Yes. A not necessarily unital not necessarily associative not necessarily finite-dimensional not necessarily noetherian not necessarily ... is commonly known as an **algebra**.

In other words, I suggest to name the categories exactly parallel to the axioms it provides. Actually, before reading your patch, I thought that you aim to *automatically* create a category of "associative algebras", given the category of algebras and the axiom "associative".

Hence, I think it should be

```
                  algebras
                /        \
 associative algebras   unital algebras
               \          /
        associative unital algebras
```
and similar for commutative algebras, commutative associative algebras, commutative associative unital algebras, and so on.



---

archive/issue_comments_108772.json:
```json
{
    "body": "<a id='comment:26'></a>\nReplying to [SimonKing](#comment%3A25):\n> Yes. A not necessarily unital not necessarily associative not\n> necessarily finite-dimensional not necessarily noetherian not\n> necessarily ... is commonly known as an **algebra**.\n\nYup, and that's indeed what Wikipedia says which is a good\npoint. However in many textbooks and other pieces of literature\n\"algebra\" implicitly includes \"associative\" and \"unital\" (for the same\nreason that it will be heavy for us to write almost everywhere\nAlgebras().Associative().Unital()).\n\nMore importantly: changing the semantic current \"Algebras\" in Sage\nwould be seriously backward incompatible. And we would have to think\nabout what we want to do about categories like \"HopfAlgebras\" to keep\nthings consistent.\n\nSo I definitely see your point but at this point I am not keen on\nopening yet another can of worms (both technical and social) to this\nalready too big patch.\n\n> Actually, before reading your patch, I thought that you aim to\n> *automatically* create a category of \"associative algebras\",\n> given the category of algebras and the axiom \"associative\".\n\nUp to the names, that's precisely what's its doing :-)\n\n> Hence, I think it should be\n\n\n```\n                  algebras\n                /        \\\n associative algebras   unital algebras\n               \\          /\n        associative unital algebras\n```\n\nWhat about, at least as a temporary measure, going for:\n\n```\n                      magmatic algebras\n                /                           \\\n associative magmatic algebras   unital magmatic algebras\n                \\                           /\n                           algebras\n```\n\n(or any other not-yet-used name you like instead of \"magmatic\nalgebra\")\n\nCheers,\n                               Nicolas",
    "created_at": "2013-07-02T16:25:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108772",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:26'></a>
Replying to [SimonKing](#comment%3A25):
> Yes. A not necessarily unital not necessarily associative not
> necessarily finite-dimensional not necessarily noetherian not
> necessarily ... is commonly known as an **algebra**.

Yup, and that's indeed what Wikipedia says which is a good
point. However in many textbooks and other pieces of literature
"algebra" implicitly includes "associative" and "unital" (for the same
reason that it will be heavy for us to write almost everywhere
Algebras().Associative().Unital()).

More importantly: changing the semantic current "Algebras" in Sage
would be seriously backward incompatible. And we would have to think
about what we want to do about categories like "HopfAlgebras" to keep
things consistent.

So I definitely see your point but at this point I am not keen on
opening yet another can of worms (both technical and social) to this
already too big patch.

> Actually, before reading your patch, I thought that you aim to
> *automatically* create a category of "associative algebras",
> given the category of algebras and the axiom "associative".

Up to the names, that's precisely what's its doing :-)

> Hence, I think it should be


```
                  algebras
                /        \
 associative algebras   unital algebras
               \          /
        associative unital algebras
```

What about, at least as a temporary measure, going for:

```
                      magmatic algebras
                /                           \
 associative magmatic algebras   unital magmatic algebras
                \                           /
                           algebras
```

(or any other not-yet-used name you like instead of "magmatic
algebra")

Cheers,
                               Nicolas



---

archive/issue_comments_108773.json:
```json
{
    "body": "<a id='comment:27'></a>\nReplying to [nthiery](#comment%3A26):\n> However in many textbooks and other pieces of literature\n> \"algebra\" implicitly includes \"associative\" and \"unital\"\n\nCertainly there also exist textbooks that will for simplicity say \"algebra\" when they in fact mean \"commutative algebra\". But I would expect that all these textbooks state at some point the definition of (plain) algebras and later say that \"for simplicity\" or \"unless stated otherwise\" they assume whatever additional axioms.\n\nAnd even \"better\": There were times when a certain algebraic community would only talk about *finite* groups. I recently heard colleagues talk about these times. It was like \"they provided generators and relations and then needed to prove that it is a group\", which in today's language is \"they provided a group presentation and needed to prove that the group is finite\".\n\nYou see: There *are* certain conventions peculiar to certain fields of research.\n\nBut I think a general computer algebra system should not be biased towards any of these peculiar conventions. Hence, it should use the \"greatest common divisor\" of the notions, which is: An R-algebra is a an R-module and a multiplicative magma, such that multiplication is R-bilinear.\n\n> (for the same\n> reason that it will be heavy for us to write almost everywhere\n> Algebras().Associative().Unital()).\n\nWe can certainly have a short-cut for defining this thing.\n\n> More importantly: changing the semantic current \"Algebras\" in Sage\n> would be seriously backward incompatible.\n\nBackward compatibility is indeed important. It would be difficult to switch from Algebras in the current Sage-use to Algebras in the (I think) normal mathematical use.\n\nHowever, I *do* think that to the very very least we should let `Algebras()` print as \"Category of unital associative algebras\".\n\n> And we would have to think\n> about what we want to do about categories like \"HopfAlgebras\" to keep\n> things consistent.\n\nWikipedia does not assume associativity for algebras, but it does assume co-associativity for co-algebras. Weird.\n\n> So I definitely see your point but at this point I am not keen on\n> opening yet another can of worms (both technical and social) to this\n> already too big patch.\n\nConcerning social: I vividly remember many talks in the s\u00e9minaire quantique in Strasbourg, entitled along the lines of \"quasi-commutative quasi-cocommutative quasi-Hopf algebras\". I think *these* guys would be unhappy about tacitly assuming too many axioms for algebras. And I just checked: There also is the notion of quasi-associative algebras in literature...\n\n> What about, at least as a temporary measure, going for:\n> \n> ```\n>                       magmatic algebras\n>                 /                           \\\n>  associative magmatic algebras   unital magmatic algebras\n>                 \\                           /\n>                            algebras\n> ```\n> \n> (or any other not-yet-used name you like instead of \"magmatic\n> algebra\")\n\nI have never heard about \"magmatic algebras\" before. But I have no better idea (\"plain algebras\"?).\n\nSage-devel poll? Sage-algebra poll (although this list seems dead)? Sage-combinat-devel poll?",
    "created_at": "2013-07-02T21:00:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108773",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:27'></a>
Replying to [nthiery](#comment%3A26):
> However in many textbooks and other pieces of literature
> "algebra" implicitly includes "associative" and "unital"

Certainly there also exist textbooks that will for simplicity say "algebra" when they in fact mean "commutative algebra". But I would expect that all these textbooks state at some point the definition of (plain) algebras and later say that "for simplicity" or "unless stated otherwise" they assume whatever additional axioms.

And even "better": There were times when a certain algebraic community would only talk about *finite* groups. I recently heard colleagues talk about these times. It was like "they provided generators and relations and then needed to prove that it is a group", which in today's language is "they provided a group presentation and needed to prove that the group is finite".

You see: There *are* certain conventions peculiar to certain fields of research.

But I think a general computer algebra system should not be biased towards any of these peculiar conventions. Hence, it should use the "greatest common divisor" of the notions, which is: An R-algebra is a an R-module and a multiplicative magma, such that multiplication is R-bilinear.

> (for the same
> reason that it will be heavy for us to write almost everywhere
> Algebras().Associative().Unital()).

We can certainly have a short-cut for defining this thing.

> More importantly: changing the semantic current "Algebras" in Sage
> would be seriously backward incompatible.

Backward compatibility is indeed important. It would be difficult to switch from Algebras in the current Sage-use to Algebras in the (I think) normal mathematical use.

However, I *do* think that to the very very least we should let `Algebras()` print as "Category of unital associative algebras".

> And we would have to think
> about what we want to do about categories like "HopfAlgebras" to keep
> things consistent.

Wikipedia does not assume associativity for algebras, but it does assume co-associativity for co-algebras. Weird.

> So I definitely see your point but at this point I am not keen on
> opening yet another can of worms (both technical and social) to this
> already too big patch.

Concerning social: I vividly remember many talks in the séminaire quantique in Strasbourg, entitled along the lines of "quasi-commutative quasi-cocommutative quasi-Hopf algebras". I think *these* guys would be unhappy about tacitly assuming too many axioms for algebras. And I just checked: There also is the notion of quasi-associative algebras in literature...

> What about, at least as a temporary measure, going for:
> 
> ```
>                       magmatic algebras
>                 /                           \
>  associative magmatic algebras   unital magmatic algebras
>                 \                           /
>                            algebras
> ```
> 
> (or any other not-yet-used name you like instead of "magmatic
> algebra")

I have never heard about "magmatic algebras" before. But I have no better idea ("plain algebras"?).

Sage-devel poll? Sage-algebra poll (although this list seems dead)? Sage-combinat-devel poll?



---

archive/issue_comments_108774.json:
```json
{
    "body": "<a id='comment:28'></a>\nReplying to [SimonKing](#comment%3A27):\n> Sage-devel poll? Sage-algebra poll (although this list seems dead)? Sage-combinat-devel poll?\n\nI think a CC to all three is in order in this case. I'll try to launch\nthe poll tomorrow.\n\nThanks for your work on the review!",
    "created_at": "2013-07-02T21:10:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108774",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:28'></a>
Replying to [SimonKing](#comment%3A27):
> Sage-devel poll? Sage-algebra poll (although this list seems dead)? Sage-combinat-devel poll?

I think a CC to all three is in order in this case. I'll try to launch
the poll tomorrow.

Thanks for your work on the review!



---

archive/issue_comments_108775.json:
```json
{
    "body": "**Changing work issues** from \"Rebase wrt. #13589\" to \"Finish merging some changes in the primer\".",
    "created_at": "2013-07-12T21:44:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108775",
    "user": "https://github.com/nthiery"
}
```

**Changing work issues** from "Rebase wrt. #13589" to "Finish merging some changes in the primer".



---

archive/issue_comments_108776.json:
```json
{
    "body": "<a id='comment:29'></a>\nPatch rebased on top of #13589",
    "created_at": "2013-07-12T21:44:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108776",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:29'></a>
Patch rebased on top of #13589



---

archive/issue_comments_108777.json:
```json
{
    "body": "<a id='comment:30'></a>\nThe patch applies with fuzz, but it does apply.",
    "created_at": "2013-07-15T11:13:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108777",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:30'></a>
The patch applies with fuzz, but it does apply.



---

archive/issue_comments_108778.json:
```json
{
    "body": "<a id='comment:31'></a>\nWhy is there a double-underscore `__neg__` method as element method of additive groups? The reason for the single underscore arithmetic methods is, to my understanding, to enable the coercion model. But the coercion model is not involved in the case of `__neg__`, isn't it? Hence, I think one should keep it double underscore, and should not ask for an implementation via a single underscore method.",
    "created_at": "2013-07-15T11:22:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108778",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:31'></a>
Why is there a double-underscore `__neg__` method as element method of additive groups? The reason for the single underscore arithmetic methods is, to my understanding, to enable the coercion model. But the coercion model is not involved in the case of `__neg__`, isn't it? Hence, I think one should keep it double underscore, and should not ask for an implementation via a single underscore method.



---

archive/issue_comments_108779.json:
```json
{
    "body": "<a id='comment:32'></a>\nMental note: A lot of things happen when joining categories. I recall that in some examples forming the join of categories was the reason for slowness in algebraic constructions. Hence, we should have a look at the speed.",
    "created_at": "2013-07-15T11:32:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108779",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:32'></a>
Mental note: A lot of things happen when joining categories. I recall that in some examples forming the join of categories was the reason for slowness in algebraic constructions. Hence, we should have a look at the speed.



---

archive/issue_comments_108780.json:
```json
{
    "body": "<a id='comment:33'></a>\nI see that you define a method `_cmp_key(self)` for join categories, that just tells that one shouldn't call it on join categories. That's bad, because meanwhile _cmp_key is a lazy attribute (or an optimized version of a lazy attribute), hence, it is no method anyway. Can we remove this method?",
    "created_at": "2013-07-15T11:35:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108780",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:33'></a>
I see that you define a method `_cmp_key(self)` for join categories, that just tells that one shouldn't call it on join categories. That's bad, because meanwhile _cmp_key is a lazy attribute (or an optimized version of a lazy attribute), hence, it is no method anyway. Can we remove this method?



---

archive/issue_comments_108781.json:
```json
{
    "body": "<a id='comment:34'></a>\nYou ask:\n\n```\n# TODO: find a better way to check that cls is an abstract class \n```\nWhat about a class attribute? Something like\n\n```\n\"abstract\" in cls.__base__.__dict__\n```\nOr is it generally not the case that `cls.__base__` coincides with `cls.__mro__[1]`?",
    "created_at": "2013-07-15T11:44:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108781",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:34'></a>
You ask:

```
# TODO: find a better way to check that cls is an abstract class 
```
What about a class attribute? Something like

```
"abstract" in cls.__base__.__dict__
```
Or is it generally not the case that `cls.__base__` coincides with `cls.__mro__[1]`?



---

archive/issue_comments_108782.json:
```json
{
    "body": "<a id='comment:35'></a>\nmake ptest resulted in\n\n```\nsage -t devel/sage/sage/geometry/polyhedron/plot.py  # 1 doctest failed\nsage -t devel/sage/sage/categories/category.py  # 3 doctests failed\nsage -t devel/sage/sage/quivers/free_small_category.py  # 2 doctests failed\nsage -t devel/sage/sage/categories/category_with_axiom.py  # 1 doctest failed\n```",
    "created_at": "2013-07-15T13:36:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108782",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:35'></a>
make ptest resulted in

```
sage -t devel/sage/sage/geometry/polyhedron/plot.py  # 1 doctest failed
sage -t devel/sage/sage/categories/category.py  # 3 doctests failed
sage -t devel/sage/sage/quivers/free_small_category.py  # 2 doctests failed
sage -t devel/sage/sage/categories/category_with_axiom.py  # 1 doctest failed
```



---

archive/issue_comments_108783.json:
```json
{
    "body": "<a id='comment:36'></a>\nI don't see why the patchbot had trouble applying the patch. Let's kick it:\n\nApply trac_10963-more_functorial_constructions-nt.patch",
    "created_at": "2013-07-15T13:37:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108783",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:36'></a>
I don't see why the patchbot had trouble applying the patch. Let's kick it:

Apply trac_10963-more_functorial_constructions-nt.patch



---

archive/issue_comments_108784.json:
```json
{
    "body": "<a id='comment:37'></a>\nReplying to [SimonKing](#comment%3A35):\n> make ptest resulted in\n> \n> ```\n> sage -t devel/sage/sage/geometry/polyhedron/plot.py  # 1 doctest failed\n> sage -t devel/sage/sage/categories/category.py  # 3 doctests failed\n> sage -t devel/sage/sage/quivers/free_small_category.py  # 2 doctests failed\n> sage -t devel/sage/sage/categories/category_with_axiom.py  # 1 doctest failed\n> ```\n\nYes, as you can see, I have #12630 applied as well. But this only introduces new modules, but does not interfere with old modules. Hence, I don't think the errors come from this.",
    "created_at": "2013-07-15T13:42:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108784",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:37'></a>
Replying to [SimonKing](#comment%3A35):
> make ptest resulted in
> 
> ```
> sage -t devel/sage/sage/geometry/polyhedron/plot.py  # 1 doctest failed
> sage -t devel/sage/sage/categories/category.py  # 3 doctests failed
> sage -t devel/sage/sage/quivers/free_small_category.py  # 2 doctests failed
> sage -t devel/sage/sage/categories/category_with_axiom.py  # 1 doctest failed
> ```

Yes, as you can see, I have #12630 applied as well. But this only introduces new modules, but does not interfere with old modules. Hence, I don't think the errors come from this.



---

archive/issue_comments_108785.json:
```json
{
    "body": "<a id='comment:38'></a>\nHere are the failures in detail:\nThe first is noise:\n\n```\nsage -t devel/sage/sage/geometry/polyhedron/plot.py\n    [178 tests, 5.55 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 5.8 seconds\n    cpu time: 4.3 seconds\n    cumulative wall time: 5.6 seconds\n```\n\nThe second:\n\n```\nsage -t devel/sage/sage/categories/category.py\n**********************************************************************\nFile \"devel/sage/sage/categories/category.py\", line 1940, in sage.categories.category.Category.join\nFailed example:\n    type(TCF)\nExpected:\n    <class 'sage.categories.category_with_axiom.TestObjects.Commutative.Facade_with_category'>\nGot:\n    <class 'sage.categories.category_with_axiom.Commutative.Facade_with_category'>\n**********************************************************************\nFile \"devel/sage/sage/categories/category.py\", line 1950, in sage.categories.category.Category.join\nFailed example:\n    type(TCF)\nExpected:\n    <class 'sage.categories.category_with_axiom.TestObjects.Commutative.FiniteDimensional_with_category'>\nGot:\n    <class 'sage.categories.category_with_axiom.Commutative.FiniteDimensional_with_category'>\n**********************************************************************\nFile \"devel/sage/sage/categories/category.py\", line 1963, in sage.categories.category.Category.join\nFailed example:\n    type(TUCF)\nExpected:\n    <class 'sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Unital.Commutative_with_category'>\nGot:\n    <class 'sage.categories.category_with_axiom.Unital.Commutative_with_category'>\n**********************************************************************\n1 item had failures:\n   3 of  47 in sage.categories.category.Category.join\n    [388 tests, 3 failures, 6.89 s]\n----------------------------------------------------------------------\nsage -t devel/sage/sage/categories/category.py  # 3 doctests failed\n----------------------------------------------------------------------\nTotal time for all tests: 7.3 seconds\n    cpu time: 6.8 seconds\n    cumulative wall time: 6.9 seconds\n```\n\nThe third needs to be taken care of only if #12630 finally gets a review.\n\nThe last one:\n\n```\nsage -t devel/sage/sage/categories/category_with_axiom.py\n**********************************************************************\nFile \"devel/sage/sage/categories/category_with_axiom.py\", line 755, in sage.categories.category_with_axiom.CategoryWithAxiom.__reduce__\nFailed example:\n    C.__class__\nExpected:\n    <class 'sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative_with_category'>\nGot:\n    <class 'sage.categories.distributive_magmas_and_additive_magmas.AdditiveAssociative.AdditiveCommutative_with_category'>\n**********************************************************************\n1 item had failures:\n   1 of   8 in sage.categories.category_with_axiom.CategoryWithAxiom.__reduce__\n    [179 tests, 1 failure, 0.25 s]\n```\n\nSo, nothing dramatic.",
    "created_at": "2013-07-15T13:54:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108785",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:38'></a>
Here are the failures in detail:
The first is noise:

```
sage -t devel/sage/sage/geometry/polyhedron/plot.py
    [178 tests, 5.55 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 5.8 seconds
    cpu time: 4.3 seconds
    cumulative wall time: 5.6 seconds
```

The second:

```
sage -t devel/sage/sage/categories/category.py
**********************************************************************
File "devel/sage/sage/categories/category.py", line 1940, in sage.categories.category.Category.join
Failed example:
    type(TCF)
Expected:
    <class 'sage.categories.category_with_axiom.TestObjects.Commutative.Facade_with_category'>
Got:
    <class 'sage.categories.category_with_axiom.Commutative.Facade_with_category'>
**********************************************************************
File "devel/sage/sage/categories/category.py", line 1950, in sage.categories.category.Category.join
Failed example:
    type(TCF)
Expected:
    <class 'sage.categories.category_with_axiom.TestObjects.Commutative.FiniteDimensional_with_category'>
Got:
    <class 'sage.categories.category_with_axiom.Commutative.FiniteDimensional_with_category'>
**********************************************************************
File "devel/sage/sage/categories/category.py", line 1963, in sage.categories.category.Category.join
Failed example:
    type(TUCF)
Expected:
    <class 'sage.categories.category_with_axiom.TestObjects.FiniteDimensional.Unital.Commutative_with_category'>
Got:
    <class 'sage.categories.category_with_axiom.Unital.Commutative_with_category'>
**********************************************************************
1 item had failures:
   3 of  47 in sage.categories.category.Category.join
    [388 tests, 3 failures, 6.89 s]
----------------------------------------------------------------------
sage -t devel/sage/sage/categories/category.py  # 3 doctests failed
----------------------------------------------------------------------
Total time for all tests: 7.3 seconds
    cpu time: 6.8 seconds
    cumulative wall time: 6.9 seconds
```

The third needs to be taken care of only if #12630 finally gets a review.

The last one:

```
sage -t devel/sage/sage/categories/category_with_axiom.py
**********************************************************************
File "devel/sage/sage/categories/category_with_axiom.py", line 755, in sage.categories.category_with_axiom.CategoryWithAxiom.__reduce__
Failed example:
    C.__class__
Expected:
    <class 'sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative_with_category'>
Got:
    <class 'sage.categories.distributive_magmas_and_additive_magmas.AdditiveAssociative.AdditiveCommutative_with_category'>
**********************************************************************
1 item had failures:
   1 of   8 in sage.categories.category_with_axiom.CategoryWithAxiom.__reduce__
    [179 tests, 1 failure, 0.25 s]
```

So, nothing dramatic.



---

archive/issue_comments_108786.json:
```json
{
    "body": "**Changing work issues** from \"Finish merging some changes in the primer\" to \"Reduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\". Trivial doctest fixes.\".",
    "created_at": "2013-07-15T16:52:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108786",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "Finish merging some changes in the primer" to "Reduce startup time by 5%. Avoid "recursion depth exceeded (ignored)". Trivial doctest fixes.".



---

archive/issue_comments_108787.json:
```json
{
    "body": "<a id='comment:39'></a>\nPatchbot finds\n\n```\nsage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/rings/number_field/number_field.py  # 1 doctest failed\nsage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/doc/ru/tutorial/tour_groups.rst  # 1 doctest failed\nsage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/geometry/polyhedron/plot.py  # 1 doctest failed\nsage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/categories/category.py  # 3 doctests failed\nsage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/categories/category_with_axiom.py  # 1 doctest failed\n```\n\nThis sounds serious:\n\n```\nsage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/rings/number_field/number_field.py\n**********************************************************************\nFile \"/mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/rings/number_field/number_field.py\", line 309, in sage.rings.number_field.number_field.?\nFailed example:\n    RR.coerce_map_from(K)\nExpected:\n    Composite map:\n      From: Number Field in a with defining polynomial x^3 - 2\n      To:   Real Field with 53 bits of precision\n      Defn:   Generic morphism:\n              From: Number Field in a with defining polynomial x^3 - 2\n              To:   Real Lazy Field\n              Defn: a -> 1.259921049894873?\n            then\n              Conversion via _mpfr_ method map:\n              From: Real Lazy Field\n              To:   Real Field with 53 bits of precision\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x2820668> ignored\n    Composite map:\n      From: Number Field in a with defining polynomial x^3 - 2\n      To:   Real Field with 53 bits of precision\n      Defn:   Generic morphism:\n              From: Number Field in a with defining polynomial x^3 - 2\n              To:   Real Lazy Field\n              Defn: a -> 1.259921049894873?\n            then\n              Conversion via _mpfr_ method map:\n              From: Real Lazy Field\n              To:   Real Field with 53 bits of precision\n```\n\n```\nFile \"/mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/doc/ru/tutorial/tour_groups.rst\", line 14, in doc.ru.tutorial.tour_groups\nFailed example:\n    G = PermutationGroup(['(1,2,3)(4,5)', '(3,4)'])\nExpected nothing\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0xfe16e0> ignored\n```\n\n```\nFile \"/mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/geometry/polyhedron/plot.py\", line 461, in sage.geometry.polyhedron.plot.Projection.__init__\nFailed example:\n    p = polytopes.icosahedron()\nExpected nothing\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded while getting the str of an object' in <function remove at 0x2e03e60> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while getting the str of an object' in <function remove at 0x2e03e60> ignored\n```\n\nAnd the result of the startup time plugin is also a bad news.\n\n```\n+Average increase of 0.057 secs or 8.1%.\n\n+With 100% confidence, startup time increased by at least 5%\n+With 100% confidence, startup time increased by at least 2.5%\n+With 100% confidence, startup time increased by at least 1%\n+With 100% confidence, startup time increased by at least 0.5%\n+With 100% confidence, startup time increased by at least 0.25%\n```",
    "created_at": "2013-07-15T16:52:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108787",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:39'></a>
Patchbot finds

```
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/rings/number_field/number_field.py  # 1 doctest failed
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/doc/ru/tutorial/tour_groups.rst  # 1 doctest failed
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/geometry/polyhedron/plot.py  # 1 doctest failed
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/categories/category.py  # 3 doctests failed
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/categories/category_with_axiom.py  # 1 doctest failed
```

This sounds serious:

```
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/rings/number_field/number_field.py
**********************************************************************
File "/mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/rings/number_field/number_field.py", line 309, in sage.rings.number_field.number_field.?
Failed example:
    RR.coerce_map_from(K)
Expected:
    Composite map:
      From: Number Field in a with defining polynomial x^3 - 2
      To:   Real Field with 53 bits of precision
      Defn:   Generic morphism:
              From: Number Field in a with defining polynomial x^3 - 2
              To:   Real Lazy Field
              Defn: a -> 1.259921049894873?
            then
              Conversion via _mpfr_ method map:
              From: Real Lazy Field
              To:   Real Field with 53 bits of precision
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x2820668> ignored
    Composite map:
      From: Number Field in a with defining polynomial x^3 - 2
      To:   Real Field with 53 bits of precision
      Defn:   Generic morphism:
              From: Number Field in a with defining polynomial x^3 - 2
              To:   Real Lazy Field
              Defn: a -> 1.259921049894873?
            then
              Conversion via _mpfr_ method map:
              From: Real Lazy Field
              To:   Real Field with 53 bits of precision
```

```
File "/mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/doc/ru/tutorial/tour_groups.rst", line 14, in doc.ru.tutorial.tour_groups
Failed example:
    G = PermutationGroup(['(1,2,3)(4,5)', '(3,4)'])
Expected nothing
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0xfe16e0> ignored
```

```
File "/mnt/storage2TB/patchbot/Sage/sage-5.11.beta3/devel/sage/sage/geometry/polyhedron/plot.py", line 461, in sage.geometry.polyhedron.plot.Projection.__init__
Failed example:
    p = polytopes.icosahedron()
Expected nothing
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded while getting the str of an object' in <function remove at 0x2e03e60> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while getting the str of an object' in <function remove at 0x2e03e60> ignored
```

And the result of the startup time plugin is also a bad news.

```
+Average increase of 0.057 secs or 8.1%.

+With 100% confidence, startup time increased by at least 5%
+With 100% confidence, startup time increased by at least 2.5%
+With 100% confidence, startup time increased by at least 1%
+With 100% confidence, startup time increased by at least 0.5%
+With 100% confidence, startup time increased by at least 0.25%
```



---

archive/issue_events_085457.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-07-15T16:52:41Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85457"
}
```



---

archive/issue_events_085458.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-07-15T16:52:41Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85458"
}
```



---

archive/issue_comments_108788.json:
```json
{
    "body": "<a id='comment:40'></a>\nThere is a naked\n\n```\nassert False \n```\nin `sage.categories.category.Category.__init__`, followed(!) by a deprecation warning. How can the warning ever appear after asserting a false statement?",
    "created_at": "2013-07-15T19:40:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108788",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:40'></a>
There is a naked

```
assert False 
```
in `sage.categories.category.Category.__init__`, followed(!) by a deprecation warning. How can the warning ever appear after asserting a false statement?



---

archive/issue_comments_108789.json:
```json
{
    "body": "<a id='comment:41'></a>\nI have a question on how to implement a new category with support of axioms.\n\nIf I understand correctly, the method `_with_axiom_categories` tells which categories need to be added to self in order to get the category with the axiom added. Is one supposed to overload this method? Sorry, I did not read your patch completely yet. Is this question answered somewhere? If not, I think it must be added to a tutorial.",
    "created_at": "2013-07-15T19:51:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108789",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:41'></a>
I have a question on how to implement a new category with support of axioms.

If I understand correctly, the method `_with_axiom_categories` tells which categories need to be added to self in order to get the category with the axiom added. Is one supposed to overload this method? Sorry, I did not read your patch completely yet. Is this question answered somewhere? If not, I think it must be added to a tutorial.



---

archive/issue_comments_108790.json:
```json
{
    "body": "<a id='comment:42'></a>\nHere is some cryptic phrase from category_with_axiom:\n\n```\nThe later two are implemented using respectively \n:meth:`__classcall__` and :meth:`__classget__` which see. \n```\nIt ends in the middle of the phrase.",
    "created_at": "2013-07-15T19:57:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108790",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:42'></a>
Here is some cryptic phrase from category_with_axiom:

```
The later two are implemented using respectively 
:meth:`__classcall__` and :meth:`__classget__` which see. 
```
It ends in the middle of the phrase.



---

archive/issue_comments_108791.json:
```json
{
    "body": "<a id='comment:43'></a>\nI try to summarize how I understand how the patch works---so, please correct me if I misunderstood.\n\nGenerally, adding an axiom A to a category C means: Forming the join of C with `C._with_axiom_categories(A)`, unless there is a class `getattr(C,A)`, for example: `Magmas().Associative` is `Semigroups`. The categories returned by `C._with_axiom_categories(A)` would, for example, provide new parent and element methods (such as: `prod()` only makes sense in an associative magma, `_test_one()` only makes sense for unital magmas).\n\nIf I understand correctly, the same \"axiom category\" (here: `Magmas.Associative`) is available to all subcategories of `Magmas()`, because it is defined in `Magmas.SubcategoryMethods`. Or am I mistaken and it is *not* the same? Is another dynamic class involved here? This could also give rise to slowness.\n\nApart from hard-coded cases, the r\u00f4le of `JoinCategory` has generally increased, and this indicates it might make sense to spend some optimization there. A highly significant increase of at least 5% of startup time is rather much. I don't know if `JoinCategory` is the only problem here.",
    "created_at": "2013-07-16T11:19:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108791",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:43'></a>
I try to summarize how I understand how the patch works---so, please correct me if I misunderstood.

Generally, adding an axiom A to a category C means: Forming the join of C with `C._with_axiom_categories(A)`, unless there is a class `getattr(C,A)`, for example: `Magmas().Associative` is `Semigroups`. The categories returned by `C._with_axiom_categories(A)` would, for example, provide new parent and element methods (such as: `prod()` only makes sense in an associative magma, `_test_one()` only makes sense for unital magmas).

If I understand correctly, the same "axiom category" (here: `Magmas.Associative`) is available to all subcategories of `Magmas()`, because it is defined in `Magmas.SubcategoryMethods`. Or am I mistaken and it is *not* the same? Is another dynamic class involved here? This could also give rise to slowness.

Apart from hard-coded cases, the rôle of `JoinCategory` has generally increased, and this indicates it might make sense to spend some optimization there. A highly significant increase of at least 5% of startup time is rather much. I don't know if `JoinCategory` is the only problem here.



---

archive/issue_comments_108792.json:
```json
{
    "body": "<a id='comment:44'></a>\nIf I understand correctly, the reason for creating a `JoinCategory` is to get the correct supercategories. But there are alternative ways to get the supercategories right. I could imagine to use a dynamic class instead. So, the aim of this post is to present an alternative approach that avoids joins.\n\nIf C is a category and one wants to have `C.MyAxiom()`, then I suggest to create a dynamic class `cls` out of `C.__class__` (and perhaps also using the class `C.MyAxiom`?), and set a *class* attribute `cls._used_axioms` which is a (frozen) set formed by `C.__class__._used_axioms` and `\"MyAxiom\"`.\n\nNote: The order in which the axioms are given should not matter. Hence, the way of caching the dynamic class should be: By a class that has no axioms, and by `C.__class__._used_axioms`.\n\nWe would like to call `cls` with the same `__init__` arguments that were used for creating `C`. So, how to get the init data? No problem, since `C` uses `UniqueRepresentation`!. For example:\n\n```\nsage: C = Bimodules(ZZ, QQ)\nsage: C._reduction\n(sage.categories.bimodules.Bimodules, (Integer Ring, Rational Field), {})\n```\n\nSo, `C.MyAxiom()` would eventually do something like this\n\n```\n   cls = dynamic_class(\"MyAxiom\"+C.__class__.__name__, (C.__class__, C.MyAxiom), C.__class__, <take care of caching>)\n   return cls(*(C._reduction[1][0]), **(C._reduction[1][1]))\n```\n\nNote that by way of caching the dynamic class, I guess the above would automatically cover the corner case that `C.__class__._used_axioms` contains `\"MyAxiom\"`. Namely, in this case, `cls is C.__class__` by means of caching the dynamic class, and then `cls(*..., **...)` coincides with C, since it is a `UniqueRepresentation`.\n\nBy means of explicitly overloading the cache of the dynamic class, one could even ensure that `DivisionRings.Finite()` returns `Fields.Finite()`, I guess.\n\nLet's denote `C2=C.MyAxiom()`. And then, the critical question is: How to determine the super categories of `C2`?\n\nI guess for each axiom `A in C2.__class__._used_axioms`, we want to return `C2._without_axiom(A)`, and we want to return `D._with_axiom(A)` for all `D` is in `C2._without_axiom(A).super_categories()`, of course removing duplicates.\n\nSo, there only remains to answer: What is `C2._without_axiom(A)`?\n\nAgain, we can use `C2._reduction` to get the input data, but how to get the class of `D=C2._without_axiom(A)`? Note that `C2` might have several axioms, and we do *not* order the axioms.\n\nHowever, we know what `D.__class__._used_axioms` is supposed to look like: It is `C2.__class__._used_axiom.difference(\"MyAxiom\")`.\n\nThus, we get something like this:\n\n```\n@cached_method\ndef _without_axiom(self, axiom):\n    if axiom not in self.__class__._used_axioms:\n        <raise some error>\n    new_axioms = self.__class__._used_axioms.difference([axiom])\n    for cls in self.__class__.__mro__:\n        if getattr(cls, \"_used_axioms\", None) == new_axioms:\n            break\n    if cls is object:\n        <raise some error>\n    return cls(*(self._reduction[1][0]), **(self._reduction[1][1]))\n```\n\nDo you think this would make sense?",
    "created_at": "2013-07-16T12:22:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108792",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:44'></a>
If I understand correctly, the reason for creating a `JoinCategory` is to get the correct supercategories. But there are alternative ways to get the supercategories right. I could imagine to use a dynamic class instead. So, the aim of this post is to present an alternative approach that avoids joins.

If C is a category and one wants to have `C.MyAxiom()`, then I suggest to create a dynamic class `cls` out of `C.__class__` (and perhaps also using the class `C.MyAxiom`?), and set a *class* attribute `cls._used_axioms` which is a (frozen) set formed by `C.__class__._used_axioms` and `"MyAxiom"`.

Note: The order in which the axioms are given should not matter. Hence, the way of caching the dynamic class should be: By a class that has no axioms, and by `C.__class__._used_axioms`.

We would like to call `cls` with the same `__init__` arguments that were used for creating `C`. So, how to get the init data? No problem, since `C` uses `UniqueRepresentation`!. For example:

```
sage: C = Bimodules(ZZ, QQ)
sage: C._reduction
(sage.categories.bimodules.Bimodules, (Integer Ring, Rational Field), {})
```

So, `C.MyAxiom()` would eventually do something like this

```
   cls = dynamic_class("MyAxiom"+C.__class__.__name__, (C.__class__, C.MyAxiom), C.__class__, <take care of caching>)
   return cls(*(C._reduction[1][0]), **(C._reduction[1][1]))
```

Note that by way of caching the dynamic class, I guess the above would automatically cover the corner case that `C.__class__._used_axioms` contains `"MyAxiom"`. Namely, in this case, `cls is C.__class__` by means of caching the dynamic class, and then `cls(*..., **...)` coincides with C, since it is a `UniqueRepresentation`.

By means of explicitly overloading the cache of the dynamic class, one could even ensure that `DivisionRings.Finite()` returns `Fields.Finite()`, I guess.

Let's denote `C2=C.MyAxiom()`. And then, the critical question is: How to determine the super categories of `C2`?

I guess for each axiom `A in C2.__class__._used_axioms`, we want to return `C2._without_axiom(A)`, and we want to return `D._with_axiom(A)` for all `D` is in `C2._without_axiom(A).super_categories()`, of course removing duplicates.

So, there only remains to answer: What is `C2._without_axiom(A)`?

Again, we can use `C2._reduction` to get the input data, but how to get the class of `D=C2._without_axiom(A)`? Note that `C2` might have several axioms, and we do *not* order the axioms.

However, we know what `D.__class__._used_axioms` is supposed to look like: It is `C2.__class__._used_axiom.difference("MyAxiom")`.

Thus, we get something like this:

```
@cached_method
def _without_axiom(self, axiom):
    if axiom not in self.__class__._used_axioms:
        <raise some error>
    new_axioms = self.__class__._used_axioms.difference([axiom])
    for cls in self.__class__.__mro__:
        if getattr(cls, "_used_axioms", None) == new_axioms:
            break
    if cls is object:
        <raise some error>
    return cls(*(self._reduction[1][0]), **(self._reduction[1][1]))
```

Do you think this would make sense?



---

archive/issue_comments_108793.json:
```json
{
    "body": "<a id='comment:45'></a>\nReplying to [SimonKing](#comment%3A38):\n> \n> ```\n> sage -t devel/sage/sage/categories/category.py\n> **********************************************************************\n> File \"devel/sage/sage/categories/category.py\", line 1940, in sage.categories.category.Category.join\n> Failed example:\n>     type(TCF)\n> Expected:\n>     <class 'sage.categories.category_with_axiom.TestObjects.Commutative.Facade_with_category'>\n> Got:\n>     <class 'sage.categories.category_with_axiom.Commutative.Facade_with_category'>\n> ```\n\nAh yes, good point: I have #9107 in my queue. So we will have to\neither add it as a dependency if it gets ready soon, or update the\ndoctests. As you point out, nothing dramatic.",
    "created_at": "2013-07-16T13:58:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108793",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:45'></a>
Replying to [SimonKing](#comment%3A38):
> 
> ```
> sage -t devel/sage/sage/categories/category.py
> **********************************************************************
> File "devel/sage/sage/categories/category.py", line 1940, in sage.categories.category.Category.join
> Failed example:
>     type(TCF)
> Expected:
>     <class 'sage.categories.category_with_axiom.TestObjects.Commutative.Facade_with_category'>
> Got:
>     <class 'sage.categories.category_with_axiom.Commutative.Facade_with_category'>
> ```

Ah yes, good point: I have #9107 in my queue. So we will have to
either add it as a dependency if it gets ready soon, or update the
doctests. As you point out, nothing dramatic.



---

archive/issue_comments_108794.json:
```json
{
    "body": "<a id='comment:46'></a>\nReplying to [SimonKing](#comment%3A31):\n> Why is there a double-underscore `__neg__` method as element method of additive groups? The reason for the single underscore arithmetic methods is, to my understanding, to enable the coercion model. But the coercion model is not involved in the case of `__neg__`, isn't it? Hence, I think one should keep it double underscore, and should not ask for an implementation via a single underscore method.\n\n\nAll I did is to lift this method from \"sage.structure.element.ModuleElement\", as a step toward deprecating this class.\n\nI agree that the `_neg_` feature itself is questionable (it has no purpose besides consistency). So one could think about removing it (and fixing the couple modules in Sage that implement `_neg_`). But that would require a discussion on sage-devel and is in any cases for a different ticket.\n\nFor this ticket, do you think I should add a little comment about this in the doc?",
    "created_at": "2013-07-16T21:24:58Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108794",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:46'></a>
Replying to [SimonKing](#comment%3A31):
> Why is there a double-underscore `__neg__` method as element method of additive groups? The reason for the single underscore arithmetic methods is, to my understanding, to enable the coercion model. But the coercion model is not involved in the case of `__neg__`, isn't it? Hence, I think one should keep it double underscore, and should not ask for an implementation via a single underscore method.


All I did is to lift this method from "sage.structure.element.ModuleElement", as a step toward deprecating this class.

I agree that the `_neg_` feature itself is questionable (it has no purpose besides consistency). So one could think about removing it (and fixing the couple modules in Sage that implement `_neg_`). But that would require a discussion on sage-devel and is in any cases for a different ticket.

For this ticket, do you think I should add a little comment about this in the doc?



---

archive/issue_comments_108795.json:
```json
{
    "body": "<a id='comment:47'></a>\nHi Simon!\n\nThanks for all your work on the review of this ticket! I am currently\non vacations, so my answers might be slow.\n\nReplying to [SimonKing](#comment%3A44):\n> If I understand correctly, the reason for creating a `JoinCategory`\n> is to get the correct supercategories.\n\nThe reason to call \"join\" is indeed to get the correct supercategories\nfor `C.MyAxiom()`. Note that, on the other hand and unless I\nscrewed up somewhere, there should be no `JoinCategory` produced\n(unless of course the end result of `C.MyAxiom()` itself is such a\n`JoinCategory`).\n\n> But there are alternative ways to get the supercategories right. I\n> could imagine to use a dynamic class instead. So, the aim of this\n> post is to present an alternative approach that avoids joins.\n\nIn general, I agree that joins are called quite often and it would be\nnice to optimize them and/or call them less often. However, I think we\nreally want to call a join to get the full power of the\narchitecture. Imagine for example that:\n\n- C is a super category of A and B\n- `A.MyAxiom()` implies `A.MyOtherAxiom()`\n- `B.MyOtherAxiom()` is non trivial\n\nThen we want `C.MyAxiom().super_categories()` to automatically\ninclude `B.MyOtherAxiom()`, for otherwise we would need to\nbasically replicate the information that `A.MyAxiom()` implies\n`A.MyOtherAxiom()` over and over in subcategories, and this would\nnot scale.\n\nHandling this kind of stuff is precisely the core of the logic in\n``join``. So if you see a way to optimize the computation of the super\ncategories of `C.MyAxiom()` while preserving the above feature,\nthen I believe you actually have found a way to optimize ``join`` in\nthe first place.\n\nCheers,\n                                       Nicolas\n\nPS: let's keep in mind this idea of using the reduction. It could indeed be that it could be used in a place or two to simplify the logic.",
    "created_at": "2013-07-16T21:56:48Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108795",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:47'></a>
Hi Simon!

Thanks for all your work on the review of this ticket! I am currently
on vacations, so my answers might be slow.

Replying to [SimonKing](#comment%3A44):
> If I understand correctly, the reason for creating a `JoinCategory`
> is to get the correct supercategories.

The reason to call "join" is indeed to get the correct supercategories
for `C.MyAxiom()`. Note that, on the other hand and unless I
screwed up somewhere, there should be no `JoinCategory` produced
(unless of course the end result of `C.MyAxiom()` itself is such a
`JoinCategory`).

> But there are alternative ways to get the supercategories right. I
> could imagine to use a dynamic class instead. So, the aim of this
> post is to present an alternative approach that avoids joins.

In general, I agree that joins are called quite often and it would be
nice to optimize them and/or call them less often. However, I think we
really want to call a join to get the full power of the
architecture. Imagine for example that:

- C is a super category of A and B
- `A.MyAxiom()` implies `A.MyOtherAxiom()`
- `B.MyOtherAxiom()` is non trivial

Then we want `C.MyAxiom().super_categories()` to automatically
include `B.MyOtherAxiom()`, for otherwise we would need to
basically replicate the information that `A.MyAxiom()` implies
`A.MyOtherAxiom()` over and over in subcategories, and this would
not scale.

Handling this kind of stuff is precisely the core of the logic in
``join``. So if you see a way to optimize the computation of the super
categories of `C.MyAxiom()` while preserving the above feature,
then I believe you actually have found a way to optimize ``join`` in
the first place.

Cheers,
                                       Nicolas

PS: let's keep in mind this idea of using the reduction. It could indeed be that it could be used in a place or two to simplify the logic.



---

archive/issue_comments_108796.json:
```json
{
    "body": "<a id='comment:48'></a>\nReplying to [nthiery](#comment%3A47):\n> Thanks for all your work on the review of this ticket! I am currently\n> on vacations, so my answers might be slow.\n\nSo am I. Perhaps I can try to provide a proof of concept, IF I manage to deal with the scenario that you mentioned.\n\nHave nice holidays!\n\nSimon",
    "created_at": "2013-07-17T07:37:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108796",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:48'></a>
Replying to [nthiery](#comment%3A47):
> Thanks for all your work on the review of this ticket! I am currently
> on vacations, so my answers might be slow.

So am I. Perhaps I can try to provide a proof of concept, IF I manage to deal with the scenario that you mentioned.

Have nice holidays!

Simon



---

archive/issue_comments_108797.json:
```json
{
    "body": "<a id='comment:49'></a>\nReplying to [nthiery](#comment%3A47):\n> The reason to call \"join\" is indeed to get the correct supercategories\n> for `C.MyAxiom()`. Note that, on the other hand and unless I\n> screwed up somewhere, there should be no `JoinCategory` produced\n> (unless of course the end result of `C.MyAxiom()` itself is such a\n> `JoinCategory`).\n\n\nReally? So, then I was mislead by a couple of doctests that demonstrate that a certain category is in fact a join category, even though it is not printed as such, and also mislead by the code that uses `self._with_axiom_categories(...)`, which I thought does in fact form a join.",
    "created_at": "2013-07-17T07:40:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108797",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:49'></a>
Replying to [nthiery](#comment%3A47):
> The reason to call "join" is indeed to get the correct supercategories
> for `C.MyAxiom()`. Note that, on the other hand and unless I
> screwed up somewhere, there should be no `JoinCategory` produced
> (unless of course the end result of `C.MyAxiom()` itself is such a
> `JoinCategory`).


Really? So, then I was mislead by a couple of doctests that demonstrate that a certain category is in fact a join category, even though it is not printed as such, and also mislead by the code that uses `self._with_axiom_categories(...)`, which I thought does in fact form a join.



---

archive/issue_comments_108798.json:
```json
{
    "body": "<a id='comment:50'></a>\nHi Nicolas,\n\nReplying to [nthiery](#comment%3A47):\n> - C is a super category of A and B\n> - `A.MyAxiom()` implies `A.MyOtherAxiom()`\n> - `B.MyOtherAxiom()` is non trivial\n\nI suppose you mean: C is a sub-category of A and B.\n\n__What is an axiom?__\n\nFirst of all, I wonder if we have the same understanding of \"axiom\". For me, an axiom is defined in terms of an algebraic structure that is provided by a certain category without this axiom. In particular `A.Associative()` is actually not well-defined: One should in theory have `A.MultiplicativeAssociative()`, where `MultiplicativeAssociative` is provided by `Magmas()`, or `A.AdditiveAssociative()`, where `AdditiveAssociative` is provided by `AdditiveMagmas()`.\n\nGranted, if `A=Algebras(ZZ)`, then `A.Associative()` should be synonym of `A.MultiplicativeAssociative()`. So, we might want to introduce reasonable short-cuts in some cases.\n\n__Your Example__\n\nNow, in your example, if `MyAxiom` is defined for both A and B, then the meet of A and B is a sub-category of a category M, for which `MyAxiom` and `MyOtherAxiom` are defined. In your example, `MyAxiom` implies `MyOtherAxiom` for A but not for B. Hence, A can be written as a sub-category of `M.SpecialAxiom()`, and `SpecialAxiom` together with `MyAxiom` implies `MyOtherAxiom`.\n\nNow, you consider a category C defined by `C.__class__(data)`, which is a common sub-category of A and B, and you wonder about the super-categories of `C.MyAxiom()`.\n\nSince A satisfies `SpecialAxiom`, C satisfies it as well. Hence, `D = C.MyAxiom()`will also satisfy `MyOtherAxiom`. I guess the logic of this implication is encoded in the way how `D.__class__._used_axioms` is determined. Hence, `D.__class__._used_axioms` contains `SpecialAxiom`, `MyAxiom` *and* `MyOtherAxiom`.\n\nIn a previous post, I presented an algorithm for determining `D.super_categories()`. Let us study what it will return. Recall that it returns `D._without_axiom(axiom)` for all axiom in `D.__class__._used_axioms`, after removing duplicates. Hence:\n- `axiom=SpecialAxiom`: We go along the mro of `D.__class__` until we find something that does not have `SpecialAxiom`. This will be a certain super-category X of C that is a sub-category of B (supposing that B does not satisfy `SpecialAxiom`). This will result in `X....MyAxiom().MySpecialAxiom()`, applying all axioms (except `SpecialAxiom`) that hold for D but not for X.\n- `axiom=MyAxiom`: This will yield `C.MyOtherAxiom()`.\n- `axiom=MyOtherAxiom`: This will yield `C.MyAxiom()`, which coincides with D and is thus removed as a duplicate.\n\nNote that in this explanation I have modified my previous suggestion for `D._without_axiom(this_axiom)`: We can not expect that `D.__class__.__mro__` provides something that has *the same* axioms than D, with just `this_axiom` omitted. But since applying axioms commutes, it is fine to take *the first* class in `D.__class__.__mro__` that does not have `this_axiom`, and then create a category from this class (with the known input data of D), and apply all other missing axioms.\n\nAnyway, I think that the above answer to `C.MyAxiom().super_categories()` looks fine. Or what else would you like to have?\n\nCheers,\n\nSimon",
    "created_at": "2013-07-17T09:38:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108798",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:50'></a>
Hi Nicolas,

Replying to [nthiery](#comment%3A47):
> - C is a super category of A and B
> - `A.MyAxiom()` implies `A.MyOtherAxiom()`
> - `B.MyOtherAxiom()` is non trivial

I suppose you mean: C is a sub-category of A and B.

__What is an axiom?__

First of all, I wonder if we have the same understanding of "axiom". For me, an axiom is defined in terms of an algebraic structure that is provided by a certain category without this axiom. In particular `A.Associative()` is actually not well-defined: One should in theory have `A.MultiplicativeAssociative()`, where `MultiplicativeAssociative` is provided by `Magmas()`, or `A.AdditiveAssociative()`, where `AdditiveAssociative` is provided by `AdditiveMagmas()`.

Granted, if `A=Algebras(ZZ)`, then `A.Associative()` should be synonym of `A.MultiplicativeAssociative()`. So, we might want to introduce reasonable short-cuts in some cases.

__Your Example__

Now, in your example, if `MyAxiom` is defined for both A and B, then the meet of A and B is a sub-category of a category M, for which `MyAxiom` and `MyOtherAxiom` are defined. In your example, `MyAxiom` implies `MyOtherAxiom` for A but not for B. Hence, A can be written as a sub-category of `M.SpecialAxiom()`, and `SpecialAxiom` together with `MyAxiom` implies `MyOtherAxiom`.

Now, you consider a category C defined by `C.__class__(data)`, which is a common sub-category of A and B, and you wonder about the super-categories of `C.MyAxiom()`.

Since A satisfies `SpecialAxiom`, C satisfies it as well. Hence, `D = C.MyAxiom()`will also satisfy `MyOtherAxiom`. I guess the logic of this implication is encoded in the way how `D.__class__._used_axioms` is determined. Hence, `D.__class__._used_axioms` contains `SpecialAxiom`, `MyAxiom` *and* `MyOtherAxiom`.

In a previous post, I presented an algorithm for determining `D.super_categories()`. Let us study what it will return. Recall that it returns `D._without_axiom(axiom)` for all axiom in `D.__class__._used_axioms`, after removing duplicates. Hence:
- `axiom=SpecialAxiom`: We go along the mro of `D.__class__` until we find something that does not have `SpecialAxiom`. This will be a certain super-category X of C that is a sub-category of B (supposing that B does not satisfy `SpecialAxiom`). This will result in `X....MyAxiom().MySpecialAxiom()`, applying all axioms (except `SpecialAxiom`) that hold for D but not for X.
- `axiom=MyAxiom`: This will yield `C.MyOtherAxiom()`.
- `axiom=MyOtherAxiom`: This will yield `C.MyAxiom()`, which coincides with D and is thus removed as a duplicate.

Note that in this explanation I have modified my previous suggestion for `D._without_axiom(this_axiom)`: We can not expect that `D.__class__.__mro__` provides something that has *the same* axioms than D, with just `this_axiom` omitted. But since applying axioms commutes, it is fine to take *the first* class in `D.__class__.__mro__` that does not have `this_axiom`, and then create a category from this class (with the known input data of D), and apply all other missing axioms.

Anyway, I think that the above answer to `C.MyAxiom().super_categories()` looks fine. Or what else would you like to have?

Cheers,

Simon



---

archive/issue_comments_108799.json:
```json
{
    "body": "<a id='comment:51'></a>\nI guess I should re-think the above in a more concrete scenario. Let `D =  DivisionRings()`. What do we do with `D.Finite()`?\n\nWould we agree on `D = Rings().WithMultiplicativeInverses()`? I guess we would obtain `Fields()=D.Commutative()`. So, as in the situation above, we have the rule that if `WithMultiplicativeInverses()` is applied to `Rings()`, then the additional axiom `Finite()` implies the axiom `Commutative()`.\n\nHence, `D.Finite()` yields `Fields().Finite()=FiniteFields()`. To be discussed: Should this be created dynamically, or should there be a hard-coded separate class definition?\n\nSo, what would `FiniteFields().super_categories()` return by the algorithm I presented above?\n- Omit `Commutative`: We still have the axioms `WithMultiplicativeInverses` and `Finite`, hence, we recover `FiniteFields()`, which is thus a duplicate and not part of `FiniteFields().super_categories()`.\n- Omit `Finite`: The remaining axioms are those of commutative division rings, which yields `Fields()`.\n- Omit `WithMultiplicativeInverses`: Yields finite commutative rings.\n\nSo, `FiniteFields().super_categories()`returns `[Fields(), Rings().Commutative().Finite()]`. Do you think this answer makes sense?",
    "created_at": "2013-07-17T10:31:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108799",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:51'></a>
I guess I should re-think the above in a more concrete scenario. Let `D =  DivisionRings()`. What do we do with `D.Finite()`?

Would we agree on `D = Rings().WithMultiplicativeInverses()`? I guess we would obtain `Fields()=D.Commutative()`. So, as in the situation above, we have the rule that if `WithMultiplicativeInverses()` is applied to `Rings()`, then the additional axiom `Finite()` implies the axiom `Commutative()`.

Hence, `D.Finite()` yields `Fields().Finite()=FiniteFields()`. To be discussed: Should this be created dynamically, or should there be a hard-coded separate class definition?

So, what would `FiniteFields().super_categories()` return by the algorithm I presented above?
- Omit `Commutative`: We still have the axioms `WithMultiplicativeInverses` and `Finite`, hence, we recover `FiniteFields()`, which is thus a duplicate and not part of `FiniteFields().super_categories()`.
- Omit `Finite`: The remaining axioms are those of commutative division rings, which yields `Fields()`.
- Omit `WithMultiplicativeInverses`: Yields finite commutative rings.

So, `FiniteFields().super_categories()`returns `[Fields(), Rings().Commutative().Finite()]`. Do you think this answer makes sense?



---

archive/issue_comments_108800.json:
```json
{
    "body": "<a id='comment:52'></a>\nReplying to [SimonKing](#comment%3A51):\n> So, `FiniteFields().super_categories()`returns `[Fields(), Rings().Commutative().Finite()]`. Do you think this answer makes sense?\n\nActually I'd like this answer more than the current answers.\n\nWithout your patch:\n\n```\nsage: FiniteFields().super_categories()\n[Category of fields, Category of finite enumerated sets]\n```\nWith your patch:\n\n```\nsage: FiniteFields().super_categories()\n[Category of fields, Category of finite monoids]\n```\n\nIt seems to me that\n\n```\nsage: FiniteFields().super_categories()\n[Category of fields, Category of finite commutative rings]\n```\nwould be more accurate.",
    "created_at": "2013-07-17T10:37:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108800",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:52'></a>
Replying to [SimonKing](#comment%3A51):
> So, `FiniteFields().super_categories()`returns `[Fields(), Rings().Commutative().Finite()]`. Do you think this answer makes sense?

Actually I'd like this answer more than the current answers.

Without your patch:

```
sage: FiniteFields().super_categories()
[Category of fields, Category of finite enumerated sets]
```
With your patch:

```
sage: FiniteFields().super_categories()
[Category of fields, Category of finite monoids]
```

It seems to me that

```
sage: FiniteFields().super_categories()
[Category of fields, Category of finite commutative rings]
```
would be more accurate.



---

archive/issue_comments_108801.json:
```json
{
    "body": "<a id='comment:53'></a>\nReplying to [SimonKing](#comment%3A52):\n> It seems to me that\n> \n> ```\n> sage: FiniteFields().super_categories()\n> [Category of fields, Category of finite commutative rings]\n> ```\n> would be more accurate.\n\nBut this would mean constructing a trivial category for finite commutative rings (there is currently no category code for finite commutative rings). The point of the axioms infrastructure is precisely to avoid such trivial categories in the category hierarchy in order to prevent the potential combinatorial explosion.\n\nBesides: should this be finite commutative rings? Or finite domains? Or finite euclidean rings? ...",
    "created_at": "2013-07-17T21:09:48Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108801",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:53'></a>
Replying to [SimonKing](#comment%3A52):
> It seems to me that
> 
> ```
> sage: FiniteFields().super_categories()
> [Category of fields, Category of finite commutative rings]
> ```
> would be more accurate.

But this would mean constructing a trivial category for finite commutative rings (there is currently no category code for finite commutative rings). The point of the axioms infrastructure is precisely to avoid such trivial categories in the category hierarchy in order to prevent the potential combinatorial explosion.

Besides: should this be finite commutative rings? Or finite domains? Or finite euclidean rings? ...



---

archive/issue_comments_108802.json:
```json
{
    "body": "<a id='comment:54'></a>\nReplying to [nthiery](#comment%3A53):\n> \n> But this would mean constructing a trivial category for finite commutative rings (there is currently no category code for finite commutative rings).\n\nThat's the point: In my approach, this category would be constructed on the fly, by means of a dynamic construction.\n\n> Besides: should this be finite commutative rings? Or finite domains? Or finite euclidean rings? ...\n\nTo be discussed. In the end of the day, this is a matter of what axioms we have for fields that do not hold for all division rings, and which are thus implied by adding `Finite()` to `Rings().Division()`. \n\nHowever, I do think that the category of finite commutative rings should be a super-category of the category of finite fields. But (with your patch):\n\n```\nsage: Rings().Commutative().Finite() in Fields().Finite().all_super_categories()\nFalse\n```\neven though\n\n```\nsage: (Fields().Finite()).is_subcategory(Rings().Commutative().Finite())\nTrue\n```",
    "created_at": "2013-07-17T21:29:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108802",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:54'></a>
Replying to [nthiery](#comment%3A53):
> 
> But this would mean constructing a trivial category for finite commutative rings (there is currently no category code for finite commutative rings).

That's the point: In my approach, this category would be constructed on the fly, by means of a dynamic construction.

> Besides: should this be finite commutative rings? Or finite domains? Or finite euclidean rings? ...

To be discussed. In the end of the day, this is a matter of what axioms we have for fields that do not hold for all division rings, and which are thus implied by adding `Finite()` to `Rings().Division()`. 

However, I do think that the category of finite commutative rings should be a super-category of the category of finite fields. But (with your patch):

```
sage: Rings().Commutative().Finite() in Fields().Finite().all_super_categories()
False
```
even though

```
sage: (Fields().Finite()).is_subcategory(Rings().Commutative().Finite())
True
```



---

archive/issue_comments_108803.json:
```json
{
    "body": "<a id='comment:55'></a>\nReplying to [SimonKing](#comment%3A50):\n> I suppose you mean: C is a sub-category of A and B.\n\nOops, yes, sure.\n\n> __What is an axiom?__\n> \n> First of all, I wonder if we have the same understanding of \"axiom\". For me, an axiom is defined in terms of an algebraic structure that is provided by a certain category without this axiom.\n\nYes.\n\n> In particular `A.Associative()` is actually not well-defined: One should in theory have `A.MultiplicativeAssociative()`, where `MultiplicativeAssociative` is provided by `Magmas()`, or `A.AdditiveAssociative()`, where `AdditiveAssociative` is provided by `AdditiveMagmas()`.\n> Granted, if `A=Algebras(ZZ)`, then `A.Associative()` should be synonym of `A.MultiplicativeAssociative()`. So, we might want to introduce reasonable short-cuts in some cases.\n\nOf course. But that would be heavy and require to have an\ninfrastructure for shortcuts. So I just followed the previously set\nconvention (as in CommutativeRings w.r.t CommutativeAdditiveMonoids):\nby default, the associative/commutative/unital/... axioms are about\nthe multiplicative structure, and I think that's ok.\n\n> __Your Example__\n> \n> Now, in your example, if `MyAxiom` is defined for both A and B, then the meet of A and B is a sub-category of a category M, for which `MyAxiom` and `MyOtherAxiom` are defined. In your example, `MyAxiom` implies `MyOtherAxiom` for A but not for B. Hence, A can be written as a sub-category of `M.SpecialAxiom()`, and `SpecialAxiom` together with `MyAxiom` implies `MyOtherAxiom`.\n> \n> Now, you consider a category C defined by `C.__class__(data)`, which is a common sub-category of A and B, and you wonder about the super-categories of `C.MyAxiom()`.\n> \n> Since A satisfies `SpecialAxiom`, C satisfies it as well. Hence, `D = C.MyAxiom()`will also satisfy `MyOtherAxiom`. I guess the logic of this implication is encoded in the way how `D.__class__._used_axioms` is determined. Hence, `D.__class__._used_axioms` contains `SpecialAxiom`, `MyAxiom` *and* `MyOtherAxiom`.\n> \n> In a previous post, I presented an algorithm for determining `D.super_categories()`. Let us study what it will return. Recall that it returns `D._without_axiom(axiom)` for all axiom in `D.__class__._used_axioms`, after removing duplicates. Hence:\n> - `axiom=SpecialAxiom`: We go along the mro of `D.__class__` until we find something that does not have `SpecialAxiom`. This will be a certain super-category X of C that is a sub-category of B (supposing that B does not satisfy `SpecialAxiom`). This will result in `X....MyAxiom().MySpecialAxiom()`, applying all axioms (except `SpecialAxiom`) that hold for D but not for X.\n> - `axiom=MyAxiom`: This will yield `C.MyOtherAxiom()`.\n> - `axiom=MyOtherAxiom`: This will yield `C.MyAxiom()`, which coincides with D and is thus removed as a duplicate.\n> \n> Note that in this explanation I have modified my previous suggestion for `D._without_axiom(this_axiom)`: We can not expect that `D.__class__.__mro__` provides something that has *the same* axioms than D, with just `this_axiom` omitted. But since applying axioms commutes, it is fine to take *the first* class in `D.__class__.__mro__` that does not have `this_axiom`, and then create a category from this class (with the known input data of D), and apply all other missing axioms.\n> \n> Anyway, I think that the above answer to `C.MyAxiom().super_categories()` looks fine. Or what else would you like to have?\n\nHonestly I don't have the time to check all the details. If you\nbelieve that computing A.Axiom() is intrinsically simpler than\ncomputing a join (I don't and would favor optimizing join instead),\nfeel free to write a prototype. The test suite in\ncategory_with_axiom.py should be a good guide. Just be warned that it\ntook me a good two weeks of solid work to get things right, and that\nafter at least two iterations :-)\n\nEnjoy your vacations too!",
    "created_at": "2013-07-17T21:33:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108803",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:55'></a>
Replying to [SimonKing](#comment%3A50):
> I suppose you mean: C is a sub-category of A and B.

Oops, yes, sure.

> __What is an axiom?__
> 
> First of all, I wonder if we have the same understanding of "axiom". For me, an axiom is defined in terms of an algebraic structure that is provided by a certain category without this axiom.

Yes.

> In particular `A.Associative()` is actually not well-defined: One should in theory have `A.MultiplicativeAssociative()`, where `MultiplicativeAssociative` is provided by `Magmas()`, or `A.AdditiveAssociative()`, where `AdditiveAssociative` is provided by `AdditiveMagmas()`.
> Granted, if `A=Algebras(ZZ)`, then `A.Associative()` should be synonym of `A.MultiplicativeAssociative()`. So, we might want to introduce reasonable short-cuts in some cases.

Of course. But that would be heavy and require to have an
infrastructure for shortcuts. So I just followed the previously set
convention (as in CommutativeRings w.r.t CommutativeAdditiveMonoids):
by default, the associative/commutative/unital/... axioms are about
the multiplicative structure, and I think that's ok.

> __Your Example__
> 
> Now, in your example, if `MyAxiom` is defined for both A and B, then the meet of A and B is a sub-category of a category M, for which `MyAxiom` and `MyOtherAxiom` are defined. In your example, `MyAxiom` implies `MyOtherAxiom` for A but not for B. Hence, A can be written as a sub-category of `M.SpecialAxiom()`, and `SpecialAxiom` together with `MyAxiom` implies `MyOtherAxiom`.
> 
> Now, you consider a category C defined by `C.__class__(data)`, which is a common sub-category of A and B, and you wonder about the super-categories of `C.MyAxiom()`.
> 
> Since A satisfies `SpecialAxiom`, C satisfies it as well. Hence, `D = C.MyAxiom()`will also satisfy `MyOtherAxiom`. I guess the logic of this implication is encoded in the way how `D.__class__._used_axioms` is determined. Hence, `D.__class__._used_axioms` contains `SpecialAxiom`, `MyAxiom` *and* `MyOtherAxiom`.
> 
> In a previous post, I presented an algorithm for determining `D.super_categories()`. Let us study what it will return. Recall that it returns `D._without_axiom(axiom)` for all axiom in `D.__class__._used_axioms`, after removing duplicates. Hence:
> - `axiom=SpecialAxiom`: We go along the mro of `D.__class__` until we find something that does not have `SpecialAxiom`. This will be a certain super-category X of C that is a sub-category of B (supposing that B does not satisfy `SpecialAxiom`). This will result in `X....MyAxiom().MySpecialAxiom()`, applying all axioms (except `SpecialAxiom`) that hold for D but not for X.
> - `axiom=MyAxiom`: This will yield `C.MyOtherAxiom()`.
> - `axiom=MyOtherAxiom`: This will yield `C.MyAxiom()`, which coincides with D and is thus removed as a duplicate.
> 
> Note that in this explanation I have modified my previous suggestion for `D._without_axiom(this_axiom)`: We can not expect that `D.__class__.__mro__` provides something that has *the same* axioms than D, with just `this_axiom` omitted. But since applying axioms commutes, it is fine to take *the first* class in `D.__class__.__mro__` that does not have `this_axiom`, and then create a category from this class (with the known input data of D), and apply all other missing axioms.
> 
> Anyway, I think that the above answer to `C.MyAxiom().super_categories()` looks fine. Or what else would you like to have?

Honestly I don't have the time to check all the details. If you
believe that computing A.Axiom() is intrinsically simpler than
computing a join (I don't and would favor optimizing join instead),
feel free to write a prototype. The test suite in
category_with_axiom.py should be a good guide. Just be warned that it
took me a good two weeks of solid work to get things right, and that
after at least two iterations :-)

Enjoy your vacations too!



---

archive/issue_comments_108804.json:
```json
{
    "body": "<a id='comment:56'></a>\nReplying to [SimonKing](#comment%3A54):\n> Replying to [nthiery](#comment%3A53):\n> > \n> > But this would mean constructing a trivial category for finite commutative rings (there is currently no category code for finite commutative rings).\n\n> \n> That's the point: In my approach, this category would be constructed on the fly, by means of a dynamic construction.\n\nWe do not even want to construct it on the fly! FiniteFields satisfies\nat least four axioms that can apply to Magmas (Associative, Finite,\nUnital, Commutative). We do not want the category hierarchy above\nFiniteFields to contain {2^4} categories (most of which being trivial) just for Magmas.\nAnd that many for additive magmas.\n\n> To be discussed. In the end of the day, this is a matter of what\n> axioms we have for fields that do not hold for all division rings,\n> and which are thus implied by adding `Finite()` to\n> `Rings().Division()`.\n\nNote that this is currently resolved automatically by the current\nmechanism by looking which axioms are defined/implemented by the\nvarious categories.\n\n> However, I do think that the category of finite commutative rings should be a super-category of the category of finite fields. But (with your patch):\n> \n> ```\n> sage: Rings().Commutative().Finite() in Fields().Finite().all_super_categories()\n> False\n> ```\n> even though\n> \n> ```\n> sage: (Fields().Finite()).is_subcategory(Rings().Commutative().Finite())\n> True\n> ```\n\nWhich is exactly what I want since finite commutative rings is\ntrivial, and realized as a join category. There is no point in adding\njoin categories in all_super_categories.\n\nCheers,\n                         Nicolas",
    "created_at": "2013-07-17T21:52:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108804",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:56'></a>
Replying to [SimonKing](#comment%3A54):
> Replying to [nthiery](#comment%3A53):
> > 
> > But this would mean constructing a trivial category for finite commutative rings (there is currently no category code for finite commutative rings).

> 
> That's the point: In my approach, this category would be constructed on the fly, by means of a dynamic construction.

We do not even want to construct it on the fly! FiniteFields satisfies
at least four axioms that can apply to Magmas (Associative, Finite,
Unital, Commutative). We do not want the category hierarchy above
FiniteFields to contain {2^4} categories (most of which being trivial) just for Magmas.
And that many for additive magmas.

> To be discussed. In the end of the day, this is a matter of what
> axioms we have for fields that do not hold for all division rings,
> and which are thus implied by adding `Finite()` to
> `Rings().Division()`.

Note that this is currently resolved automatically by the current
mechanism by looking which axioms are defined/implemented by the
various categories.

> However, I do think that the category of finite commutative rings should be a super-category of the category of finite fields. But (with your patch):
> 
> ```
> sage: Rings().Commutative().Finite() in Fields().Finite().all_super_categories()
> False
> ```
> even though
> 
> ```
> sage: (Fields().Finite()).is_subcategory(Rings().Commutative().Finite())
> True
> ```

Which is exactly what I want since finite commutative rings is
trivial, and realized as a join category. There is no point in adding
join categories in all_super_categories.

Cheers,
                         Nicolas



---

archive/issue_comments_108805.json:
```json
{
    "body": "<a id='comment:57'></a>\nReplying to [nthiery](#comment%3A56):\n> Replying to [SimonKing](#comment%3A54):\n> > That's the point: In my approach, this category would be constructed on the fly, by means of a dynamic construction.\n\n> \n> We do not even want to construct it on the fly! FiniteFields satisfies\n> at least four axioms that can apply to Magmas (Associative, Finite,\n> Unital, Commutative). We do not want the category hierarchy above\n> FiniteFields to contain {2^4} categories (most of which being trivial) just for Magmas.\n\nOK, that's a considerable change. In the \"good\" old times, a category C was (by definition) a sub-category of another category D, if and only if D was contained in `C.all_super_categories()`. So, you say this shall change (or already has?).\n\n\n> Which is exactly what I want since finite commutative rings is\n> trivial, and realized as a join category. There is no point in adding\n> join categories in all_super_categories.\n\nOK, it somehow convinces me that we don't want to create categories \"on the fly\" that do not provide any additional information (methods etc) beyond the categories that were created anyway.\n\nBut then, I still don't see why this should be implemented by a plain join category.\n\nDo we agree that there is a category `Magmas().Commutative()`, such that all information on `Algebras(ZZ).Commutative()` is provided by `Algebras(ZZ)` together with `Magmas().Commutative()`? Sure, we could then implement `Algebras(ZZ).Commutative()` by a `JoinCategory`.\n\nBut then, I would expect that we can have a class which is similar to `JoinCategory` but is specially designed and thus faster. After all, creating the join of a list of categories should be more complicated then adding a list of \"axiom categories\" (such as `Magmas().Commutative()` and `Magmas().Division()` and `Sets().Finite()`) to a given category (such as `Rings()`).\n\nAnyway, I think my original suggestion of creating classes for categories-with-axiom on the fly was probably not so good. But I think I will try to experiment with the other idea (using a specially designed \"mock join\" for adding axioms).",
    "created_at": "2013-07-18T08:31:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108805",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:57'></a>
Replying to [nthiery](#comment%3A56):
> Replying to [SimonKing](#comment%3A54):
> > That's the point: In my approach, this category would be constructed on the fly, by means of a dynamic construction.

> 
> We do not even want to construct it on the fly! FiniteFields satisfies
> at least four axioms that can apply to Magmas (Associative, Finite,
> Unital, Commutative). We do not want the category hierarchy above
> FiniteFields to contain {2^4} categories (most of which being trivial) just for Magmas.

OK, that's a considerable change. In the "good" old times, a category C was (by definition) a sub-category of another category D, if and only if D was contained in `C.all_super_categories()`. So, you say this shall change (or already has?).


> Which is exactly what I want since finite commutative rings is
> trivial, and realized as a join category. There is no point in adding
> join categories in all_super_categories.

OK, it somehow convinces me that we don't want to create categories "on the fly" that do not provide any additional information (methods etc) beyond the categories that were created anyway.

But then, I still don't see why this should be implemented by a plain join category.

Do we agree that there is a category `Magmas().Commutative()`, such that all information on `Algebras(ZZ).Commutative()` is provided by `Algebras(ZZ)` together with `Magmas().Commutative()`? Sure, we could then implement `Algebras(ZZ).Commutative()` by a `JoinCategory`.

But then, I would expect that we can have a class which is similar to `JoinCategory` but is specially designed and thus faster. After all, creating the join of a list of categories should be more complicated then adding a list of "axiom categories" (such as `Magmas().Commutative()` and `Magmas().Division()` and `Sets().Finite()`) to a given category (such as `Rings()`).

Anyway, I think my original suggestion of creating classes for categories-with-axiom on the fly was probably not so good. But I think I will try to experiment with the other idea (using a specially designed "mock join" for adding axioms).



---

archive/issue_comments_108806.json:
```json
{
    "body": "<a id='comment:58'></a>\nReplying to [SimonKing](#comment%3A57):\n> After all, creating the join of a list of categories should be more complicated then adding a list of \"axiom categories\" (such as `Magmas().Commutative()` and `Magmas().Division()` and `Sets().Finite()`) to a given category (such as `Rings()`).\n\nOr perhaps rather `Rngs().Division()`, because we ask for inverses for all non-zero elements, hence `Division()` requires a category that has a notion of a zero and is at the same time a multiplicative monoid.",
    "created_at": "2013-07-18T08:48:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108806",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:58'></a>
Replying to [SimonKing](#comment%3A57):
> After all, creating the join of a list of categories should be more complicated then adding a list of "axiom categories" (such as `Magmas().Commutative()` and `Magmas().Division()` and `Sets().Finite()`) to a given category (such as `Rings()`).

Or perhaps rather `Rngs().Division()`, because we ask for inverses for all non-zero elements, hence `Division()` requires a category that has a notion of a zero and is at the same time a multiplicative monoid.



---

archive/issue_comments_108807.json:
```json
{
    "body": "<a id='comment:59'></a>\nA question:\n\nWhy should we have a hard-coded category `Fields()`, if all information is encoded in the combination of `Rings().Division()` and `Rings().Commutative()`? Should we not aim at removing sage.categories.fields if we take the axiomatic approach serious?",
    "created_at": "2013-07-18T08:55:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108807",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:59'></a>
A question:

Why should we have a hard-coded category `Fields()`, if all information is encoded in the combination of `Rings().Division()` and `Rings().Commutative()`? Should we not aim at removing sage.categories.fields if we take the axiomatic approach serious?



---

archive/issue_comments_108808.json:
```json
{
    "body": "<a id='comment:60'></a>\nAnd a more general question we should answer: What is the semantics of `super_categories()`?\n\nIt used to be like this, if I understood correctly: `C.super_categories()` should return a list of all categories `S1, S2, ...` constructible in Sage such that C is a proper sub-category of `S1, S2, ...` and there is no category D **constructible in Sage** such that C is a proper sub-category of D and D is a proper sub-category of any of the `S1, S2, ...`.\n\nThe problem with this old meaning of `C.super_categories()` is, of course, that \"constructible in Sage\" is a moving target, and hence it won't scale.\n\nNow it seems that you want to change the old semantics, and I wonder about the exact definition of the new semantics.\n\nIt seems to me that you suggest the following: `C.super_categories()` shall return categories `S1, S2, ...` such that C is a proper sub-category of `S1, S2, ...`, and such that all \"named classes\" of C (i.e., results of calls to `C._make_named_class(...)`) can be constructed from the corresponding named classes of `S1, S2, ...` and from attributes of `C.__class__` (for example, from `C.__class__.ParentMethods`)?",
    "created_at": "2013-07-18T09:44:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108808",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:60'></a>
And a more general question we should answer: What is the semantics of `super_categories()`?

It used to be like this, if I understood correctly: `C.super_categories()` should return a list of all categories `S1, S2, ...` constructible in Sage such that C is a proper sub-category of `S1, S2, ...` and there is no category D **constructible in Sage** such that C is a proper sub-category of D and D is a proper sub-category of any of the `S1, S2, ...`.

The problem with this old meaning of `C.super_categories()` is, of course, that "constructible in Sage" is a moving target, and hence it won't scale.

Now it seems that you want to change the old semantics, and I wonder about the exact definition of the new semantics.

It seems to me that you suggest the following: `C.super_categories()` shall return categories `S1, S2, ...` such that C is a proper sub-category of `S1, S2, ...`, and such that all "named classes" of C (i.e., results of calls to `C._make_named_class(...)`) can be constructed from the corresponding named classes of `S1, S2, ...` and from attributes of `C.__class__` (for example, from `C.__class__.ParentMethods`)?



---

archive/issue_comments_108809.json:
```json
{
    "body": "<a id='comment:61'></a>\nReplying to [SimonKing](#comment%3A57):\n> OK, that's a considerable change. In the \"good\" old times, a\n> category C was (by definition) a sub-category of another category D,\n> if and only if D was contained in `C.all_super_categories()`. So,\n> you say this shall change (or already has?).\n\nThis was already like this for join categories. E.g. with plain sage 5.11.beta3:\n\n```\nsage: C1 = Category.join([Magmas(), CommutativeAdditiveMonoids()])\nsage: C2 = Rings()\nsage: C2.is_subcategory(C1)\nTrue\n```\n\n\n> But then, I still don't see why this should be implemented by a plain join category.\n> \n> Do we agree that there is a category `Magmas().Commutative()`, such\n> that all information on `Algebras(ZZ).Commutative()` is provided by\n> `Algebras(ZZ)` together with `Magmas().Commutative()`?\n\nThose two pieces are indeed sufficient to recover the category:\n\n```\n    sage: C = Algebras(ZZ) & Magmas().Commutative(); C\n    Category of commutative algebras over Integer Ring\n```\n\nBut the join calculation is non trivial since Sage discovers by\nintrospection that there is a specific category for commutative rings,\nso we get:\n\n```\n    sage: C.super_categories()\n    [Category of algebras over Integer Ring, Category of commutative rings]\n```\n\nGranted, the example is not so great since the commutative rings\ncategory is actually currently empty; so we could think about removing\nit, though it's likely to eventually contain something. For a more\ninteresting example we can look at:\n\nMaybe a better example is:\n\n```\nsage: Rings().Finite().super_categories()\n[Category of rings, Category of finite monoids]\n```\n\nAnd some good tests (compare with the sources!):\n\n```\nsage: from sage.categories.category_with_axiom import TestObjectsOverBaseRing\nsage: C = TestObjectsOverBaseRing(QQ)\nsage: C.Facade().Commutative().FiniteDimensional().Finite().Unital().super_categories()\n[Category of finite finite dimensional test objects over base ring over Rational Field,\n Category of finite commutative test objects over base ring over Rational Field,\n Category of facade commutative test objects over base ring over Rational Field,\n Category of finite dimensional commutative unital test objects over base ring over Rational Field]\nsage: C.Facade().Commutative().Finite().Unital().super_categories()                    \n[Category of finite commutative test objects over base ring over Rational Field,\n Category of facade commutative test objects over base ring over Rational Field,\n Category of unital test objects over base ring over Rational Field]\n```\n\n> Sure, we could then implement `Algebras(ZZ).Commutative()` by a `JoinCategory`.\n\n>\n> But then, I would expect that we can have a class which is similar\n> to `JoinCategory` but is specially designed and thus faster. After\n> all, creating the join of a list of categories should be more\n> complicated then adding a list of \"axiom categories\" (such as\n> `Magmas().Commutative()` and `Magmas().Division()` and\n> `Sets().Finite()`) to a given category (such as `Rings()`).\n\nI guess I don't see at this point what can be made really\nsimpler/lighter for a join category when it comes from adding axioms\nto a category. I still believe we can't spare the join calculation.\n\nCheers,\n                             Nicolas",
    "created_at": "2013-07-18T17:20:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108809",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:61'></a>
Replying to [SimonKing](#comment%3A57):
> OK, that's a considerable change. In the "good" old times, a
> category C was (by definition) a sub-category of another category D,
> if and only if D was contained in `C.all_super_categories()`. So,
> you say this shall change (or already has?).

This was already like this for join categories. E.g. with plain sage 5.11.beta3:

```
sage: C1 = Category.join([Magmas(), CommutativeAdditiveMonoids()])
sage: C2 = Rings()
sage: C2.is_subcategory(C1)
True
```


> But then, I still don't see why this should be implemented by a plain join category.
> 
> Do we agree that there is a category `Magmas().Commutative()`, such
> that all information on `Algebras(ZZ).Commutative()` is provided by
> `Algebras(ZZ)` together with `Magmas().Commutative()`?

Those two pieces are indeed sufficient to recover the category:

```
    sage: C = Algebras(ZZ) & Magmas().Commutative(); C
    Category of commutative algebras over Integer Ring
```

But the join calculation is non trivial since Sage discovers by
introspection that there is a specific category for commutative rings,
so we get:

```
    sage: C.super_categories()
    [Category of algebras over Integer Ring, Category of commutative rings]
```

Granted, the example is not so great since the commutative rings
category is actually currently empty; so we could think about removing
it, though it's likely to eventually contain something. For a more
interesting example we can look at:

Maybe a better example is:

```
sage: Rings().Finite().super_categories()
[Category of rings, Category of finite monoids]
```

And some good tests (compare with the sources!):

```
sage: from sage.categories.category_with_axiom import TestObjectsOverBaseRing
sage: C = TestObjectsOverBaseRing(QQ)
sage: C.Facade().Commutative().FiniteDimensional().Finite().Unital().super_categories()
[Category of finite finite dimensional test objects over base ring over Rational Field,
 Category of finite commutative test objects over base ring over Rational Field,
 Category of facade commutative test objects over base ring over Rational Field,
 Category of finite dimensional commutative unital test objects over base ring over Rational Field]
sage: C.Facade().Commutative().Finite().Unital().super_categories()                    
[Category of finite commutative test objects over base ring over Rational Field,
 Category of facade commutative test objects over base ring over Rational Field,
 Category of unital test objects over base ring over Rational Field]
```

> Sure, we could then implement `Algebras(ZZ).Commutative()` by a `JoinCategory`.

>
> But then, I would expect that we can have a class which is similar
> to `JoinCategory` but is specially designed and thus faster. After
> all, creating the join of a list of categories should be more
> complicated then adding a list of "axiom categories" (such as
> `Magmas().Commutative()` and `Magmas().Division()` and
> `Sets().Finite()`) to a given category (such as `Rings()`).

I guess I don't see at this point what can be made really
simpler/lighter for a join category when it comes from adding axioms
to a category. I still believe we can't spare the join calculation.

Cheers,
                             Nicolas



---

archive/issue_comments_108810.json:
```json
{
    "body": "<a id='comment:62'></a>\nReplying to [SimonKing](#comment%3A58):\n> Or perhaps rather `Rngs().Division()`, because we ask for inverses for all non-zero elements, hence `Division()` requires a category that has a notion of a zero and is at the same time a multiplicative monoid.\n\nYes; and pushing your argument to its conclusion that could even be\nDistributiveMagmasAndAssociativeMagmas().AdditiveUnital().Division().\nI guess DivisionRing will do for now.",
    "created_at": "2013-07-18T17:24:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108810",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:62'></a>
Replying to [SimonKing](#comment%3A58):
> Or perhaps rather `Rngs().Division()`, because we ask for inverses for all non-zero elements, hence `Division()` requires a category that has a notion of a zero and is at the same time a multiplicative monoid.

Yes; and pushing your argument to its conclusion that could even be
DistributiveMagmasAndAssociativeMagmas().AdditiveUnital().Division().
I guess DivisionRing will do for now.



---

archive/issue_comments_108811.json:
```json
{
    "body": "<a id='comment:63'></a>\nReplying to [SimonKing](#comment%3A59):\n> Why should we have a hard-coded category `Fields()`, if all information is encoded in the combination of `Rings().Division()` and `Rings().Commutative()`? Should we not aim at removing sage.categories.fields if we take the axiomatic approach serious?\n\nFields is already implemented as a CategoryWithAxiom. But it's a non\ntrivial category (there are quite a few parent and element methods),\nso we want to keep it around.\n\nCheers,\n                              Nicolas",
    "created_at": "2013-07-18T17:28:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108811",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:63'></a>
Replying to [SimonKing](#comment%3A59):
> Why should we have a hard-coded category `Fields()`, if all information is encoded in the combination of `Rings().Division()` and `Rings().Commutative()`? Should we not aim at removing sage.categories.fields if we take the axiomatic approach serious?

Fields is already implemented as a CategoryWithAxiom. But it's a non
trivial category (there are quite a few parent and element methods),
so we want to keep it around.

Cheers,
                              Nicolas



---

archive/issue_comments_108812.json:
```json
{
    "body": "<a id='comment:64'></a>\nReplying to [SimonKing](#comment%3A60):\n> And a more general question we should answer: What is the semantics of `super_categories()`?\n> \n> It used to be like this, if I understood correctly: `C.super_categories()` should return a list of all categories `S1, S2, ...` constructible in Sage such that C is a proper sub-category of `S1, S2, ...` and there is no category D **constructible in Sage** such that C is a proper sub-category of D and D is a proper sub-category of any of the `S1, S2, ...`.\n\nI very much like this definition, and think it's still perfectly up to\ndate. Maybe one would use \"implemented in Sage\" rather than\n\"constructible in Sage\" to rule out join categories.\n\n(a short rephrasing is that super_cartegories give the covering\nrelations in the poset of implemented categories in Sage).\n\nThe only difference after this ticket is that there is a new syntax to\nimplement a category, e.g. `Blahs().Finite()`, as:\n\n```\n    class Blahs(Category):\n        class Finite(CategoryWithAxiom):\n```\n\nbut that's not really different from what we were already doing for\ne.g. `Blahs().CartesianProducts()`.\n\n> The problem with this old meaning of `C.super_categories()` is, of\n> course, that \"constructible in Sage\" is a moving target, and hence\n> it won't scale.\n\nLet me rephrase this as: since \"constructible in Sage\" is a moving\ntarget, maintaining by hand the information in super_categories()\noften does not scale.  So whenever possible, `super_categories`\nshould be calculated automatically.\n\nCheers,\n                      Nicolas",
    "created_at": "2013-07-18T17:41:52Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108812",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:64'></a>
Replying to [SimonKing](#comment%3A60):
> And a more general question we should answer: What is the semantics of `super_categories()`?
> 
> It used to be like this, if I understood correctly: `C.super_categories()` should return a list of all categories `S1, S2, ...` constructible in Sage such that C is a proper sub-category of `S1, S2, ...` and there is no category D **constructible in Sage** such that C is a proper sub-category of D and D is a proper sub-category of any of the `S1, S2, ...`.

I very much like this definition, and think it's still perfectly up to
date. Maybe one would use "implemented in Sage" rather than
"constructible in Sage" to rule out join categories.

(a short rephrasing is that super_cartegories give the covering
relations in the poset of implemented categories in Sage).

The only difference after this ticket is that there is a new syntax to
implement a category, e.g. `Blahs().Finite()`, as:

```
    class Blahs(Category):
        class Finite(CategoryWithAxiom):
```

but that's not really different from what we were already doing for
e.g. `Blahs().CartesianProducts()`.

> The problem with this old meaning of `C.super_categories()` is, of
> course, that "constructible in Sage" is a moving target, and hence
> it won't scale.

Let me rephrase this as: since "constructible in Sage" is a moving
target, maintaining by hand the information in super_categories()
often does not scale.  So whenever possible, `super_categories`
should be calculated automatically.

Cheers,
                      Nicolas



---

archive/issue_comments_108813.json:
```json
{
    "body": "<a id='comment:65'></a>\nReplying to [nthiery](#comment%3A63):\n> Fields is already implemented as a CategoryWithAxiom. But it's a non\n> trivial category (there are quite a few parent and element methods),\n> so we want to keep it around.\n\nSure it has quite a few parent and element methods. But the point is: Since the category of fields is nothing but `Rings().Division().Commutative()`, all these methods should be defined somewhere else.",
    "created_at": "2013-07-18T20:31:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108813",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:65'></a>
Replying to [nthiery](#comment%3A63):
> Fields is already implemented as a CategoryWithAxiom. But it's a non
> trivial category (there are quite a few parent and element methods),
> so we want to keep it around.

Sure it has quite a few parent and element methods. But the point is: Since the category of fields is nothing but `Rings().Division().Commutative()`, all these methods should be defined somewhere else.



---

archive/issue_comments_108814.json:
```json
{
    "body": "<a id='comment:66'></a>\nReplying to [nthiery](#comment%3A61):\n> Replying to [SimonKing](#comment%3A57):\n> > OK, that's a considerable change. In the \"good\" old times, a\n> > category C was (by definition) a sub-category of another category D,\n> > if and only if D was contained in `C.all_super_categories()`. So,\n> > you say this shall change (or already has?).\n\n> \n> This was already like this for join categories.\n\nYou're right. But I think this has been the *only* exception.",
    "created_at": "2013-07-18T20:52:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108814",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:66'></a>
Replying to [nthiery](#comment%3A61):
> Replying to [SimonKing](#comment%3A57):
> > OK, that's a considerable change. In the "good" old times, a
> > category C was (by definition) a sub-category of another category D,
> > if and only if D was contained in `C.all_super_categories()`. So,
> > you say this shall change (or already has?).

> 
> This was already like this for join categories.

You're right. But I think this has been the *only* exception.



---

archive/issue_comments_108815.json:
```json
{
    "body": "<a id='comment:67'></a>\nReplying to [nthiery](#comment%3A64):\n> Replying to [SimonKing](#comment%3A60):\n> > And a more general question we should answer: What is the semantics of `super_categories()`?\n> > \n> > It used to be like this, if I understood correctly: `C.super_categories()` should return a list of all categories `S1, S2, ...` constructible in Sage such that C is a proper sub-category of `S1, S2, ...` and there is no category D **constructible in Sage** such that C is a proper sub-category of D and D is a proper sub-category of any of the `S1, S2, ...`.\n\n> \n> I very much like this definition, and think it's still perfectly up to\n> date.\n\nThis totally surprises me now.\n\nBack to the `Fields().Finite().super_categories()` example. I have argued that we have a couple of axioms, and keeping all axioms but one gives us a list that (after removing duplicates) gives us a list of super categories that exactly follows the specification above. And in [comment:51](#comment%3A51), I have shown that this definition more or less forces us to have `Fields().Finite().super_categories() = [Category of fields, Category of finite commutative rings]`.\n\nAnd you argued against this answer (because of having 2<sup>4</sup> many additional \"empty\" categories in the list of all super categories). You seemed to be in favour of `Fields().Finite().super_categories() = [Category of fields, Category of finite enumerated sets]`.\n\nActually, this is why I came up with the other specification of `C.super_categories()`. That's why it surprises me that you now say you like this specification less.",
    "created_at": "2013-07-18T21:06:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108815",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:67'></a>
Replying to [nthiery](#comment%3A64):
> Replying to [SimonKing](#comment%3A60):
> > And a more general question we should answer: What is the semantics of `super_categories()`?
> > 
> > It used to be like this, if I understood correctly: `C.super_categories()` should return a list of all categories `S1, S2, ...` constructible in Sage such that C is a proper sub-category of `S1, S2, ...` and there is no category D **constructible in Sage** such that C is a proper sub-category of D and D is a proper sub-category of any of the `S1, S2, ...`.

> 
> I very much like this definition, and think it's still perfectly up to
> date.

This totally surprises me now.

Back to the `Fields().Finite().super_categories()` example. I have argued that we have a couple of axioms, and keeping all axioms but one gives us a list that (after removing duplicates) gives us a list of super categories that exactly follows the specification above. And in [comment:51](#comment%3A51), I have shown that this definition more or less forces us to have `Fields().Finite().super_categories() = [Category of fields, Category of finite commutative rings]`.

And you argued against this answer (because of having 2<sup>4</sup> many additional "empty" categories in the list of all super categories). You seemed to be in favour of `Fields().Finite().super_categories() = [Category of fields, Category of finite enumerated sets]`.

Actually, this is why I came up with the other specification of `C.super_categories()`. That's why it surprises me that you now say you like this specification less.



---

archive/issue_comments_108816.json:
```json
{
    "body": "<a id='comment:68'></a>\nReplying to [SimonKing](#comment%3A67):\n> This totally surprises me now.\n\nHmm, it feels like there is a rolling confusion here :-) Trac\ncommunication is not so easy!\n\n> Back to the `Fields().Finite().super_categories()` example. I have argued that we have a couple of axioms, and keeping all axioms but one gives us a list that (after removing duplicates) gives us a list of super categories that exactly follows the specification above. And in [comment:51](#comment%3A51), I have shown that this definition more or less forces us to have `Fields().Finite().super_categories() = [Category of fields, Category of finite commutative rings]`.\n> \n> And you argued against this answer (because of having 2<sup>4</sup> many additional \"empty\" categories in the list of all super categories). You seemed to be in favour of `Fields().Finite().super_categories() = [Category of fields, Category of finite enumerated sets]`.\n\nYes and no: I indeed don't want all 2<sup>4</sup> potential categories. But I do\nwant those that are *implemented* in Sage. In the current state, we\nhave no category implemented for finite commutative rings (in other\nwords, Rings().Commutative().Finite() is a join category), but we do\nhave one for finite monoids (in Monoids.Finite). Hence the current\nanswer:\n\n`[Category of fields, Category of finite monoids]`\n\nCheers,",
    "created_at": "2013-07-19T20:35:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108816",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:68'></a>
Replying to [SimonKing](#comment%3A67):
> This totally surprises me now.

Hmm, it feels like there is a rolling confusion here :-) Trac
communication is not so easy!

> Back to the `Fields().Finite().super_categories()` example. I have argued that we have a couple of axioms, and keeping all axioms but one gives us a list that (after removing duplicates) gives us a list of super categories that exactly follows the specification above. And in [comment:51](#comment%3A51), I have shown that this definition more or less forces us to have `Fields().Finite().super_categories() = [Category of fields, Category of finite commutative rings]`.
> 
> And you argued against this answer (because of having 2<sup>4</sup> many additional "empty" categories in the list of all super categories). You seemed to be in favour of `Fields().Finite().super_categories() = [Category of fields, Category of finite enumerated sets]`.

Yes and no: I indeed don't want all 2<sup>4</sup> potential categories. But I do
want those that are *implemented* in Sage. In the current state, we
have no category implemented for finite commutative rings (in other
words, Rings().Commutative().Finite() is a join category), but we do
have one for finite monoids (in Monoids.Finite). Hence the current
answer:

`[Category of fields, Category of finite monoids]`

Cheers,



---

archive/issue_comments_108817.json:
```json
{
    "body": "<a id='comment:69'></a>\nReplying to [SimonKing](#comment%3A66):\n> You're right. But I think this has been the *only* exception.\n\nAnd this still is the only exception: `Rings().Commutative().Finite()` is a join category.\n\n```\nsage: type(Rings().Finite().Commutative())\n<class 'sage.categories.category.JoinCategory_with_category'>\n```",
    "created_at": "2013-07-19T20:40:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108817",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:69'></a>
Replying to [SimonKing](#comment%3A66):
> You're right. But I think this has been the *only* exception.

And this still is the only exception: `Rings().Commutative().Finite()` is a join category.

```
sage: type(Rings().Finite().Commutative())
<class 'sage.categories.category.JoinCategory_with_category'>
```



---

archive/issue_comments_108818.json:
```json
{
    "body": "<a id='comment:70'></a>\nReplying to [SimonKing](#comment%3A65):\n> Sure it has quite a few parent and element methods. But the point\n> is: Since the category of fields is nothing but\n> `Rings().Division().Commutative()`, all these methods should be\n> defined somewhere else.\n\nWhere else? Of course some of the methods currently in Fields might\nactually work in a more general setting and could be lifted to some\nsuper categories. But others are really about fields (like the trivial\nis_field :-)), so that's their natural spot, isn't it?\n\nBtw:\n\n```\nsage: Rings.Division.Commutative\n<class 'sage.categories.fields.Fields'>\n```",
    "created_at": "2013-07-19T20:54:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108818",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:70'></a>
Replying to [SimonKing](#comment%3A65):
> Sure it has quite a few parent and element methods. But the point
> is: Since the category of fields is nothing but
> `Rings().Division().Commutative()`, all these methods should be
> defined somewhere else.

Where else? Of course some of the methods currently in Fields might
actually work in a more general setting and could be lifted to some
super categories. But others are really about fields (like the trivial
is_field :-)), so that's their natural spot, isn't it?

Btw:

```
sage: Rings.Division.Commutative
<class 'sage.categories.fields.Fields'>
```



---

archive/issue_comments_108819.json:
```json
{
    "body": "<a id='comment:71'></a>\nHi Simon!\n\nBack to work after some good vacations :-)\n\nThe updated patch includes a complete refactoring of the primer and fixes the continuations in docstrings as reported by the patchbot. The next step is to handle the renaming of NonAssociativeNonUnitalAlgebras.\n\nDid you manage to reproduce the doctest errors reported by the patchbot about recursion loop?\n\nCheers,\n                      Nicolas",
    "created_at": "2013-08-13T13:18:48Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108819",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:71'></a>
Hi Simon!

Back to work after some good vacations :-)

The updated patch includes a complete refactoring of the primer and fixes the continuations in docstrings as reported by the patchbot. The next step is to handle the renaming of NonAssociativeNonUnitalAlgebras.

Did you manage to reproduce the doctest errors reported by the patchbot about recursion loop?

Cheers,
                      Nicolas



---

archive/issue_comments_108820.json:
```json
{
    "body": "**Changing work issues** from \"Reduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\". Trivial doctest fixes.\" to \"Rename NonAssociativeNonUnitalAlgebras. Reduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\".\".",
    "created_at": "2013-08-13T13:19:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108820",
    "user": "https://github.com/nthiery"
}
```

**Changing work issues** from "Reduce startup time by 5%. Avoid "recursion depth exceeded (ignored)". Trivial doctest fixes." to "Rename NonAssociativeNonUnitalAlgebras. Reduce startup time by 5%. Avoid "recursion depth exceeded (ignored)".".



---

archive/issue_comments_108821.json:
```json
{
    "body": "<a id='comment:73'></a>\nWhat shall we do about #9107 (mangling of nested class names)? The dependency is rather trivial: just a doctests or two to update.",
    "created_at": "2013-08-13T13:22:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108821",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:73'></a>
What shall we do about #9107 (mangling of nested class names)? The dependency is rather trivial: just a doctests or two to update.



---

archive/issue_comments_108822.json:
```json
{
    "body": "**Changing work issues** from \"Rename NonAssociativeNonUnitalAlgebras. Reduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\".\" to \"RenReduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\".\".",
    "created_at": "2013-08-13T15:48:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108822",
    "user": "https://github.com/nthiery"
}
```

**Changing work issues** from "Rename NonAssociativeNonUnitalAlgebras. Reduce startup time by 5%. Avoid "recursion depth exceeded (ignored)"." to "RenReduce startup time by 5%. Avoid "recursion depth exceeded (ignored)".".



---

archive/issue_comments_108823.json:
```json
{
    "body": "<a id='comment:75'></a>\nThe updated patch also fixes doctests in the primer (I had forgotten to run the tests after the revamping).",
    "created_at": "2013-08-13T15:48:58Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108823",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:75'></a>
The updated patch also fixes doctests in the primer (I had forgotten to run the tests after the revamping).



---

archive/issue_comments_108824.json:
```json
{
    "body": "<a id='comment:76'></a>\nReplacing the current Algebras by MagmaticAlgebras is now the follow up #15043.",
    "created_at": "2013-08-13T16:09:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108824",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:76'></a>
Replacing the current Algebras by MagmaticAlgebras is now the follow up #15043.



---

archive/issue_comments_108825.json:
```json
{
    "body": "**Changing work issues** from \"RenReduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\".\" to \"Rename NoReduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\".\".",
    "created_at": "2013-08-13T16:09:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108825",
    "user": "https://github.com/nthiery"
}
```

**Changing work issues** from "RenReduce startup time by 5%. Avoid "recursion depth exceeded (ignored)"." to "Rename NoReduce startup time by 5%. Avoid "recursion depth exceeded (ignored)".".



---

archive/issue_comments_108826.json:
```json
{
    "body": "**Changing work issues** from \"Rename NoReduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\".\" to \"Reduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\".\".",
    "created_at": "2013-08-13T16:09:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108826",
    "user": "https://github.com/nthiery"
}
```

**Changing work issues** from "Rename NoReduce startup time by 5%. Avoid "recursion depth exceeded (ignored)"." to "Reduce startup time by 5%. Avoid "recursion depth exceeded (ignored)".".



---

archive/issue_comments_108827.json:
```json
{
    "body": "<a id='comment:78'></a>\nReworked the renaming: we might as well use directly AssociativeAlgebras rather than AssociativeMagmaticAlgebras. I added appropriate pointers to #15043.",
    "created_at": "2013-08-13T16:24:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108827",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:78'></a>
Reworked the renaming: we might as well use directly AssociativeAlgebras rather than AssociativeMagmaticAlgebras. I added appropriate pointers to #15043.



---

archive/issue_comments_108828.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,21 +1,40 @@\n-The patch under finalization on the Sage-Combinat queue implements:\n+This ticket implements:\n \n-- Support for full subcategories defined by a predicate on the objects\n-  (Finite, Infinite, FiniteDimensional, Commutative, Graded, Facade),\n-  and joins thereof:\n+- Support for full subcategories defined by an axiom (Finite,\n+  Infinite, FiniteDimensional, Commutative, Associative, Unital,\n+  Inverse, NoZeroDivisors, Division, Facade), and joins thereof:\n \n ```\n-    sage: Category.join([Groups(), Sets().Finite()])\n+    sage: Groups() & Sets().Finite()\n     Category of finite groups\n-    sage: Category.join([Algebras(QQ).Finite(), Monoids().Commutative()])\n+    sage: Algebras(QQ).Finite() & Monoids().Commutative()\n     Join of Category of commutative algebras over Rational Field and Category of finite monoids\n+    sage: Rings().Division() & Sets().Finite()\n+    Category of finite fields\n ```\n+\n+- New categories:\n+  - AdditiveSemigroups, AdditiveMonoids, AdditiveGroups\n+  - DistributiveMagmasAndAdditiveMagmas\n+  - MagmaticAlgebras (will replace Algebras in #15043)\n+  - AssociativeAlgebras\n+  - UnitalAlgebras\n+  - Algebras of additive semigroups and monoids\n \n - More mathematical rules:\n   - A subquotient of a finite set is a finite set\n   - The algebra of a finite set is finite dimensional\n   - The algebra of a commutative magma is commutative\n-- Algebras of commutative additive semigroups and monoids\n+  - A finite division ring is a field\n+  - ...\n+\n - More documentation for IsomorphicObjects and other doc improvements\n \n-See http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch and follow ups.\n+- Complete revamping of sage.categories.primer\n+\n+- Use SubcategoryMethods to put the functorial constructions where\n+  they belong. E.g. DualObjects, TensorProducts, and Graded are now\n+  only defined for subcategories of Modules.\n+\n+Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.\n+\n``````\n",
    "created_at": "2013-08-14T08:47:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108828",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,21 +1,40 @@
-The patch under finalization on the Sage-Combinat queue implements:
+This ticket implements:
 
-- Support for full subcategories defined by a predicate on the objects
-  (Finite, Infinite, FiniteDimensional, Commutative, Graded, Facade),
-  and joins thereof:
+- Support for full subcategories defined by an axiom (Finite,
+  Infinite, FiniteDimensional, Commutative, Associative, Unital,
+  Inverse, NoZeroDivisors, Division, Facade), and joins thereof:
 
 ```
-    sage: Category.join([Groups(), Sets().Finite()])
+    sage: Groups() & Sets().Finite()
     Category of finite groups
-    sage: Category.join([Algebras(QQ).Finite(), Monoids().Commutative()])
+    sage: Algebras(QQ).Finite() & Monoids().Commutative()
     Join of Category of commutative algebras over Rational Field and Category of finite monoids
+    sage: Rings().Division() & Sets().Finite()
+    Category of finite fields
 ```
+
+- New categories:
+  - AdditiveSemigroups, AdditiveMonoids, AdditiveGroups
+  - DistributiveMagmasAndAdditiveMagmas
+  - MagmaticAlgebras (will replace Algebras in #15043)
+  - AssociativeAlgebras
+  - UnitalAlgebras
+  - Algebras of additive semigroups and monoids
 
 - More mathematical rules:
   - A subquotient of a finite set is a finite set
   - The algebra of a finite set is finite dimensional
   - The algebra of a commutative magma is commutative
-- Algebras of commutative additive semigroups and monoids
+  - A finite division ring is a field
+  - ...
+
 - More documentation for IsomorphicObjects and other doc improvements
 
-See http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch and follow ups.
+- Complete revamping of sage.categories.primer
+
+- Use SubcategoryMethods to put the functorial constructions where
+  they belong. E.g. DualObjects, TensorProducts, and Graded are now
+  only defined for subcategories of Modules.
+
+Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.
+
``````




---

archive/issue_comments_108829.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,8 +1,9 @@\n This ticket implements:\n \n - Support for full subcategories defined by an axiom (Finite,\n-  Infinite, FiniteDimensional, Commutative, Associative, Unital,\n-  Inverse, NoZeroDivisors, Division, Facade), and joins thereof:\n+  Infinite, Facade, Commutative, Associative, Unital,\n+  Inverse, NoZeroDivisors, Division, FiniteDimensional, Connected,\n+  WithBasis, Irreducible), and joins thereof:\n \n ```\n     sage: Groups() & Sets().Finite()\n``````\n",
    "created_at": "2013-08-14T08:50:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108829",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,8 +1,9 @@
 This ticket implements:
 
 - Support for full subcategories defined by an axiom (Finite,
-  Infinite, FiniteDimensional, Commutative, Associative, Unital,
-  Inverse, NoZeroDivisors, Division, Facade), and joins thereof:
+  Infinite, Facade, Commutative, Associative, Unital,
+  Inverse, NoZeroDivisors, Division, FiniteDimensional, Connected,
+  WithBasis, Irreducible), and joins thereof:
 
 ```
     sage: Groups() & Sets().Finite()
``````




---

archive/issue_comments_108830.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -29,13 +29,16 @@\n   - A finite division ring is a field\n   - ...\n \n-- More documentation for IsomorphicObjects and other doc improvements\n-\n-- Complete revamping of sage.categories.primer\n+- Documentation:\n+  - More documentation for IsomorphicObjects\n+  - Complete revamping of sage.categories.primer\n+  - Misc\n \n - Use SubcategoryMethods to put the functorial constructions where\n   they belong. E.g. DualObjects, TensorProducts, and Graded are now\n   only defined for subcategories of Modules.\n \n+- More lazy imports, removed a bunch of unused imports, ...\n+\n Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.\n \n``````\n",
    "created_at": "2013-08-14T10:33:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108830",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -29,13 +29,16 @@
   - A finite division ring is a field
   - ...
 
-- More documentation for IsomorphicObjects and other doc improvements
-
-- Complete revamping of sage.categories.primer
+- Documentation:
+  - More documentation for IsomorphicObjects
+  - Complete revamping of sage.categories.primer
+  - Misc
 
 - Use SubcategoryMethods to put the functorial constructions where
   they belong. E.g. DualObjects, TensorProducts, and Graded are now
   only defined for subcategories of Modules.
 
+- More lazy imports, removed a bunch of unused imports, ...
+
 Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.
 
``````




---

archive/issue_comments_108831.json:
```json
{
    "body": "<a id='comment:82'></a>\nHi Simon,\n\nLet me know when you will be back to reviewing this patch, and I'll be more careful with providing incremental patches.\n\nMy recent changes concern:\n- Fixing broken links\n- Fixing imports\n- Moving functorial constructions where they belong (e.g. TensorProducts is only defined for subcategories of Modules)\n\nI am now going to try to investigate the \"recursion\" errors.",
    "created_at": "2013-08-14T10:36:48Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108831",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:82'></a>
Hi Simon,

Let me know when you will be back to reviewing this patch, and I'll be more careful with providing incremental patches.

My recent changes concern:
- Fixing broken links
- Fixing imports
- Moving functorial constructions where they belong (e.g. TensorProducts is only defined for subcategories of Modules)

I am now going to try to investigate the "recursion" errors.



---

archive/issue_comments_108832.json:
```json
{
    "body": "<a id='comment:83'></a>\nHi Nicolas,\n\nconcerning the notion of \"super_categories\":\n\nReplying to [nthiery](#comment%3A69):\n> Replying to [SimonKing](#comment%3A66):\n> > You're right. But I think this has been the *only* exception.\n\n> \n> And this still is the only exception: `Rings().Commutative().Finite()` is a join category.\n> \n> ```\n> sage: type(Rings().Finite().Commutative())\n> <class 'sage.categories.category.JoinCategory_with_category'>\n> ```\n\nExactly. And my impression is that your patch drastically increases the use of join categories. Perhaps this is actually not the case, but if I recall correctly, creating a join is the default when adding an axiom.\n\nAnd this means that you implicitly really change the meaning of `C.super_categories()`. It used to be \"the list of all super-categories of C such that Sage does not implement categories properly between C and the super-category\", except in the case of joins. But if joins are ubiquitous, then `C.super_categories()` will *usually* (i.e., implicitly by default) be \"the list of all super-categories of C, such that all named classes associated with C can be defined by means of the named classes of these super-categories together with attributes of `C.__class__`.\"\n\nMy question (or even suggestion!) is to make this implicit policy official. Rationale:\n- The notion of a \"category implemented in Sage\" is not a mathematical notion, but refers to implementation. Since we don't talk about mathematics here, we should give priority to the question: Where is `super_categories()` used in our implementations?\n- If I am not mistaken, we currently use `super_categories()` for two purposes:\n  1. Construct named classes\n  2. Create a list of all_super_categories, which is used to test for sub-categories in the case of *non-join* categories.\n\nSince in future many categories will be join-categories, only the first point remains really relevant. And this means: We seek a notion of `super_categories` in terms of named classes. That's where my suggestion comes from.",
    "created_at": "2013-08-14T10:59:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108832",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:83'></a>
Hi Nicolas,

concerning the notion of "super_categories":

Replying to [nthiery](#comment%3A69):
> Replying to [SimonKing](#comment%3A66):
> > You're right. But I think this has been the *only* exception.

> 
> And this still is the only exception: `Rings().Commutative().Finite()` is a join category.
> 
> ```
> sage: type(Rings().Finite().Commutative())
> <class 'sage.categories.category.JoinCategory_with_category'>
> ```

Exactly. And my impression is that your patch drastically increases the use of join categories. Perhaps this is actually not the case, but if I recall correctly, creating a join is the default when adding an axiom.

And this means that you implicitly really change the meaning of `C.super_categories()`. It used to be "the list of all super-categories of C such that Sage does not implement categories properly between C and the super-category", except in the case of joins. But if joins are ubiquitous, then `C.super_categories()` will *usually* (i.e., implicitly by default) be "the list of all super-categories of C, such that all named classes associated with C can be defined by means of the named classes of these super-categories together with attributes of `C.__class__`."

My question (or even suggestion!) is to make this implicit policy official. Rationale:
- The notion of a "category implemented in Sage" is not a mathematical notion, but refers to implementation. Since we don't talk about mathematics here, we should give priority to the question: Where is `super_categories()` used in our implementations?
- If I am not mistaken, we currently use `super_categories()` for two purposes:
  1. Construct named classes
  2. Create a list of all_super_categories, which is used to test for sub-categories in the case of *non-join* categories.

Since in future many categories will be join-categories, only the first point remains really relevant. And this means: We seek a notion of `super_categories` in terms of named classes. That's where my suggestion comes from.



---

archive/issue_comments_108833.json:
```json
{
    "body": "<a id='comment:84'></a>\nIn some posts (don't find them right now), I said that adding axioms is easier than forming a join category, and thus one should try to find an implementation that does not rely on plain joins. Let me try to elaborate on it.\n\nIt seems to me that there are (in Sage) two types of categories. My suggestion boils down to: \"Implement two different Python classes for these two types of categories\".\n\nFirstly, there are categories that stipulate the existence of certain algebraic operations. Most notably: `AdditiveMagmas()` (providing the operator \"+\") and `Magmas()` (providing the operator \"*\"), but conceivably there should also be something like `RightGSets(G)` (providing the operator \"`^`\" or perhaps another version of \"*\") and `LeftGSets(G)`. Probably one can formulate all of them as the categories of sets with actions by some **free** operad. Lets call them \"free operator categories\". \n\nAnd secondly, there are \"axiom categories\" that stipulate certain axioms that hold for the operators defined in one of the \"free operator categories\". For example, \n\n```\nAdditiveCommutative() = AdditiveMagmas().Commutative()\n```\nis a category which is a sub-category of `AdditiveMagmas()` in which the \"+\"-operator is commutative; and the law of (left/right/twosided) distributivity is encoded as a sub-category of the join of `AdditiveMagmas()` and `Magmas()`.\n\nHence, an \"axiom category\" should tell what operations it is referring to, and this can be expressed by a (join of) \"free operator categories\". Hence, `Rings().free_operator_category()` would return `Category.join([AdditiveMagmas(), Magmas()])`.\n\nAnd I guess the join of such \"free operator categories\" is trivial: We have one non-join free operator category for each algebraic operation (*, +, /, ...), and forming the join of two free operator categories just amounts to remove duplicates.\n\nWhat about the join of two \"axiom categories\"? Well, first of all, we need to form the join of the underlying  free operator categories (which is trivial), and then combine the two lists of axioms. Here is where one can implement theorems such as \"a finite commutative division ring is a field\". But again, the default is to remove duplicate axioms.\n\nPossible approach to an implementation:\n- I guess `class FreeOperatorCategory` should provide exactly one operation (multiple operations will be implemented by joins). It should have a method `C.operator()` returning `operator.mul` or `operator.add` or `operator.sub` and so on, telling what Python operator it corresponds to. And it should request certain abstract methods by which the operation is implemented (i.e., `_add_` or `_mul_`).\n- `class CategoryWithAxioms` keeps \n  1. a non-empty duplicate-free list FOC of non-join \"free operator categories\", and\n  2. a duplicate-free list EAC of \"elementary (non-join) axiom categories\". In a non-join axiom category, this second list is empty.\n\n  In addition, it has to provide some `_test_...` method(s) for parent and/or element classes, testing against the axioms.\n\nHence, `C=Rings()` would have `C.FOC = [AdditiveMagmas(), SubtractiveMagmas(), Magmas()]` and `C.EAC = [Distributive(), AdditiveCommutative(), AdditiveAssociative(), AdditiveInverses(), Associative()]` (perhaps I forgot some axioms).\n\nNow, about `C.super_categegories()`.\n- If `C` is a non-join free operator category, then it returns `[Objects()]`, which is the only operator-free category (note that `Sets()` is a free operator category for the operator \"in\", requesting an abstract parent method `__contains__`).\n- If `C` is a join of non-join free operator categories, then it returns the list of these non-join free operator categories.\n- If `C` is an axiom category, then it returns the list `C.FOC+C.EAC` after removing those items of `C.FOC` which are already covered by one of the elementary axiom categories from `C.EAC`.\n\n__Example__\n\nEnumerated rings `ER` are a join of rings (with FOC and EAC as above) and enumerated sets. The latter is a free operator category with empty operator but requested abstract parent method `__iter__`. Hence, I would suggest to have\n\n```\nER.super_categories() == [EnumeratedSets(), Distributive(), AdditiveCommutative(), AdditiveAssociative(), AdditiveInverses(), Associative()]\n```\nThis is because `EnumeratedSets()` is the only FOC that is not subject to one of the EAC. Further,\n\n```\nAdditiveInverses().super_categories() == [AdditiveMagmas(), SubtractiveMagmas()]\n```\ni.e., the super categories just state that the axioms are formulated in terms of + and -.\n\nHm. We also have \"0\" (zero). Should one say that \"0\" is a null-ary operator, and thus \"0\" is defined in a free operator category, and that the axiomatic properties of \"0\" as additive unit is then defined in an elementary axiom category `WithAdditiveUnit()`?\n\nAnyway. This is the approach that I would have taken. Do you find anything useful in this approach?",
    "created_at": "2013-08-14T12:09:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108833",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:84'></a>
In some posts (don't find them right now), I said that adding axioms is easier than forming a join category, and thus one should try to find an implementation that does not rely on plain joins. Let me try to elaborate on it.

It seems to me that there are (in Sage) two types of categories. My suggestion boils down to: "Implement two different Python classes for these two types of categories".

Firstly, there are categories that stipulate the existence of certain algebraic operations. Most notably: `AdditiveMagmas()` (providing the operator "+") and `Magmas()` (providing the operator "*"), but conceivably there should also be something like `RightGSets(G)` (providing the operator "`^`" or perhaps another version of "*") and `LeftGSets(G)`. Probably one can formulate all of them as the categories of sets with actions by some **free** operad. Lets call them "free operator categories". 

And secondly, there are "axiom categories" that stipulate certain axioms that hold for the operators defined in one of the "free operator categories". For example, 

```
AdditiveCommutative() = AdditiveMagmas().Commutative()
```
is a category which is a sub-category of `AdditiveMagmas()` in which the "+"-operator is commutative; and the law of (left/right/twosided) distributivity is encoded as a sub-category of the join of `AdditiveMagmas()` and `Magmas()`.

Hence, an "axiom category" should tell what operations it is referring to, and this can be expressed by a (join of) "free operator categories". Hence, `Rings().free_operator_category()` would return `Category.join([AdditiveMagmas(), Magmas()])`.

And I guess the join of such "free operator categories" is trivial: We have one non-join free operator category for each algebraic operation (*, +, /, ...), and forming the join of two free operator categories just amounts to remove duplicates.

What about the join of two "axiom categories"? Well, first of all, we need to form the join of the underlying  free operator categories (which is trivial), and then combine the two lists of axioms. Here is where one can implement theorems such as "a finite commutative division ring is a field". But again, the default is to remove duplicate axioms.

Possible approach to an implementation:
- I guess `class FreeOperatorCategory` should provide exactly one operation (multiple operations will be implemented by joins). It should have a method `C.operator()` returning `operator.mul` or `operator.add` or `operator.sub` and so on, telling what Python operator it corresponds to. And it should request certain abstract methods by which the operation is implemented (i.e., `_add_` or `_mul_`).
- `class CategoryWithAxioms` keeps 
  1. a non-empty duplicate-free list FOC of non-join "free operator categories", and
  2. a duplicate-free list EAC of "elementary (non-join) axiom categories". In a non-join axiom category, this second list is empty.

  In addition, it has to provide some `_test_...` method(s) for parent and/or element classes, testing against the axioms.

Hence, `C=Rings()` would have `C.FOC = [AdditiveMagmas(), SubtractiveMagmas(), Magmas()]` and `C.EAC = [Distributive(), AdditiveCommutative(), AdditiveAssociative(), AdditiveInverses(), Associative()]` (perhaps I forgot some axioms).

Now, about `C.super_categegories()`.
- If `C` is a non-join free operator category, then it returns `[Objects()]`, which is the only operator-free category (note that `Sets()` is a free operator category for the operator "in", requesting an abstract parent method `__contains__`).
- If `C` is a join of non-join free operator categories, then it returns the list of these non-join free operator categories.
- If `C` is an axiom category, then it returns the list `C.FOC+C.EAC` after removing those items of `C.FOC` which are already covered by one of the elementary axiom categories from `C.EAC`.

__Example__

Enumerated rings `ER` are a join of rings (with FOC and EAC as above) and enumerated sets. The latter is a free operator category with empty operator but requested abstract parent method `__iter__`. Hence, I would suggest to have

```
ER.super_categories() == [EnumeratedSets(), Distributive(), AdditiveCommutative(), AdditiveAssociative(), AdditiveInverses(), Associative()]
```
This is because `EnumeratedSets()` is the only FOC that is not subject to one of the EAC. Further,

```
AdditiveInverses().super_categories() == [AdditiveMagmas(), SubtractiveMagmas()]
```
i.e., the super categories just state that the axioms are formulated in terms of + and -.

Hm. We also have "0" (zero). Should one say that "0" is a null-ary operator, and thus "0" is defined in a free operator category, and that the axiomatic properties of "0" as additive unit is then defined in an elementary axiom category `WithAdditiveUnit()`?

Anyway. This is the approach that I would have taken. Do you find anything useful in this approach?



---

archive/issue_comments_108834.json:
```json
{
    "body": "<a id='comment:85'></a>\nHi Simon,\n\nWould you have time for a phone / skype call? It probably would be the quickest to discuss the matter. I am at home and available all afternoon.\n\nCheers,",
    "created_at": "2013-08-14T12:49:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108834",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:85'></a>
Hi Simon,

Would you have time for a phone / skype call? It probably would be the quickest to discuss the matter. I am at home and available all afternoon.

Cheers,



---

archive/issue_comments_108835.json:
```json
{
    "body": "<a id='comment:86'></a>\nReplying to [nthiery](#comment%3A85):\n> Would you have time for a phone / skype call? It probably would be the quickest to discuss the matter. I am at home and available all afternoon.\n\nYes, but I need to get some late lunch first.",
    "created_at": "2013-08-14T13:01:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108835",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:86'></a>
Replying to [nthiery](#comment%3A85):
> Would you have time for a phone / skype call? It probably would be the quickest to discuss the matter. I am at home and available all afternoon.

Yes, but I need to get some late lunch first.



---

archive/issue_comments_108836.json:
```json
{
    "body": "<a id='comment:87'></a>\nReplying to [SimonKing](#comment%3A86):\n> Replying to [nthiery](#comment%3A85):\n> > Would you have time for a phone / skype call? It probably would be the quickest to discuss the matter. I am at home and available all afternoon.\n\n> \n> Yes, but I need to get some late lunch first.\n\nSure. Call me when you are back.",
    "created_at": "2013-08-14T13:08:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108836",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:87'></a>
Replying to [SimonKing](#comment%3A86):
> Replying to [nthiery](#comment%3A85):
> > Would you have time for a phone / skype call? It probably would be the quickest to discuss the matter. I am at home and available all afternoon.

> 
> Yes, but I need to get some late lunch first.

Sure. Call me when you are back.



---

archive/issue_comments_108837.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471\".",
    "created_at": "2013-08-19T15:45:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108837",
    "user": "https://github.com/nthiery"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471".



---

archive/issue_comments_108838.json:
```json
{
    "body": "<a id='comment:89'></a>\nThe updated patch has been trivially rebased on top of #14471 which just got merged.",
    "created_at": "2013-08-19T15:47:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108838",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:89'></a>
The updated patch has been trivially rebased on top of #14471 which just got merged.



---

archive/attachments_014898.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "bla.py",
    "asset_url": "tarball://root/attachments/ticket10963/bla.py",
    "created_at": "2013-08-20T10:19:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket10963/bla.py",
    "user": "https://github.com/nthiery"
}
```



---

archive/issue_comments_108839.json:
```json
{
    "body": "<a id='comment:90'></a>\n**Attachment:** [bla.py](https://github.com/sagemath/sage/files/ticket10963/bla.py)\n\nHi Simon,\n\nI am investigating the recursion error. It is definitely caused by the weak reference handling.\nIf you run\n\n```\n     sage -tp 8 bla.py bla.py\n```\nwith the attached extract of pushout.py, you get a bunch of error messages like:\n\n```\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x347af68> ignored\n```\nAnd if you comment out the \"del\" line in TripleDictEraser.__call__, then the error message disapears.\n\nI am know going to proceed reducing further bla.py to get something that hopefuly would trigger the bug without the functorial construction patch. The hard part is that basically removing any line in bla.py gets the error not to appear.\n\nLet me know if you have ideas ...",
    "created_at": "2013-08-20T10:19:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108839",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:90'></a>
**Attachment:** [bla.py](https://github.com/sagemath/sage/files/ticket10963/bla.py)

Hi Simon,

I am investigating the recursion error. It is definitely caused by the weak reference handling.
If you run

```
     sage -tp 8 bla.py bla.py
```
with the attached extract of pushout.py, you get a bunch of error messages like:

```
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x347af68> ignored
```
And if you comment out the "del" line in TripleDictEraser.__call__, then the error message disapears.

I am know going to proceed reducing further bla.py to get something that hopefuly would trigger the bug without the functorial construction patch. The hard part is that basically removing any line in bla.py gets the error not to appear.

Let me know if you have ideas ...



---

archive/issue_comments_108840.json:
```json
{
    "body": "<a id='comment:91'></a>\nOk, from Volker's suggestion on Sage-devel, one can raise a similar error message when garbage collecting the entries of a MonoDict (would be the same with a tripledict) involves a big recursion because deleting an entry triggers the deletion of another entry and so on:\n\n```\nfrom sage.structure.coerce_dict import MonoDict\nM = MonoDict(11)\n\nclass A: pass\na = A()\nprev = a\n\nfor i in range(1000):\n    newA = A()\n    M[prev] = newA\n    prev = newA\n\nlen(M)\ndel a\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x5a13788> ignored\n```\n\nAt this point, my guess is that our weak dictionary infrastructure currently has an intrisic limitation on the depth of the reference graph, and that all the functioral construction patch does is putting a bit more stress and reach this limitation. So now the question is: is it possible to fix the weak dict infrastructure to let it scale properly by somehow unrolling the recursion as Volker suggests in [1].\n\nCheers,\n\n[1] https://groups.google.com/d/msg/sage-devel/us0JCrRwGz0/McDlwepFve4J",
    "created_at": "2013-08-20T11:13:06Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108840",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:91'></a>
Ok, from Volker's suggestion on Sage-devel, one can raise a similar error message when garbage collecting the entries of a MonoDict (would be the same with a tripledict) involves a big recursion because deleting an entry triggers the deletion of another entry and so on:

```
from sage.structure.coerce_dict import MonoDict
M = MonoDict(11)

class A: pass
a = A()
prev = a

for i in range(1000):
    newA = A()
    M[prev] = newA
    prev = newA

len(M)
del a
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x5a13788> ignored
```

At this point, my guess is that our weak dictionary infrastructure currently has an intrisic limitation on the depth of the reference graph, and that all the functioral construction patch does is putting a bit more stress and reach this limitation. So now the question is: is it possible to fix the weak dict infrastructure to let it scale properly by somehow unrolling the recursion as Volker suggests in [1].

Cheers,

[1] https://groups.google.com/d/msg/sage-devel/us0JCrRwGz0/McDlwepFve4J



---

archive/issue_comments_108841.json:
```json
{
    "body": "<a id='comment:92'></a>\nReplying to [nthiery](#comment%3A91):\n> Ok, from Volker's suggestion on Sage-devel, one can raise a similar error message when garbage collecting the entries of a MonoDict (would be the same with a tripledict) involves a big recursion because deleting an entry triggers the deletion of another entry and so on:\n\nThis sounds like we need a different ticket. What do Python's weak dictionaries do? Don't they have similar problems?",
    "created_at": "2013-08-20T11:18:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108841",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:92'></a>
Replying to [nthiery](#comment%3A91):
> Ok, from Volker's suggestion on Sage-devel, one can raise a similar error message when garbage collecting the entries of a MonoDict (would be the same with a tripledict) involves a big recursion because deleting an entry triggers the deletion of another entry and so on:

This sounds like we need a different ticket. What do Python's weak dictionaries do? Don't they have similar problems?



---

archive/issue_comments_108842.json:
```json
{
    "body": "<a id='comment:93'></a>\nReplying to [nthiery](#comment%3A91):\n> \n> ```\n> len(M)\n> del a\n> Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x5a13788> ignored\n> ```\n\nAre you sure that the error in bla.py is the same as the error reported by the patchbot? After all, the patchbot did not mention `MonoDictEraser`, but named a function `remove()`, isn't it?",
    "created_at": "2013-08-20T11:32:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108842",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:93'></a>
Replying to [nthiery](#comment%3A91):
> 
> ```
> len(M)
> del a
> Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x5a13788> ignored
> ```

Are you sure that the error in bla.py is the same as the error reported by the patchbot? After all, the patchbot did not mention `MonoDictEraser`, but named a function `remove()`, isn't it?



---

archive/issue_comments_108843.json:
```json
{
    "body": "<a id='comment:94'></a>\nReplying to [SimonKing](#comment%3A92):\n> This sounds like we need a different ticket. What do Python's weak dictionaries do? Don't they have similar problems?\n\nThey do. In your example, just replace `M = MonoDict(11)` by `M = weakref.WeakKeyDictionary()`, and you get essentially the same error:\n\n```\nsage: del a\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x5f9d578> ignored\n```\n\nAnd this actually sounds much closer to the error reported by the patchbot.",
    "created_at": "2013-08-20T11:42:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108843",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:94'></a>
Replying to [SimonKing](#comment%3A92):
> This sounds like we need a different ticket. What do Python's weak dictionaries do? Don't they have similar problems?

They do. In your example, just replace `M = MonoDict(11)` by `M = weakref.WeakKeyDictionary()`, and you get essentially the same error:

```
sage: del a
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x5f9d578> ignored
```

And this actually sounds much closer to the error reported by the patchbot.



---

archive/issue_comments_108844.json:
```json
{
    "body": "<a id='comment:95'></a>\nNote that for the join, we are using a `WeakValueDictionary`, and with your patch we are making increased use of joins. Could this be the source of trouble?\n\nBut to my surprise, with a `WeakValueDictionary`, one can not get the same error (here, of course, we need to delete the first value, not the first key):\n\n```\nsage: class A: pass\nsage: M = weakref.WeakValueDictionary()\nsage: a = A()\n....: prev = a\n....: for i in range(1000):\n....:     newA = A()\n....:     M[newA] = prev\n....:     prev = newA\n....:     \nsage: len(M)\n1000\nsage: del a\nsage: len(M)\n0\n```",
    "created_at": "2013-08-20T11:51:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108844",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:95'></a>
Note that for the join, we are using a `WeakValueDictionary`, and with your patch we are making increased use of joins. Could this be the source of trouble?

But to my surprise, with a `WeakValueDictionary`, one can not get the same error (here, of course, we need to delete the first value, not the first key):

```
sage: class A: pass
sage: M = weakref.WeakValueDictionary()
sage: a = A()
....: prev = a
....: for i in range(1000):
....:     newA = A()
....:     M[newA] = prev
....:     prev = newA
....:     
sage: len(M)
1000
sage: del a
sage: len(M)
0
```



---

archive/issue_comments_108845.json:
```json
{
    "body": "<a id='comment:96'></a>\n... and a `WeakKeyDictionary` is only used in sage.misc.randstate, nowhere else! `WeakValueDictionary` is used more often.\n\nHm.\n\nLet me try to summarize:\n- The patchbot reported\n\n  ```\n  Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x2820668> ignored\n  Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0xfe16e0> ignored\n  Exception RuntimeError: 'maximum recursion depth exceeded while getting the str of an object' in <function remove at 0x2e03e60> ignored\n  Exception RuntimeError: 'maximum recursion depth exceeded while getting the str of an object' in <function remove at 0x2e03e60> ignored\n  ```\n- Your [attachment:bla.py](https://github.com/sagemath/sage/files/ticket10963/bla.py) fails with\n\n  ```\n  Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x347af68> ignored\n  ```\n- It is possible to get an error message similar to the first two examples of the patchbot by using a `WeakKeyDictionary`, but seemingly not by using a `WeakValueDictionary`. But only the latter is used in Sage.\n\nWhere shall one start to try and analyse the problem?",
    "created_at": "2013-08-20T12:00:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108845",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:96'></a>
... and a `WeakKeyDictionary` is only used in sage.misc.randstate, nowhere else! `WeakValueDictionary` is used more often.

Hm.

Let me try to summarize:
- The patchbot reported

  ```
  Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x2820668> ignored
  Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0xfe16e0> ignored
  Exception RuntimeError: 'maximum recursion depth exceeded while getting the str of an object' in <function remove at 0x2e03e60> ignored
  Exception RuntimeError: 'maximum recursion depth exceeded while getting the str of an object' in <function remove at 0x2e03e60> ignored
  ```
- Your [attachment:bla.py](https://github.com/sagemath/sage/files/ticket10963/bla.py) fails with

  ```
  Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x347af68> ignored
  ```
- It is possible to get an error message similar to the first two examples of the patchbot by using a `WeakKeyDictionary`, but seemingly not by using a `WeakValueDictionary`. But only the latter is used in Sage.

Where shall one start to try and analyse the problem?



---

archive/issue_comments_108846.json:
```json
{
    "body": "<a id='comment:97'></a>\nReplying to [SimonKing](#comment%3A96):\n> - Your [attachment:bla.py](https://github.com/sagemath/sage/files/ticket10963/bla.py) fails with\n> \n>   ```\n>   Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x347af68> ignored\n>   ```\n\nYup. I should add that it produces a combination of \"remove\" and\n\"TripleDictEraser\" errors; I pointed to the later because it was more\nspecific. Also the whole thing is very sensitive to changes: if you\nchange a line in bla.py you can switch from one message to the\nother. My bet is that we have a recursive data structure which is a\nmix of Triple dict and other weak dictionary, so depending on how deep\nthe recursion breaks you get one message or the other.\n\n> Where shall one start to try and analyse the problem?\n\nLooking at the sources of `WeakValueDictionary` to see how they work\naround the recursion issue?\n\nCheers,\n                           Nicolas",
    "created_at": "2013-08-20T13:05:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108846",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:97'></a>
Replying to [SimonKing](#comment%3A96):
> - Your [attachment:bla.py](https://github.com/sagemath/sage/files/ticket10963/bla.py) fails with
> 
>   ```
>   Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x347af68> ignored
>   ```

Yup. I should add that it produces a combination of "remove" and
"TripleDictEraser" errors; I pointed to the later because it was more
specific. Also the whole thing is very sensitive to changes: if you
change a line in bla.py you can switch from one message to the
other. My bet is that we have a recursive data structure which is a
mix of Triple dict and other weak dictionary, so depending on how deep
the recursion breaks you get one message or the other.

> Where shall one start to try and analyse the problem?

Looking at the sources of `WeakValueDictionary` to see how they work
around the recursion issue?

Cheers,
                           Nicolas



---

archive/issue_comments_108847.json:
```json
{
    "body": "<a id='comment:98'></a>\n`WeakValueDictionary` uses\n\n```python\n        def remove(wr, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                del self.data[wr.key]\n```\nand `WeakKeyDictionary` uses\n\n```python\n        def remove(k, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                del self.data[k]\n```\nas a call-back.\n\nAnd I think I see why `WeakValueDictionary` does not crash. Recall from [comment:95](#comment%3A95) that I did (of course with more layers)\n\n```\nM[b]=a\nM[c]=b\nM[d]=c\n```\nand the only elements with a strong reference being kept are d and a. When deleting a, then successively the items keyed by b, c and d are removed from the `WeakValueDictionary`.\n\nBut think for a moment what is happening during the callback, in the line\n\n```\n    del self.data[wr.key]\n```\nWhen this is first called, `wr` is a weak reference pointing to a, and `wr.key` is b. Hence, when `del self.data[wr.key]` is executed, then there is still a *strong* reference to b, namely in wr.key. Only when the call to `remove()` is finished, `wr` will be released, and in this moment the last reference to b is gone. Hence, `del self.data[wr.key]` is called again, but this time `wr` points to b and `wr.key` is a strong reference to c.\n\n**Conclusion:** During the deletion of the dictionary item (b,a), there is a strong reference to the key b. Hence, the deletion of the item (c,b) will only be started after deletion of the item (b,a) is completed. Hence, no recursion.\n\nBut for a `WeakKeyDictionary` things are different. There,we have\n(of course with more layers)\n\n```\nM[b]=a\nM[c]=b\nM[d]=c\n```\nand we only keep a reference to a and d. When we delete d, then the item (d,c) will be removed. In the line\n\n```\n    del self.data[k]\n```\nthere is no strong reference to the value of `self.data[k]`. Hence, while `self.data[k]` is deleted, it could be that the callback of a weak reference pointing to this value is invoked.\n\nAnd this analysis gives rise to a solution: In the `TripleDictEraser` and `MonoDictEraser`, one should not simply do `del bucket[i:i+3]` or `del bucket[i:i+7]`, but one should assign a temporary variable to `bucket[i+2]` or `bucket[i+6]` that will keep the value alive until the call to the eraser is completed, thus, avoiding the recursion.\n\nI suggest to open a separate ticket for this issue.",
    "created_at": "2013-08-20T14:31:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108847",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:98'></a>
`WeakValueDictionary` uses

```python
        def remove(wr, selfref=ref(self)):
            self = selfref()
            if self is not None:
                del self.data[wr.key]
```
and `WeakKeyDictionary` uses

```python
        def remove(k, selfref=ref(self)):
            self = selfref()
            if self is not None:
                del self.data[k]
```
as a call-back.

And I think I see why `WeakValueDictionary` does not crash. Recall from [comment:95](#comment%3A95) that I did (of course with more layers)

```
M[b]=a
M[c]=b
M[d]=c
```
and the only elements with a strong reference being kept are d and a. When deleting a, then successively the items keyed by b, c and d are removed from the `WeakValueDictionary`.

But think for a moment what is happening during the callback, in the line

```
    del self.data[wr.key]
```
When this is first called, `wr` is a weak reference pointing to a, and `wr.key` is b. Hence, when `del self.data[wr.key]` is executed, then there is still a *strong* reference to b, namely in wr.key. Only when the call to `remove()` is finished, `wr` will be released, and in this moment the last reference to b is gone. Hence, `del self.data[wr.key]` is called again, but this time `wr` points to b and `wr.key` is a strong reference to c.

**Conclusion:** During the deletion of the dictionary item (b,a), there is a strong reference to the key b. Hence, the deletion of the item (c,b) will only be started after deletion of the item (b,a) is completed. Hence, no recursion.

But for a `WeakKeyDictionary` things are different. There,we have
(of course with more layers)

```
M[b]=a
M[c]=b
M[d]=c
```
and we only keep a reference to a and d. When we delete d, then the item (d,c) will be removed. In the line

```
    del self.data[k]
```
there is no strong reference to the value of `self.data[k]`. Hence, while `self.data[k]` is deleted, it could be that the callback of a weak reference pointing to this value is invoked.

And this analysis gives rise to a solution: In the `TripleDictEraser` and `MonoDictEraser`, one should not simply do `del bucket[i:i+3]` or `del bucket[i:i+7]`, but one should assign a temporary variable to `bucket[i+2]` or `bucket[i+6]` that will keep the value alive until the call to the eraser is completed, thus, avoiding the recursion.

I suggest to open a separate ticket for this issue.



---

archive/issue_comments_108848.json:
```json
{
    "body": "<a id='comment:99'></a>\nReplying to [SimonKing](#comment%3A98):\n> And this analysis gives rise to a solution: In the\n> `TripleDictEraser` and `MonoDictEraser`, one should not simply do\n> `del bucket[i:i+3]` or `del bucket[i:i+7]`, but one should assign a\n> temporary variable to `bucket[i+2]` or `bucket[i+6]` that will keep\n> the value alive until the call to the eraser is completed, thus,\n> avoiding the recursion.\n\nCool! I am looking forward seeing this work! Thanks for investigating.\n\n> I suggest to open a separate ticket for this issue.\n\nDefinitely!\n\nCheers,\n                             Nicolas",
    "created_at": "2013-08-20T16:03:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108848",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:99'></a>
Replying to [SimonKing](#comment%3A98):
> And this analysis gives rise to a solution: In the
> `TripleDictEraser` and `MonoDictEraser`, one should not simply do
> `del bucket[i:i+3]` or `del bucket[i:i+7]`, but one should assign a
> temporary variable to `bucket[i+2]` or `bucket[i+6]` that will keep
> the value alive until the call to the eraser is completed, thus,
> avoiding the recursion.

Cool! I am looking forward seeing this work! Thanks for investigating.

> I suggest to open a separate ticket for this issue.

Definitely!

Cheers,
                             Nicolas



---

archive/issue_comments_108849.json:
```json
{
    "body": "<a id='comment:0'></a>\nHmmmm. It is not as easy as I thought. Therefore I put Volker and Nils on Cc, because they know a lot more on Python than I do.\n\nBy inserting print statements, I verified that with unpatched Sage in the `MonoDict` example, the eraser is called recursively: When invoking the eraser for a key K1, the deletion of the key-value pair (K1,K2) results in calling the eraser for K2 *before* the eraser of K1 has finished. Hence, the order is like this:\n- the eraser is called recursively, because a deletion happening inside of the eraser triggers the call to the next eraser.\n- the `RuntimeError` is reported after the last deletion has happened\n- after reporting the error, the 1000 nested erasers return one after the other.\n\nWith a tentative patch, I can make the callback function work in a seemingly good way: The eraser is invoked for a key K1, and by assigning K2 to a local variable, the key-value pair (K1,K2) can be \"safely\" removed. The order is like this:\n- one eraser is called, and inside of it a deletion happens.\n- the next eraser is only called after when the first eraser returns.\n\nAnd now comes the big surprise: In the very end, the `RuntimeError` is still reported! Even though the inserted print statements show that the calls are not nested!",
    "created_at": "2013-08-20T20:03:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108849",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Hmmmm. It is not as easy as I thought. Therefore I put Volker and Nils on Cc, because they know a lot more on Python than I do.

By inserting print statements, I verified that with unpatched Sage in the `MonoDict` example, the eraser is called recursively: When invoking the eraser for a key K1, the deletion of the key-value pair (K1,K2) results in calling the eraser for K2 *before* the eraser of K1 has finished. Hence, the order is like this:
- the eraser is called recursively, because a deletion happening inside of the eraser triggers the call to the next eraser.
- the `RuntimeError` is reported after the last deletion has happened
- after reporting the error, the 1000 nested erasers return one after the other.

With a tentative patch, I can make the callback function work in a seemingly good way: The eraser is invoked for a key K1, and by assigning K2 to a local variable, the key-value pair (K1,K2) can be "safely" removed. The order is like this:
- one eraser is called, and inside of it a deletion happens.
- the next eraser is only called after when the first eraser returns.

And now comes the big surprise: In the very end, the `RuntimeError` is still reported! Even though the inserted print statements show that the calls are not nested!



---

archive/issue_comments_108850.json:
```json
{
    "body": "<a id='comment:1'></a>\nTwo more data points.\n\nWhen I provide the class A with a `__del__` method printing a debug message, I see that first the (now non-nested) calls to the eraser happen, and then FOUR `Exception RuntimeError: ... ignored` are reported, namely:\n\n```\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x5610440> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <bound method A.__del__ of <__main__.A instance at 0x573b3f8>> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <bound method A.__del__ of <__main__.A instance at 0x573b368>> ignored\nException RuntimeError: 'maximum recursion depth exceeded' in <bound method A.__del__ of <__main__.A instance at 0x573b2d8>> ignored\n```\nand only in the very end, all calls to `__del__` happen. I.e., the calls to `__del__` are not mixed with calls to the eraser.\n\nHowever, when I define `A` as a cdef class with `__weakref__` and a `__dealloc__` method (again printing debug info), the picture is different: The `__dealloc__` of K1 is called, then the eraser for K1 is called (deleting the key-value pair K1,K2 from the `MonoDict`), then the eraser for K1 returns, then `__dealloc__` for K2 is called, followed by the eraser for K2, and so on. So, `__del__` is not mixed with calling the erasers, but `__dealloc__` is mixed. And in the very and, there are two errors reported:\n\n```\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <_home_simon__sage_temp_linux_sqwp_site_5429_tmp_oooXg4_spyx_0.A object at 0x570e738> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x560f440> ignored\n```\n\nFrankly I'm puzzled.",
    "created_at": "2013-08-20T20:16:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108850",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Two more data points.

When I provide the class A with a `__del__` method printing a debug message, I see that first the (now non-nested) calls to the eraser happen, and then FOUR `Exception RuntimeError: ... ignored` are reported, namely:

```
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x5610440> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <bound method A.__del__ of <__main__.A instance at 0x573b3f8>> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <bound method A.__del__ of <__main__.A instance at 0x573b368>> ignored
Exception RuntimeError: 'maximum recursion depth exceeded' in <bound method A.__del__ of <__main__.A instance at 0x573b2d8>> ignored
```
and only in the very end, all calls to `__del__` happen. I.e., the calls to `__del__` are not mixed with calls to the eraser.

However, when I define `A` as a cdef class with `__weakref__` and a `__dealloc__` method (again printing debug info), the picture is different: The `__dealloc__` of K1 is called, then the eraser for K1 is called (deleting the key-value pair K1,K2 from the `MonoDict`), then the eraser for K1 returns, then `__dealloc__` for K2 is called, followed by the eraser for K2, and so on. So, `__del__` is not mixed with calling the erasers, but `__dealloc__` is mixed. And in the very and, there are two errors reported:

```
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <_home_simon__sage_temp_linux_sqwp_site_5429_tmp_oooXg4_spyx_0.A object at 0x570e738> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x560f440> ignored
```

Frankly I'm puzzled.



---

archive/issue_comments_108851.json:
```json
{
    "body": "<a id='comment:2'></a>\nFor the record, I currently work with this patch\n\n```diff\ndiff --git a/sage/structure/coerce_dict.pyx b/sage/structure/coerce_dict.pyx\n--- a/sage/structure/coerce_dict.pyx\n+++ b/sage/structure/coerce_dict.pyx\n@@ -187,14 +187,18 @@\n         h,offset = r.key\n         cdef list bucket = <object>PyList_GET_ITEM(buckets, (<size_t>h) % PyList_GET_SIZE(buckets))\n         cdef Py_ssize_t i\n+        cdef object val\n         for i from 0 <= i < PyList_GET_SIZE(bucket) by 3:\n             if PyInt_AsSsize_t(PyList_GET_ITEM(bucket,i))==h:\n                 if PyList_GET_ITEM(bucket,i+offset)==<void *>r:\n+                    val = <object>PyList_GET_ITEM(bucket,i+2)\n+                    print \"deletion for\",<size_t>h,\"with value\",<size_t><void*>val\n                     del bucket[i:i+3]\n                     D._size -= 1\n                     break\n                 else:\n                     break\n+        print \"last line for\",<size_t>h,\"with value\",<size_t><void*>val\n \n cdef class TripleDictEraser:\n     \"\"\"\n```\nand the examples are\n\n```\nsage: from sage.structure.coerce_dict import MonoDict\nsage: M = MonoDict(11)\nsage: class A:                  \n....:     def __del__(self):\n....:         print \"__del__\",id(self)\n....:          \nsage: a = A()\nsage: prev = a\nsage: M = MonoDict(11)\nsage: for i in range(1000):\n....:     newA = A()\n....:     M[prev] = newA\n....:     prev = newA\n....:     \nsage: del a\ndeletion for 91294536 with value 89650384\nlast line for 91294536 with value 89650384\ndeletion for 89650384 with value 89650600\nlast line for 89650384 with value 89650600\ndeletion for 89650600 with value 89660160\nlast line for 89650600 with value 89660160\ndeletion for 89660160 with value 89660232\nlast line for 89660160 with value 89660232\ndeletion for 89660232 with value 89660016\nlast line for 89660232 with value 89660016\n...\ndeletion for 91409944 with value 91410016\nlast line for 91409944 with value 91410016\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x54169f0> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <bound method A.__del__ of <__main__.A instance at 0x572ce60>> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <bound method A.__del__ of <__main__.A instance at 0x572ce18>> ignored\nException RuntimeError: 'maximum recursion depth exceeded' in <bound method A.__del__ of <__main__.A instance at 0x572cdd0>> ignored\n__del__ 91409800\n__del__ 91409728\n__del__ 91409656\n__del__ 91409584\n__del__ 91409512\n...\n__del__ 89660160\n__del__ 89650600\n__del__ 89650384\n__del__ 91294536\n```\nrespectively\n\n```\nsage: from sage.structure.coerce_dict import MonoDict\nsage: M = MonoDict(11)\nsage: cython(\"\"\"\n....: cdef class A:\n....:     cdef __weakref__\n....:     def __dealloc__(self):\n....:         print \"__dealloc__\",id(self)\n....: \"\"\")\n....: \nsage: a = A()\nsage: prev = a\nsage: for i in range(1000):\n....:     newA = A()\n....:     M[prev] = newA\n....:     prev = newA\n....:     \nsage: len(M)\n1000\nsage: del a\n__dealloc__ 140403054971016\ndeletion for 140403054971016 with value 140403054971064\nlast line for 140403054971016 with value 140403054971064\n__dealloc__ 140403054971064\ndeletion for 140403054971064 with value 140403054971184\nlast line for 140403054971064 with value 140403054971184\n__dealloc__ 140403054971184\ndeletion for 140403054971184 with value 140403054971160\nlast line for 140403054971184 with value 140403054971160\n__dealloc__ 140403054971160\ndeletion for 140403054971160 with value 140403054971208\nlast line for 140403054971160 with value 140403054971208\n__dealloc__ 140403054971208\ndeletion for 140403054971208 with value 140403054971088\nlast line for 140403054971208 with value 140403054971088\n__dealloc__ 140403054971088\ndeletion for 140403054971088 with value 140403054971112\nlast line for 140403054971088 with value 140403054971112\n__dealloc__ 140403054971112\ndeletion for 140403054971112 with value 140403054971232\nlast line for 140403054971112 with value 140403054971232\n...\n__dealloc__ 91285256\ndeletion for 91285256 with value 91285280\nlast line for 91285256 with value 91285280\n__dealloc__ 91285280\ndeletion for 91285280 with value 91285304\nlast line for 91285280 with value 91285304\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <_home_simon__sage_temp_linux_sqwp_site_5429_tmp_oooXg4_spyx_0.A object at 0x570e738> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x560f440> ignored\n```\n\nConclusion: I thought I understood what was happening, but these two examples prove me wrong.",
    "created_at": "2013-08-20T20:26:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108851",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
For the record, I currently work with this patch

```diff
diff --git a/sage/structure/coerce_dict.pyx b/sage/structure/coerce_dict.pyx
--- a/sage/structure/coerce_dict.pyx
+++ b/sage/structure/coerce_dict.pyx
@@ -187,14 +187,18 @@
         h,offset = r.key
         cdef list bucket = <object>PyList_GET_ITEM(buckets, (<size_t>h) % PyList_GET_SIZE(buckets))
         cdef Py_ssize_t i
+        cdef object val
         for i from 0 <= i < PyList_GET_SIZE(bucket) by 3:
             if PyInt_AsSsize_t(PyList_GET_ITEM(bucket,i))==h:
                 if PyList_GET_ITEM(bucket,i+offset)==<void *>r:
+                    val = <object>PyList_GET_ITEM(bucket,i+2)
+                    print "deletion for",<size_t>h,"with value",<size_t><void*>val
                     del bucket[i:i+3]
                     D._size -= 1
                     break
                 else:
                     break
+        print "last line for",<size_t>h,"with value",<size_t><void*>val
 
 cdef class TripleDictEraser:
     """
```
and the examples are

```
sage: from sage.structure.coerce_dict import MonoDict
sage: M = MonoDict(11)
sage: class A:                  
....:     def __del__(self):
....:         print "__del__",id(self)
....:          
sage: a = A()
sage: prev = a
sage: M = MonoDict(11)
sage: for i in range(1000):
....:     newA = A()
....:     M[prev] = newA
....:     prev = newA
....:     
sage: del a
deletion for 91294536 with value 89650384
last line for 91294536 with value 89650384
deletion for 89650384 with value 89650600
last line for 89650384 with value 89650600
deletion for 89650600 with value 89660160
last line for 89650600 with value 89660160
deletion for 89660160 with value 89660232
last line for 89660160 with value 89660232
deletion for 89660232 with value 89660016
last line for 89660232 with value 89660016
...
deletion for 91409944 with value 91410016
last line for 91409944 with value 91410016
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x54169f0> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <bound method A.__del__ of <__main__.A instance at 0x572ce60>> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <bound method A.__del__ of <__main__.A instance at 0x572ce18>> ignored
Exception RuntimeError: 'maximum recursion depth exceeded' in <bound method A.__del__ of <__main__.A instance at 0x572cdd0>> ignored
__del__ 91409800
__del__ 91409728
__del__ 91409656
__del__ 91409584
__del__ 91409512
...
__del__ 89660160
__del__ 89650600
__del__ 89650384
__del__ 91294536
```
respectively

```
sage: from sage.structure.coerce_dict import MonoDict
sage: M = MonoDict(11)
sage: cython("""
....: cdef class A:
....:     cdef __weakref__
....:     def __dealloc__(self):
....:         print "__dealloc__",id(self)
....: """)
....: 
sage: a = A()
sage: prev = a
sage: for i in range(1000):
....:     newA = A()
....:     M[prev] = newA
....:     prev = newA
....:     
sage: len(M)
1000
sage: del a
__dealloc__ 140403054971016
deletion for 140403054971016 with value 140403054971064
last line for 140403054971016 with value 140403054971064
__dealloc__ 140403054971064
deletion for 140403054971064 with value 140403054971184
last line for 140403054971064 with value 140403054971184
__dealloc__ 140403054971184
deletion for 140403054971184 with value 140403054971160
last line for 140403054971184 with value 140403054971160
__dealloc__ 140403054971160
deletion for 140403054971160 with value 140403054971208
last line for 140403054971160 with value 140403054971208
__dealloc__ 140403054971208
deletion for 140403054971208 with value 140403054971088
last line for 140403054971208 with value 140403054971088
__dealloc__ 140403054971088
deletion for 140403054971088 with value 140403054971112
last line for 140403054971088 with value 140403054971112
__dealloc__ 140403054971112
deletion for 140403054971112 with value 140403054971232
last line for 140403054971112 with value 140403054971232
...
__dealloc__ 91285256
deletion for 91285256 with value 91285280
last line for 91285256 with value 91285280
__dealloc__ 91285280
deletion for 91285280 with value 91285304
last line for 91285280 with value 91285304
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <_home_simon__sage_temp_linux_sqwp_site_5429_tmp_oooXg4_spyx_0.A object at 0x570e738> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x560f440> ignored
```

Conclusion: I thought I understood what was happening, but these two examples prove me wrong.



---

archive/issue_comments_108852.json:
```json
{
    "body": "<a id='comment:103'></a>\nHi Simon,\n\nThanks for your ongoing investigation! I just created #15070 for it.\nI guess the discussion might as well continue there.\n\nCheers,\n                        Nicolas",
    "created_at": "2013-08-20T20:40:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108852",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:103'></a>
Hi Simon,

Thanks for your ongoing investigation! I just created #15070 for it.
I guess the discussion might as well continue there.

Cheers,
                        Nicolas



---

archive/issue_comments_108853.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15070\".",
    "created_at": "2013-08-20T20:40:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108853",
    "user": "https://github.com/nthiery"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15070".



---

archive/issue_comments_108854.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15070\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069\".",
    "created_at": "2013-08-20T20:48:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108854",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15070" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069".



---

archive/issue_comments_108855.json:
```json
{
    "body": "<a id='comment:105'></a>\nReplying to [nthiery](#comment%3A103):\n> \tHi Simon,\n> \n> Thanks for your ongoing investigation! I just created #15070 for it.\n> I guess the discussion might as well continue there.\n> \n> Cheers,\n>                         Nicolas\n\nARRGH! I just created #15069 (which is *before* #15070, and thus your ticket is the duplicate ;)",
    "created_at": "2013-08-20T20:48:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108855",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:105'></a>
Replying to [nthiery](#comment%3A103):
> 	Hi Simon,
> 
> Thanks for your ongoing investigation! I just created #15070 for it.
> I guess the discussion might as well continue there.
> 
> Cheers,
>                         Nicolas

ARRGH! I just created #15069 (which is *before* #15070, and thus your ticket is the duplicate ;)



---

archive/issue_comments_108856.json:
```json
{
    "body": "**Changing work issues** from \"Reduce startup time by 5%. Avoid \"recursion depth exceeded (ignored)\".\" to \"Reduce startup time by 5%.\".",
    "created_at": "2013-08-21T10:52:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108856",
    "user": "https://github.com/nthiery"
}
```

**Changing work issues** from "Reduce startup time by 5%. Avoid "recursion depth exceeded (ignored)"." to "Reduce startup time by 5%.".



---

archive/issue_comments_108857.json:
```json
{
    "body": "<a id='comment:6'></a>\nThanks so much Simon and Volker for #15069! Now we just have to handle the startup time.\n\nI am now kicking the patchbot to see the result of the tests.",
    "created_at": "2013-08-21T10:52:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108857",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>
Thanks so much Simon and Volker for #15069! Now we just have to handle the startup time.

I am now kicking the patchbot to see the result of the tests.



---

archive/issue_comments_108858.json:
```json
{
    "body": "<a id='comment:107'></a>\nAny further progress on this patch? Many other patches are waiting to get in and depend on it :-) !\n\nAnne",
    "created_at": "2013-09-10T00:24:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108858",
    "user": "https://github.com/anneschilling"
}
```

<a id='comment:107'></a>
Any further progress on this patch? Many other patches are waiting to get in and depend on it :-) !

Anne



---

archive/issue_comments_108859.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094\".",
    "created_at": "2013-09-11T22:30:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108859",
    "user": "https://github.com/tscrim"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094".



---

archive/issue_comments_108860.json:
```json
{
    "body": "<a id='comment:8'></a>\nThere's a very minor dependency from #15094 in `qsym.py`.",
    "created_at": "2013-09-11T22:30:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108860",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>
There's a very minor dependency from #15094 in `qsym.py`.



---

archive/issue_comments_108861.json:
```json
{
    "body": "<a id='comment:9'></a>\nThere is an additional dependency from #11688.",
    "created_at": "2013-10-02T14:50:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108861",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:9'></a>
There is an additional dependency from #11688.



---

archive/issue_comments_108862.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688\".",
    "created_at": "2013-10-02T14:50:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108862",
    "user": "https://github.com/tscrim"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688".



---

archive/issue_events_085459.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2013-10-16T16:57:26Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85459"
}
```



---

archive/issue_events_085460.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2013-10-16T16:57:26Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85460"
}
```



---

archive/issue_comments_108863.json:
```json
{
    "body": "**Changing work issues** from \"Reduce startup time by 5%.\" to \"\".",
    "created_at": "2013-10-16T16:57:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108863",
    "user": "https://github.com/nthiery"
}
```

**Changing work issues** from "Reduce startup time by 5%." to "".



---

archive/issue_comments_108864.json:
```json
{
    "body": "<a id='comment:0'></a>\nI thereby pledge to pay off my startup time tax by working on lazy importing more combinat stuff. See #15293 for a proof of concept showing that one can easily gain back the current 5% we might loose here. I thus have removed the needs work for this ticket. \n\nThe only remaining issue is the dependency upon #9107, which we can either finalize (I hope to get to it by the end of the week), or trivially work around.\n\nSimon, pleeeeeeeaase, do you have a chance to get back to the review of this ticket? So many things depend on it ...",
    "created_at": "2013-10-16T16:57:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108864",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:0'></a>
I thereby pledge to pay off my startup time tax by working on lazy importing more combinat stuff. See #15293 for a proof of concept showing that one can easily gain back the current 5% we might loose here. I thus have removed the needs work for this ticket. 

The only remaining issue is the dependency upon #9107, which we can either finalize (I hope to get to it by the end of the week), or trivially work around.

Simon, pleeeeeeeaase, do you have a chance to get back to the review of this ticket? So many things depend on it ...



---

archive/issue_comments_108865.json:
```json
{
    "body": "<a id='comment:1'></a>\nIMHO its ridiculous to hold up this ticket for 2 months because of a tiny startup time increase. Just get this merged, especially if lots of other stuff depends on it.",
    "created_at": "2013-10-16T20:10:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108865",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:1'></a>
IMHO its ridiculous to hold up this ticket for 2 months because of a tiny startup time increase. Just get this merged, especially if lots of other stuff depends on it.



---

archive/issue_comments_108866.json:
```json
{
    "body": "<a id='comment:2'></a>\nThis needs to be rebased on 5.13.beta0, see the latest report of **patchbot**",
    "created_at": "2013-10-18T20:13:06Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108866",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:2'></a>
This needs to be rebased on 5.13.beta0, see the latest report of **patchbot**



---

archive/issue_comments_108867.json:
```json
{
    "body": "<a id='comment:3'></a>\nThanks for the notice! I am about to upload the latest version on the combinat server which Travis rebased recently. That is likely to do the job.\n\nCheers,\n                          Nicolas",
    "created_at": "2013-10-19T09:50:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108867",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:3'></a>
Thanks for the notice! I am about to upload the latest version on the combinat server which Travis rebased recently. That is likely to do the job.

Cheers,
                          Nicolas



---

archive/issue_comments_108868.json:
```json
{
    "body": "<a id='comment:4'></a>\nThere are some failing doctests, see the **patchbot** report.",
    "created_at": "2013-10-19T14:59:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108868",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:4'></a>
There are some failing doctests, see the **patchbot** report.



---

archive/issue_comments_108869.json:
```json
{
    "body": "<a id='comment:115'></a>\nReplying to [vbraun](#comment%3A111):\n> IMHO its ridiculous to hold up this ticket for 2 months because of a tiny startup time increase. Just get this merged, especially if lots of other stuff depends on it.\n\nYes, especially with the Sage Days coming up in November it would be good to get this\nticket merged!!! A lot of stuff depends on it.",
    "created_at": "2013-10-26T02:56:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108869",
    "user": "https://github.com/anneschilling"
}
```

<a id='comment:115'></a>
Replying to [vbraun](#comment%3A111):
> IMHO its ridiculous to hold up this ticket for 2 months because of a tiny startup time increase. Just get this merged, especially if lots of other stuff depends on it.

Yes, especially with the Sage Days coming up in November it would be good to get this
ticket merged!!! A lot of stuff depends on it.



---

archive/issue_comments_108870.json:
```json
{
    "body": "<a id='comment:6'></a>\nHello,\n\nhere is a patch correcting the failing doctests. Nicolas, could you please check that I have not made a mistake ? and maybe qfold if you want ?\n\nI have been forced to remove (or rather disconnect) the example of graded module with basis. But this can wait for another ticket.\n\nThere remains a strange failing doctest in sagenb.notebook.interact.list_of_first_n. I am not able to solve that. Could somebody else help ?\n\napply trac_10963-more_functorial_constructions-nt.patch trac_10963_doctest_correction-fc.patch",
    "created_at": "2013-10-27T13:10:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108870",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:6'></a>
Hello,

here is a patch correcting the failing doctests. Nicolas, could you please check that I have not made a mistake ? and maybe qfold if you want ?

I have been forced to remove (or rather disconnect) the example of graded module with basis. But this can wait for another ticket.

There remains a strange failing doctest in sagenb.notebook.interact.list_of_first_n. I am not able to solve that. Could somebody else help ?

apply trac_10963-more_functorial_constructions-nt.patch trac_10963_doctest_correction-fc.patch



---

archive/issue_comments_108871.json:
```json
{
    "body": "<a id='comment:7'></a>\nThe patches now pass the tests.\n\nIs there something else to do, before this can be positive-reviewed ?",
    "created_at": "2013-10-27T15:30:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108871",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:7'></a>
The patches now pass the tests.

Is there something else to do, before this can be positive-reviewed ?



---

archive/issue_comments_108872.json:
```json
{
    "body": "<a id='comment:8'></a>\nI am sorry for my long silence. The current 8% of regression in the startup time is, of course, not good. But, as Nicolas has already said, he might be able to improve the startup time in other places. \n\nAlso, I don't think that the suggested solution is final. In some posts long time ago, I indicated some further ideas. However, the suggested solution is certainly better (in the sense of \"will scale better\") than the status quo. Hence, it would be silly to wait longer, just because one could *perhaps* solve the issue with a different (and not necessarily better) approach.\n\nI have studied the code in the past, and it made sense to me. The doctests work. Startup time regression has been taken care of in a different ticket. And further improvements (performance and conception) may be done in future. So, it seems good to go from my perspective.\n\nSince I had such a long break, I think it would be fair that one declares Fr\u00e9d\u00e9ric's patch as review patch, he adds himself to the list of reviewers, and changes it to a positive review (unless he finds further problems, of course).",
    "created_at": "2013-10-27T15:53:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108872",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
I am sorry for my long silence. The current 8% of regression in the startup time is, of course, not good. But, as Nicolas has already said, he might be able to improve the startup time in other places. 

Also, I don't think that the suggested solution is final. In some posts long time ago, I indicated some further ideas. However, the suggested solution is certainly better (in the sense of "will scale better") than the status quo. Hence, it would be silly to wait longer, just because one could *perhaps* solve the issue with a different (and not necessarily better) approach.

I have studied the code in the past, and it made sense to me. The doctests work. Startup time regression has been taken care of in a different ticket. And further improvements (performance and conception) may be done in future. So, it seems good to go from my perspective.

Since I had such a long break, I think it would be fair that one declares Frédéric's patch as review patch, he adds himself to the list of reviewers, and changes it to a positive review (unless he finds further problems, of course).



---

archive/issue_comments_108873.json:
```json
{
    "body": "<a id='comment:9'></a>\nOk, then I agree to give a positive review, although I have **not** looked at the code.\n\nBut first Nicolas has to refresh his patch (there is a HUNK).",
    "created_at": "2013-10-27T16:54:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108873",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:9'></a>
Ok, then I agree to give a positive review, although I have **not** looked at the code.

But first Nicolas has to refresh his patch (there is a HUNK).



---

archive/issue_comments_108874.json:
```json
{
    "body": "**Changing reviewer** from \"Simon King\" to \"Simon King, Fr\u00e9d\u00e9ric Chapoton\".",
    "created_at": "2013-10-27T16:54:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108874",
    "user": "https://github.com/fchapoton"
}
```

**Changing reviewer** from "Simon King" to "Simon King, Frédéric Chapoton".



---

archive/issue_comments_108875.json:
```json
{
    "body": "<a id='comment:0'></a>\nTo make the release manager comfortable: I state that the code and the maths behind it look good, and Fr\u00e9d\u00e9ric please make sure that the patch is fine wrt. the current version of Sage.",
    "created_at": "2013-10-27T17:08:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108875",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
To make the release manager comfortable: I state that the code and the maths behind it look good, and Frédéric please make sure that the patch is fine wrt. the current version of Sage.



---

archive/issue_comments_108876.json:
```json
{
    "body": "<a id='comment:1'></a>\nThe hunk comes from #12453 in the combinat queue (this does some refactoring and cleanup) which doesn't quite commute past this, but it can be made so, i.e. there is no functional dependency AFAIK. The lazy/cunning part of me would say, \"Lets review #12453 first and I don't think it's too difficult of a review job (it looks bigger because of the reorganization),\" but I don't want to hold this up if you don't agree with that sentiment.",
    "created_at": "2013-10-27T18:02:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108876",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:1'></a>
The hunk comes from #12453 in the combinat queue (this does some refactoring and cleanup) which doesn't quite commute past this, but it can be made so, i.e. there is no functional dependency AFAIK. The lazy/cunning part of me would say, "Lets review #12453 first and I don't think it's too difficult of a review job (it looks bigger because of the reorganization)," but I don't want to hold this up if you don't agree with that sentiment.



---

archive/issue_comments_108877.json:
```json
{
    "body": "<a id='comment:2'></a>\nWell, I guess maybe one would then have to wait longer (days ? months ? years ?) unless an enthousiastic reviewer for #12453 enters the scene right now.",
    "created_at": "2013-10-27T21:14:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108877",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:2'></a>
Well, I guess maybe one would then have to wait longer (days ? months ? years ?) unless an enthousiastic reviewer for #12453 enters the scene right now.



---

archive/issue_comments_108878.json:
```json
{
    "body": "<a id='comment:3'></a>\nYippee! Thanks for the (almost) positive review!\n\nI am going to double check Frederic's patch and the HUNK in the train later this morning.\n\nCheers,",
    "created_at": "2013-10-29T06:46:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108878",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:3'></a>
Yippee! Thanks for the (almost) positive review!

I am going to double check Frederic's patch and the HUNK in the train later this morning.

Cheers,



---

archive/attachments_014899.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "trac_10963_doctest_correction-fc.patch",
    "asset_url": "tarball://root/attachments/ticket10963/trac_10963_doctest_correction-fc.patch",
    "created_at": "2013-10-29T10:05:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket10963/trac_10963_doctest_correction-fc.patch",
    "user": "https://github.com/nthiery"
}
```



---

archive/issue_comments_108879.json:
```json
{
    "body": "**Attachment:** [trac_10963_doctest_correction-fc.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963_doctest_correction-fc.patch)",
    "created_at": "2013-10-29T10:05:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108879",
    "user": "https://github.com/nthiery"
}
```

**Attachment:** [trac_10963_doctest_correction-fc.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963_doctest_correction-fc.patch)



---

archive/issue_comments_108880.json:
```json
{
    "body": "<a id='comment:4'></a>\nI checked Frederic's doctest fixes. Some of them were the expected fixes in waiting for #9107. Thanks for handling those! The others actually stemmed from a regression which was revealed by the commutation with #11688: GradedModules(QQ) was constructed as a join category. I fixed that (well, it's more like a workaround, but that will do for now) in :attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch, and reuploaded Frederic's patch without the corresponding hunks.\n\nAs for the commutation issue in the queue with #12453: this does not affect this ticket. It just requires to rebase #12453 in the queue, which I am about to do now. And rerun the tests. Note that this will be for 5.12 since I don't have the latest beta installed though.\n\nPlease have a quick look to the updated patches, and set the ticket to positive review if you are happy!\n\nTime permitting, I'll have a look at #9107 in case we could just get done with it and avoid Frederics patch altogether, but let's not wait for that.",
    "created_at": "2013-10-29T10:12:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108880",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:4'></a>
I checked Frederic's doctest fixes. Some of them were the expected fixes in waiting for #9107. Thanks for handling those! The others actually stemmed from a regression which was revealed by the commutation with #11688: GradedModules(QQ) was constructed as a join category. I fixed that (well, it's more like a workaround, but that will do for now) in :attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch, and reuploaded Frederic's patch without the corresponding hunks.

As for the commutation issue in the queue with #12453: this does not affect this ticket. It just requires to rebase #12453 in the queue, which I am about to do now. And rerun the tests. Note that this will be for 5.12 since I don't have the latest beta installed though.

Please have a quick look to the updated patches, and set the ticket to positive review if you are happy!

Time permitting, I'll have a look at #9107 in case we could just get done with it and avoid Frederics patch altogether, but let's not wait for that.



---

archive/issue_comments_108881.json:
```json
{
    "body": "<a id='comment:5'></a>\nThe patches in this ticket are now high up in the queue. I rebased #12453 accordingly (trivial).",
    "created_at": "2013-10-29T10:37:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108881",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>
The patches in this ticket are now high up in the queue. I rebased #12453 accordingly (trivial).



---

archive/issue_comments_108882.json:
```json
{
    "body": "<a id='comment:6'></a>\nHello Nicolas,\n\nOn 5.13.beta1, one got\n\n```\napplication de trac_10963-more_functorial_constructions-nt.patch\npatching file sage/combinat/integer_vector_weighted.py\nHunk #1 succeeded at 122 with fuzz 2 (offset -141 lines).\n```\nSo I have refreshed your patch and uploaded a version with no hunks.\n\nfor the patchbot:\n\napply trac_10963-more_functorial_constructions-nt-refreshed.patch trac_10963_doctest_correction-fc.patch trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch",
    "created_at": "2013-10-29T19:40:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108882",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:6'></a>
Hello Nicolas,

On 5.13.beta1, one got

```
application de trac_10963-more_functorial_constructions-nt.patch
patching file sage/combinat/integer_vector_weighted.py
Hunk #1 succeeded at 122 with fuzz 2 (offset -141 lines).
```
So I have refreshed your patch and uploaded a version with no hunks.

for the patchbot:

apply trac_10963-more_functorial_constructions-nt-refreshed.patch trac_10963_doctest_correction-fc.patch trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch



---

archive/issue_comments_108883.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -42,3 +42,8 @@\n \n Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.\n \n+Apply:\n+\n+* [attachment:trac_10963-more_functorial_constructions-nt-refreshed.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt-refreshed.patch)\n+* [attachment:trac_10963_doctest_correction-fc.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963_doctest_correction-fc.patch)\n+* [attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch)\n``````\n",
    "created_at": "2013-10-29T19:40:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108883",
    "user": "https://github.com/fchapoton"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -42,3 +42,8 @@
 
 Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.
 
+Apply:
+
+* [attachment:trac_10963-more_functorial_constructions-nt-refreshed.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt-refreshed.patch)
+* [attachment:trac_10963_doctest_correction-fc.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963_doctest_correction-fc.patch)
+* [attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch)
``````




---

archive/issue_events_085461.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2013-10-29T19:55:56Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85461"
}
```



---

archive/issue_events_085462.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2013-10-29T19:55:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85462"
}
```



---

archive/issue_comments_108884.json:
```json
{
    "body": "<a id='comment:7'></a>\nok, then let's go. \n\nBut (about startup time) please consider the tickets #15335, #15293, #3685",
    "created_at": "2013-10-29T19:55:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108884",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:7'></a>
ok, then let's go. 

But (about startup time) please consider the tickets #15335, #15293, #3685



---

archive/issue_comments_108885.json:
```json
{
    "body": "<a id='comment:8'></a>\nI don't remember why I am the owner of this patch, but let me congratulate that you finally got it positively reviewed!\n\nMy main motivation for implementing stuff in Sage was that I wanted to work on #11187. But I accidentally built it on top of this patch, so I never finished it, and it never made it into main Sage. I hope to find the motivation for working it out again!\n\nBest, Christian",
    "created_at": "2013-10-29T20:17:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108885",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:8'></a>
I don't remember why I am the owner of this patch, but let me congratulate that you finally got it positively reviewed!

My main motivation for implementing stuff in Sage was that I wanted to work on #11187. But I accidentally built it on top of this patch, so I never finished it, and it never made it into main Sage. I hope to find the motivation for working it out again!

Best, Christian



---

archive/attachments_014900.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch",
    "asset_url": "tarball://root/attachments/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch",
    "created_at": "2013-10-29T22:24:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch",
    "user": "https://github.com/nthiery"
}
```



---

archive/issue_comments_108886.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Attachment:** [trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch)\n\nSorry to do a change on a patch with positive review. trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch\u200b now includes two trivial updates to failing doctests it caused in c3_controlled.pyx. All tests now pass on my machine, so I allow myself to leave it on positive review.",
    "created_at": "2013-10-29T22:24:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108886",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:9'></a>
**Attachment:** [trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch)

Sorry to do a change on a patch with positive review. trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch​ now includes two trivial updates to failing doctests it caused in c3_controlled.pyx. All tests now pass on my machine, so I allow myself to leave it on positive review.



---

archive/issue_comments_108887.json:
```json
{
    "body": "<a id='comment:130'></a>\nReplying to [stumpc5](#comment%3A128):\n> I don't remember why I am the owner of this patch, but let me congratulate that you finally got it positively reviewed!\n\nThanks!\n\n> My main motivation for implementing stuff in Sage was that I wanted to work on #11187. But I accidentally built it on top of this patch, so I never finished it, and it never made it into main Sage. I hope to find the motivation for working it out again!\n\nYeah, I am sorry for all the good features that have been postponed forever due to this patch; I paid the price myself and know how frustrating this could be! But now I am looking forward your coming back to this topic!\n\nCheers,\n                               Nicolas",
    "created_at": "2013-10-30T19:49:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108887",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:130'></a>
Replying to [stumpc5](#comment%3A128):
> I don't remember why I am the owner of this patch, but let me congratulate that you finally got it positively reviewed!

Thanks!

> My main motivation for implementing stuff in Sage was that I wanted to work on #11187. But I accidentally built it on top of this patch, so I never finished it, and it never made it into main Sage. I hope to find the motivation for working it out again!

Yeah, I am sorry for all the good features that have been postponed forever due to this patch; I paid the price myself and know how frustrating this could be! But now I am looking forward your coming back to this topic!

Cheers,
                               Nicolas



---

archive/issue_comments_108888.json:
```json
{
    "body": "<a id='comment:1'></a>\n\n```\n-class BialgebrasWithBasis(Category_over_base_ring):\n+def BialgebrasWithBasis(base_ring):\n     \"\"\"\n-    The category of bialgebras with a distinguished basis\n+    The category of finite dimensional coalgebras with a distinguished basis\n```\nShouldn't the \"coalgebras\" still be \"bialgebras\"?\n\nSimilarly:\n\n```\n-class GradedBialgebras(Category_over_base_ring):\n+def GradedBialgebras(base_ring):\n     \"\"\"\n-    The category of bialgebras with several bases\n+    The category of finite dimensional coalgebras with a distinguished basis\n```\nAlso, not sure where the \"finite dimensional\" has come from...",
    "created_at": "2013-10-31T06:13:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108888",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:1'></a>

```
-class BialgebrasWithBasis(Category_over_base_ring):
+def BialgebrasWithBasis(base_ring):
     """
-    The category of bialgebras with a distinguished basis
+    The category of finite dimensional coalgebras with a distinguished basis
```
Shouldn't the "coalgebras" still be "bialgebras"?

Similarly:

```
-class GradedBialgebras(Category_over_base_ring):
+def GradedBialgebras(base_ring):
     """
-    The category of bialgebras with several bases
+    The category of finite dimensional coalgebras with a distinguished basis
```
Also, not sure where the "finite dimensional" has come from...



---

archive/issue_events_085463.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-10-31T08:33:48Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85463"
}
```



---

archive/issue_events_085464.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-10-31T08:33:48Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85464"
}
```



---

archive/issue_events_085465.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-10-31T08:33:48Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "milestone": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85465"
}
```



---

archive/issue_comments_108889.json:
```json
{
    "body": "<a id='comment:2'></a>\nVarious changes/comments after positive_review => please review",
    "created_at": "2013-10-31T08:33:48Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108889",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>
Various changes/comments after positive_review => please review



---

archive/issue_comments_108890.json:
```json
{
    "body": "<a id='comment:3'></a>\nThanks Darij for spotting this. I uploaded a new version of the patch that fixes those and a couple others. Here is the patch diff:\n\n```\n@@ -2099,8 +2102,7 @@ diff --git a/sage/categories/bialgebras_\n -class BialgebrasWithBasis(Category_over_base_ring):\n +def BialgebrasWithBasis(base_ring):\n      \"\"\"\n--    The category of bialgebras with a distinguished basis\n-+    The category of finite dimensional coalgebras with a distinguished basis\n+     The category of bialgebras with a distinguished basis\n  \n      EXAMPLES::\n  \n@@ -7273,8 +7275,7 @@ diff --git a/sage/categories/finite_dime\n -class FiniteDimensionalBialgebrasWithBasis(Category_over_base_ring):\n +def FiniteDimensionalBialgebrasWithBasis(base_ring):\n      \"\"\"\n--    The category of finite dimensional bialgebras with a distinguished basis\n-+    The category of finite dimensional coalgebras with a distinguished basis\n+     The category of finite dimensional bialgebras with a distinguished basis\n  \n      EXAMPLES::\n  \n@@ -8366,7 +8367,7 @@ diff --git a/sage/categories/graded_bial\n +def GradedBialgebras(base_ring):\n      \"\"\"\n -    The category of bialgebras with several bases\n-+    The category of finite dimensional coalgebras with a distinguished basis\n++    The category of graded bialgebras\n  \n      EXAMPLES::\n  \n...skipping...\n+     The category of graded coalgebras\n  \n      EXAMPLES::\n  \n@@ -8608,7 +8607,7 @@ diff --git a/sage/categories/graded_hopf\n +def GradedHopfAlgebras(base_ring):\n      \"\"\"\n -    The category of GradedHopf algebras with several bases\n-+    The category of graded coalgebras with a distinguished basis\n++    The category of graded Hopf algebras\n  \n      EXAMPLES::\n  \n@@ -15116,7 +15115,7 @@ diff --git a/sage/categories/with_realiz\n diff --git a/sage/combinat/all.py b/sage/combinat/all.py\n --- a/sage/combinat/all.py\n +++ b/sage/combinat/all.py\n-@@ -135,6 +135,8 @@ from cluster_algebra_quiver.all import *\n+@@ -133,6 +133,8 @@ from cluster_algebra_quiver.all import *\n  \n  #import lrcalc\n  \n@@ -15205,15 +15204,15 @@ diff --git a/sage/combinat/free_module.p\n diff --git a/sage/combinat/integer_vector_weighted.py b/sage/combinat/integer_vector_weighted.py\n --- a/sage/combinat/integer_vector_weighted.py\n +++ b/sage/combinat/integer_vector_weighted.py\n-@@ -261,7 +261,7 @@ class WeightedIntegerVectors_all(Disjoin\n- \n-             sage: C = WeightedIntegerVectors([2,1,3])\n+@@ -120,7 +120,7 @@ class WeightedIntegerVectors_all(Disjoin\n+             sage: C.__class__\n+             <class 'sage.combinat.integer_vector_weighted.WeightedIntegerVectors_all_with_category'>\n              sage: C.category()\n -            Join of Category of infinite enumerated sets and Category of sets with grading\n +            Join of Category of sets with grading and Category of infinite enumerated sets\n              sage: TestSuite(C).run()\n          \"\"\"\n-         self._weights = weight\n+         self._weights = weights\n```",
    "created_at": "2013-10-31T09:43:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108890",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:3'></a>
Thanks Darij for spotting this. I uploaded a new version of the patch that fixes those and a couple others. Here is the patch diff:

```
@@ -2099,8 +2102,7 @@ diff --git a/sage/categories/bialgebras_
 -class BialgebrasWithBasis(Category_over_base_ring):
 +def BialgebrasWithBasis(base_ring):
      """
--    The category of bialgebras with a distinguished basis
-+    The category of finite dimensional coalgebras with a distinguished basis
+     The category of bialgebras with a distinguished basis
  
      EXAMPLES::
  
@@ -7273,8 +7275,7 @@ diff --git a/sage/categories/finite_dime
 -class FiniteDimensionalBialgebrasWithBasis(Category_over_base_ring):
 +def FiniteDimensionalBialgebrasWithBasis(base_ring):
      """
--    The category of finite dimensional bialgebras with a distinguished basis
-+    The category of finite dimensional coalgebras with a distinguished basis
+     The category of finite dimensional bialgebras with a distinguished basis
  
      EXAMPLES::
  
@@ -8366,7 +8367,7 @@ diff --git a/sage/categories/graded_bial
 +def GradedBialgebras(base_ring):
      """
 -    The category of bialgebras with several bases
-+    The category of finite dimensional coalgebras with a distinguished basis
++    The category of graded bialgebras
  
      EXAMPLES::
  
...skipping...
+     The category of graded coalgebras
  
      EXAMPLES::
  
@@ -8608,7 +8607,7 @@ diff --git a/sage/categories/graded_hopf
 +def GradedHopfAlgebras(base_ring):
      """
 -    The category of GradedHopf algebras with several bases
-+    The category of graded coalgebras with a distinguished basis
++    The category of graded Hopf algebras
  
      EXAMPLES::
  
@@ -15116,7 +15115,7 @@ diff --git a/sage/categories/with_realiz
 diff --git a/sage/combinat/all.py b/sage/combinat/all.py
 --- a/sage/combinat/all.py
 +++ b/sage/combinat/all.py
-@@ -135,6 +135,8 @@ from cluster_algebra_quiver.all import *
+@@ -133,6 +133,8 @@ from cluster_algebra_quiver.all import *
  
  #import lrcalc
  
@@ -15205,15 +15204,15 @@ diff --git a/sage/combinat/free_module.p
 diff --git a/sage/combinat/integer_vector_weighted.py b/sage/combinat/integer_vector_weighted.py
 --- a/sage/combinat/integer_vector_weighted.py
 +++ b/sage/combinat/integer_vector_weighted.py
-@@ -261,7 +261,7 @@ class WeightedIntegerVectors_all(Disjoin
- 
-             sage: C = WeightedIntegerVectors([2,1,3])
+@@ -120,7 +120,7 @@ class WeightedIntegerVectors_all(Disjoin
+             sage: C.__class__
+             <class 'sage.combinat.integer_vector_weighted.WeightedIntegerVectors_all_with_category'>
              sage: C.category()
 -            Join of Category of infinite enumerated sets and Category of sets with grading
 +            Join of Category of sets with grading and Category of infinite enumerated sets
              sage: TestSuite(C).run()
          """
-         self._weights = weight
+         self._weights = weights
```



---

archive/issue_comments_108891.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -42,8 +42,10 @@\n \n Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.\n \n+This ticket is dedicated to the town of Megantic where I was so warmly welcomed and a good chunk of this ticket got implemented!\n+\n Apply:\n \n-* [attachment:trac_10963-more_functorial_constructions-nt-refreshed.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt-refreshed.patch)\n+* [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)\n * [attachment:trac_10963_doctest_correction-fc.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963_doctest_correction-fc.patch)\n * [attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch)\n``````\n",
    "created_at": "2013-10-31T09:45:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108891",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -42,8 +42,10 @@
 
 Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.
 
+This ticket is dedicated to the town of Megantic where I was so warmly welcomed and a good chunk of this ticket got implemented!
+
 Apply:
 
-* [attachment:trac_10963-more_functorial_constructions-nt-refreshed.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt-refreshed.patch)
+* [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)
 * [attachment:trac_10963_doctest_correction-fc.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963_doctest_correction-fc.patch)
 * [attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch)
``````




---

archive/issue_comments_108892.json:
```json
{
    "body": "<a id='comment:5'></a>\nAll long tests passed for me on 5.12.beta1, except for one of those random failures:\n\n```\nsage -t --long devel/sage/sage/schemes/toric/weierstrass_covering.py\n**********************************************************************\nFile \"devel/sage/sage/schemes/toric/weierstrass_covering.py\", line 72, in sage.schemes.toric.weierstrass_covering\nFailed example:\n    P2_112 = toric_varieties.P2_112()\nExpected nothing\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x194e398> ignored\n```\n\nAs for the patchbot failure, it's due to a wrong order in the application of the patches. Someone knows how to fix this?",
    "created_at": "2013-11-01T08:48:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108892",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>
All long tests passed for me on 5.12.beta1, except for one of those random failures:

```
sage -t --long devel/sage/sage/schemes/toric/weierstrass_covering.py
**********************************************************************
File "devel/sage/sage/schemes/toric/weierstrass_covering.py", line 72, in sage.schemes.toric.weierstrass_covering
Failed example:
    P2_112 = toric_varieties.P2_112()
Expected nothing
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x194e398> ignored
```

As for the patchbot failure, it's due to a wrong order in the application of the patches. Someone knows how to fix this?



---

archive/issue_comments_108893.json:
```json
{
    "body": "<a id='comment:6'></a>\nhttp://sage.math.washington.edu/home/nthiery/trac_10963_doctest_correction-fc.patch-testlog",
    "created_at": "2013-11-01T08:50:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108893",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>
http://sage.math.washington.edu/home/nthiery/trac_10963_doctest_correction-fc.patch-testlog



---

archive/issue_comments_108894.json:
```json
{
    "body": "<a id='comment:137'></a>\nReplying to [nthiery](#comment%3A135):\n> All long tests passed for me on 5.12.beta1, except for one of those random failures:\n> \n> ```\n> sage -t --long devel/sage/sage/schemes/toric/weierstrass_covering.py\n> **********************************************************************\n> File \"devel/sage/sage/schemes/toric/weierstrass_covering.py\", line 72, in sage.schemes.toric.weierstrass_covering\n> Failed example:\n>     P2_112 = toric_varieties.P2_112()\n> Expected nothing\n> Got:\n>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x194e398> ignored\n> ```\n\nThat's bad and needs to be fixed.\n\nCan you test whether #13394 fixes it? I am pretty confident that it does.\n\n> As for the patchbot failure, it's due to a wrong order in the application of the patches. Someone knows how to fix this?\n\nGive the order by saying \"apply: patch1 patch2 patch3\" in some comment, and then kick the patchbot?",
    "created_at": "2013-11-01T10:32:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108894",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:137'></a>
Replying to [nthiery](#comment%3A135):
> All long tests passed for me on 5.12.beta1, except for one of those random failures:
> 
> ```
> sage -t --long devel/sage/sage/schemes/toric/weierstrass_covering.py
> **********************************************************************
> File "devel/sage/sage/schemes/toric/weierstrass_covering.py", line 72, in sage.schemes.toric.weierstrass_covering
> Failed example:
>     P2_112 = toric_varieties.P2_112()
> Expected nothing
> Got:
>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <function remove at 0x194e398> ignored
> ```

That's bad and needs to be fixed.

Can you test whether #13394 fixes it? I am pretty confident that it does.

> As for the patchbot failure, it's due to a wrong order in the application of the patches. Someone knows how to fix this?

Give the order by saying "apply: patch1 patch2 patch3" in some comment, and then kick the patchbot?



---

archive/issue_comments_108895.json:
```json
{
    "body": "<a id='comment:8'></a>\nCould you export a mercurial patch for #13394 for me? I only have an old version of the sage-git dev tools under hand right now ...\n\nApply: :attachment:trac_10963-more_functorial_constructions-nt.patch :attachment:trac_10963_doctest_correction-fc.patch :attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch\n\n(redundant with the description ...)",
    "created_at": "2013-11-02T07:43:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108895",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:8'></a>
Could you export a mercurial patch for #13394 for me? I only have an old version of the sage-git dev tools under hand right now ...

Apply: :attachment:trac_10963-more_functorial_constructions-nt.patch :attachment:trac_10963_doctest_correction-fc.patch :attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch

(redundant with the description ...)



---

archive/issue_comments_108896.json:
```json
{
    "body": "Diff patch for #13394---just to test whether #13394 fixes some issues here",
    "created_at": "2013-11-02T08:35:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108896",
    "user": "https://github.com/simon-king-jena"
}
```

Diff patch for #13394---just to test whether #13394 fixes some issues here



---

archive/attachments_014901.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "trac13394.patch",
    "asset_url": "tarball://root/attachments/ticket10963/trac13394.patch",
    "created_at": "2013-11-02T08:39:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket10963/trac13394.patch",
    "user": "https://github.com/simon-king-jena"
}
```



---

archive/issue_comments_108897.json:
```json
{
    "body": "<a id='comment:139'></a>\n**Attachment:** [trac13394.patch](https://github.com/sagemath/sage/files/ticket10963/trac13394.patch)\n\nReplying to [nthiery](#comment%3A138):\n> Could you export a mercurial patch for #13394 for me? I only have an old version of the sage-git dev tools under hand right now ...\n\nSee [attachment:trac13394.patch](https://github.com/sagemath/sage/files/ticket10963/trac13394.patch). It is a diff patch, hence, it does not contain the commit messages of the separate commits.\n\nHence, you may try to apply it, and then do what the patchbot should do:\n\napply trac_10963-more_functorial_constructions-nt.patch trac_10963_doctest_correction-fc.patch trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch",
    "created_at": "2013-11-02T08:39:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108897",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:139'></a>
**Attachment:** [trac13394.patch](https://github.com/sagemath/sage/files/ticket10963/trac13394.patch)

Replying to [nthiery](#comment%3A138):
> Could you export a mercurial patch for #13394 for me? I only have an old version of the sage-git dev tools under hand right now ...

See [attachment:trac13394.patch](https://github.com/sagemath/sage/files/ticket10963/trac13394.patch). It is a diff patch, hence, it does not contain the commit messages of the separate commits.

Hence, you may try to apply it, and then do what the patchbot should do:

apply trac_10963-more_functorial_constructions-nt.patch trac_10963_doctest_correction-fc.patch trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch



---

archive/issue_comments_108898.json:
```json
{
    "body": "<a id='comment:0'></a>\nPS: Note the different folder layout: In the diff patch for #13394, we have `$SAGE_ROOT/src/sage`. So, it could be that you need to tell mercurial *how* to apply my diff patch...\n\nAnyway, it seems that I can apply your patch to my git repository.",
    "created_at": "2013-11-02T08:52:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108898",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
PS: Note the different folder layout: In the diff patch for #13394, we have `$SAGE_ROOT/src/sage`. So, it could be that you need to tell mercurial *how* to apply my diff patch...

Anyway, it seems that I can apply your patch to my git repository.



---

archive/issue_comments_108899.json:
```json
{
    "body": "<a id='comment:1'></a>\nSpoke to soon. It appears that I have not been able to import your patches, even though git did not give errors.",
    "created_at": "2013-11-02T08:57:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108899",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Spoke to soon. It appears that I have not been able to import your patches, even though git did not give errors.



---

archive/issue_comments_108900.json:
```json
{
    "body": "<a id='comment:2'></a>\nToo bad. I needed to change filenames a lot, but then I still obtain\n\n```\nerror: Anwendung des Patches fehlgeschlagen: src/doc/en/reference/categories/index.rst:127\nerror: src/doc/en/reference/categories/index.rst: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/algebras/group_algebra_new.py:143\nerror: src/sage/algebras/group_algebra_new.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/categories/algebras.py:67\nerror: src/sage/categories/algebras.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/categories/algebras_with_basis.py:122\nerror: src/sage/categories/algebras_with_basis.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/categories/category.py:106\nerror: src/sage/categories/category.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/categories/coalgebras_with_basis.py:3\nerror: src/sage/categories/coalgebras_with_basis.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/categories/commutative_rings.py:5\nerror: src/sage/categories/commutative_rings.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/categories/groups.py:430\nerror: src/sage/categories/groups.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/categories/infinite_enumerated_sets.py:31\nerror: src/sage/categories/infinite_enumerated_sets.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/categories/rngs.py:3\nerror: src/sage/categories/rngs.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/combinat/debruijn_sequence.pyx:287\nerror: src/sage/combinat/debruijn_sequence.pyx: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/rings/finite_rings/integer_mod_ring.py:259\nerror: src/sage/rings/finite_rings/integer_mod_ring.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/schemes/generic/morphism.py:268\nerror: src/sage/schemes/generic/morphism.py: Patch konnte nicht angewendet werden\nerror: Anwendung des Patches fehlgeschlagen: src/sage/structure/parent.pyx:293\nerror: src/sage/structure/parent.pyx: Patch konnte nicht angewendet werden\n```\nNeed to see what is happening.",
    "created_at": "2013-11-02T09:06:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108900",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Too bad. I needed to change filenames a lot, but then I still obtain

```
error: Anwendung des Patches fehlgeschlagen: src/doc/en/reference/categories/index.rst:127
error: src/doc/en/reference/categories/index.rst: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/algebras/group_algebra_new.py:143
error: src/sage/algebras/group_algebra_new.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/categories/algebras.py:67
error: src/sage/categories/algebras.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/categories/algebras_with_basis.py:122
error: src/sage/categories/algebras_with_basis.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/categories/category.py:106
error: src/sage/categories/category.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/categories/coalgebras_with_basis.py:3
error: src/sage/categories/coalgebras_with_basis.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/categories/commutative_rings.py:5
error: src/sage/categories/commutative_rings.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/categories/groups.py:430
error: src/sage/categories/groups.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/categories/infinite_enumerated_sets.py:31
error: src/sage/categories/infinite_enumerated_sets.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/categories/rngs.py:3
error: src/sage/categories/rngs.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/combinat/debruijn_sequence.pyx:287
error: src/sage/combinat/debruijn_sequence.pyx: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/rings/finite_rings/integer_mod_ring.py:259
error: src/sage/rings/finite_rings/integer_mod_ring.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/schemes/generic/morphism.py:268
error: src/sage/schemes/generic/morphism.py: Patch konnte nicht angewendet werden
error: Anwendung des Patches fehlgeschlagen: src/sage/structure/parent.pyx:293
error: src/sage/structure/parent.pyx: Patch konnte nicht angewendet werden
```
Need to see what is happening.



---

archive/issue_comments_108901.json:
```json
{
    "body": "<a id='comment:3'></a>\nThe following did not apply (clearly, because it mentions `weakref`, which is not used any longer because of #13394).\n\n```patch\ndiff a/src/sage/categories/category.py b/src/sage/categories/category.py\t(rejected hunks)\n@@ -106,66 +107,13 @@ from sage.structure.sage_object import S\n from sage.structure.unique_representation import UniqueRepresentation\n from sage.structure.dynamic_class import DynamicMetaclass, dynamic_class\n \n-from weakref import WeakValueDictionary\n-_join_cache = WeakValueDictionary()\n-\n-def _join(categories, as_list):\n-    \"\"\"\n-    This is an auxiliary function for :meth:`Category.join`\n-\n-    INPUT:\n-\n-    - ``categories``: A tuple (no list) of categories.\n-    - ``as_list`` (boolean): Whether or not the result should be represented as a list.\n-\n-    EXAMPLES::\n-\n-        sage: Category.join((Groups(), CommutativeAdditiveMonoids()))  # indirect doctest\n-        Join of Category of groups and Category of commutative additive monoids\n-        sage: Category.join((Modules(ZZ), FiniteFields()), as_list=True)\n-        [Category of finite fields, Category of modules over Integer Ring]\n-\n-    \"\"\"\n-    # Since Objects() is the top category, it is the neutral element of join\n-    if len(categories) == 0:\n-        from objects import Objects\n-        return Objects()\n-\n-    if not as_list:\n-        try:\n-            return _join_cache[categories]\n-        except KeyError:\n-            pass\n-\n-    # Ensure associativity by flattening JoinCategory's\n-    # Invariant: the super categories of a JoinCategory are not JoinCategories themselves\n-    categories = sum( (tuple(category._super_categories) if isinstance(category, JoinCategory) else (category,)\n-                       for category in categories), ())\n-\n-    # canonicalize, by removing redundant categories which are super\n-    # categories of others, and by sorting\n-    result = ()\n-    for category in categories:\n-        if any(cat.is_subcategory(category) for cat in result):\n-            continue\n-        result = tuple( cat for cat in result if not category.is_subcategory(cat) ) + (category,)\n-    result = tuple(sorted(result, key = category_sort_key, reverse=True))\n-    if as_list:\n-        return list(result)\n-    if len(result) == 1:\n-        out = _join_cache[categories] = result[0]\n-    else:\n-        out = _join_cache[categories] = JoinCategory(result)\n-    return out\n-\n-\n class Category(UniqueRepresentation, SageObject):\n     r\"\"\"\n     The base class for modeling mathematical categories, like for example:\n \n-    - Groups(): the category of groups\n-    - EuclideanRings(): the category of euclidean rings\n-    - VectorSpaces(QQ): the category of vector spaces over the field of rational\n+    - ``Groups()``: the category of groups\n+    - ``EuclideanDomains()``: the category of euclidean rings\n+    - ``VectorSpaces(QQ)``: the category of vector spaces over the field of rational\n \n     See :mod:`sage.categories.primer` for an introduction to\n     categories in Sage, their relevance, purpose and usage. The\n```\nDo I understand correctly that you want to remove the `_join_cache` weak value dictionary and the `def _join` function entirely?",
    "created_at": "2013-11-02T09:23:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108901",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
The following did not apply (clearly, because it mentions `weakref`, which is not used any longer because of #13394).

```patch
diff a/src/sage/categories/category.py b/src/sage/categories/category.py	(rejected hunks)
@@ -106,66 +107,13 @@ from sage.structure.sage_object import S
 from sage.structure.unique_representation import UniqueRepresentation
 from sage.structure.dynamic_class import DynamicMetaclass, dynamic_class
 
-from weakref import WeakValueDictionary
-_join_cache = WeakValueDictionary()
-
-def _join(categories, as_list):
-    """
-    This is an auxiliary function for :meth:`Category.join`
-
-    INPUT:
-
-    - ``categories``: A tuple (no list) of categories.
-    - ``as_list`` (boolean): Whether or not the result should be represented as a list.
-
-    EXAMPLES::
-
-        sage: Category.join((Groups(), CommutativeAdditiveMonoids()))  # indirect doctest
-        Join of Category of groups and Category of commutative additive monoids
-        sage: Category.join((Modules(ZZ), FiniteFields()), as_list=True)
-        [Category of finite fields, Category of modules over Integer Ring]
-
-    """
-    # Since Objects() is the top category, it is the neutral element of join
-    if len(categories) == 0:
-        from objects import Objects
-        return Objects()
-
-    if not as_list:
-        try:
-            return _join_cache[categories]
-        except KeyError:
-            pass
-
-    # Ensure associativity by flattening JoinCategory's
-    # Invariant: the super categories of a JoinCategory are not JoinCategories themselves
-    categories = sum( (tuple(category._super_categories) if isinstance(category, JoinCategory) else (category,)
-                       for category in categories), ())
-
-    # canonicalize, by removing redundant categories which are super
-    # categories of others, and by sorting
-    result = ()
-    for category in categories:
-        if any(cat.is_subcategory(category) for cat in result):
-            continue
-        result = tuple( cat for cat in result if not category.is_subcategory(cat) ) + (category,)
-    result = tuple(sorted(result, key = category_sort_key, reverse=True))
-    if as_list:
-        return list(result)
-    if len(result) == 1:
-        out = _join_cache[categories] = result[0]
-    else:
-        out = _join_cache[categories] = JoinCategory(result)
-    return out
-
-
 class Category(UniqueRepresentation, SageObject):
     r"""
     The base class for modeling mathematical categories, like for example:
 
-    - Groups(): the category of groups
-    - EuclideanRings(): the category of euclidean rings
-    - VectorSpaces(QQ): the category of vector spaces over the field of rational
+    - ``Groups()``: the category of groups
+    - ``EuclideanDomains()``: the category of euclidean rings
+    - ``VectorSpaces(QQ)``: the category of vector spaces over the field of rational
 
     See :mod:`sage.categories.primer` for an introduction to
     categories in Sage, their relevance, purpose and usage. The
```
Do I understand correctly that you want to remove the `_join_cache` weak value dictionary and the `def _join` function entirely?



---

archive/issue_comments_108902.json:
```json
{
    "body": "<a id='comment:4'></a>\nTo be precise: I notice that there is a module level _join_cache and a _join_cache that appears to be an attribute of `Category`. You want to remove the module level cache, but not the class level cache, right?",
    "created_at": "2013-11-02T09:26:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108902",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
To be precise: I notice that there is a module level _join_cache and a _join_cache that appears to be an attribute of `Category`. You want to remove the module level cache, but not the class level cache, right?



---

archive/issue_comments_108903.json:
```json
{
    "body": "<a id='comment:5'></a>\nI think I managed to turn your patches into a git branch on top of #13394. But I'll run tests before I push it to Trac.",
    "created_at": "2013-11-02T09:44:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108903",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
I think I managed to turn your patches into a git branch on top of #13394. But I'll run tests before I push it to Trac.



---

archive/issue_comments_108904.json:
```json
{
    "body": "<a id='comment:146'></a>\nReplying to [SimonKing](#comment%3A145):\n> I think I managed to turn your patches into a git branch on top of #13394. But I'll run tests before I push it to Trac.\n\nMeanwhile I have put a \"proper\" mercurial patch to #13394, so that\n1. there might be a chance to get this into Sage before version 6.0\n2. you can easily get the patch from #13394 and can test if everything works. I did test, and all tests pass for me.\n\nQuestion: Shall I create a git branch for this ticket and push it? Or do you want to keep it in the mercurial world (which means it might be mergeable before 6.0)?",
    "created_at": "2013-11-02T12:00:58Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108904",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:146'></a>
Replying to [SimonKing](#comment%3A145):
> I think I managed to turn your patches into a git branch on top of #13394. But I'll run tests before I push it to Trac.

Meanwhile I have put a "proper" mercurial patch to #13394, so that
1. there might be a chance to get this into Sage before version 6.0
2. you can easily get the patch from #13394 and can test if everything works. I did test, and all tests pass for me.

Question: Shall I create a git branch for this ticket and push it? Or do you want to keep it in the mercurial world (which means it might be mergeable before 6.0)?



---

archive/issue_comments_108905.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394\".",
    "created_at": "2013-11-03T08:54:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108905",
    "user": "https://github.com/nthiery"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394".



---

archive/attachments_014902.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "trac_10963-more_functorial_constructions-nt.patch",
    "asset_url": "tarball://root/attachments/ticket10963/trac_10963-more_functorial_constructions-nt.patch",
    "created_at": "2013-11-03T08:54:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch",
    "user": "https://github.com/nthiery"
}
```



---

archive/issue_comments_108906.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Attachment:** [trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)\n\nI just ran all tests on sage-5.12 with #13394 applied, and they all passed! Yippee! Thanks Simon! I am running them on 5.13.beta1.\n\nI have reuploaded the main patch here after the trivial rebase upon #13394 you mentionned (indeed, _join_cache is now only an attribute of Category), and added #13394 as dependency.\nIf the patchbot goes back to green, and you confirm that you agree with :attachment:\ntrac_10963-more_functorial_constructions-graded-modules-fix-nt.patch\u200b, then this ticket can go back to positive review I guess.\n\nCheers,\n                                         Nicolas",
    "created_at": "2013-11-03T08:54:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108906",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:7'></a>
**Attachment:** [trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)

I just ran all tests on sage-5.12 with #13394 applied, and they all passed! Yippee! Thanks Simon! I am running them on 5.13.beta1.

I have reuploaded the main patch here after the trivial rebase upon #13394 you mentionned (indeed, _join_cache is now only an attribute of Category), and added #13394 as dependency.
If the patchbot goes back to green, and you confirm that you agree with :attachment:
trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch​, then this ticket can go back to positive review I guess.

Cheers,
                                         Nicolas



---

archive/issue_comments_108907.json:
```json
{
    "body": "<a id='comment:8'></a>\nAll tests passed on 5.13.beta1 with the following patches applied:\n\n```\ntrac_15237-fix_crystals_graphviz-ts.patch\ntrac_9290-geometric_coxeter_groups-ts.patch\ntrac-9290-review.patch\ntrac_15195-family_cardinality-ts.patch\ntrac_15309-sga_alg_gens_fix-ts.patch\ntrac_10358-oeis-tm_rebase.patch\ntrac_10358-oeis-review_1-tm.patch\ntrac_10358-oeis-review_2-tm.patch\ntrac_10358-oeis-review_3-nc-tm.patch\ntrac13394-weak_value_dictionary.patch\ntrac_10963-more_functorial_constructions-nt.patch\ntrac_10963-more_functorial_constructions-graded-modules-fix-nt.patch\ntrac_10963_doctest_correction-fc.patch\n```",
    "created_at": "2013-11-03T08:55:06Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108907",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:8'></a>
All tests passed on 5.13.beta1 with the following patches applied:

```
trac_15237-fix_crystals_graphviz-ts.patch
trac_9290-geometric_coxeter_groups-ts.patch
trac-9290-review.patch
trac_15195-family_cardinality-ts.patch
trac_15309-sga_alg_gens_fix-ts.patch
trac_10358-oeis-tm_rebase.patch
trac_10358-oeis-review_1-tm.patch
trac_10358-oeis-review_2-tm.patch
trac_10358-oeis-review_3-nc-tm.patch
trac13394-weak_value_dictionary.patch
trac_10963-more_functorial_constructions-nt.patch
trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch
trac_10963_doctest_correction-fc.patch
```



---

archive/issue_comments_108908.json:
```json
{
    "body": "<a id='comment:9'></a>\nNote: I haven't pushed the latest version of the patch and #13394 on the sage-combinat queue yet, for #13394 triggers quite a bit of recompilation.",
    "created_at": "2013-11-03T08:56:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108908",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:9'></a>
Note: I haven't pushed the latest version of the patch and #13394 on the sage-combinat queue yet, for #13394 triggers quite a bit of recompilation.



---

archive/issue_comments_108909.json:
```json
{
    "body": "<a id='comment:150'></a>\nReplying to [nthiery](#comment%3A149):\n> Note: I haven't pushed the latest version of the patch and #13394 on the sage-combinat queue yet, for #13394 triggers quite a bit of recompilation.\n\nHow can this be? #13394 does not touch any pxd-file at all.\n\nAnyway, good news that it helps fixing some troubles!",
    "created_at": "2013-11-03T09:38:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108909",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:150'></a>
Replying to [nthiery](#comment%3A149):
> Note: I haven't pushed the latest version of the patch and #13394 on the sage-combinat queue yet, for #13394 triggers quite a bit of recompilation.

How can this be? #13394 does not touch any pxd-file at all.

Anyway, good news that it helps fixing some troubles!



---

archive/issue_comments_108910.json:
```json
{
    "body": "<a id='comment:151'></a>\nReplying to [SimonKing](#comment%3A150):\n> Replying to [nthiery](#comment%3A149):\n> > Note: I haven't pushed the latest version of the patch and #13394 on the sage-combinat queue yet, for #13394 triggers quite a bit of recompilation.\n\n> \n> How can this be? #13394 does not touch any pxd-file at all.\n\nIndeed; actually you are right, it seemed like a lot but in fact it's just because it was for #10963 and #13394 together; the overhead of #13394 is minor. I am about to push.\n\nCheers,",
    "created_at": "2013-11-03T09:51:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108910",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:151'></a>
Replying to [SimonKing](#comment%3A150):
> Replying to [nthiery](#comment%3A149):
> > Note: I haven't pushed the latest version of the patch and #13394 on the sage-combinat queue yet, for #13394 triggers quite a bit of recompilation.

> 
> How can this be? #13394 does not touch any pxd-file at all.

Indeed; actually you are right, it seemed like a lot but in fact it's just because it was for #10963 and #13394 together; the overhead of #13394 is minor. I am about to push.

Cheers,



---

archive/issue_comments_108911.json:
```json
{
    "body": "<a id='comment:2'></a>\nfor the **patchbots**:\n\nappply trac_10963-more_functorial_constructions-nt.patch trac_10963_doctest_correction-fc.patch trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch",
    "created_at": "2013-11-04T10:20:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108911",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:2'></a>
for the **patchbots**:

appply trac_10963-more_functorial_constructions-nt.patch trac_10963_doctest_correction-fc.patch trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch



---

archive/issue_comments_108912.json:
```json
{
    "body": "<a id='comment:3'></a>\nfor the **patchbots**:\n\napply trac_10963-more_functorial_constructions-nt.patch trac_10963_doctest_correction-fc.patch trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch",
    "created_at": "2013-11-04T10:20:52Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108912",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:3'></a>
for the **patchbots**:

apply trac_10963-more_functorial_constructions-nt.patch trac_10963_doctest_correction-fc.patch trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch



---

archive/issue_comments_108913.json:
```json
{
    "body": "<a id='comment:4'></a>\nIt seems that this patch increases the memory usage in Sage. This used to pass, but now fails:\n\n```\n$ ulimit -v 2300000; ./sage -t --long devel/sage/sage/schemes/elliptic_curves/heegner.py\nRunning doctests with ID 2013-11-04-21-49-06-b972df36.\nDoctesting 1 file.\nsage -t --long devel/sage/sage/schemes/elliptic_curves/heegner.py\nProcess DocTestWorker-1:\nTraceback (most recent call last):\n  File \"/scratch/release/merger/sage-5.13.beta3/local/lib/python/multiprocessing/process.py\", line 258, in _bootstrap\n    self.run()\n  File \"/scratch/release/merger/sage-5.13.beta3/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 1802, in run\n    task(self.options, self.outtmpfile, msgpipe, self.result_queue)\n  File \"/scratch/release/merger/sage-5.13.beta3/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 2113, in __call__\n    result_queue.put(result, False)\n  File \"/scratch/release/merger/sage-5.13.beta3/local/lib/python/multiprocessing/queues.py\", line 107, in put\n    self._start_thread()\n  File \"/scratch/release/merger/sage-5.13.beta3/local/lib/python/multiprocessing/queues.py\", line 191, in _start_thread\n    self._thread.start()\n  File \"/scratch/release/merger/sage-5.13.beta3/local/lib/python/threading.py\", line 743, in start\n    _start_new_thread(self.__bootstrap, ())\nerror: can't start new thread\n    Bad exit: 1\n**********************************************************************\nTests run before process (pid=22245) failed:\nsage: E = EllipticCurve('433a') ## line 13 ##\nsage: P = E.heegner_point(-8,3) ## line 14 ##\nsage: z = P.point_exact(201); z ## line 15 ##\n(-4/3 : 1/27*a - 4/27 : 1)\n[...]\nsage: E.heegner_index(-8) ## line 6478 ##\nterminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n\n**********************************************************************\n----------------------------------------------------------------------\nsage -t --long devel/sage/sage/schemes/elliptic_curves/heegner.py  # Bad exit: 1\n----------------------------------------------------------------------\n```\n\nFor me, this doesn't imply needs_work, but somebody should at least confirm that this is normal and expected.",
    "created_at": "2013-11-04T20:52:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108913",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
It seems that this patch increases the memory usage in Sage. This used to pass, but now fails:

```
$ ulimit -v 2300000; ./sage -t --long devel/sage/sage/schemes/elliptic_curves/heegner.py
Running doctests with ID 2013-11-04-21-49-06-b972df36.
Doctesting 1 file.
sage -t --long devel/sage/sage/schemes/elliptic_curves/heegner.py
Process DocTestWorker-1:
Traceback (most recent call last):
  File "/scratch/release/merger/sage-5.13.beta3/local/lib/python/multiprocessing/process.py", line 258, in _bootstrap
    self.run()
  File "/scratch/release/merger/sage-5.13.beta3/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1802, in run
    task(self.options, self.outtmpfile, msgpipe, self.result_queue)
  File "/scratch/release/merger/sage-5.13.beta3/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 2113, in __call__
    result_queue.put(result, False)
  File "/scratch/release/merger/sage-5.13.beta3/local/lib/python/multiprocessing/queues.py", line 107, in put
    self._start_thread()
  File "/scratch/release/merger/sage-5.13.beta3/local/lib/python/multiprocessing/queues.py", line 191, in _start_thread
    self._thread.start()
  File "/scratch/release/merger/sage-5.13.beta3/local/lib/python/threading.py", line 743, in start
    _start_new_thread(self.__bootstrap, ())
error: can't start new thread
    Bad exit: 1
**********************************************************************
Tests run before process (pid=22245) failed:
sage: E = EllipticCurve('433a') ## line 13 ##
sage: P = E.heegner_point(-8,3) ## line 14 ##
sage: z = P.point_exact(201); z ## line 15 ##
(-4/3 : 1/27*a - 4/27 : 1)
[...]
sage: E.heegner_index(-8) ## line 6478 ##
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc

**********************************************************************
----------------------------------------------------------------------
sage -t --long devel/sage/sage/schemes/elliptic_curves/heegner.py  # Bad exit: 1
----------------------------------------------------------------------
```

For me, this doesn't imply needs_work, but somebody should at least confirm that this is normal and expected.



---

archive/issue_comments_108914.json:
```json
{
    "body": "<a id='comment:5'></a>\nThe lines around the error (line 6478) are\n\n```\n        sage: E = EllipticCurve([0, 0, 1, -34874, -2506691])\n        sage: E.heegner_index(-8)\n        Traceback (most recent call last):\n        ...\n        RuntimeError: ...\n```\nHence, we test against a runtime error with unspecified error message. Let us see which, and let us test the memory consumption.\n\nFirst, with the branch from #13394:\n\n```\nsage: get_memory_usage()\n190.30078125\nsage: E = EllipticCurve([0, 0, 1, -34874, -2506691])\nsage: get_memory_usage()\n190.7265625\nsage: E.heegner_index(-8)\nUnable to compute the rank with certainty (lower bound=0).\nThis could be because Sha(E/Q)[2] is nontrivial.\nTry calling something like two_descent(second_limit=13) on the\ncurve then trying this command again.  You could also try rank\nwith only_use_mwrank=False.\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\n...\nRuntimeError: Rank not provably correct.\nsage: get_memory_usage()\n193.0625\n```\nNow, with my local branch that I've created for the patch from here:\n\n```\nsage: get_memory_usage()\n191.50390625\nsage: E = EllipticCurve([0, 0, 1, -34874, -2506691])\nsage: get_memory_usage()\n191.6328125\nsage: E.heegner_index(-8)\n...\nRuntimeError: Rank not provably correct.\nsage: get_memory_usage()\n194.25390625\n```\nSo, it seems that the memory consumption has just increased by a constant amount. Also note that\n\n```\nulimit -v 2300000; ./sage -t --long src/sage/schemes/elliptic_curves/heegner.py \nRunning doctests with ID 2013-11-04-23-46-03-6fbd5fa5.\nDoctesting 1 file.\nsage -t --long src/sage/schemes/elliptic_curves/heegner.py\n    [1072 tests, 104.05 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 106.1 seconds\n    cpu time: 97.4 seconds\n    cumulative wall time: 104.0 seconds\n```\nworks for me. I'll try to decrease the memory limit.",
    "created_at": "2013-11-04T22:49:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108914",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
The lines around the error (line 6478) are

```
        sage: E = EllipticCurve([0, 0, 1, -34874, -2506691])
        sage: E.heegner_index(-8)
        Traceback (most recent call last):
        ...
        RuntimeError: ...
```
Hence, we test against a runtime error with unspecified error message. Let us see which, and let us test the memory consumption.

First, with the branch from #13394:

```
sage: get_memory_usage()
190.30078125
sage: E = EllipticCurve([0, 0, 1, -34874, -2506691])
sage: get_memory_usage()
190.7265625
sage: E.heegner_index(-8)
Unable to compute the rank with certainty (lower bound=0).
This could be because Sha(E/Q)[2] is nontrivial.
Try calling something like two_descent(second_limit=13) on the
curve then trying this command again.  You could also try rank
with only_use_mwrank=False.
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
...
RuntimeError: Rank not provably correct.
sage: get_memory_usage()
193.0625
```
Now, with my local branch that I've created for the patch from here:

```
sage: get_memory_usage()
191.50390625
sage: E = EllipticCurve([0, 0, 1, -34874, -2506691])
sage: get_memory_usage()
191.6328125
sage: E.heegner_index(-8)
...
RuntimeError: Rank not provably correct.
sage: get_memory_usage()
194.25390625
```
So, it seems that the memory consumption has just increased by a constant amount. Also note that

```
ulimit -v 2300000; ./sage -t --long src/sage/schemes/elliptic_curves/heegner.py 
Running doctests with ID 2013-11-04-23-46-03-6fbd5fa5.
Doctesting 1 file.
sage -t --long src/sage/schemes/elliptic_curves/heegner.py
    [1072 tests, 104.05 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 106.1 seconds
    cpu time: 97.4 seconds
    cumulative wall time: 104.0 seconds
```
works for me. I'll try to decrease the memory limit.



---

archive/issue_comments_108915.json:
```json
{
    "body": "<a id='comment:6'></a>\nThanks Jeroen for reporting the issue!\n\nThanks Simon for investigating!\n\nWe certainly should investigate this further later on, but as Jeroen mentions it's not critical. Simon, could you double check the little patch :attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch\u200b, and then I guess we can go back to positive review and get this ticket merged!",
    "created_at": "2013-11-06T13:29:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108915",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>
Thanks Jeroen for reporting the issue!

Thanks Simon for investigating!

We certainly should investigate this further later on, but as Jeroen mentions it's not critical. Simon, could you double check the little patch :attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch​, and then I guess we can go back to positive review and get this ticket merged!



---

archive/issue_comments_108916.json:
```json
{
    "body": "<a id='comment:157'></a>\nReplying to [nthiery](#comment%3A156):\n> Thanks Jeroen for reporting the issue!\n> \n> Thanks Simon for investigating!\n> \n> We certainly should investigate this further later on, but as Jeroen mentions it's not critical. Simon, could you double check the little patch :attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch\u200b, and then I guess we can go back to positive review and get this ticket merged!\n\nDo I understand correctly: This is not a new patch, but replaces an old patch? How does it differ?",
    "created_at": "2013-11-06T15:42:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108916",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:157'></a>
Replying to [nthiery](#comment%3A156):
> Thanks Jeroen for reporting the issue!
> 
> Thanks Simon for investigating!
> 
> We certainly should investigate this further later on, but as Jeroen mentions it's not critical. Simon, could you double check the little patch :attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch​, and then I guess we can go back to positive review and get this ticket merged!

Do I understand correctly: This is not a new patch, but replaces an old patch? How does it differ?



---

archive/issue_comments_108917.json:
```json
{
    "body": "<a id='comment:8'></a>\nAgain, if I understand correctly, I have tested stuff with these three patches from here applied (after moving it to git). My git log starting with the master branch is this:\n\n```\n*   660f126 - (HEAD, ticket/10963) Merge branch 'ticket/13394' into ticket/10963, because one commit has been added there (vor 4 Tagen) <Simon King>\n|\\  \n| * 11bd210 - Remove some trailing whitespace (vor 4 Tagen) <Simon King>\n* | d0ffcfa - Trac #10963: More functorial constructions (fix graded modules with basis) (vor 4 Tagen) <Nicolas M. Thiery>\n* | 1d8f75a - Trac #10963: doctests corrections (vor 4 Tagen) <Frederic Chapoton>\n* | b700f98 - Trac #10963: More functorial constructions (vor 4 Tagen) <Nicolas M. Thiery>\n|/  \n* 1a12ce6 - Fix some typos. Better tests for WeakValueDict iteration guard. (vor 5 Tagen) <Simon King>\n* e60890e - Add direct and indirect stresstests for the weak value callbacks (vor 6 Tagen) <Simon King>\n* 851cc95 - Avoid some pointer casts in WeakValueDict callbacks (vor 6 Tagen) <Simon King>\n* 246518f - Use <dict>'s internals in WeakValueDictionary and do not reinvent the bucket. (vor 6 Tagen) <Simon King>\n* fab0ed4 - Use WeakValueDict's iteration guard more consequently (vor 7 Tagen) <Simon King>\n* e4adaeb - Implement copy and deepcopy for WeakValueDictionary (vor 8 Tagen) <Simon King>\n* 70a7b8a - Guard WeakValueDictionary against deletions during iteration (vor 8 Tagen) <Simon King>\n* c3dba98 - Replace weakref.WeakValueDictionary by sage.misc.weak_dict.WeakValueDictionary (vor 9 Tagen) <Simon King>\n* 17b0236 - Documentation for WeakValueDictionary (vor 9 Tagen) <Simon King>\n* f0ed60f - Initial version of a safer and faster WeakValueDictionary (vor 9 Tagen) <Simon King>\n*   0d00bf7 - (trac/master, origin/master, origin/HEAD, master) Merge branch 'build_system' (vor 4 Wochen) <R. Andrew Ohana>\n```\nSo, if the \"graded module\" patch did not change since 4 days, then I did successfully test it (\"make ptest\"). Also, the changes seem reasonable to me.\n\nJeroen, would this be good enough (from your perspective) to put it back to positive review? I can not reproduce the memory problems you mentioned.",
    "created_at": "2013-11-06T15:49:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108917",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Again, if I understand correctly, I have tested stuff with these three patches from here applied (after moving it to git). My git log starting with the master branch is this:

```
*   660f126 - (HEAD, ticket/10963) Merge branch 'ticket/13394' into ticket/10963, because one commit has been added there (vor 4 Tagen) <Simon King>
|\  
| * 11bd210 - Remove some trailing whitespace (vor 4 Tagen) <Simon King>
* | d0ffcfa - Trac #10963: More functorial constructions (fix graded modules with basis) (vor 4 Tagen) <Nicolas M. Thiery>
* | 1d8f75a - Trac #10963: doctests corrections (vor 4 Tagen) <Frederic Chapoton>
* | b700f98 - Trac #10963: More functorial constructions (vor 4 Tagen) <Nicolas M. Thiery>
|/  
* 1a12ce6 - Fix some typos. Better tests for WeakValueDict iteration guard. (vor 5 Tagen) <Simon King>
* e60890e - Add direct and indirect stresstests for the weak value callbacks (vor 6 Tagen) <Simon King>
* 851cc95 - Avoid some pointer casts in WeakValueDict callbacks (vor 6 Tagen) <Simon King>
* 246518f - Use <dict>'s internals in WeakValueDictionary and do not reinvent the bucket. (vor 6 Tagen) <Simon King>
* fab0ed4 - Use WeakValueDict's iteration guard more consequently (vor 7 Tagen) <Simon King>
* e4adaeb - Implement copy and deepcopy for WeakValueDictionary (vor 8 Tagen) <Simon King>
* 70a7b8a - Guard WeakValueDictionary against deletions during iteration (vor 8 Tagen) <Simon King>
* c3dba98 - Replace weakref.WeakValueDictionary by sage.misc.weak_dict.WeakValueDictionary (vor 9 Tagen) <Simon King>
* 17b0236 - Documentation for WeakValueDictionary (vor 9 Tagen) <Simon King>
* f0ed60f - Initial version of a safer and faster WeakValueDictionary (vor 9 Tagen) <Simon King>
*   0d00bf7 - (trac/master, origin/master, origin/HEAD, master) Merge branch 'build_system' (vor 4 Wochen) <R. Andrew Ohana>
```
So, if the "graded module" patch did not change since 4 days, then I did successfully test it ("make ptest"). Also, the changes seem reasonable to me.

Jeroen, would this be good enough (from your perspective) to put it back to positive review? I can not reproduce the memory problems you mentioned.



---

archive/issue_events_085466.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-06T20:23:00Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85466"
}
```



---

archive/issue_events_085467.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-06T20:23:00Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85467"
}
```



---

archive/issue_comments_108918.json:
```json
{
    "body": "<a id='comment:9'></a>\nThis happens sometimes:\n\n```\nsage -t --long devel/sage/sage/rings/function_field/function_field_element.pyx\n**********************************************************************\nFile \"devel/sage/sage/rings/function_field/function_field_element.pyx\", line 714, in sage.rings.function_field.function_field_element.FunctionFieldElement_rational.inverse_mod\nFailed example:\n    O = K.maximal_order(); I = O.ideal(x^2+1)\nExpected nothing\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x2421410> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n**********************************************************************\n```\nand\n\n```\nsage -t --long devel/sage/doc/en/constructions/elliptic_curves.rst\n**********************************************************************\nFile \"devel/sage/doc/en/constructions/elliptic_curves.rst\", line 72, in doc.en.constructions.elliptic_curves\nFailed example:\n    G = E.abelian_group()\nExpected nothing\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x8c71d0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x8c71d0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x8c71d0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x1781a98> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x8c71d0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n**********************************************************************\n```",
    "created_at": "2013-11-06T20:23:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108918",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:9'></a>
This happens sometimes:

```
sage -t --long devel/sage/sage/rings/function_field/function_field_element.pyx
**********************************************************************
File "devel/sage/sage/rings/function_field/function_field_element.pyx", line 714, in sage.rings.function_field.function_field_element.FunctionFieldElement_rational.inverse_mod
Failed example:
    O = K.maximal_order(); I = O.ideal(x^2+1)
Expected nothing
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x2421410> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
**********************************************************************
```
and

```
sage -t --long devel/sage/doc/en/constructions/elliptic_curves.rst
**********************************************************************
File "devel/sage/doc/en/constructions/elliptic_curves.rst", line 72, in doc.en.constructions.elliptic_curves
Failed example:
    G = E.abelian_group()
Expected nothing
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x8c71d0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x8c71d0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x8c71d0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x1781a98> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x8c71d0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
**********************************************************************
```



---

archive/issue_comments_108919.json:
```json
{
    "body": "<a id='comment:160'></a>\nReplying to [SimonKing](#comment%3A158):\n> So, if the \"graded module\" patch did not change since 4 days, then I did successfully test it (\"make ptest\"). Also, the changes seem reasonable to me.\n\nConfirmed: it's the original patch I uploaded 8 days ago.",
    "created_at": "2013-11-06T21:44:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108919",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:160'></a>
Replying to [SimonKing](#comment%3A158):
> So, if the "graded module" patch did not change since 4 days, then I did successfully test it ("make ptest"). Also, the changes seem reasonable to me.

Confirmed: it's the original patch I uploaded 8 days ago.



---

archive/issue_comments_108920.json:
```json
{
    "body": "<a id='comment:161'></a>\nReplying to [jdemeyer](#comment%3A159):\n>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored\n\nReally?? Blimey! The callback of the new `WeakValueDictionary` was supposed to be absolutely safe against this kind of problems. So, we need work...",
    "created_at": "2013-11-06T23:17:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108920",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:161'></a>
Replying to [jdemeyer](#comment%3A159):
>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x21e64d0> ignored

Really?? Blimey! The callback of the new `WeakValueDictionary` was supposed to be absolutely safe against this kind of problems. So, we need work...



---

archive/issue_comments_108921.json:
```json
{
    "body": "<a id='comment:162'></a>\nReplying to [jdemeyer](#comment%3A159):\n> This happens sometimes:\n> \n> ```\n>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored\n>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x2421410> ignored\n> ```\n\nLooks similar to #15069, so the most likely scenario is that there is a very complicated data structure that gets garbage collected and that the decref of something initiates a chain of subsequent decrefs that is more than 1000 deep.\n\nIt seems there are unresolved issues in python with this stuff. See [http://bugs.python.org/issue483469](http://bugs.python.org/issue483469) for an even worse (segmentation fault inducing!) problem with `__del__`. It looks like the python \"maximum recursion depth\" is avoided there via a similar trick to #15069, leading do a C-stack overflow as a result (hence the harder crash). Indeed:\n\n```\nsage: class A: pass\nsage: a=A(); prev=a;\nsage: from sage.structure.coerce_dict import MonoDict\nsage: M = MonoDict(11)\nsage: for i in range(10^5): newA = A(); M[prev] = newA; prev = newA\nsage: del a\nSegmentation fault \n```\n(the value `10^5` may need adjustment, depending on your C-stack), showing that with the fix on #15069 we only postpone the problem with some order of magnitudes, and get a worse problem instead.\n\nI suspect we're hitting here the same problem (note that for a `WeakValueDictionary` we have to chain in the other direction):\n\n```\nsage: a=A(); prev=a;\nsage: M=WeakValueDictionary()\nsage: for i in range(10^3+10): newA = A(); M[newA] = prev; prev = newA\nsage: del a\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x6a527d0> ignored\n```\nThis problem goes away if we instead define\n\n```\nsage: class A(object): pass\n```\nProbably, old-style objects do not participate in the \"trashcan\" but new-style objects do (see #13901 and [cython ticket#797](http://trac.cython.org/cython_trac/ticket/797); we need this on cython classes too), which flattens call-stacks during deallocation.\n\nThe problem also doesn't occur with `weakref.WeakValueDictionary`, probably also because there are sufficiently many general python structures involved to let the trashcan kick in.\n\nOddly enough, replacing `object` above by `SageObject` or `Parent` seems to also work, so the scenario we're running into is probably not exactly what described here.",
    "created_at": "2013-11-06T23:19:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108921",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:162'></a>
Replying to [jdemeyer](#comment%3A159):
> This happens sometimes:
> 
> ```
>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x17814b0> ignored
>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x2421410> ignored
> ```

Looks similar to #15069, so the most likely scenario is that there is a very complicated data structure that gets garbage collected and that the decref of something initiates a chain of subsequent decrefs that is more than 1000 deep.

It seems there are unresolved issues in python with this stuff. See [http://bugs.python.org/issue483469](http://bugs.python.org/issue483469) for an even worse (segmentation fault inducing!) problem with `__del__`. It looks like the python "maximum recursion depth" is avoided there via a similar trick to #15069, leading do a C-stack overflow as a result (hence the harder crash). Indeed:

```
sage: class A: pass
sage: a=A(); prev=a;
sage: from sage.structure.coerce_dict import MonoDict
sage: M = MonoDict(11)
sage: for i in range(10^5): newA = A(); M[prev] = newA; prev = newA
sage: del a
Segmentation fault 
```
(the value `10^5` may need adjustment, depending on your C-stack), showing that with the fix on #15069 we only postpone the problem with some order of magnitudes, and get a worse problem instead.

I suspect we're hitting here the same problem (note that for a `WeakValueDictionary` we have to chain in the other direction):

```
sage: a=A(); prev=a;
sage: M=WeakValueDictionary()
sage: for i in range(10^3+10): newA = A(); M[newA] = prev; prev = newA
sage: del a
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x6a527d0> ignored
```
This problem goes away if we instead define

```
sage: class A(object): pass
```
Probably, old-style objects do not participate in the "trashcan" but new-style objects do (see #13901 and [cython ticket#797](http://trac.cython.org/cython_trac/ticket/797); we need this on cython classes too), which flattens call-stacks during deallocation.

The problem also doesn't occur with `weakref.WeakValueDictionary`, probably also because there are sufficiently many general python structures involved to let the trashcan kick in.

Oddly enough, replacing `object` above by `SageObject` or `Parent` seems to also work, so the scenario we're running into is probably not exactly what described here.



---

archive/issue_comments_108922.json:
```json
{
    "body": "<a id='comment:4'></a>\nI must say that the error occurred only one time, I haven't been able to reproduce it.",
    "created_at": "2013-11-07T07:19:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108922",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
I must say that the error occurred only one time, I haven't been able to reproduce it.



---

archive/issue_comments_108923.json:
```json
{
    "body": "<a id='comment:5'></a>\nOn a different machine:\n\n```\nsage -t --long devel/sage/sage/categories/sets_cat.py\n**********************************************************************\nFile \"devel/sage/sage/categories/sets_cat.py\", line 188, in sage.categories.sets_cat.Sets\nFailed example:\n    TestSuite(Sets()).run()\nExpected nothing\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x26531d0> ignored\n**********************************************************************\n```",
    "created_at": "2013-11-07T07:21:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108923",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
On a different machine:

```
sage -t --long devel/sage/sage/categories/sets_cat.py
**********************************************************************
File "devel/sage/sage/categories/sets_cat.py", line 188, in sage.categories.sets_cat.Sets
Failed example:
    TestSuite(Sets()).run()
Expected nothing
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x26531d0> ignored
**********************************************************************
```



---

archive/issue_comments_108924.json:
```json
{
    "body": "<a id='comment:6'></a>\nThere is a way to \"borrow\" the trashcan: make sure that some standard python\ncontainer type is involved in the chain of deletions. For `sage.misc.weak_dict`\nthis can be done by modifying `del_dictitem_by_exact_value` to return the key\n(so it's more \"pop_dictitem\") and then in the callback do:\n\n```\n...\n                v=(del_dictitem_by_exact_value(<PyDictObject *>cself, <PyObject *>r, r.key),)\n                del v\n...\n```\ni.e., delete a tuple containing the key rather than the key by itself. The tuple\ndeallocation routine does participate in the trashcan. Drawbacks:\n- this is a little slower\n- we're doing a memory allocation (creation of a tuple) in a weakref callback.\n That's not particularly forbidden, but it can trigger a GC.\nWe could do something similar in `MonoDictEraser` etc. to properly solve #15069.\nAgain, the real solution is for cython to participate in the trashcan.",
    "created_at": "2013-11-07T07:46:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108924",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:6'></a>
There is a way to "borrow" the trashcan: make sure that some standard python
container type is involved in the chain of deletions. For `sage.misc.weak_dict`
this can be done by modifying `del_dictitem_by_exact_value` to return the key
(so it's more "pop_dictitem") and then in the callback do:

```
...
                v=(del_dictitem_by_exact_value(<PyDictObject *>cself, <PyObject *>r, r.key),)
                del v
...
```
i.e., delete a tuple containing the key rather than the key by itself. The tuple
deallocation routine does participate in the trashcan. Drawbacks:
- this is a little slower
- we're doing a memory allocation (creation of a tuple) in a weakref callback.
 That's not particularly forbidden, but it can trigger a GC.
We could do something similar in `MonoDictEraser` etc. to properly solve #15069.
Again, the real solution is for cython to participate in the trashcan.



---

archive/issue_comments_108925.json:
```json
{
    "body": "<a id='comment:7'></a>\n**New commits:**\n<table><tr><td>[362fd5e](https://github.com/sagemath/sagetrac-mirror/commit/362fd5e)</td><td><code># Tue Oct 29 20:14:19 2013 +0100</code></td></tr><tr><td>[b2914f3](https://github.com/sagemath/sagetrac-mirror/commit/b2914f3)</td><td><code># Sun Oct 27 13:58:49 2013 +0100</code></td></tr><tr><td>[9d9cae3](https://github.com/sagemath/sagetrac-mirror/commit/9d9cae3)</td><td><code># Sat Oct 19 11:50:04 2013 +0200</code></td></tr><tr><td>[0251a33](https://github.com/sagemath/sagetrac-mirror/commit/0251a33)</td><td><code>Trac #13394: Implement faster and safer WeakValueDictionary</code></td></tr></table>\n",
    "created_at": "2013-11-08T20:19:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108925",
    "user": "https://github.com/anneschilling"
}
```

<a id='comment:7'></a>
**New commits:**
<table><tr><td>[362fd5e](https://github.com/sagemath/sagetrac-mirror/commit/362fd5e)</td><td><code># Tue Oct 29 20:14:19 2013 +0100</code></td></tr><tr><td>[b2914f3](https://github.com/sagemath/sagetrac-mirror/commit/b2914f3)</td><td><code># Sun Oct 27 13:58:49 2013 +0100</code></td></tr><tr><td>[9d9cae3](https://github.com/sagemath/sagetrac-mirror/commit/9d9cae3)</td><td><code># Sat Oct 19 11:50:04 2013 +0200</code></td></tr><tr><td>[0251a33](https://github.com/sagemath/sagetrac-mirror/commit/0251a33)</td><td><code>Trac #13394: Implement faster and safer WeakValueDictionary</code></td></tr></table>




---

archive/issue_comments_108926.json:
```json
{
    "body": "**Commit:** [362fd5e462adea5860d52fd99db94a2623044d89](https://github.com/sagemath/sagetrac-mirror/commit/362fd5e462adea5860d52fd99db94a2623044d89)",
    "created_at": "2013-11-08T20:19:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108926",
    "user": "https://github.com/anneschilling"
}
```

**Commit:** [362fd5e462adea5860d52fd99db94a2623044d89](https://github.com/sagemath/sagetrac-mirror/commit/362fd5e462adea5860d52fd99db94a2623044d89)



---

archive/issue_comments_108927.json:
```json
{
    "body": "**Branch:** [public/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963)",
    "created_at": "2013-11-08T20:19:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108927",
    "user": "https://github.com/anneschilling"
}
```

**Branch:** [public/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963)



---

archive/issue_comments_108928.json:
```json
{
    "body": "**Changing keywords** from \"\" to \"days54\".",
    "created_at": "2013-11-08T22:55:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108928",
    "user": "https://github.com/anneschilling"
}
```

**Changing keywords** from "" to "days54".



---

archive/issue_comments_108929.json:
```json
{
    "body": "<a id='comment:9'></a>\nHow about we just create our own trashcan for weakref callbacks? \n\n```\ncdef bool trashcan_closed = True\ncdef object trashcan = []\n\ndef remove(wr):\n    if trashcan_closed:\n        trashcan_closed = False\n        trashcan = []   # empty trash, possible call to remove()\n    trashcan_closed = False\n    trashcan.append(wr.subobject)\n    trashcan_close = True\n```\nLimits Python and C recursion depth to 2 frames...",
    "created_at": "2013-11-28T16:03:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108929",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:9'></a>
How about we just create our own trashcan for weakref callbacks? 

```
cdef bool trashcan_closed = True
cdef object trashcan = []

def remove(wr):
    if trashcan_closed:
        trashcan_closed = False
        trashcan = []   # empty trash, possible call to remove()
    trashcan_closed = False
    trashcan.append(wr.subobject)
    trashcan_close = True
```
Limits Python and C recursion depth to 2 frames...



---

archive/issue_comments_108930.json:
```json
{
    "body": "<a id='comment:0'></a>\n\n```\ndarij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ git pull origin public/ticket/10963\nEnter passphrase for key '/home/darij/.ssh/id_rsa': \nFrom trac.sagemath.org:sage\n * branch            public/ticket/10963 -> FETCH_HEAD\nAuto-merging src/sage/structure/parent.pyx\nAuto-merging src/sage/misc/misc.py\nAuto-merging src/sage/combinat/posets/posets.py\nAuto-merging src/sage/combinat/free_module.py\nAuto-merging src/sage/combinat/all.py\nAuto-merging src/sage/categories/posets.py\nAuto-merging src/sage/categories/finite_posets.py\nAuto-merging src/sage/categories/category.py\nCONFLICT (content): Merge conflict in src/sage/categories/category.py\nAutomatic merge failed; fix conflicts and then commit the result.\ndarij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ \n```\n\nFrom a (vain) attempt to merge this I can tell in agreeance with Simon that meld *is* confusing. Too bad kdiff3 is buggy...",
    "created_at": "2013-12-01T00:37:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108930",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:0'></a>

```
darij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ git pull origin public/ticket/10963
Enter passphrase for key '/home/darij/.ssh/id_rsa': 
From trac.sagemath.org:sage
 * branch            public/ticket/10963 -> FETCH_HEAD
Auto-merging src/sage/structure/parent.pyx
Auto-merging src/sage/misc/misc.py
Auto-merging src/sage/combinat/posets/posets.py
Auto-merging src/sage/combinat/free_module.py
Auto-merging src/sage/combinat/all.py
Auto-merging src/sage/categories/posets.py
Auto-merging src/sage/categories/finite_posets.py
Auto-merging src/sage/categories/category.py
CONFLICT (content): Merge conflict in src/sage/categories/category.py
Automatic merge failed; fix conflicts and then commit the result.
darij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ 
```

From a (vain) attempt to merge this I can tell in agreeance with Simon that meld *is* confusing. Too bad kdiff3 is buggy...



---

archive/issue_comments_108931.json:
```json
{
    "body": "<a id='comment:171'></a>\nReplying to [vbraun](#comment%3A169):\n> How about we just create our own trashcan for weakref callbacks? \n> \n> ```\n> cdef bool trashcan_closed = True\n> cdef object trashcan = []\n> \n> def remove(wr):\n>     if trashcan_closed:\n>         trashcan_closed = False\n>         trashcan = []   # empty trash, possible call to remove()\n>     trashcan_closed = False\n>     trashcan.append(wr.subobject)\n>     trashcan_close = True\n> ```\n> Limits Python and C recursion depth to 2 frames...\n\nIt's easier than that. You can take the same approach as in #15367:\n\n```\n    def remove(wr):\n        key_tmp = [key under which wr occurs in dict]\n        remove (key:wr) entry from dict\n        del key_tmp\n```\nInstead of deleting a bare key, we're deleting a list containing the key. Since python lists participate in the trashcan, we get to borrow the trashcan count from there.\n\nThere's a slight cost to this approach: we're allocating a list only to delete it, but that is a very small cost indeed (and a cost we'd incur with our home-rolled trashcan too), and we still get to benefit from all the other performance tunings that have gone into python's trashcan.",
    "created_at": "2013-12-01T01:00:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108931",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:171'></a>
Replying to [vbraun](#comment%3A169):
> How about we just create our own trashcan for weakref callbacks? 
> 
> ```
> cdef bool trashcan_closed = True
> cdef object trashcan = []
> 
> def remove(wr):
>     if trashcan_closed:
>         trashcan_closed = False
>         trashcan = []   # empty trash, possible call to remove()
>     trashcan_closed = False
>     trashcan.append(wr.subobject)
>     trashcan_close = True
> ```
> Limits Python and C recursion depth to 2 frames...

It's easier than that. You can take the same approach as in #15367:

```
    def remove(wr):
        key_tmp = [key under which wr occurs in dict]
        remove (key:wr) entry from dict
        del key_tmp
```
Instead of deleting a bare key, we're deleting a list containing the key. Since python lists participate in the trashcan, we get to borrow the trashcan count from there.

There's a slight cost to this approach: we're allocating a list only to delete it, but that is a very small cost indeed (and a cost we'd incur with our home-rolled trashcan too), and we still get to benefit from all the other performance tunings that have gone into python's trashcan.



---

archive/issue_comments_108932.json:
```json
{
    "body": "**Changing commit** from \"[362fd5e462adea5860d52fd99db94a2623044d89](https://github.com/sagemath/sagetrac-mirror/commit/362fd5e462adea5860d52fd99db94a2623044d89)\" to \"[80d55fe6f2c1ed2496a02cab4ae0db4cb31a7b06](https://github.com/sagemath/sagetrac-mirror/commit/80d55fe6f2c1ed2496a02cab4ae0db4cb31a7b06)\".",
    "created_at": "2013-12-01T01:56:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108932",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[362fd5e462adea5860d52fd99db94a2623044d89](https://github.com/sagemath/sagetrac-mirror/commit/362fd5e462adea5860d52fd99db94a2623044d89)" to "[80d55fe6f2c1ed2496a02cab4ae0db4cb31a7b06](https://github.com/sagemath/sagetrac-mirror/commit/80d55fe6f2c1ed2496a02cab4ae0db4cb31a7b06)".



---

archive/issue_comments_108933.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[80d55fe](https://github.com/sagemath/sagetrac-mirror/commit/80d55fe)</td><td><code>merging sage/categories/category.py</code></td></tr></table>\n",
    "created_at": "2013-12-01T01:56:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108933",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[80d55fe](https://github.com/sagemath/sagetrac-mirror/commit/80d55fe)</td><td><code>merging sage/categories/category.py</code></td></tr></table>




---

archive/issue_comments_108934.json:
```json
{
    "body": "<a id='comment:3'></a>\nI've pushed a merge commit with beta4.\n\nBut please watch out. This branch has the git version of #13394 in its history, whereas the hg version of #13394 was merged into beta3. I don't know whether the branch thus doesn't accidentally set something back that it shouldn't.",
    "created_at": "2013-12-01T01:59:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108934",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:3'></a>
I've pushed a merge commit with beta4.

But please watch out. This branch has the git version of #13394 in its history, whereas the hg version of #13394 was merged into beta3. I don't know whether the branch thus doesn't accidentally set something back that it shouldn't.



---

archive/issue_comments_108935.json:
```json
{
    "body": "<a id='comment:174'></a>\nReplying to [nbruin](#comment%3A171):\n> Replying to [vbraun](#comment%3A169):\n> > How about we just create our own trashcan for weakref callbacks? \n> > ...\n\n> It's easier than that. You can take the same approach as in #15367:\n> ..\n> Instead of deleting a bare key, we're deleting a list containing the key. Since python lists participate in the trashcan, we get to borrow the trashcan count from there.\n> \n> There's a slight cost to this approach: we're allocating a list only to delete it, but that is a very small cost indeed (and a cost we'd incur with our home-rolled trashcan too), and we still get to benefit from all the other performance tunings that have gone into python's trashcan.\n\nI am glad to hear that there seems to be an easy solution.  I can't\nwait to see it implemented, tested, reviewed, merged! And then see\n#10963 merged finally!\n\nWhoever participates to this will get a triple beer from me\n(chocolates work too :-)) at the next occasion! Who's in?\n\nCheers,\n                              Nicolas",
    "created_at": "2013-12-01T09:11:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108935",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:174'></a>
Replying to [nbruin](#comment%3A171):
> Replying to [vbraun](#comment%3A169):
> > How about we just create our own trashcan for weakref callbacks? 
> > ...

> It's easier than that. You can take the same approach as in #15367:
> ..
> Instead of deleting a bare key, we're deleting a list containing the key. Since python lists participate in the trashcan, we get to borrow the trashcan count from there.
> 
> There's a slight cost to this approach: we're allocating a list only to delete it, but that is a very small cost indeed (and a cost we'd incur with our home-rolled trashcan too), and we still get to benefit from all the other performance tunings that have gone into python's trashcan.

I am glad to hear that there seems to be an easy solution.  I can't
wait to see it implemented, tested, reviewed, merged! And then see
#10963 merged finally!

Whoever participates to this will get a triple beer from me
(chocolates work too :-)) at the next occasion! Who's in?

Cheers,
                              Nicolas



---

archive/issue_comments_108936.json:
```json
{
    "body": "<a id='comment:5'></a>\nI don't understand git...\n\nSo I've typed\n\n```\ngit diff -c 362fd5e4..80d55fe | gedit\n```\nto check my merge again. It gives a lot of changes (of course -- update from beta2 to beta4), including this:\n\n```\ndiff --git a/src/sage/categories/category.py b/src/sage/categories/category.py\nindex 69373b7..732c233 100644\n--- a/src/sage/categories/category.py\n+++ b/src/sage/categories/category.py\n@@ -108,6 +108,60 @@ from sage.structure.sage_object import SageObject\n from sage.structure.unique_representation import UniqueRepresentation\n from sage.structure.dynamic_class import DynamicMetaclass, dynamic_class\n \n+import sage.misc.weak_dict\n+from sage.misc.weak_dict import WeakValueDictionary\n+_join_cache = WeakValueDictionary()\n+\n+def _join(categories, as_list):\n+    \"\"\"\n+    This is an auxiliary function for :meth:`Category.join`\n+\n+    INPUT:\n+\n+    - ``categories``: A tuple (no list) of categories.\n+    - ``as_list`` (boolean): Whether or not the result should be represented as a list.\n+\n+    EXAMPLES::\n+\n+        sage: Category.join((Groups(), CommutativeAdditiveMonoids()))  # indirect doctest\n+        Join of Category of groups and Category of commutative additive monoids\n+        sage: Category.join((Modules(ZZ), FiniteFields()), as_list=True)\n+        [Category of finite fields, Category of modules over Integer Ring]\n+\n+    \"\"\"\n+    # Since Objects() is the top category, it is the neutral element of join\n+    if len(categories) == 0:\n+        from objects import Objects\n+        return Objects()\n+\n+    if not as_list:\n+        try:\n+            return _join_cache[categories]\n+        except KeyError:\n+            pass\n+\n+    # Ensure associativity by flattening JoinCategory's\n+    # Invariant: the super categories of a JoinCategory are not JoinCategories themselves\n+    categories = sum( (tuple(category._super_categories) if isinstance(category, JoinCategory) else (category,)\n+                       for category in categories), ())\n+\n+    # canonicalize, by removing redundant categories which are super\n+    # categories of others, and by sorting\n+    result = ()\n+    for category in categories:\n+        if any(cat.is_subcategory(category) for cat in result):\n+            continue\n+        result = tuple( cat for cat in result if not category.is_subcategory(cat) ) + (category,)\n+    result = tuple(sorted(result, key = category_sort_key, reverse=True))\n+    if as_list:\n+        return list(result)\n+    if len(result) == 1:\n+        out = _join_cache[categories] = result[0]\n+    else:\n+        out = _join_cache[categories] = JoinCategory(result)\n+    return out\n+\n+\n class Category(UniqueRepresentation, SageObject):\n     r\"\"\"\n     The base class for modeling mathematical categories, like for example:\n```\nWhy is `def _join` marked as newly added? It did not enter Sage between beta2 and beta4. Instead, git blame shows most of it is from 2011:\n\n```\ndarij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ git blame src/sage/categories/category.py \n[...]\nfa807558 (Simon King        2013-11-02 22:51:17 +0100  110) import sage.misc.weak_dict\nfa807558 (Simon King        2013-11-02 22:51:17 +0100  111) from sage.misc.weak_dict import WeakValueDiction\nf89e19cf (Simon King        2011-12-25 00:48:56 +0100  112) _join_cache = WeakValueDictionary()\nf89e19cf (Simon King        2011-12-25 00:48:56 +0100  113) \na3c5958b (Simon King        2011-10-06 14:17:11 +0200  114) def _join(categories, as_list):\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  115)     \"\"\"\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  116)     This is an auxiliary function for :meth:`Cat\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  117) \na3c5958b (Simon King        2011-10-06 14:17:11 +0200  118)     INPUT:\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  119) \na3c5958b (Simon King        2011-10-06 14:17:11 +0200  120)     - ``categories``: A tuple (no list) of categ\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  121)     - ``as_list`` (boolean): Whether or not the \na3c5958b (Simon King        2011-10-06 14:17:11 +0200  122) \na3c5958b (Simon King        2011-10-06 14:17:11 +0200  123)     EXAMPLES::\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  124) \na3c5958b (Simon King        2011-10-06 14:17:11 +0200  125)         sage: Category.join((Groups(), Commutati\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  126)         Join of Category of groups and Category \na3c5958b (Simon King        2011-10-06 14:17:11 +0200  127)         sage: Category.join((Modules(ZZ), Finite\n71230653 (Nicolas M. Thiery 2013-05-31 13:11:13 -0400  128)         [Category of finite fields, Category of \na3c5958b (Simon King        2011-10-06 14:17:11 +0200  129) \na3c5958b (Simon King        2011-10-06 14:17:11 +0200  130)     \"\"\"\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  131)     # Since Objects() is the top category, it is\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  132)     if len(categories) == 0:\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  133)         from objects import Objects\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  134)         return Objects()\na3c5958b (Simon King        2011-10-06 14:17:11 +0200  135) \nf89e19cf (Simon King        2011-12-25 00:48:56 +0100  136)     if not as_list:\nf89e19cf (Simon King        2011-12-25 00:48:56 +0100  137)         try:\nf89e19cf (Simon King        2011-12-25 00:48:56 +0100  138)             return _join_cache[categories]\nf89e19cf (Simon King        2011-12-25 00:48:56 +0100  139)         except KeyError:\n[...]\n```",
    "created_at": "2013-12-10T04:19:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108936",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:5'></a>
I don't understand git...

So I've typed

```
git diff -c 362fd5e4..80d55fe | gedit
```
to check my merge again. It gives a lot of changes (of course -- update from beta2 to beta4), including this:

```
diff --git a/src/sage/categories/category.py b/src/sage/categories/category.py
index 69373b7..732c233 100644
--- a/src/sage/categories/category.py
+++ b/src/sage/categories/category.py
@@ -108,6 +108,60 @@ from sage.structure.sage_object import SageObject
 from sage.structure.unique_representation import UniqueRepresentation
 from sage.structure.dynamic_class import DynamicMetaclass, dynamic_class
 
+import sage.misc.weak_dict
+from sage.misc.weak_dict import WeakValueDictionary
+_join_cache = WeakValueDictionary()
+
+def _join(categories, as_list):
+    """
+    This is an auxiliary function for :meth:`Category.join`
+
+    INPUT:
+
+    - ``categories``: A tuple (no list) of categories.
+    - ``as_list`` (boolean): Whether or not the result should be represented as a list.
+
+    EXAMPLES::
+
+        sage: Category.join((Groups(), CommutativeAdditiveMonoids()))  # indirect doctest
+        Join of Category of groups and Category of commutative additive monoids
+        sage: Category.join((Modules(ZZ), FiniteFields()), as_list=True)
+        [Category of finite fields, Category of modules over Integer Ring]
+
+    """
+    # Since Objects() is the top category, it is the neutral element of join
+    if len(categories) == 0:
+        from objects import Objects
+        return Objects()
+
+    if not as_list:
+        try:
+            return _join_cache[categories]
+        except KeyError:
+            pass
+
+    # Ensure associativity by flattening JoinCategory's
+    # Invariant: the super categories of a JoinCategory are not JoinCategories themselves
+    categories = sum( (tuple(category._super_categories) if isinstance(category, JoinCategory) else (category,)
+                       for category in categories), ())
+
+    # canonicalize, by removing redundant categories which are super
+    # categories of others, and by sorting
+    result = ()
+    for category in categories:
+        if any(cat.is_subcategory(category) for cat in result):
+            continue
+        result = tuple( cat for cat in result if not category.is_subcategory(cat) ) + (category,)
+    result = tuple(sorted(result, key = category_sort_key, reverse=True))
+    if as_list:
+        return list(result)
+    if len(result) == 1:
+        out = _join_cache[categories] = result[0]
+    else:
+        out = _join_cache[categories] = JoinCategory(result)
+    return out
+
+
 class Category(UniqueRepresentation, SageObject):
     r"""
     The base class for modeling mathematical categories, like for example:
```
Why is `def _join` marked as newly added? It did not enter Sage between beta2 and beta4. Instead, git blame shows most of it is from 2011:

```
darij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ git blame src/sage/categories/category.py 
[...]
fa807558 (Simon King        2013-11-02 22:51:17 +0100  110) import sage.misc.weak_dict
fa807558 (Simon King        2013-11-02 22:51:17 +0100  111) from sage.misc.weak_dict import WeakValueDiction
f89e19cf (Simon King        2011-12-25 00:48:56 +0100  112) _join_cache = WeakValueDictionary()
f89e19cf (Simon King        2011-12-25 00:48:56 +0100  113) 
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  114) def _join(categories, as_list):
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  115)     """
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  116)     This is an auxiliary function for :meth:`Cat
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  117) 
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  118)     INPUT:
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  119) 
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  120)     - ``categories``: A tuple (no list) of categ
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  121)     - ``as_list`` (boolean): Whether or not the 
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  122) 
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  123)     EXAMPLES::
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  124) 
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  125)         sage: Category.join((Groups(), Commutati
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  126)         Join of Category of groups and Category 
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  127)         sage: Category.join((Modules(ZZ), Finite
71230653 (Nicolas M. Thiery 2013-05-31 13:11:13 -0400  128)         [Category of finite fields, Category of 
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  129) 
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  130)     """
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  131)     # Since Objects() is the top category, it is
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  132)     if len(categories) == 0:
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  133)         from objects import Objects
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  134)         return Objects()
a3c5958b (Simon King        2011-10-06 14:17:11 +0200  135) 
f89e19cf (Simon King        2011-12-25 00:48:56 +0100  136)     if not as_list:
f89e19cf (Simon King        2011-12-25 00:48:56 +0100  137)         try:
f89e19cf (Simon King        2011-12-25 00:48:56 +0100  138)             return _join_cache[categories]
f89e19cf (Simon King        2011-12-25 00:48:56 +0100  139)         except KeyError:
[...]
```



---

archive/issue_comments_108937.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[a410d05](https://github.com/sagemath/sagetrac-mirror/commit/a410d05)</td><td><code>typos and unused imports</code></td></tr><tr><td>[b21dde5](https://github.com/sagemath/sagetrac-mirror/commit/b21dde5)</td><td><code>duplication introduced in my own merge removed</code></td></tr><tr><td>[91b4e23](https://github.com/sagemath/sagetrac-mirror/commit/91b4e23)</td><td><code>Merge branch 'master' into 10963</code></td></tr></table>\n",
    "created_at": "2013-12-10T04:51:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108937",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[a410d05](https://github.com/sagemath/sagetrac-mirror/commit/a410d05)</td><td><code>typos and unused imports</code></td></tr><tr><td>[b21dde5](https://github.com/sagemath/sagetrac-mirror/commit/b21dde5)</td><td><code>duplication introduced in my own merge removed</code></td></tr><tr><td>[91b4e23](https://github.com/sagemath/sagetrac-mirror/commit/91b4e23)</td><td><code>Merge branch 'master' into 10963</code></td></tr></table>




---

archive/issue_comments_108938.json:
```json
{
    "body": "**Changing commit** from \"[80d55fe6f2c1ed2496a02cab4ae0db4cb31a7b06](https://github.com/sagemath/sagetrac-mirror/commit/80d55fe6f2c1ed2496a02cab4ae0db4cb31a7b06)\" to \"[a410d05b692eead348214b0378dfc78113a3bf5a](https://github.com/sagemath/sagetrac-mirror/commit/a410d05b692eead348214b0378dfc78113a3bf5a)\".",
    "created_at": "2013-12-10T04:51:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108938",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[80d55fe6f2c1ed2496a02cab4ae0db4cb31a7b06](https://github.com/sagemath/sagetrac-mirror/commit/80d55fe6f2c1ed2496a02cab4ae0db4cb31a7b06)" to "[a410d05b692eead348214b0378dfc78113a3bf5a](https://github.com/sagemath/sagetrac-mirror/commit/a410d05b692eead348214b0378dfc78113a3bf5a)".



---

archive/issue_comments_108939.json:
```json
{
    "body": "<a id='comment:7'></a>\nPushed a couple trivial (hopefully...) changes -- someone please check!\n\nAlso I've confirmed that the version of #13394 in the patch equals the one in the master, so there was no error in that.\n\nAlso, am I seeing it right that the category of group algebras is now no longer a subcategory of Hopf algebras, and the category of monoid algebras no longer one of that of bialgebras? Or were they never? EDIT: Yeah, they never were. I guess they should be, at least once bialgebras and Hopf algebras get any useful methods like integrals?\n\n---\n**New commits:**\n<table><tr><td>[a410d05](https://github.com/sagemath/sagetrac-mirror/commit/a410d05)</td><td><code>typos and unused imports</code></td></tr><tr><td>[b21dde5](https://github.com/sagemath/sagetrac-mirror/commit/b21dde5)</td><td><code>duplication introduced in my own merge removed</code></td></tr><tr><td>[91b4e23](https://github.com/sagemath/sagetrac-mirror/commit/91b4e23)</td><td><code>Merge branch 'master' into 10963</code></td></tr></table>\n",
    "created_at": "2013-12-10T04:52:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108939",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:7'></a>
Pushed a couple trivial (hopefully...) changes -- someone please check!

Also I've confirmed that the version of #13394 in the patch equals the one in the master, so there was no error in that.

Also, am I seeing it right that the category of group algebras is now no longer a subcategory of Hopf algebras, and the category of monoid algebras no longer one of that of bialgebras? Or were they never? EDIT: Yeah, they never were. I guess they should be, at least once bialgebras and Hopf algebras get any useful methods like integrals?

---
**New commits:**
<table><tr><td>[a410d05](https://github.com/sagemath/sagetrac-mirror/commit/a410d05)</td><td><code>typos and unused imports</code></td></tr><tr><td>[b21dde5](https://github.com/sagemath/sagetrac-mirror/commit/b21dde5)</td><td><code>duplication introduced in my own merge removed</code></td></tr><tr><td>[91b4e23](https://github.com/sagemath/sagetrac-mirror/commit/91b4e23)</td><td><code>Merge branch 'master' into 10963</code></td></tr></table>




---

archive/issue_comments_108940.json:
```json
{
    "body": "<a id='comment:178'></a>\nReplying to [darij](#comment%3A177):\n> Pushed a couple trivial (hopefully...) changes -- someone please check!\n\nI checked them, and I am happy with them in principle. Thanks for the\nproofreading! However this ticket is more or less in frozen state, and\nstill officially to be merged on the mercurial side (the git branch is\njust to allow for development of tickets depending on this one on the\ngit side). In fact, I consider this ticket as positive review modulo\nthe dependency on this memory deallocation bug.\n\nSo I'd rather postpone those changes to a later ticket\ninstead of spending time backporting them to mercurial.\n\n> Also I've confirmed that the version of #13394 in the patch equals the one in the master, so there was no error in that.\n\nOk\n\n> Also, am I seeing it right that the category of group algebras is\n> now no longer a subcategory of Hopf algebras, and the category of\n> monoid algebras no longer one of that of bialgebras? Or were they\n> never? EDIT: Yeah, they never were. I guess they should be, at least\n> once bialgebras and Hopf algebras get any useful methods like\n> integrals?\n\nGroup algebras are still Hopf algebras as they used to be. Making\nmonoid algebras into bialgebras is certainly a desirable feature, in a\nlater ticket.\n\nCheers,\n                                       Nicolas",
    "created_at": "2013-12-10T06:15:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108940",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:178'></a>
Replying to [darij](#comment%3A177):
> Pushed a couple trivial (hopefully...) changes -- someone please check!

I checked them, and I am happy with them in principle. Thanks for the
proofreading! However this ticket is more or less in frozen state, and
still officially to be merged on the mercurial side (the git branch is
just to allow for development of tickets depending on this one on the
git side). In fact, I consider this ticket as positive review modulo
the dependency on this memory deallocation bug.

So I'd rather postpone those changes to a later ticket
instead of spending time backporting them to mercurial.

> Also I've confirmed that the version of #13394 in the patch equals the one in the master, so there was no error in that.

Ok

> Also, am I seeing it right that the category of group algebras is
> now no longer a subcategory of Hopf algebras, and the category of
> monoid algebras no longer one of that of bialgebras? Or were they
> never? EDIT: Yeah, they never were. I guess they should be, at least
> once bialgebras and Hopf algebras get any useful methods like
> integrals?

Group algebras are still Hopf algebras as they used to be. Making
monoid algebras into bialgebras is certainly a desirable feature, in a
later ticket.

Cheers,
                                       Nicolas



---

archive/issue_comments_108941.json:
```json
{
    "body": "<a id='comment:9'></a>\nOoooooh, so the branch is experimental?\n\nGuise! Pleeease don't put experimental branches in the `public` namespace!",
    "created_at": "2013-12-10T06:23:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108941",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:9'></a>
Ooooooh, so the branch is experimental?

Guise! Pleeease don't put experimental branches in the `public` namespace!



---

archive/issue_comments_108942.json:
```json
{
    "body": "<a id='comment:180'></a>\nReplying to [nthiery](#comment%3A174):\n> Replying to [nbruin](#comment%3A171):\n> > Replying to [vbraun](#comment%3A169):\n> > > How about we just create our own trashcan for weakref callbacks? \n> > > ...\n\n> > It's easier than that. You can take the same approach as in #15367:\n> > ..\n> > Instead of deleting a bare key, we're deleting a list containing the key. Since python lists participate in the trashcan, we get to borrow the trashcan count from there.\n> > \n> > There's a slight cost to this approach: we're allocating a list only to delete it, but that is a very small cost indeed (and a cost we'd incur with our home-rolled trashcan too), and we still get to benefit from all the other performance tunings that have gone into python's trashcan.\n\nNils, if you see precisely how to handle this, pleeeeeeaaaaase\nproceed! I have created #15506 for this issue.\n\nCheers,\n                              Nicolas",
    "created_at": "2013-12-10T06:30:48Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108942",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:180'></a>
Replying to [nthiery](#comment%3A174):
> Replying to [nbruin](#comment%3A171):
> > Replying to [vbraun](#comment%3A169):
> > > How about we just create our own trashcan for weakref callbacks? 
> > > ...

> > It's easier than that. You can take the same approach as in #15367:
> > ..
> > Instead of deleting a bare key, we're deleting a list containing the key. Since python lists participate in the trashcan, we get to borrow the trashcan count from there.
> > 
> > There's a slight cost to this approach: we're allocating a list only to delete it, but that is a very small cost indeed (and a cost we'd incur with our home-rolled trashcan too), and we still get to benefit from all the other performance tunings that have gone into python's trashcan.

Nils, if you see precisely how to handle this, pleeeeeeaaaaase
proceed! I have created #15506 for this issue.

Cheers,
                              Nicolas



---

archive/issue_comments_108943.json:
```json
{
    "body": "**Work Issues:** Fix #15506. Other than that this ticket is good to go and in frozen state.",
    "created_at": "2013-12-10T06:33:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108943",
    "user": "https://github.com/nthiery"
}
```

**Work Issues:** Fix #15506. Other than that this ticket is good to go and in frozen state.



---

archive/issue_comments_108944.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15506\".",
    "created_at": "2013-12-10T06:33:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108944",
    "user": "https://github.com/nthiery"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15506".



---

archive/issue_comments_108945.json:
```json
{
    "body": "<a id='comment:182'></a>\nReplying to [darij](#comment%3A179):\n> Ooooooh, so the branch is experimental?\n> \n> Guise! Pleeease don't put experimental branches in the `public` namespace!\n\nThe branch is/was not experimental. It was just the git version of the hg patch since we needed it to develop other code that is based on this patch. Since it is already positively reviewed it is not a good idea to modify the git branch.\n\nBest,\n\nAnne",
    "created_at": "2013-12-10T06:39:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108945",
    "user": "https://github.com/anneschilling"
}
```

<a id='comment:182'></a>
Replying to [darij](#comment%3A179):
> Ooooooh, so the branch is experimental?
> 
> Guise! Pleeease don't put experimental branches in the `public` namespace!

The branch is/was not experimental. It was just the git version of the hg patch since we needed it to develop other code that is based on this patch. Since it is already positively reviewed it is not a good idea to modify the git branch.

Best,

Anne



---

archive/issue_comments_108946.json:
```json
{
    "body": "**Changing work issues** from \"Fix #15506. Other than that this ticket is good to go and in frozen state.\" to \"\".",
    "created_at": "2013-12-10T06:39:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108946",
    "user": "https://github.com/anneschilling"
}
```

**Changing work issues** from "Fix #15506. Other than that this ticket is good to go and in frozen state." to "".



---

archive/issue_comments_108947.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15506\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394\".",
    "created_at": "2013-12-10T06:39:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108947",
    "user": "https://github.com/anneschilling"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15506" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394".



---

archive/issue_comments_108948.json:
```json
{
    "body": "<a id='comment:3'></a>\nAh! The fact that this used to be `positive_review` should be made clearer IMHO (but this is a trac issue among many...).",
    "created_at": "2013-12-10T06:41:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108948",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:3'></a>
Ah! The fact that this used to be `positive_review` should be made clearer IMHO (but this is a trac issue among many...).



---

archive/issue_comments_108949.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15506\".",
    "created_at": "2013-12-10T08:41:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108949",
    "user": "https://github.com/tscrim"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15506".



---

archive/issue_comments_108950.json:
```json
{
    "body": "<a id='comment:4'></a>\nSo if I'm understanding everything properly, #15506 is a dependency and this can be set to positive review modulo Darij's tweaks?",
    "created_at": "2013-12-10T08:41:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108950",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:4'></a>
So if I'm understanding everything properly, #15506 is a dependency and this can be set to positive review modulo Darij's tweaks?



---

archive/issue_events_085468.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2013-12-10T08:41:38Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85468"
}
```



---

archive/issue_events_085469.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2013-12-10T08:41:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85469"
}
```



---

archive/issue_comments_108951.json:
```json
{
    "body": "<a id='comment:5'></a>\nIt was just acted by Jeoroen that #15506, and therefore this ticket, is postponned to Sage 6.0.\n\nI consider this ticket as positive review, assuming that #15506 indeed fixes the issue.\n\nI postpone Darij's tweaks to a followup ticket, in order to keep the git and mercurial version of this ticket in sync. Darij, can you open a ticket?\n\nCheers,\n                                      Nicolas",
    "created_at": "2013-12-10T08:58:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108951",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>
It was just acted by Jeoroen that #15506, and therefore this ticket, is postponned to Sage 6.0.

I consider this ticket as positive review, assuming that #15506 indeed fixes the issue.

I postpone Darij's tweaks to a followup ticket, in order to keep the git and mercurial version of this ticket in sync. Darij, can you open a ticket?

Cheers,
                                      Nicolas



---

archive/issue_events_085470.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2013-12-10T08:58:15Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "milestone": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85470"
}
```



---

archive/issue_events_085471.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2013-12-10T08:58:15Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "milestone": "sage-6.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85471"
}
```



---

archive/issue_events_085472.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-12-10T11:26:09Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "milestone": "sage-6.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85472"
}
```



---

archive/issue_events_085473.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-12-10T11:26:09Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "milestone": "sage-6.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85473"
}
```



---

archive/issue_comments_108952.json:
```json
{
    "body": "<a id='comment:6'></a>\n6.0 will be 5.13 + git (and released at the same time). All tickets that are not related to the git transition (such as this one) will go into 6.1+.",
    "created_at": "2013-12-10T11:26:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108952",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:6'></a>
6.0 will be 5.13 + git (and released at the same time). All tickets that are not related to the git transition (such as this one) will go into 6.1+.



---

archive/issue_comments_108953.json:
```json
{
    "body": "<a id='comment:7'></a>\nI've made a note for myself to reintroduce the changes in #15475.\n\nI thought 6.0 was waiting for this patch (and #15506) to be merged, though?",
    "created_at": "2013-12-10T16:36:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108953",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:7'></a>
I've made a note for myself to reintroduce the changes in #15475.

I thought 6.0 was waiting for this patch (and #15506) to be merged, though?



---

archive/issue_comments_108954.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15506\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150 #15506\".",
    "created_at": "2013-12-10T16:41:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108954",
    "user": "https://github.com/tscrim"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15506" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150 #15506".



---

archive/issue_comments_108955.json:
```json
{
    "body": "<a id='comment:8'></a>\nSince this is getting pushed back, I've put #15150 ahead of this. The only difference is the ordering of the output of categories in `sage/combinat/ncsym/bases.py`. If things change, I can easily reverse the ordering.",
    "created_at": "2013-12-10T16:41:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108955",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>
Since this is getting pushed back, I've put #15150 ahead of this. The only difference is the ordering of the output of categories in `sage/combinat/ncsym/bases.py`. If things change, I can easily reverse the ordering.



---

archive/issue_comments_108956.json:
```json
{
    "body": "<a id='comment:189'></a>\nReplying to [darij](#comment%3A187):\n> I thought 6.0 was waiting for this patch (and #15506) to be merged, though?\n\nI have seen that suggested/asked, yes. However, I don't see a good reason why this ticket should be a blocker for Sage 5.13. But if there is a good reason, I'm listening...",
    "created_at": "2013-12-10T17:24:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108956",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:189'></a>
Replying to [darij](#comment%3A187):
> I thought 6.0 was waiting for this patch (and #15506) to be merged, though?

I have seen that suggested/asked, yes. However, I don't see a good reason why this ticket should be a blocker for Sage 5.13. But if there is a good reason, I'm listening...



---

archive/issue_comments_108957.json:
```json
{
    "body": "<a id='comment:0'></a>\nHmm. I have a strong *desire* to get this ticket in very soon and get\nit off my plate. And I *fear* that if it's bounced to 6.1 it will go\ninto another long cycle of conflicts/fixes/... whereas it's currently\n(almost) good to go. Now besides frustration and emotions is there a\n*rationale* justifying a special treatment, well, I am in a conflict\nof interest to judge. The main fact is that many tickets depends on\nthis one and it already took a *long* while to get it straight.\n\nCheers,\n                                     Nicolas",
    "created_at": "2013-12-11T22:31:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108957",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:0'></a>
Hmm. I have a strong *desire* to get this ticket in very soon and get
it off my plate. And I *fear* that if it's bounced to 6.1 it will go
into another long cycle of conflicts/fixes/... whereas it's currently
(almost) good to go. Now besides frustration and emotions is there a
*rationale* justifying a special treatment, well, I am in a conflict
of interest to judge. The main fact is that many tickets depends on
this one and it already took a *long* while to get it straight.

Cheers,
                                     Nicolas



---

archive/issue_comments_108958.json:
```json
{
    "body": "<a id='comment:1'></a>\nSeconding Nicolas. There are a couple changes I wanted to do that I am deferring until #10963 gets merged so as not to create yet more conflicts.\n\nEither way I am worried about the branch-vs.-patch issue. If the branch is not going to be merged into sage as it is, won't we get a rebase cascade on all the branches that depend on it?",
    "created_at": "2013-12-11T23:42:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108958",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:1'></a>
Seconding Nicolas. There are a couple changes I wanted to do that I am deferring until #10963 gets merged so as not to create yet more conflicts.

Either way I am worried about the branch-vs.-patch issue. If the branch is not going to be merged into sage as it is, won't we get a rebase cascade on all the branches that depend on it?



---

archive/issue_comments_108959.json:
```json
{
    "body": "<a id='comment:192'></a>\nI can confirm that not having this patch in sage is hampering a lot of development. First of all, there are already many patches that depend on it (such as #14102 for example), but also projects that are stagnant since it has not yet been merged. For example, Franco has code on the representation theory of the symmetric group that would need this (and #11111), Christian has code on Coxeter groups etc.. It has been a long wait! When code cannot be merged (like the dependent tickets), they usually do not get maintained and they rot away! So I strongly, strongly recommend to try to merge this ticket soon!",
    "created_at": "2013-12-12T00:12:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108959",
    "user": "https://github.com/anneschilling"
}
```

<a id='comment:192'></a>
I can confirm that not having this patch in sage is hampering a lot of development. First of all, there are already many patches that depend on it (such as #14102 for example), but also projects that are stagnant since it has not yet been merged. For example, Franco has code on the representation theory of the symmetric group that would need this (and #11111), Christian has code on Coxeter groups etc.. It has been a long wait! When code cannot be merged (like the dependent tickets), they usually do not get maintained and they rot away! So I strongly, strongly recommend to try to merge this ticket soon!



---

archive/issue_comments_108960.json:
```json
{
    "body": "<a id='comment:193'></a>\nReplying to [darij](#comment%3A191):\n> Either way I am worried about the branch-vs.-patch issue. If the branch is not going to be merged into sage as it is, won't we get a rebase cascade on all the branches that depend on it?\n\nThe branch may be based on an earlier version of sage, but that doesn't preclude it from being merged into a later version without rebasing. There may still be conflicts that need to be resolved, but a merge rather than a rebase should allow git to be a lot more intelligent about what to do. The same holds for other branches that are based off this one: On the whole, a merge rather than rebase should pretty much limit problems to conflicts that actually are conflicts.",
    "created_at": "2013-12-12T01:45:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108960",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:193'></a>
Replying to [darij](#comment%3A191):
> Either way I am worried about the branch-vs.-patch issue. If the branch is not going to be merged into sage as it is, won't we get a rebase cascade on all the branches that depend on it?

The branch may be based on an earlier version of sage, but that doesn't preclude it from being merged into a later version without rebasing. There may still be conflicts that need to be resolved, but a merge rather than a rebase should allow git to be a lot more intelligent about what to do. The same holds for other branches that are based off this one: On the whole, a merge rather than rebase should pretty much limit problems to conflicts that actually are conflicts.



---

archive/issue_comments_108961.json:
```json
{
    "body": "<a id='comment:194'></a>\nReplying to [jdemeyer](#comment%3A165):\n> On a different machine:\n> \n> ```\n> sage -t --long devel/sage/sage/categories/sets_cat.py\n> **********************************************************************\n> File \"devel/sage/sage/categories/sets_cat.py\", line 188, in sage.categories.sets_cat.Sets\n> Failed example:\n>     TestSuite(Sets()).run()\n> Expected nothing\n> Got:\n>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x26531d0> ignored\n> **********************************************************************\n> ```\n\nCircumstantial evidence suggests that this ticket makes these kinds of events more likely than they were before. While we know a way to avoid the actual error (and the condition happening is in itself not an error condition either), it would be good to see exactly what deletion chains are responsible for this, since those might be indicative of an \"almost\" memory leak: I find it hard to conceive of a valid situation where such a deep chain of weakref callbacks triggering further weakref callbacks would occur. It shouldn't hold up the merge of this ticket, but it could well be a worthwhile investigation into whether our data structures are still sane.",
    "created_at": "2013-12-12T01:55:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108961",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:194'></a>
Replying to [jdemeyer](#comment%3A165):
> On a different machine:
> 
> ```
> sage -t --long devel/sage/sage/categories/sets_cat.py
> **********************************************************************
> File "devel/sage/sage/categories/sets_cat.py", line 188, in sage.categories.sets_cat.Sets
> Failed example:
>     TestSuite(Sets()).run()
> Expected nothing
> Got:
>     Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <cyfunction WeakValueDictionary.__init__.<locals>.callback at 0x26531d0> ignored
> **********************************************************************
> ```

Circumstantial evidence suggests that this ticket makes these kinds of events more likely than they were before. While we know a way to avoid the actual error (and the condition happening is in itself not an error condition either), it would be good to see exactly what deletion chains are responsible for this, since those might be indicative of an "almost" memory leak: I find it hard to conceive of a valid situation where such a deep chain of weakref callbacks triggering further weakref callbacks would occur. It shouldn't hold up the merge of this ticket, but it could well be a worthwhile investigation into whether our data structures are still sane.



---

archive/issue_comments_108962.json:
```json
{
    "body": "<a id='comment:5'></a>\nAbsolutely nothing personal, but I'm actually more convinced that this should **not** go into Sage 5.13. If the patch has potential to create subtle issues which are hard to reproduce/debug/understand, then it's not something which should be merged into an -rc1.",
    "created_at": "2013-12-12T08:17:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108962",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
Absolutely nothing personal, but I'm actually more convinced that this should **not** go into Sage 5.13. If the patch has potential to create subtle issues which are hard to reproduce/debug/understand, then it's not something which should be merged into an -rc1.



---

archive/issue_comments_108963.json:
```json
{
    "body": "<a id='comment:196'></a>\nReplying to [aschilling](#comment%3A192):\n> I can confirm that not having this patch in sage is hampering a lot of development.\n\nAnne, that might be true, but postponing Sage 5.13 to wait for this patch isn't going to solve this problem.\n\nIn fact, I would say that Sage development is hampered more by *all the other patches* waiting to get merged in Sage 6.x. If you think that this one ticket here is more important than those 73 other, you need a good reason.",
    "created_at": "2013-12-12T08:21:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108963",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:196'></a>
Replying to [aschilling](#comment%3A192):
> I can confirm that not having this patch in sage is hampering a lot of development.

Anne, that might be true, but postponing Sage 5.13 to wait for this patch isn't going to solve this problem.

In fact, I would say that Sage development is hampered more by *all the other patches* waiting to get merged in Sage 6.x. If you think that this one ticket here is more important than those 73 other, you need a good reason.



---

archive/issue_comments_108964.json:
```json
{
    "body": "<a id='comment:7'></a>\nThing is, I have experienced two spooky and unexplainable bugs in the coercion system (I believe) in the last few weeks:\n\nhttps://groups.google.com/forum/#!topic/sage-devel/LapvScfoBuI\n\nhttp://trac.sagemath.org/ticket/15473#modify\n\nwhich both magically disappeared when I added in the #10963 branch. I don't know if this is because #10963 fixes some subtle underlying cause, or just because some patches which were merged in lately were already built under the preassumption that #10963 were there and would not really work without. So at least from my viewpoint, the #10963 branch is more stable than current master...",
    "created_at": "2013-12-12T15:33:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108964",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:7'></a>
Thing is, I have experienced two spooky and unexplainable bugs in the coercion system (I believe) in the last few weeks:

https://groups.google.com/forum/#!topic/sage-devel/LapvScfoBuI

http://trac.sagemath.org/ticket/15473#modify

which both magically disappeared when I added in the #10963 branch. I don't know if this is because #10963 fixes some subtle underlying cause, or just because some patches which were merged in lately were already built under the preassumption that #10963 were there and would not really work without. So at least from my viewpoint, the #10963 branch is more stable than current master...



---

archive/issue_comments_108965.json:
```json
{
    "body": "<a id='comment:198'></a>\nReplying to [jdemeyer](#comment%3A196):\n> Anne, that might be true, but postponing Sage 5.13 to wait for this patch isn't going to solve this problem.\n> \n> In fact, I would say that Sage development is hampered more by *all the other patches* waiting to get merged in Sage 6.x. If you think that this one ticket here is more important than those 73 other, you need a good reason.\n\nIf 5.3 and 6.0 are almost ready to be released so that this ticket can be merged very soon in some beta release of 6.1, I guess that's a reasonable alternative. Especially if this ticket gets some priority :-)",
    "created_at": "2013-12-16T21:59:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108965",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:198'></a>
Replying to [jdemeyer](#comment%3A196):
> Anne, that might be true, but postponing Sage 5.13 to wait for this patch isn't going to solve this problem.
> 
> In fact, I would say that Sage development is hampered more by *all the other patches* waiting to get merged in Sage 6.x. If you think that this one ticket here is more important than those 73 other, you need a good reason.

If 5.3 and 6.0 are almost ready to be released so that this ticket can be merged very soon in some beta release of 6.1, I guess that's a reasonable alternative. Especially if this ticket gets some priority :-)



---

archive/issue_comments_108966.json:
```json
{
    "body": "<a id='comment:9'></a>\nI'll be happy to merge this as the first ticket in 6.1, but that'll also mean that I am counting on you to fix any newly-discovered breakage over the xmas holidays :P",
    "created_at": "2013-12-16T22:55:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108966",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:9'></a>
I'll be happy to merge this as the first ticket in 6.1, but that'll also mean that I am counting on you to fix any newly-discovered breakage over the xmas holidays :P



---

archive/issue_comments_108967.json:
```json
{
    "body": "<a id='comment:0'></a>\nThe dependencies currently set suggest that #15506 (and as a corollary #15367 as well) need to be reviewed and merged as well then. Neither of those tickets are *essential* for merging this ticket, but they should help avoid (rare) failures.",
    "created_at": "2013-12-16T23:14:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108967",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:0'></a>
The dependencies currently set suggest that #15506 (and as a corollary #15367 as well) need to be reviewed and merged as well then. Neither of those tickets are *essential* for merging this ticket, but they should help avoid (rare) failures.



---

archive/issue_comments_108968.json:
```json
{
    "body": "<a id='comment:201'></a>\nReplying to [vbraun](#comment%3A199):\n> I'll be happy to merge this as the first ticket in 6.1,\n\nGreat, thanks!\n\n> but that'll also mean that I am counting on you to fix any newly-discovered breakage over the xmas holidays :P \n\nFair enough :-) Hmm, between the 26th and 31st I'll be offline, but other than this, I'll do my best!",
    "created_at": "2013-12-16T23:52:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108968",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:201'></a>
Replying to [vbraun](#comment%3A199):
> I'll be happy to merge this as the first ticket in 6.1,

Great, thanks!

> but that'll also mean that I am counting on you to fix any newly-discovered breakage over the xmas holidays :P 

Fair enough :-) Hmm, between the 26th and 31st I'll be offline, but other than this, I'll do my best!



---

archive/issue_comments_108969.json:
```json
{
    "body": "<a id='comment:2'></a>\nI am currently at reviewing #15367.",
    "created_at": "2013-12-17T10:29:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108969",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
I am currently at reviewing #15367.



---

archive/issue_comments_108970.json:
```json
{
    "body": "<a id='comment:3'></a>\nTogether with #15367 I get:\n\n```\nsage -t --long src/sage/combinat/ncsym/bases.py  # 1 doctest failed\nsage -t --long src/sage/structure/unique_representation.py  # 4 doctests failed\n```\nNot sure which ticket needs the fix but one of them does.",
    "created_at": "2013-12-19T13:07:58Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108970",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:3'></a>
Together with #15367 I get:

```
sage -t --long src/sage/combinat/ncsym/bases.py  # 1 doctest failed
sage -t --long src/sage/structure/unique_representation.py  # 4 doctests failed
```
Not sure which ticket needs the fix but one of them does.



---

archive/issue_comments_108971.json:
```json
{
    "body": "<a id='comment:4'></a>\nYou're a tease, Volker. :) What tests fail?\n\nHow do I get these two files up to the version you have? I tried \"git pull origin master\" and \"git pull origin develop\", but neither of them leaves me with #14912 merged in (which I suppose is what you have applied to unique_representation.py). Since #14912 is supposedly closed, I assume something is going wrong.\n\nOnce I find the issues, can I fix them on the public/ticket/10963 branch and keep my older changes? Or should I revert to hg somehow?",
    "created_at": "2013-12-19T13:24:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108971",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:4'></a>
You're a tease, Volker. :) What tests fail?

How do I get these two files up to the version you have? I tried "git pull origin master" and "git pull origin develop", but neither of them leaves me with #14912 merged in (which I suppose is what you have applied to unique_representation.py). Since #14912 is supposedly closed, I assume something is going wrong.

Once I find the issues, can I fix them on the public/ticket/10963 branch and keep my older changes? Or should I revert to hg somehow?



---

archive/issue_comments_108972.json:
```json
{
    "body": "<a id='comment:5'></a>\nLog:\n\nhttp://build.sagemath.org/sage/builders/%20%20fast%20UW%20mod%20%28Ubuntu%208.04%20x86_64%29%20incremental/builds/3/steps/shell_3/logs/stdio\n\nI'll release 6.0.beta0 shortly, you can merge that in the current ticket to reproduce the error. Or merge #10963 into this ticket if it is indeed the cause.",
    "created_at": "2013-12-19T13:38:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108972",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:5'></a>
Log:

http://build.sagemath.org/sage/builders/%20%20fast%20UW%20mod%20%28Ubuntu%208.04%20x86_64%29%20incremental/builds/3/steps/shell_3/logs/stdio

I'll release 6.0.beta0 shortly, you can merge that in the current ticket to reproduce the error. Or merge #10963 into this ticket if it is indeed the cause.



---

archive/issue_comments_108973.json:
```json
{
    "body": "<a id='comment:6'></a>\nThanks!\n\nOhkay, the ncsym issue is simple (one should simply replace the claimed output by the actual new output), but the unique_representation one is tricky. Simon??",
    "created_at": "2013-12-19T13:58:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108973",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:6'></a>
Thanks!

Ohkay, the ncsym issue is simple (one should simply replace the claimed output by the actual new output), but the unique_representation one is tricky. Simon??



---

archive/issue_comments_108974.json:
```json
{
    "body": "<a id='comment:207'></a>\nReplying to [darij](#comment%3A206):\n> Ohkay, the ncsym issue is simple (one should simply replace the claimed output by the actual new output), but the unique_representation one is tricky. Simon??\n\nScary. The failing doctest is not using cyclic garbage collection, nor categories, nor parents, nor coercion. Absolutely no idea why this could possibly be failing.",
    "created_at": "2013-12-19T14:18:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108974",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:207'></a>
Replying to [darij](#comment%3A206):
> Ohkay, the ncsym issue is simple (one should simply replace the claimed output by the actual new output), but the unique_representation one is tricky. Simon??

Scary. The failing doctest is not using cyclic garbage collection, nor categories, nor parents, nor coercion. Absolutely no idea why this could possibly be failing.



---

archive/issue_comments_108975.json:
```json
{
    "body": "<a id='comment:8'></a>\nInteraction with #14912, by any chance?",
    "created_at": "2013-12-19T14:37:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108975",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:8'></a>
Interaction with #14912, by any chance?



---

archive/issue_comments_108976.json:
```json
{
    "body": "<a id='comment:9'></a>\nWell -- #14912 is what added the failing doctests, but let's not kill the messenger. For some reason, del's (even those explicitly triggered) don't seem to actually delete instances anymore with #10963, and that's really spooky.",
    "created_at": "2013-12-19T14:41:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108976",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:9'></a>
Well -- #14912 is what added the failing doctests, but let's not kill the messenger. For some reason, del's (even those explicitly triggered) don't seem to actually delete instances anymore with #10963, and that's really spooky.



---

archive/issue_comments_108977.json:
```json
{
    "body": "<a id='comment:210'></a>\nReplying to [darij](#comment%3A206):\n> Ohkay, the ncsym issue is simple (one should simply replace the claimed output by the actual new output), but the unique_representation one is tricky. Simon??\n\nThe NCSym is this ticket (not #15367); see [comment:188](#comment%3A188) and #15150. As for the unique representations, there seems to be a memory leak. Using the failing example from #14912:\n\n```\nsage: import gc\nsage: O = SomeClass(1)\ncreating new instance for argument 1\nsage: del O\nsage: gc.garbage\n[]\nsage: gc.collect()\n3\nsage: O = SomeClass(1)\n\nsage: x = get_memory_usage()\nsage: x\n176.6640625\nsage: L = [SomeClass(i) for i in range(10^6)] # I removed the creation printing\nsage: del L\nsage: get_memory_usage()\n652.1171875\nsage: import gc\nsage: gc.collect()\n0\nsage: get_memory_usage()\n652.1171875\n```",
    "created_at": "2013-12-19T16:32:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108977",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:210'></a>
Replying to [darij](#comment%3A206):
> Ohkay, the ncsym issue is simple (one should simply replace the claimed output by the actual new output), but the unique_representation one is tricky. Simon??

The NCSym is this ticket (not #15367); see [comment:188](#comment%3A188) and #15150. As for the unique representations, there seems to be a memory leak. Using the failing example from #14912:

```
sage: import gc
sage: O = SomeClass(1)
creating new instance for argument 1
sage: del O
sage: gc.garbage
[]
sage: gc.collect()
3
sage: O = SomeClass(1)

sage: x = get_memory_usage()
sage: x
176.6640625
sage: L = [SomeClass(i) for i in range(10^6)] # I removed the creation printing
sage: del L
sage: get_memory_usage()
652.1171875
sage: import gc
sage: gc.collect()
0
sage: get_memory_usage()
652.1171875
```



---

archive/issue_comments_108978.json:
```json
{
    "body": "**Changing commit** from \"[a410d05b692eead348214b0378dfc78113a3bf5a](https://github.com/sagemath/sagetrac-mirror/commit/a410d05b692eead348214b0378dfc78113a3bf5a)\" to \"[588c27689bafc908b4e4f68646f9c5f3a2726a86](https://github.com/sagemath/sagetrac-mirror/commit/588c27689bafc908b4e4f68646f9c5f3a2726a86)\".",
    "created_at": "2013-12-19T16:33:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108978",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[a410d05b692eead348214b0378dfc78113a3bf5a](https://github.com/sagemath/sagetrac-mirror/commit/a410d05b692eead348214b0378dfc78113a3bf5a)" to "[588c27689bafc908b4e4f68646f9c5f3a2726a86](https://github.com/sagemath/sagetrac-mirror/commit/588c27689bafc908b4e4f68646f9c5f3a2726a86)".



---

archive/issue_comments_108979.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/588c276\">588c276</a></td><td><code>Fixed ncsym/bases.py doctest.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1e0990d\">1e0990d</a></td><td><code>Merge branch 'public/ticket/10963' of ssh://trac.sagemath.org:2222/sage into public/ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3735dfd\">3735dfd</a></td><td><code>Updated Sage version to 6.1.beta0</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/47c9c75\">47c9c75</a></td><td><code>Trac #15224: Iterate over the points of a toric variety</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f382aec\">f382aec</a></td><td><code>Trac #15403: knapsack's docstring doesn't document an useful feature</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0c95d3d\">0c95d3d</a></td><td><code>Trac #15228: Default embedding of Ljubljana graph (typo)</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/09fd00b\">09fd00b</a></td><td><code>Trac #12217: Finite field polynomials allow division by zero</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9acb905\">9acb905</a></td><td><code>Trac 12217: correctly handle division by zero</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8094791\">8094791</a></td><td><code>Trac #14912: UniqueRepresentation tutorial could use more love</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4ce6a49\">4ce6a49</a></td><td><code>Trac #15442: MILP solver CBC  : undefined symbol: dgetrf_</code></td></tr></table>\n",
    "created_at": "2013-12-19T16:33:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108979",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/588c276">588c276</a></td><td><code>Fixed ncsym/bases.py doctest.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1e0990d">1e0990d</a></td><td><code>Merge branch 'public/ticket/10963' of ssh://trac.sagemath.org:2222/sage into public/ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3735dfd">3735dfd</a></td><td><code>Updated Sage version to 6.1.beta0</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/47c9c75">47c9c75</a></td><td><code>Trac #15224: Iterate over the points of a toric variety</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f382aec">f382aec</a></td><td><code>Trac #15403: knapsack's docstring doesn't document an useful feature</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0c95d3d">0c95d3d</a></td><td><code>Trac #15228: Default embedding of Ljubljana graph (typo)</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/09fd00b">09fd00b</a></td><td><code>Trac #12217: Finite field polynomials allow division by zero</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9acb905">9acb905</a></td><td><code>Trac 12217: correctly handle division by zero</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8094791">8094791</a></td><td><code>Trac #14912: UniqueRepresentation tutorial could use more love</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4ce6a49">4ce6a49</a></td><td><code>Trac #15442: MILP solver CBC  : undefined symbol: dgetrf_</code></td></tr></table>




---

archive/issue_comments_108980.json:
```json
{
    "body": "<a id='comment:212'></a>\nReplying to [tscrim](#comment%3A210):\n> The NCSym is this ticket (not #15367); see [comment:188](#comment%3A188) and #15150. As for the unique representations, there seems to be a memory leak. Using the failing example from #14912:\n\nDo the usual: look up the objects using `[a for a in gc.get_objects() if type(a) is ...]` and use `objgraph` or `gc.get_referrers` to track who's keeping it alive. Should be pretty quick.",
    "created_at": "2013-12-19T18:57:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108980",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:212'></a>
Replying to [tscrim](#comment%3A210):
> The NCSym is this ticket (not #15367); see [comment:188](#comment%3A188) and #15150. As for the unique representations, there seems to be a memory leak. Using the failing example from #14912:

Do the usual: look up the objects using `[a for a in gc.get_objects() if type(a) is ...]` and use `objgraph` or `gc.get_referrers` to track who's keeping it alive. Should be pretty quick.



---

archive/issue_comments_108981.json:
```json
{
    "body": "<a id='comment:213'></a>\nReplying to [nbruin](#comment%3A212):\n> Replying to [tscrim](#comment%3A210):\n> > The NCSym is this ticket (not #15367); see [comment:188](#comment%3A188) and #15150. As for the unique representations, there seems to be a memory leak. Using the failing example from #14912:\n\n> Do the usual: look up the objects using `[a for a in gc.get_objects() if type(a) is ...]` and use `objgraph` or `gc.get_referrers` to track who's keeping it alive. Should be pretty quick.\n\nOK, I did not realise that [comment:210](#comment%3A210) is about something that can be done in an interactive session. I thought that it was something like \"it fails in the doctest, but not interactively\", which would be considerably more difficult to debug. It will take a while to build the branch of this ticket `:-/`...",
    "created_at": "2013-12-19T22:50:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108981",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:213'></a>
Replying to [nbruin](#comment%3A212):
> Replying to [tscrim](#comment%3A210):
> > The NCSym is this ticket (not #15367); see [comment:188](#comment%3A188) and #15150. As for the unique representations, there seems to be a memory leak. Using the failing example from #14912:

> Do the usual: look up the objects using `[a for a in gc.get_objects() if type(a) is ...]` and use `objgraph` or `gc.get_referrers` to track who's keeping it alive. Should be pretty quick.

OK, I did not realise that [comment:210](#comment%3A210) is about something that can be done in an interactive session. I thought that it was something like "it fails in the doctest, but not interactively", which would be considerably more difficult to debug. It will take a while to build the branch of this ticket `:-/`...



---

archive/issue_comments_108982.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150 #15506\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506\".",
    "created_at": "2013-12-19T22:53:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108982",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150 #15506" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506".



---

archive/issue_comments_108983.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0c907cf\">0c907cf</a></td><td><code>Reverted cached_function to weak_cached_function.</code></td></tr></table>\n",
    "created_at": "2013-12-20T02:08:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108983",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0c907cf">0c907cf</a></td><td><code>Reverted cached_function to weak_cached_function.</code></td></tr></table>




---

archive/issue_comments_108984.json:
```json
{
    "body": "**Changing commit** from \"[588c27689bafc908b4e4f68646f9c5f3a2726a86](https://github.com/sagemath/sagetrac-mirror/commit/588c27689bafc908b4e4f68646f9c5f3a2726a86)\" to \"[0c907cf81efeb9bd2d0a44f73539c4e32583c1be](https://github.com/sagemath/sagetrac-mirror/commit/0c907cf81efeb9bd2d0a44f73539c4e32583c1be)\".",
    "created_at": "2013-12-20T02:08:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108984",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[588c27689bafc908b4e4f68646f9c5f3a2726a86](https://github.com/sagemath/sagetrac-mirror/commit/588c27689bafc908b4e4f68646f9c5f3a2726a86)" to "[0c907cf81efeb9bd2d0a44f73539c4e32583c1be](https://github.com/sagemath/sagetrac-mirror/commit/0c907cf81efeb9bd2d0a44f73539c4e32583c1be)".



---

archive/issue_comments_108985.json:
```json
{
    "body": "<a id='comment:6'></a>\nOkay, I figured out the problem. The `weak_cached_function` was changed to a `cached_function` for `CachedRepresentation.__classcall__()` in `unique_representation.py`. IDK what impact this might have on the rest of things with this patch, but it fixes the memory leak.",
    "created_at": "2013-12-20T02:11:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108985",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>
Okay, I figured out the problem. The `weak_cached_function` was changed to a `cached_function` for `CachedRepresentation.__classcall__()` in `unique_representation.py`. IDK what impact this might have on the rest of things with this patch, but it fixes the memory leak.



---

archive/issue_comments_108986.json:
```json
{
    "body": "<a id='comment:217'></a>\nReplying to [tscrim](#comment%3A216):\n> Okay, I figured out the problem.\n\nExcellent work! I'm also happy to see that we're finally getting to a point that introducing memory leaks leads to failing doctests (at least sometimes).",
    "created_at": "2013-12-20T05:13:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108986",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:217'></a>
Replying to [tscrim](#comment%3A216):
> Okay, I figured out the problem.

Excellent work! I'm also happy to see that we're finally getting to a point that introducing memory leaks leads to failing doctests (at least sometimes).



---

archive/issue_comments_108987.json:
```json
{
    "body": "<a id='comment:218'></a>\nReplying to [tscrim](#comment%3A216):\n> Okay, I figured out the problem. The `weak_cached_function` was changed to a `cached_function` for `CachedRepresentation.__classcall__()` in `unique_representation.py`. IDK what impact this might have on the rest of things with this patch, but it fixes the memory leak.\n\nWHAT??????\n\nI made `CachedRepresentation.__classcall__()` a `@weak_cached_function` quite a long time ago, and I think I have also added doctests to show that a weak cache is used. So, how could it be possible that such a change almost went unnoticed?\n\n`git blame` shows that this change has been done by Nicolas in revision `9d9cae`, and\n\n```\n| | * | 362fd5e - # Tue Oct 29 20:14:19 2013 +0100 (vor 6 Wochen) <Nicolas M. Thiery>\n| | * | b2914f3 - # Sun Oct 27 13:58:49 2013 +0100 (vor 6 Wochen) <Frederic Chapoton>\n| | * | 9d9cae3 - # Sat Oct 19 11:50:04 2013 +0200 (vor 6 Wochen) <Nicolas M. Thiery>\n```\nWhy is there no proper commit message? Is this stuff from here? Have I really been the reviewer of this change `:-\\`?\n\nI notice that there are further uses of `@cached_function` in the changeset. So, I guess in the next round of review I need to take more care of this point.",
    "created_at": "2013-12-20T07:37:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108987",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:218'></a>
Replying to [tscrim](#comment%3A216):
> Okay, I figured out the problem. The `weak_cached_function` was changed to a `cached_function` for `CachedRepresentation.__classcall__()` in `unique_representation.py`. IDK what impact this might have on the rest of things with this patch, but it fixes the memory leak.

WHAT??????

I made `CachedRepresentation.__classcall__()` a `@weak_cached_function` quite a long time ago, and I think I have also added doctests to show that a weak cache is used. So, how could it be possible that such a change almost went unnoticed?

`git blame` shows that this change has been done by Nicolas in revision `9d9cae`, and

```
| | * | 362fd5e - # Tue Oct 29 20:14:19 2013 +0100 (vor 6 Wochen) <Nicolas M. Thiery>
| | * | b2914f3 - # Sun Oct 27 13:58:49 2013 +0100 (vor 6 Wochen) <Frederic Chapoton>
| | * | 9d9cae3 - # Sat Oct 19 11:50:04 2013 +0200 (vor 6 Wochen) <Nicolas M. Thiery>
```
Why is there no proper commit message? Is this stuff from here? Have I really been the reviewer of this change `:-\`?

I notice that there are further uses of `@cached_function` in the changeset. So, I guess in the next round of review I need to take more care of this point.



---

archive/issue_comments_108988.json:
```json
{
    "body": "<a id='comment:219'></a>\nReplying to [SimonKing](#comment%3A218):\n> Why is there no proper commit message? Is this stuff from here? Have I really been the reviewer of this change `:-\\`?\n\nYep ... It's right there at the end of [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)\n\n```\ndiff --git a/sage/structure/unique_representation.py b/sage/structure/unique_representation.py\n--- a/sage/structure/unique_representation.py\n+++ b/sage/structure/unique_representation.py\n@@ -29,7 +29,7 @@ AUTHORS:\n #                  http://www.gnu.org/licenses/\n #******************************************************************************\n \n-from sage.misc.cachefunc import weak_cached_function\n+from sage.misc.cachefunc import cached_function\n from sage.misc.classcall_metaclass import ClasscallMetaclass, typecall\n from sage.misc.fast_methods import WithEqualityById\n \n@@ -428,7 +428,7 @@ class CachedRepresentation:\n \n     _included_private_doc_ = [\"__classcall__\"]\n \n-    @weak_cached_function # automatically a staticmethod\n+    @cached_function # automatically a staticmethod\n     def __classcall__(cls, *args, **options):\n         \"\"\"\n         Constructs a new object of this class or reuse an existing one.\n```",
    "created_at": "2013-12-20T07:49:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108988",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:219'></a>
Replying to [SimonKing](#comment%3A218):
> Why is there no proper commit message? Is this stuff from here? Have I really been the reviewer of this change `:-\`?

Yep ... It's right there at the end of [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)

```
diff --git a/sage/structure/unique_representation.py b/sage/structure/unique_representation.py
--- a/sage/structure/unique_representation.py
+++ b/sage/structure/unique_representation.py
@@ -29,7 +29,7 @@ AUTHORS:
 #                  http://www.gnu.org/licenses/
 #******************************************************************************
 
-from sage.misc.cachefunc import weak_cached_function
+from sage.misc.cachefunc import cached_function
 from sage.misc.classcall_metaclass import ClasscallMetaclass, typecall
 from sage.misc.fast_methods import WithEqualityById
 
@@ -428,7 +428,7 @@ class CachedRepresentation:
 
     _included_private_doc_ = ["__classcall__"]
 
-    @weak_cached_function # automatically a staticmethod
+    @cached_function # automatically a staticmethod
     def __classcall__(cls, *args, **options):
         """
         Constructs a new object of this class or reuse an existing one.
```



---

archive/issue_comments_108989.json:
```json
{
    "body": "<a id='comment:0'></a>\nI digged through the history of the patch on the mercurial queue, and I apparently introduced this hunk back in August 2012 (changeset 7492). Why in the hell I did that, I don't remember. I guess I must have misproperly rebased the patch upon the then-in-developpement #12215.\n\nIn any cases, thanks Travis for catching this!",
    "created_at": "2013-12-20T08:42:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108989",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:0'></a>
I digged through the history of the patch on the mercurial queue, and I apparently introduced this hunk back in August 2012 (changeset 7492). Why in the hell I did that, I don't remember. I guess I must have misproperly rebased the patch upon the then-in-developpement #12215.

In any cases, thanks Travis for catching this!



---

archive/issue_comments_108990.json:
```json
{
    "body": "<a id='comment:1'></a>\nNote that this branch currently does not merge cleanly with #15303.",
    "created_at": "2013-12-20T09:05:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108990",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:1'></a>
Note that this branch currently does not merge cleanly with #15303.



---

archive/issue_events_085474.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-12-20T10:05:56Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85474"
}
```



---

archive/issue_events_085475.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-12-20T10:05:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85475"
}
```



---

archive/issue_comments_108991.json:
```json
{
    "body": "<a id='comment:222'></a>\nReplying to [nbruin](#comment%3A219):\n> Replying to [SimonKing](#comment%3A218):\n> > Why is there no proper commit message? Is this stuff from here? Have I really been the reviewer of this change `:-\\`?\n\n> \n> Yep ... It's right there at the end of [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)\n\nArgh. Sorry that I didn't notice it.\n\nBut why can this not have led to doctest failures before? I am sure that I added doctests showing that `CachedRepresentation` uses a weak cache! Have these tests been removed by the patch?\n\nSomething else (and this is a question to Volker, hence, \"needs info\"):\n\nWhy is there no proper commit message in the git log? I thought that `sage --dev import-patch` would preserve the commit messages from the mercurial patch.\n\nAnd what shall we do about it? By git's idiosyncratic notion of history, adding a proper commit message would imply a history change, and since this branch is already in use by people, we can't change the history, it would create merge conflicts, etc.\n\nAFAIK, adding a commit message in the mercurial workflow was trivial, since only the code matters for whether or not subsequent patches apply cleanly.",
    "created_at": "2013-12-20T10:05:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108991",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:222'></a>
Replying to [nbruin](#comment%3A219):
> Replying to [SimonKing](#comment%3A218):
> > Why is there no proper commit message? Is this stuff from here? Have I really been the reviewer of this change `:-\`?

> 
> Yep ... It's right there at the end of [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)

Argh. Sorry that I didn't notice it.

But why can this not have led to doctest failures before? I am sure that I added doctests showing that `CachedRepresentation` uses a weak cache! Have these tests been removed by the patch?

Something else (and this is a question to Volker, hence, "needs info"):

Why is there no proper commit message in the git log? I thought that `sage --dev import-patch` would preserve the commit messages from the mercurial patch.

And what shall we do about it? By git's idiosyncratic notion of history, adding a proper commit message would imply a history change, and since this branch is already in use by people, we can't change the history, it would create merge conflicts, etc.

AFAIK, adding a commit message in the mercurial workflow was trivial, since only the code matters for whether or not subsequent patches apply cleanly.



---

archive/issue_comments_108992.json:
```json
{
    "body": "<a id='comment:223'></a>\nReplying to [SimonKing](#comment%3A222):\n> Why is there no proper commit message in the git log? I thought that `sage --dev import-patch` would preserve the commit messages from the mercurial patch.\n\nLooks like a bug in `sage --dev import-patch`. The commit message of [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch) looks like\n\n```\ncommit fc1993ce33bef97f50fbf3d52aef525bd1f3da8d\nAuthor: Nicolas M. Thiery <nthiery@users.sf.net>\nDate:   Sat Oct 19 09:50:04 2013 +0000\n\n    # Sat Oct 19 11:50:04 2013 +0200\n    \n    # Node ID f98c0b44c17dbb718c8449f3eabcbc7b8bdc825d\n    # Parent  2306f17ea8f3e40d1a3668c24695a50bfad34d1f\n    #10963: More functorial constructions\n```",
    "created_at": "2013-12-20T10:28:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108992",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:223'></a>
Replying to [SimonKing](#comment%3A222):
> Why is there no proper commit message in the git log? I thought that `sage --dev import-patch` would preserve the commit messages from the mercurial patch.

Looks like a bug in `sage --dev import-patch`. The commit message of [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch) looks like

```
commit fc1993ce33bef97f50fbf3d52aef525bd1f3da8d
Author: Nicolas M. Thiery <nthiery@users.sf.net>
Date:   Sat Oct 19 09:50:04 2013 +0000

    # Sat Oct 19 11:50:04 2013 +0200
    
    # Node ID f98c0b44c17dbb718c8449f3eabcbc7b8bdc825d
    # Parent  2306f17ea8f3e40d1a3668c24695a50bfad34d1f
    #10963: More functorial constructions
```



---

archive/issue_comments_108993.json:
```json
{
    "body": "<a id='comment:4'></a>\nJudging from Anne's posts, this branch is way too widely used for git amend...\n\nCan we just leave the nameless commit there, it being the least of the problems?",
    "created_at": "2013-12-20T10:39:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108993",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:4'></a>
Judging from Anne's posts, this branch is way too widely used for git amend...

Can we just leave the nameless commit there, it being the least of the problems?



---

archive/issue_events_085476.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-12-20T10:56:39Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85476"
}
```



---

archive/issue_events_085477.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-12-20T10:56:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85477"
}
```



---

archive/issue_comments_108994.json:
```json
{
    "body": "<a id='comment:5'></a>\nLeave the commit as it is. Maybe have a look at the converted commit message next time. In any case, there is only a finite number of mercurial patches to convert ;-)",
    "created_at": "2013-12-20T10:56:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108994",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:5'></a>
Leave the commit as it is. Maybe have a look at the converted commit message next time. In any case, there is only a finite number of mercurial patches to convert ;-)



---

archive/issue_comments_108995.json:
```json
{
    "body": "<a id='comment:6'></a>\nHi,\n\nI would like to understand that:\n\n```\nsage: from sage.categories.category_with_axiom import CategoryWithAxiom_over_base_ring\nsage: class A(CategoryWithAxiom_over_base_ring):\n....:    pass\nsage: class B(CategoryWithAxiom_over_base_ring):\n....:     pass          \n....:                \nsage: setattr(A, \"B\", B)\nsage: getattr(A, \"B\")\nValueError                                Traceback (most recent call last):\n...\nValueError: could not infer axiom for the nested class <class '__main__.B'> of <class '__main__.A'>\n```\n\nWhy do we have this limitation?\n\nMerry Christmas,\nJean-Baptiste",
    "created_at": "2013-12-24T12:14:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108995",
    "user": "https://trac.sagemath.org/admin/accounts/users/elixyre"
}
```

<a id='comment:6'></a>
Hi,

I would like to understand that:

```
sage: from sage.categories.category_with_axiom import CategoryWithAxiom_over_base_ring
sage: class A(CategoryWithAxiom_over_base_ring):
....:    pass
sage: class B(CategoryWithAxiom_over_base_ring):
....:     pass          
....:                
sage: setattr(A, "B", B)
sage: getattr(A, "B")
ValueError                                Traceback (most recent call last):
...
ValueError: could not infer axiom for the nested class <class '__main__.B'> of <class '__main__.A'>
```

Why do we have this limitation?

Merry Christmas,
Jean-Baptiste



---

archive/issue_comments_108996.json:
```json
{
    "body": "<a id='comment:7'></a>\nJean-Baptiste, if you have questions about functionality you should probably ask on sage-devel. If you think it is a bug or missing feature feel free to open a separate ticket.",
    "created_at": "2013-12-25T13:15:52Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108996",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:7'></a>
Jean-Baptiste, if you have questions about functionality you should probably ask on sage-devel. If you think it is a bug or missing feature feel free to open a separate ticket.



---

archive/issue_comments_108997.json:
```json
{
    "body": "<a id='comment:8'></a>\nI'm now getting a fairly reproducable error in `set_species.py`:\n\n```\nsage -t --long src/sage/combinat/species/set_species.py\n**********************************************************************\nFile \"src/sage/combinat/species/set_species.py\", line 172, in sage.combinat.species.set_species.SetSpecies._cis\nFailed example:\n    g = S.cycle_index_series()\nExpected nothing\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded' in  ignored\n**********************************************************************\n```",
    "created_at": "2013-12-25T15:26:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108997",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:8'></a>
I'm now getting a fairly reproducable error in `set_species.py`:

```
sage -t --long src/sage/combinat/species/set_species.py
**********************************************************************
File "src/sage/combinat/species/set_species.py", line 172, in sage.combinat.species.set_species.SetSpecies._cis
Failed example:
    g = S.cycle_index_series()
Expected nothing
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded' in  ignored
**********************************************************************
```



---

archive/issue_comments_108998.json:
```json
{
    "body": "<a id='comment:229'></a>\nReplying to [vbraun](#comment%3A228):\n> I'm now getting a fairly reproducable error in `set_species.py`:\n\n#15506 is a dependency, but it is not merged into the branch (or did I miss something?). I suppose odds are that #15506 fixes the problem.",
    "created_at": "2013-12-25T16:34:58Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108998",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:229'></a>
Replying to [vbraun](#comment%3A228):
> I'm now getting a fairly reproducable error in `set_species.py`:

#15506 is a dependency, but it is not merged into the branch (or did I miss something?). I suppose odds are that #15506 fixes the problem.



---

archive/issue_comments_108999.json:
```json
{
    "body": "**Changing branch** from \"[public/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963)\" to \"[u/SimonKing/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/10963)\".",
    "created_at": "2013-12-25T16:54:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-108999",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing branch** from "[public/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963)" to "[u/SimonKing/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/10963)".



---

archive/issue_comments_109000.json:
```json
{
    "body": "<a id='comment:1'></a>\nI expected that `sage --dev push` would push to the existing branch `public/ticket/10963`, but instead it created a branch in `u/SimonKing/`. Anyway, the new branch has #15506 merged in. Could you test if this fixes the problem?",
    "created_at": "2013-12-25T16:58:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109000",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
I expected that `sage --dev push` would push to the existing branch `public/ticket/10963`, but instead it created a branch in `u/SimonKing/`. Anyway, the new branch has #15506 merged in. Could you test if this fixes the problem?



---

archive/issue_events_085478.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-12-25T16:58:12Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85478"
}
```



---

archive/issue_events_085479.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-12-25T16:58:12Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85479"
}
```



---

archive/issue_comments_109001.json:
```json
{
    "body": "**Changing commit** from \"[0c907cf81efeb9bd2d0a44f73539c4e32583c1be](https://github.com/sagemath/sagetrac-mirror/commit/0c907cf81efeb9bd2d0a44f73539c4e32583c1be)\" to \"[14e63b6feebddaf3dc7ab1d569d219690a765ce8](https://github.com/sagemath/sagetrac-mirror/commit/14e63b6feebddaf3dc7ab1d569d219690a765ce8)\".",
    "created_at": "2013-12-25T16:58:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109001",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing commit** from "[0c907cf81efeb9bd2d0a44f73539c4e32583c1be](https://github.com/sagemath/sagetrac-mirror/commit/0c907cf81efeb9bd2d0a44f73539c4e32583c1be)" to "[14e63b6feebddaf3dc7ab1d569d219690a765ce8](https://github.com/sagemath/sagetrac-mirror/commit/14e63b6feebddaf3dc7ab1d569d219690a765ce8)".



---

archive/issue_comments_109002.json:
```json
{
    "body": "<a id='comment:2'></a>\nAll tests passed for me.",
    "created_at": "2013-12-25T17:04:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109002",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>
All tests passed for me.



---

archive/issue_comments_109003.json:
```json
{
    "body": "<a id='comment:3'></a>\nBut then again, this is not failing for me previously (with the most recent develop branch merged in).",
    "created_at": "2013-12-25T17:07:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109003",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:3'></a>
But then again, this is not failing for me previously (with the most recent develop branch merged in).



---

archive/issue_comments_109004.json:
```json
{
    "body": "**Changing branch** from \"[u/SimonKing/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/10963)\" to \"[public/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963)\".",
    "created_at": "2013-12-25T17:14:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109004",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[u/SimonKing/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/10963)" to "[public/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963)".



---

archive/issue_comments_109005.json:
```json
{
    "body": "**Changing commit** from \"[14e63b6feebddaf3dc7ab1d569d219690a765ce8](https://github.com/sagemath/sagetrac-mirror/commit/14e63b6feebddaf3dc7ab1d569d219690a765ce8)\" to \"[5ccf253b17c151d8e773037ac634a64f84f03075](https://github.com/sagemath/sagetrac-mirror/commit/5ccf253b17c151d8e773037ac634a64f84f03075)\".",
    "created_at": "2013-12-25T17:14:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109005",
    "user": "https://github.com/vbraun"
}
```

**Changing commit** from "[14e63b6feebddaf3dc7ab1d569d219690a765ce8](https://github.com/sagemath/sagetrac-mirror/commit/14e63b6feebddaf3dc7ab1d569d219690a765ce8)" to "[5ccf253b17c151d8e773037ac634a64f84f03075](https://github.com/sagemath/sagetrac-mirror/commit/5ccf253b17c151d8e773037ac634a64f84f03075)".



---

archive/issue_comments_109006.json:
```json
{
    "body": "<a id='comment:4'></a>\n#15506 is already merged (this is why its closed) even if its not in a beta release. I'll revert to the old branch.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5ccf253\">5ccf253</a></td><td><code>Merge branch 'u/SimonKing/ticket/10963' of trac.sagemath.org:sage into public/ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3d978e9\">3d978e9</a></td><td><code>Merge branch 'develop' into public/ticket/10963</code></td></tr></table>\n",
    "created_at": "2013-12-25T17:14:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109006",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:4'></a>
#15506 is already merged (this is why its closed) even if its not in a beta release. I'll revert to the old branch.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5ccf253">5ccf253</a></td><td><code>Merge branch 'u/SimonKing/ticket/10963' of trac.sagemath.org:sage into public/ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3d978e9">3d978e9</a></td><td><code>Merge branch 'develop' into public/ticket/10963</code></td></tr></table>




---

archive/issue_comments_109007.json:
```json
{
    "body": "<a id='comment:5'></a>\nYou can try to build it on mod, that seems like its going to trigger it:\nhttp://build.sagemath.org/sage/builders/%20%20fast%20UW%20mod%20%28Ubuntu%208.04%20x86_64%29%20incremental/builds/34",
    "created_at": "2013-12-25T17:19:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109007",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:5'></a>
You can try to build it on mod, that seems like its going to trigger it:
http://build.sagemath.org/sage/builders/%20%20fast%20UW%20mod%20%28Ubuntu%208.04%20x86_64%29%20incremental/builds/34



---

archive/issue_comments_109008.json:
```json
{
    "body": "<a id='comment:6'></a>\nUnfortunately I too get no errors with both new and old state of the branch.\n\n--\n\nSimonKing:\n\n```\n I notice that there are further uses of @cached_function in the changeset. So, I guess in the next round of review I need to take more care of this point. \n```\nHas this been done? (I only see one revert in 0c907cf81efeb9bd2d0a44f73539c4e32583c1be.)",
    "created_at": "2013-12-25T17:47:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109008",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:6'></a>
Unfortunately I too get no errors with both new and old state of the branch.

--

SimonKing:

```
 I notice that there are further uses of @cached_function in the changeset. So, I guess in the next round of review I need to take more care of this point. 
```
Has this been done? (I only see one revert in 0c907cf81efeb9bd2d0a44f73539c4e32583c1be.)



---

archive/issue_events_085480.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-12-25T18:42:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85480"
}
```



---

archive/issue_events_085481.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-12-25T18:42:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85481"
}
```



---

archive/issue_comments_109009.json:
```json
{
    "body": "**Work Issues:** Detect and fix Heisenbugs",
    "created_at": "2013-12-25T18:42:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109009",
    "user": "https://github.com/simon-king-jena"
}
```

**Work Issues:** Detect and fix Heisenbugs



---

archive/issue_comments_109010.json:
```json
{
    "body": "<a id='comment:7'></a>\nSigh.\n\nIt seems, according to Darij and Volker, that the existence of errors depends on the machine and so on.\n\nWith the new branch, I get two errors, namely:\n\n```\nsage -t src/sage/sets/set.py\n**********************************************************************\nFile \"src/sage/sets/set.py\", line 1046, in sage.sets.set.Set_object_union.__cmp__\nFailed example:\n    Y = Set(ZZ^2).union(Set(ZZ^3))\nExpected nothing\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb668971c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x9cdc77c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xa6b814c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb668971c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb6689584> ignored\n**********************************************************************\n1 item had failures:\n   1 of   6 in sage.sets.set.Set_object_union.__cmp__\n    [325 tests, 1 failure, 1.01 s]\n```\nand\n\n```\nsage -t src/sage/combinat/ncsf_qsym/tutorial.py\n**********************************************************************\nFile \"src/sage/combinat/ncsf_qsym/tutorial.py\", line 30, in sage.combinat.ncsf_qsym.tutorial\nFailed example:\n    QSym = QuasiSymmetricFunctions(QQ)\nExpected nothing\nGot:\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0x9adac8c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0x9adac8c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb6689584> ignored\n**********************************************************************\n1 item had failures:\n   1 of  93 in sage.combinat.ncsf_qsym.tutorial\n    [92 tests, 1 failure, 4.67 s]\n```\n\nNeedless to say, since we all knew already: It is a Heisenbug. I get the above with `make ptest`. There is no error if I do\n\n```\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/combinat/ncsf_qsym/tutorial.py\nRunning doctests with ID 2013-12-25-19-38-34-bd3e15f5.\nDoctesting 1 file.\nsage -t src/sage/combinat/ncsf_qsym/tutorial.py\n    [92 tests, 4.56 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 4.6 seconds\n    cpu time: 4.6 seconds\n    cumulative wall time: 4.6 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/sets/set.py\nRunning doctests with ID 2013-12-25-19-38-48-d7f7d326.\nDoctesting 1 file.\nsage -t src/sage/sets/set.py\n    [325 tests, 0.92 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 1.1 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.9 seconds\n```\n\nNils, could it be that I forgot to merge another of your fixes to weak value dictionary respectively triple- or monodict?",
    "created_at": "2013-12-25T18:42:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109010",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Sigh.

It seems, according to Darij and Volker, that the existence of errors depends on the machine and so on.

With the new branch, I get two errors, namely:

```
sage -t src/sage/sets/set.py
**********************************************************************
File "src/sage/sets/set.py", line 1046, in sage.sets.set.Set_object_union.__cmp__
Failed example:
    Y = Set(ZZ^2).union(Set(ZZ^3))
Expected nothing
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb668971c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x9cdc77c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xa6b814c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb668971c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb6689584> ignored
**********************************************************************
1 item had failures:
   1 of   6 in sage.sets.set.Set_object_union.__cmp__
    [325 tests, 1 failure, 1.01 s]
```
and

```
sage -t src/sage/combinat/ncsf_qsym/tutorial.py
**********************************************************************
File "src/sage/combinat/ncsf_qsym/tutorial.py", line 30, in sage.combinat.ncsf_qsym.tutorial
Failed example:
    QSym = QuasiSymmetricFunctions(QQ)
Expected nothing
Got:
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0x9adac8c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0x9adac8c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb6689584> ignored
**********************************************************************
1 item had failures:
   1 of  93 in sage.combinat.ncsf_qsym.tutorial
    [92 tests, 1 failure, 4.67 s]
```

Needless to say, since we all knew already: It is a Heisenbug. I get the above with `make ptest`. There is no error if I do

```
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/combinat/ncsf_qsym/tutorial.py
Running doctests with ID 2013-12-25-19-38-34-bd3e15f5.
Doctesting 1 file.
sage -t src/sage/combinat/ncsf_qsym/tutorial.py
    [92 tests, 4.56 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 4.6 seconds
    cpu time: 4.6 seconds
    cumulative wall time: 4.6 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/sets/set.py
Running doctests with ID 2013-12-25-19-38-48-d7f7d326.
Doctesting 1 file.
sage -t src/sage/sets/set.py
    [325 tests, 0.92 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 1.1 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.9 seconds
```

Nils, could it be that I forgot to merge another of your fixes to weak value dictionary respectively triple- or monodict?



---

archive/issue_comments_109011.json:
```json
{
    "body": "<a id='comment:8'></a>\nAFAIK, #15506 contains all fixes to the \"recursion depth exceeded\" problem that Nils came up with.\n\nInterestingly, in one of the errors, the \"recursion depth exceeded\" combines weak value dictionary and triple dict:\n\n```\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb668971c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x9cdc77c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xa6b814c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb668971c> ignored\n    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb6689584> ignored\n```",
    "created_at": "2013-12-25T18:54:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109011",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
AFAIK, #15506 contains all fixes to the "recursion depth exceeded" problem that Nils came up with.

Interestingly, in one of the errors, the "recursion depth exceeded" combines weak value dictionary and triple dict:

```
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb668971c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.MonoDictEraser object at 0x9cdc77c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b06554> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xa6b814c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9b064ac> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb668971c> ignored
    Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <sage.misc.weak_dict.WeakValueDictEraser object at 0xb6689584> ignored
```



---

archive/issue_comments_109012.json:
```json
{
    "body": "<a id='comment:239'></a>\nReplying to [SimonKing](#comment%3A238):\n> AFAIK, #15506 contains all fixes to the \"recursion depth exceeded\" problem that Nils came up with.\n\nWell, we observed the error, came up with an example that produced the same error, and made sure that error didn't occur any more. It may be we're looking at a different cause here (for one thing, it's hard to imagine that doctests produce such deeply nested structures that even the naive deletion code would trigger a recursion depth error). Another hypothesis is that there is a dealloc somewhere that is genuinely recursing on itself, perhaps creating a new parent upon deletion, that then immediately becomes available for deallocation as well. It could be that the first \"deeper\" call in those cases is always an eraser. In that case, it's just that we're forcing the eraser to work with increasingly smaller (python) stack headroom, in a way that apparently even the trashcan can't avoid. \n\nI'd say the most promising debugging technique is to set a breakpoint on this RuntimeError (or patch python to throw a segfault or something like it) so that we get to see the stack backtrace  for when this problem arises. I'd hope that seeing which routines are involved (I expect it not to be just dictionaries) will show where the real problem may lie.",
    "created_at": "2013-12-25T19:21:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109012",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:239'></a>
Replying to [SimonKing](#comment%3A238):
> AFAIK, #15506 contains all fixes to the "recursion depth exceeded" problem that Nils came up with.

Well, we observed the error, came up with an example that produced the same error, and made sure that error didn't occur any more. It may be we're looking at a different cause here (for one thing, it's hard to imagine that doctests produce such deeply nested structures that even the naive deletion code would trigger a recursion depth error). Another hypothesis is that there is a dealloc somewhere that is genuinely recursing on itself, perhaps creating a new parent upon deletion, that then immediately becomes available for deallocation as well. It could be that the first "deeper" call in those cases is always an eraser. In that case, it's just that we're forcing the eraser to work with increasingly smaller (python) stack headroom, in a way that apparently even the trashcan can't avoid. 

I'd say the most promising debugging technique is to set a breakpoint on this RuntimeError (or patch python to throw a segfault or something like it) so that we get to see the stack backtrace  for when this problem arises. I'd hope that seeing which routines are involved (I expect it not to be just dictionaries) will show where the real problem may lie.



---

archive/issue_comments_109013.json:
```json
{
    "body": "<a id='comment:0'></a>\nAny thoughts? Is the problem that we need a better traceback?",
    "created_at": "2014-01-04T02:29:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109013",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:0'></a>
Any thoughts? Is the problem that we need a better traceback?



---

archive/issue_comments_109014.json:
```json
{
    "body": "<a id='comment:1'></a>\nHere is another stab at debugging this: Put an `abort()` in `PyErr_WriteUnraisable` to just die and let gdb produce a backtrace where an exception would be ignored. See attachment. Then recompile Python, Cython, and the Sage library with `CFLAGS='-O0 -g3'` for good measure.\n\nThe first surprise is that this always hits `PyErr_WriteUnraisable` when quitting Sage, its only that printing the message is disabled while Python shuts down (stderr == None). So skip over that, too.\n\nThen force a failure by running\n\n```\nsage -btp --long --global-iterations=100 src/sage/combinat/species/\n```\nfor a while. Stack backtrace of the eventual failure is at http://boxen.math.washington.edu/home/vbraun/logs/crash_functorial_constructions.log",
    "created_at": "2014-01-04T10:17:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109014",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:1'></a>
Here is another stab at debugging this: Put an `abort()` in `PyErr_WriteUnraisable` to just die and let gdb produce a backtrace where an exception would be ignored. See attachment. Then recompile Python, Cython, and the Sage library with `CFLAGS='-O0 -g3'` for good measure.

The first surprise is that this always hits `PyErr_WriteUnraisable` when quitting Sage, its only that printing the message is disabled while Python shuts down (stderr == None). So skip over that, too.

Then force a failure by running

```
sage -btp --long --global-iterations=100 src/sage/combinat/species/
```
for a while. Stack backtrace of the eventual failure is at http://boxen.math.washington.edu/home/vbraun/logs/crash_functorial_constructions.log



---

archive/issue_comments_109015.json:
```json
{
    "body": "Patch for python to abort instead of ignore exception",
    "created_at": "2014-01-04T10:18:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109015",
    "user": "https://github.com/vbraun"
}
```

Patch for python to abort instead of ignore exception



---

archive/attachments_014903.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "debug_exception_ignored.patch",
    "asset_url": "tarball://root/attachments/ticket10963/debug_exception_ignored.patch",
    "created_at": "2014-01-04T18:29:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket10963/debug_exception_ignored.patch",
    "user": "https://github.com/nbruin"
}
```



---

archive/issue_comments_109016.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Attachment:** [debug_exception_ignored.patch](https://github.com/sagemath/sage/files/ticket10963/debug_exception_ignored.patch)\n\nWould it make sense to put this debugging on a different ticket? The length of\nthis one makes working on it excruciating (especially tickets with a lot of\ncomments seem particularly slow with trac) and the debugging involved in this is\na bit of a side-issue.\n\nSince it is a python recursion bug, we should probably look at the \".py\" files\ninvolved, so I did a grep:\n\n```\n$ grep \"^#.*py:[0-9]*$\" crash_functorial_constructions.log\n#24 0x00007fee3aa07580 in __classget__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:507\n#38 0x00007fee3aa07580 in base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:243\n#47 0x00007fee3aa07580 in _base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:381\n#57 0x00007fee3aa07580 in axiom_of_nested_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:281\n#66 0x00007fee3aa07580 in __classget__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:507\n...\n#710 0x00007fee3aa07580 in base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:243\n#719 0x00007fee3aa07580 in _base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:381\n#729 0x00007fee3aa07580 in axiom_of_nested_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:281\n#738 0x00007fee3aa07580 in __classget__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:507\n...\n#2768 0x00007fee3aa07580 in base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:243\n#2777 0x00007fee3aa07580 in _base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:381\n#2787 0x00007fee3aa07580 in axiom_of_nested_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:281\n#2796 0x00007fee3aa07580 in __classget__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:507\n#2809 0x00007fee3aa07580 in extra_super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/sets_cat.py:1826\n#2812 0x00007fee3aa07580 in super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/covariant_functorial_construction.py:399\n#2815 0x00007fee3aa07580 in _super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:1015\n#2823 0x00007fee3aa07580 in _all_super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:885\n#2831 0x00007fee3aa07580 in _super_categories_for_classes() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:1040\n#2839 0x00007fee3aa07580 in _make_named_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:1246\n#2843 0x00007fee3aa07580 in subcategory_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:1290\n#2851 0x00007fee3aa07580 in __init__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:504\n#2856 0x00007fee3aa07580 in __init__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/covariant_functorial_construction.py:355\n#2867 0x00007fee3aa07580 in __classcall__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:1021\n#2875 0x00007fee3aa07580 in __classcall__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:465\n#2883 0x00007fee3aa07580 in category_of() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/covariant_functorial_construction.py:269\n...\n#3180 0x00007fee3aa07580 in WithRealizations() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/with_realizations.py:181\n#3183 0x00007fee3aa07580 in __init__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/combinat/sf/sf.py:767\n#3194 0x00007fee3aa07580 in __classcall__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:1021\n#3206 0x00007fee3aa07580 in __init__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/combinat/species/generating_series.py:327\n#3217 0x00007fee3aa07580 in CycleIndexSeriesRing() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/combinat/species/generating_series.py:314\n...\n```\nSo it would seem that the creation of a `SymmetricFunctions` object leads via a\nlong chain of `WithRealizations` calls to the creation of a category (frame\n`#2851`) which calls `extra_super_categories` (frame `#2809`) and then goes off\nto a long chain of calls involving `axiom_of_nested_class` and\n`base_category_class_and_axiom` (66 deep apparently)\n\nWhat probably causes the eventual error is that building such a deep call chain\nrequires memory and thus can trigger a garbage collection, at which point there\nmay be some extra room required on top of the python call stack to execute the\nvarious weakref callbacks. Apparently that room isn't there.\n\n66 calls is suspiciously deep, but perhaps symmetric functions realizations are\nindeed extremely complicated. Let's look at the relevant frames:\n\n```\n#2807 0x00007fee2dcdcd6d in __pyx_tp_descr_get_4sage_4misc_11lazy_import_LazyImport() at /home/vbraun/Code/sage/src/sage/misc/lazy_import.c:7252\n#2808 0x00007fee3a9a2c00 in _PyObject_GenericGetAttrWithDict() at /home/vbraun/Code/sage/local/var/tmp/sage/build/python-2.7.5.p1/src/Objects/object.c:1439\n#2809 0x00007fee3aa07580 in extra_super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/sets_cat.py:1826\n> 1826                return [Sets().Facade()]\n```\n\nThere seems to be a lazy import involved, and indeed, there seems to be a cycle\nof 24 frames that keeps repeating from this point on. So one hypothesis might be\nthat somehow some lazy import resolution doesn't go right, which confuses the\n`base_category_class_and_axiom` code, which them keeps recursing. Perhaps a\nscript like this rings some bells with the persons who are familiar with the\ncode?",
    "created_at": "2014-01-04T18:29:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109016",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:2'></a>
**Attachment:** [debug_exception_ignored.patch](https://github.com/sagemath/sage/files/ticket10963/debug_exception_ignored.patch)

Would it make sense to put this debugging on a different ticket? The length of
this one makes working on it excruciating (especially tickets with a lot of
comments seem particularly slow with trac) and the debugging involved in this is
a bit of a side-issue.

Since it is a python recursion bug, we should probably look at the ".py" files
involved, so I did a grep:

```
$ grep "^#.*py:[0-9]*$" crash_functorial_constructions.log
#24 0x00007fee3aa07580 in __classget__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:507
#38 0x00007fee3aa07580 in base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:243
#47 0x00007fee3aa07580 in _base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:381
#57 0x00007fee3aa07580 in axiom_of_nested_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:281
#66 0x00007fee3aa07580 in __classget__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:507
...
#710 0x00007fee3aa07580 in base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:243
#719 0x00007fee3aa07580 in _base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:381
#729 0x00007fee3aa07580 in axiom_of_nested_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:281
#738 0x00007fee3aa07580 in __classget__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:507
...
#2768 0x00007fee3aa07580 in base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:243
#2777 0x00007fee3aa07580 in _base_category_class_and_axiom() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:381
#2787 0x00007fee3aa07580 in axiom_of_nested_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:281
#2796 0x00007fee3aa07580 in __classget__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:507
#2809 0x00007fee3aa07580 in extra_super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/sets_cat.py:1826
#2812 0x00007fee3aa07580 in super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/covariant_functorial_construction.py:399
#2815 0x00007fee3aa07580 in _super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:1015
#2823 0x00007fee3aa07580 in _all_super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:885
#2831 0x00007fee3aa07580 in _super_categories_for_classes() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:1040
#2839 0x00007fee3aa07580 in _make_named_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:1246
#2843 0x00007fee3aa07580 in subcategory_class() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:1290
#2851 0x00007fee3aa07580 in __init__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:504
#2856 0x00007fee3aa07580 in __init__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/covariant_functorial_construction.py:355
#2867 0x00007fee3aa07580 in __classcall__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:1021
#2875 0x00007fee3aa07580 in __classcall__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/category.py:465
#2883 0x00007fee3aa07580 in category_of() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/covariant_functorial_construction.py:269
...
#3180 0x00007fee3aa07580 in WithRealizations() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/with_realizations.py:181
#3183 0x00007fee3aa07580 in __init__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/combinat/sf/sf.py:767
#3194 0x00007fee3aa07580 in __classcall__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:1021
#3206 0x00007fee3aa07580 in __init__() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/combinat/species/generating_series.py:327
#3217 0x00007fee3aa07580 in CycleIndexSeriesRing() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/combinat/species/generating_series.py:314
...
```
So it would seem that the creation of a `SymmetricFunctions` object leads via a
long chain of `WithRealizations` calls to the creation of a category (frame
`#2851`) which calls `extra_super_categories` (frame `#2809`) and then goes off
to a long chain of calls involving `axiom_of_nested_class` and
`base_category_class_and_axiom` (66 deep apparently)

What probably causes the eventual error is that building such a deep call chain
requires memory and thus can trigger a garbage collection, at which point there
may be some extra room required on top of the python call stack to execute the
various weakref callbacks. Apparently that room isn't there.

66 calls is suspiciously deep, but perhaps symmetric functions realizations are
indeed extremely complicated. Let's look at the relevant frames:

```
#2807 0x00007fee2dcdcd6d in __pyx_tp_descr_get_4sage_4misc_11lazy_import_LazyImport() at /home/vbraun/Code/sage/src/sage/misc/lazy_import.c:7252
#2808 0x00007fee3a9a2c00 in _PyObject_GenericGetAttrWithDict() at /home/vbraun/Code/sage/local/var/tmp/sage/build/python-2.7.5.p1/src/Objects/object.c:1439
#2809 0x00007fee3aa07580 in extra_super_categories() at /home/vbraun/Code/sage/local/lib/python2.7/site-packages/sage/categories/sets_cat.py:1826
> 1826                return [Sets().Facade()]
```

There seems to be a lazy import involved, and indeed, there seems to be a cycle
of 24 frames that keeps repeating from this point on. So one hypothesis might be
that somehow some lazy import resolution doesn't go right, which confuses the
`base_category_class_and_axiom` code, which them keeps recursing. Perhaps a
script like this rings some bells with the persons who are familiar with the
code?



---

archive/issue_comments_109017.json:
```json
{
    "body": "<a id='comment:3'></a>\nIf you look at the Cython backtrace (2nd half of the crash log) then most stack frames (24 .. 2796) have something to do with `category_with_axiom.py`. E.g. search for `base_category_class`. \n\nSo it seems that this is not a garbage collection issue at all, it is really this ticket recursing very deeply. Is the recursion really needed? My guess is not since the depth has something to do with when the garbage collection is running, so must be too many temporary objects. Everything recursive can be written without recursion...",
    "created_at": "2014-01-04T18:31:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109017",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:3'></a>
If you look at the Cython backtrace (2nd half of the crash log) then most stack frames (24 .. 2796) have something to do with `category_with_axiom.py`. E.g. search for `base_category_class`. 

So it seems that this is not a garbage collection issue at all, it is really this ticket recursing very deeply. Is the recursion really needed? My guess is not since the depth has something to do with when the garbage collection is running, so must be too many temporary objects. Everything recursive can be written without recursion...



---

archive/issue_comments_109018.json:
```json
{
    "body": "<a id='comment:4'></a>\nAfter instrumenting `base_category_class_and_axiom` a bit with a counter for recursion level (inc-ed on entry, dec-ed on exit points) we get:\n\n```\nFile \"src/sage/combinat/species/empty_species.py\", line 42, in sage.combinat.species.empty_species.EmptySpecies\nFailed example:\n    X.cycle_index_series().coefficients(4)\nExpected:\n    [0, 0, 0, 0]\nGot:\n    base_cat_and_ax LVL 1, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 2, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 3, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 4, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 5, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 6, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 7, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 8, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 9, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 10, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 11, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 12, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 13, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 14, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 15, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 16, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 17, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 18, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 19, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 20, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 21, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 22, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 23, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 24, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 25, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 26, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 27, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 28, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 29, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 30, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 31, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 32, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 33, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 34, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 35, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 36, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 37, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 38, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 39, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 40, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 41, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 42, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 43, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 44, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 45, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 46, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 47, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 48, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 49, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 50, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 51, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 52, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 53, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 54, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 55, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 56, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 57, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 58, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 59, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 60, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 61, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 62, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 63, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 64, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 65, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 66, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 67, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 68, cls=<class 'sage.categories.facade_sets.FacadeSets'>\n    base_cat_and_ax LVL 1, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 2, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 3, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 4, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 5, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 6, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 7, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 8, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 9, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 10, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 11, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 12, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 13, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 14, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 15, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 16, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 17, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 18, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 19, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 20, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 21, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 22, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 23, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 24, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 25, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 26, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 27, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 28, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 29, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 30, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 31, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 32, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 33, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 34, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 35, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 36, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 37, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 38, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 39, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 40, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 41, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 42, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 43, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 44, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 45, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 46, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 47, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 48, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 49, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 50, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 51, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 52, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 53, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 54, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 55, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 56, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 57, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 58, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 59, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 60, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 61, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 62, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 63, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 64, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 65, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 66, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 67, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 68, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 69, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 70, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 71, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 72, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 73, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 74, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 75, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>\n    base_cat_and_ax LVL 1, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 2, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 3, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 4, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 5, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 6, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 7, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 8, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 9, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 10, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 11, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 12, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 13, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 14, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 15, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 16, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 17, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 18, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 19, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 20, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 21, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 22, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 23, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 24, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 25, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 26, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 27, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 28, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 29, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 30, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 31, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 32, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 33, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 34, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 35, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 36, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 37, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 38, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 39, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 40, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 41, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 42, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 43, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 44, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 45, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 46, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 47, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 48, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 49, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 50, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 51, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 52, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 53, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 54, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 55, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 56, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 57, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 58, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 59, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 60, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 61, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 62, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 63, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 64, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 65, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 66, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 67, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 68, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 69, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 70, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 71, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>\n    base_cat_and_ax LVL 1, cls=<class 'sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis'>\n    base_cat_and_ax LVL 1, cls=<class 'sage.categories.vector_spaces.VectorSpaces.WithBasis'>\n    base_cat_and_ax LVL 1, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 2, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 3, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 4, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 5, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 6, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 7, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 8, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 9, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 10, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 11, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 12, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 13, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 14, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 15, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 16, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 17, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 18, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 19, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 20, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 21, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 22, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 23, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 24, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 25, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 26, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 27, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 28, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 29, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 30, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 31, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 32, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 33, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 34, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 35, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 36, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 37, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 38, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 39, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 40, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 41, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 42, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 43, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 44, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 45, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 46, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 47, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 48, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 49, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 50, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 51, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 52, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 53, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 54, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 55, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 56, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 57, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 58, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 59, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 60, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>\n    base_cat_and_ax LVL 1, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 2, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 3, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 4, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 5, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 6, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 7, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 8, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 9, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 10, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 11, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 12, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 13, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 14, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 15, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 16, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 17, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 18, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 19, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 20, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 21, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 22, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 23, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 24, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 25, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 26, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 27, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 28, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 29, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 30, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 31, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 32, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 33, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 34, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 35, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 36, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 37, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 38, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 39, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 40, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 41, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 42, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 43, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 44, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 45, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 46, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 47, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 48, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 49, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 50, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 51, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 52, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 53, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 54, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 55, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 56, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 57, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 58, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 59, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 60, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 61, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 62, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 63, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 64, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 65, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 66, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 67, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 68, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 69, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 70, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    base_cat_and_ax LVL 71, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>\n    [0, 0, 0, 0]\n**********************************************************************\n1 item had failures:\n   1 of  21 in sage.combinat.species.empty_species.EmptySpecies\n    [37 tests, 1 failure, 0.08 s]\n----------------------------------------------------------------------\nsage -t src/sage/combinat/species/empty_species.py  # 1 doctest failed\n----------------------------------------------------------------------\nTotal time for all tests: 0.1 seconds\n    cpu time: 0.1 seconds\n    cumulative wall time: 0.1 seconds\n```\nso it does seem that even when this code doesn't produce errors, it recurses\nridiculously deeply. Als, it keeps importing the same file! (that's not apparent\nfrom the output given here, but it was when I put the print statement at the\nimport instruction.\n\nThis seems another case where an obscure bug report leads us to finding serious\ndeficiencies in code.",
    "created_at": "2014-01-04T20:06:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109018",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:4'></a>
After instrumenting `base_category_class_and_axiom` a bit with a counter for recursion level (inc-ed on entry, dec-ed on exit points) we get:

```
File "src/sage/combinat/species/empty_species.py", line 42, in sage.combinat.species.empty_species.EmptySpecies
Failed example:
    X.cycle_index_series().coefficients(4)
Expected:
    [0, 0, 0, 0]
Got:
    base_cat_and_ax LVL 1, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 2, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 3, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 4, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 5, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 6, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 7, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 8, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 9, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 10, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 11, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 12, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 13, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 14, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 15, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 16, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 17, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 18, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 19, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 20, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 21, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 22, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 23, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 24, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 25, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 26, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 27, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 28, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 29, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 30, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 31, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 32, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 33, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 34, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 35, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 36, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 37, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 38, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 39, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 40, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 41, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 42, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 43, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 44, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 45, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 46, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 47, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 48, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 49, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 50, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 51, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 52, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 53, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 54, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 55, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 56, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 57, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 58, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 59, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 60, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 61, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 62, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 63, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 64, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 65, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 66, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 67, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 68, cls=<class 'sage.categories.facade_sets.FacadeSets'>
    base_cat_and_ax LVL 1, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 2, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 3, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 4, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 5, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 6, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 7, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 8, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 9, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 10, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 11, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 12, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 13, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 14, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 15, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 16, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 17, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 18, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 19, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 20, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 21, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 22, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 23, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 24, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 25, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 26, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 27, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 28, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 29, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 30, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 31, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 32, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 33, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 34, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 35, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 36, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 37, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 38, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 39, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 40, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 41, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 42, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 43, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 44, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 45, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 46, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 47, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 48, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 49, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 50, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 51, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 52, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 53, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 54, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 55, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 56, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 57, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 58, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 59, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 60, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 61, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 62, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 63, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 64, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 65, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 66, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 67, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 68, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 69, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 70, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 71, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 72, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 73, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 74, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 75, cls=<class 'sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis'>
    base_cat_and_ax LVL 1, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 2, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 3, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 4, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 5, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 6, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 7, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 8, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 9, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 10, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 11, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 12, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 13, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 14, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 15, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 16, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 17, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 18, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 19, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 20, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 21, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 22, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 23, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 24, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 25, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 26, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 27, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 28, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 29, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 30, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 31, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 32, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 33, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 34, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 35, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 36, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 37, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 38, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 39, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 40, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 41, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 42, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 43, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 44, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 45, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 46, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 47, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 48, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 49, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 50, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 51, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 52, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 53, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 54, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 55, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 56, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 57, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 58, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 59, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 60, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 61, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 62, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 63, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 64, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 65, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 66, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 67, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 68, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 69, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 70, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 71, cls=<class 'sage.categories.algebras_with_basis.AlgebrasWithBasis'>
    base_cat_and_ax LVL 1, cls=<class 'sage.categories.magmatic_algebras.MagmaticAlgebras.WithBasis'>
    base_cat_and_ax LVL 1, cls=<class 'sage.categories.vector_spaces.VectorSpaces.WithBasis'>
    base_cat_and_ax LVL 1, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 2, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 3, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 4, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 5, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 6, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 7, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 8, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 9, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 10, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 11, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 12, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 13, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 14, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 15, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 16, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 17, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 18, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 19, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 20, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 21, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 22, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 23, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 24, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 25, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 26, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 27, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 28, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 29, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 30, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 31, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 32, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 33, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 34, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 35, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 36, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 37, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 38, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 39, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 40, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 41, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 42, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 43, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 44, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 45, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 46, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 47, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 48, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 49, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 50, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 51, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 52, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 53, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 54, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 55, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 56, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 57, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 58, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 59, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 60, cls=<class 'sage.categories.modules_with_basis.ModulesWithBasis'>
    base_cat_and_ax LVL 1, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 2, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 3, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 4, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 5, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 6, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 7, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 8, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 9, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 10, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 11, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 12, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 13, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 14, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 15, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 16, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 17, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 18, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 19, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 20, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 21, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 22, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 23, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 24, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 25, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 26, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 27, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 28, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 29, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 30, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 31, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 32, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 33, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 34, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 35, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 36, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 37, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 38, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 39, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 40, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 41, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 42, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 43, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 44, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 45, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 46, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 47, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 48, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 49, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 50, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 51, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 52, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 53, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 54, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 55, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 56, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 57, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 58, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 59, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 60, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 61, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 62, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 63, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 64, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 65, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 66, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 67, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 68, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 69, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 70, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    base_cat_and_ax LVL 71, cls=<class 'sage.categories.coalgebras_with_basis.CoalgebrasWithBasis'>
    [0, 0, 0, 0]
**********************************************************************
1 item had failures:
   1 of  21 in sage.combinat.species.empty_species.EmptySpecies
    [37 tests, 1 failure, 0.08 s]
----------------------------------------------------------------------
sage -t src/sage/combinat/species/empty_species.py  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 0.1 seconds
    cpu time: 0.1 seconds
    cumulative wall time: 0.1 seconds
```
so it does seem that even when this code doesn't produce errors, it recurses
ridiculously deeply. Als, it keeps importing the same file! (that's not apparent
from the output given here, but it was when I put the print statement at the
import instruction.

This seems another case where an obscure bug report leads us to finding serious
deficiencies in code.



---

archive/issue_comments_109019.json:
```json
{
    "body": "<a id='comment:5'></a>\nA little further experimenting shows that the recursion occurs in the `assert` statement in the fragment\n\n```\n                base_module = importlib.import_module(\"sage.categories.\"+base_module_name)\n                base_category_class = getattr(base_module, base_name)\n                assert getattr(base_category_class, axiom, None) is cls, \\\n                    \"Missing (lazy import) link for %s to %s for axiom %s?\"%(base_category_class, cls, axiom)\n                return base_category_class, axiom\n```\nSo my guess is that the recursions happen when the relevant module has to be actually (lazily) imported. The `getattr` on an object defined in the module triggers the actual loading of the module and the initialization code of the module triggers the execution of the same `base_category_class_and_axiom` incantation. This is a cached method, but since it is still running through its first call the cache isn't there yet, so another call happens. The surprising thing is that the code finishes at all. It wouldn't surprise me if this is just another incarnation of a circular import problem. \n\nAs the tracebacks above suggest, the lazyclassattribute `_base_category_class_and_axiom` is probably to blame (it calls the function `base_category_class_and_axiom`). Its computation is triggered by the class attribute `_axiom` and it looks quite probable that there is some (meta)class magic somewhere that causes this to be called during initialization of some modules.\n\nIt surprises me that the code does finish. A hash collision would be too rare an event to explain it (especially because most of python only suffers in performance from a bad hash, not in correctness), so my bet is that things depend on a certain order of import/execution and as we know, execution order during imports isn't completely deterministic.\n\nTo fix this: it seems that a lot of magic (looking at module\nnames etc.) is there for convenience (i.e., that a FiniteSet is a Set with the\nFinite axiom). Perhaps it's worthwhile to consider coding these bits a little\nmore conservatively, exchanging some convenience for enhanced maintainability.\n\nWhen Nicholas looks at this (he's the only one who has a chance of being able to\nfix this stuff) I hope he will reconsider some of the design decision. I think\nthere are a lot of potential contributors who can appreciate if the fundamental\ninfrastructure of Sage continues to read like a little more normal python code\nif at all possible.\n\nThe code here looks amazingly ingenious and smart, but unfortunately that is not\na desirable trait for basic infrastructure that needs to be maintained for a\nlong time and by many people.\n\nI think the bug/behaviour we're running into now illustrates why \"smart\" code is\noften not a good idea: as we see here, the behaviour can be hard to predict.",
    "created_at": "2014-01-04T22:15:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109019",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:5'></a>
A little further experimenting shows that the recursion occurs in the `assert` statement in the fragment

```
                base_module = importlib.import_module("sage.categories."+base_module_name)
                base_category_class = getattr(base_module, base_name)
                assert getattr(base_category_class, axiom, None) is cls, \
                    "Missing (lazy import) link for %s to %s for axiom %s?"%(base_category_class, cls, axiom)
                return base_category_class, axiom
```
So my guess is that the recursions happen when the relevant module has to be actually (lazily) imported. The `getattr` on an object defined in the module triggers the actual loading of the module and the initialization code of the module triggers the execution of the same `base_category_class_and_axiom` incantation. This is a cached method, but since it is still running through its first call the cache isn't there yet, so another call happens. The surprising thing is that the code finishes at all. It wouldn't surprise me if this is just another incarnation of a circular import problem. 

As the tracebacks above suggest, the lazyclassattribute `_base_category_class_and_axiom` is probably to blame (it calls the function `base_category_class_and_axiom`). Its computation is triggered by the class attribute `_axiom` and it looks quite probable that there is some (meta)class magic somewhere that causes this to be called during initialization of some modules.

It surprises me that the code does finish. A hash collision would be too rare an event to explain it (especially because most of python only suffers in performance from a bad hash, not in correctness), so my bet is that things depend on a certain order of import/execution and as we know, execution order during imports isn't completely deterministic.

To fix this: it seems that a lot of magic (looking at module
names etc.) is there for convenience (i.e., that a FiniteSet is a Set with the
Finite axiom). Perhaps it's worthwhile to consider coding these bits a little
more conservatively, exchanging some convenience for enhanced maintainability.

When Nicholas looks at this (he's the only one who has a chance of being able to
fix this stuff) I hope he will reconsider some of the design decision. I think
there are a lot of potential contributors who can appreciate if the fundamental
infrastructure of Sage continues to read like a little more normal python code
if at all possible.

The code here looks amazingly ingenious and smart, but unfortunately that is not
a desirable trait for basic infrastructure that needs to be maintained for a
long time and by many people.

I think the bug/behaviour we're running into now illustrates why "smart" code is
often not a good idea: as we see here, the behaviour can be hard to predict.



---

archive/issue_comments_109020.json:
```json
{
    "body": "<a id='comment:6'></a>\nIf it finishes (but non-deterministically) then it must be that it recurses until it chances upon a hash collision in a cache. I don't have any other explanation...",
    "created_at": "2014-01-04T22:42:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109020",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:6'></a>
If it finishes (but non-deterministically) then it must be that it recurses until it chances upon a hash collision in a cache. I don't have any other explanation...



---

archive/issue_comments_109021.json:
```json
{
    "body": "<a id='comment:247'></a>\nReplying to [vbraun](#comment%3A246):\n> If it finishes (but non-deterministically) then it must be that it recurses until it chances upon a hash collision in a cache. I don't have any other explanation...\n\nI'm wondering... would that mean that hash collisions leave active objects in Sage prone to getting garbage-collected? Isn't that a use-after-free danger?",
    "created_at": "2014-01-05T02:02:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109021",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:247'></a>
Replying to [vbraun](#comment%3A246):
> If it finishes (but non-deterministically) then it must be that it recurses until it chances upon a hash collision in a cache. I don't have any other explanation...

I'm wondering... would that mean that hash collisions leave active objects in Sage prone to getting garbage-collected? Isn't that a use-after-free danger?



---

archive/issue_comments_109022.json:
```json
{
    "body": "<a id='comment:248'></a>\nReplying to [vbraun](#comment%3A246):\n> If it finishes (but non-deterministically) then it must be that it recurses until it chances upon a hash collision in a cache. I don't have any other explanation...\n\nWell we could test against this by modifying the behavior of `@cached_method` by adding a key with some dummy class like `CatchedMethodCalledNotReturned`, and if that class is the returned value, raise an error. Although I don't see why it should terminate if there is a hash collision because there should not be an equal key in the cache; unless something scarier is happening: `==` is `True` but the corresponding hashes aren't...",
    "created_at": "2014-01-05T03:03:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109022",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:248'></a>
Replying to [vbraun](#comment%3A246):
> If it finishes (but non-deterministically) then it must be that it recurses until it chances upon a hash collision in a cache. I don't have any other explanation...

Well we could test against this by modifying the behavior of `@cached_method` by adding a key with some dummy class like `CatchedMethodCalledNotReturned`, and if that class is the returned value, raise an error. Although I don't see why it should terminate if there is a hash collision because there should not be an equal key in the cache; unless something scarier is happening: `==` is `True` but the corresponding hashes aren't...



---

archive/issue_comments_109023.json:
```json
{
    "body": "<a id='comment:9'></a>\nA cheap way out is simply removing the assert statement. I haven't seen excessive recursion without it. However, since this code is infrastructure for all of sage, it would be good to know exactly what the bad condition is that happens with the assert and why avoiding the assert is enough to avoid the bad scenarios.",
    "created_at": "2014-01-05T03:28:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109023",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:9'></a>
A cheap way out is simply removing the assert statement. I haven't seen excessive recursion without it. However, since this code is infrastructure for all of sage, it would be good to know exactly what the bad condition is that happens with the assert and why avoiding the assert is enough to avoid the bad scenarios.



---

archive/issue_comments_109024.json:
```json
{
    "body": "<a id='comment:250'></a>\nReplying to [nbruin](#comment%3A245):\n> A little further experimenting shows that the recursion occurs in the `assert` statement in the fragment\n> \n> ```\n>                 base_module = importlib.import_module(\"sage.categories.\"+base_module_name)\n>                 base_category_class = getattr(base_module, base_name)\n>                 assert getattr(base_category_class, axiom, None) is cls, \\\n>                     \"Missing (lazy import) link for %s to %s for axiom %s?\"%(base_category_class, cls, axiom)\n>                 return base_category_class, axiom\n> ```\n\nIndeed, this looks suspicious. It could result in importing something while importing it.\n\n> This is a cached method, but since it is still running through its first call the cache isn't there yet, so another call happens.\n\nThis could be a work-around: Start the function by *filling* the cache of this function with some value (say: `(cls, '')`, or some special value like `NotImplemented` that can be tested against when calling the function somewhere), so that the function really will be called only once for each input.\n\nOr rather: We could wrap it in `try: ... finally:`, emptying the cache from the wrong value. Then, in case of an error being raised, the cache will be clean afterwards, and if there is no error then the cache will be filled with the correct value anyway.\n\nBTW, note the typo in the docstring: `however we ca notdo it robustly`...\n\n> The surprising thing is that the code finishes at all.\n\nIndeed.\n\n> To fix this: it seems that a lot of magic (looking at module\n> names etc.) is there for convenience (i.e., that a FiniteSet is a Set with the\n> Finite axiom). Perhaps it's worthwhile to consider coding these bits a little\n> more conservatively, exchanging some convenience for enhanced maintainability.\n\n+1. In some discussion above, I suggested to keep track of the axioms of a category by a tuple that is stored as an attribute. Actually I suggested a different approach to implement axioms. But I think this ticket has progressed too much, and *if* (really \"if\", I don't know if I will) I want to try to implement the alternative approach, then I can still do it after merging Nicolas' approach.",
    "created_at": "2014-01-05T10:11:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109024",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:250'></a>
Replying to [nbruin](#comment%3A245):
> A little further experimenting shows that the recursion occurs in the `assert` statement in the fragment
> 
> ```
>                 base_module = importlib.import_module("sage.categories."+base_module_name)
>                 base_category_class = getattr(base_module, base_name)
>                 assert getattr(base_category_class, axiom, None) is cls, \
>                     "Missing (lazy import) link for %s to %s for axiom %s?"%(base_category_class, cls, axiom)
>                 return base_category_class, axiom
> ```

Indeed, this looks suspicious. It could result in importing something while importing it.

> This is a cached method, but since it is still running through its first call the cache isn't there yet, so another call happens.

This could be a work-around: Start the function by *filling* the cache of this function with some value (say: `(cls, '')`, or some special value like `NotImplemented` that can be tested against when calling the function somewhere), so that the function really will be called only once for each input.

Or rather: We could wrap it in `try: ... finally:`, emptying the cache from the wrong value. Then, in case of an error being raised, the cache will be clean afterwards, and if there is no error then the cache will be filled with the correct value anyway.

BTW, note the typo in the docstring: `however we ca notdo it robustly`...

> The surprising thing is that the code finishes at all.

Indeed.

> To fix this: it seems that a lot of magic (looking at module
> names etc.) is there for convenience (i.e., that a FiniteSet is a Set with the
> Finite axiom). Perhaps it's worthwhile to consider coding these bits a little
> more conservatively, exchanging some convenience for enhanced maintainability.

+1. In some discussion above, I suggested to keep track of the axioms of a category by a tuple that is stored as an attribute. Actually I suggested a different approach to implement axioms. But I think this ticket has progressed too much, and *if* (really "if", I don't know if I will) I want to try to implement the alternative approach, then I can still do it after merging Nicolas' approach.



---

archive/issue_comments_109025.json:
```json
{
    "body": "<a id='comment:1'></a>\nI tried to trace how often the lazy class attribute `_base_category_class_and_axiom` is called for each class. Note that (as a lazy attribute) it should be called only once!! This is how often it is called:\n\n```\n sage.categories.finite_semigroups.FiniteSemigroups: 76,\n sage.categories.sets_cat.Sets.Infinite: 1,\n sage.categories.commutative_rings.CommutativeRings: 82,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveAssociative.AdditiveCommutative: 1,\n sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative: 1,\n sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative: 1,\n sage.categories.additive_magmas.AdditiveUnital.AdditiveInverse: 1,\n sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital: 1,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveCommutative.AdditiveUnital: 1,\n sage.categories.magmas.Magmas.Commutative: 1,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.Associative: 1,\n sage.categories.magmas.Unital.Inverse: 1,\n sage.categories.magmas.Magmas.Unital: 1,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.AdditiveInverse: 1,\n sage.categories.commutative_algebras.CommutativeAlgebras: 81,\n sage.categories.finite_fields.FiniteFields: 82,\n sage.categories.finite_enumerated_sets.FiniteEnumeratedSets: 82,\n sage.categories.finite_monoids.FiniteMonoids: 76,\n sage.categories.finite_sets.FiniteSets: 79,\n sage.categories.unital_algebras.UnitalAlgebras.WithBasis: 1,\n sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets: 81\n```\n\nThat's bad.",
    "created_at": "2014-01-05T10:21:52Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109025",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
I tried to trace how often the lazy class attribute `_base_category_class_and_axiom` is called for each class. Note that (as a lazy attribute) it should be called only once!! This is how often it is called:

```
 sage.categories.finite_semigroups.FiniteSemigroups: 76,
 sage.categories.sets_cat.Sets.Infinite: 1,
 sage.categories.commutative_rings.CommutativeRings: 82,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveAssociative.AdditiveCommutative: 1,
 sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative: 1,
 sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative: 1,
 sage.categories.additive_magmas.AdditiveUnital.AdditiveInverse: 1,
 sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital: 1,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveCommutative.AdditiveUnital: 1,
 sage.categories.magmas.Magmas.Commutative: 1,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.Associative: 1,
 sage.categories.magmas.Unital.Inverse: 1,
 sage.categories.magmas.Magmas.Unital: 1,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.AdditiveInverse: 1,
 sage.categories.commutative_algebras.CommutativeAlgebras: 81,
 sage.categories.finite_fields.FiniteFields: 82,
 sage.categories.finite_enumerated_sets.FiniteEnumeratedSets: 82,
 sage.categories.finite_monoids.FiniteMonoids: 76,
 sage.categories.finite_sets.FiniteSets: 79,
 sage.categories.unital_algebras.UnitalAlgebras.WithBasis: 1,
 sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets: 81
```

That's bad.



---

archive/issue_comments_109026.json:
```json
{
    "body": "<a id='comment:2'></a>\nPS: Probably this can also explain the startup time regression. Hence, we should think how to fix it.",
    "created_at": "2014-01-05T10:22:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109026",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
PS: Probably this can also explain the startup time regression. Hence, we should think how to fix it.



---

archive/issue_comments_109027.json:
```json
{
    "body": "<a id='comment:3'></a>\nPPS: I think I understand why the code is finishing at all. The \"assert\" statement involves importing something. Hence, it may fail with an `ImportError`. This is caught (`except (ImportError,AttributeError)`), in which case the axiom under consideration is skipped.\n\nIn the worst case, this means that the *correct* axiom is skipped, so that eventually ` TypeError(\"Could not retrieve base category class for %s\"%cls)` is raised (EDIT: And the code certainly deals well with this type error, so that it does not surface).",
    "created_at": "2014-01-05T10:29:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109027",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
PPS: I think I understand why the code is finishing at all. The "assert" statement involves importing something. Hence, it may fail with an `ImportError`. This is caught (`except (ImportError,AttributeError)`), in which case the axiom under consideration is skipped.

In the worst case, this means that the *correct* axiom is skipped, so that eventually ` TypeError("Could not retrieve base category class for %s"%cls)` is raised (EDIT: And the code certainly deals well with this type error, so that it does not surface).



---

archive/issue_comments_109028.json:
```json
{
    "body": "<a id='comment:4'></a>\nHere is the proof of concept of a cached function that prevents infinite recursion by storing some value in its cache:\n\n```\nsage: @cached_function          \n....: def bla(x):\n....:     bla.cache[(x,),()] = None\n....:     try:\n....:         if x:\n....:             return bla(x-1)+2\n....:         return bla(x) or 100\n....:     finally:\n....:         try:\n....:             del bla.cache[(x,),()]\n....:         except KeyError:\n....:             print x,\"not stored\"\n....:             \nsage: bla(3)\n106\n```",
    "created_at": "2014-01-05T10:42:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109028",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
Here is the proof of concept of a cached function that prevents infinite recursion by storing some value in its cache:

```
sage: @cached_function          
....: def bla(x):
....:     bla.cache[(x,),()] = None
....:     try:
....:         if x:
....:             return bla(x-1)+2
....:         return bla(x) or 100
....:     finally:
....:         try:
....:             del bla.cache[(x,),()]
....:         except KeyError:
....:             print x,"not stored"
....:             
sage: bla(3)
106
```



---

archive/issue_comments_109029.json:
```json
{
    "body": "<a id='comment:5'></a>\nDoing what I sketched above, Sage starts and I get these numbers:\n\n```\nsage: from sage.categories.category_with_axiom import lazy_cls_attr_counter\nsage: lazy_cls_attr_counter\n{sage.categories.sets_cat.Sets.Infinite: 1,\n sage.categories.commutative_rings.CommutativeRings: 2,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveAssociative.AdditiveCommutative: 1,\n sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative: 1,\n sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative: 1,\n sage.categories.additive_magmas.AdditiveUnital.AdditiveInverse: 1,\n sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital: 1,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveCommutative.AdditiveUnital: 1,\n sage.categories.magmas.Magmas.Commutative: 1,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.Associative: 1,\n sage.categories.magmas.Unital.Inverse: 1,\n sage.categories.magmas.Magmas.Unital: 1,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.AdditiveInverse: 1,\n sage.categories.commutative_algebras.CommutativeAlgebras: 2,\n sage.categories.finite_fields.FiniteFields: 2,\n sage.categories.finite_sets.FiniteSets: 2,\n sage.categories.finite_enumerated_sets.FiniteEnumeratedSets: 2,\n sage.categories.finite_semigroups.FiniteSemigroups: 2,\n sage.categories.finite_monoids.FiniteMonoids: 2,\n sage.categories.unital_algebras.UnitalAlgebras.WithBasis: 1,\n sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets: 2}\n```\nbut in the end, things seem to be correct, for example:\n\n```\nsage: sage.categories.finite_semigroups.FiniteSemigroups._base_category_class_and_axiom\n(sage.categories.semigroups.Semigroups, 'Finite')\nsage: sage.categories.finite_enumerated_sets.FiniteEnumeratedSets._base_category_class_and_axiom\n(sage.categories.enumerated_sets.EnumeratedSets, 'Finite')\n```\n\nHence, I think my approach solves the problem.",
    "created_at": "2014-01-05T10:53:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109029",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
Doing what I sketched above, Sage starts and I get these numbers:

```
sage: from sage.categories.category_with_axiom import lazy_cls_attr_counter
sage: lazy_cls_attr_counter
{sage.categories.sets_cat.Sets.Infinite: 1,
 sage.categories.commutative_rings.CommutativeRings: 2,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveAssociative.AdditiveCommutative: 1,
 sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative: 1,
 sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative: 1,
 sage.categories.additive_magmas.AdditiveUnital.AdditiveInverse: 1,
 sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital: 1,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveCommutative.AdditiveUnital: 1,
 sage.categories.magmas.Magmas.Commutative: 1,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.Associative: 1,
 sage.categories.magmas.Unital.Inverse: 1,
 sage.categories.magmas.Magmas.Unital: 1,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.AdditiveInverse: 1,
 sage.categories.commutative_algebras.CommutativeAlgebras: 2,
 sage.categories.finite_fields.FiniteFields: 2,
 sage.categories.finite_sets.FiniteSets: 2,
 sage.categories.finite_enumerated_sets.FiniteEnumeratedSets: 2,
 sage.categories.finite_semigroups.FiniteSemigroups: 2,
 sage.categories.finite_monoids.FiniteMonoids: 2,
 sage.categories.unital_algebras.UnitalAlgebras.WithBasis: 1,
 sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets: 2}
```
but in the end, things seem to be correct, for example:

```
sage: sage.categories.finite_semigroups.FiniteSemigroups._base_category_class_and_axiom
(sage.categories.semigroups.Semigroups, 'Finite')
sage: sage.categories.finite_enumerated_sets.FiniteEnumeratedSets._base_category_class_and_axiom
(sage.categories.enumerated_sets.EnumeratedSets, 'Finite')
```

Hence, I think my approach solves the problem.



---

archive/issue_comments_109030.json:
```json
{
    "body": "**Changing commit** from \"[5ccf253b17c151d8e773037ac634a64f84f03075](https://github.com/sagemath/sagetrac-mirror/commit/5ccf253b17c151d8e773037ac634a64f84f03075)\" to \"[8eaf51a82c4e2194769db13457979ae601ebbc04](https://github.com/sagemath/sagetrac-mirror/commit/8eaf51a82c4e2194769db13457979ae601ebbc04)\".",
    "created_at": "2014-01-05T13:19:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109030",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing commit** from "[5ccf253b17c151d8e773037ac634a64f84f03075](https://github.com/sagemath/sagetrac-mirror/commit/5ccf253b17c151d8e773037ac634a64f84f03075)" to "[8eaf51a82c4e2194769db13457979ae601ebbc04](https://github.com/sagemath/sagetrac-mirror/commit/8eaf51a82c4e2194769db13457979ae601ebbc04)".



---

archive/issue_comments_109031.json:
```json
{
    "body": "<a id='comment:7'></a>\nWith the new commit, all tests pass for me. Please check whether you think it could be a good solution.",
    "created_at": "2014-01-05T13:20:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109031",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
With the new commit, all tests pass for me. Please check whether you think it could be a good solution.



---

archive/issue_comments_109032.json:
```json
{
    "body": "<a id='comment:8'></a>\nPS: Perhaps one should remove the `print \"this should not happen!\",cls` that I have put at the end of the cached function. Or: One should make the warning provide a clear message to submit a bug report.",
    "created_at": "2014-01-05T14:21:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109032",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
PS: Perhaps one should remove the `print "this should not happen!",cls` that I have put at the end of the cached function. Or: One should make the warning provide a clear message to submit a bug report.



---

archive/issue_comments_109033.json:
```json
{
    "body": "<a id='comment:9'></a>\nI'm not completely convinced because you're still getting some calls twice. It seems that with your changes, the ones that get called twice are those that are not nested or called via a `cached_method`. In fact, it seems like those are the same classes that fell into this recursion loop, so while this might help (and even be a fix for the problem at hand), I don't think this is the \"right\" solution.\n\nPerhaps this is a question more for Nicolas, but is there a reason why we need a separate (cached) function `base_category_class_and_axiom` and not just including it with the lazy attribute? It seems that it's only called in the lazy attribute.",
    "created_at": "2014-01-05T17:30:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109033",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:9'></a>
I'm not completely convinced because you're still getting some calls twice. It seems that with your changes, the ones that get called twice are those that are not nested or called via a `cached_method`. In fact, it seems like those are the same classes that fell into this recursion loop, so while this might help (and even be a fix for the problem at hand), I don't think this is the "right" solution.

Perhaps this is a question more for Nicolas, but is there a reason why we need a separate (cached) function `base_category_class_and_axiom` and not just including it with the lazy attribute? It seems that it's only called in the lazy attribute.



---

archive/issue_comments_109034.json:
```json
{
    "body": "<a id='comment:0'></a>\nI am afraid that Simon's solution, while directly addressing the apparent issue, is insufficient. You are using a caching mechanism--something that should be used as a performance tool--to avoid an infinite recursion. That's bad. You're putting program logic in a place where people won't expect it.\n\nIt also relies on the cache being of a particular form and in a particular place. That's an implementation detail of our cached function decorator. It's already hard to figure out where that cache is stored. I can easily see the location changing in the future. Then you'll get stuff cached in two places or some hard-to-debug error.\n\nAnother issue (and this is already in the code) is that `base_category_and_axiom` is a module level function, so has a global cache. Any input to it (including erroneous input?) will be stored for eternity: memory leak.\n\nIn addition, `_base_category_and_axiom` is a lazy class attribute, so it has a cache of its own. Why are we caching things twice?\n\nFinally, and there are some design decisions in the ticket itself: Currently, there is code that relies on packages being in `sage.categories` by looking at the `__name__` and doing string mangling on it. Furthermore, it relates the class name `CamelCase` to the module `camel_case`. These are all fine as programming *conventions* but I find it questionable if it's a good idea to engrave them in *program logic*. This is what I referred to when I wrote \"doesn't read like python\" above. If this were happening in a specialized little corner it wouldn't be so alarming, but categories are supposed to be a fundamental tool to govern inheritance in sage and hence part of the infrastructure. That means a lot of people will have to touch and maintain it in the future, so such code should really be held to a higher standard in terms of understandability, cleanness, and design.\n\nWriting a document that explains how to work with it and maintain the code might help, but isn't enough: documents tend to get out of sync with code over time (even docstrings!). But at least it would mean we have a record of the original author's intent.",
    "created_at": "2014-01-05T17:41:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109034",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:0'></a>
I am afraid that Simon's solution, while directly addressing the apparent issue, is insufficient. You are using a caching mechanism--something that should be used as a performance tool--to avoid an infinite recursion. That's bad. You're putting program logic in a place where people won't expect it.

It also relies on the cache being of a particular form and in a particular place. That's an implementation detail of our cached function decorator. It's already hard to figure out where that cache is stored. I can easily see the location changing in the future. Then you'll get stuff cached in two places or some hard-to-debug error.

Another issue (and this is already in the code) is that `base_category_and_axiom` is a module level function, so has a global cache. Any input to it (including erroneous input?) will be stored for eternity: memory leak.

In addition, `_base_category_and_axiom` is a lazy class attribute, so it has a cache of its own. Why are we caching things twice?

Finally, and there are some design decisions in the ticket itself: Currently, there is code that relies on packages being in `sage.categories` by looking at the `__name__` and doing string mangling on it. Furthermore, it relates the class name `CamelCase` to the module `camel_case`. These are all fine as programming *conventions* but I find it questionable if it's a good idea to engrave them in *program logic*. This is what I referred to when I wrote "doesn't read like python" above. If this were happening in a specialized little corner it wouldn't be so alarming, but categories are supposed to be a fundamental tool to govern inheritance in sage and hence part of the infrastructure. That means a lot of people will have to touch and maintain it in the future, so such code should really be held to a higher standard in terms of understandability, cleanness, and design.

Writing a document that explains how to work with it and maintain the code might help, but isn't enough: documents tend to get out of sync with code over time (even docstrings!). But at least it would mean we have a record of the original author's intent.



---

archive/issue_comments_109035.json:
```json
{
    "body": "<a id='comment:261'></a>\nReplying to [nbruin](#comment%3A260):\n> Another issue (and this is already in the code) is that `base_category_and_axiom` is a module level function, so has a global cache. Any input to it (including erroneous input?) will be stored for eternity: memory leak.\n\nNo, it is not a memory leak. The stored items are formed by classes that are defined in modules anyway.\n\n> In addition, `_base_category_and_axiom` is a lazy class attribute, so it has a cache of its own. Why are we caching things twice?\n\nWhen making this function an uncached function (thus relying on the lazy attribute), and hence when removing the hack with temporarily filling the cache, one gets this many calls of `base_category_class_and_axiom(cls)`, sorted by `cls`:\n\n```\n sage.categories.sets_cat.Sets.Infinite: 1,\n sage.categories.commutative_rings.CommutativeRings: 98,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveCommutative.AdditiveUnital: 1,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveAssociative.AdditiveCommutative: 1,\n sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative: 1,\n sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative: 1,\n sage.categories.additive_magmas.AdditiveUnital.AdditiveInverse: 1,\n sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital: 1,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.Associative: 1,\n sage.categories.magmas.Magmas.Commutative: 1,\n sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.AdditiveInverse: 1,\n sage.categories.magmas.Unital.Inverse: 1,\n sage.categories.magmas.Magmas.Unital: 1,\n sage.categories.commutative_algebras.CommutativeAlgebras: 97,\n sage.categories.finite_fields.FiniteFields: 98,\n sage.categories.finite_enumerated_sets.FiniteEnumeratedSets: 98,\n sage.categories.finite_sets.FiniteSets: 94,\n sage.categories.finite_semigroups.FiniteSemigroups: 91,\n sage.categories.finite_monoids.FiniteMonoids: 91,\n sage.categories.unital_algebras.UnitalAlgebras.WithBasis: 1,\n sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets: 97\n```\nSo, it may be a hack, but what else do you suggest to avoid this high number of function calls?\n\n> Finally, and there are some design decisions in the ticket itself: Currently, there is code that relies on packages being in `sage.categories` by looking at the `__name__` and doing string mangling on it. Furthermore, it relates the class name `CamelCase` to the module `camel_case`. These are all fine as programming *conventions* but I find it questionable if it's a good idea to engrave them in *program logic*.\n\n+1.\n\nCeterum censeo: Trac sucks. My browser keeps jumping to the middle of this long ticket while I write.",
    "created_at": "2014-01-05T17:59:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109035",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:261'></a>
Replying to [nbruin](#comment%3A260):
> Another issue (and this is already in the code) is that `base_category_and_axiom` is a module level function, so has a global cache. Any input to it (including erroneous input?) will be stored for eternity: memory leak.

No, it is not a memory leak. The stored items are formed by classes that are defined in modules anyway.

> In addition, `_base_category_and_axiom` is a lazy class attribute, so it has a cache of its own. Why are we caching things twice?

When making this function an uncached function (thus relying on the lazy attribute), and hence when removing the hack with temporarily filling the cache, one gets this many calls of `base_category_class_and_axiom(cls)`, sorted by `cls`:

```
 sage.categories.sets_cat.Sets.Infinite: 1,
 sage.categories.commutative_rings.CommutativeRings: 98,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveCommutative.AdditiveUnital: 1,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveAssociative.AdditiveCommutative: 1,
 sage.categories.distributive_magmas_and_additive_magmas.DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative: 1,
 sage.categories.additive_magmas.AdditiveMagmas.AdditiveCommutative: 1,
 sage.categories.additive_magmas.AdditiveUnital.AdditiveInverse: 1,
 sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital: 1,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.Associative: 1,
 sage.categories.magmas.Magmas.Commutative: 1,
 sage.categories.distributive_magmas_and_additive_magmas.AdditiveUnital.AdditiveInverse: 1,
 sage.categories.magmas.Unital.Inverse: 1,
 sage.categories.magmas.Magmas.Unital: 1,
 sage.categories.commutative_algebras.CommutativeAlgebras: 97,
 sage.categories.finite_fields.FiniteFields: 98,
 sage.categories.finite_enumerated_sets.FiniteEnumeratedSets: 98,
 sage.categories.finite_sets.FiniteSets: 94,
 sage.categories.finite_semigroups.FiniteSemigroups: 91,
 sage.categories.finite_monoids.FiniteMonoids: 91,
 sage.categories.unital_algebras.UnitalAlgebras.WithBasis: 1,
 sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets: 97
```
So, it may be a hack, but what else do you suggest to avoid this high number of function calls?

> Finally, and there are some design decisions in the ticket itself: Currently, there is code that relies on packages being in `sage.categories` by looking at the `__name__` and doing string mangling on it. Furthermore, it relates the class name `CamelCase` to the module `camel_case`. These are all fine as programming *conventions* but I find it questionable if it's a good idea to engrave them in *program logic*.

+1.

Ceterum censeo: Trac sucks. My browser keeps jumping to the middle of this long ticket while I write.



---

archive/issue_comments_109036.json:
```json
{
    "body": "<a id='comment:2'></a>\nI tried to trace at what point redundant calls are happening, and I can confirm what others have stated: They occur in the assert statement. More precisely: They occur when doing `getattr(base_category_class, axiom, None)`.\n\nSo, we have several options:\n- Temporarily fill the cache with `(None, None)`, as I have suggested. The lazy attribute raises a `TypeError` when encountering that `(None, None)`, and this error seems to result in an import error, which then is caught.\n- Remove the assertion. However, I believe that it is reasonable to have an assertion, so that future errors with categories and axioms will be found more easily.\n- Change how the axiom binds to the `base_category_class`. I guess this involves a `__classget__`: Apparently this `__classget__` somehow requests the value of the lazy class attribute *while it is computed*.\n\nProbably the third approach is the cleanest, but so far I am not sure if we really have a `__classget__` that we can blame.",
    "created_at": "2014-01-05T18:28:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109036",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
I tried to trace at what point redundant calls are happening, and I can confirm what others have stated: They occur in the assert statement. More precisely: They occur when doing `getattr(base_category_class, axiom, None)`.

So, we have several options:
- Temporarily fill the cache with `(None, None)`, as I have suggested. The lazy attribute raises a `TypeError` when encountering that `(None, None)`, and this error seems to result in an import error, which then is caught.
- Remove the assertion. However, I believe that it is reasonable to have an assertion, so that future errors with categories and axioms will be found more easily.
- Change how the axiom binds to the `base_category_class`. I guess this involves a `__classget__`: Apparently this `__classget__` somehow requests the value of the lazy class attribute *while it is computed*.

Probably the third approach is the cleanest, but so far I am not sure if we really have a `__classget__` that we can blame.



---

archive/issue_comments_109037.json:
```json
{
    "body": "<a id='comment:263'></a>\nReplying to [SimonKing](#comment%3A261):\n> No, it is not a memory leak. The stored items are formed by classes that are defined in modules anyway.\n\nNot for things that get fed to it for which it's designed. Does it always raise an error if it gets something else? It could leak that. So (especially when you scribbe in the cache beforehand) you'll have to ensure that the cache is cleansed of undesirable things.\n\n> > In addition, `_base_category_and_axiom` is a lazy class attribute, so it has a cache of its own. Why are we caching things twice?\n\n> When making this function an uncached function (thus relying on the lazy attribute), and hence when removing the hack with temporarily filling the cache, one gets this many calls of `base_category_class_and_axiom(cls)`, sorted by `cls`:\n> ...\n> So, it may be a hack, but what else do you suggest to avoid this high number of function calls?\n\nThat's just the bug we had before. If you remove the assertion the recursion is also avoided and you'll see a much lower number of calls. The bug here is that executing `base_category_and_axiom` (or rather the assert) apparently queries the attribute `_base_category_and_axiom`. That's bad, so don't do that. That's exactly what I mean with using a cache to cover up flawed programming logic.\n\nBasically, the whole use of `base_category_class_and_axiom` is questionable. Categories shoud just define a `_base_category_and_axiom` attribute outright. As far as `base_category_class_and_axiom` is concerned, the value is a function of only their name anyway. It's just a tool to save (a small amount of) typing, and as we're seeing, causing nasty problems while trying to do it.",
    "created_at": "2014-01-05T18:29:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109037",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:263'></a>
Replying to [SimonKing](#comment%3A261):
> No, it is not a memory leak. The stored items are formed by classes that are defined in modules anyway.

Not for things that get fed to it for which it's designed. Does it always raise an error if it gets something else? It could leak that. So (especially when you scribbe in the cache beforehand) you'll have to ensure that the cache is cleansed of undesirable things.

> > In addition, `_base_category_and_axiom` is a lazy class attribute, so it has a cache of its own. Why are we caching things twice?

> When making this function an uncached function (thus relying on the lazy attribute), and hence when removing the hack with temporarily filling the cache, one gets this many calls of `base_category_class_and_axiom(cls)`, sorted by `cls`:
> ...
> So, it may be a hack, but what else do you suggest to avoid this high number of function calls?

That's just the bug we had before. If you remove the assertion the recursion is also avoided and you'll see a much lower number of calls. The bug here is that executing `base_category_and_axiom` (or rather the assert) apparently queries the attribute `_base_category_and_axiom`. That's bad, so don't do that. That's exactly what I mean with using a cache to cover up flawed programming logic.

Basically, the whole use of `base_category_class_and_axiom` is questionable. Categories shoud just define a `_base_category_and_axiom` attribute outright. As far as `base_category_class_and_axiom` is concerned, the value is a function of only their name anyway. It's just a tool to save (a small amount of) typing, and as we're seeing, causing nasty problems while trying to do it.



---

archive/issue_comments_109038.json:
```json
{
    "body": "<a id='comment:4'></a>\nIn `__classget__`, we find\n\n```python\n        if \"_base_category_class_and_axiom\" not in cls.__dict__:\n            cls._base_category_class_and_axiom = (base_category_class, axiom_of_nested_class(base_category_class, cls))\n            cls._base_category_class_and_axiom_was_guessed = True\n        else:\n            assert cls._base_category_class_and_axiom[0] is base_category_class, \\\n                \"base category class for %s mismatch; expected %s, got %s\"%(cls, cls._base_category_class_and_axiom[0], base_category_class)\n```\nWhat does that mean? Can `_base_category_class_and_axiom` be in the dict before the call to the lazy class attribute is completed?",
    "created_at": "2014-01-05T18:33:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109038",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
In `__classget__`, we find

```python
        if "_base_category_class_and_axiom" not in cls.__dict__:
            cls._base_category_class_and_axiom = (base_category_class, axiom_of_nested_class(base_category_class, cls))
            cls._base_category_class_and_axiom_was_guessed = True
        else:
            assert cls._base_category_class_and_axiom[0] is base_category_class, \
                "base category class for %s mismatch; expected %s, got %s"%(cls, cls._base_category_class_and_axiom[0], base_category_class)
```
What does that mean? Can `_base_category_class_and_axiom` be in the dict before the call to the lazy class attribute is completed?



---

archive/issue_comments_109039.json:
```json
{
    "body": "<a id='comment:265'></a>\nReplying to [nbruin](#comment%3A263):\n> Replying to [SimonKing](#comment%3A261):\n> > No, it is not a memory leak. The stored items are formed by classes that are defined in modules anyway.\n\n> \n> Not for things that get fed to it for which it's designed. Does it always raise an error if it gets something else? It could leak that. So (especially when you scribbe in the cache beforehand) you'll have to ensure that the cache is cleansed of undesirable things.\n\nThat's what I do in the \"finally\" clause (EDIT: which is only executed if there is a manually inserted cache value, as can be seen by the absence of the warning message when starting Sage).\n\n> Basically, the whole use of `base_category_class_and_axiom` is questionable. Categories shoud just define a `_base_category_and_axiom` attribute outright.\n\n+1, because this would avoid headache.\n\n-1, because this is what one would have to do in an abundance of categories. This may even include (in the future?) categories that are dynamically created.\n\nNote that in addition to the lazy attribute, `CategoryWithAxiom.__classget__` overrides `cls._base_category_class_and_axiom`. So, why is there this lazy class attribute?\n\nI am not sure yet if I come to the same conclusions as you do. But I agree that the relationship of these three things\n- a lazy class attribute,\n- a `__classget__` that as a side effect overrides the lazy class attribute, and\n- a cached function that calls the `__classget__` while it is computing stuff for the lazy class attribute\nshould be straightened.\n\n> As far as `base_category_class_and_axiom` is concerned, the value is a function of only their name anyway. It's just a tool to save (a small amount of) typing, and as we're seeing, causing nasty problems while trying to do it.\n\nYes, for what we want to compute, it would be enough to let the input be `cls.__name__`.\n\nBut no, *if* we want to make consistency checks (and in the current implementation we do want consistency checks), then we need to input the class.",
    "created_at": "2014-01-05T18:45:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109039",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:265'></a>
Replying to [nbruin](#comment%3A263):
> Replying to [SimonKing](#comment%3A261):
> > No, it is not a memory leak. The stored items are formed by classes that are defined in modules anyway.

> 
> Not for things that get fed to it for which it's designed. Does it always raise an error if it gets something else? It could leak that. So (especially when you scribbe in the cache beforehand) you'll have to ensure that the cache is cleansed of undesirable things.

That's what I do in the "finally" clause (EDIT: which is only executed if there is a manually inserted cache value, as can be seen by the absence of the warning message when starting Sage).

> Basically, the whole use of `base_category_class_and_axiom` is questionable. Categories shoud just define a `_base_category_and_axiom` attribute outright.

+1, because this would avoid headache.

-1, because this is what one would have to do in an abundance of categories. This may even include (in the future?) categories that are dynamically created.

Note that in addition to the lazy attribute, `CategoryWithAxiom.__classget__` overrides `cls._base_category_class_and_axiom`. So, why is there this lazy class attribute?

I am not sure yet if I come to the same conclusions as you do. But I agree that the relationship of these three things
- a lazy class attribute,
- a `__classget__` that as a side effect overrides the lazy class attribute, and
- a cached function that calls the `__classget__` while it is computing stuff for the lazy class attribute
should be straightened.

> As far as `base_category_class_and_axiom` is concerned, the value is a function of only their name anyway. It's just a tool to save (a small amount of) typing, and as we're seeing, causing nasty problems while trying to do it.

Yes, for what we want to compute, it would be enough to let the input be `cls.__name__`.

But no, *if* we want to make consistency checks (and in the current implementation we do want consistency checks), then we need to input the class.



---

archive/issue_comments_109040.json:
```json
{
    "body": "<a id='comment:6'></a>\nHere is my attempt at explaining the interrelation of the cached function\n`base_category_class_and_axiom`, the `__classget__`, and the lazy attribute\n`_base_category_class_and_axiom`.\n\n- The lazy attribute needs the cached function to compute its value.\n- If the classget is invoked, then the value of the lazy attribute does not\n  need to be guessed, but can be put explicitly (but then: Why is\n  `cls._base_category_class_and_axiom_was_guessed = True`? It should be False,\n  since the value is in fact *not* guessed by classget).\n- The cached function invokes the classget to do a consistency test.\n\nNow, it can obviously happen that everything starts by calling the lazy\nattribute. Then, classget is called, and overrides the lazy attribute ''before\nits computation is finished''. Then, the lazy attribute finishes its\ncomputation, and is overridden again (by the value it just computed).\n\nI guess this is why the lazy attribute / cached function is called twice for\nsome classes, even with our fixes.",
    "created_at": "2014-01-05T18:57:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109040",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
Here is my attempt at explaining the interrelation of the cached function
`base_category_class_and_axiom`, the `__classget__`, and the lazy attribute
`_base_category_class_and_axiom`.

- The lazy attribute needs the cached function to compute its value.
- If the classget is invoked, then the value of the lazy attribute does not
  need to be guessed, but can be put explicitly (but then: Why is
  `cls._base_category_class_and_axiom_was_guessed = True`? It should be False,
  since the value is in fact *not* guessed by classget).
- The cached function invokes the classget to do a consistency test.

Now, it can obviously happen that everything starts by calling the lazy
attribute. Then, classget is called, and overrides the lazy attribute ''before
its computation is finished''. Then, the lazy attribute finishes its
computation, and is overridden again (by the value it just computed).

I guess this is why the lazy attribute / cached function is called twice for
some classes, even with our fixes.



---

archive/issue_comments_109041.json:
```json
{
    "body": "<a id='comment:7'></a>\nAhahah! There is yet another level of indirection!\n\nNamely, I found that the redundant calls to `base_category_class_and_axiom` happens because of `axiom_of_nested_class`. It starts with this:\n\n```python\n    if hasattr(nested_cls, \"_base_category_class_and_axiom\"):\n        axiom = nested_cls._base_category_class_and_axiom[1]\n```\nI guess it is wrong to do `hasattr` here, since this triggers the (re!)computation of the lazy class attribute. What we should do instead is to look up `nested_cls.__dict__`!!\n\nEDIT: That's to say\n\n```python\n    try:\n        axiom =nested_cls.__dict__[\"_base_category_class_and_axiom\"][1]\n    except KeyError:\n        ...\n```",
    "created_at": "2014-01-05T19:05:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109041",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Ahahah! There is yet another level of indirection!

Namely, I found that the redundant calls to `base_category_class_and_axiom` happens because of `axiom_of_nested_class`. It starts with this:

```python
    if hasattr(nested_cls, "_base_category_class_and_axiom"):
        axiom = nested_cls._base_category_class_and_axiom[1]
```
I guess it is wrong to do `hasattr` here, since this triggers the (re!)computation of the lazy class attribute. What we should do instead is to look up `nested_cls.__dict__`!!

EDIT: That's to say

```python
    try:
        axiom =nested_cls.__dict__["_base_category_class_and_axiom"][1]
    except KeyError:
        ...
```



---

archive/issue_comments_109042.json:
```json
{
    "body": "<a id='comment:8'></a>\nWhow!!! When doing what I proposed in my previous comment, the numbers of calling the lazy class attribute drastically drop! No surprise, since now it will be directly written as an attribute:\n\n```\n sage.categories.commutative_rings.CommutativeRings: 1,\n sage.categories.commutative_algebras.CommutativeAlgebras: 1,\n sage.categories.finite_fields.FiniteFields: 1,\n sage.categories.finite_enumerated_sets.FiniteEnumeratedSets: 1,\n sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets: 1\n```\nThat's all, no further calls.\n\nHence, a new commit is soon to come.",
    "created_at": "2014-01-05T19:09:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109042",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Whow!!! When doing what I proposed in my previous comment, the numbers of calling the lazy class attribute drastically drop! No surprise, since now it will be directly written as an attribute:

```
 sage.categories.commutative_rings.CommutativeRings: 1,
 sage.categories.commutative_algebras.CommutativeAlgebras: 1,
 sage.categories.finite_fields.FiniteFields: 1,
 sage.categories.finite_enumerated_sets.FiniteEnumeratedSets: 1,
 sage.categories.infinite_enumerated_sets.InfiniteEnumeratedSets: 1
```
That's all, no further calls.

Hence, a new commit is soon to come.



---

archive/issue_comments_109043.json:
```json
{
    "body": "**Changing commit** from \"[8eaf51a82c4e2194769db13457979ae601ebbc04](https://github.com/sagemath/sagetrac-mirror/commit/8eaf51a82c4e2194769db13457979ae601ebbc04)\" to \"[bdefe0daeb7a4154a506f5ac69a064b6150f8de6](https://github.com/sagemath/sagetrac-mirror/commit/bdefe0daeb7a4154a506f5ac69a064b6150f8de6)\".",
    "created_at": "2014-01-05T19:22:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109043",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing commit** from "[8eaf51a82c4e2194769db13457979ae601ebbc04](https://github.com/sagemath/sagetrac-mirror/commit/8eaf51a82c4e2194769db13457979ae601ebbc04)" to "[bdefe0daeb7a4154a506f5ac69a064b6150f8de6](https://github.com/sagemath/sagetrac-mirror/commit/bdefe0daeb7a4154a506f5ac69a064b6150f8de6)".



---

archive/issue_comments_109044.json:
```json
{
    "body": "<a id='comment:9'></a>\nHere is the new commit. What it does:\n\n- Do not access the lazy attribute (since this may happen while it is being computed) when what we want to know is in fact whether the attribute is in the `__dict__` of the class.\n- Remove the cache from `base_category_class_and_axiom`, since it is cached by the lazy attribute anyway.\n- Correctly state that `cls._base_category_class_and_axiom_was_guessed = False` if the attribute is in fact not guessed but explicitly set by invoking the classget.\n\nConsequences:\n- Most of the time, the lazy attribute is not guessed but explicitly set. I think this should save a lot of computation time. In fact, during startup, a \"guess\" only happens precisely five times!\n- Since there are some tests expecting `cls._base_category_class_and_axiom_was_guessed == True`, I suppose I have to change some doctests.\n\nDoing `make ptest` now. But I guess you can already have a look at the code, to see if it is clearer now.",
    "created_at": "2014-01-05T19:22:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109044",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Here is the new commit. What it does:

- Do not access the lazy attribute (since this may happen while it is being computed) when what we want to know is in fact whether the attribute is in the `__dict__` of the class.
- Remove the cache from `base_category_class_and_axiom`, since it is cached by the lazy attribute anyway.
- Correctly state that `cls._base_category_class_and_axiom_was_guessed = False` if the attribute is in fact not guessed but explicitly set by invoking the classget.

Consequences:
- Most of the time, the lazy attribute is not guessed but explicitly set. I think this should save a lot of computation time. In fact, during startup, a "guess" only happens precisely five times!
- Since there are some tests expecting `cls._base_category_class_and_axiom_was_guessed == True`, I suppose I have to change some doctests.

Doing `make ptest` now. But I guess you can already have a look at the code, to see if it is clearer now.



---

archive/issue_comments_109045.json:
```json
{
    "body": "**Changing work issues** from \"Detect and fix Heisenbugs\" to \"\".",
    "created_at": "2014-01-05T19:22:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109045",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "Detect and fix Heisenbugs" to "".



---

archive/issue_comments_109046.json:
```json
{
    "body": "<a id='comment:0'></a>\nVery nice. However I think we should move the cached function into the lazy attribute too.",
    "created_at": "2014-01-05T19:39:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109046",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:0'></a>
Very nice. However I think we should move the cached function into the lazy attribute too.



---

archive/issue_comments_109047.json:
```json
{
    "body": "<a id='comment:271'></a>\nReplying to [tscrim](#comment%3A270):\n> Very nice. However I think we should move the cached function into the lazy attribute too.\n\nWhich one you mean? `base_category_class_and_axiom()` is not a cached function, with my new commit.",
    "created_at": "2014-01-05T19:46:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109047",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:271'></a>
Replying to [tscrim](#comment%3A270):
> Very nice. However I think we should move the cached function into the lazy attribute too.

Which one you mean? `base_category_class_and_axiom()` is not a cached function, with my new commit.



---

archive/issue_comments_109048.json:
```json
{
    "body": "<a id='comment:2'></a>\nBTW: This explains why the code was more or less working, in spite of the recursion. Namely, apparently the import or recursion error resulted in `hasattr(nested_cls, \"_base_category_class_and_axiom\")` returning False (without error!), and from there, things worked, since then the lazy attribute was overridden with its correct value by the `classget`.\n\nNow, we override the lazy attribute with its correct value by the `classget` right away, without spending time on waiting for an error to happen...",
    "created_at": "2014-01-05T19:50:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109048",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
BTW: This explains why the code was more or less working, in spite of the recursion. Namely, apparently the import or recursion error resulted in `hasattr(nested_cls, "_base_category_class_and_axiom")` returning False (without error!), and from there, things worked, since then the lazy attribute was overridden with its correct value by the `classget`.

Now, we override the lazy attribute with its correct value by the `classget` right away, without spending time on waiting for an error to happen...



---

archive/issue_comments_109049.json:
```json
{
    "body": "<a id='comment:273'></a>\nReplying to [SimonKing](#comment%3A269):\n> - Do not access the lazy attribute (since this may happen while it is being computed) when what we want to know is in fact whether the attribute is in the `__dict__` of the class.\n\nThat sounds like it's not going to work correctly if one is inheriting from a class that has a value for the attribute already. I don't think it's a good idea to move away from normal attribute lookup semantics in python.",
    "created_at": "2014-01-05T19:53:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109049",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:273'></a>
Replying to [SimonKing](#comment%3A269):
> - Do not access the lazy attribute (since this may happen while it is being computed) when what we want to know is in fact whether the attribute is in the `__dict__` of the class.

That sounds like it's not going to work correctly if one is inheriting from a class that has a value for the attribute already. I don't think it's a good idea to move away from normal attribute lookup semantics in python.



---

archive/issue_comments_109050.json:
```json
{
    "body": "<a id='comment:274'></a>\nReplying to [SimonKing](#comment%3A271):\n> Replying to [tscrim](#comment%3A270):\n> > Very nice. However I think we should move the cached function into the lazy attribute too.\n\n> \n> Which one you mean? `base_category_class_and_axiom()` is not a cached function, with my new commit.\n\nAh, I missed that in your commit; I thought it was still cached.",
    "created_at": "2014-01-05T19:59:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109050",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:274'></a>
Replying to [SimonKing](#comment%3A271):
> Replying to [tscrim](#comment%3A270):
> > Very nice. However I think we should move the cached function into the lazy attribute too.

> 
> Which one you mean? `base_category_class_and_axiom()` is not a cached function, with my new commit.

Ah, I missed that in your commit; I thought it was still cached.



---

archive/issue_comments_109051.json:
```json
{
    "body": "<a id='comment:5'></a>\nBranch conflicts with #15588, can you either merge in either the branch from there or 6.1.beta4? Then I'll give it a whirl on the buildbot....",
    "created_at": "2014-01-05T20:10:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109051",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:5'></a>
Branch conflicts with #15588, can you either merge in either the branch from there or 6.1.beta4? Then I'll give it a whirl on the buildbot....



---

archive/issue_comments_109052.json:
```json
{
    "body": "<a id='comment:6'></a>\nThe lazy class attribute's documentation states:\n\n```\n            The base category class is often another category with axiom,\n            therefore having a special ``__classget__`` method.  Storing the\n            base category class and the axiom in a single tuple attribute --\n            instead of two separate attributes -- has the advantage of not\n            trigerring, for example, ``Semigroups.__classget__`` upon\n            ``Monoids._base_category_class``.\n```\nI think this is actually not correct. If I am not mistaken, `Finite.__classget__` is involved when doing `Fields().Finite`, but not when calling `Fields()._base_category_class`.\n\nIn any case, a remark should be added that the classget will set the `_base_category_class_and_axiom` attribute of `Fields().Finite()`.",
    "created_at": "2014-01-05T21:07:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109052",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
The lazy class attribute's documentation states:

```
            The base category class is often another category with axiom,
            therefore having a special ``__classget__`` method.  Storing the
            base category class and the axiom in a single tuple attribute --
            instead of two separate attributes -- has the advantage of not
            trigerring, for example, ``Semigroups.__classget__`` upon
            ``Monoids._base_category_class``.
```
I think this is actually not correct. If I am not mistaken, `Finite.__classget__` is involved when doing `Fields().Finite`, but not when calling `Fields()._base_category_class`.

In any case, a remark should be added that the classget will set the `_base_category_class_and_axiom` attribute of `Fields().Finite()`.



---

archive/issue_comments_109053.json:
```json
{
    "body": "<a id='comment:277'></a>\nReplying to [nbruin](#comment%3A273):\n> That sounds like it's not going to work correctly if one is inheriting from a class that has a value for the attribute already.\n\n1. If I understand correctly, we are not supposed to subclass a category with axiom.\n2. If we *do* subclass a category with axiom, `hasattr(nested_cls, \"_base_category_class_and_axiom\")` would indeed return True when nested_cls is a subclass of something that has this attribute. However, this is in fact not what we want. We would rather want that the subclass has its own attribute. At least this is my guess what we *would* want, if we were to create a subclass (which we don't).\n\n> I don't think it's a good idea to move away from normal attribute lookup semantics in python.\n\nI think the normal attribute lookup semantics in python simply is the wrong tool here. Actually we don't need `hasattr` at all, since we know for sure that the class *has* the attribute (namely: lazy class attribute). What we want to know is: Is this lazy attribute computed or not? And hasattr can certainly not answer that question.",
    "created_at": "2014-01-05T21:14:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109053",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:277'></a>
Replying to [nbruin](#comment%3A273):
> That sounds like it's not going to work correctly if one is inheriting from a class that has a value for the attribute already.

1. If I understand correctly, we are not supposed to subclass a category with axiom.
2. If we *do* subclass a category with axiom, `hasattr(nested_cls, "_base_category_class_and_axiom")` would indeed return True when nested_cls is a subclass of something that has this attribute. However, this is in fact not what we want. We would rather want that the subclass has its own attribute. At least this is my guess what we *would* want, if we were to create a subclass (which we don't).

> I don't think it's a good idea to move away from normal attribute lookup semantics in python.

I think the normal attribute lookup semantics in python simply is the wrong tool here. Actually we don't need `hasattr` at all, since we know for sure that the class *has* the attribute (namely: lazy class attribute). What we want to know is: Is this lazy attribute computed or not? And hasattr can certainly not answer that question.



---

archive/issue_comments_109054.json:
```json
{
    "body": "<a id='comment:278'></a>\nReplying to [vbraun](#comment%3A275):\n> Branch conflicts with #15588, can you either merge in either the branch from there or 6.1.beta4? Then I'll give it a whirl on the buildbot....\n\nYou mean: Merge with develop (after pulling from develop)?",
    "created_at": "2014-01-05T21:15:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109054",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:278'></a>
Replying to [vbraun](#comment%3A275):
> Branch conflicts with #15588, can you either merge in either the branch from there or 6.1.beta4? Then I'll give it a whirl on the buildbot....

You mean: Merge with develop (after pulling from develop)?



---

archive/issue_comments_109055.json:
```json
{
    "body": "**Changing commit** from \"[bdefe0daeb7a4154a506f5ac69a064b6150f8de6](https://github.com/sagemath/sagetrac-mirror/commit/bdefe0daeb7a4154a506f5ac69a064b6150f8de6)\" to \"[408e0545d832e83eab41e88740ab16c18ccde426](https://github.com/sagemath/sagetrac-mirror/commit/408e0545d832e83eab41e88740ab16c18ccde426)\".",
    "created_at": "2014-01-05T21:18:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109055",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[bdefe0daeb7a4154a506f5ac69a064b6150f8de6](https://github.com/sagemath/sagetrac-mirror/commit/bdefe0daeb7a4154a506f5ac69a064b6150f8de6)" to "[408e0545d832e83eab41e88740ab16c18ccde426](https://github.com/sagemath/sagetrac-mirror/commit/408e0545d832e83eab41e88740ab16c18ccde426)".



---

archive/issue_comments_109056.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/408e0545d832e83eab41e88740ab16c18ccde426\">408e054</a></td><td><code>Merge branch 'develop' into public/ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3008fe10865f5ba2611f157396650507a73f5653\">3008fe1</a></td><td><code>Merge branch 'public/ticket/10963' of trac.sagemath.org:sage into public/ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ffbc6a7bbb910ac374a8e8d0e2b1b193c31f0e50\">ffbc6a7</a></td><td><code>Merge branch 'public/ticket/10963' of trac.sagemath.org:sage into testing_10963</code></td></tr></table>\n",
    "created_at": "2014-01-05T21:18:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109056",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/408e0545d832e83eab41e88740ab16c18ccde426">408e054</a></td><td><code>Merge branch 'develop' into public/ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3008fe10865f5ba2611f157396650507a73f5653">3008fe1</a></td><td><code>Merge branch 'public/ticket/10963' of trac.sagemath.org:sage into public/ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ffbc6a7bbb910ac374a8e8d0e2b1b193c31f0e50">ffbc6a7</a></td><td><code>Merge branch 'public/ticket/10963' of trac.sagemath.org:sage into testing_10963</code></td></tr></table>




---

archive/issue_comments_109057.json:
```json
{
    "body": "<a id='comment:0'></a>\nHere's the branch with merging the latest `develop` (6.1.beta4), I'm building and testing `integer_mod_ring.py` currently.",
    "created_at": "2014-01-05T21:20:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109057",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:0'></a>
Here's the branch with merging the latest `develop` (6.1.beta4), I'm building and testing `integer_mod_ring.py` currently.



---

archive/issue_comments_109058.json:
```json
{
    "body": "<a id='comment:1'></a>\nBefore you start with the tests: I have a new commit. What do I need to do to push it to trac, after you have changed the branch?\n\nDoes it suffice to pull (which automatically merges into my current branch) and then to push again?\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/408e0545d832e83eab41e88740ab16c18ccde426\">408e054</a></td><td><code>Merge branch 'develop' into public/ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3008fe10865f5ba2611f157396650507a73f5653\">3008fe1</a></td><td><code>Merge branch 'public/ticket/10963' of trac.sagemath.org:sage into public/ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ffbc6a7bbb910ac374a8e8d0e2b1b193c31f0e50\">ffbc6a7</a></td><td><code>Merge branch 'public/ticket/10963' of trac.sagemath.org:sage into testing_10963</code></td></tr></table>\n",
    "created_at": "2014-01-05T21:31:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109058",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Before you start with the tests: I have a new commit. What do I need to do to push it to trac, after you have changed the branch?

Does it suffice to pull (which automatically merges into my current branch) and then to push again?

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/408e0545d832e83eab41e88740ab16c18ccde426">408e054</a></td><td><code>Merge branch 'develop' into public/ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3008fe10865f5ba2611f157396650507a73f5653">3008fe1</a></td><td><code>Merge branch 'public/ticket/10963' of trac.sagemath.org:sage into public/ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ffbc6a7bbb910ac374a8e8d0e2b1b193c31f0e50">ffbc6a7</a></td><td><code>Merge branch 'public/ticket/10963' of trac.sagemath.org:sage into testing_10963</code></td></tr></table>




---

archive/issue_comments_109059.json:
```json
{
    "body": "**Changing commit** from \"[408e0545d832e83eab41e88740ab16c18ccde426](https://github.com/sagemath/sagetrac-mirror/commit/408e0545d832e83eab41e88740ab16c18ccde426)\" to \"[9dcafa54b452ffe8a340663ed38087ed7c2d8a4d](https://github.com/sagemath/sagetrac-mirror/commit/9dcafa54b452ffe8a340663ed38087ed7c2d8a4d)\".",
    "created_at": "2014-01-05T21:35:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109059",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[408e0545d832e83eab41e88740ab16c18ccde426](https://github.com/sagemath/sagetrac-mirror/commit/408e0545d832e83eab41e88740ab16c18ccde426)" to "[9dcafa54b452ffe8a340663ed38087ed7c2d8a4d](https://github.com/sagemath/sagetrac-mirror/commit/9dcafa54b452ffe8a340663ed38087ed7c2d8a4d)".



---

archive/issue_comments_109060.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9dcafa54b452ffe8a340663ed38087ed7c2d8a4d\">9dcafa5</a></td><td><code>Merge branch 'public/ticket/10963' of ssh://trac.sagemath.org:2222/sage into ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/100e66f08532c93ebabc07ac91dd88765310a564\">100e66f</a></td><td><code>Trac 10963: Provide doctests for the changed behaviour of a lazy class</code></td></tr></table>\n",
    "created_at": "2014-01-05T21:35:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109060",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9dcafa54b452ffe8a340663ed38087ed7c2d8a4d">9dcafa5</a></td><td><code>Merge branch 'public/ticket/10963' of ssh://trac.sagemath.org:2222/sage into ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/100e66f08532c93ebabc07ac91dd88765310a564">100e66f</a></td><td><code>Trac 10963: Provide doctests for the changed behaviour of a lazy class</code></td></tr></table>




---

archive/issue_comments_109061.json:
```json
{
    "body": "<a id='comment:3'></a>\nIt seems the answer is \"yes\". My additional commit is in the branch. Now you may test...",
    "created_at": "2014-01-05T21:36:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109061",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
It seems the answer is "yes". My additional commit is in the branch. Now you may test...



---

archive/issue_comments_109062.json:
```json
{
    "body": "<a id='comment:4'></a>\nDoing a pull should be sufficient (but I think you've figured that out now). Now to wait for it to recompile...",
    "created_at": "2014-01-05T21:37:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109062",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:4'></a>
Doing a pull should be sufficient (but I think you've figured that out now). Now to wait for it to recompile...



---

archive/issue_comments_109063.json:
```json
{
    "body": "<a id='comment:285'></a>\nReplying to [tscrim](#comment%3A284):\n> Doing a pull should be sufficient (but I think you've figured that out now).\n\nYes. But it makes git create another merge commit. Git is ugly.",
    "created_at": "2014-01-05T21:43:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109063",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:285'></a>
Replying to [tscrim](#comment%3A284):
> Doing a pull should be sufficient (but I think you've figured that out now).

Yes. But it makes git create another merge commit. Git is ugly.



---

archive/issue_comments_109064.json:
```json
{
    "body": "<a id='comment:6'></a>\nTravis went a bit overboard with merging here, you only need to merge once. But oh well. In any case, you can't merge without a merge commit. Thats a feature.",
    "created_at": "2014-01-05T22:04:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109064",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:6'></a>
Travis went a bit overboard with merging here, you only need to merge once. But oh well. In any case, you can't merge without a merge commit. Thats a feature.



---

archive/issue_comments_109065.json:
```json
{
    "body": "<a id='comment:287'></a>\nReplying to [vbraun](#comment%3A286):\n> Travis went a bit overboard with merging here, you only need to merge once. But oh well. In any case, you can't merge without a merge commit. Thats a feature.\n\nI had one commit at the tip of my local branch, and what I *really* wanted was to rebase it on top of Travis' branch. But pulling means merging, not rebasing.\n\nHowever, in the end, the code is what it should be, and code is what matters to me.",
    "created_at": "2014-01-05T22:09:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109065",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:287'></a>
Replying to [vbraun](#comment%3A286):
> Travis went a bit overboard with merging here, you only need to merge once. But oh well. In any case, you can't merge without a merge commit. Thats a feature.

I had one commit at the tip of my local branch, and what I *really* wanted was to rebase it on top of Travis' branch. But pulling means merging, not rebasing.

However, in the end, the code is what it should be, and code is what matters to me.



---

archive/issue_comments_109066.json:
```json
{
    "body": "<a id='comment:8'></a>\n\n```\nsage -t src/sage/symbolic/expression.pyx\n    Timed out\n```\nSigh.",
    "created_at": "2014-01-05T22:20:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109066",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>

```
sage -t src/sage/symbolic/expression.pyx
    Timed out
```
Sigh.



---

archive/issue_comments_109067.json:
```json
{
    "body": "<a id='comment:9'></a>\nThe good new is that the timout can easily be demonstrated on the command line.\n\n```\nsage: %time integral(exp(x + x^2)/(x+1), x)\nCPU times: user 4.97 s, sys: 0.10 s, total: 5.07 s\nWall time: 5.28 s\nintegrate(e^(x^2 + x)/(x + 1), x)\nsage: %time ascii_art(integral(exp(x + x^2)/(x+1), x))\n<HANGS>\n```\nThe bad new is that there are more timeouts.",
    "created_at": "2014-01-05T22:27:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109067",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
The good new is that the timout can easily be demonstrated on the command line.

```
sage: %time integral(exp(x + x^2)/(x+1), x)
CPU times: user 4.97 s, sys: 0.10 s, total: 5.07 s
Wall time: 5.28 s
integrate(e^(x^2 + x)/(x + 1), x)
sage: %time ascii_art(integral(exp(x + x^2)/(x+1), x))
<HANGS>
```
The bad new is that there are more timeouts.



---

archive/issue_comments_109068.json:
```json
{
    "body": "**Work Issues:** analyse and fix timeouts",
    "created_at": "2014-01-05T22:39:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109068",
    "user": "https://github.com/simon-king-jena"
}
```

**Work Issues:** analyse and fix timeouts



---

archive/issue_comments_109069.json:
```json
{
    "body": "<a id='comment:1'></a>\nNote: Without merging develop, I'd get\n\n```\nsage: %time integral(exp(x + x^2)/(x+1), x)\nCPU times: user 2.11 s, sys: 0.06 s, total: 2.18 s\nWall time: 2.26 s\nintegrate(e^(x^2 + x)/(x + 1), x)\nsage: %time ascii_art(integral(exp(x + x^2)/(x+1), x))\nCPU times: user 24.33 s, sys: 0.10 s, total: 24.43 s\nWall time: 24.83 s\n  /          \n |           \n |   2       \n |  x  + x   \n | e         \n | ------- dx\n |  x + 1    \n |           \n/            \n```\nThis is bad enough. I mean, why does it take more than 20 seconds to computer the ascii art representation of this integral?\n\nAnd the question is: How can **categories** make ascii art and integration so dog slow? Are categories even used there??",
    "created_at": "2014-01-05T22:58:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109069",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Note: Without merging develop, I'd get

```
sage: %time integral(exp(x + x^2)/(x+1), x)
CPU times: user 2.11 s, sys: 0.06 s, total: 2.18 s
Wall time: 2.26 s
integrate(e^(x^2 + x)/(x + 1), x)
sage: %time ascii_art(integral(exp(x + x^2)/(x+1), x))
CPU times: user 24.33 s, sys: 0.10 s, total: 24.43 s
Wall time: 24.83 s
  /          
 |           
 |   2       
 |  x  + x   
 | e         
 | ------- dx
 |  x + 1    
 |           
/            
```
This is bad enough. I mean, why does it take more than 20 seconds to computer the ascii art representation of this integral?

And the question is: How can **categories** make ascii art and integration so dog slow? Are categories even used there??



---

archive/issue_comments_109070.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ec340363a811bbafbb8cd5ff8f39e75db9872f9f\">ec34036</a></td><td><code>Fixed failing doctest in integer_mod_ring.py from (my bad) merging.</code></td></tr></table>\n",
    "created_at": "2014-01-05T23:31:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109070",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ec340363a811bbafbb8cd5ff8f39e75db9872f9f">ec34036</a></td><td><code>Fixed failing doctest in integer_mod_ring.py from (my bad) merging.</code></td></tr></table>




---

archive/issue_comments_109071.json:
```json
{
    "body": "**Changing commit** from \"[9dcafa54b452ffe8a340663ed38087ed7c2d8a4d](https://github.com/sagemath/sagetrac-mirror/commit/9dcafa54b452ffe8a340663ed38087ed7c2d8a4d)\" to \"[ec340363a811bbafbb8cd5ff8f39e75db9872f9f](https://github.com/sagemath/sagetrac-mirror/commit/ec340363a811bbafbb8cd5ff8f39e75db9872f9f)\".",
    "created_at": "2014-01-05T23:31:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109071",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[9dcafa54b452ffe8a340663ed38087ed7c2d8a4d](https://github.com/sagemath/sagetrac-mirror/commit/9dcafa54b452ffe8a340663ed38087ed7c2d8a4d)" to "[ec340363a811bbafbb8cd5ff8f39e75db9872f9f](https://github.com/sagemath/sagetrac-mirror/commit/ec340363a811bbafbb8cd5ff8f39e75db9872f9f)".



---

archive/issue_comments_109072.json:
```json
{
    "body": "<a id='comment:293'></a>\nReplying to [vbraun](#comment%3A286):\n> Travis went a bit overboard with merging here, you only need to merge once. But oh well. In any case, you can't merge without a merge commit. Thats a feature.\n\nYea, that wasn't the cleanest bit of git I've done...\n\nAnyways, the hanging comes from calling the calling of `sympify`:\n\n```\n    def _ascii_art_(self):\n        ...\n        from sympy import pretty, sympify\n        ...\n        try:\n            s = pretty(sympify(self), use_unicode=False)\n        ...\n```\nAlthough this is hanging with a clean `develop` branch...",
    "created_at": "2014-01-05T23:46:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109072",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:293'></a>
Replying to [vbraun](#comment%3A286):
> Travis went a bit overboard with merging here, you only need to merge once. But oh well. In any case, you can't merge without a merge commit. Thats a feature.

Yea, that wasn't the cleanest bit of git I've done...

Anyways, the hanging comes from calling the calling of `sympify`:

```
    def _ascii_art_(self):
        ...
        from sympy import pretty, sympify
        ...
        try:
            s = pretty(sympify(self), use_unicode=False)
        ...
```
Although this is hanging with a clean `develop` branch...



---

archive/issue_comments_109073.json:
```json
{
    "body": "<a id='comment:4'></a>\nThe slow ascii art is the sympy update (#15512). Now sympy spends a lot of time trying to solve that integral. Drawing the ascii art is still fast.",
    "created_at": "2014-01-06T02:54:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109073",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:4'></a>
The slow ascii art is the sympy update (#15512). Now sympy spends a lot of time trying to solve that integral. Drawing the ascii art is still fast.



---

archive/issue_comments_109074.json:
```json
{
    "body": "<a id='comment:5'></a>\nThe slow ascii art issue is now #15636.",
    "created_at": "2014-01-06T03:34:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109074",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:5'></a>
The slow ascii art issue is now #15636.



---

archive/issue_comments_109075.json:
```json
{
    "body": "**Changing work issues** from \"analyse and fix timeouts\" to \"\".",
    "created_at": "2014-01-06T03:34:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109075",
    "user": "https://github.com/vbraun"
}
```

**Changing work issues** from "analyse and fix timeouts" to "".



---

archive/issue_events_085482.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-01-06T03:34:21Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85482"
}
```



---

archive/issue_events_085483.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-01-06T03:34:21Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85483"
}
```



---

archive/issue_comments_109076.json:
```json
{
    "body": "<a id='comment:6'></a>\nHow is one supposed to review this, then? In the good old mercurial workflow, I would take the patches, apply them to a slightly older beta version (before #15512 got merged), and test. But in the git workflow, this would only be possible be rebasing, which changes history (for some notion of history) and is supposed to be bad.\n\nOr what else can we do? Wait for #15636? Why is #15636 not a blocker? After all, the current beta hangs.",
    "created_at": "2014-01-06T09:18:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109076",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
How is one supposed to review this, then? In the good old mercurial workflow, I would take the patches, apply them to a slightly older beta version (before #15512 got merged), and test. But in the git workflow, this would only be possible be rebasing, which changes history (for some notion of history) and is supposed to be bad.

Or what else can we do? Wait for #15636? Why is #15636 not a blocker? After all, the current beta hangs.



---

archive/issue_comments_109077.json:
```json
{
    "body": "<a id='comment:7'></a>\nIt doesn't hang for me, just takes a while to draw the ascii art. Does it actually hang for you?",
    "created_at": "2014-01-06T09:22:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109077",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:7'></a>
It doesn't hang for me, just takes a while to draw the ascii art. Does it actually hang for you?



---

archive/issue_comments_109078.json:
```json
{
    "body": "<a id='comment:298'></a>\nReplying to [vbraun](#comment%3A297):\n> It doesn't hang for me, just takes a while to draw the ascii art. Does it actually hang for you?\n\nI didn't run `make ptest` with the \"pure\" develop branch. But with the branch that is currently attached to this ticket, I get several timeouts. As stated in [comment:291](#comment%3A291), without merging develop into the branch of this ticket, it is quite slow (22 seconds to translate an integral into ascii art), but terminates.\n\nAnd with the pure develop branch, it hangs in the sense of \"I lost patience after a couple of minutes\". to be precise:\n\n```\nsage: %time integral(exp(x + x^2)/(x+1), x)  # this is fine\nCPU times: user 2.12 s, sys: 0.10 s, total: 2.22 s\nWall time: 3.53 s\nintegrate(e^(x^2 + x)/(x + 1), x)\nsage: %time alarm(120); ascii_art(integral(exp(x + x^2)/(x+1), x))\nTraceback (most recent call last):\n...\nAlarmInterrupt:\n```",
    "created_at": "2014-01-06T10:51:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109078",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:298'></a>
Replying to [vbraun](#comment%3A297):
> It doesn't hang for me, just takes a while to draw the ascii art. Does it actually hang for you?

I didn't run `make ptest` with the "pure" develop branch. But with the branch that is currently attached to this ticket, I get several timeouts. As stated in [comment:291](#comment%3A291), without merging develop into the branch of this ticket, it is quite slow (22 seconds to translate an integral into ascii art), but terminates.

And with the pure develop branch, it hangs in the sense of "I lost patience after a couple of minutes". to be precise:

```
sage: %time integral(exp(x + x^2)/(x+1), x)  # this is fine
CPU times: user 2.12 s, sys: 0.10 s, total: 2.22 s
Wall time: 3.53 s
integrate(e^(x^2 + x)/(x + 1), x)
sage: %time alarm(120); ascii_art(integral(exp(x + x^2)/(x+1), x))
Traceback (most recent call last):
...
AlarmInterrupt:
```



---

archive/issue_comments_109079.json:
```json
{
    "body": "<a id='comment:9'></a>\nAha! I have not been patient enough.\n\n```\nsage: %time ascii_art(integral(exp(x + x^2)/(x+1), x))\nCPU times: user 178.11 s, sys: 1.77 s, total: 179.88 s\nWall time: 180.71 s\n  /          \n |           \n |   2       \n |  x  + x   \n | e         \n | ------- dx\n |  x + 1    \n |           \n/            \n```\nwith the develop branch. But that's too slow.",
    "created_at": "2014-01-06T10:57:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109079",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Aha! I have not been patient enough.

```
sage: %time ascii_art(integral(exp(x + x^2)/(x+1), x))
CPU times: user 178.11 s, sys: 1.77 s, total: 179.88 s
Wall time: 180.71 s
  /          
 |           
 |   2       
 |  x  + x   
 | e         
 | ------- dx
 |  x + 1    
 |           
/            
```
with the develop branch. But that's too slow.



---

archive/issue_comments_109080.json:
```json
{
    "body": "<a id='comment:0'></a>\nWhen I tested yesterday, I got\n\n```\nsage -t src/sage/symbolic/expression.pyx  # Timed out\nsage -t src/sage/plot/plot.py  # Timed out\nsage -t src/sage/combinat/crystals/littelmann_path.py  # Timed out\n```\nbefore I interrupted after testing only 6 out of 2496 files. That's why I thought #15636 should be a blocker.",
    "created_at": "2014-01-06T13:03:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109080",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
When I tested yesterday, I got

```
sage -t src/sage/symbolic/expression.pyx  # Timed out
sage -t src/sage/plot/plot.py  # Timed out
sage -t src/sage/combinat/crystals/littelmann_path.py  # Timed out
```
before I interrupted after testing only 6 out of 2496 files. That's why I thought #15636 should be a blocker.



---

archive/issue_comments_109081.json:
```json
{
    "body": "<a id='comment:1'></a>\nPS: But today, again with the branch from here, I am getting\n\n```\nsage -t src/sage/symbolic/expression.pyx\n    [2139 tests, 278.47 s]\nsage -t src/sage/plot/plot.py\n    [373 tests, 147.14 s]\nsage -t src/sage/combinat/crystals/littelmann_path.py\n    [210 tests, 130.32 s]\n```\nStrange.",
    "created_at": "2014-01-06T13:04:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109081",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
PS: But today, again with the branch from here, I am getting

```
sage -t src/sage/symbolic/expression.pyx
    [2139 tests, 278.47 s]
sage -t src/sage/plot/plot.py
    [373 tests, 147.14 s]
sage -t src/sage/combinat/crystals/littelmann_path.py
    [210 tests, 130.32 s]
```
Strange.



---

archive/issue_comments_109082.json:
```json
{
    "body": "<a id='comment:2'></a>\nBack to the topic.\n\nDo you think that it is a valid solution to let `._base_category_class_and_axiom` be explicitly set, with the exception of 5 cases in which it is computed/guessed by a lazy attribute? Even with the caveat that this \"explicit setting\" happens as side-effect of a `__classget__`? I think it is, since the `__classget__` method does not need to *guess*: It merely documents how it has constructed the category that `__classget__` returns.",
    "created_at": "2014-01-06T13:14:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109082",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Back to the topic.

Do you think that it is a valid solution to let `._base_category_class_and_axiom` be explicitly set, with the exception of 5 cases in which it is computed/guessed by a lazy attribute? Even with the caveat that this "explicit setting" happens as side-effect of a `__classget__`? I think it is, since the `__classget__` method does not need to *guess*: It merely documents how it has constructed the category that `__classget__` returns.



---

archive/issue_comments_109083.json:
```json
{
    "body": "<a id='comment:3'></a>\nNow, all tests work:\n\n```\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 4016.6 seconds\n    cpu time: 6508.4 seconds\n    cumulative wall time: 7741.2 seconds\n```\nVery strange. But from my perspective, we can be back at review now.",
    "created_at": "2014-01-06T13:58:06Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109083",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Now, all tests work:

```
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 4016.6 seconds
    cpu time: 6508.4 seconds
    cumulative wall time: 7741.2 seconds
```
Very strange. But from my perspective, we can be back at review now.



---

archive/issue_comments_109084.json:
```json
{
    "body": "<a id='comment:304'></a>\nReplying to [SimonKing](#comment%3A302):\n> Do you think that it is a valid solution to let `._base_category_class_and_axiom` be explicitly set, with the exception of 5 cases in which it is computed/guessed by a lazy attribute? Even with the caveat that this \"explicit setting\" happens as side-effect of a `__classget__`? I think it is, since the `__classget__` method does not need to *guess*: It merely documents how it has constructed the category that `__classget__` returns.\n\nFrom reading the discussion so far, this sounds reasonable. I'll be back to Sage development tomorrow (yeah, finally!), and review in details your changes then.\n\nThanks to all of you for figuring out the issue in my black magic!\n\nHappy new year!\n                            Nicolas",
    "created_at": "2014-01-06T14:28:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109084",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:304'></a>
Replying to [SimonKing](#comment%3A302):
> Do you think that it is a valid solution to let `._base_category_class_and_axiom` be explicitly set, with the exception of 5 cases in which it is computed/guessed by a lazy attribute? Even with the caveat that this "explicit setting" happens as side-effect of a `__classget__`? I think it is, since the `__classget__` method does not need to *guess*: It merely documents how it has constructed the category that `__classget__` returns.

From reading the discussion so far, this sounds reasonable. I'll be back to Sage development tomorrow (yeah, finally!), and review in details your changes then.

Thanks to all of you for figuring out the issue in my black magic!

Happy new year!
                            Nicolas



---

archive/issue_comments_109085.json:
```json
{
    "body": "<a id='comment:305'></a>\nReplying to [SimonKing](#comment%3A302):\n> Do you think that it is a valid solution to let `._base_category_class_and_axiom` be explicitly set, with the exception of 5 cases in which it is computed/guessed by a lazy attribute?\n\nWould it be too onerous to just change/handcode those 5 cases? It would get rid of the necessity to have an incredibly fragile magic fallback that has program logic attached to `__name__`. When I stumbled into it I was unpleasantly surprised. Sure, as a *guess* it's not a bad heuristic, but as the Zen of Python says: \"In the face of ambiguity refuse the temptation to guess\". I think that's often good advice and I think it's here too.",
    "created_at": "2014-01-06T15:39:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109085",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:305'></a>
Replying to [SimonKing](#comment%3A302):
> Do you think that it is a valid solution to let `._base_category_class_and_axiom` be explicitly set, with the exception of 5 cases in which it is computed/guessed by a lazy attribute?

Would it be too onerous to just change/handcode those 5 cases? It would get rid of the necessity to have an incredibly fragile magic fallback that has program logic attached to `__name__`. When I stumbled into it I was unpleasantly surprised. Sure, as a *guess* it's not a bad heuristic, but as the Zen of Python says: "In the face of ambiguity refuse the temptation to guess". I think that's often good advice and I think it's here too.



---

archive/issue_comments_109086.json:
```json
{
    "body": "<a id='comment:306'></a>\nReplying to [nbruin](#comment%3A305):\n> Replying to [SimonKing](#comment%3A302):\n> > Do you think that it is a valid solution to let `._base_category_class_and_axiom` be explicitly set, with the exception of 5 cases in which it is computed/guessed by a lazy attribute?\n\n> Would it be too onerous to just change/handcode those 5 cases?\n\nThese 5 are those that appear when starting Sage. Nicolas, can you guarantee that all categories-with-axiom that are created after starting Sage will be constructed by means of the `__classget__`?\n\nI think it would be good to get rid of the guesswork! For example, it makes it impossible to create a new category with axiom just *somewhere*: The module name must be chosen according to the name of the category class, or creation of an instance of this class will fail.\n\n```\nsage: from sage.categories.category_with_axiom import CategoryWithAxiom\nsage: class MyAxiom(CategoryWithAxiom): pass\nsage: C = MyAxiom()\nTraceback (most recent call last):\n...\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.pyc in base_category_class_and_axiom(cls)\n    224     module = uncamelcase(name, \"_\")\n    225     assert cls.__module__ == \"sage.categories.\"+module,\\\n--> 226         \"%s should be implemented in `sage.categories.%s`\"%(cls, module)\n    227     for axiom in all_axioms:\n    228         if axiom == \"WithBasis\" and name.endswith(axiom):\n\nAssertionError: <class '__main__.MyAxiom'> should be implemented in `sage.categories.my_axiom`\n```\nAnd this is certainly not very pleasant. Occasionally I like to create a category class on the fly, interactively, and I don't want to be forced to implement it in a specific sub-module of sage.categories.",
    "created_at": "2014-01-06T16:17:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109086",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:306'></a>
Replying to [nbruin](#comment%3A305):
> Replying to [SimonKing](#comment%3A302):
> > Do you think that it is a valid solution to let `._base_category_class_and_axiom` be explicitly set, with the exception of 5 cases in which it is computed/guessed by a lazy attribute?

> Would it be too onerous to just change/handcode those 5 cases?

These 5 are those that appear when starting Sage. Nicolas, can you guarantee that all categories-with-axiom that are created after starting Sage will be constructed by means of the `__classget__`?

I think it would be good to get rid of the guesswork! For example, it makes it impossible to create a new category with axiom just *somewhere*: The module name must be chosen according to the name of the category class, or creation of an instance of this class will fail.

```
sage: from sage.categories.category_with_axiom import CategoryWithAxiom
sage: class MyAxiom(CategoryWithAxiom): pass
sage: C = MyAxiom()
Traceback (most recent call last):
...
/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.pyc in base_category_class_and_axiom(cls)
    224     module = uncamelcase(name, "_")
    225     assert cls.__module__ == "sage.categories."+module,\
--> 226         "%s should be implemented in `sage.categories.%s`"%(cls, module)
    227     for axiom in all_axioms:
    228         if axiom == "WithBasis" and name.endswith(axiom):

AssertionError: <class '__main__.MyAxiom'> should be implemented in `sage.categories.my_axiom`
```
And this is certainly not very pleasant. Occasionally I like to create a category class on the fly, interactively, and I don't want to be forced to implement it in a specific sub-module of sage.categories.



---

archive/issue_comments_109087.json:
```json
{
    "body": "<a id='comment:7'></a>\nFor the record, the buildbot didn't find any further issues. I agree with Nils about not doing string munging if it can be avoided.",
    "created_at": "2014-01-06T21:57:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109087",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:7'></a>
For the record, the buildbot didn't find any further issues. I agree with Nils about not doing string munging if it can be avoided.



---

archive/issue_comments_109088.json:
```json
{
    "body": "<a id='comment:8'></a>\nSince we only have 5 (additional) exceptional cases, I agree it would make sense to provide them directly, otherwise rely on the classget. If you don't mind, I'll prepare a commit accordingly. I could imagine that we can get rid of the guessing function `base_category_class_and_axiom(cls)`, but this would (perhaps) be a second commit.",
    "created_at": "2014-01-06T22:10:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109088",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Since we only have 5 (additional) exceptional cases, I agree it would make sense to provide them directly, otherwise rely on the classget. If you don't mind, I'll prepare a commit accordingly. I could imagine that we can get rid of the guessing function `base_category_class_and_axiom(cls)`, but this would (perhaps) be a second commit.



---

archive/issue_comments_109089.json:
```json
{
    "body": "<a id='comment:9'></a>\nAha, it is not so easy. It turns out that the lazy attribute is involved much more often, but not during startup of Sage.\n\nFor example, when you start Sage, then `FinitePermutationGroups` are not constructed by means of applying an axiom. Hence, the attribute is not available. Hence, things crash.\n\n```\nsage: FinitePermutationGroups()\n# Note: Here I have replaced the lazy axiom by something that just raises an error\nTraceback (most recent call last):\n...\nAttributeError: <class 'sage.categories.finite_permutation_groups.FinitePermutationGroups'> does not know its base category and axiom\n```\nIf one then constructs the category *class* (not instance!) by means of an axiom, thing work:\n\n```\nsage: PermutationGroups.Finite\n<class 'sage.categories.finite_permutation_groups.FinitePermutationGroups'>\nsage: FinitePermutationGroups()\nCategory of finite permutation groups\n```\n\nSo, it seems that we have to live with the guesswork. But I wonder if we can simplify the logic, and can make it so that categories with axiom can be defined interactively.",
    "created_at": "2014-01-06T22:49:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109089",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Aha, it is not so easy. It turns out that the lazy attribute is involved much more often, but not during startup of Sage.

For example, when you start Sage, then `FinitePermutationGroups` are not constructed by means of applying an axiom. Hence, the attribute is not available. Hence, things crash.

```
sage: FinitePermutationGroups()
# Note: Here I have replaced the lazy axiom by something that just raises an error
Traceback (most recent call last):
...
AttributeError: <class 'sage.categories.finite_permutation_groups.FinitePermutationGroups'> does not know its base category and axiom
```
If one then constructs the category *class* (not instance!) by means of an axiom, thing work:

```
sage: PermutationGroups.Finite
<class 'sage.categories.finite_permutation_groups.FinitePermutationGroups'>
sage: FinitePermutationGroups()
Category of finite permutation groups
```

So, it seems that we have to live with the guesswork. But I wonder if we can simplify the logic, and can make it so that categories with axiom can be defined interactively.



---

archive/issue_comments_109090.json:
```json
{
    "body": "<a id='comment:310'></a>\nReplying to [SimonKing](#comment%3A309):\n\n> So, it seems that we have to live with the guesswork.\n\nOr change the way `FinitePermutationGroups` is constructed. It's not that the base category of `FinitePermutationGroups` is ever going to be anything else than `PermutationGroups`.",
    "created_at": "2014-01-07T01:55:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109090",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:310'></a>
Replying to [SimonKing](#comment%3A309):

> So, it seems that we have to live with the guesswork.

Or change the way `FinitePermutationGroups` is constructed. It's not that the base category of `FinitePermutationGroups` is ever going to be anything else than `PermutationGroups`.



---

archive/issue_comments_109091.json:
```json
{
    "body": "<a id='comment:311'></a>\nReplying to [nbruin](#comment%3A310):\n> Replying to [SimonKing](#comment%3A309):\n> \n> > So, it seems that we have to live with the guesswork.\n\n> \n> Or change the way `FinitePermutationGroups` is constructed. It's not that the base category of `FinitePermutationGroups` is ever going to be anything else than `PermutationGroups`. \n\nHow?\n\nThe current logic is: There is a category `FinitePermutationGroups`, that in the first place is stand-alone and only knows that it is obtained by some axiom, but it does not know *which* axiom. To work properly, it needs to find out which axiom it was obtained from.\n\nWith the current logic, the category class has three ways to learn the construction information:\n1. If someone did `PermutationGroups().Finite()`, then `FinitePermutationGroups` would be returned *and* at the same time the construction information would be stored in `FinitePermutationGroups._base_category_class_and_axiom`.\n2. We could handcode `FinitePermutationGroups._base_category_class_and_axiom`.\n3. The correct value of `FinitePermutationGroups._base_category_class_and_axiom` could be guessed from the name, and then verified by calling the base category with the axiom. If an inconsistency arises, then an error is raised stating that the value can not be guessed.\n\nSo, questions to Nils:\n- Do you intend to handcode everything? Then you need to cover many cases.\n- Do you intend to put `PermutationGroups().Finite()` into code that is executed at startup time, and similarly for *all* other categories with axiom? Then, the startup time would likely to increase, and it would not be less work than the other way to handcode the construction.\n- Do you intend to change the logic totally? This would mean to re-write Nicolas patch from scratch.",
    "created_at": "2014-01-07T09:46:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109091",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:311'></a>
Replying to [nbruin](#comment%3A310):
> Replying to [SimonKing](#comment%3A309):
> 
> > So, it seems that we have to live with the guesswork.

> 
> Or change the way `FinitePermutationGroups` is constructed. It's not that the base category of `FinitePermutationGroups` is ever going to be anything else than `PermutationGroups`. 

How?

The current logic is: There is a category `FinitePermutationGroups`, that in the first place is stand-alone and only knows that it is obtained by some axiom, but it does not know *which* axiom. To work properly, it needs to find out which axiom it was obtained from.

With the current logic, the category class has three ways to learn the construction information:
1. If someone did `PermutationGroups().Finite()`, then `FinitePermutationGroups` would be returned *and* at the same time the construction information would be stored in `FinitePermutationGroups._base_category_class_and_axiom`.
2. We could handcode `FinitePermutationGroups._base_category_class_and_axiom`.
3. The correct value of `FinitePermutationGroups._base_category_class_and_axiom` could be guessed from the name, and then verified by calling the base category with the axiom. If an inconsistency arises, then an error is raised stating that the value can not be guessed.

So, questions to Nils:
- Do you intend to handcode everything? Then you need to cover many cases.
- Do you intend to put `PermutationGroups().Finite()` into code that is executed at startup time, and similarly for *all* other categories with axiom? Then, the startup time would likely to increase, and it would not be less work than the other way to handcode the construction.
- Do you intend to change the logic totally? This would mean to re-write Nicolas patch from scratch.



---

archive/issue_comments_109092.json:
```json
{
    "body": "<a id='comment:2'></a>\nFor the record: I am in the process of writing a long answer to the discussion.",
    "created_at": "2014-01-07T10:13:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109092",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:2'></a>
For the record: I am in the process of writing a long answer to the discussion.



---

archive/issue_comments_109093.json:
```json
{
    "body": "<a id='comment:313'></a>\nHi Simon, Nils, Volker,\n\nWhen designing infrastructure, one of my main guiding principle is to\nstrive hard to get concise, expressive, redundancy free idioms. In\nparticular, I believe that a bit of well localized black magic in the\ninfrastructure is acceptable if it avoids redundancy in many places in\nthe code using that infrastructure. Trading uglyness in one spot for\nbeauty in many. For example `ClasscallMetaclass` is definitely ugly\nblack magic, but I believe it was the price to pay for the nice\n`UniqueRepresentation` idiom.\n\nNow, in the case at hand, is this going overboard?\n\nHere are some necessary conditions that should be satisfied:\n\n(1) The black magic should be robust.\n(2) The black magic should be well documented.\n(3) The black magic should be transparent to the casual user; that is it should be invisible most of the time, and when it appears on the surface, it should be easy to understand what it does without understanding the implementation details.\n(4) In particular, in case of error, the black magic should raise clear enough messages.\n(5) There should be a couple developers that understand the implementation details.\n(6) It should be worth it :-)\n\nLet's take those points one by one.\n\n(1,5) Well, hopefully this is now the case :-)\n    Thanks so much and congratulations for your work on this! The\n    recursion triggered by an assertion check was really a tricky\n    one.\n\n(2) Granted, this is not yet up to speed. In general there is no documentation yet on how axioms work which is very bad. I created the follow up #15643 for this.\n\n(3) From the feedback I got from users / implementers of axioms, this seems to be not so bad.\n\n(4) This is hopefully better now. See below.\n\n(6) the guesswork is currently used in roughly 20 categories:\n\n```\nmistral>grep -L base_category `grep -l \"^class.*CategoryWithAxiom\" *.py` | wc -l\n20\n```\n\nI expect this number to increase much with time, as more and more\ncategories with axioms are added. The existing followup code in the\nSage-Combinat queue adds at least as many.\n\n\nAbout Simon's issue with interactively creating categories with axiom.\nThe error message was confusing; it is in fact possible; one just need\nto specify _base_category_class_and_axiom if the guessing does not\nwork:\n\n```\n    sage: class Cs(Category):\n    ....:     def super_categories(self): return [Sets()]\n    sage: class Ds(CategoryWithAxiom):\n    ....:     _base_category_class_and_axiom = [ Cs, \"Finite\" ]\n    sage: Cs.Finite = Ds\n    sage: Cs.Finite = Ds\n    sage: Ds()\n    Category of ds\n    sage: Ds().super_categories()\n    [Category of finite sets, Category of cs]\n```\n\nIn an upcoming commit, I improved the error message and also the\nlogic: for the guessing to work, only the base category needs to be in\nthe standard location, not the category with axiom itself. So now one\ncan do:\n\n```\n    sage: class FacadeSemigroups(CategoryWithAxiom):\n    ....:     pass\n    sage: Semigroups.Facade = FacadeSemigroups\n    sage: FacadeSemigroups()\n    Category of facade semigroups\n```\n\nThanks Simon for pointing those deficiencies!\n\n\nAltogether, I think it's worth keeping the feature. The implementation\nis definitely disputable and any further improvement is more than\nwelcome: simplified logic, better error handling, documentation, ...\nBut maybe we can consider it good enough for now.\n\nCheers,\n                             Nicolas\n\nPS: about Python's Zen about guessing: I believe this is more about\nhuman guessing rather than computer heuristics; but that might be just\nmy interpretation!",
    "created_at": "2014-01-07T10:48:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109093",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:313'></a>
Hi Simon, Nils, Volker,

When designing infrastructure, one of my main guiding principle is to
strive hard to get concise, expressive, redundancy free idioms. In
particular, I believe that a bit of well localized black magic in the
infrastructure is acceptable if it avoids redundancy in many places in
the code using that infrastructure. Trading uglyness in one spot for
beauty in many. For example `ClasscallMetaclass` is definitely ugly
black magic, but I believe it was the price to pay for the nice
`UniqueRepresentation` idiom.

Now, in the case at hand, is this going overboard?

Here are some necessary conditions that should be satisfied:

(1) The black magic should be robust.
(2) The black magic should be well documented.
(3) The black magic should be transparent to the casual user; that is it should be invisible most of the time, and when it appears on the surface, it should be easy to understand what it does without understanding the implementation details.
(4) In particular, in case of error, the black magic should raise clear enough messages.
(5) There should be a couple developers that understand the implementation details.
(6) It should be worth it :-)

Let's take those points one by one.

(1,5) Well, hopefully this is now the case :-)
    Thanks so much and congratulations for your work on this! The
    recursion triggered by an assertion check was really a tricky
    one.

(2) Granted, this is not yet up to speed. In general there is no documentation yet on how axioms work which is very bad. I created the follow up #15643 for this.

(3) From the feedback I got from users / implementers of axioms, this seems to be not so bad.

(4) This is hopefully better now. See below.

(6) the guesswork is currently used in roughly 20 categories:

```
mistral>grep -L base_category `grep -l "^class.*CategoryWithAxiom" *.py` | wc -l
20
```

I expect this number to increase much with time, as more and more
categories with axioms are added. The existing followup code in the
Sage-Combinat queue adds at least as many.


About Simon's issue with interactively creating categories with axiom.
The error message was confusing; it is in fact possible; one just need
to specify _base_category_class_and_axiom if the guessing does not
work:

```
    sage: class Cs(Category):
    ....:     def super_categories(self): return [Sets()]
    sage: class Ds(CategoryWithAxiom):
    ....:     _base_category_class_and_axiom = [ Cs, "Finite" ]
    sage: Cs.Finite = Ds
    sage: Cs.Finite = Ds
    sage: Ds()
    Category of ds
    sage: Ds().super_categories()
    [Category of finite sets, Category of cs]
```

In an upcoming commit, I improved the error message and also the
logic: for the guessing to work, only the base category needs to be in
the standard location, not the category with axiom itself. So now one
can do:

```
    sage: class FacadeSemigroups(CategoryWithAxiom):
    ....:     pass
    sage: Semigroups.Facade = FacadeSemigroups
    sage: FacadeSemigroups()
    Category of facade semigroups
```

Thanks Simon for pointing those deficiencies!


Altogether, I think it's worth keeping the feature. The implementation
is definitely disputable and any further improvement is more than
welcome: simplified logic, better error handling, documentation, ...
But maybe we can consider it good enough for now.

Cheers,
                             Nicolas

PS: about Python's Zen about guessing: I believe this is more about
human guessing rather than computer heuristics; but that might be just
my interpretation!



---

archive/issue_comments_109094.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/32b3c4e13aca58a7dfc9a33528164a5ef1b273e7\">32b3c4e</a></td><td><code>Improved the guessing logic for categories with axioms + typo fixes</code></td></tr></table>\n",
    "created_at": "2014-01-07T11:06:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109094",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/32b3c4e13aca58a7dfc9a33528164a5ef1b273e7">32b3c4e</a></td><td><code>Improved the guessing logic for categories with axioms + typo fixes</code></td></tr></table>




---

archive/issue_comments_109095.json:
```json
{
    "body": "**Changing commit** from \"[ec340363a811bbafbb8cd5ff8f39e75db9872f9f](https://github.com/sagemath/sagetrac-mirror/commit/ec340363a811bbafbb8cd5ff8f39e75db9872f9f)\" to \"[32b3c4e13aca58a7dfc9a33528164a5ef1b273e7](https://github.com/sagemath/sagetrac-mirror/commit/32b3c4e13aca58a7dfc9a33528164a5ef1b273e7)\".",
    "created_at": "2014-01-07T11:06:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109095",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ec340363a811bbafbb8cd5ff8f39e75db9872f9f](https://github.com/sagemath/sagetrac-mirror/commit/ec340363a811bbafbb8cd5ff8f39e75db9872f9f)" to "[32b3c4e13aca58a7dfc9a33528164a5ef1b273e7](https://github.com/sagemath/sagetrac-mirror/commit/32b3c4e13aca58a7dfc9a33528164a5ef1b273e7)".



---

archive/issue_comments_109096.json:
```json
{
    "body": "<a id='comment:5'></a>\nHi Simon,\n\nI just went through your changes to the guessing, and I am happy with them. Just one thing: did you have a specific rationale for switching the value of \"was_guessed\" to False when it's set by __classget__?\n\nA priori, I meant the value to be True whenever the base category and axiom was discovered by the system, and not set explicitly in the category with axiom.\n\nCheers,\n                                     Nicolas",
    "created_at": "2014-01-07T11:40:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109096",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>
Hi Simon,

I just went through your changes to the guessing, and I am happy with them. Just one thing: did you have a specific rationale for switching the value of "was_guessed" to False when it's set by __classget__?

A priori, I meant the value to be True whenever the base category and axiom was discovered by the system, and not set explicitly in the category with axiom.

Cheers,
                                     Nicolas



---

archive/issue_comments_109097.json:
```json
{
    "body": "<a id='comment:6'></a>\nNote: I'll have a small review patch which I'll push after lunch.",
    "created_at": "2014-01-07T11:41:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109097",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>
Note: I'll have a small review patch which I'll push after lunch.



---

archive/issue_comments_109098.json:
```json
{
    "body": "<a id='comment:317'></a>\nReplying to [nthiery](#comment%3A315):\n> I just went through your changes to the guessing, and I am happy with them. Just one thing: did you have a specific rationale for switching the value of \"was_guessed\" to False when it's set by `__classget__`?\n\nYes. If it is set by `__classget__` then it wasn't guessed. Hence, \"was_guessed\" should be false.\n\nMoreover, it makes debugging slightly easier, as the \"was_guessed\" attribute tells how the base category class and axiom were obtained:\n- If \"was_guessed\" is missing: handcoded.\n- If \"was_guessed==True\": lazy class attribute was using name mangling.\n- If \"was_guessed==False\": the class was *explicitly constructed* in that way, hence, guessing (and name mangling) was not needed.\n\n> A priori, I meant the value to be True whenever the base category and axiom was discovered by the system, and not set explicitly in the category with axiom.\n\nSee above: This can still be seen in the absence of \"was_guessed\".",
    "created_at": "2014-01-07T11:52:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109098",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:317'></a>
Replying to [nthiery](#comment%3A315):
> I just went through your changes to the guessing, and I am happy with them. Just one thing: did you have a specific rationale for switching the value of "was_guessed" to False when it's set by `__classget__`?

Yes. If it is set by `__classget__` then it wasn't guessed. Hence, "was_guessed" should be false.

Moreover, it makes debugging slightly easier, as the "was_guessed" attribute tells how the base category class and axiom were obtained:
- If "was_guessed" is missing: handcoded.
- If "was_guessed==True": lazy class attribute was using name mangling.
- If "was_guessed==False": the class was *explicitly constructed* in that way, hence, guessing (and name mangling) was not needed.

> A priori, I meant the value to be True whenever the base category and axiom was discovered by the system, and not set explicitly in the category with axiom.

See above: This can still be seen in the absence of "was_guessed".



---

archive/issue_comments_109099.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/478de48553d203516cddb47e0cb89c34ccc210ee\">478de48</a></td><td><code>Categories with axioms: improved names for the protocol to recover how _base_category_class_and_axiom was set.</code></td></tr></table>\n",
    "created_at": "2014-01-07T14:43:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109099",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/478de48553d203516cddb47e0cb89c34ccc210ee">478de48</a></td><td><code>Categories with axioms: improved names for the protocol to recover how _base_category_class_and_axiom was set.</code></td></tr></table>




---

archive/issue_comments_109100.json:
```json
{
    "body": "**Changing commit** from \"[32b3c4e13aca58a7dfc9a33528164a5ef1b273e7](https://github.com/sagemath/sagetrac-mirror/commit/32b3c4e13aca58a7dfc9a33528164a5ef1b273e7)\" to \"[478de48553d203516cddb47e0cb89c34ccc210ee](https://github.com/sagemath/sagetrac-mirror/commit/478de48553d203516cddb47e0cb89c34ccc210ee)\".",
    "created_at": "2014-01-07T14:43:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109100",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[32b3c4e13aca58a7dfc9a33528164a5ef1b273e7](https://github.com/sagemath/sagetrac-mirror/commit/32b3c4e13aca58a7dfc9a33528164a5ef1b273e7)" to "[478de48553d203516cddb47e0cb89c34ccc210ee](https://github.com/sagemath/sagetrac-mirror/commit/478de48553d203516cddb47e0cb89c34ccc210ee)".



---

archive/issue_comments_109101.json:
```json
{
    "body": "<a id='comment:319'></a>\nReplying to [SimonKing](#comment%3A317):\n> Yes. If it is set by `__classget__` then it wasn't guessed. Hence, \"was_guessed\" should be false.\n> \n> Moreover, it makes debugging slightly easier, as the \"was_guessed\" attribute tells how the base category class and axiom were obtained:\n> - If \"was_guessed\" is missing: handcoded.\n> - If \"was_guessed==True\": lazy class attribute was using name mangling.\n> - If \"was_guessed==False\": the class was *explicitly constructed* in that way, hence, guessing (and name mangling) was not needed.\n> \n> > A priori, I meant the value to be True whenever the base category and axiom was discovered by the system, and not set explicitly in the category with axiom.\n\n> \n> See above: This can still be seen in the absence of \"was_guessed\".\n\nOk; from this discussion it became clear that the name of this\nattribute was bad since we did not interpret it in the same way. I\nreworked a tiny bit the protocol so that it's less ambiguous, and\nimproved the doc accordingly.\n\nIf all test pass, if you are happy with the above change, and if Nils\nand Volker are ok with keeping the guessing strategy, then we could go\nback to positive review!\n\nCheers,\n                            Nicolas",
    "created_at": "2014-01-07T14:48:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109101",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:319'></a>
Replying to [SimonKing](#comment%3A317):
> Yes. If it is set by `__classget__` then it wasn't guessed. Hence, "was_guessed" should be false.
> 
> Moreover, it makes debugging slightly easier, as the "was_guessed" attribute tells how the base category class and axiom were obtained:
> - If "was_guessed" is missing: handcoded.
> - If "was_guessed==True": lazy class attribute was using name mangling.
> - If "was_guessed==False": the class was *explicitly constructed* in that way, hence, guessing (and name mangling) was not needed.
> 
> > A priori, I meant the value to be True whenever the base category and axiom was discovered by the system, and not set explicitly in the category with axiom.

> 
> See above: This can still be seen in the absence of "was_guessed".

Ok; from this discussion it became clear that the name of this
attribute was bad since we did not interpret it in the same way. I
reworked a tiny bit the protocol so that it's less ambiguous, and
improved the doc accordingly.

If all test pass, if you are happy with the above change, and if Nils
and Volker are ok with keeping the guessing strategy, then we could go
back to positive review!

Cheers,
                            Nicolas



---

archive/issue_comments_109102.json:
```json
{
    "body": "<a id='comment:320'></a>\nReplying to [nthiery](#comment%3A319):\n> Ok; from this discussion it became clear that the name of this\n> attribute was bad since we did not interpret it in the same way. I\n> reworked a tiny bit the protocol so that it's less ambiguous, and\n> improved the doc accordingly.\n\nSo, now you want that `_base_category_class_and_axiom_origin` is explicitly set to `'hardcoded'` whenever someone hardcodes `_base_category_class_and_axiom`? Said \"someone\" will probably forget to set it. That's why I still think it is better to *not* set it, if it is hardcoded, and to automatically set it in classget resp. in the lazy attribute.\n \n> If all test pass, if you are happy with the above change,\n\nUp to the above criticism, I am happy with the previous two commits. But let's see if tests pass.\n\nSome meta-remark:\n\nIt seems to me that you want to turn sage.categories into a database, but without using existing implementations of databases (aka \"reinventing the wheel\"). Relations between the items stored in that database are encoded in `_base_category_class_and_axiom` on the one hand, and by providing nested classes (e.g., \n\n```\nPermutationGroups.Finite = LazyImport('sage.categories.finite_permutation_groups', 'FinitePermutationGroups')\n```\non the other hand. Here, `_base_category_class_and_axiom` is either hardcoded, guessed from the names (which requires to stick to certain naming conventions), or explicitly obtained if `__classget__` happens to be involved.\n\nPerhaps (in a second step, certainly not now) one should think of using dedicated database tools?",
    "created_at": "2014-01-07T15:06:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109102",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:320'></a>
Replying to [nthiery](#comment%3A319):
> Ok; from this discussion it became clear that the name of this
> attribute was bad since we did not interpret it in the same way. I
> reworked a tiny bit the protocol so that it's less ambiguous, and
> improved the doc accordingly.

So, now you want that `_base_category_class_and_axiom_origin` is explicitly set to `'hardcoded'` whenever someone hardcodes `_base_category_class_and_axiom`? Said "someone" will probably forget to set it. That's why I still think it is better to *not* set it, if it is hardcoded, and to automatically set it in classget resp. in the lazy attribute.
 
> If all test pass, if you are happy with the above change,

Up to the above criticism, I am happy with the previous two commits. But let's see if tests pass.

Some meta-remark:

It seems to me that you want to turn sage.categories into a database, but without using existing implementations of databases (aka "reinventing the wheel"). Relations between the items stored in that database are encoded in `_base_category_class_and_axiom` on the one hand, and by providing nested classes (e.g., 

```
PermutationGroups.Finite = LazyImport('sage.categories.finite_permutation_groups', 'FinitePermutationGroups')
```
on the other hand. Here, `_base_category_class_and_axiom` is either hardcoded, guessed from the names (which requires to stick to certain naming conventions), or explicitly obtained if `__classget__` happens to be involved.

Perhaps (in a second step, certainly not now) one should think of using dedicated database tools?



---

archive/issue_comments_109103.json:
```json
{
    "body": "<a id='comment:321'></a>\nReplying to [SimonKing](#comment%3A320):\n> So, now you want that `_base_category_class_and_axiom_origin` is\n> explicitly set to `'hardcoded'` whenever someone hardcodes\n> `_base_category_class_and_axiom`?\n\nLuckily, not! That would be very bad indeed: cluttering the code with\nredundant information. If you look right after the\n_base_category_class_and_axiom attribute, you will see that\n_base_category_class_and_axiom_origin is set to 'hardcoded' which does\nthe trick.\n\n> Some meta-remark:\n> \n> It seems to me that you want to turn sage.categories into a database, but without using existing implementations of databases (aka \"reinventing the wheel\"). Relations between the items stored in that database are encoded in `_base_category_class_and_axiom` on the one hand, and by providing nested classes (e.g., \n> \n> ```\n> PermutationGroups.Finite = LazyImport('sage.categories.finite_permutation_groups', 'FinitePermutationGroups')\n> ```\n> on the other hand. Here, `_base_category_class_and_axiom` is either hardcoded, guessed from the names (which requires to stick to certain naming conventions), or explicitly obtained if `__classget__` happens to be involved.\n> \n> Perhaps (in a second step, certainly not now) one should think of using dedicated database tools?\n\nYes, from the beginning, Categories are definitely some sort of\ndatabase of algorithms and math knowledge (in particular deduction\nrules defined programmatically). At first sight, it does not seem\nobvious that this could be implemented using standard database tools,\nbut we can certainly think about it.\n\nCheers,\n\t\t\t\tNicolas",
    "created_at": "2014-01-07T15:31:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109103",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:321'></a>
Replying to [SimonKing](#comment%3A320):
> So, now you want that `_base_category_class_and_axiom_origin` is
> explicitly set to `'hardcoded'` whenever someone hardcodes
> `_base_category_class_and_axiom`?

Luckily, not! That would be very bad indeed: cluttering the code with
redundant information. If you look right after the
_base_category_class_and_axiom attribute, you will see that
_base_category_class_and_axiom_origin is set to 'hardcoded' which does
the trick.

> Some meta-remark:
> 
> It seems to me that you want to turn sage.categories into a database, but without using existing implementations of databases (aka "reinventing the wheel"). Relations between the items stored in that database are encoded in `_base_category_class_and_axiom` on the one hand, and by providing nested classes (e.g., 
> 
> ```
> PermutationGroups.Finite = LazyImport('sage.categories.finite_permutation_groups', 'FinitePermutationGroups')
> ```
> on the other hand. Here, `_base_category_class_and_axiom` is either hardcoded, guessed from the names (which requires to stick to certain naming conventions), or explicitly obtained if `__classget__` happens to be involved.
> 
> Perhaps (in a second step, certainly not now) one should think of using dedicated database tools?

Yes, from the beginning, Categories are definitely some sort of
database of algorithms and math knowledge (in particular deduction
rules defined programmatically). At first sight, it does not seem
obvious that this could be implemented using standard database tools,
but we can certainly think about it.

Cheers,
				Nicolas



---

archive/issue_comments_109104.json:
```json
{
    "body": "<a id='comment:322'></a>\nReplying to [nthiery](#comment%3A321):\n> Luckily, not! That would be very bad indeed: cluttering the code with\n> redundant information. If you look right after the\n> _base_category_class_and_axiom attribute, you will see that\n> _base_category_class_and_axiom_origin is set to 'hardcoded' which does\n> the trick.\n\nAhaha, you are right. The \"origin\" attribute is there by default and overridden as soon as classget or the lazy attribute are involved. OK, then I'm fine with both recent commits, modulo doctests passing.",
    "created_at": "2014-01-07T15:38:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109104",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:322'></a>
Replying to [nthiery](#comment%3A321):
> Luckily, not! That would be very bad indeed: cluttering the code with
> redundant information. If you look right after the
> _base_category_class_and_axiom attribute, you will see that
> _base_category_class_and_axiom_origin is set to 'hardcoded' which does
> the trick.

Ahaha, you are right. The "origin" attribute is there by default and overridden as soon as classget or the lazy attribute are involved. OK, then I'm fine with both recent commits, modulo doctests passing.



---

archive/issue_comments_109105.json:
```json
{
    "body": "<a id='comment:3'></a>\nFor the record, all tests passed on my machine.",
    "created_at": "2014-01-07T16:19:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109105",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:3'></a>
For the record, all tests passed on my machine.



---

archive/issue_comments_109106.json:
```json
{
    "body": "<a id='comment:4'></a>\n\n```\n+ @cached_method\n+ def DualObjects(self):\n+ r\"\"\"\n+ Return the category of duals of objects of ``self``.\n+\n+ The dual of a vector space `V` is the space consisting of\n+ all linear functionals on `V` (see :wikipedia:`Dual_space`).\n+ Additional structure on `V` can endow its dual with\n+ additional structure; e.g. if `V` is an algebra, then its\n+ dual is a coalgebra.\n+\n+ This returns the category of dual of spaces in ``self`` endowed\n+ with the appropriate additional structure.\n+\n+ .. SEEALSO::\n+\n+ - :class:`.dual.DualObjectsCategory`\n+ - :class:`~.covariant_functorial_construction.CovariantFunctorialConstruction`.\n+\n+ .. TODO:: add support for graded duals.\n+\n+ EXAMPLES::\n+\n+ sage: VectorSpaces(QQ).DualObjects()\n+ Category of duals of vector spaces over Rational Field\n+\n+ The dual of a vector space is a vector space::\n+\n+ sage: VectorSpaces(QQ).DualObjects().super_categories()\n+ [Category of vector spaces over Rational Field]\n+\n+ The dual of an algebra is a coalgebra::\n+\n+ sage: sorted(Algebras(QQ).DualObjects().super_categories(), key=str)\n+ [Category of coalgebras over Rational Field,\n+ Category of duals of vector spaces over Rational Field]\n```\n\nI know this is not a big issue since the `dual()` of an algebra *is* a coalgebra in all cases in which `dual()` is implemented (not least because in the infinite-dimensional cases it usually means the graded dual). But I'm still unhappy with the docstring lying in my face. Can anyone write a reasonably worded .. WARNING about this `dual()` not being the actual vector-space dual?",
    "created_at": "2014-01-07T16:32:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109106",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:4'></a>

```
+ @cached_method
+ def DualObjects(self):
+ r"""
+ Return the category of duals of objects of ``self``.
+
+ The dual of a vector space `V` is the space consisting of
+ all linear functionals on `V` (see :wikipedia:`Dual_space`).
+ Additional structure on `V` can endow its dual with
+ additional structure; e.g. if `V` is an algebra, then its
+ dual is a coalgebra.
+
+ This returns the category of dual of spaces in ``self`` endowed
+ with the appropriate additional structure.
+
+ .. SEEALSO::
+
+ - :class:`.dual.DualObjectsCategory`
+ - :class:`~.covariant_functorial_construction.CovariantFunctorialConstruction`.
+
+ .. TODO:: add support for graded duals.
+
+ EXAMPLES::
+
+ sage: VectorSpaces(QQ).DualObjects()
+ Category of duals of vector spaces over Rational Field
+
+ The dual of a vector space is a vector space::
+
+ sage: VectorSpaces(QQ).DualObjects().super_categories()
+ [Category of vector spaces over Rational Field]
+
+ The dual of an algebra is a coalgebra::
+
+ sage: sorted(Algebras(QQ).DualObjects().super_categories(), key=str)
+ [Category of coalgebras over Rational Field,
+ Category of duals of vector spaces over Rational Field]
```

I know this is not a big issue since the `dual()` of an algebra *is* a coalgebra in all cases in which `dual()` is implemented (not least because in the infinite-dimensional cases it usually means the graded dual). But I'm still unhappy with the docstring lying in my face. Can anyone write a reasonably worded .. WARNING about this `dual()` not being the actual vector-space dual?



---

archive/issue_comments_109107.json:
```json
{
    "body": "<a id='comment:325'></a>\nAlso, I suspect this to be a typo:\n\n```\n+ class Unital(CategoryWithAxiom):\n+\n+ class SubcategoryMethods:\n+\n+ @cached_method\n+ def Inverse(self):\n+ r\"\"\"\n+ Returns the full subcategory of the unital objects of ``self``.\n+\n+ EXAMPLES::\n+\n+ sage: Magmas().Unital().Inverse()\n+ Category of inverse unital magmas\n+ sage: Monoids().Inverse()\n+ Category of groups\n```\nShould be the full subcategory of the *inverse*, not the unital, objects of self.",
    "created_at": "2014-01-07T16:35:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109107",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:325'></a>
Also, I suspect this to be a typo:

```
+ class Unital(CategoryWithAxiom):
+
+ class SubcategoryMethods:
+
+ @cached_method
+ def Inverse(self):
+ r"""
+ Returns the full subcategory of the unital objects of ``self``.
+
+ EXAMPLES::
+
+ sage: Magmas().Unital().Inverse()
+ Category of inverse unital magmas
+ sage: Monoids().Inverse()
+ Category of groups
```
Should be the full subcategory of the *inverse*, not the unital, objects of self.



---

archive/issue_comments_109108.json:
```json
{
    "body": "<a id='comment:326'></a>\nNicholas has explained his original intent to a large degree in a post above and I mostly agree with him, except on one place. Apparently, in his model every category is constructed from a supercategory and an axiom. In that case there is no need for guessing data: all the data is there when the category gets constructed.\n\nApparently some categories do not get constructed explicitly from a supercategory and an axiom. Instead, the system splits the `__name__` into pieces and uses part as a name for an axiom and another part as name for the supercategory. I guess that this seems a convenient shortcut because most of those categories are defined by literal source code. I think it's crossing a line. Nowhere else in Python does the makeup of a name determine the inheritance of properties (which eventually categories will lead to). As Thierry points out, it's a heuristic one can avoid, but I think it departs so much from what Python normally does that it will frequently lead to confusion. I think you should look for a cleaner paradigm to express these relations concisely, and now is the time to get it right. It will be more painful to change it afterwards.\n\nIt doesn't sound to me like the category information forms a database in the sense of a bunch of tables filled with rows and columns. To me it seems closer to a (rooted?) tree, with edged labelled by axioms. Python has syntax to express rooted trees: inheritance. The only thing missing is the label. That can be replaced by a class attribute, simply set to a string. There is a small amount of boilerplate involved with writing classes, e.g., one usually has to write `def __init__(self):`. Writing a single line `axiom = \"Finite\"` can be considered acceptable boilerplate in my opinion and removes all guessing. Do you think that having to write that \"Finite\" is redundancy because \"Finite\" already occurs in the `__name__`? In that case I disagree: everywhere in python people are free to choose names that they think are most informative (avoiding collisions and key words), regardless of semantics of the code.\n\nReplying to [SimonKing](#comment%3A311):\n\n> So, questions to Nils:\n> - Do you intend to handcode everything? Then you need to cover many cases.\n\nI may misunderstand what is required in the process, but at the moment I think \"yes\". If an axiom is a required property for a Category then it needs to be supplied somewhere, not derived by chopping a part of a `__name__`.\n\n> - Do you intend to put `PermutationGroups().Finite()` into code that is executed at startup time, and similarly for *all* other categories with axiom? Then, the startup time would likely to increase, and it would not be less work than the other way to handcode the construction.\n\nYou do not make that sound attractive. I don't know what that code would do, so I was not intending to put that anywhere.\n\n> - Do you intend to change the logic totally? This would mean to re-write Nicolas patch from scratch.\n\nIf the present patch unavoidably leads to convoluted constructs that that's a strong indication that the design is flawed. In that case it might be advisable to either redesign or carefully argue what the current design is and indicate why the nasty bits are really unavoidable.\n\nThis is infrastructure. We'll be living with this for a *long* time (see coercion framework). It's worth trying to get it right.",
    "created_at": "2014-01-07T17:33:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109108",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:326'></a>
Nicholas has explained his original intent to a large degree in a post above and I mostly agree with him, except on one place. Apparently, in his model every category is constructed from a supercategory and an axiom. In that case there is no need for guessing data: all the data is there when the category gets constructed.

Apparently some categories do not get constructed explicitly from a supercategory and an axiom. Instead, the system splits the `__name__` into pieces and uses part as a name for an axiom and another part as name for the supercategory. I guess that this seems a convenient shortcut because most of those categories are defined by literal source code. I think it's crossing a line. Nowhere else in Python does the makeup of a name determine the inheritance of properties (which eventually categories will lead to). As Thierry points out, it's a heuristic one can avoid, but I think it departs so much from what Python normally does that it will frequently lead to confusion. I think you should look for a cleaner paradigm to express these relations concisely, and now is the time to get it right. It will be more painful to change it afterwards.

It doesn't sound to me like the category information forms a database in the sense of a bunch of tables filled with rows and columns. To me it seems closer to a (rooted?) tree, with edged labelled by axioms. Python has syntax to express rooted trees: inheritance. The only thing missing is the label. That can be replaced by a class attribute, simply set to a string. There is a small amount of boilerplate involved with writing classes, e.g., one usually has to write `def __init__(self):`. Writing a single line `axiom = "Finite"` can be considered acceptable boilerplate in my opinion and removes all guessing. Do you think that having to write that "Finite" is redundancy because "Finite" already occurs in the `__name__`? In that case I disagree: everywhere in python people are free to choose names that they think are most informative (avoiding collisions and key words), regardless of semantics of the code.

Replying to [SimonKing](#comment%3A311):

> So, questions to Nils:
> - Do you intend to handcode everything? Then you need to cover many cases.

I may misunderstand what is required in the process, but at the moment I think "yes". If an axiom is a required property for a Category then it needs to be supplied somewhere, not derived by chopping a part of a `__name__`.

> - Do you intend to put `PermutationGroups().Finite()` into code that is executed at startup time, and similarly for *all* other categories with axiom? Then, the startup time would likely to increase, and it would not be less work than the other way to handcode the construction.

You do not make that sound attractive. I don't know what that code would do, so I was not intending to put that anywhere.

> - Do you intend to change the logic totally? This would mean to re-write Nicolas patch from scratch.

If the present patch unavoidably leads to convoluted constructs that that's a strong indication that the design is flawed. In that case it might be advisable to either redesign or carefully argue what the current design is and indicate why the nasty bits are really unavoidable.

This is infrastructure. We'll be living with this for a *long* time (see coercion framework). It's worth trying to get it right.



---

archive/issue_comments_109109.json:
```json
{
    "body": "<a id='comment:7'></a>\nLet me just remind you of the standard lore against using string contents for program flow: It makes it much harder to debug. Python, like pretty much any programming language, protects you from typos by raising errors at the parser stage. But if you encode information in the class name then no parser in the world is going to tell you whether you have a typo or not. Well-designed code may contstruct names from code, but getting code from names is a bad idea.",
    "created_at": "2014-01-07T19:21:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109109",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:7'></a>
Let me just remind you of the standard lore against using string contents for program flow: It makes it much harder to debug. Python, like pretty much any programming language, protects you from typos by raising errors at the parser stage. But if you encode information in the class name then no parser in the world is going to tell you whether you have a typo or not. Well-designed code may contstruct names from code, but getting code from names is a bad idea.



---

archive/issue_comments_109110.json:
```json
{
    "body": "<a id='comment:328'></a>\nReplying to [nbruin](#comment%3A326):\n> Nicholas has explained his original intent to a large degree in a post above and I mostly agree with him, except on one place. Apparently, in his model every category is constructed from a supercategory and an axiom. In that case there is no need for guessing data: all the data is there when the category gets constructed.\n\nI think it is two times \"no\".\n\n1. Some categories have no axiom.\n\n  ```\n  sage: Magmas.mro()\n  [sage.categories.magmas.Magmas,\n   sage.categories.category_singleton.Category_singleton,\n   sage.categories.category.Category,\n   sage.structure.unique_representation.UniqueRepresentation,\n   sage.structure.unique_representation.CachedRepresentation,\n   sage.misc.fast_methods.WithEqualityById,\n   sage.structure.sage_object.SageObject,\n   object]\n   ```\n   No axiom in it.\n\n2. If you look at `sage.categories.finite_permutation_groups.FinitePermutationGroups`, you'll find that this *is not* coded as the result of applying an axiom to a super-category. However, it *can* be constructed by applying an axiom to a super-category: The result will be the same.\n\n> I think it's crossing a line. Nowhere else in Python does the makeup of a name determine the inheritance of properties (which eventually categories will lead to). As Thierry points out, it's a heuristic one can avoid, but I think it departs so much from what Python normally does that it will frequently lead to confusion. I think you should look for a cleaner paradigm to express these relations concisely, and now is the time to get it right. It will be more painful to change it afterwards.\n\n+1\n\nWith the caveat that the code does sufficient tests to get the axioms right. These tests make it relatively robust, I think.\n\n> It doesn't sound to me like the category information forms a database in the sense of a bunch of tables filled with rows and columns. To me it seems closer to a (rooted?) tree,\n\nNo, it is not a tree. It is a digraph, with edges being labelled by axioms, and I guess one also has a poset structure. But certainly it is not a tree.\n\n> with edged labelled by axioms. Python has syntax to express rooted trees: inheritance. The only thing missing is the label. That can be replaced by a class attribute, simply set to a string. \n\nThis is what large parts of Nicolas' model does. However, since we don't have a tree, some complication arises.\n\n> There is a small amount of boilerplate involved with writing classes, e.g., one usually has to write `def __init__(self):`. Writing a single line `axiom = \"Finite\"` can be considered acceptable boilerplate in my opinion and removes all guessing. Do you think that having to write that \"Finite\" is redundancy because \"Finite\" already occurs in the `__name__`? In that case I disagree: everywhere in python people are free to choose names that they think are most informative (avoiding collisions and key words), regardless of semantics of the code.\n\n+1.\n\n> Replying to [SimonKing](#comment%3A311):\n> > So, questions to Nils:\n> > - Do you intend to handcode everything? Then you need to cover many cases.\n\n> \n> I may misunderstand what is required in the process, but at the moment I think \"yes\". If an axiom is a required property for a Category then it needs to be supplied somewhere, not derived by chopping a part of a `__name__`.\n\nOK, but it is quite some additional (and rather dull) work involved.\n \n> > - Do you intend to put `PermutationGroups().Finite()` into code that is executed at startup time, and similarly for *all* other categories with axiom? Then, the startup time would likely to increase, and it would not be less work than the other way to handcode the construction.\n\n> \n> You do not make that sound attractive.\n\nCorrect. It would increase startup time. By the way: Did the startup time improve after removing the deep recursion?\n\n> If the present patch unavoidably leads to convoluted constructs that that's a strong indication that the design is flawed. In that case it might be advisable to either redesign or carefully argue what the current design is and indicate why the nasty bits are really unavoidable.\n\nI think the design is good, robust and clear, but one implementation detail is flawed: I think you agree with me that a naming scheme is not the right tool to implement large parts of a digraph structure. It should better be hardcoded in what currently is a lazy class attribute---even though it is dull work to put it in.\n\n> This is infrastructure. We'll be living with this for a *long* time (see coercion framework). It's worth trying to get it right.\n\nI think the coercion framework isn't totally flawed either. And it is about digraphs, too...",
    "created_at": "2014-01-07T20:02:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109110",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:328'></a>
Replying to [nbruin](#comment%3A326):
> Nicholas has explained his original intent to a large degree in a post above and I mostly agree with him, except on one place. Apparently, in his model every category is constructed from a supercategory and an axiom. In that case there is no need for guessing data: all the data is there when the category gets constructed.

I think it is two times "no".

1. Some categories have no axiom.

  ```
  sage: Magmas.mro()
  [sage.categories.magmas.Magmas,
   sage.categories.category_singleton.Category_singleton,
   sage.categories.category.Category,
   sage.structure.unique_representation.UniqueRepresentation,
   sage.structure.unique_representation.CachedRepresentation,
   sage.misc.fast_methods.WithEqualityById,
   sage.structure.sage_object.SageObject,
   object]
   ```
   No axiom in it.

2. If you look at `sage.categories.finite_permutation_groups.FinitePermutationGroups`, you'll find that this *is not* coded as the result of applying an axiom to a super-category. However, it *can* be constructed by applying an axiom to a super-category: The result will be the same.

> I think it's crossing a line. Nowhere else in Python does the makeup of a name determine the inheritance of properties (which eventually categories will lead to). As Thierry points out, it's a heuristic one can avoid, but I think it departs so much from what Python normally does that it will frequently lead to confusion. I think you should look for a cleaner paradigm to express these relations concisely, and now is the time to get it right. It will be more painful to change it afterwards.

+1

With the caveat that the code does sufficient tests to get the axioms right. These tests make it relatively robust, I think.

> It doesn't sound to me like the category information forms a database in the sense of a bunch of tables filled with rows and columns. To me it seems closer to a (rooted?) tree,

No, it is not a tree. It is a digraph, with edges being labelled by axioms, and I guess one also has a poset structure. But certainly it is not a tree.

> with edged labelled by axioms. Python has syntax to express rooted trees: inheritance. The only thing missing is the label. That can be replaced by a class attribute, simply set to a string. 

This is what large parts of Nicolas' model does. However, since we don't have a tree, some complication arises.

> There is a small amount of boilerplate involved with writing classes, e.g., one usually has to write `def __init__(self):`. Writing a single line `axiom = "Finite"` can be considered acceptable boilerplate in my opinion and removes all guessing. Do you think that having to write that "Finite" is redundancy because "Finite" already occurs in the `__name__`? In that case I disagree: everywhere in python people are free to choose names that they think are most informative (avoiding collisions and key words), regardless of semantics of the code.

+1.

> Replying to [SimonKing](#comment%3A311):
> > So, questions to Nils:
> > - Do you intend to handcode everything? Then you need to cover many cases.

> 
> I may misunderstand what is required in the process, but at the moment I think "yes". If an axiom is a required property for a Category then it needs to be supplied somewhere, not derived by chopping a part of a `__name__`.

OK, but it is quite some additional (and rather dull) work involved.
 
> > - Do you intend to put `PermutationGroups().Finite()` into code that is executed at startup time, and similarly for *all* other categories with axiom? Then, the startup time would likely to increase, and it would not be less work than the other way to handcode the construction.

> 
> You do not make that sound attractive.

Correct. It would increase startup time. By the way: Did the startup time improve after removing the deep recursion?

> If the present patch unavoidably leads to convoluted constructs that that's a strong indication that the design is flawed. In that case it might be advisable to either redesign or carefully argue what the current design is and indicate why the nasty bits are really unavoidable.

I think the design is good, robust and clear, but one implementation detail is flawed: I think you agree with me that a naming scheme is not the right tool to implement large parts of a digraph structure. It should better be hardcoded in what currently is a lazy class attribute---even though it is dull work to put it in.

> This is infrastructure. We'll be living with this for a *long* time (see coercion framework). It's worth trying to get it right.

I think the coercion framework isn't totally flawed either. And it is about digraphs, too...



---

archive/issue_comments_109111.json:
```json
{
    "body": "<a id='comment:9'></a>\nConcerning startup time, I notice that with commit 5ccf253b17c151d8e773037ac634a64f84f03075 the startup_time plugin does not complain. And that commit is *before* we fixed the recursion problem. I was kicking the patchbot now, I hope we will soon get more relevant data.",
    "created_at": "2014-01-07T21:17:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109111",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Concerning startup time, I notice that with commit 5ccf253b17c151d8e773037ac634a64f84f03075 the startup_time plugin does not complain. And that commit is *before* we fixed the recursion problem. I was kicking the patchbot now, I hope we will soon get more relevant data.



---

archive/issue_comments_109112.json:
```json
{
    "body": "<a id='comment:0'></a>\nThanks guys for bringing in your different perspective!\n\nA couple comments:\n\n- We should leave the database discussion aside for now. It's just\n  going to pollute that thread which is already too long.\n\n- Nils is right in that the category *code* is indeed structured as a\n  tree. Of course, the inheritance diagram between the categories\n  forms an acyclic digraph.\n\n- The guessing is just about allowing for the shorthand\n  `FiniteDimensionalAlgebras(QQ) -> Algebras(QQ).FiniteDimensional()`\n\n  Those shorthands are mostly used interactively or for backward\n  compatibility.\n\n- The guessing does not prevent from using any name you like for your\n  class. But if you adhere to the standards, which is what you would\n  do naturally anyway most of the time, you get rewarded by some\n  syntactic sugar and don't have to write down redundant\n  information. I like the idea of encouraging people to follow the\n  standards.\n\n- In case there is a typo in the class name, you get an explicit error\n  the first time you try to create the category. So, assuming the\n  black magic is now reasonably robust (I believe so, but ...), the\n  issues should only pop up when creating a new category, and thus be\n  well localized and easy to debug.\n\n- By setting explicitly _base_category_and_axiom, you are putting in\n  information which is redundant with the reverse link from the base\n  category. For the above example, here are the two pieces of\n  information:\n\n  In Algebras:\n\n  ```\n      FiniteDimensional = LazyImport('sage.categories.finite_dimensional_algebras', 'FiniteDimensionalAlgebras')\n  ```\n\n  In FiniteDimensionalAlgebras:\n\n  ```\n      _base_category_and_axiom = [Algebras, \"FiniteDimensional\"]\n  ```\n\n  This violates the single point of truth and opens the door for\n  inconsistent information.  It also makes restructuring the code a\n  tiny bit be more brittle. Granted, it's not so bad since, in\n  principle, any such inconsistency will be detected and barked about\n  at runtime.\n\n- The act of not specifying _base_category_and_axiom is actually a\n  statement: ``this category is following the naming standards''. This\n  statement is used in the name building for category objects (see\n  _repr_object_names). Getting nice names for category objects is an\n  important feature that we will have to support one way or the other.\n\n- For the record, there is already some name mangling occurring in the\n  Sage code, e.g. for unpickling instances of nested classes, or for\n  compiling the documentation thereof with Sphinx. And of course in\n  repr for constructing the names of the objects of the categories;\n  but I agree that the latter is not as touchy since this only affects\n  the output, not the semantic.\n\n\nAltogether, I really don't like adding this redundant information\neverywhere. It feels to me as spreading dirt over my carefully crafted\nidioms :-) But I understand your being conservative after the bad bug\nthat hit us. And we need to move forward and get this done. If you\n*really* can't stand this guessing, go ahead, add the redundant\ninformation everywhere this is needed, and fix the implementation of\n_repr_object_names accordingly.\n\nIf instead you have a protocol in mind that avoids this redundant\ninformation without doing name mangling and while leaving the same\nflexibility in terms of code organization (in particular supporting to\nimplement a category with axioms either as a nested class or in a\nseparate file, typically lazy imported), I am all ear! But I converged\nto this protocol after three years of practical usage. I may of course\nhave missed something obvious but don't foresee myself finding some\nbetter protocol in the coming days.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-01-07T21:32:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109112",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:0'></a>
Thanks guys for bringing in your different perspective!

A couple comments:

- We should leave the database discussion aside for now. It's just
  going to pollute that thread which is already too long.

- Nils is right in that the category *code* is indeed structured as a
  tree. Of course, the inheritance diagram between the categories
  forms an acyclic digraph.

- The guessing is just about allowing for the shorthand
  `FiniteDimensionalAlgebras(QQ) -> Algebras(QQ).FiniteDimensional()`

  Those shorthands are mostly used interactively or for backward
  compatibility.

- The guessing does not prevent from using any name you like for your
  class. But if you adhere to the standards, which is what you would
  do naturally anyway most of the time, you get rewarded by some
  syntactic sugar and don't have to write down redundant
  information. I like the idea of encouraging people to follow the
  standards.

- In case there is a typo in the class name, you get an explicit error
  the first time you try to create the category. So, assuming the
  black magic is now reasonably robust (I believe so, but ...), the
  issues should only pop up when creating a new category, and thus be
  well localized and easy to debug.

- By setting explicitly _base_category_and_axiom, you are putting in
  information which is redundant with the reverse link from the base
  category. For the above example, here are the two pieces of
  information:

  In Algebras:

  ```
      FiniteDimensional = LazyImport('sage.categories.finite_dimensional_algebras', 'FiniteDimensionalAlgebras')
  ```

  In FiniteDimensionalAlgebras:

  ```
      _base_category_and_axiom = [Algebras, "FiniteDimensional"]
  ```

  This violates the single point of truth and opens the door for
  inconsistent information.  It also makes restructuring the code a
  tiny bit be more brittle. Granted, it's not so bad since, in
  principle, any such inconsistency will be detected and barked about
  at runtime.

- The act of not specifying _base_category_and_axiom is actually a
  statement: ``this category is following the naming standards''. This
  statement is used in the name building for category objects (see
  _repr_object_names). Getting nice names for category objects is an
  important feature that we will have to support one way or the other.

- For the record, there is already some name mangling occurring in the
  Sage code, e.g. for unpickling instances of nested classes, or for
  compiling the documentation thereof with Sphinx. And of course in
  repr for constructing the names of the objects of the categories;
  but I agree that the latter is not as touchy since this only affects
  the output, not the semantic.


Altogether, I really don't like adding this redundant information
everywhere. It feels to me as spreading dirt over my carefully crafted
idioms :-) But I understand your being conservative after the bad bug
that hit us. And we need to move forward and get this done. If you
*really* can't stand this guessing, go ahead, add the redundant
information everywhere this is needed, and fix the implementation of
_repr_object_names accordingly.

If instead you have a protocol in mind that avoids this redundant
information without doing name mangling and while leaving the same
flexibility in terms of code organization (in particular supporting to
implement a category with axioms either as a nested class or in a
separate file, typically lazy imported), I am all ear! But I converged
to this protocol after three years of practical usage. I may of course
have missed something obvious but don't foresee myself finding some
better protocol in the coming days.

Cheers,
                              Nicolas



---

archive/issue_comments_109113.json:
```json
{
    "body": "<a id='comment:331'></a>\nReplying to [nthiery](#comment%3A330):\n>   In Algebras:\n> \n>   ```\n>       FiniteDimensional = LazyImport('sage.categories.finite_dimensional_algebras', 'FiniteDimensionalAlgebras')\n>   ```\n> \n>   In FiniteDimensionalAlgebras:\n> \n>   ```\n>       _base_category_and_axiom = [Algebras, \"FiniteDimensional\"]\n>   ```\n\nRight. I was expecting something like that. The fact that each has to refer to the other is suspicious to me. What is the scenario that makes this absolutely necessary to be there right from the start? Wouldn't it be possible for there to be only one link? Perhaps when that link is actually exercised the other one can be put in place.\n\nMy default reaction would be that FiniteDimensionalAlgebras needs to know about Algebras because it needs to inherit the properties of Algebras, but is it absolutely necessary for Algebras to know about a FiniteDimensional version, even before it is instantiated? In general I expect the LazyImport to be a bad sign. LazyImports have trouble getting resolved in the first place. In fact, in the traceback that Volker produced, you can see there are is a LazyImport involved in the deep recursion, so I suspect that the LazyImport in this case indeed does not get cleared properly.\n\nMy default would be that `FiniteDimensionalAlgebras` only registers itself with `Algebras` when it gets instantiated, if that is necessary at all. That requires finding a solution for `Algebras().FiniteDimensional()` (is that how you call it?) when that happens before `FiniteDimensionalAlgebras` gets imported. Does that happen at all? If so, what's the scenario? Perhaps we can solve that scenario.\n\n(About the coercion framework: I do not intend to imply it's bad; it's just trying to solve a hard problem, and I know for a fact that the current iteration we have was very carefully designed, and certainly wasn't the first version that was tried.)",
    "created_at": "2014-01-07T23:17:06Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109113",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:331'></a>
Replying to [nthiery](#comment%3A330):
>   In Algebras:
> 
>   ```
>       FiniteDimensional = LazyImport('sage.categories.finite_dimensional_algebras', 'FiniteDimensionalAlgebras')
>   ```
> 
>   In FiniteDimensionalAlgebras:
> 
>   ```
>       _base_category_and_axiom = [Algebras, "FiniteDimensional"]
>   ```

Right. I was expecting something like that. The fact that each has to refer to the other is suspicious to me. What is the scenario that makes this absolutely necessary to be there right from the start? Wouldn't it be possible for there to be only one link? Perhaps when that link is actually exercised the other one can be put in place.

My default reaction would be that FiniteDimensionalAlgebras needs to know about Algebras because it needs to inherit the properties of Algebras, but is it absolutely necessary for Algebras to know about a FiniteDimensional version, even before it is instantiated? In general I expect the LazyImport to be a bad sign. LazyImports have trouble getting resolved in the first place. In fact, in the traceback that Volker produced, you can see there are is a LazyImport involved in the deep recursion, so I suspect that the LazyImport in this case indeed does not get cleared properly.

My default would be that `FiniteDimensionalAlgebras` only registers itself with `Algebras` when it gets instantiated, if that is necessary at all. That requires finding a solution for `Algebras().FiniteDimensional()` (is that how you call it?) when that happens before `FiniteDimensionalAlgebras` gets imported. Does that happen at all? If so, what's the scenario? Perhaps we can solve that scenario.

(About the coercion framework: I do not intend to imply it's bad; it's just trying to solve a hard problem, and I know for a fact that the current iteration we have was very carefully designed, and certainly wasn't the first version that was tried.)



---

archive/issue_comments_109114.json:
```json
{
    "body": "<a id='comment:332'></a>\nReplying to [nthiery](#comment%3A330):\n> - We should leave the database discussion aside for now. It's just\n>   going to pollute that thread which is already too long.\n\n+1. I said that we should get the correct logic into the code right now. But using a \"proper\" database is something for the future.\n\n> - Nils is right in that the category *code* is indeed structured as a\n>   tree.\n\nThat's why I said \"this is what large parts of Nicolas' model do\". But:\n\n> Of course, the inheritance diagram between the categories\n>   forms an acyclic digraph.\n\nYou explained to me that the categories being arranged in something that is not a tree gave you some headache. See \"`DivisionRings().Finite()==Fields().Finite()`\".\n=\n> - The guessing is just about allowing for the shorthand\n>   `FiniteDimensionalAlgebras(QQ) -> Algebras(QQ).FiniteDimensional()`\n> \n>   Those shorthands are mostly used interactively or for backward\n>   compatibility.\n\nAnd, as I have pointed out above, only 5 shorthands are used when Sage starts.\n\n> - In case there is a typo in the class name, you get an explicit error\n>   the first time you try to create the category. So, assuming the\n>   black magic is now reasonably robust (I believe so, but ...), the\n>   issues should only pop up when creating a new category, and thus be\n>   well localized and easy to debug.\n\n+1. I think it is important that the consistency tests take place, and I think they guarantee robustness of the code.\n\nI can't check the code right now; but didn't one of your last commits remove the \"assert\" statement that has originally triggered the recursion? I think after my commit, the assertion would not trigger a recursion, and it would perhaps be better to keep it in---unless you can point out that an equivalent consistency check is happening anyway.\n\n> - By setting explicitly _base_category_and_axiom, you are putting in\n>   information which is redundant with the reverse link from the base\n>   category. For the above example, here are the two pieces of\n>   information:\n> \n>   In Algebras:\n> \n>   ```\n>       FiniteDimensional = LazyImport('sage.categories.finite_dimensional_algebras', 'FiniteDimensionalAlgebras')\n>   ```\n> \n>   In FiniteDimensionalAlgebras:\n> \n>   ```\n>       _base_category_and_axiom = [Algebras, \"FiniteDimensional\"]\n>   ```\n> \n>   This violates the single point of truth and opens the door for\n>   inconsistent information.\n\nIn a digraph, it is useful that any node knows both the in-arrows and the\nout-arrows. So, the data structure should be so that both\n`Algebras.FiniteDimensional` and\n`FiniteDimensionalAlgebras._base_category_and_axiom` are available (and of\ncourse this is what your code provides.\n\nHowever, it would indeed be nice to have a single point of truth. I believe\nthat this single point of truth should (in FUTURE!!) not be the naming scheme,\nbut a database. You'd register the fact that `MyNiceCategory` is obtained\nfrom `MyUglyCategory` by adding the axiom `Makeup` in the database, and the\ndatabase would automatically add the relevant information both to\n`MyNiceCategory` and to `MyUglyCategory`.\n\n> - The act of not specifying _base_category_and_axiom is actually a\n>   statement: ``this category is following the naming standards''. This\n>   statement is used in the name building for category objects (see\n>   _repr_object_names). Getting nice names for category objects is an\n>   important feature that we will have to support one way or the other.\n\n+1. I'd find it annoying to override `_repr_object_names` whenever\nimplementing a new category.\n\n> Altogether, I really don't like adding this redundant information\n> everywhere. It feels to me as spreading dirt over my carefully crafted\n> idioms :-)\n\nI agree that it would be annoying to add the same info in two places.\n\n> If instead you have a protocol in mind that avoids this redundant\n> information without doing name mangling and while leaving the same\n> flexibility in terms of code organization (in particular supporting to\n> implement a category with axioms either as a nested class or in a\n> separate file, typically lazy imported), I am all ear!\n\nLet's try...\n\nConsider the `DivisionRings().Finite()==Fields().Finite()==FiniteFields()`\nexample. My Sage version is on a different branch now, but I hope it is correct\nthat `FiniteFields._base_category_class_and_axiom==(Fields, 'Finite')`. Hence, `FiniteFields()` knows one possible way of being\nconstructed. The other possible way is encoded in\n`DivisionRings.Finite_extra_super_categories`. In addition to that, we have\n`Fields.Finite=FiniteFields` (lazily imported).\n\nIt seems evident to me that each category-with-axiom should know one (namely\nthe default) way of construction, as encoded in\n`_base_category_class_and_axiom`---either hardcoded or encoded in the class\nname. In the example, mathematics forces us to encode a second way of\nconstruction, namely `DivisionRings.Finite_extra_super_categories`. However,\nwhy should we additionally hardcode `Fields.Finite=FiniteFields`, as this\ninformation is already encoded in `FiniteFields`?\n\nCouldn't a database do the job? If I am not mistaken, there are databases that\ncan not only store items (here: Category classes), but also relations between\nitems (here: Construction of a category by applying an axiom). Hence, the\ndatabase knows the default construction of `FiniteFields()` (in particular, it\nknows that it involves `Fields()`), and it knows an additional construction of\n`FiniteFields()` (namely starting with `DivisionRings()`).\n\nRegistering default and additional constructions into the database would be\nyour \"single point of truth\".\n\nIt would be possible to have the database act as a metaclass for\n`CategoryWithAxioms`. Hence, *during creation of a category class `cls`*,\nthe database would be called, and could certainly be made to look up\n- the default construction of `cls`, registering it in `cls._base_category_class_and_axiom`\n- any known construction starting with `cls`, registering it in lazily imported class attributes (similar to `Fields.Finite` and some attribute of `DivisionRings`).\n\nTo summarise my suggestion (again: For the future, not for now):\n\n- Have a database that acts as metaclass of `CategoryWithAxiom`\n- As a single point of truth, constructions are registered in the database.\n- Of course, the database is stored, and loaded at startup of Sage. Note that\n  the database knows where to find the category classes---it is *not* the case\n  that loading the database implies loading all possible category classes\n  during startup!!\n- When being asked to return a category class `cls`, the metaclass (=the\n  database) would handle the incoming and outgoing constructions of `cls`---lazily.\n- It is possible to register further constructions into the database in an\n  interactive session.\n\nSo, we'd have flexibility/interactivity, no name mangling, lazy imports, and a\nsingle point of truth.",
    "created_at": "2014-01-07T23:41:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109114",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:332'></a>
Replying to [nthiery](#comment%3A330):
> - We should leave the database discussion aside for now. It's just
>   going to pollute that thread which is already too long.

+1. I said that we should get the correct logic into the code right now. But using a "proper" database is something for the future.

> - Nils is right in that the category *code* is indeed structured as a
>   tree.

That's why I said "this is what large parts of Nicolas' model do". But:

> Of course, the inheritance diagram between the categories
>   forms an acyclic digraph.

You explained to me that the categories being arranged in something that is not a tree gave you some headache. See "`DivisionRings().Finite()==Fields().Finite()`".
=
> - The guessing is just about allowing for the shorthand
>   `FiniteDimensionalAlgebras(QQ) -> Algebras(QQ).FiniteDimensional()`
> 
>   Those shorthands are mostly used interactively or for backward
>   compatibility.

And, as I have pointed out above, only 5 shorthands are used when Sage starts.

> - In case there is a typo in the class name, you get an explicit error
>   the first time you try to create the category. So, assuming the
>   black magic is now reasonably robust (I believe so, but ...), the
>   issues should only pop up when creating a new category, and thus be
>   well localized and easy to debug.

+1. I think it is important that the consistency tests take place, and I think they guarantee robustness of the code.

I can't check the code right now; but didn't one of your last commits remove the "assert" statement that has originally triggered the recursion? I think after my commit, the assertion would not trigger a recursion, and it would perhaps be better to keep it in---unless you can point out that an equivalent consistency check is happening anyway.

> - By setting explicitly _base_category_and_axiom, you are putting in
>   information which is redundant with the reverse link from the base
>   category. For the above example, here are the two pieces of
>   information:
> 
>   In Algebras:
> 
>   ```
>       FiniteDimensional = LazyImport('sage.categories.finite_dimensional_algebras', 'FiniteDimensionalAlgebras')
>   ```
> 
>   In FiniteDimensionalAlgebras:
> 
>   ```
>       _base_category_and_axiom = [Algebras, "FiniteDimensional"]
>   ```
> 
>   This violates the single point of truth and opens the door for
>   inconsistent information.

In a digraph, it is useful that any node knows both the in-arrows and the
out-arrows. So, the data structure should be so that both
`Algebras.FiniteDimensional` and
`FiniteDimensionalAlgebras._base_category_and_axiom` are available (and of
course this is what your code provides.

However, it would indeed be nice to have a single point of truth. I believe
that this single point of truth should (in FUTURE!!) not be the naming scheme,
but a database. You'd register the fact that `MyNiceCategory` is obtained
from `MyUglyCategory` by adding the axiom `Makeup` in the database, and the
database would automatically add the relevant information both to
`MyNiceCategory` and to `MyUglyCategory`.

> - The act of not specifying _base_category_and_axiom is actually a
>   statement: ``this category is following the naming standards''. This
>   statement is used in the name building for category objects (see
>   _repr_object_names). Getting nice names for category objects is an
>   important feature that we will have to support one way or the other.

+1. I'd find it annoying to override `_repr_object_names` whenever
implementing a new category.

> Altogether, I really don't like adding this redundant information
> everywhere. It feels to me as spreading dirt over my carefully crafted
> idioms :-)

I agree that it would be annoying to add the same info in two places.

> If instead you have a protocol in mind that avoids this redundant
> information without doing name mangling and while leaving the same
> flexibility in terms of code organization (in particular supporting to
> implement a category with axioms either as a nested class or in a
> separate file, typically lazy imported), I am all ear!

Let's try...

Consider the `DivisionRings().Finite()==Fields().Finite()==FiniteFields()`
example. My Sage version is on a different branch now, but I hope it is correct
that `FiniteFields._base_category_class_and_axiom==(Fields, 'Finite')`. Hence, `FiniteFields()` knows one possible way of being
constructed. The other possible way is encoded in
`DivisionRings.Finite_extra_super_categories`. In addition to that, we have
`Fields.Finite=FiniteFields` (lazily imported).

It seems evident to me that each category-with-axiom should know one (namely
the default) way of construction, as encoded in
`_base_category_class_and_axiom`---either hardcoded or encoded in the class
name. In the example, mathematics forces us to encode a second way of
construction, namely `DivisionRings.Finite_extra_super_categories`. However,
why should we additionally hardcode `Fields.Finite=FiniteFields`, as this
information is already encoded in `FiniteFields`?

Couldn't a database do the job? If I am not mistaken, there are databases that
can not only store items (here: Category classes), but also relations between
items (here: Construction of a category by applying an axiom). Hence, the
database knows the default construction of `FiniteFields()` (in particular, it
knows that it involves `Fields()`), and it knows an additional construction of
`FiniteFields()` (namely starting with `DivisionRings()`).

Registering default and additional constructions into the database would be
your "single point of truth".

It would be possible to have the database act as a metaclass for
`CategoryWithAxioms`. Hence, *during creation of a category class `cls`*,
the database would be called, and could certainly be made to look up
- the default construction of `cls`, registering it in `cls._base_category_class_and_axiom`
- any known construction starting with `cls`, registering it in lazily imported class attributes (similar to `Fields.Finite` and some attribute of `DivisionRings`).

To summarise my suggestion (again: For the future, not for now):

- Have a database that acts as metaclass of `CategoryWithAxiom`
- As a single point of truth, constructions are registered in the database.
- Of course, the database is stored, and loaded at startup of Sage. Note that
  the database knows where to find the category classes---it is *not* the case
  that loading the database implies loading all possible category classes
  during startup!!
- When being asked to return a category class `cls`, the metaclass (=the
  database) would handle the incoming and outgoing constructions of `cls`---lazily.
- It is possible to register further constructions into the database in an
  interactive session.

So, we'd have flexibility/interactivity, no name mangling, lazy imports, and a
single point of truth.



---

archive/issue_comments_109115.json:
```json
{
    "body": "<a id='comment:333'></a>\nReplying to [nbruin](#comment%3A331):\n> Right. I was expecting something like that. The fact that each has to refer to the other is suspicious to me.\n\n+1.\n\n> What is the scenario that makes this absolutely necessary to be there right from the start? Wouldn't it be possible for there to be only one link? Perhaps when that link is actually exercised the other one can be put in place.\n\nYou can not know what end of the link will be called first. The user could\nfirst do `FinitePermutationGroups()`, or `PermutationGroups().Finite()`. You\nhave no way to know what will happen first. Of course, you can make it so that\nstarting with one end of the link will make the other and of the link\nwork. But you don't know at what end you start and thus need to implement\n*both* directions of the link.\n\n... unless you forget to think about the *ends* of the link, and start thinking about\nthe *link* itself---and make it so that any attempt to access either end of\nthe link will use the information that is stored in the link (see the\nsuggestion in my previous post).\n\n> My default reaction would be that FiniteDimensionalAlgebras needs to know about Algebras because it needs to inherit the properties of Algebras, but is it absolutely necessary for Algebras to know about a FiniteDimensional version, even before it is instantiated?\n\nI think so.\n\n> My default would be that `FiniteDimensionalAlgebras` only registers itself with `Algebras` when it gets instantiated, if that is necessary at all. That requires finding a solution for `Algebras().FiniteDimensional()` (is that how you call it?) when that happens before `FiniteDimensionalAlgebras` gets imported. Does that happen at all?\n\nSure. This is the default scenario.",
    "created_at": "2014-01-07T23:51:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109115",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:333'></a>
Replying to [nbruin](#comment%3A331):
> Right. I was expecting something like that. The fact that each has to refer to the other is suspicious to me.

+1.

> What is the scenario that makes this absolutely necessary to be there right from the start? Wouldn't it be possible for there to be only one link? Perhaps when that link is actually exercised the other one can be put in place.

You can not know what end of the link will be called first. The user could
first do `FinitePermutationGroups()`, or `PermutationGroups().Finite()`. You
have no way to know what will happen first. Of course, you can make it so that
starting with one end of the link will make the other and of the link
work. But you don't know at what end you start and thus need to implement
*both* directions of the link.

... unless you forget to think about the *ends* of the link, and start thinking about
the *link* itself---and make it so that any attempt to access either end of
the link will use the information that is stored in the link (see the
suggestion in my previous post).

> My default reaction would be that FiniteDimensionalAlgebras needs to know about Algebras because it needs to inherit the properties of Algebras, but is it absolutely necessary for Algebras to know about a FiniteDimensional version, even before it is instantiated?

I think so.

> My default would be that `FiniteDimensionalAlgebras` only registers itself with `Algebras` when it gets instantiated, if that is necessary at all. That requires finding a solution for `Algebras().FiniteDimensional()` (is that how you call it?) when that happens before `FiniteDimensionalAlgebras` gets imported. Does that happen at all?

Sure. This is the default scenario.



---

archive/issue_comments_109116.json:
```json
{
    "body": "<a id='comment:334'></a>\nReplying to [darij](#comment%3A325):\n> Also, I suspect this to be a typo:\n> \n> ```\n> + class Unital(CategoryWithAxiom):\n> +\n> + class SubcategoryMethods:\n> +\n> + @cached_method\n> + def Inverse(self):\n> + r\"\"\"\n> + Returns the full subcategory of the unital objects of ``self``.\n> +\n> + EXAMPLES::\n> +\n> + sage: Magmas().Unital().Inverse()\n> + Category of inverse unital magmas\n> + sage: Monoids().Inverse()\n> + Category of groups\n> ```\n> Should be the full subcategory of the *inverse*, not the unital, objects of self.\n\nThanks for spotting this. Fixed and pushed!",
    "created_at": "2014-01-08T00:52:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109116",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:334'></a>
Replying to [darij](#comment%3A325):
> Also, I suspect this to be a typo:
> 
> ```
> + class Unital(CategoryWithAxiom):
> +
> + class SubcategoryMethods:
> +
> + @cached_method
> + def Inverse(self):
> + r"""
> + Returns the full subcategory of the unital objects of ``self``.
> +
> + EXAMPLES::
> +
> + sage: Magmas().Unital().Inverse()
> + Category of inverse unital magmas
> + sage: Monoids().Inverse()
> + Category of groups
> ```
> Should be the full subcategory of the *inverse*, not the unital, objects of self.

Thanks for spotting this. Fixed and pushed!



---

archive/issue_comments_109117.json:
```json
{
    "body": "**Changing commit** from \"[478de48553d203516cddb47e0cb89c34ccc210ee](https://github.com/sagemath/sagetrac-mirror/commit/478de48553d203516cddb47e0cb89c34ccc210ee)\" to \"[dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c](https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c)\".",
    "created_at": "2014-01-08T00:54:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109117",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[478de48553d203516cddb47e0cb89c34ccc210ee](https://github.com/sagemath/sagetrac-mirror/commit/478de48553d203516cddb47e0cb89c34ccc210ee)" to "[dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c](https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c)".



---

archive/issue_comments_109118.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c\">dbb17b1</a></td><td><code>Fixed typo and improved documentation for Magmas.Unital.Inverse</code></td></tr></table>\n",
    "created_at": "2014-01-08T00:54:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109118",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c">dbb17b1</a></td><td><code>Fixed typo and improved documentation for Magmas.Unital.Inverse</code></td></tr></table>




---

archive/issue_comments_109119.json:
```json
{
    "body": "<a id='comment:336'></a>\nHi Darij,\n\n> I know this is not a big issue since the `dual()` of an algebra *is* a coalgebra in all cases in which `dual()` is implemented (not least because in the infinite-dimensional cases it usually means the graded dual). But I'm still unhappy with the docstring lying in my face. Can anyone write a reasonably worded .. WARNING about this `dual()` not being the actual vector-space dual?\n\nYes, we need to clean up the distinction between dual and graded dual;\nthis is not completely obvious to set the things up so that we can\nstill share some code between the two. But this issue predates this\nticket: the code and documentation about dual objects is just being\nmoved around. Please create a separate ticket about this!\n\nCheers,\n                            Nicolas\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c\">dbb17b1</a></td><td><code>Fixed typo and improved documentation for Magmas.Unital.Inverse</code></td></tr></table>\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c\">dbb17b1</a></td><td><code>Fixed typo and improved documentation for Magmas.Unital.Inverse</code></td></tr></table>\n",
    "created_at": "2014-01-08T00:59:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109119",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:336'></a>
Hi Darij,

> I know this is not a big issue since the `dual()` of an algebra *is* a coalgebra in all cases in which `dual()` is implemented (not least because in the infinite-dimensional cases it usually means the graded dual). But I'm still unhappy with the docstring lying in my face. Can anyone write a reasonably worded .. WARNING about this `dual()` not being the actual vector-space dual?

Yes, we need to clean up the distinction between dual and graded dual;
this is not completely obvious to set the things up so that we can
still share some code between the two. But this issue predates this
ticket: the code and documentation about dual objects is just being
moved around. Please create a separate ticket about this!

Cheers,
                            Nicolas

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c">dbb17b1</a></td><td><code>Fixed typo and improved documentation for Magmas.Unital.Inverse</code></td></tr></table>

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c">dbb17b1</a></td><td><code>Fixed typo and improved documentation for Magmas.Unital.Inverse</code></td></tr></table>




---

archive/issue_comments_109120.json:
```json
{
    "body": "<a id='comment:337'></a>\nReplying to [nbruin](#comment%3A331):\n> Replying to [nthiery](#comment%3A330):\n> Right. I was expecting something like that. The fact that each has to refer to the other is suspicious to me. What is the scenario that makes this absolutely necessary to be there right from the start? Wouldn't it be possible for there to be only one link? Perhaps when that link is actually exercised the other one can be put in place.\n> \n> My default reaction would be that FiniteDimensionalAlgebras needs to know about Algebras because it needs to inherit the properties of Algebras, but is it absolutely necessary for Algebras to know about a FiniteDimensional version, even before it is instantiated? In general I expect the LazyImport to be a bad sign. LazyImports have trouble getting resolved in the first place. In fact, in the traceback that Volker produced, you can see there are is a LazyImport involved in the deep recursion, so I suspect that the LazyImport in this case indeed does not get cleared properly.\n> \n\n> My default would be that `FiniteDimensionalAlgebras` only registers itself with `Algebras` when it gets instantiated, if that is necessary at all. That requires finding a solution for `Algebras().FiniteDimensional()` (is that how you call it?) when that happens before `FiniteDimensionalAlgebras` gets imported. Does that happen at all? If so, what's the scenario? Perhaps we can solve that scenario.\n\nAs pointed by Simon, `Algebras().FiniteDimensional()` is usually\nthe default scenario. And it was an important design goal for me that\nimporting Algebras did not trigger the import of all its axiom\nsubcategories, because there can be many. For example, with my\nupcoming patch on semigroups, I would not want that importing\nsemigroups (which is done at startup time) would trigger the import of\nthe categories of respectively LTrivial, RTrivial, JTrivial, DTrivial,\nHTrivial, and Band semigroups, and their finite variants, since those\nare only relevant to a small public.\n\nThe reverse scenario (where FiniteDimensionalAlgebras is called first)\nis not as important but still is a nice and natural feature. One would\nnot usually think of using `DivisionRings().Commutative()` for\n`Fields()` :-)\n\nWe could think of FiniteDimensionalAlgebras triggering the import of\nAlgebra, with some magic to put in place the link in\nFiniteDimensionalAlgebras from that in Algebra. But it sounds to me\nthat this logic would be somewhat more complicated (searching through\nthe code to get the link) and not necessarily more robust than the\ncurrent name mangling.\n\nCheers,\n                           Nicolas",
    "created_at": "2014-01-08T01:24:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109120",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:337'></a>
Replying to [nbruin](#comment%3A331):
> Replying to [nthiery](#comment%3A330):
> Right. I was expecting something like that. The fact that each has to refer to the other is suspicious to me. What is the scenario that makes this absolutely necessary to be there right from the start? Wouldn't it be possible for there to be only one link? Perhaps when that link is actually exercised the other one can be put in place.
> 
> My default reaction would be that FiniteDimensionalAlgebras needs to know about Algebras because it needs to inherit the properties of Algebras, but is it absolutely necessary for Algebras to know about a FiniteDimensional version, even before it is instantiated? In general I expect the LazyImport to be a bad sign. LazyImports have trouble getting resolved in the first place. In fact, in the traceback that Volker produced, you can see there are is a LazyImport involved in the deep recursion, so I suspect that the LazyImport in this case indeed does not get cleared properly.
> 

> My default would be that `FiniteDimensionalAlgebras` only registers itself with `Algebras` when it gets instantiated, if that is necessary at all. That requires finding a solution for `Algebras().FiniteDimensional()` (is that how you call it?) when that happens before `FiniteDimensionalAlgebras` gets imported. Does that happen at all? If so, what's the scenario? Perhaps we can solve that scenario.

As pointed by Simon, `Algebras().FiniteDimensional()` is usually
the default scenario. And it was an important design goal for me that
importing Algebras did not trigger the import of all its axiom
subcategories, because there can be many. For example, with my
upcoming patch on semigroups, I would not want that importing
semigroups (which is done at startup time) would trigger the import of
the categories of respectively LTrivial, RTrivial, JTrivial, DTrivial,
HTrivial, and Band semigroups, and their finite variants, since those
are only relevant to a small public.

The reverse scenario (where FiniteDimensionalAlgebras is called first)
is not as important but still is a nice and natural feature. One would
not usually think of using `DivisionRings().Commutative()` for
`Fields()` :-)

We could think of FiniteDimensionalAlgebras triggering the import of
Algebra, with some magic to put in place the link in
FiniteDimensionalAlgebras from that in Algebra. But it sounds to me
that this logic would be somewhat more complicated (searching through
the code to get the link) and not necessarily more robust than the
current name mangling.

Cheers,
                           Nicolas



---

archive/issue_comments_109121.json:
```json
{
    "body": "<a id='comment:338'></a>\nReplying to [SimonKing](#comment%3A332):\n> +1. I think it is important that the consistency tests take place, and I think they guarantee robustness of the code.\n> \n> I can't check the code right now; but didn't one of your last commits remove the \"assert\" statement that has originally triggered the recursion? I think after my commit, the assertion would not trigger a recursion, and it would perhaps be better to keep it in---unless you can point out that an equivalent consistency check is happening anyway.\n\nMy commit removed the assertion enforcing that the axiom category\nclass itself had to be in a standard location. On the other hand, the\nassertion about the consistency of links is still there (line 262).\n\nCheers,\n                               Nicolas",
    "created_at": "2014-01-08T01:31:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109121",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:338'></a>
Replying to [SimonKing](#comment%3A332):
> +1. I think it is important that the consistency tests take place, and I think they guarantee robustness of the code.
> 
> I can't check the code right now; but didn't one of your last commits remove the "assert" statement that has originally triggered the recursion? I think after my commit, the assertion would not trigger a recursion, and it would perhaps be better to keep it in---unless you can point out that an equivalent consistency check is happening anyway.

My commit removed the assertion enforcing that the axiom category
class itself had to be in a standard location. On the other hand, the
assertion about the consistency of links is still there (line 262).

Cheers,
                               Nicolas



---

archive/issue_comments_109122.json:
```json
{
    "body": "<a id='comment:9'></a>\nFor the record: all long tests passed for me.",
    "created_at": "2014-01-08T07:42:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109122",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:9'></a>
For the record: all long tests passed for me.



---

archive/issue_comments_109123.json:
```json
{
    "body": "<a id='comment:0'></a>\nI have to think about your explanation. I have a hunch there's a problem with it but as long as I cannot point it out explicitly I cannot really object.\n\nIndependently, the lazy import indeed doesn't seem to clear properly, as was indicated by the tracebacks above already. With\n\n```diff\ndiff --git a/src/sage/misc/lazy_import.pyx b/src/sage/misc/lazy_import.pyx\nindex 051a99b..2b96582 100644\n--- a/src/sage/misc/lazy_import.pyx\n+++ b/src/sage/misc/lazy_import.pyx\n@@ -480,6 +480,7 @@ cdef class LazyImport(object):\n         documentation of :meth:`_get_object` for an explanation of\n         this.\n         \"\"\"\n+        print \"lazy_import.__get__(%s,%s,%s)\"%(self, instance, owner)\n         obj = self._get_object(owner=owner)\n         if hasattr(obj, \"__get__\"):\n             return obj.__get__(instance, owner)\n```\nI get:\n\n```\nsage: Algebras(GF(13))\nlazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\nlazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)\nlazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\nCategory of algebras over Finite Field of size 13\nsage: Algebras(GF(5))\nlazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\nlazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)\nlazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\nCategory of algebras over Finite Field of size 5\nsage: Algebras(GF(7))\nlazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\nlazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)\nlazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\nCategory of algebras over Finite Field of size 7\n```\nAfter the first call, all the lazy importing should have happened already, so subsequent invocations shouldn't have a lazy_import in between any more. I suspect that this happens because there is a lazy import object somewhere that doesn't get replaced by the reference to the actual object once it gets loaded. This is a known issue: lazy_importing objects from modules doesn't actually work very well (lazy importing modules and then referring to an object in the module works better, if I'm not mistaken).\n\nSo, you should probably not use lazy import for this but rather do it manually: just keep the string first and do an actual import, replacing the string, once you really need the object.",
    "created_at": "2014-01-08T07:58:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109123",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:0'></a>
I have to think about your explanation. I have a hunch there's a problem with it but as long as I cannot point it out explicitly I cannot really object.

Independently, the lazy import indeed doesn't seem to clear properly, as was indicated by the tracebacks above already. With

```diff
diff --git a/src/sage/misc/lazy_import.pyx b/src/sage/misc/lazy_import.pyx
index 051a99b..2b96582 100644
--- a/src/sage/misc/lazy_import.pyx
+++ b/src/sage/misc/lazy_import.pyx
@@ -480,6 +480,7 @@ cdef class LazyImport(object):
         documentation of :meth:`_get_object` for an explanation of
         this.
         """
+        print "lazy_import.__get__(%s,%s,%s)"%(self, instance, owner)
         obj = self._get_object(owner=owner)
         if hasattr(obj, "__get__"):
             return obj.__get__(instance, owner)
```
I get:

```
sage: Algebras(GF(13))
lazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
lazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)
lazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
Category of algebras over Finite Field of size 13
sage: Algebras(GF(5))
lazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
lazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)
lazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
Category of algebras over Finite Field of size 5
sage: Algebras(GF(7))
lazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
lazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)
lazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
Category of algebras over Finite Field of size 7
```
After the first call, all the lazy importing should have happened already, so subsequent invocations shouldn't have a lazy_import in between any more. I suspect that this happens because there is a lazy import object somewhere that doesn't get replaced by the reference to the actual object once it gets loaded. This is a known issue: lazy_importing objects from modules doesn't actually work very well (lazy importing modules and then referring to an object in the module works better, if I'm not mistaken).

So, you should probably not use lazy import for this but rather do it manually: just keep the string first and do an actual import, replacing the string, once you really need the object.



---

archive/issue_comments_109124.json:
```json
{
    "body": "<a id='comment:1'></a>\nHelloooo guys !\n\nI was reading the modifications that this branch makes to code I care for, and I read the following in `posets.py`\n\n```\n         sage: Q = Poset(DiGraph({'a':['b'],'b':['c'],'c':['d']}), facade = True)\n         sage: Q.category()\n-        Category of facade finite posets\n+        Join of Category of finite posets\n+            and Category of finite enumerated sets\n+            and Category of facade sets\n```\n\nWell. Isn't a finite poset always an enumerated set too ? And so why do the two appear ? Besides, if I can suspect what the mathematical meaning of \"posets\" and \"enumerated sets\" is, is \"facade sets\" really a mathematical category, or just a programming trick ? Thus should it be a category ?\n\nIt would be cool (=necessary) to have an index somewhere of all categories used in Sage (let's say in our own code/doctests) with an explanation of what they mean. Especially if their meaning is non-mathematical, and so possibly not documented in textbooks.\n\nNathann",
    "created_at": "2014-01-08T09:31:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109124",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:1'></a>
Helloooo guys !

I was reading the modifications that this branch makes to code I care for, and I read the following in `posets.py`

```
         sage: Q = Poset(DiGraph({'a':['b'],'b':['c'],'c':['d']}), facade = True)
         sage: Q.category()
-        Category of facade finite posets
+        Join of Category of finite posets
+            and Category of finite enumerated sets
+            and Category of facade sets
```

Well. Isn't a finite poset always an enumerated set too ? And so why do the two appear ? Besides, if I can suspect what the mathematical meaning of "posets" and "enumerated sets" is, is "facade sets" really a mathematical category, or just a programming trick ? Thus should it be a category ?

It would be cool (=necessary) to have an index somewhere of all categories used in Sage (let's say in our own code/doctests) with an explanation of what they mean. Especially if their meaning is non-mathematical, and so possibly not documented in textbooks.

Nathann



---

archive/issue_comments_109125.json:
```json
{
    "body": "<a id='comment:342'></a>\nHi Nathann,\n\nReplying to [ncohen](#comment%3A341):\n> I was reading the modifications that this branch makes to code I care for, and I read the following in `posets.py`\n> \n> ```\n>          sage: Q = Poset(DiGraph({'a':['b'],'b':['c'],'c':['d']}), facade = True)\n>          sage: Q.category()\n> -        Category of facade finite posets\n> +        Join of Category of finite posets\n> +            and Category of finite enumerated sets\n> +            and Category of facade sets\n> ```\n> \n\n> Well. Isn't a finite poset always an enumerated set too?\n\nWith our current implementation FinitePoset, yes. But in general we\nwill eventually want to implement other posets were you can do poset\noperations on the elements without necessarily having an algorithm to\ngenerate them all.\n\nIn practice, for FinitePoset only the output of the category changes;\nthe categories and thus the features are the same as before.\n\n> is \"facade sets\" really a mathematical category, or just a programming trick? Thus should it be a category ?\n\nIt's indeed technical. But that's ok: the category infrastructure is\nnot necessarily only about mathematical categories. In fact other\nsystems like Axiom go much further into using technical categories.\nSee: http://www.axiom-developer.org/axiom-website/bookvol10.2full.html\n\n> It would be cool (=necessary) to have an index somewhere of all categories used in Sage (let's say in our own code/doctests) with an explanation of what they mean. Especially if their meaning is non-mathematical, and so possibly not documented in textbooks.\n\nThere it is, and there is even documentation about facades :-)\n\nhttp://www.sagemath.org/doc/reference/categories/index.html\n\nCheers,\n                              Nicolas",
    "created_at": "2014-01-08T10:13:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109125",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:342'></a>
Hi Nathann,

Replying to [ncohen](#comment%3A341):
> I was reading the modifications that this branch makes to code I care for, and I read the following in `posets.py`
> 
> ```
>          sage: Q = Poset(DiGraph({'a':['b'],'b':['c'],'c':['d']}), facade = True)
>          sage: Q.category()
> -        Category of facade finite posets
> +        Join of Category of finite posets
> +            and Category of finite enumerated sets
> +            and Category of facade sets
> ```
> 

> Well. Isn't a finite poset always an enumerated set too?

With our current implementation FinitePoset, yes. But in general we
will eventually want to implement other posets were you can do poset
operations on the elements without necessarily having an algorithm to
generate them all.

In practice, for FinitePoset only the output of the category changes;
the categories and thus the features are the same as before.

> is "facade sets" really a mathematical category, or just a programming trick? Thus should it be a category ?

It's indeed technical. But that's ok: the category infrastructure is
not necessarily only about mathematical categories. In fact other
systems like Axiom go much further into using technical categories.
See: http://www.axiom-developer.org/axiom-website/bookvol10.2full.html

> It would be cool (=necessary) to have an index somewhere of all categories used in Sage (let's say in our own code/doctests) with an explanation of what they mean. Especially if their meaning is non-mathematical, and so possibly not documented in textbooks.

There it is, and there is even documentation about facades :-)

http://www.sagemath.org/doc/reference/categories/index.html

Cheers,
                              Nicolas



---

archive/issue_comments_109126.json:
```json
{
    "body": "<a id='comment:343'></a>\nYooooooo !!\n\n> With our current implementation FinitePoset, yes. But in general we\n> will eventually want to implement other posets were you can do poset\n> operations on the elements without necessarily having an algorithm to\n> generate them all.\n\nOh. Okayyyyyyyyyyyy.\n\n> It's indeed technical. But that's ok: the category infrastructure is\n> not necessarily only about mathematical categories. In fact other\n> systems like Axiom go much further into using technical categories.\n> See: http://www.axiom-developer.org/axiom-website/bookvol10.2full.html\n> \n> There it is, and there is even documentation about facades :-)\n\nExcellent ! THaaaaaaaaaaanks !!\n\nNathann",
    "created_at": "2014-01-08T10:17:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109126",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:343'></a>
Yooooooo !!

> With our current implementation FinitePoset, yes. But in general we
> will eventually want to implement other posets were you can do poset
> operations on the elements without necessarily having an algorithm to
> generate them all.

Oh. Okayyyyyyyyyyyy.

> It's indeed technical. But that's ok: the category infrastructure is
> not necessarily only about mathematical categories. In fact other
> systems like Axiom go much further into using technical categories.
> See: http://www.axiom-developer.org/axiom-website/bookvol10.2full.html
> 
> There it is, and there is even documentation about facades :-)

Excellent ! THaaaaaaaaaaanks !!

Nathann



---

archive/issue_comments_109127.json:
```json
{
    "body": "<a id='comment:344'></a>\nReplying to [nbruin](#comment%3A340):\n> Independently, the lazy import indeed doesn't seem to clear properly, as was indicated by the tracebacks above already.> I get:\n> \n> ```\n> sage: Algebras(GF(13))\n> lazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\n> lazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)\n> lazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\n> Category of algebras over Finite Field of size 13\n> sage: Algebras(GF(5))\n> lazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\n> lazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)\n> lazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\n> Category of algebras over Finite Field of size 5\n> sage: Algebras(GF(7))\n> lazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\n> lazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)\n> lazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)\n> Category of algebras over Finite Field of size 7\n> ```\n\nObvious solution: Replace\n\n```\n    Finite = LazyImport('...')\n```\nby\n\n```\n    @lazy_class_attribute\n    def Finite(cls):\n        from ... import ...\n        return ...\n```\nThen, the import would happen *only* when the lazy class attribute is invoked. Afterwards, the lazy class attribute is replaced by an actual class attribute, hence, the import won't happen again.",
    "created_at": "2014-01-08T11:09:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109127",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:344'></a>
Replying to [nbruin](#comment%3A340):
> Independently, the lazy import indeed doesn't seem to clear properly, as was indicated by the tracebacks above already.> I get:
> 
> ```
> sage: Algebras(GF(13))
> lazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
> lazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)
> lazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
> Category of algebras over Finite Field of size 13
> sage: Algebras(GF(5))
> lazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
> lazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)
> lazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
> Category of algebras over Finite Field of size 5
> sage: Algebras(GF(7))
> lazy_import.__get__(<class 'sage.categories.associative_algebras.AssociativeAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
> lazy_import.__get__(<class 'sage.categories.algebras.Algebras'>,None,<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>)
> lazy_import.__get__(<class 'sage.categories.unital_algebras.UnitalAlgebras'>,None,<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>)
> Category of algebras over Finite Field of size 7
> ```

Obvious solution: Replace

```
    Finite = LazyImport('...')
```
by

```
    @lazy_class_attribute
    def Finite(cls):
        from ... import ...
        return ...
```
Then, the import would happen *only* when the lazy class attribute is invoked. Afterwards, the lazy class attribute is replaced by an actual class attribute, hence, the import won't happen again.



---

archive/issue_comments_109128.json:
```json
{
    "body": "**Changing commit** from \"[dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c](https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c)\" to \"[48dc0c06e567d07a70f1b45018f1e2a02cd434e7](https://github.com/sagemath/sagetrac-mirror/commit/48dc0c06e567d07a70f1b45018f1e2a02cd434e7)\".",
    "created_at": "2014-01-08T11:12:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109128",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c](https://github.com/sagemath/sagetrac-mirror/commit/dbb17b11bb9e8f94b5d9d3424cd34c5efc82564c)" to "[48dc0c06e567d07a70f1b45018f1e2a02cd434e7](https://github.com/sagemath/sagetrac-mirror/commit/48dc0c06e567d07a70f1b45018f1e2a02cd434e7)".



---

archive/issue_comments_109129.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/48dc0c06e567d07a70f1b45018f1e2a02cd434e7\">48dc0c0</a></td><td><code>Category with axioms: workaround limitation in lazy import to avoid lazy reimporting over and over</code></td></tr></table>\n",
    "created_at": "2014-01-08T11:12:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109129",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/48dc0c06e567d07a70f1b45018f1e2a02cd434e7">48dc0c0</a></td><td><code>Category with axioms: workaround limitation in lazy import to avoid lazy reimporting over and over</code></td></tr></table>




---

archive/issue_comments_109130.json:
```json
{
    "body": "<a id='comment:6'></a>\nI don't agree with the solution proposed in the previous commit. Please revert it.\n\nSince these lazy imports happen quite often, I think it does not suffice at all to just fix *one* of these lay imports.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/48dc0c06e567d07a70f1b45018f1e2a02cd434e7\">48dc0c0</a></td><td><code>Category with axioms: workaround limitation in lazy import to avoid lazy reimporting over and over</code></td></tr></table>\n",
    "created_at": "2014-01-08T11:17:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109130",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
I don't agree with the solution proposed in the previous commit. Please revert it.

Since these lazy imports happen quite often, I think it does not suffice at all to just fix *one* of these lay imports.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/48dc0c06e567d07a70f1b45018f1e2a02cd434e7">48dc0c0</a></td><td><code>Category with axioms: workaround limitation in lazy import to avoid lazy reimporting over and over</code></td></tr></table>




---

archive/issue_comments_109131.json:
```json
{
    "body": "<a id='comment:347'></a>\nHi Nils!\n\nReplying to [nbruin](#comment%3A340):\n> I have to think about your explanation. I have a hunch there's a problem with it but as long as I cannot point it out explicitly I cannot really object.\n\nOk; thanks for your thinking about it, and let us know soon if you\npinpoint a problem!\n\n> Independently, the lazy import indeed doesn't seem to clear\n> properly, as was indicated by the tracebacks above already.\n\nOh, right, it's good you are raising again this issue.\n\n> After the first call, all the lazy importing should have happened already, so subsequent invocations shouldn't have a lazy_import in between any more. I suspect that this happens because there is a lazy import object somewhere that doesn't get replaced by the reference to the actual object once it gets loaded. This is a known issue: lazy_importing objects from modules doesn't actually work very well (lazy importing modules and then referring to an object in the module works better, if I'm not mistaken).\n\nYeah, I also consider this as a shortcoming of lazy import and created\n#15648 for it.\n\n> So, you should probably not use lazy import for this but rather do it manually: just keep the string first and do an actual import, replacing the string, once you really need the object.\n\nI am not sure there is an easy solution for #15648. Luckily, there is\nan easy workaround in the case at hand, which I have implemented in\nthe commit I just pushed. I checked, and now the files are lazily\nimported only once.\n\nSo I think we can stick to the standard lazy import idiom which I very\nmuch like (concise, explicit, and the reader does not need to learn a\nnew idiom).\n\nWhat do you think?\n\nCheers,\n                    Nicolas",
    "created_at": "2014-01-08T11:21:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109131",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:347'></a>
Hi Nils!

Replying to [nbruin](#comment%3A340):
> I have to think about your explanation. I have a hunch there's a problem with it but as long as I cannot point it out explicitly I cannot really object.

Ok; thanks for your thinking about it, and let us know soon if you
pinpoint a problem!

> Independently, the lazy import indeed doesn't seem to clear
> properly, as was indicated by the tracebacks above already.

Oh, right, it's good you are raising again this issue.

> After the first call, all the lazy importing should have happened already, so subsequent invocations shouldn't have a lazy_import in between any more. I suspect that this happens because there is a lazy import object somewhere that doesn't get replaced by the reference to the actual object once it gets loaded. This is a known issue: lazy_importing objects from modules doesn't actually work very well (lazy importing modules and then referring to an object in the module works better, if I'm not mistaken).

Yeah, I also consider this as a shortcoming of lazy import and created
#15648 for it.

> So, you should probably not use lazy import for this but rather do it manually: just keep the string first and do an actual import, replacing the string, once you really need the object.

I am not sure there is an easy solution for #15648. Luckily, there is
an easy workaround in the case at hand, which I have implemented in
the commit I just pushed. I checked, and now the files are lazily
imported only once.

So I think we can stick to the standard lazy import idiom which I very
much like (concise, explicit, and the reader does not need to learn a
new idiom).

What do you think?

Cheers,
                    Nicolas



---

archive/issue_comments_109132.json:
```json
{
    "body": "<a id='comment:8'></a>\nI suggest to create a combination of lazy class attribute and `__import__`. Such as:\n\n```python\ndef imported_lazy_class_attribute(module_name, cls_name):\n    return lazy_class_attribute(lambda cls: getattr(__import__(module_name, {}, {}, [cls_name]),cls_name))\n```\n\nProof of concept:\n\n```\nsage: def imported_lazy_class_attribute(module_name, cls_name):                         \n....:     return lazy_class_attribute(lambda cls: getattr(__import__(module_name, {}, {}, [cls_name]),cls_name))\n....: \nsage: class Test(object):\n....:     Finite = imported_lazy_class_attribute('sage.categories.finite_permutation_groups', 'FinitePermutationGroups')\n....:     \nsage: Test.Finite\n<class 'sage.categories.finite_permutation_groups.FinitePermutationGroups'>\n```\n\nSo, we have a simple wrapper, that can be used to replace `LazyImport`.",
    "created_at": "2014-01-08T11:25:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109132",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
I suggest to create a combination of lazy class attribute and `__import__`. Such as:

```python
def imported_lazy_class_attribute(module_name, cls_name):
    return lazy_class_attribute(lambda cls: getattr(__import__(module_name, {}, {}, [cls_name]),cls_name))
```

Proof of concept:

```
sage: def imported_lazy_class_attribute(module_name, cls_name):                         
....:     return lazy_class_attribute(lambda cls: getattr(__import__(module_name, {}, {}, [cls_name]),cls_name))
....: 
sage: class Test(object):
....:     Finite = imported_lazy_class_attribute('sage.categories.finite_permutation_groups', 'FinitePermutationGroups')
....:     
sage: Test.Finite
<class 'sage.categories.finite_permutation_groups.FinitePermutationGroups'>
```

So, we have a simple wrapper, that can be used to replace `LazyImport`.



---

archive/issue_comments_109133.json:
```json
{
    "body": "<a id='comment:9'></a>\nIf you don't mind, I'll create a commit for my suggestion. But it will take until this evening.",
    "created_at": "2014-01-08T11:26:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109133",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
If you don't mind, I'll create a commit for my suggestion. But it will take until this evening.



---

archive/issue_comments_109134.json:
```json
{
    "body": "<a id='comment:0'></a>\nHmmmm. Perhaps you are right, and one can make `LazyImport` behave as a lazy attribute (lazy class attribute *or* lazy instance attribute, in fact!). Then, we wouldn't need to change the code here, but would instead just change a few lines in `LazyImport.__get__`. Hence, I'll now focus on #15648.",
    "created_at": "2014-01-08T11:32:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109134",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Hmmmm. Perhaps you are right, and one can make `LazyImport` behave as a lazy attribute (lazy class attribute *or* lazy instance attribute, in fact!). Then, we wouldn't need to change the code here, but would instead just change a few lines in `LazyImport.__get__`. Hence, I'll now focus on #15648.



---

archive/issue_comments_109135.json:
```json
{
    "body": "<a id='comment:1'></a>\nHmmm. I think I see the problem: #15648 is probably invalid, as `LazyImport` already puts an imported object into the class' dict (provided it is called on a class).\n\nThe problem is: The attribute name coincides with the name of the imported object (here: `'FinitePermutationGroups'`), but it should be assigned to the attribute `'Finite'`. Hence, I suppose it is enough to provide `as_name=\"Finite\"` to the lazy import.",
    "created_at": "2014-01-08T11:51:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109135",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Hmmm. I think I see the problem: #15648 is probably invalid, as `LazyImport` already puts an imported object into the class' dict (provided it is called on a class).

The problem is: The attribute name coincides with the name of the imported object (here: `'FinitePermutationGroups'`), but it should be assigned to the attribute `'Finite'`. Hence, I suppose it is enough to provide `as_name="Finite"` to the lazy import.



---

archive/issue_comments_109136.json:
```json
{
    "body": "<a id='comment:2'></a>\n\n```\nsage: from sage.misc.lazy_import import LazyImport\nsage: class A:\n....:     Associative = LazyImport('sage.categories.magmas', 'Magmas', 'Associative')\n....:     \nsage: A.Associative\n<class 'sage.categories.magmas.Magmas'>\nsage: A.__dict__['Associative']\n<class 'sage.categories.magmas.Magmas'>\n```\nHence, we won't need #15648.",
    "created_at": "2014-01-08T12:08:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109136",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>

```
sage: from sage.misc.lazy_import import LazyImport
sage: class A:
....:     Associative = LazyImport('sage.categories.magmas', 'Magmas', 'Associative')
....:     
sage: A.Associative
<class 'sage.categories.magmas.Magmas'>
sage: A.__dict__['Associative']
<class 'sage.categories.magmas.Magmas'>
```
Hence, we won't need #15648.



---

archive/issue_comments_109137.json:
```json
{
    "body": "<a id='comment:3'></a>\nIf you don't mind: I am now trying to create a new commit that uses the `as_name` argument, to avoid multiple imports.",
    "created_at": "2014-01-08T17:02:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109137",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
If you don't mind: I am now trying to create a new commit that uses the `as_name` argument, to avoid multiple imports.



---

archive/issue_comments_109138.json:
```json
{
    "body": "<a id='comment:4'></a>\nSorry for the delay, just coming out of four hour of classes ...\n\nI now agree that #15648 is not a bug, but rather a dream feature that\nmight not be possible to implement, and that can be worked around\neasily by using as_name. Nice finding Simon!\n\nBack to the issue here. Having to specify as_name works but is a bit\nredundant. In particular, it's likely that one will occasionally\nforget to put it in, or put it in with a typo, and then the induced\nreiterating lazy import will probably go unnoticed.\n\nThat unless we add an assertion test about this in `__classget__` but\nthen it's barely different from the current workaround I implemented.\n\nAltogether, I am hesitant in the trade off between adding four\nadmittedly-not-so-nice lines in one spot, and adding an extra argument\nin 43 (and increasing) spots spread over the category code. In fact,\nif it was just for me, you know what my choice would be :-)\n\nWhat do you think?\n\nCheers,\n                               Nicolas",
    "created_at": "2014-01-08T17:42:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109138",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:4'></a>
Sorry for the delay, just coming out of four hour of classes ...

I now agree that #15648 is not a bug, but rather a dream feature that
might not be possible to implement, and that can be worked around
easily by using as_name. Nice finding Simon!

Back to the issue here. Having to specify as_name works but is a bit
redundant. In particular, it's likely that one will occasionally
forget to put it in, or put it in with a typo, and then the induced
reiterating lazy import will probably go unnoticed.

That unless we add an assertion test about this in `__classget__` but
then it's barely different from the current workaround I implemented.

Altogether, I am hesitant in the trade off between adding four
admittedly-not-so-nice lines in one spot, and adding an extra argument
in 43 (and increasing) spots spread over the category code. In fact,
if it was just for me, you know what my choice would be :-)

What do you think?

Cheers,
                               Nicolas



---

archive/issue_comments_109139.json:
```json
{
    "body": "<a id='comment:355'></a>\nReplying to [SimonKing](#comment%3A351):\n> The problem is: The attribute name coincides with the name of the imported object (here: `'FinitePermutationGroups'`), but it should be assigned to the attribute `'Finite'`. Hence, I suppose it is enough to provide `as_name=\"Finite\"` to the lazy import.\n\nYou really want to check that this works properly. LazyImport proxies seem deceivingly easy to use but have nasty catches. For instance, if such a proxy gets returned by a caching routine then the proxy gets nailed in the cache, out of reach of the replacement code.",
    "created_at": "2014-01-08T17:49:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109139",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:355'></a>
Replying to [SimonKing](#comment%3A351):
> The problem is: The attribute name coincides with the name of the imported object (here: `'FinitePermutationGroups'`), but it should be assigned to the attribute `'Finite'`. Hence, I suppose it is enough to provide `as_name="Finite"` to the lazy import.

You really want to check that this works properly. LazyImport proxies seem deceivingly easy to use but have nasty catches. For instance, if such a proxy gets returned by a caching routine then the proxy gets nailed in the cache, out of reach of the replacement code.



---

archive/issue_comments_109140.json:
```json
{
    "body": "<a id='comment:356'></a>\nReplying to [nthiery](#comment%3A354):\n> Altogether, I am hesitant in the trade off between adding four\n> admittedly-not-so-nice lines in one spot, and adding an extra argument\n> in 43 (and increasing) spots spread over the category code. In fact,\n> if it was just for me, you know what my choice would be :-)\n\nThen what about my other suggestion: Make a shortcut (say, `LazilyImportedClassAttribute`), that guarantees that stuff is put into the class' dict (see [comment:348](#comment%3A348)). Then, we would change the 43 places *now*, and have something that is easier to maintain, since we don't need to specify `as_name`.\n\nNote that there would be one difference: Doint `LazyImport` will bind the imported object to the class resp. the instance --- but my suggestion from [comment:348](#comment%3A348) just puts stuff into an attribute, without binding it (i.e., without calling the imported object's `__get__`). This may be what we want, or perhaps it isn't? Not totally clear to me.",
    "created_at": "2014-01-08T18:25:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109140",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:356'></a>
Replying to [nthiery](#comment%3A354):
> Altogether, I am hesitant in the trade off between adding four
> admittedly-not-so-nice lines in one spot, and adding an extra argument
> in 43 (and increasing) spots spread over the category code. In fact,
> if it was just for me, you know what my choice would be :-)

Then what about my other suggestion: Make a shortcut (say, `LazilyImportedClassAttribute`), that guarantees that stuff is put into the class' dict (see [comment:348](#comment%3A348)). Then, we would change the 43 places *now*, and have something that is easier to maintain, since we don't need to specify `as_name`.

Note that there would be one difference: Doint `LazyImport` will bind the imported object to the class resp. the instance --- but my suggestion from [comment:348](#comment%3A348) just puts stuff into an attribute, without binding it (i.e., without calling the imported object's `__get__`). This may be what we want, or perhaps it isn't? Not totally clear to me.



---

archive/issue_comments_109141.json:
```json
{
    "body": "<a id='comment:7'></a>\nOops, forget my suggestion. As it turns out, one has\n\n```\nsage: def imported_lazy_class_attribute(module_name, cls_name):\n    return lazy_class_attribute(lambda cls: getattr(__import__(module_name, {}, {}, [cls_name]),cls_name))\n....: \nsage: class Test(object):\n....:     Finite = imported_lazy_class_attribute('sage.categories.finite_permutation_groups', 'FinitePermutationGroups')\n....:\nsage: Test.Finite\n<class 'sage.categories.finite_permutation_groups.FinitePermutationGroups'>\nsage: Test.__dict__['Finite']\n<sage.misc.lazy_attribute.lazy_class_attribute at 0xc29702c>\n```\nSo, what I suggested in [comment:348](#comment%3A348) is not a solution.\n\nI think we *should* solve the problem now. Currently, I am running tests for the \"add `as_name` in 43 spots\" approach.\n\nIt would be a good idea (for maintainability) to have an assertion that the lazily imported object in fact ends up in the class' dict.\n\nBut where could such a test take place? What part of the code knows, e.g., that `Groups` are known under the name `Inverse` to `Monoids`?",
    "created_at": "2014-01-08T20:12:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109141",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Oops, forget my suggestion. As it turns out, one has

```
sage: def imported_lazy_class_attribute(module_name, cls_name):
    return lazy_class_attribute(lambda cls: getattr(__import__(module_name, {}, {}, [cls_name]),cls_name))
....: 
sage: class Test(object):
....:     Finite = imported_lazy_class_attribute('sage.categories.finite_permutation_groups', 'FinitePermutationGroups')
....:
sage: Test.Finite
<class 'sage.categories.finite_permutation_groups.FinitePermutationGroups'>
sage: Test.__dict__['Finite']
<sage.misc.lazy_attribute.lazy_class_attribute at 0xc29702c>
```
So, what I suggested in [comment:348](#comment%3A348) is not a solution.

I think we *should* solve the problem now. Currently, I am running tests for the "add `as_name` in 43 spots" approach.

It would be a good idea (for maintainability) to have an assertion that the lazily imported object in fact ends up in the class' dict.

But where could such a test take place? What part of the code knows, e.g., that `Groups` are known under the name `Inverse` to `Monoids`?



---

archive/issue_comments_109142.json:
```json
{
    "body": "<a id='comment:358'></a>\nReplying to [SimonKing](#comment%3A357):\n> I think we *should* solve the problem now. Currently, I am running tests for the \"add `as_name` in 43 spots\" approach.\n> \n> It would be a good idea (for maintainability) to have an assertion that the lazily imported object in fact ends up in the class' dict.\n> \n> But where could such a test take place? What part of the code knows, e.g., that `Groups` are known under the name `Inverse` to `Monoids`?\n\nA natural spot is where I introduced the trick that forces the\nreplacement of the lazy import by the object itself: in\nCategoryWithAxiom.__classget__.\n\nBut then the trick is no more complicated than the assertion test, and\nthe trick by itself solves the problem now. So honestly I don't see\nwhy bother :-)\n\nCheers,\n                             Nicolas",
    "created_at": "2014-01-08T20:26:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109142",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:358'></a>
Replying to [SimonKing](#comment%3A357):
> I think we *should* solve the problem now. Currently, I am running tests for the "add `as_name` in 43 spots" approach.
> 
> It would be a good idea (for maintainability) to have an assertion that the lazily imported object in fact ends up in the class' dict.
> 
> But where could such a test take place? What part of the code knows, e.g., that `Groups` are known under the name `Inverse` to `Monoids`?

A natural spot is where I introduced the trick that forces the
replacement of the lazy import by the object itself: in
CategoryWithAxiom.__classget__.

But then the trick is no more complicated than the assertion test, and
the trick by itself solves the problem now. So honestly I don't see
why bother :-)

Cheers,
                             Nicolas



---

archive/issue_comments_109143.json:
```json
{
    "body": "<a id='comment:359'></a>\n**I HATE TRAC!!! **\n\nIt always keeps jumping to the top of the page while editing. And right now, after typing for, say, 30 minutes, the text got lost, even though I pressed \"submit\". So, let's use itsalltext.\n\n\nReplying to [nthiery](#comment%3A358):\n> > But where could such a test take place? What part of the code knows, e.g., that `Groups` are known under the name `Inverse` to `Monoids`?\n\n> \n> A natural spot is where I introduced the trick that forces the\n> replacement of the lazy import by the object itself: in\n> CategoryWithAxiom.__classget__.\n> \n> But then the trick is no more complicated than the assertion test, and\n> the trick by itself solves the problem now.\n\nAha! I got distracted by the comments that you've put into the code: I thought\nyou *only* consider the special case of the axiom 'Finite'.\n\nBut you use `cls._axiom`, and this should give the correct attribute name.\n\nOr does it? I think you'll run into problems, as soon as you have categories\n`C`, `B1`, `B2`, such that `C==B1.Axiom1()==B2.Axiom2()`.\n\nIndeed, you must decide what value to assign to `C._axiom`. Say, you decide\n`C._axiom=='Axiom1'`. Then, with your trick, calling `B2.Axiom2` would put `C`\ninto `B2.__dict__['Axiom1']`. And that's the wrong attribute, it should be\n`'Axiom2'`.\n\nMore concretely:\n\n```\nsage: Rings().Commutative().Finite().Division()\nCategory of finite fields\nsage: DivisionRings().Finite()\nCategory of finite fields\nsage: Rings().Commutative().Finite().Division()._axiom\n'Finite'\n```\n\nLuckily, `Rings().Commutative().Finite()` is a join category. But assume, in a\ncifferent example, you would build it not as a join, but using a separate\ncategory class class `CC`. Then, you would originally find that\n`CC.Finite()==C()` (since `C` comprises the finiteness axiom). But after doing\n`CC.Division()`, the result would be put into `CC.__dict__['Finite']`. Hence,\nnext time you call `C.Finite()`, the result wouldn't be `CC()` but `CC.Division()`.\n\n> So honestly I don't see why bother :-)\n\nDo you see now? It is sheer luck that you don't run into that kind of\nproblems. So, I'd say we should better be explicit here.",
    "created_at": "2014-01-08T21:03:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109143",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:359'></a>
**I HATE TRAC!!! **

It always keeps jumping to the top of the page while editing. And right now, after typing for, say, 30 minutes, the text got lost, even though I pressed "submit". So, let's use itsalltext.


Replying to [nthiery](#comment%3A358):
> > But where could such a test take place? What part of the code knows, e.g., that `Groups` are known under the name `Inverse` to `Monoids`?

> 
> A natural spot is where I introduced the trick that forces the
> replacement of the lazy import by the object itself: in
> CategoryWithAxiom.__classget__.
> 
> But then the trick is no more complicated than the assertion test, and
> the trick by itself solves the problem now.

Aha! I got distracted by the comments that you've put into the code: I thought
you *only* consider the special case of the axiom 'Finite'.

But you use `cls._axiom`, and this should give the correct attribute name.

Or does it? I think you'll run into problems, as soon as you have categories
`C`, `B1`, `B2`, such that `C==B1.Axiom1()==B2.Axiom2()`.

Indeed, you must decide what value to assign to `C._axiom`. Say, you decide
`C._axiom=='Axiom1'`. Then, with your trick, calling `B2.Axiom2` would put `C`
into `B2.__dict__['Axiom1']`. And that's the wrong attribute, it should be
`'Axiom2'`.

More concretely:

```
sage: Rings().Commutative().Finite().Division()
Category of finite fields
sage: DivisionRings().Finite()
Category of finite fields
sage: Rings().Commutative().Finite().Division()._axiom
'Finite'
```

Luckily, `Rings().Commutative().Finite()` is a join category. But assume, in a
cifferent example, you would build it not as a join, but using a separate
category class class `CC`. Then, you would originally find that
`CC.Finite()==C()` (since `C` comprises the finiteness axiom). But after doing
`CC.Division()`, the result would be put into `CC.__dict__['Finite']`. Hence,
next time you call `C.Finite()`, the result wouldn't be `CC()` but `CC.Division()`.

> So honestly I don't see why bother :-)

Do you see now? It is sheer luck that you don't run into that kind of
problems. So, I'd say we should better be explicit here.



---

archive/issue_comments_109144.json:
```json
{
    "body": "<a id='comment:360'></a>\nReplying to [SimonKing](#comment%3A359):\n> It always keeps jumping to the top of the page while editing. And right now, after typing for, say, 30 minutes, the text got lost, even though I pressed \"submit\". So, let's use itsalltext.\n\nYes, pretty annoying! I am also systematically using itsalltext ...\n\n\n> Replying to [nthiery](#comment%3A358):\n> Aha! I got distracted by the comments that you've put into the code: I thought\n> you *only* consider the special case of the axiom 'Finite'.\n\nOh, I see! I now understand your comment on trac. Sorry for my\nmisleading comment in the code.\n\n> But you use `cls._axiom`, and this should give the correct attribute name.\n> \n> Or does it? I think you'll run into problems, as soon as you have categories\n> `C`, `B1`, `B2`, such that `C==B1.Axiom1()==B2.Axiom2()`.\n\nLet me write instead C(), B1() and B2() for the categories, and C, B1,\nand B2 for their respective classes.\n\nYou would indeed run into a problem if you had B1.Axiom1 and B2.Axiom2\npoint to the same class C. But that's forbidden: the classes are to be\norganized in a tree. In particular, the class of a category with axiom\nhas a unique base_category class and axiom, which is that given in the\ncode by the link \"X.Axiom = Y\". In principle there should be\nappropriate barking if this specification is violated.\n\nSince the trick in `__classget__` works at the level of the classes,\nbefore even the category is created, we are safe.\n\nFor the record, at the level of categories, here is what\nhappens. Imagine C=B1.Axiom1. Even if you get also C() as the end\nresult of calling B2.Axiom2(), C() is still constructed internally as\nB1().Axiom1(), and the base_category_class and axiom are set\naccordingly:\n\n```\nsage: B1 = Magmas.Associative\nsage: B2 = Magmas.Unital\nsage: C = B1.Unital\n\nsage: B1()\nCategory of semigroups\nsage: B2()\nCategory of unital magmas\nsage: C()\nCategory of monoids\n\nsage: B2().Associative() is B1().Unital()\nTrue\n\nsage: B1().Unital()._base_category_class_and_axiom\n[sage.categories.semigroups.Semigroups, 'Unital']\n```\n\n> Do you see now? It is sheer luck that you don't run into that kind of\n> problems. So, I'd say we should better be explicit here.\n\nNo sheer luck. Just a consequence of the specifications :-)\n\nCheers,\n                              Nicolas",
    "created_at": "2014-01-08T21:41:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109144",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:360'></a>
Replying to [SimonKing](#comment%3A359):
> It always keeps jumping to the top of the page while editing. And right now, after typing for, say, 30 minutes, the text got lost, even though I pressed "submit". So, let's use itsalltext.

Yes, pretty annoying! I am also systematically using itsalltext ...


> Replying to [nthiery](#comment%3A358):
> Aha! I got distracted by the comments that you've put into the code: I thought
> you *only* consider the special case of the axiom 'Finite'.

Oh, I see! I now understand your comment on trac. Sorry for my
misleading comment in the code.

> But you use `cls._axiom`, and this should give the correct attribute name.
> 
> Or does it? I think you'll run into problems, as soon as you have categories
> `C`, `B1`, `B2`, such that `C==B1.Axiom1()==B2.Axiom2()`.

Let me write instead C(), B1() and B2() for the categories, and C, B1,
and B2 for their respective classes.

You would indeed run into a problem if you had B1.Axiom1 and B2.Axiom2
point to the same class C. But that's forbidden: the classes are to be
organized in a tree. In particular, the class of a category with axiom
has a unique base_category class and axiom, which is that given in the
code by the link "X.Axiom = Y". In principle there should be
appropriate barking if this specification is violated.

Since the trick in `__classget__` works at the level of the classes,
before even the category is created, we are safe.

For the record, at the level of categories, here is what
happens. Imagine C=B1.Axiom1. Even if you get also C() as the end
result of calling B2.Axiom2(), C() is still constructed internally as
B1().Axiom1(), and the base_category_class and axiom are set
accordingly:

```
sage: B1 = Magmas.Associative
sage: B2 = Magmas.Unital
sage: C = B1.Unital

sage: B1()
Category of semigroups
sage: B2()
Category of unital magmas
sage: C()
Category of monoids

sage: B2().Associative() is B1().Unital()
True

sage: B1().Unital()._base_category_class_and_axiom
[sage.categories.semigroups.Semigroups, 'Unital']
```

> Do you see now? It is sheer luck that you don't run into that kind of
> problems. So, I'd say we should better be explicit here.

No sheer luck. Just a consequence of the specifications :-)

Cheers,
                              Nicolas



---

archive/issue_comments_109145.json:
```json
{
    "body": "<a id='comment:361'></a>\nReplying to [nthiery](#comment%3A360):\n> You would indeed run into a problem if you had B1.Axiom1 and B2.Axiom2\n> point to the same class C. But that's forbidden: \n\nHow? And don't you think it is easier to enforce people using the `as_name`\nargument of `LazyAttribute` then to follow this strange \"No-no\"?\n\n> the classes are to be\n> organized in a tree. In particular, the class of a category with axiom\n> has a unique base_category class and axiom, which is that given in the\n> code by the link \"X.Axiom = Y\". In principle there should be\n> appropriate barking if this specification is violated.\n\nIt could very well be that mathematically you have\n`Z().OtherAxiom()==X().Axiom()==Y()`. So, why do you forbid to support\n`OtherAxiom` on the class level? And how would you enforce it?\n \n> Since the trick in `__classget__` works at the level of the classes,\n> before even the category is created, we are safe.\n\nI was talking about classes, and we are only safe if everybody follows the\nconvention that you just formulated, and that I don't think is clearly documented.\n\n> ```\n> sage: B1 = Magmas.Associative\n> sage: B2 = Magmas.Unital\n> sage: C = B1.Unital\n> \n> sage: B1()\n> Category of semigroups\n> sage: B2()\n> Category of unital magmas\n> sage: C()\n> Category of monoids\n> \n> sage: B2().Associative() is B1().Unital()\n> True\n> \n> sage: B1().Unital()._base_category_class_and_axiom\n> [sage.categories.semigroups.Semigroups, 'Unital']\n> ```\n\nMathematically, it should be the case that `B2.Associative` is the\nsame as `B1.Unital`. On the instance level, it is. But not on the class level:\n\n```\nsage: B2().Associative()\nCategory of monoids\nsage: B2.Associative\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-9-179422d552e4> in <module>()\n----> 1 B2.Associative\n\nAttributeError: type object 'Magmas.Unital' has no attribute 'Associative'\n```\nThere are associative unital magmas, in the same way as there are unital\nassociative magmas. Apparently the categories know it, even though the classes\nof the category don't.\n\nIt seems quite likely to me that a mathematician would think: \"Well, of course\nthe category of unital magmas should also support the axiom of associativity,\nso, let's provide it *on the level of classes*.\" But then, your trick would result in the problem\n(putting a class into the wrong attribute of the base class) that I sketched\nin my previous post.\n\n> > Do you see now? It is sheer luck that you don't run into that kind of\n> > problems. So, I'd say we should better be explicit here.\n\n> \n> No sheer luck. Just a consequence of the specifications :-)\n\nThe more I think of it, the less I like the convention that some mathematical\nfacts can only be implemented for instances of a class, but not for the class\nitself. And I don't see how you enforce or even just encourage this convention.",
    "created_at": "2014-01-08T22:46:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109145",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:361'></a>
Replying to [nthiery](#comment%3A360):
> You would indeed run into a problem if you had B1.Axiom1 and B2.Axiom2
> point to the same class C. But that's forbidden: 

How? And don't you think it is easier to enforce people using the `as_name`
argument of `LazyAttribute` then to follow this strange "No-no"?

> the classes are to be
> organized in a tree. In particular, the class of a category with axiom
> has a unique base_category class and axiom, which is that given in the
> code by the link "X.Axiom = Y". In principle there should be
> appropriate barking if this specification is violated.

It could very well be that mathematically you have
`Z().OtherAxiom()==X().Axiom()==Y()`. So, why do you forbid to support
`OtherAxiom` on the class level? And how would you enforce it?
 
> Since the trick in `__classget__` works at the level of the classes,
> before even the category is created, we are safe.

I was talking about classes, and we are only safe if everybody follows the
convention that you just formulated, and that I don't think is clearly documented.

> ```
> sage: B1 = Magmas.Associative
> sage: B2 = Magmas.Unital
> sage: C = B1.Unital
> 
> sage: B1()
> Category of semigroups
> sage: B2()
> Category of unital magmas
> sage: C()
> Category of monoids
> 
> sage: B2().Associative() is B1().Unital()
> True
> 
> sage: B1().Unital()._base_category_class_and_axiom
> [sage.categories.semigroups.Semigroups, 'Unital']
> ```

Mathematically, it should be the case that `B2.Associative` is the
same as `B1.Unital`. On the instance level, it is. But not on the class level:

```
sage: B2().Associative()
Category of monoids
sage: B2.Associative
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-9-179422d552e4> in <module>()
----> 1 B2.Associative

AttributeError: type object 'Magmas.Unital' has no attribute 'Associative'
```
There are associative unital magmas, in the same way as there are unital
associative magmas. Apparently the categories know it, even though the classes
of the category don't.

It seems quite likely to me that a mathematician would think: "Well, of course
the category of unital magmas should also support the axiom of associativity,
so, let's provide it *on the level of classes*." But then, your trick would result in the problem
(putting a class into the wrong attribute of the base class) that I sketched
in my previous post.

> > Do you see now? It is sheer luck that you don't run into that kind of
> > problems. So, I'd say we should better be explicit here.

> 
> No sheer luck. Just a consequence of the specifications :-)

The more I think of it, the less I like the convention that some mathematical
facts can only be implemented for instances of a class, but not for the class
itself. And I don't see how you enforce or even just encourage this convention.



---

archive/issue_comments_109146.json:
```json
{
    "body": "<a id='comment:2'></a>\nI see. Continuing the example from above:\n\n```\nsage: B2.Associative = sage.misc.lazy_import.LazyImport('sage.categories.monoids','Monoids')\nsage: B2.Associative()\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\n<ipython-input-5-2f486cd5dd51> in <module>()\n----> 1 B2.Associative()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/misc/lazy_import.so in sage.misc.lazy_import.LazyImport.__get__ (sage/misc/lazy_import.c:3371)()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.ClasscallMetaclass.__get__ (sage/misc/classcall_metaclass.c:1350)()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.pyc in __classget__(cls, base_category, base_category_class)\n    549         else:\n    550             assert cls._base_category_class_and_axiom[0] is base_category_class, \\\n--> 551                 \"base category class for %s mismatch; expected %s, got %s\"%(cls, cls._base_category_class_and_axiom[0], base_category_class)\n    552         if base_category is None:\n    553              return cls\n\nAssertionError: base category class for <class 'sage.categories.monoids.Monoids'> mismatch; expected <class 'sage.categories.semigroups.Semigroups'>, got <class 'sage.categories.magmas.Magmas.Unital'>\n```\nSo, this is how you enforce it.\n\nBut then: Do you really expect that **in the long run** all developers contributing to the category framework will be happy to do\n\n```\n    class SubcategoryMethods:\n\n        @cached_method\n        def Associative(self):\n```\non *some* categories, and \n\n```\n   Associative = LazyImport('...', '...')\n```\non exactly one category?\n\nGranted, if one uses a database as a metaclass, this could be automated. Well, once we got this ticket merged, I will start to do experiments with that idea...",
    "created_at": "2014-01-08T23:35:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109146",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
I see. Continuing the example from above:

```
sage: B2.Associative = sage.misc.lazy_import.LazyImport('sage.categories.monoids','Monoids')
sage: B2.Associative()
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
<ipython-input-5-2f486cd5dd51> in <module>()
----> 1 B2.Associative()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/misc/lazy_import.so in sage.misc.lazy_import.LazyImport.__get__ (sage/misc/lazy_import.c:3371)()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.ClasscallMetaclass.__get__ (sage/misc/classcall_metaclass.c:1350)()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.pyc in __classget__(cls, base_category, base_category_class)
    549         else:
    550             assert cls._base_category_class_and_axiom[0] is base_category_class, \
--> 551                 "base category class for %s mismatch; expected %s, got %s"%(cls, cls._base_category_class_and_axiom[0], base_category_class)
    552         if base_category is None:
    553              return cls

AssertionError: base category class for <class 'sage.categories.monoids.Monoids'> mismatch; expected <class 'sage.categories.semigroups.Semigroups'>, got <class 'sage.categories.magmas.Magmas.Unital'>
```
So, this is how you enforce it.

But then: Do you really expect that **in the long run** all developers contributing to the category framework will be happy to do

```
    class SubcategoryMethods:

        @cached_method
        def Associative(self):
```
on *some* categories, and 

```
   Associative = LazyImport('...', '...')
```
on exactly one category?

Granted, if one uses a database as a metaclass, this could be automated. Well, once we got this ticket merged, I will start to do experiments with that idea...



---

archive/issue_comments_109147.json:
```json
{
    "body": "<a id='comment:3'></a>\nNicolas, I think more things could potentially go wrong. Assume that someone has a category class `CC` and has two axioms Axiom1 and Axiom2. As it happens, both `CC().Axiom1()` and `CC.Axiom2()` return two *different* categories R1 and R2, but unfortunately both `R1._axiom=='Axiom1'==R2._axiom`. It seems to me that in this situation it would be possible to screw up (trying to construct an example now), if you just test whether `CC.__dict__[R1._axiom]` is a lazy import (and then override it).\n\nCould it not happen that `CC.__dict__[R1._axiom]` happens to be R2? I think this case should be barked at as well.\n\nI believe the following should happen:\n- if `CC.__dict__[R1._axiom]` is a `LazyImport` then presumably the `LazyImport` had the wrong (or no) `as_name`. Rather than blindly putting R1 into it, Sage should better raise an error and ask to provide the correct name.\n- if `CC.__dict__[R1._axiom]` is not a `LazyImport`, then it must be tested whether it coincides with R1. If it doesn't, then certainly there is something wrong, which should give rise to an error, too.",
    "created_at": "2014-01-09T14:50:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109147",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Nicolas, I think more things could potentially go wrong. Assume that someone has a category class `CC` and has two axioms Axiom1 and Axiom2. As it happens, both `CC().Axiom1()` and `CC.Axiom2()` return two *different* categories R1 and R2, but unfortunately both `R1._axiom=='Axiom1'==R2._axiom`. It seems to me that in this situation it would be possible to screw up (trying to construct an example now), if you just test whether `CC.__dict__[R1._axiom]` is a lazy import (and then override it).

Could it not happen that `CC.__dict__[R1._axiom]` happens to be R2? I think this case should be barked at as well.

I believe the following should happen:
- if `CC.__dict__[R1._axiom]` is a `LazyImport` then presumably the `LazyImport` had the wrong (or no) `as_name`. Rather than blindly putting R1 into it, Sage should better raise an error and ask to provide the correct name.
- if `CC.__dict__[R1._axiom]` is not a `LazyImport`, then it must be tested whether it coincides with R1. If it doesn't, then certainly there is something wrong, which should give rise to an error, too.



---

archive/issue_comments_109148.json:
```json
{
    "body": "**Changing commit** from \"[48dc0c06e567d07a70f1b45018f1e2a02cd434e7](https://github.com/sagemath/sagetrac-mirror/commit/48dc0c06e567d07a70f1b45018f1e2a02cd434e7)\" to \"[8045aa4a4b7ada735b3eb6055382f9b341a39f1e](https://github.com/sagemath/sagetrac-mirror/commit/8045aa4a4b7ada735b3eb6055382f9b341a39f1e)\".",
    "created_at": "2014-01-09T16:39:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109148",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[48dc0c06e567d07a70f1b45018f1e2a02cd434e7](https://github.com/sagemath/sagetrac-mirror/commit/48dc0c06e567d07a70f1b45018f1e2a02cd434e7)" to "[8045aa4a4b7ada735b3eb6055382f9b341a39f1e](https://github.com/sagemath/sagetrac-mirror/commit/8045aa4a4b7ada735b3eb6055382f9b341a39f1e)".



---

archive/issue_comments_109149.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8045aa4a4b7ada735b3eb6055382f9b341a39f1e\">8045aa4</a></td><td><code>Trac 10963: Fix LazyImport as_name, and make stronger consistency tests</code></td></tr></table>\n",
    "created_at": "2014-01-09T16:39:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109149",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8045aa4a4b7ada735b3eb6055382f9b341a39f1e">8045aa4</a></td><td><code>Trac 10963: Fix LazyImport as_name, and make stronger consistency tests</code></td></tr></table>




---

archive/issue_comments_109150.json:
```json
{
    "body": "<a id='comment:5'></a>\nNicolas, please see if you can agree with my changes. If you can agree, then\nin the next step I'd like to try and add some more tests.\n\nFirst of all, I did not succeed in constructing an example in which the\nproblem sketched above really occurs: All the time there was an error telling\nme that I did something wrong. This is the good news.\n\nNonetheless, I think it is better to ask developers to lazy-import with the correct name. Hence, I replaced your workaround by an error, explaining what needs to be done (and this is what I want to add a doctest for).\n\nIn addition, just to be on the safe side, I test whether the thing found in\n`base_category_class.__dict__[cls._axiom]` actually *is* `cls`. If it isn't,\nthen there is a problem: Either it is a lazy import put under the wrong name,\nor we are in the scenario sketched above. I think we have good reason to be\nparanoid, because *if* a class is put into `base_category_class.__dict__`\nwith the wrong key, then I guess we would have very difficult to debug crashes.",
    "created_at": "2014-01-09T16:48:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109150",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
Nicolas, please see if you can agree with my changes. If you can agree, then
in the next step I'd like to try and add some more tests.

First of all, I did not succeed in constructing an example in which the
problem sketched above really occurs: All the time there was an error telling
me that I did something wrong. This is the good news.

Nonetheless, I think it is better to ask developers to lazy-import with the correct name. Hence, I replaced your workaround by an error, explaining what needs to be done (and this is what I want to add a doctest for).

In addition, just to be on the safe side, I test whether the thing found in
`base_category_class.__dict__[cls._axiom]` actually *is* `cls`. If it isn't,
then there is a problem: Either it is a lazy import put under the wrong name,
or we are in the scenario sketched above. I think we have good reason to be
paranoid, because *if* a class is put into `base_category_class.__dict__`
with the wrong key, then I guess we would have very difficult to debug crashes.



---

archive/issue_comments_109151.json:
```json
{
    "body": "<a id='comment:6'></a>\nOK, I think I've pinned down what bits make me think that the current\nimplementation may be a bit unnatural for (what I understand of) what is being\nmodelled. To me it seems there are some differences between the implementation\nand the model. That is often necessary in practice, so they may be quite\njustified. But I see some problems popping up here that may be due to those\ndifferences.\n\nFirst: what is modelled? As I understand this is an acyclic digraph, where the\nvertices are categories and the edges are labelled with axioms. Furthermore, I\nthink the assumption is that this graph is determined at build/startup time. The\nmodelled graph is supposed to be constant throughout runtime (so Simon's desire\nto dynamically extend the graph would, strictly speaking, not fit in the model).\n\nThere is of course information that is carried with this graph. I'm not sure\nwhat exactly the information is, but it seems to be mainly \"code\" (methods\netc.), attached to the vertices.\n\nInstantiating the entire graph at startup is apparently too expensive (I can\ndefinitely believe so), so although the modelled graph is constant, we are only\nkeeping part of it in memory, gradually extending it as needed.\n\nIt seems that each category is modelled by a \"class\" (for code-centric\ninformation, this seems a reasonable choice). However, inheritance isn't used to\nexpress edges (they wouldn not be sufficient anyway, since \"subclass of\" arrows\ndon't carry labels). Instead, \"axioms\" are indicated by class attributes on the\nmore general category, where the name of the attribute provides the axiom label\nand the value is the category obtained from adding the axiom.\n\n**Potential Problem:** Implementing a labelled digraph using dictionaries is a\nvery natural one, but here we have a bit of a mess: the outgoing edges are mixed\nin to a dictionary that has all kinds of other stuff in it too. For instance,\ngetting a list of which axioms are \"implemented\" for a category involves\niterating over the `class.__dict__` and filtering on which attributes are axioms\nand which are other methods. How do we tell the difference? By name? How about\nname clashes?\n\n**Unusual:** It is rare that callables are bound to an attribute that doesn't\nbear their (unqualified) name. It's not unheard of, though.\n\nThe \"lazy loading\" requirement is implemented by choosing for every category a\npreferred (basecategory,axiom) pair through which it can be obtained. The class\nattribute corresponding to that edge is implemented by a `LazyImport` link\nrather than putting the actual class there.\n\n**Question:** At this point, it seems unnecessary to do this only for a\npreferred edge. Each `LazyImport` would need to be called once to resolve, but\nif the import in question has already happened then the result should just be\nthat the LazyImport removes itself from the story (provided the LazyImport has\nthe right references to take itself out of the relevant dictionary).\n\nIt also seems to be useful to have a link from a category to the categories from\nwhich is can be obtained. Oddly enough, the system insists on having a single\nmain (category,axiom) pair through which it can be obtained, even though the\noriginal graph we're modelling doesn't have any such concept\n\n**Question:** Why do we need `_base_category_and_axiom` at all? It seems very\nunnatural: there are many ways in which a category can be obtained by adding an\nextra axiom to another category. Indeed, there are `extra_super_categories`. Why\nare they separate? Should we just have a set of `(base_category,axiom)` pairs?\n\n**Question:** (for lazy loading) given that categories refer to their super\ncategories, is it indeed the case that loading a category will imply loading the\nentire \"inbound component\" (all vertices that have a path to this one)? It is\nnot entirely clear to me how they get that info. Is that a combination of a name\nmangling search and hard-wiring the connections? \n\n**Question:** Is there always just one axiom to add to go from one category to another?\nWouldn't there be useless nodes in the graph then (partial axiom combinations\nthat no-one is interested in)?\n\nIn short, I think the current problems are mainly coming from an imposed\nasymmetry: the introduction of a \"main\" `(base_category,axiom)` pair.\nAdditionally, the lazy loading issue only becomes complicated because the\nderived categories insist on knowing what their direct supercategories are. If\nwe wouldn't need that then just the lazy imports would do the trick.\n\nIf we do need categories to know their supercategories, then there is indeed a\nproblem of how to get that information. Name mangling doesn't do the trick,\nbecause that only works for a rooted tree. We need to be able to express an\n(acyclic)digraph (I don't think we get any mileage out of the acyclic bit).\n\nIf you really want a single point of truth, I don't see an alternative to\nSimon's suggestion a bit list of:\n\n```\n(\"base category\", \"axiom\", \"resulting category\")\n```\ntriples, where the entries are indeed strings, and a nasty (meta?)metaclass on\ncategories that looks up all the entries with base category occurring, to put in\nthe appropriate `LazyImport` bindings and a look up of the `resulting category`\nentries to put the links back in the super_category attribute.\n\nAnother point that's a little dirty presently is that the axiom callables are\nmixed in with all the other class attributes. That could easily cause name\nclashes. I would almost say that instead of\n\n```\nAlgebras(GF(5)).FiniteDimensional()\n```\nit would be preferable to do\n\n```\nAlgebras(GF(5)).with_axiom(\"FiniteDimensional\")\n```\nsince that would give the freedom to use a dedicated dictionary.",
    "created_at": "2014-01-09T18:23:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109151",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:6'></a>
OK, I think I've pinned down what bits make me think that the current
implementation may be a bit unnatural for (what I understand of) what is being
modelled. To me it seems there are some differences between the implementation
and the model. That is often necessary in practice, so they may be quite
justified. But I see some problems popping up here that may be due to those
differences.

First: what is modelled? As I understand this is an acyclic digraph, where the
vertices are categories and the edges are labelled with axioms. Furthermore, I
think the assumption is that this graph is determined at build/startup time. The
modelled graph is supposed to be constant throughout runtime (so Simon's desire
to dynamically extend the graph would, strictly speaking, not fit in the model).

There is of course information that is carried with this graph. I'm not sure
what exactly the information is, but it seems to be mainly "code" (methods
etc.), attached to the vertices.

Instantiating the entire graph at startup is apparently too expensive (I can
definitely believe so), so although the modelled graph is constant, we are only
keeping part of it in memory, gradually extending it as needed.

It seems that each category is modelled by a "class" (for code-centric
information, this seems a reasonable choice). However, inheritance isn't used to
express edges (they wouldn not be sufficient anyway, since "subclass of" arrows
don't carry labels). Instead, "axioms" are indicated by class attributes on the
more general category, where the name of the attribute provides the axiom label
and the value is the category obtained from adding the axiom.

**Potential Problem:** Implementing a labelled digraph using dictionaries is a
very natural one, but here we have a bit of a mess: the outgoing edges are mixed
in to a dictionary that has all kinds of other stuff in it too. For instance,
getting a list of which axioms are "implemented" for a category involves
iterating over the `class.__dict__` and filtering on which attributes are axioms
and which are other methods. How do we tell the difference? By name? How about
name clashes?

**Unusual:** It is rare that callables are bound to an attribute that doesn't
bear their (unqualified) name. It's not unheard of, though.

The "lazy loading" requirement is implemented by choosing for every category a
preferred (basecategory,axiom) pair through which it can be obtained. The class
attribute corresponding to that edge is implemented by a `LazyImport` link
rather than putting the actual class there.

**Question:** At this point, it seems unnecessary to do this only for a
preferred edge. Each `LazyImport` would need to be called once to resolve, but
if the import in question has already happened then the result should just be
that the LazyImport removes itself from the story (provided the LazyImport has
the right references to take itself out of the relevant dictionary).

It also seems to be useful to have a link from a category to the categories from
which is can be obtained. Oddly enough, the system insists on having a single
main (category,axiom) pair through which it can be obtained, even though the
original graph we're modelling doesn't have any such concept

**Question:** Why do we need `_base_category_and_axiom` at all? It seems very
unnatural: there are many ways in which a category can be obtained by adding an
extra axiom to another category. Indeed, there are `extra_super_categories`. Why
are they separate? Should we just have a set of `(base_category,axiom)` pairs?

**Question:** (for lazy loading) given that categories refer to their super
categories, is it indeed the case that loading a category will imply loading the
entire "inbound component" (all vertices that have a path to this one)? It is
not entirely clear to me how they get that info. Is that a combination of a name
mangling search and hard-wiring the connections? 

**Question:** Is there always just one axiom to add to go from one category to another?
Wouldn't there be useless nodes in the graph then (partial axiom combinations
that no-one is interested in)?

In short, I think the current problems are mainly coming from an imposed
asymmetry: the introduction of a "main" `(base_category,axiom)` pair.
Additionally, the lazy loading issue only becomes complicated because the
derived categories insist on knowing what their direct supercategories are. If
we wouldn't need that then just the lazy imports would do the trick.

If we do need categories to know their supercategories, then there is indeed a
problem of how to get that information. Name mangling doesn't do the trick,
because that only works for a rooted tree. We need to be able to express an
(acyclic)digraph (I don't think we get any mileage out of the acyclic bit).

If you really want a single point of truth, I don't see an alternative to
Simon's suggestion a bit list of:

```
("base category", "axiom", "resulting category")
```
triples, where the entries are indeed strings, and a nasty (meta?)metaclass on
categories that looks up all the entries with base category occurring, to put in
the appropriate `LazyImport` bindings and a look up of the `resulting category`
entries to put the links back in the super_category attribute.

Another point that's a little dirty presently is that the axiom callables are
mixed in with all the other class attributes. That could easily cause name
clashes. I would almost say that instead of

```
Algebras(GF(5)).FiniteDimensional()
```
it would be preferable to do

```
Algebras(GF(5)).with_axiom("FiniteDimensional")
```
since that would give the freedom to use a dedicated dictionary.



---

archive/issue_comments_109152.json:
```json
{
    "body": "<a id='comment:7'></a>\nGiven the number of questions poping out recently, I decided this\nmorning that I might as well write the developer's documentation for\naxioms instead of spreading the information in comments on this track\nticket. Beware: so much more work for you to review :-)\n\nI hope it will be convincing about the design decisions and, up to\nsome point, the implementation. It will take me some more time (until\ntomorrow evening maybe?), so don't start hacking around in the mean\ntime!\n\nI can answer right now to Nils last comment though. I believe that\n\n```\nC.FiniteDimensional()\n```\nis *really* better than\n\n```\nC.with_axiom(\"FiniteDimensional\")\n```\n\nRationale:\n\n- This idiom is short, unambiguous and super expressive. Look at the\n  non trivial examples in the primer and see how painful those would\n  be with the _with_axiom idiom. It is backed up by three years of\n  practical usage, and during that period it has appeared, as far as I\n  know, totally natural to all those who played with it.\n\n- It's nice w.r.t. introspection:\n\n  - The axioms of C appear in the tab completion of C. In particular\n    you get an easy access to the list of them.\n\n  - introspection on C.FiniteDimensional gives specific documentation\n    on what each axiom is about.\n\n- It's consistent with what we have been using for years for\n  functorial constructions (Cartesian products, Graded, ...)\n\n- Categories have few operations. So the odds of a name clash is low.\n\n- You can *also* use C._with_axiom(...) if you feel inclined to, for\n  example if the name of the axiom you are interested in is stored in\n  a variable. I am happy to rename C._with_axiom to C.with_axiom if\n  you believe it deserves to be public.\n\n- This idiom does not depend on the actual implementation behind the\n  scene. We could still decide later on to store the links in a\n  database or whatever.\n\nCheers,\n                      Nicolas",
    "created_at": "2014-01-10T00:35:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109152",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:7'></a>
Given the number of questions poping out recently, I decided this
morning that I might as well write the developer's documentation for
axioms instead of spreading the information in comments on this track
ticket. Beware: so much more work for you to review :-)

I hope it will be convincing about the design decisions and, up to
some point, the implementation. It will take me some more time (until
tomorrow evening maybe?), so don't start hacking around in the mean
time!

I can answer right now to Nils last comment though. I believe that

```
C.FiniteDimensional()
```
is *really* better than

```
C.with_axiom("FiniteDimensional")
```

Rationale:

- This idiom is short, unambiguous and super expressive. Look at the
  non trivial examples in the primer and see how painful those would
  be with the _with_axiom idiom. It is backed up by three years of
  practical usage, and during that period it has appeared, as far as I
  know, totally natural to all those who played with it.

- It's nice w.r.t. introspection:

  - The axioms of C appear in the tab completion of C. In particular
    you get an easy access to the list of them.

  - introspection on C.FiniteDimensional gives specific documentation
    on what each axiom is about.

- It's consistent with what we have been using for years for
  functorial constructions (Cartesian products, Graded, ...)

- Categories have few operations. So the odds of a name clash is low.

- You can *also* use C._with_axiom(...) if you feel inclined to, for
  example if the name of the axiom you are interested in is stored in
  a variable. I am happy to rename C._with_axiom to C.with_axiom if
  you believe it deserves to be public.

- This idiom does not depend on the actual implementation behind the
  scene. We could still decide later on to store the links in a
  database or whatever.

Cheers,
                      Nicolas



---

archive/issue_comments_109153.json:
```json
{
    "body": "<a id='comment:368'></a>\nNicolas:\n\nReplying to [nthiery](#comment%3A367):\n> Given the number of questions poping out recently, I decided this\n> morning that I might as well write the developer's documentation for\n> axioms instead of spreading the information in comments on this track\n> ticket.\n\nThank you!!",
    "created_at": "2014-01-10T09:54:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109153",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:368'></a>
Nicolas:

Replying to [nthiery](#comment%3A367):
> Given the number of questions poping out recently, I decided this
> morning that I might as well write the developer's documentation for
> axioms instead of spreading the information in comments on this track
> ticket.

Thank you!!



---

archive/issue_comments_109154.json:
```json
{
    "body": "<a id='comment:9'></a>\nI have just pushed a first step on `u/nthiery/ticket/10963`\n(extended primer on axioms). Lunch and then documentation of how to\nimplement axioms ...\n\nPS: do we have a trac role for referencing git branches?",
    "created_at": "2014-01-10T11:28:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109154",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:9'></a>
I have just pushed a first step on `u/nthiery/ticket/10963`
(extended primer on axioms). Lunch and then documentation of how to
implement axioms ...

PS: do we have a trac role for referencing git branches?



---

archive/issue_comments_109155.json:
```json
{
    "body": "<a id='comment:370'></a>\nReplying to [nthiery](#comment%3A369):\n> I have just pushed a first step on `u/nthiery/ticket/10963`\n> (extended primer on axioms). Lunch and then documentation of how to\n> implement axioms ...\n\nI'm looking forward to it. Can you also link to a readily typeset version of this documentation? I'm mainly interested in reading it, not so much building it.",
    "created_at": "2014-01-10T15:31:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109155",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:370'></a>
Replying to [nthiery](#comment%3A369):
> I have just pushed a first step on `u/nthiery/ticket/10963`
> (extended primer on axioms). Lunch and then documentation of how to
> implement axioms ...

I'm looking forward to it. Can you also link to a readily typeset version of this documentation? I'm mainly interested in reading it, not so much building it.



---

archive/issue_comments_109156.json:
```json
{
    "body": "<a id='comment:1'></a>\n> Can you also link to a readily typeset version of this documentation? I'm mainly interested in reading it, not so much building it. \n\nThere it is:\n\nhttp://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/category_with_axiom.html\n\nIn progress, ...",
    "created_at": "2014-01-10T17:38:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109156",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:1'></a>
> Can you also link to a readily typeset version of this documentation? I'm mainly interested in reading it, not so much building it. 

There it is:

http://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/category_with_axiom.html

In progress, ...



---

archive/issue_comments_109157.json:
```json
{
    "body": "<a id='comment:2'></a>\nProgress in the documentation:\n\n- implementing new axioms\n- handling multiple axioms, and tree structure of the classes\n- recovering the class of a category with axiom to add new code\n\nI am not sure I'll be able to make more progress over the week-end.",
    "created_at": "2014-01-11T00:31:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109157",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:2'></a>
Progress in the documentation:

- implementing new axioms
- handling multiple axioms, and tree structure of the classes
- recovering the class of a category with axiom to add new code

I am not sure I'll be able to make more progress over the week-end.



---

archive/issue_comments_109158.json:
```json
{
    "body": "<a id='comment:3'></a>\nI am reading the documentation of axioms, which begins by saying that one should first be used to the doc of axioms in the category primer... which is probably contained in this very patch too. Even though I cannot find where.\n\nWell, this just to say that there seems to be something wrong with the first two examples  of Sage code in the section entitled \"Difference between axioms and regressive covariant functorial constructions\" of the following doc : http://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/primer.html#category-primer-axioms\n\nNathann",
    "created_at": "2014-01-12T15:24:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109158",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:3'></a>
I am reading the documentation of axioms, which begins by saying that one should first be used to the doc of axioms in the category primer... which is probably contained in this very patch too. Even though I cannot find where.

Well, this just to say that there seems to be something wrong with the first two examples  of Sage code in the section entitled "Difference between axioms and regressive covariant functorial constructions" of the following doc : http://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/primer.html#category-primer-axioms

Nathann



---

archive/issue_comments_109159.json:
```json
{
    "body": "<a id='comment:4'></a>\nIn the same page, there is a broken link, in \"Each category should come with a good example, in sage.categories.examples\". If you want to avoid that, you can use the `--warn-links` flag when compiling the doc. Broken links will appear as warnings, it's totally cool.\n\nBesides, it seems very easy to intersect properties (axioms). Isn't there any need to *remove* axioms from time to time ? And is there a way to do it ?\n\nNathann",
    "created_at": "2014-01-12T15:29:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109159",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:4'></a>
In the same page, there is a broken link, in "Each category should come with a good example, in sage.categories.examples". If you want to avoid that, you can use the `--warn-links` flag when compiling the doc. Broken links will appear as warnings, it's totally cool.

Besides, it seems very easy to intersect properties (axioms). Isn't there any need to *remove* axioms from time to time ? And is there a way to do it ?

Nathann



---

archive/issue_comments_109160.json:
```json
{
    "body": "<a id='comment:5'></a>\nHi Nicholas,\n\nGreat work writing up the documentation. It's very accessibly written and very friendly in tone. I see you're not done yet. One (in my view major) point I don't see addressed yet:\n\n**base_category**:\nWhile you argue why the code is *written* like a (spanning) tree of the acyclic digraph, I don't see it argued why it needs to be reflected in further data structures. In particular, I don't see why \"base_category\" is necessary at all. Surely we need to know what the super categories are, but I don't see why one needs to be preferred.\n\nIn fact, as soon as classes get implemented in their own module rather than as a nested class, there isn't a natural tree structure anyway.\n\n\nApart from that some minor comments about coding conventions and class use.\n\n**old style classes**: If you type `class ElementMethods:`, you create a nested class that is an old-style class in python 2. Since you're basically only interested in `ElementMethods.__dict__` anyway, this is perhaps not such an issue. Old-style classes have some semantic differences. I don't know if they have any significant performance differences, and probably they don't have any performance differences that matter for your very limited application.\n\n**nested classes**: are a little strange in python. The syntax suggests the class would become a kind of closure with the enveloping class as scope closed over. That is *not* the case, however, which is probably good for your purposes. It's one reason why nested classes aren't very popular, however: they add an extra indentation level and they aren't any different from a separate class, even though the lexical context might suggest differently. So I'd lean towards *not* nesting axiom classes. At the cost of one attribute assignment `Finite=FiniteGroups` (or something like that), you're being spared extra indentation on *many* lines. It probably also makes the code easier to read for people who don't usually use a code-folding editor.",
    "created_at": "2014-01-12T19:51:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109160",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:5'></a>
Hi Nicholas,

Great work writing up the documentation. It's very accessibly written and very friendly in tone. I see you're not done yet. One (in my view major) point I don't see addressed yet:

**base_category**:
While you argue why the code is *written* like a (spanning) tree of the acyclic digraph, I don't see it argued why it needs to be reflected in further data structures. In particular, I don't see why "base_category" is necessary at all. Surely we need to know what the super categories are, but I don't see why one needs to be preferred.

In fact, as soon as classes get implemented in their own module rather than as a nested class, there isn't a natural tree structure anyway.


Apart from that some minor comments about coding conventions and class use.

**old style classes**: If you type `class ElementMethods:`, you create a nested class that is an old-style class in python 2. Since you're basically only interested in `ElementMethods.__dict__` anyway, this is perhaps not such an issue. Old-style classes have some semantic differences. I don't know if they have any significant performance differences, and probably they don't have any performance differences that matter for your very limited application.

**nested classes**: are a little strange in python. The syntax suggests the class would become a kind of closure with the enveloping class as scope closed over. That is *not* the case, however, which is probably good for your purposes. It's one reason why nested classes aren't very popular, however: they add an extra indentation level and they aren't any different from a separate class, even though the lexical context might suggest differently. So I'd lean towards *not* nesting axiom classes. At the cost of one attribute assignment `Finite=FiniteGroups` (or something like that), you're being spared extra indentation on *many* lines. It probably also makes the code easier to read for people who don't usually use a code-folding editor.



---

archive/issue_comments_109161.json:
```json
{
    "body": "<a id='comment:376'></a>\nReplying to [ncohen](#comment%3A373):\n> I am reading the documentation of axioms, which begins by saying that one should first be used to the doc of axioms in the category primer... which is probably contained in this very patch too. Even though I cannot find where.\n\nI am confused. Are you looking at http://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/category_with_axiom.html#module-sage.categories.category_with_axiom? Doesn't it start with links to the primer and the appropriate section there?\n\n> Well, this just to say that there seems to be something wrong with the first two examples  of Sage code in the section entitled \"Difference between axioms and regressive covariant functorial constructions\" of the following doc : http://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/primer.html#category-primer-axiom\n\nYou mean that they are not framed as Sage examples? Thanks for spotting this! I had indeed forgotten the ::. Fixed on my machine; it will be in the next commit.",
    "created_at": "2014-01-13T22:28:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109161",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:376'></a>
Replying to [ncohen](#comment%3A373):
> I am reading the documentation of axioms, which begins by saying that one should first be used to the doc of axioms in the category primer... which is probably contained in this very patch too. Even though I cannot find where.

I am confused. Are you looking at http://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/category_with_axiom.html#module-sage.categories.category_with_axiom? Doesn't it start with links to the primer and the appropriate section there?

> Well, this just to say that there seems to be something wrong with the first two examples  of Sage code in the section entitled "Difference between axioms and regressive covariant functorial constructions" of the following doc : http://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/primer.html#category-primer-axiom

You mean that they are not framed as Sage examples? Thanks for spotting this! I had indeed forgotten the ::. Fixed on my machine; it will be in the next commit.



---

archive/issue_comments_109162.json:
```json
{
    "body": "<a id='comment:377'></a>\nReplying to [ncohen](#comment%3A374):\n> In the same page, there is a broken link, in \"Each category should come with a good example, in sage.categories.examples\".\n\nThanks for the reminder. I was wondering about this. At this point, the module sage.categories.examples bears no documentation (like most modules corresponding to directories in Sage). In such a case is it better to not put a link, or put one in case someone would later add documentation? Well, ok, or add doc there, but I am not sure what would be useful to say.\n\n>  If you want to avoid that, you can use the `--warn-links` flag when compiling the doc. Broken links will appear as warnings, it's totally cool.\n\nYup; I'll run that. I just don't promise I'll fix here those links that were previously broken.\n\n> Besides, it seems very easy to intersect properties (axioms). Isn't there any need to *remove* axioms from time to time ? And is there a way to do it ?\n\nYou have the _without_axiom method. It works stupidly by removing all axioms and then reinserting all but the one you mentionned. It's not super robust though, since some combinations of axioms may imply others and thus you might get back the original category as in:\n\n```\nsage: F = FiniteFields()\nsage: F._without_axiom(\"Commutative\")\nCategory of finite fields\n```\n\nSince I had only very little use cases for this method, I left it as private for now until one will get a clearer idea of the precise semantic we want.\n\nCheers,\n                                    Nicolas",
    "created_at": "2014-01-13T22:35:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109162",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:377'></a>
Replying to [ncohen](#comment%3A374):
> In the same page, there is a broken link, in "Each category should come with a good example, in sage.categories.examples".

Thanks for the reminder. I was wondering about this. At this point, the module sage.categories.examples bears no documentation (like most modules corresponding to directories in Sage). In such a case is it better to not put a link, or put one in case someone would later add documentation? Well, ok, or add doc there, but I am not sure what would be useful to say.

>  If you want to avoid that, you can use the `--warn-links` flag when compiling the doc. Broken links will appear as warnings, it's totally cool.

Yup; I'll run that. I just don't promise I'll fix here those links that were previously broken.

> Besides, it seems very easy to intersect properties (axioms). Isn't there any need to *remove* axioms from time to time ? And is there a way to do it ?

You have the _without_axiom method. It works stupidly by removing all axioms and then reinserting all but the one you mentionned. It's not super robust though, since some combinations of axioms may imply others and thus you might get back the original category as in:

```
sage: F = FiniteFields()
sage: F._without_axiom("Commutative")
Category of finite fields
```

Since I had only very little use cases for this method, I left it as private for now until one will get a clearer idea of the precise semantic we want.

Cheers,
                                    Nicolas



---

archive/issue_comments_109163.json:
```json
{
    "body": "<a id='comment:378'></a>\nReplying to [nbruin](#comment%3A375):\n> Great work writing up the documentation. It's very accessibly written and very friendly in tone.\n\nThanks :-)\n\n> I see you're not done yet.\n\nYup. I'll be back to it tomorrow morning.\n\n> One (in my view major) point I don't see addressed yet:\n> \n> **base_category**:\n> While you argue why the code is *written* like a (spanning) tree of the acyclic digraph, I don't see it argued why it needs to be reflected in further data structures. In particular, I don't see why \"base_category\" is necessary at all. Surely we need to know what the super categories are, but I don't see why one needs to be preferred.\n\n``base_category`` is used in a few spots for computing stuff\nrecursively. This is includes _without_axioms (a trivial recursion),\nand more importantly the calculations of the super categories (a\ntricky recursion).\n\nI agree that this is mostly for internal use. But it's consistent with\nfunctorial constructions and the like to have the .base_category() method.\n\n> In fact, as soon as classes get implemented in their own module rather than as a nested class, there isn't a natural tree structure anyway.\n\nThe tree structure is still there, given by the links\n\"Finite=...\". And it is used extensively by the underlying\nalgorithmic.\n\n> **old style classes**: If you type `class ElementMethods:`, you create a nested class that is an old-style class in python 2. Since you're basically only interested in `ElementMethods.__dict__` anyway, this is perhaps not such an issue. Old-style classes have some semantic differences. I don't know if they have any significant performance differences, and probably they don't have any performance differences that matter for your very limited application.\n\nYup. We have been using ElementMethods and friends since 2009 while\nbeing aware of this artifact. As you mention, those are just bags of\nmethods and the semantic difference does not pop up in practice (well,\nit did once, but it was trivial).\n\n> **nested classes**: are a little strange in python. The syntax suggests the class would become a kind of closure with the enveloping class as scope closed over. That is *not* the case, however, which is probably good for your purposes. It's one reason why nested classes aren't very popular, however: they add an extra indentation level and they aren't any different from a separate class, even though the lexical context might suggest differently. So I'd lean towards *not* nesting axiom classes. At the cost of one attribute assignment `Finite=FiniteGroups` (or something like that), you're being spared extra indentation on *many* lines. It probably also makes the code easier to read for people who don't usually use a code-folding editor.\n\nWell, we have been using extensively nested classes from the beginning\nof the category code in late 2008. It really helps seeing the\nstructure of the code. See magmas.py for an example. Maybe it's time\nto advertise them more to the Python community :-)\n\nI agree that we should not nest too much for the indentation to not\nbecome too large; which is why I want the code to support both nesting\nand links to other files or elsewhere.\n\nI agree that code-folding is a killer tool there. And I am blaming\nemacs everyday for not supporting it easily. But I still managed\nwriting quite some category code without it :-)\n\nCheers,\n                            Nicolas",
    "created_at": "2014-01-13T23:11:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109163",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:378'></a>
Replying to [nbruin](#comment%3A375):
> Great work writing up the documentation. It's very accessibly written and very friendly in tone.

Thanks :-)

> I see you're not done yet.

Yup. I'll be back to it tomorrow morning.

> One (in my view major) point I don't see addressed yet:
> 
> **base_category**:
> While you argue why the code is *written* like a (spanning) tree of the acyclic digraph, I don't see it argued why it needs to be reflected in further data structures. In particular, I don't see why "base_category" is necessary at all. Surely we need to know what the super categories are, but I don't see why one needs to be preferred.

``base_category`` is used in a few spots for computing stuff
recursively. This is includes _without_axioms (a trivial recursion),
and more importantly the calculations of the super categories (a
tricky recursion).

I agree that this is mostly for internal use. But it's consistent with
functorial constructions and the like to have the .base_category() method.

> In fact, as soon as classes get implemented in their own module rather than as a nested class, there isn't a natural tree structure anyway.

The tree structure is still there, given by the links
"Finite=...". And it is used extensively by the underlying
algorithmic.

> **old style classes**: If you type `class ElementMethods:`, you create a nested class that is an old-style class in python 2. Since you're basically only interested in `ElementMethods.__dict__` anyway, this is perhaps not such an issue. Old-style classes have some semantic differences. I don't know if they have any significant performance differences, and probably they don't have any performance differences that matter for your very limited application.

Yup. We have been using ElementMethods and friends since 2009 while
being aware of this artifact. As you mention, those are just bags of
methods and the semantic difference does not pop up in practice (well,
it did once, but it was trivial).

> **nested classes**: are a little strange in python. The syntax suggests the class would become a kind of closure with the enveloping class as scope closed over. That is *not* the case, however, which is probably good for your purposes. It's one reason why nested classes aren't very popular, however: they add an extra indentation level and they aren't any different from a separate class, even though the lexical context might suggest differently. So I'd lean towards *not* nesting axiom classes. At the cost of one attribute assignment `Finite=FiniteGroups` (or something like that), you're being spared extra indentation on *many* lines. It probably also makes the code easier to read for people who don't usually use a code-folding editor.

Well, we have been using extensively nested classes from the beginning
of the category code in late 2008. It really helps seeing the
structure of the code. See magmas.py for an example. Maybe it's time
to advertise them more to the Python community :-)

I agree that we should not nest too much for the indentation to not
become too large; which is why I want the code to support both nesting
and links to other files or elsewhere.

I agree that code-folding is a killer tool there. And I am blaming
emacs everyday for not supporting it easily. But I still managed
writing quite some category code without it :-)

Cheers,
                            Nicolas



---

archive/issue_comments_109164.json:
```json
{
    "body": "<a id='comment:379'></a>\nReplying to [nthiery](#comment%3A378):\n> The tree structure is still there, given by the links\n> \"Finite=...\". And it is used extensively by the underlying\n> algorithmic.\n\nNo, that's my point. Both `Fields.Finite` and `DivisionRings.Finite` can point at the same category (and I think they could both do that via a properly formatted lazy import proxy if required). Then there's no tree structure. I haven't seen a convincing reason yet why you need to bless one (in this case probably `Fields.Finite`) as the main link. You may well have a convincing reason, in which case you should mention it. If there is no convincing reason we should start deemphasizing it. The data that you're modelling doesn't intrinsically imply a spanning tree, so if we can avoid putting it in, we'd probably be better off.",
    "created_at": "2014-01-14T01:48:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109164",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:379'></a>
Replying to [nthiery](#comment%3A378):
> The tree structure is still there, given by the links
> "Finite=...". And it is used extensively by the underlying
> algorithmic.

No, that's my point. Both `Fields.Finite` and `DivisionRings.Finite` can point at the same category (and I think they could both do that via a properly formatted lazy import proxy if required). Then there's no tree structure. I haven't seen a convincing reason yet why you need to bless one (in this case probably `Fields.Finite`) as the main link. You may well have a convincing reason, in which case you should mention it. If there is no convincing reason we should start deemphasizing it. The data that you're modelling doesn't intrinsically imply a spanning tree, so if we can avoid putting it in, we'd probably be better off.



---

archive/issue_comments_109165.json:
```json
{
    "body": "<a id='comment:0'></a>\nSo I read the documentation and it does a pretty good job of explaining what is going on. The goals are very nice and I totally agree with you. I didn't see it spelled how and what kind of identities between different categories with axioms can be found automaticaly. It seems that this is about the same problem as normal form for toric ideals so there needs to be some decision about monomials / axiom orderings.\n\nBut thats not what I really want to bring up. I'm also more and more convinced that the whole \"axioms as strings\" is an absolutely terrible implementation. The very first example:\n\n```python\nsage: class Cs(Category):\n....:     def super_categories(self):\n....:         return [Sets()]\n....:     class Finite(CategoryWithAxiom):\n....:         class ParentMethods:\n....:             def foo(self):\n....:                 print \"I am a method on finite C's\"\n```\nimplements\n\n```python\nsage: P = Parent(category=Cs().Finite())\nsage: P.foo()           # ok, nice\nI am a method on finite C's\nsage: P.is_finite()     # What is this I don't even \nTrue\n```\nFrom a Python programmer's perspective, the fact that class names get parsed under the hood is just about entirely unexpected. Sure its possible to implement, but it is also entirely opposite of Python best practices. I don't even want to bring up the poor guy who'll try this with \"Endlich\" instead of \"Finite\" as a class name and be in for a surprise.\n\nSlightly different angle, same problem IMHO:\n\n```\nsage: Cs().Finite().super_categories()         # ok, nice\n[Category of finite sets, Category of cs]     \nsage: Cs().Finite().axioms()                   # really, this is the best we can do?\nfrozenset(['Finite'])\n```\nAxioms are at the end of the day the analog of mixins in the category framework, and as such implemented as classes. Just return the classes. This should be obvious.",
    "created_at": "2014-01-14T03:22:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109165",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:0'></a>
So I read the documentation and it does a pretty good job of explaining what is going on. The goals are very nice and I totally agree with you. I didn't see it spelled how and what kind of identities between different categories with axioms can be found automaticaly. It seems that this is about the same problem as normal form for toric ideals so there needs to be some decision about monomials / axiom orderings.

But thats not what I really want to bring up. I'm also more and more convinced that the whole "axioms as strings" is an absolutely terrible implementation. The very first example:

```python
sage: class Cs(Category):
....:     def super_categories(self):
....:         return [Sets()]
....:     class Finite(CategoryWithAxiom):
....:         class ParentMethods:
....:             def foo(self):
....:                 print "I am a method on finite C's"
```
implements

```python
sage: P = Parent(category=Cs().Finite())
sage: P.foo()           # ok, nice
I am a method on finite C's
sage: P.is_finite()     # What is this I don't even 
True
```
From a Python programmer's perspective, the fact that class names get parsed under the hood is just about entirely unexpected. Sure its possible to implement, but it is also entirely opposite of Python best practices. I don't even want to bring up the poor guy who'll try this with "Endlich" instead of "Finite" as a class name and be in for a surprise.

Slightly different angle, same problem IMHO:

```
sage: Cs().Finite().super_categories()         # ok, nice
[Category of finite sets, Category of cs]     
sage: Cs().Finite().axioms()                   # really, this is the best we can do?
frozenset(['Finite'])
```
Axioms are at the end of the day the analog of mixins in the category framework, and as such implemented as classes. Just return the classes. This should be obvious.



---

archive/issue_comments_109166.json:
```json
{
    "body": "<a id='comment:381'></a>\nYooooooo !!\n\n> You have the _without_axiom method.\n\n>\n> Since I had only very little use cases for this method, I left it as private for now until one will get a clearer idea of the precise semantic we want.\n\nOkayokay. And about your confusion above : I was looking for the code, not for the doc. I wondered where this doc was actually implemented. I didn't even know if it came from this patch or some other place `^^;`\n\nNathann",
    "created_at": "2014-01-14T09:12:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109166",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:381'></a>
Yooooooo !!

> You have the _without_axiom method.

>
> Since I had only very little use cases for this method, I left it as private for now until one will get a clearer idea of the precise semantic we want.

Okayokay. And about your confusion above : I was looking for the code, not for the doc. I wondered where this doc was actually implemented. I didn't even know if it came from this patch or some other place `^^;`

Nathann



---

archive/issue_comments_109167.json:
```json
{
    "body": "<a id='comment:382'></a>\nReplying to [vbraun](#comment%3A380):\n> Axioms are at the end of the day the analog of mixins in the category framework, and as such implemented as classes. Just return the classes. This should be obvious.\n\nI'm not entirely sure this is true presently. While `Groups.Finite` points to a\nclass (category) `FiniteGroups` (or really just at the class named\n`Groups.Finite` if written as a nested class), the class `Sets.Finite` is also\nautomatically picked up, and if I'm not mistaken that's one of the features of\naxioms: if they can, they get applied to supercategories as well. The class\n`FiniteSets` and the class `FiniteGroups` are quite probably distinct classes,\nso there is no single class that symbolizes the `Finite` axiom, yet it is\nrelevant that `FiniteGroups` resp. `FiniteSets` are obtained from `Groups` resp.\n`Sets` by applying the *same* axiom. The label that signifies this is\ncurrently the string `\"Finite\"`. From an implementation point of view I think\nit's confusing to abuse the class type `__dict__` to document this fact, but\nNicholas does illustrate how the abuse leads to easy to write classes.\n\nEssentially, Nicholas has selected a bunch of special method names (such as\ndundermethods `__len__`, `__get__` etc) and blessed them to be \"axioms\", which\nreceive special treatment: If a category implements one of those then this axiom\ncan be \"applied\" to this category. It does mean the documentation should have an\nexhaustive list of what method names are considered `axioms` and introducing new\naxioms would be subject to name clash warnings (we wouldn't want to break code\nout there that already gives a non-axiom meaning to an attribute).\n\nI think that if we're staying with this pattern, we should announce some rule:\non categories, any method name starting with a capital is in principle reserved\nto be used as an axiom or functorial construction. We should probably also\ninclude some guidelines how users should go about implementing their own\nnon-library axioms in a way that is likely to work with future versions, or\ndeclare that such a thing is not guaranteed (meaning Categories do not implement\nan \"open protocol\" but are entirely meant to be internals of sage).",
    "created_at": "2014-01-14T17:19:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109167",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:382'></a>
Replying to [vbraun](#comment%3A380):
> Axioms are at the end of the day the analog of mixins in the category framework, and as such implemented as classes. Just return the classes. This should be obvious.

I'm not entirely sure this is true presently. While `Groups.Finite` points to a
class (category) `FiniteGroups` (or really just at the class named
`Groups.Finite` if written as a nested class), the class `Sets.Finite` is also
automatically picked up, and if I'm not mistaken that's one of the features of
axioms: if they can, they get applied to supercategories as well. The class
`FiniteSets` and the class `FiniteGroups` are quite probably distinct classes,
so there is no single class that symbolizes the `Finite` axiom, yet it is
relevant that `FiniteGroups` resp. `FiniteSets` are obtained from `Groups` resp.
`Sets` by applying the *same* axiom. The label that signifies this is
currently the string `"Finite"`. From an implementation point of view I think
it's confusing to abuse the class type `__dict__` to document this fact, but
Nicholas does illustrate how the abuse leads to easy to write classes.

Essentially, Nicholas has selected a bunch of special method names (such as
dundermethods `__len__`, `__get__` etc) and blessed them to be "axioms", which
receive special treatment: If a category implements one of those then this axiom
can be "applied" to this category. It does mean the documentation should have an
exhaustive list of what method names are considered `axioms` and introducing new
axioms would be subject to name clash warnings (we wouldn't want to break code
out there that already gives a non-axiom meaning to an attribute).

I think that if we're staying with this pattern, we should announce some rule:
on categories, any method name starting with a capital is in principle reserved
to be used as an axiom or functorial construction. We should probably also
include some guidelines how users should go about implementing their own
non-library axioms in a way that is likely to work with future versions, or
declare that such a thing is not guaranteed (meaning Categories do not implement
an "open protocol" but are entirely meant to be internals of sage).



---

archive/issue_comments_109168.json:
```json
{
    "body": "<a id='comment:3'></a>\nI agree with Nils, but imho that is just another way of spelling out the problem. What does adding the *Finite* axiom actually mean if I want to apply it to a category that I'm using/writing?  I can guess that it gives me a `is_finite()` method returning `True`, but confusingly that is implemented in some category. Anything else? How can I use code introspection (one of Pythons absolute strong points) to find out what is going on? I can't, because all I got is this string to represent the axiom. Axioms should be **code** (classes) with some protocol for how they are used to enrich categories.\n\nSlightly related, I don't like the `_base_category_class_and_axiom` attribute. A heterogeneous list with some convention to treat the first element special is a terrible data structure. Just split it up into `_base_category_class` and `_axioms`.",
    "created_at": "2014-01-14T18:09:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109168",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:3'></a>
I agree with Nils, but imho that is just another way of spelling out the problem. What does adding the *Finite* axiom actually mean if I want to apply it to a category that I'm using/writing?  I can guess that it gives me a `is_finite()` method returning `True`, but confusingly that is implemented in some category. Anything else? How can I use code introspection (one of Pythons absolute strong points) to find out what is going on? I can't, because all I got is this string to represent the axiom. Axioms should be **code** (classes) with some protocol for how they are used to enrich categories.

Slightly related, I don't like the `_base_category_class_and_axiom` attribute. A heterogeneous list with some convention to treat the first element special is a terrible data structure. Just split it up into `_base_category_class` and `_axioms`.



---

archive/issue_comments_109169.json:
```json
{
    "body": "<a id='comment:4'></a>\nI just pushed two new sections on axioms depending on other axioms and on deduction rules.\n\nI'll answer your comments later tonight. Thanks for them, they are making me thing on how to best present the material. Thanks Jean-Baptiste for some profreading too!\n\nCheers,\n     Nicolas",
    "created_at": "2014-01-14T18:10:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109169",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:4'></a>
I just pushed two new sections on axioms depending on other axioms and on deduction rules.

I'll answer your comments later tonight. Thanks for them, they are making me thing on how to best present the material. Thanks Jean-Baptiste for some profreading too!

Cheers,
     Nicolas



---

archive/issue_comments_109170.json:
```json
{
    "body": "<a id='comment:385'></a>\nReplying to [nbruin](#comment%3A382):\n> I'm not entirely sure this is true presently. While `Groups.Finite` points to a\n> class (category) `FiniteGroups` (or really just at the class named\n> `Groups.Finite` if written as a nested class), the class `Sets.Finite` is also\n> automatically picked up, and if I'm not mistaken that's one of the features of\n> axioms: if they can, they get applied to supercategories as well. The class\n> `FiniteSets` and the class `FiniteGroups` are quite probably distinct classes,\n> so there is no single class that symbolizes the `Finite` axiom, yet it is\n> relevant that `FiniteGroups` resp. `FiniteSets` are obtained from `Groups` resp.\n> `Sets` by applying the *same* axiom.\n\n+1\n\n> The label that signifies this is\n> currently the string `\"Finite\"`. From an implementation point of view I think\n> it's confusing to abuse the class type `__dict__` to document this fact, but\n> Nicholas does illustrate how the abuse leads to easy to write classes.\n\nIt's not a label. Cs() inherits from the Sets category a ``Finite``\nmethod, and it can complement this method with extra data (here a\nmixin class) in the form of a class attribute ``Cs.Finite``. The fact\nthat ``Cs.Finite`` *complements* the ``Finite`` method rather than\n*overriding* is not unnatural: that's what sequences of ``super``\ncalls are usually about.\n\n> Essentially, Nicholas has selected a bunch of special method names (such as\n> dundermethods `__len__`, `__get__` etc) and blessed them to be \"axioms\", which\n> receive special treatment: If a category implements one of those then this axiom\n> can be \"applied\" to this category. It does mean the documentation should have an\n> exhaustive list of what method names are considered `axioms` and introducing new\n> axioms would be subject to name clash warnings (we wouldn't want to break code\n> out there that already gives a non-axiom meaning to an attribute).\n\n>\n> I think that if we're staying with this pattern, we should announce some rule:\n> on categories, any method name starting with a capital is in principle reserved\n> to be used as an axiom or functorial construction. We should probably also\n> include some guidelines how users should go about implementing their own\n> non-library axioms in a way that is likely to work with future versions, or\n> declare that such a thing is not guaranteed (meaning Categories do not implement\n> an \"open protocol\" but are entirely meant to be internals of sage).\n\nNote quite since the definition of an axiom is local to a category and\nits super categories. For example, the category of Modules defines an\naxiom \"Graded\", and this fixes the semantic of Cs.Graded for every\nsubcategory of Modules, but no more. That's no different from usual\nhierarchy of classes: if a class defines (or declares) an attribute or\nmethod with a given name, this fixes the semantic of that name for all\nsubclasses.\n\nTherefore I don't think we need to take any more specific step than if\nwe were implementing usual hierarchies of classes.\n\nOf course, I agree that it's good for consistency to promote the\nconvention that axioms and functorial constructions should start with\na capital. It gives a hint that ``Cs().A()`` is going to construct a\ncategory.\n\nCheers,\n                                    Nicolas",
    "created_at": "2014-01-14T21:48:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109170",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:385'></a>
Replying to [nbruin](#comment%3A382):
> I'm not entirely sure this is true presently. While `Groups.Finite` points to a
> class (category) `FiniteGroups` (or really just at the class named
> `Groups.Finite` if written as a nested class), the class `Sets.Finite` is also
> automatically picked up, and if I'm not mistaken that's one of the features of
> axioms: if they can, they get applied to supercategories as well. The class
> `FiniteSets` and the class `FiniteGroups` are quite probably distinct classes,
> so there is no single class that symbolizes the `Finite` axiom, yet it is
> relevant that `FiniteGroups` resp. `FiniteSets` are obtained from `Groups` resp.
> `Sets` by applying the *same* axiom.

+1

> The label that signifies this is
> currently the string `"Finite"`. From an implementation point of view I think
> it's confusing to abuse the class type `__dict__` to document this fact, but
> Nicholas does illustrate how the abuse leads to easy to write classes.

It's not a label. Cs() inherits from the Sets category a ``Finite``
method, and it can complement this method with extra data (here a
mixin class) in the form of a class attribute ``Cs.Finite``. The fact
that ``Cs.Finite`` *complements* the ``Finite`` method rather than
*overriding* is not unnatural: that's what sequences of ``super``
calls are usually about.

> Essentially, Nicholas has selected a bunch of special method names (such as
> dundermethods `__len__`, `__get__` etc) and blessed them to be "axioms", which
> receive special treatment: If a category implements one of those then this axiom
> can be "applied" to this category. It does mean the documentation should have an
> exhaustive list of what method names are considered `axioms` and introducing new
> axioms would be subject to name clash warnings (we wouldn't want to break code
> out there that already gives a non-axiom meaning to an attribute).

>
> I think that if we're staying with this pattern, we should announce some rule:
> on categories, any method name starting with a capital is in principle reserved
> to be used as an axiom or functorial construction. We should probably also
> include some guidelines how users should go about implementing their own
> non-library axioms in a way that is likely to work with future versions, or
> declare that such a thing is not guaranteed (meaning Categories do not implement
> an "open protocol" but are entirely meant to be internals of sage).

Note quite since the definition of an axiom is local to a category and
its super categories. For example, the category of Modules defines an
axiom "Graded", and this fixes the semantic of Cs.Graded for every
subcategory of Modules, but no more. That's no different from usual
hierarchy of classes: if a class defines (or declares) an attribute or
method with a given name, this fixes the semantic of that name for all
subclasses.

Therefore I don't think we need to take any more specific step than if
we were implementing usual hierarchies of classes.

Of course, I agree that it's good for consistency to promote the
convention that axioms and functorial constructions should start with
a capital. It gives a hint that ``Cs().A()`` is going to construct a
category.

Cheers,
                                    Nicolas



---

archive/issue_comments_109171.json:
```json
{
    "body": "<a id='comment:386'></a>\nReplying to [ncohen](#comment%3A381):\n> Okayokay. And about your confusion above : I was looking for the code, not for the doc. I wondered where this doc was actually implemented. I didn't even know if it came from this patch or some other place `^^;`\n\n:-)",
    "created_at": "2014-01-14T21:49:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109171",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:386'></a>
Replying to [ncohen](#comment%3A381):
> Okayokay. And about your confusion above : I was looking for the code, not for the doc. I wondered where this doc was actually implemented. I didn't even know if it came from this patch or some other place `^^;`

:-)



---

archive/issue_comments_109172.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [vbraun](#comment%3A380):\n> So I read the documentation and it does a pretty good job of explaining what is going on. The goals are very nice and I totally agree with you.\n\nI am glad you appreciate it :-)\n\n> I didn't see it spelled how and what kind of identities between different categories with axioms can be found automaticaly.\n\nThe new section on deduction rules (i.e. mathematical facts encoded\ninto the system) might answer your question. Otherwise, let me know.\n\n> It seems that this is about the same problem as normal form for toric ideals so there needs to be some decision about monomials / axiom orderings.\n\nHmm, I am not sure. It's more about computing recursively a closure\nupon all available deduction rules to derive as much information as\npossible from what's available.\n\n> But thats not what I really want to bring up. I'm also more and more convinced that the whole \"axioms as strings\" is an absolutely terrible implementation. The very first example:\n> \n> ```python\n> sage: class Cs(Category):\n> ....:     def super_categories(self):\n> ....:         return [Sets()]\n> ....:     class Finite(CategoryWithAxiom):\n> ....:         class ParentMethods:\n> ....:             def foo(self):\n> ....:                 print \"I am a method on finite C's\"\n> ```\n> implements\n> \n> ```python\n> sage: P = Parent(category=Cs().Finite())\n> sage: P.foo()           # ok, nice\n> I am a method on finite C's\n> sage: P.is_finite()     # What is this I don't even \n> True\n> ```\n> From a Python programmer's perspective, the fact that class names get parsed under the hood is just about entirely unexpected. Sure its possible to implement, but it is also entirely opposite of Python best practices. I don't even want to bring up the poor guy who'll try this with \"Endlich\" instead of \"Finite\" as a class name and be in for a surprise.\n\nIn the above example, there is no class name parsing. If the name\n``Finite`` is special, that's because Cs is a subcategory of Sets, and\nSets defines the ``Finite`` axiom. Namewise, it's of the same nature\nas implementing in a class a method declared in some superclass. I\njust added a note to make this more explicit in the documentation.\n\n> Slightly different angle, same problem IMHO:\n> \n> ```\n> sage: Cs().Finite().super_categories()         # ok, nice\n> [Category of finite sets, Category of cs]     \n> sage: Cs().Finite().axioms()                   # really, this is the best we can do?\n> frozenset(['Finite'])\n> ```\n> Axioms are at the end of the day the analog of mixins in the category framework, and as such implemented as classes. Just return the classes. This should be obvious.\n\nAs pointed out by Nils, a single axiom (like Finite) corresponds to a\nbunch of mixin classes (Groups.Finite, Crystals.Finite,\nLattices.Finite, ...). Each mixin models a given category with a given\naxiom. Granted, the mixin in the category defining the axiom\n(e.g. Sets.Finite) is a bit special; still it is a category, not the\naxiom itself (mathematically speaking, we make a difference, even just\nin the naming, between the axiom of associativity and the category of\nassociative magmas), so I would not want to model the axiom with it.\n\nNow there is the question of whether we want to model the axioms at\nall with objects (or classes), for example when returning the axioms\nof a category. Honestly, in three years I haven't had a need for it;\nin particular, I did not need to have operations on the axioms. The\nonly relevant operation I could see so far is asking an axiom in which\ncategory it's defined. So for now let's keep it simple.\n\nCheers,\n                            Nicolas",
    "created_at": "2014-01-14T21:51:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109172",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:7'></a>
Replying to [vbraun](#comment%3A380):
> So I read the documentation and it does a pretty good job of explaining what is going on. The goals are very nice and I totally agree with you.

I am glad you appreciate it :-)

> I didn't see it spelled how and what kind of identities between different categories with axioms can be found automaticaly.

The new section on deduction rules (i.e. mathematical facts encoded
into the system) might answer your question. Otherwise, let me know.

> It seems that this is about the same problem as normal form for toric ideals so there needs to be some decision about monomials / axiom orderings.

Hmm, I am not sure. It's more about computing recursively a closure
upon all available deduction rules to derive as much information as
possible from what's available.

> But thats not what I really want to bring up. I'm also more and more convinced that the whole "axioms as strings" is an absolutely terrible implementation. The very first example:
> 
> ```python
> sage: class Cs(Category):
> ....:     def super_categories(self):
> ....:         return [Sets()]
> ....:     class Finite(CategoryWithAxiom):
> ....:         class ParentMethods:
> ....:             def foo(self):
> ....:                 print "I am a method on finite C's"
> ```
> implements
> 
> ```python
> sage: P = Parent(category=Cs().Finite())
> sage: P.foo()           # ok, nice
> I am a method on finite C's
> sage: P.is_finite()     # What is this I don't even 
> True
> ```
> From a Python programmer's perspective, the fact that class names get parsed under the hood is just about entirely unexpected. Sure its possible to implement, but it is also entirely opposite of Python best practices. I don't even want to bring up the poor guy who'll try this with "Endlich" instead of "Finite" as a class name and be in for a surprise.

In the above example, there is no class name parsing. If the name
``Finite`` is special, that's because Cs is a subcategory of Sets, and
Sets defines the ``Finite`` axiom. Namewise, it's of the same nature
as implementing in a class a method declared in some superclass. I
just added a note to make this more explicit in the documentation.

> Slightly different angle, same problem IMHO:
> 
> ```
> sage: Cs().Finite().super_categories()         # ok, nice
> [Category of finite sets, Category of cs]     
> sage: Cs().Finite().axioms()                   # really, this is the best we can do?
> frozenset(['Finite'])
> ```
> Axioms are at the end of the day the analog of mixins in the category framework, and as such implemented as classes. Just return the classes. This should be obvious.

As pointed out by Nils, a single axiom (like Finite) corresponds to a
bunch of mixin classes (Groups.Finite, Crystals.Finite,
Lattices.Finite, ...). Each mixin models a given category with a given
axiom. Granted, the mixin in the category defining the axiom
(e.g. Sets.Finite) is a bit special; still it is a category, not the
axiom itself (mathematically speaking, we make a difference, even just
in the naming, between the axiom of associativity and the category of
associative magmas), so I would not want to model the axiom with it.

Now there is the question of whether we want to model the axioms at
all with objects (or classes), for example when returning the axioms
of a category. Honestly, in three years I haven't had a need for it;
in particular, I did not need to have operations on the axioms. The
only relevant operation I could see so far is asking an axiom in which
category it's defined. So for now let's keep it simple.

Cheers,
                            Nicolas



---

archive/issue_comments_109173.json:
```json
{
    "body": "<a id='comment:388'></a>\nReplying to [vbraun](#comment%3A383):\n> Slightly related, I don't like the `_base_category_class_and_axiom` attribute. A heterogeneous list with some convention to treat the first element special is a terrible data structure. Just split it up into `_base_category_class` and `_axioms`. \n\nI agree it's not so nice. But there is a technicality preventing from\nstoring the base category class by itself in an attribute (see the\nnote at the bottom of the lazy class attribute\n_base_category_class_and_axiom). Well, you could but you'd need to\nwrap it somehow, typically in a tuple. Also handling them together has\na small advantage since they are always set simultaneously, and this\ngives some guarantee of atomicity.\n\nAnyway, it's mostly an internal implementation detail that can be\nrefactored later on if we then decide that there is a better solution;\nand the piece of it that is exposed (when a category implementer\nprovides the attribute) gives a safe idiom.",
    "created_at": "2014-01-14T22:04:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109173",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:388'></a>
Replying to [vbraun](#comment%3A383):
> Slightly related, I don't like the `_base_category_class_and_axiom` attribute. A heterogeneous list with some convention to treat the first element special is a terrible data structure. Just split it up into `_base_category_class` and `_axioms`. 

I agree it's not so nice. But there is a technicality preventing from
storing the base category class by itself in an attribute (see the
note at the bottom of the lazy class attribute
_base_category_class_and_axiom). Well, you could but you'd need to
wrap it somehow, typically in a tuple. Also handling them together has
a small advantage since they are always set simultaneously, and this
gives some guarantee of atomicity.

Anyway, it's mostly an internal implementation detail that can be
refactored later on if we then decide that there is a better solution;
and the piece of it that is exposed (when a category implementer
provides the attribute) gives a safe idiom.



---

archive/issue_comments_109174.json:
```json
{
    "body": "<a id='comment:9'></a>\nYou are parsing the \"Finite\" class name, I don't care if it is explicit using string tools/regexes or implicit looking for classes whose names match certain strings. The usual way is to provide a programmatic interface that sets up stuff in code. You should avoid using strings for program flow, and most certainly not use them for foundational material. I wouldn't care so much if we were talking about some implementation details in the combinat project, but you expect us to go around and teach others to use this. That better have a really good reason for the current interface. **Simple** would be something that follows usual patterns (even if its a few characters more). I don't see anything simple here, I see a bunch of trickery that is extremely hard to understand by looking at the code.  \n\nAnd you don't need operations on axioms? I see a lot of weird stuff in this ticket where you use strings to do operations that would be much clearer if you had some object to represent the axiom. E.g.:\n\n```\nsage: FiniteFields()._without_axiom(\"Commutative\")\n```\nvs.\n\n```\nsage: FiniteFields().without(Commutative())\nsage: FiniteFields() - Commutative()\n```\nIts an absolute no-brainer in Python to model **everything** with objects. Which file implements the commutativity axiom? If I have an object then I can tell immediately. Where is the documentation for the `Commutative` axiom? Lets keep it simple and explicit, yes. Shorter but non-discoverable is most certainly not simpler. And explicit is better than implicit, as always.\n\nAlso, I don't agree with atomicity in setting `_base_category_class_and_axiom` buys us anything. Its private by convention, so it is the job of the setter to make changes atomically if necessary (though thats hardly an issue in Python). But in multi-threaded Java, say, this would be a bad data structure as well. We all know the old joke, whats the only data structure in Cobol? A 2000-character EBCDIC string...",
    "created_at": "2014-01-15T02:41:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109174",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:9'></a>
You are parsing the "Finite" class name, I don't care if it is explicit using string tools/regexes or implicit looking for classes whose names match certain strings. The usual way is to provide a programmatic interface that sets up stuff in code. You should avoid using strings for program flow, and most certainly not use them for foundational material. I wouldn't care so much if we were talking about some implementation details in the combinat project, but you expect us to go around and teach others to use this. That better have a really good reason for the current interface. **Simple** would be something that follows usual patterns (even if its a few characters more). I don't see anything simple here, I see a bunch of trickery that is extremely hard to understand by looking at the code.  

And you don't need operations on axioms? I see a lot of weird stuff in this ticket where you use strings to do operations that would be much clearer if you had some object to represent the axiom. E.g.:

```
sage: FiniteFields()._without_axiom("Commutative")
```
vs.

```
sage: FiniteFields().without(Commutative())
sage: FiniteFields() - Commutative()
```
Its an absolute no-brainer in Python to model **everything** with objects. Which file implements the commutativity axiom? If I have an object then I can tell immediately. Where is the documentation for the `Commutative` axiom? Lets keep it simple and explicit, yes. Shorter but non-discoverable is most certainly not simpler. And explicit is better than implicit, as always.

Also, I don't agree with atomicity in setting `_base_category_class_and_axiom` buys us anything. Its private by convention, so it is the job of the setter to make changes atomically if necessary (though thats hardly an issue in Python). But in multi-threaded Java, say, this would be a bad data structure as well. We all know the old joke, whats the only data structure in Cobol? A 2000-character EBCDIC string...



---

archive/issue_comments_109175.json:
```json
{
    "body": "<a id='comment:390'></a>\nReplying to [vbraun](#comment%3A389):\n> You are parsing the \"Finite\" class name,\n\nThe fact that axioms are represented by a string is a corollary of the fact that\nthe category that results from storing the axiom in an attribute of\nthe supercategory. Attributes are labelled by (interned) strings.\n\nIt seems that axioms by themselves are hardly more than labels (they definitely\ndon't implement something themselves), so I'm not sure something significant is\ngained by introducing another object to model axioms themselves.\n\nAny operations that explicitly depend on axiom labels being strings is less\ndesirable in my eyes, i.e., no mangling please.",
    "created_at": "2014-01-15T07:21:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109175",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:390'></a>
Replying to [vbraun](#comment%3A389):
> You are parsing the "Finite" class name,

The fact that axioms are represented by a string is a corollary of the fact that
the category that results from storing the axiom in an attribute of
the supercategory. Attributes are labelled by (interned) strings.

It seems that axioms by themselves are hardly more than labels (they definitely
don't implement something themselves), so I'm not sure something significant is
gained by introducing another object to model axioms themselves.

Any operations that explicitly depend on axiom labels being strings is less
desirable in my eyes, i.e., no mangling please.



---

archive/issue_comments_109176.json:
```json
{
    "body": "<a id='comment:1'></a>\nI'm not sure what kind of argument you are trying to make with axioms being just labels. Variables are just labels in Python, but we still pass them around. In fact, you could use magic variable names (a.k.a. global variables) for everything, but I think we all agree that this is bad practice. \n\n```\ndef sin():\n    arg = globals().get('x')\n    return math.sin(arg)\n```\nIn fact, since types are just stuff that is assigned to a variable in Python, this is precisely what this ticket does. It establishes a naming convention for types to avoid having to pass them around. And IMHO that is bad practice for exactly the same reasons as global variables.",
    "created_at": "2014-01-15T15:04:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109176",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:1'></a>
I'm not sure what kind of argument you are trying to make with axioms being just labels. Variables are just labels in Python, but we still pass them around. In fact, you could use magic variable names (a.k.a. global variables) for everything, but I think we all agree that this is bad practice. 

```
def sin():
    arg = globals().get('x')
    return math.sin(arg)
```
In fact, since types are just stuff that is assigned to a variable in Python, this is precisely what this ticket does. It establishes a naming convention for types to avoid having to pass them around. And IMHO that is bad practice for exactly the same reasons as global variables.



---

archive/issue_comments_109177.json:
```json
{
    "body": "<a id='comment:2'></a>\nIt really sounds like what you're after Volker is something like Java's `enum` type: labels belonging to some collection (which in this case we can use as flags [ints]). Perhaps we should mimic that with a container class called `Axioms` which has methods (ideal world would be immutable attributes which show up in the documentation) for the various axioms (which we could encode as strings or flgs). I'd almost advocate going a step further with this in that this also stores what axioms are used. So it would work something like this:\n\n```\nsage: F = Fields().with_axiom(Axioms.finite()); F\nFinite fields\nsage: F.axioms()\nAxioms: Finite\n```\nand internally:\n\n```python\n# In Category\n    def with_axiom(axiom):\n        new_axioms = copy(self._axioms).with_axioms([axiom])\n        return ObjectWithAxioms(new_axioms)\n\n# The container class\nclass Axioms(object):\n    def __init__(self, axioms=[]):\n        self._axioms = set(axioms)\n\n    def __repr__(self):\n        return \"Axioms: \" + \", \".join(ax for ax in self._axioms)\n\n    def __iadd__(self, axiom):\n        return self.add_axioms([axiom])\n\n    def __isub__(self, axiom):\n        return self.without_axioms([axiom])\n\n    def with_axioms(self, axioms):\n        # After making sure each axiom is valid\n        self._axioms = self._axioms.union(axioms)\n\n    def without_axioms(self, axioms):\n        self._axioms = self._axioms.difference(axioms)\n\n    @staticmethod\n    def finite():\n        \"\"\"\n        With this we can document what each axiom means and\n        it shows up on tab completion.\n        \"\"\"\n        return \"Finite\"\n\n    @staticmethod\n    def commutative():\n        return \"Commutative\"\n```\n\nAlthough we might want to change the above behavior to act like an immutable object.",
    "created_at": "2014-01-15T16:53:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109177",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>
It really sounds like what you're after Volker is something like Java's `enum` type: labels belonging to some collection (which in this case we can use as flags [ints]). Perhaps we should mimic that with a container class called `Axioms` which has methods (ideal world would be immutable attributes which show up in the documentation) for the various axioms (which we could encode as strings or flgs). I'd almost advocate going a step further with this in that this also stores what axioms are used. So it would work something like this:

```
sage: F = Fields().with_axiom(Axioms.finite()); F
Finite fields
sage: F.axioms()
Axioms: Finite
```
and internally:

```python
# In Category
    def with_axiom(axiom):
        new_axioms = copy(self._axioms).with_axioms([axiom])
        return ObjectWithAxioms(new_axioms)

# The container class
class Axioms(object):
    def __init__(self, axioms=[]):
        self._axioms = set(axioms)

    def __repr__(self):
        return "Axioms: " + ", ".join(ax for ax in self._axioms)

    def __iadd__(self, axiom):
        return self.add_axioms([axiom])

    def __isub__(self, axiom):
        return self.without_axioms([axiom])

    def with_axioms(self, axioms):
        # After making sure each axiom is valid
        self._axioms = self._axioms.union(axioms)

    def without_axioms(self, axioms):
        self._axioms = self._axioms.difference(axioms)

    @staticmethod
    def finite():
        """
        With this we can document what each axiom means and
        it shows up on tab completion.
        """
        return "Finite"

    @staticmethod
    def commutative():
        return "Commutative"
```

Although we might want to change the above behavior to act like an immutable object.



---

archive/issue_comments_109178.json:
```json
{
    "body": "<a id='comment:3'></a>\nHmmmmm... And would there be anything wrong with that ? `:-P`\n\n```\nF = Fields() and axioms.finite()\n```\n\nAnyway I like this `axioms.<tab>` thing. As much as I love all the `thing.<tab>` things.\n\nNathann",
    "created_at": "2014-01-15T17:00:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109178",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:3'></a>
Hmmmmm... And would there be anything wrong with that ? `:-P`

```
F = Fields() and axioms.finite()
```

Anyway I like this `axioms.<tab>` thing. As much as I love all the `thing.<tab>` things.

Nathann



---

archive/issue_comments_109179.json:
```json
{
    "body": "<a id='comment:4'></a>\nAt least implementing a kind of \"axiom enum\" type leverages some of Python's code inspection capabilities. But IMHO there is a reason that it took until Python 3.4 and at least one failed PEP for enums to make it into Python: there are few compelling use cases in a completely dynamic language. You can pass anything to a method and store anything as an attribute, so instead of an enum value you can always use the enumerated thing. And I don't buy that there is no code or data that we could possibly attach to axioms. Why not\n\n```python\nclass Finite(Axiom):\n    class ParentMethods:\n        def is_finite(self): return True\n\nclass Groups(Category):\n    class ParentMethods:\n        @requires_axiom(Finite())\n        def is_finite_group(self): return True\n```",
    "created_at": "2014-01-15T17:51:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109179",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:4'></a>
At least implementing a kind of "axiom enum" type leverages some of Python's code inspection capabilities. But IMHO there is a reason that it took until Python 3.4 and at least one failed PEP for enums to make it into Python: there are few compelling use cases in a completely dynamic language. You can pass anything to a method and store anything as an attribute, so instead of an enum value you can always use the enumerated thing. And I don't buy that there is no code or data that we could possibly attach to axioms. Why not

```python
class Finite(Axiom):
    class ParentMethods:
        def is_finite(self): return True

class Groups(Category):
    class ParentMethods:
        @requires_axiom(Finite())
        def is_finite_group(self): return True
```



---

archive/issue_comments_109180.json:
```json
{
    "body": "<a id='comment:395'></a>\nReplying to [vbraun](#comment%3A391):\n\n> I'm not sure what kind of argument you are trying to make with axioms being\n> just labels. Variables are just labels in Python, but we still pass them around.\n\nWe don't! We normally pass around the values that are bound to them. Passing around\n\"variables\" would necessarily boil down to passing around the strings that can\nthen be looked up in the dictionaries representing the scope bindings to be investigated. THAT is\nindeed what the category code does (it also mangles strings, and that I don't\nlike).\n\n> ```\n> def sin():\n>     arg = globals().get('x')\n>     return math.sin(arg)\n> ```\n\nI think this is fundamentally different from what is happening in this code. A\ndirect corollary of storing the subcategory obtained by applying an axiom to a\nsupercategory in an attribute labelled with the axiom name is that at least at\nsome point axioms are represented by a string.\n\nIt seems the strongest motivation (and a convincing one to me) for storing\nsubcategories in attributes is that it allows leveraging Python's syntax for\nwriting classes and attributes. Given that implementation, axioms are\nrepresented by a string at some point. Do we need another representation as\nwell? \n\nIf you take \"applying an axiom to a category\" literally, then basically the\nimplementation\n\n```\ndef Finite(category):\n    return category.Finite()\n    #or, to illustrate where the string is living:\n    #return getattr(category,\"Finite\")()\n```\nwould do the trick. There'd be room for documentation on that, but really there\nis not much to document. Checking whether a given axiom is applicable boils down\nto eventually\n\n```\ndef has_axiom(category,axiom):\n    return hasattr(category,string_corresponding_to(axiom))\n```\nwhere the implementation of `string_corresponding_to` is simplest if `axiom`\nitself is already given by a string. What do we gain from representing axioms\notherwise?",
    "created_at": "2014-01-15T18:39:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109180",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:395'></a>
Replying to [vbraun](#comment%3A391):

> I'm not sure what kind of argument you are trying to make with axioms being
> just labels. Variables are just labels in Python, but we still pass them around.

We don't! We normally pass around the values that are bound to them. Passing around
"variables" would necessarily boil down to passing around the strings that can
then be looked up in the dictionaries representing the scope bindings to be investigated. THAT is
indeed what the category code does (it also mangles strings, and that I don't
like).

> ```
> def sin():
>     arg = globals().get('x')
>     return math.sin(arg)
> ```

I think this is fundamentally different from what is happening in this code. A
direct corollary of storing the subcategory obtained by applying an axiom to a
supercategory in an attribute labelled with the axiom name is that at least at
some point axioms are represented by a string.

It seems the strongest motivation (and a convincing one to me) for storing
subcategories in attributes is that it allows leveraging Python's syntax for
writing classes and attributes. Given that implementation, axioms are
represented by a string at some point. Do we need another representation as
well? 

If you take "applying an axiom to a category" literally, then basically the
implementation

```
def Finite(category):
    return category.Finite()
    #or, to illustrate where the string is living:
    #return getattr(category,"Finite")()
```
would do the trick. There'd be room for documentation on that, but really there
is not much to document. Checking whether a given axiom is applicable boils down
to eventually

```
def has_axiom(category,axiom):
    return hasattr(category,string_corresponding_to(axiom))
```
where the implementation of `string_corresponding_to` is simplest if `axiom`
itself is already given by a string. What do we gain from representing axioms
otherwise?



---

archive/issue_comments_109181.json:
```json
{
    "body": "<a id='comment:396'></a>\nReplying to [nbruin](#comment%3A395):\n> We don't! We normally pass around the values that are bound to them.\n\nThats what I meant by \"them\", sorry for being unclear. My point is not so much about what exactly is passed, but that there is nothing passed, referenced, imported, or inherited from at all: \n\n```\nsage: class Cs(Category):\n....:     def super_categories(self):\n....:         return [Sets()]\n....:     class Finite(CategoryWithAxiom):\n....:         class ParentMethods:\n....:             def foo(self):\n....:                 print \"I am a method on finite C's\"\nsage: P = Parent(category=Cs().Finite())\nsage: P.is_finite()     # What is this I don't even \n```\nNowhere does the source of `Sets.Finite` refer to `Cs.Finite` or vice versa. By the normal mental model of Python code (principle of least astonishment), that ought to mean that the implementations are independent. The only thing that ties them together ultimately is that a substring of the type name matches. For example the following would make me much happier since it makes the dependence visible:\n\n```\nsage: class Cs(Category):\n....:     def super_categories(self):\n....:         return [Sets()]\n....:     class Finite_or_any_other_name(Sets.Finite):\n....:         class ParentMethods:\n....:             def foo(self):\n....:                 print \"I am a method on finite C's\"\nsage: P = Parent(category=Cs().Finite_or_any_other_name())\nsage: P.is_finite()     # obviously comes from Sets.Finite\n```\nOr, even better, with stand-alone axiom objects either using a `@require_axiom(Finite)` decorator or class syntax if you prefer:\n\n```\nsage: class Cs(Category):\n....:     class Finite_or_any_other_name(axioms.Finite):\n....:         class ParentMethods:\n....:             def foo(self):\n....:                 print \"I am a method on finite C's\"\n```\n\nYou could argue that the `ParentMethods` / `ElementMethods` are already precedent for magic attribute names that violate the usual python mental model. Thats true, but a) I wasn't asked when they were introduced and b) there are only two magic names that are ubiquitous in every category source. So it is still kind of obvious from the source code. But if you end up with precisely two categories that have a  *Flasque* subcategory, say, then it is going to be very confusing.",
    "created_at": "2014-01-15T19:48:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109181",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:396'></a>
Replying to [nbruin](#comment%3A395):
> We don't! We normally pass around the values that are bound to them.

Thats what I meant by "them", sorry for being unclear. My point is not so much about what exactly is passed, but that there is nothing passed, referenced, imported, or inherited from at all: 

```
sage: class Cs(Category):
....:     def super_categories(self):
....:         return [Sets()]
....:     class Finite(CategoryWithAxiom):
....:         class ParentMethods:
....:             def foo(self):
....:                 print "I am a method on finite C's"
sage: P = Parent(category=Cs().Finite())
sage: P.is_finite()     # What is this I don't even 
```
Nowhere does the source of `Sets.Finite` refer to `Cs.Finite` or vice versa. By the normal mental model of Python code (principle of least astonishment), that ought to mean that the implementations are independent. The only thing that ties them together ultimately is that a substring of the type name matches. For example the following would make me much happier since it makes the dependence visible:

```
sage: class Cs(Category):
....:     def super_categories(self):
....:         return [Sets()]
....:     class Finite_or_any_other_name(Sets.Finite):
....:         class ParentMethods:
....:             def foo(self):
....:                 print "I am a method on finite C's"
sage: P = Parent(category=Cs().Finite_or_any_other_name())
sage: P.is_finite()     # obviously comes from Sets.Finite
```
Or, even better, with stand-alone axiom objects either using a `@require_axiom(Finite)` decorator or class syntax if you prefer:

```
sage: class Cs(Category):
....:     class Finite_or_any_other_name(axioms.Finite):
....:         class ParentMethods:
....:             def foo(self):
....:                 print "I am a method on finite C's"
```

You could argue that the `ParentMethods` / `ElementMethods` are already precedent for magic attribute names that violate the usual python mental model. Thats true, but a) I wasn't asked when they were introduced and b) there are only two magic names that are ubiquitous in every category source. So it is still kind of obvious from the source code. But if you end up with precisely two categories that have a  *Flasque* subcategory, say, then it is going to be very confusing.



---

archive/issue_comments_109182.json:
```json
{
    "body": "<a id='comment:397'></a>\nReplying to [vbraun](#comment%3A389):\n> You are parsing the \"Finite\" class name, I don't care if it is explicit using string tools/regexes or implicit looking for classes whose names match certain strings. The usual way is to provide a programmatic interface that sets up stuff in code. You should avoid using strings for program flow, and most certainly not use them for foundational material. I wouldn't care so much if we were talking about some implementation details in the combinat project, but you expect us to go around and teach others to use this. That better have a really good reason for the current interface. **Simple** would be something that follows usual patterns (even if its a few characters more). I don't see anything simple here, I see a bunch of trickery that is extremely hard to understand by looking at the code.  \n> \n> And you don't need operations on axioms? I see a lot of weird stuff in this ticket where you use strings to do operations that would be much clearer if you had some object to represent the axiom. E.g.:\n> \n> ```\n> sage: FiniteFields()._without_axiom(\"Commutative\")\n> ```\n> vs.\n> \n> ```\n> sage: FiniteFields().without(Commutative())\n> sage: FiniteFields() - Commutative()\n> ```\n\nI will change this example to `FiniteFields() + Commutative()` so\nas to speak of an operation which is clearly useful in real life.\n\nThe syntax:\n\n```\n    FiniteFields().Commutative()\n```\n\nhas the following merits:\n\n- No need to import stuff. From a single entry point (e.g. the\n  category of Fields()), you can explore all categories you can get\n  from it by just following the flow of calling methods.\n\n- Want to know what are the available axioms? Well, constructing the\n  subcategory of objects satisfying the Finite axiom is a natural\n  operation on a category; therefore, in a standard OO pattern you\n  find this operations along the other methods. Just use\n  introspection:\n\n  ```\n      sage: C = Monoids()\n      sage: C.<tab>\n  ```\n\n  (as pointed by Nils, you could refine this to recover exactly the\n  axioms)\n\n- Tab completion naturally reduces to exactly those axioms that are\n  applicable in the given context.\n\n- Which file implements the commutativity axiom? Use introspection:\n\n  ```\n    sage: Monoids().Finite.__module__\n    'sage.categories.sets_cat'\n  ```\n\n- Where is the documentation for the `Commutative` axiom? Use introspection:\n\n  ```\n    sage: C = Monoids()\n    sage: C.Finite?\n  ```\n\n- Somewhat unrelated, but since you asked elsewhere. How do you know\n  which mixins get inserted when you use a given axiom? Use\n  introspection::\n\n    ```\n   \tsage: Groups().Finite().parent_class.mro()\n   \t[sage.categories.finite_groups.FiniteGroups.parent_class,\n   \t sage.categories.finite_monoids.FiniteMonoids.parent_class,\n   \t sage.categories.groups.Groups.parent_class,\n   \t sage.categories.monoids.Monoids.parent_class,\n   \t sage.categories.finite_semigroups.FiniteSemigroups.parent_class,\n   \t sage.categories.semigroups.Semigroups.parent_class,\n   \t sage.categories.magmas.Unital.Inverse.parent_class,\n   \t sage.categories.magmas.Magmas.Unital.parent_class,\n   \t sage.categories.magmas.Magmas.parent_class,\n   \t sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.parent_class,\n   \t sage.categories.enumerated_sets.EnumeratedSets.parent_class,\n   \t sage.categories.finite_sets.FiniteSets.parent_class,\n   \t sage.categories.sets_cat.Sets.parent_class,\n   \t sage.categories.sets_with_partial_maps.SetsWithPartialMaps.parent_class,\n   \t sage.categories.objects.Objects.parent_class,\n   \t object]\n    ```\n\n\nBesides I would not want to use arithmetic for the operation of adding\nan axiom, since mathematically we would not write this using\narithmetic either, but that's a minor detail.\n\n\nYes there is a bit of complexity under the hood. Implementing a mixins\nmechanism in a language that does not support it natively means that\nyou have to do some non trivial stuff. The internals of an interpreter\nare not simple either. It does not necessarily means that it's\ncomplicated to use in practice.\n\n<grin>\nOh but right, in Python, methods and attributes are accessed by\nlooking up for strings in the dictionary of the classes/objects.\nOverriding a method means inserting a string in a dictionary.  Yuck!\nMaybe we should not be using methods and attributes at all in our\ncode?\n</grin>\n\n\n> Its an absolute no-brainer in Python to model **everything** with objects. If I have an object then I can tell immediately.  Lets keep it simple and explicit, yes. Shorter but non-discoverable is most certainly not simpler. And explicit is better than implicit, as always.\n\nThe axiom is basically already modeled by a *method*. That's rather\nsimple and explicit. And introspection works rather naturally.\n\nMaybe we could go a bit further and indeed use objects instead of\nstrings in the _with(...) methods and in the output of .axioms(). But\nplease, go ahead, try it in a non trivial project and see if it really\nmakes things easier to use in practice. It's not clear.\n\nI am happy leaving a note that this piece of the design is an\nimplementation detail and subject to refactoring.\n\n> Also, I don't agree with atomicity in setting `_base_category_class_and_axiom` buys us anything. Its private by convention, so it is the job of the setter to make changes atomically if necessary (though thats hardly an issue in Python). But in multi-threaded Java, say, this would be a bad data structure as well. We all know the old joke, whats the only data structure in Cobol? A 2000-character EBCDIC string...\n\n<getting frustrated>\nWhatever. That's a minor implementation detail I don't care about. Not\nhappy with it? Go ahead, fix it and get everything right. I spent\nweeks polishing everything to a state where it works smoothly. This\npatch has been advertised for quite some time now, and already got\npositively reviewed featurewise months ago. Time to move on.\n</getting frustrated>\n\n                      Nicolas",
    "created_at": "2014-01-15T22:33:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109182",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:397'></a>
Replying to [vbraun](#comment%3A389):
> You are parsing the "Finite" class name, I don't care if it is explicit using string tools/regexes or implicit looking for classes whose names match certain strings. The usual way is to provide a programmatic interface that sets up stuff in code. You should avoid using strings for program flow, and most certainly not use them for foundational material. I wouldn't care so much if we were talking about some implementation details in the combinat project, but you expect us to go around and teach others to use this. That better have a really good reason for the current interface. **Simple** would be something that follows usual patterns (even if its a few characters more). I don't see anything simple here, I see a bunch of trickery that is extremely hard to understand by looking at the code.  
> 
> And you don't need operations on axioms? I see a lot of weird stuff in this ticket where you use strings to do operations that would be much clearer if you had some object to represent the axiom. E.g.:
> 
> ```
> sage: FiniteFields()._without_axiom("Commutative")
> ```
> vs.
> 
> ```
> sage: FiniteFields().without(Commutative())
> sage: FiniteFields() - Commutative()
> ```

I will change this example to `FiniteFields() + Commutative()` so
as to speak of an operation which is clearly useful in real life.

The syntax:

```
    FiniteFields().Commutative()
```

has the following merits:

- No need to import stuff. From a single entry point (e.g. the
  category of Fields()), you can explore all categories you can get
  from it by just following the flow of calling methods.

- Want to know what are the available axioms? Well, constructing the
  subcategory of objects satisfying the Finite axiom is a natural
  operation on a category; therefore, in a standard OO pattern you
  find this operations along the other methods. Just use
  introspection:

  ```
      sage: C = Monoids()
      sage: C.<tab>
  ```

  (as pointed by Nils, you could refine this to recover exactly the
  axioms)

- Tab completion naturally reduces to exactly those axioms that are
  applicable in the given context.

- Which file implements the commutativity axiom? Use introspection:

  ```
    sage: Monoids().Finite.__module__
    'sage.categories.sets_cat'
  ```

- Where is the documentation for the `Commutative` axiom? Use introspection:

  ```
    sage: C = Monoids()
    sage: C.Finite?
  ```

- Somewhat unrelated, but since you asked elsewhere. How do you know
  which mixins get inserted when you use a given axiom? Use
  introspection::

    ```
   	sage: Groups().Finite().parent_class.mro()
   	[sage.categories.finite_groups.FiniteGroups.parent_class,
   	 sage.categories.finite_monoids.FiniteMonoids.parent_class,
   	 sage.categories.groups.Groups.parent_class,
   	 sage.categories.monoids.Monoids.parent_class,
   	 sage.categories.finite_semigroups.FiniteSemigroups.parent_class,
   	 sage.categories.semigroups.Semigroups.parent_class,
   	 sage.categories.magmas.Unital.Inverse.parent_class,
   	 sage.categories.magmas.Magmas.Unital.parent_class,
   	 sage.categories.magmas.Magmas.parent_class,
   	 sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.parent_class,
   	 sage.categories.enumerated_sets.EnumeratedSets.parent_class,
   	 sage.categories.finite_sets.FiniteSets.parent_class,
   	 sage.categories.sets_cat.Sets.parent_class,
   	 sage.categories.sets_with_partial_maps.SetsWithPartialMaps.parent_class,
   	 sage.categories.objects.Objects.parent_class,
   	 object]
    ```


Besides I would not want to use arithmetic for the operation of adding
an axiom, since mathematically we would not write this using
arithmetic either, but that's a minor detail.


Yes there is a bit of complexity under the hood. Implementing a mixins
mechanism in a language that does not support it natively means that
you have to do some non trivial stuff. The internals of an interpreter
are not simple either. It does not necessarily means that it's
complicated to use in practice.

<grin>
Oh but right, in Python, methods and attributes are accessed by
looking up for strings in the dictionary of the classes/objects.
Overriding a method means inserting a string in a dictionary.  Yuck!
Maybe we should not be using methods and attributes at all in our
code?
</grin>


> Its an absolute no-brainer in Python to model **everything** with objects. If I have an object then I can tell immediately.  Lets keep it simple and explicit, yes. Shorter but non-discoverable is most certainly not simpler. And explicit is better than implicit, as always.

The axiom is basically already modeled by a *method*. That's rather
simple and explicit. And introspection works rather naturally.

Maybe we could go a bit further and indeed use objects instead of
strings in the _with(...) methods and in the output of .axioms(). But
please, go ahead, try it in a non trivial project and see if it really
makes things easier to use in practice. It's not clear.

I am happy leaving a note that this piece of the design is an
implementation detail and subject to refactoring.

> Also, I don't agree with atomicity in setting `_base_category_class_and_axiom` buys us anything. Its private by convention, so it is the job of the setter to make changes atomically if necessary (though thats hardly an issue in Python). But in multi-threaded Java, say, this would be a bad data structure as well. We all know the old joke, whats the only data structure in Cobol? A 2000-character EBCDIC string...

<getting frustrated>
Whatever. That's a minor implementation detail I don't care about. Not
happy with it? Go ahead, fix it and get everything right. I spent
weeks polishing everything to a state where it works smoothly. This
patch has been advertised for quite some time now, and already got
positively reviewed featurewise months ago. Time to move on.
</getting frustrated>

                      Nicolas



---

archive/issue_comments_109183.json:
```json
{
    "body": "<a id='comment:398'></a>\nReplying to [vbraun](#comment%3A396):\n>For example the following would make me much happier since it makes the dependence visible:\n>\n> ```\n> sage: class Cs(Category):\n> ....:     def super_categories(self):\n> ....:         return [Sets()]\n> ....:     class Finite_or_any_other_name(Sets.Finite):\n> ....:         class ParentMethods:\n> ....:             def foo(self):\n> ....:                 print \"I am a method on finite C's\"\n> sage: P = Parent(category=Cs().Finite_or_any_other_name())\n> sage: P.is_finite()     # obviously comes from Sets.Finite\n> ```\n\nAh, I see your issue. I get the feeling that if one would address that point\nfully, one would end up with a system so verbose that axioms don't really save\ncoding any more, which is the motivation of the system in the first place.\n\nI also don't think the above suggestion expresses the link properly: P doesn't\nhave the `is_finite` method because its category is `Cs.Finite`, but because its\ncategory is `Cs` together with the `Finite` axiom, `Cs` is a subcategory of\n`Sets`, and `Sets` can also have the `Finite` axiom applied to it. This kind of\ninheritance is fundamentally richer than what normal class inheritance allows\nfor, so trying to express it is doomed to fail (otherwise we could have used the\ntranslation!). I am not convinced that we really *need* this in sage, but the\nauthor does.\n\nIn fact, the syntax above is perhaps more misleading: By letting `Cs.Finite`\ninherit from `Sets.Finite`, you might think that attributes like `ParentMethods`\nfollow the usual inheritance rules as well. But they shouldn't, because\n`Cs.Finite.ParentMethods` does not contain `is_finite`, so this fails to express\nhow P gets its `is_finite` attribute completely. By not letting `Cs.Finite`\ninherit from `Sets.Finite`, at least we're not suggesting a kind of relation\nthat doesn't apply.\n\n> Or, even better, with stand-alone axiom objects either using a `@require_axiom(Finite)` decorator or class syntax if you prefer:\n> \n> ```\n> sage: class Cs(Category):\n> ....:     class Finite_or_any_other_name(axioms.Finite):\n> ....:         class ParentMethods:\n> ....:             def foo(self):\n> ....:                 print \"I am a method on finite C's\"\n> ```\n\nThere might be something to that, but if the `or_any_other_name` option gets\nexcercises, how would you tell efficiently whether `Cs` can have `axioms.Finite`\napplied to it? See if there are any attributes that are subtypes of\naxioms.Finite?\n\nThere are precedents in Python for \"magic\" attribute names. For instance, an\nobject gets a length by implementing a `__len__` method on it.\n\nI think the bigger issue is how the supercategories of a category are\ndocumented, rather than the relations between the axioms on each of them.\n\n> You could argue that the `ParentMethods` / `ElementMethods` are already\n> precedent for magic attribute names that violate the usual python mental model.\n\nI think the category framework itself violates the usual python mental model,\nbut that's being advertised as feature, the argument being that the usual python\nmodel isn't expressive enough.",
    "created_at": "2014-01-15T22:44:52Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109183",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:398'></a>
Replying to [vbraun](#comment%3A396):
>For example the following would make me much happier since it makes the dependence visible:
>
> ```
> sage: class Cs(Category):
> ....:     def super_categories(self):
> ....:         return [Sets()]
> ....:     class Finite_or_any_other_name(Sets.Finite):
> ....:         class ParentMethods:
> ....:             def foo(self):
> ....:                 print "I am a method on finite C's"
> sage: P = Parent(category=Cs().Finite_or_any_other_name())
> sage: P.is_finite()     # obviously comes from Sets.Finite
> ```

Ah, I see your issue. I get the feeling that if one would address that point
fully, one would end up with a system so verbose that axioms don't really save
coding any more, which is the motivation of the system in the first place.

I also don't think the above suggestion expresses the link properly: P doesn't
have the `is_finite` method because its category is `Cs.Finite`, but because its
category is `Cs` together with the `Finite` axiom, `Cs` is a subcategory of
`Sets`, and `Sets` can also have the `Finite` axiom applied to it. This kind of
inheritance is fundamentally richer than what normal class inheritance allows
for, so trying to express it is doomed to fail (otherwise we could have used the
translation!). I am not convinced that we really *need* this in sage, but the
author does.

In fact, the syntax above is perhaps more misleading: By letting `Cs.Finite`
inherit from `Sets.Finite`, you might think that attributes like `ParentMethods`
follow the usual inheritance rules as well. But they shouldn't, because
`Cs.Finite.ParentMethods` does not contain `is_finite`, so this fails to express
how P gets its `is_finite` attribute completely. By not letting `Cs.Finite`
inherit from `Sets.Finite`, at least we're not suggesting a kind of relation
that doesn't apply.

> Or, even better, with stand-alone axiom objects either using a `@require_axiom(Finite)` decorator or class syntax if you prefer:
> 
> ```
> sage: class Cs(Category):
> ....:     class Finite_or_any_other_name(axioms.Finite):
> ....:         class ParentMethods:
> ....:             def foo(self):
> ....:                 print "I am a method on finite C's"
> ```

There might be something to that, but if the `or_any_other_name` option gets
excercises, how would you tell efficiently whether `Cs` can have `axioms.Finite`
applied to it? See if there are any attributes that are subtypes of
axioms.Finite?

There are precedents in Python for "magic" attribute names. For instance, an
object gets a length by implementing a `__len__` method on it.

I think the bigger issue is how the supercategories of a category are
documented, rather than the relations between the axioms on each of them.

> You could argue that the `ParentMethods` / `ElementMethods` are already
> precedent for magic attribute names that violate the usual python mental model.

I think the category framework itself violates the usual python mental model,
but that's being advertised as feature, the argument being that the usual python
model isn't expressive enough.



---

archive/issue_comments_109184.json:
```json
{
    "body": "<a id='comment:399'></a>\nReplying to [vbraun](#comment%3A394):\n> Why not\n\n> ```python\n> class Finite(Axiom):\n>     class ParentMethods:\n>         def is_finite(self): return True\n> \n> class Groups(Category):\n>     class ParentMethods:\n>         @requires_axiom(Finite())\n>         def is_finite_group(self): return True\n> ```\n\nWe had a similar syntax in MuPAD / Axiom. There, axioms were basically\npredicates on parents which you could test in your code. And they were\norganized in a module Ax.Finite, Ax., etc. In practice we never found\nan interesting use case for those (and we tried!).\n\nOn the other hand, I believe from practical experience that a\nmechanism of mixins like that implemented in categories, and further\nextended by this patch, can help a lot structuring the code based on\nmath knowledge.\n\nOf course the downside is that we are necessarily deviating at some\npoint from standard Python, since Python does not have native support\nfor mixins. But this is relatively alleviated by the fact that, once\nthe magic for building the hierarchy of classes for parent and element\nis finished, we are back to a purely standard OO; which means that all\nstandard tools like instrospection and the like work.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-01-15T23:06:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109184",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:399'></a>
Replying to [vbraun](#comment%3A394):
> Why not

> ```python
> class Finite(Axiom):
>     class ParentMethods:
>         def is_finite(self): return True
> 
> class Groups(Category):
>     class ParentMethods:
>         @requires_axiom(Finite())
>         def is_finite_group(self): return True
> ```

We had a similar syntax in MuPAD / Axiom. There, axioms were basically
predicates on parents which you could test in your code. And they were
organized in a module Ax.Finite, Ax., etc. In practice we never found
an interesting use case for those (and we tried!).

On the other hand, I believe from practical experience that a
mechanism of mixins like that implemented in categories, and further
extended by this patch, can help a lot structuring the code based on
math knowledge.

Of course the downside is that we are necessarily deviating at some
point from standard Python, since Python does not have native support
for mixins. But this is relatively alleviated by the fact that, once
the magic for building the hierarchy of classes for parent and element
is finished, we are back to a purely standard OO; which means that all
standard tools like instrospection and the like work.

Cheers,
                              Nicolas



---

archive/issue_comments_109185.json:
```json
{
    "body": "<a id='comment:400'></a>\nReplying to [nthiery](#comment%3A378):\n> ``base_category`` is used in a few spots for computing stuff\n> recursively. This is includes _without_axioms (a trivial recursion),\n\nIs that even a well-defined operation? Given that\n\n```\nDivisionRings().Finite().base_category()\n```\nis not `DivisionRings`, it's not clear to me that this process is guaranteed to\nundo the application of \"axioms\". In this case it works because both\n`DivisionRings()` and `Fields()` are obtained via axioms from a common category.\nBut that also means that we didn't have to recurse up via a marked \"base\ncategory\". We could have taken any supercategory that is of type\n`CategoryWithAxiom`. There's a theorem to be proved that such a greedy approach\nworks, but the commutativity of applying axioms should take care of that.\n\n> and more importantly the calculations of the super categories (a\n> tricky recursion).\n\nYup, this bit:\n\n```\n        base_category = self._base_category\n        axiom = self._axiom\n        extra = self.extra_super_categories()\n        return Category.join((self._base_category,) +\n                             tuple(base_category.super_categories()) +\n                             tuple(extra),\n                             axioms = (axiom,),\n                             uniq=False,\n                             ignore_axioms = ((base_category, axiom),),\n                             as_list = True)\n```\nThis code just needs some supercategories that tie this thing into the\ncategory hierarchy. Apparently `(base,)+base.super_categories+extra` is enough,\nfor some base that is present upon initialization. Why bother keeping the base\nspecial if it's not inherently special.\n\nFrom:\n\n```\nsage: V=Fields().Finite().super_categories()\nsage: V=flatten([v.super_categories() for v in V])\nsage: V=flatten([v.super_categories() for v in V])\nsage: V\n[Category of principal ideal domains,\n Category of domains,\n Category of semigroups,\n Category of unital magmas,\n Category of semigroups,\n Category of finite enumerated sets]\n```\nyou can already see that the supercategories as returned now lead to multiple\npaths to the same thing any way, so (as always when walking up a tree) you need\nto keep track of already visited nodes any way. Limiting recursion to just\n\"base\" isn't going to alleviate that.\n\n> I agree that this is mostly for internal use. But it's consistent with\n> functorial constructions and the like to have the .base_category() method.\n\nSince it has no meaning here, I don't see why this consistency is desirable. I'd\nsay it's misleading.",
    "created_at": "2014-01-15T23:27:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109185",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:400'></a>
Replying to [nthiery](#comment%3A378):
> ``base_category`` is used in a few spots for computing stuff
> recursively. This is includes _without_axioms (a trivial recursion),

Is that even a well-defined operation? Given that

```
DivisionRings().Finite().base_category()
```
is not `DivisionRings`, it's not clear to me that this process is guaranteed to
undo the application of "axioms". In this case it works because both
`DivisionRings()` and `Fields()` are obtained via axioms from a common category.
But that also means that we didn't have to recurse up via a marked "base
category". We could have taken any supercategory that is of type
`CategoryWithAxiom`. There's a theorem to be proved that such a greedy approach
works, but the commutativity of applying axioms should take care of that.

> and more importantly the calculations of the super categories (a
> tricky recursion).

Yup, this bit:

```
        base_category = self._base_category
        axiom = self._axiom
        extra = self.extra_super_categories()
        return Category.join((self._base_category,) +
                             tuple(base_category.super_categories()) +
                             tuple(extra),
                             axioms = (axiom,),
                             uniq=False,
                             ignore_axioms = ((base_category, axiom),),
                             as_list = True)
```
This code just needs some supercategories that tie this thing into the
category hierarchy. Apparently `(base,)+base.super_categories+extra` is enough,
for some base that is present upon initialization. Why bother keeping the base
special if it's not inherently special.

From:

```
sage: V=Fields().Finite().super_categories()
sage: V=flatten([v.super_categories() for v in V])
sage: V=flatten([v.super_categories() for v in V])
sage: V
[Category of principal ideal domains,
 Category of domains,
 Category of semigroups,
 Category of unital magmas,
 Category of semigroups,
 Category of finite enumerated sets]
```
you can already see that the supercategories as returned now lead to multiple
paths to the same thing any way, so (as always when walking up a tree) you need
to keep track of already visited nodes any way. Limiting recursion to just
"base" isn't going to alleviate that.

> I agree that this is mostly for internal use. But it's consistent with
> functorial constructions and the like to have the .base_category() method.

Since it has no meaning here, I don't see why this consistency is desirable. I'd
say it's misleading.



---

archive/issue_comments_109186.json:
```json
{
    "body": "<a id='comment:401'></a>\nReplying to [vbraun](#comment%3A396):\n> Nowhere does the source of `Sets.Finite` refer to `Cs.Finite` or vice versa. By the normal mental model of Python code (principle of least astonishment), that ought to mean that the implementations are independent. The only thing that ties them together ultimately is that a substring of the type name matches.\n\nMay I play the advocate of the devil? Consider this example:\n\n```\nclass A:\n    def foo():\n        ...\n\nclass B(A):\n    def foo()\n        ...\n```\n\nNothing ties ``B.foo`` to ``A.foo``. Yet, by standard OO mental model,\nwe know that B.foo() overrides A.foo() and should thus have the same\nsemantic.  Yet, ultimately the only link between the two is that the\nsubstring ``foo`` of the names ``A.foo`` and ``B.foo`` matches.\n\nGranted, the relation \"inheritance\" relation between ``Cs`` and\n``Sets`` is not as explicit as between ``B`` and ``A``; but that's the\nprice we pay for all the flexibility of dynamic mixins.\n\nFor example the following would make me much happier since it makes the dependence visible:\n> \n> ```\n> sage: class Cs(Category):\n> ....:     def super_categories(self):\n> ....:         return [Sets()]\n> ....:     class Finite_or_any_other_name(Sets.Finite):\n> ....:         class ParentMethods:\n> ....:             def foo(self):\n> ....:                 print \"I am a method on finite C's\"\n> ```\n\nI see your point. We have something similar for functorial\nconstructions where the idiom is:\n\n```\n> sage: class Algebras(Category):\n> ....:     class Graded(GradedModulesCategory):\n> ....:         class ParentMethods:\n> ....:             def foo(self):\n> ....:                 print \"I am a method on graded algebras\"\n```\n\nThe reason why I moved away from this idiom, and why I consider\nrefactoring functorial constructions similarly, is that defining new\naxioms is much more lightweight in practice than defining new\nconstructions.  Really it was getting in my way when writing\ncode. Itching hard. In fact Jean-Baptiste is complaining that it's\nstill not lightweight enough :-) Also, even just implementing an axiom\nin a category is more lightweight than implementing a functorial\nconstruction (no need to fiddle with an extra import and risk merge\nconflicts there, ...).\n\nThere is another annoying issue in being explicit about where the\naxiom is defined as in the idiom `Finite(Sets.Finite)`. Namely, if\nlater on one wants to generalize the axiom by moving its definition up\nthe category hierarchy (maybe because in the meantime a larger\ncategory has been implemented where the axiom makes sense), then you\nneed to fix accordingly each and every category where the axiom is\nimplemented (the usual price for redundant information). This\nsituation has happened to me in practice more than once!\n\n> You could argue that the `ParentMethods` / `ElementMethods` are\n\nalready precedent for magic attribute names that violate the usual\npython mental model. Thats true, but a) I wasn't asked when they were\nintroduced\n\nBut this was reviewed by a bunch of people. Of course not as great as\nyou, master :-)\n\nSorry, I could not resist. I totally understand your being careful\nbefore being imposed upon a framework that may have long lasting\nconsequences on our code. But it's super frustrating for me and all\nthose who have tons of code depending on that framework.\n\n>  and b) there are only two magic names that are ubiquitous\n\nin every category source. So it is still kind of obvious from the\nsource code. But if you end up with precisely two categories that have\na *Flasque* subcategory, say, then it is going to be very confusing.\n\nWell, you see Flasque(CategoryWithAxiom) in Cs. It tells you that it's\nimplementing an axiom named Flasque axiom. If you are interested at\nthe code of Cs, there are some chances that you know what Cs is about\nand are aware of this axiom. And otherwise you quickly lookup\n`Cs().Flasque?` to know what it's about.\n\nGranted this assumes a minimum of knowledge about categories and\naxioms. Like any infrastructure there is a minimum of stuff to learn\nbefore you can really benefit from it. Here a 30 minutes course should\nbe sufficient to cover the necessary ground.\n\nCheers,\n                           Nicolas",
    "created_at": "2014-01-15T23:58:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109186",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:401'></a>
Replying to [vbraun](#comment%3A396):
> Nowhere does the source of `Sets.Finite` refer to `Cs.Finite` or vice versa. By the normal mental model of Python code (principle of least astonishment), that ought to mean that the implementations are independent. The only thing that ties them together ultimately is that a substring of the type name matches.

May I play the advocate of the devil? Consider this example:

```
class A:
    def foo():
        ...

class B(A):
    def foo()
        ...
```

Nothing ties ``B.foo`` to ``A.foo``. Yet, by standard OO mental model,
we know that B.foo() overrides A.foo() and should thus have the same
semantic.  Yet, ultimately the only link between the two is that the
substring ``foo`` of the names ``A.foo`` and ``B.foo`` matches.

Granted, the relation "inheritance" relation between ``Cs`` and
``Sets`` is not as explicit as between ``B`` and ``A``; but that's the
price we pay for all the flexibility of dynamic mixins.

For example the following would make me much happier since it makes the dependence visible:
> 
> ```
> sage: class Cs(Category):
> ....:     def super_categories(self):
> ....:         return [Sets()]
> ....:     class Finite_or_any_other_name(Sets.Finite):
> ....:         class ParentMethods:
> ....:             def foo(self):
> ....:                 print "I am a method on finite C's"
> ```

I see your point. We have something similar for functorial
constructions where the idiom is:

```
> sage: class Algebras(Category):
> ....:     class Graded(GradedModulesCategory):
> ....:         class ParentMethods:
> ....:             def foo(self):
> ....:                 print "I am a method on graded algebras"
```

The reason why I moved away from this idiom, and why I consider
refactoring functorial constructions similarly, is that defining new
axioms is much more lightweight in practice than defining new
constructions.  Really it was getting in my way when writing
code. Itching hard. In fact Jean-Baptiste is complaining that it's
still not lightweight enough :-) Also, even just implementing an axiom
in a category is more lightweight than implementing a functorial
construction (no need to fiddle with an extra import and risk merge
conflicts there, ...).

There is another annoying issue in being explicit about where the
axiom is defined as in the idiom `Finite(Sets.Finite)`. Namely, if
later on one wants to generalize the axiom by moving its definition up
the category hierarchy (maybe because in the meantime a larger
category has been implemented where the axiom makes sense), then you
need to fix accordingly each and every category where the axiom is
implemented (the usual price for redundant information). This
situation has happened to me in practice more than once!

> You could argue that the `ParentMethods` / `ElementMethods` are

already precedent for magic attribute names that violate the usual
python mental model. Thats true, but a) I wasn't asked when they were
introduced

But this was reviewed by a bunch of people. Of course not as great as
you, master :-)

Sorry, I could not resist. I totally understand your being careful
before being imposed upon a framework that may have long lasting
consequences on our code. But it's super frustrating for me and all
those who have tons of code depending on that framework.

>  and b) there are only two magic names that are ubiquitous

in every category source. So it is still kind of obvious from the
source code. But if you end up with precisely two categories that have
a *Flasque* subcategory, say, then it is going to be very confusing.

Well, you see Flasque(CategoryWithAxiom) in Cs. It tells you that it's
implementing an axiom named Flasque axiom. If you are interested at
the code of Cs, there are some chances that you know what Cs is about
and are aware of this axiom. And otherwise you quickly lookup
`Cs().Flasque?` to know what it's about.

Granted this assumes a minimum of knowledge about categories and
axioms. Like any infrastructure there is a minimum of stuff to learn
before you can really benefit from it. Here a 30 minutes course should
be sufficient to cover the necessary ground.

Cheers,
                           Nicolas



---

archive/issue_comments_109187.json:
```json
{
    "body": "<a id='comment:402'></a>\nReplying to [nbruin](#comment%3A398):\n> > \n> > ```\n> > sage: class Cs(Category):\n> > ....:     class Finite_or_any_other_name(axioms.Finite):\n> > ....:         class ParentMethods:\n> > ....:             def foo(self):\n> > ....:                 print \"I am a method on finite C's\"\n> > ```\n\n> There might be something to that, but if the `or_any_other_name` option gets\n> excercises, how would you tell efficiently whether `Cs` can have `axioms.Finite`\n> applied to it? See if there are any attributes that are subtypes of\n> axioms.Finite?\n\nExactly, that would be the implementation. And that can easily be cached in the unlikely case that it would ever be a speed problem to extract the attributes that are subclasses of the base `Axiom` class. Also\n\n* Independent axioms make them easier to implement since you don't need to figure out the most basic category that can carry the axiom. I.e. you don't need a global understanding of the existing categories. You never have to \"move it up the category hierarchy\" either.\n\n* It gives you additional freedom to only implement methods when certain combinations of axioms are applied (for breverity as decorator, same argument applies to contained-class syntax):\n\n  ```\n     @require_axiom(Foo)\n     def foo() [...]\n     \n     @require_axiom(Bar)\n     def bar() [...]\n\n     @require_axiom(Foo, Bar)\n     def baz() [...]\n   ```\n \n* You don't have to decide who owns a particular adjective. E.g. \"Rigid\" for differential operators is not the \"Rigid\" in the category theory sense, at least I don't think so. (Exercise: Find your own rarely-used/obscure adjective with conflicting meanings). \n\n* Its actually a pretty minimal change of the existing code, the only thing that really changes is that we look for attributes that are tagged by being subclasses of the axiom class (i.e. in code) instead of having a blessed adjective as name.\n\n> There is precedency in Python for \"magic\" attribute names. For instance, an\n> object gets a length by implementing a `__len__` method on it.\n\nTrue, and it is really unfair that if Guido van Rossum blesses a name with magical properties then that is automatically good Python and people explain it in every book about Python. Whereas if one of us declares a name special then it is bad practice and no Python book in the world gives a hoot about it.",
    "created_at": "2014-01-16T06:19:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109187",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:402'></a>
Replying to [nbruin](#comment%3A398):
> > 
> > ```
> > sage: class Cs(Category):
> > ....:     class Finite_or_any_other_name(axioms.Finite):
> > ....:         class ParentMethods:
> > ....:             def foo(self):
> > ....:                 print "I am a method on finite C's"
> > ```

> There might be something to that, but if the `or_any_other_name` option gets
> excercises, how would you tell efficiently whether `Cs` can have `axioms.Finite`
> applied to it? See if there are any attributes that are subtypes of
> axioms.Finite?

Exactly, that would be the implementation. And that can easily be cached in the unlikely case that it would ever be a speed problem to extract the attributes that are subclasses of the base `Axiom` class. Also

* Independent axioms make them easier to implement since you don't need to figure out the most basic category that can carry the axiom. I.e. you don't need a global understanding of the existing categories. You never have to "move it up the category hierarchy" either.

* It gives you additional freedom to only implement methods when certain combinations of axioms are applied (for breverity as decorator, same argument applies to contained-class syntax):

  ```
     @require_axiom(Foo)
     def foo() [...]
     
     @require_axiom(Bar)
     def bar() [...]

     @require_axiom(Foo, Bar)
     def baz() [...]
   ```
 
* You don't have to decide who owns a particular adjective. E.g. "Rigid" for differential operators is not the "Rigid" in the category theory sense, at least I don't think so. (Exercise: Find your own rarely-used/obscure adjective with conflicting meanings). 

* Its actually a pretty minimal change of the existing code, the only thing that really changes is that we look for attributes that are tagged by being subclasses of the axiom class (i.e. in code) instead of having a blessed adjective as name.

> There is precedency in Python for "magic" attribute names. For instance, an
> object gets a length by implementing a `__len__` method on it.

True, and it is really unfair that if Guido van Rossum blesses a name with magical properties then that is automatically good Python and people explain it in every book about Python. Whereas if one of us declares a name special then it is bad practice and no Python book in the world gives a hoot about it.



---

archive/issue_comments_109188.json:
```json
{
    "body": "<a id='comment:403'></a>\nReplying to [vbraun](#comment%3A402):\n> * Independent axioms make them easier to implement since you don't need to figure out the most basic category that can carry the axiom. I.e. you don't need a global understanding of the existing categories. You never have to \"move it up the category hierarchy\" either.\n\nReally?\n\nA few months ago (see some earlier comments), I suggested to distinguish between categories that provide certain \"features\" (such as: addition, subtraction, multiplication, division, a total ordering) and categories that provide axioms for these \"features\" (such as: commutativity, distributivity, compatibility of an order with arithmetic operations). The \"features\" largely correspond to magical Python methods for parents and their elements---hence, it could be implement by (abstract) `ParentMethods` and `ElementMethods`.\n\nThe axioms then require that the parent/element methods satisfy certain specifications, that give rise to tests of the test suite, and also (by mathematical theorems) you may get default implementations of the abstract parent/element methods, and you might automatically get further axioms when applying one axiom (such as: division ring plus finite implies commutative).\n\nThis model relies on the observation that you *must* have an additive and a multiplicative magma among the super categories, if you want to have distributivity: Their join is the most basic category that can carry this axiom.\n\n> * Its actually a pretty minimal change of the existing code, the only thing that really changes is that we look for attributes that are tagged by being subclasses of the axiom class (i.e. in code) instead of having a blessed adjective as name.\n\nActually, from a practical point of view, I'd prefer to have something that works (i.e., this code) and move on to a different (better?) model later.\n\nFor example, I think the approach to use a proper database could also relatively easily be implemented on top of the existing code. Namely: The construction digraph will still be encoded by (1) axioms that are stored as (lazy/nested/...) class attributes of a base category, and (2) by an attribute of a category-with-axiom providing the default construction (`_base_category_class_and_axiom`). The only difference is that these attributes would be provided by the database, and *only* the database (as a single point of truth).\n\nBut I think it would be a mistake to do this presumably/hopefully \"small\" change now, i.e. before merging Nicolas' code.\n \n> > There is precedency in Python for \"magic\" attribute names. For instance, an\n> > object gets a length by implementing a `__len__` method on it.\n\n> \n> True, and it is really unfair that if Guido van Rossum blesses a name with magical properties then that is automatically good Python and people explain it in every book about Python. Whereas if one of us declares a name special then it is bad practice and no Python book in the world gives a hoot about it.\n\n+1, provided they the Sage documentation explains our magical methods as clearly as the Python books document magical Python methods.",
    "created_at": "2014-01-16T10:44:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109188",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:403'></a>
Replying to [vbraun](#comment%3A402):
> * Independent axioms make them easier to implement since you don't need to figure out the most basic category that can carry the axiom. I.e. you don't need a global understanding of the existing categories. You never have to "move it up the category hierarchy" either.

Really?

A few months ago (see some earlier comments), I suggested to distinguish between categories that provide certain "features" (such as: addition, subtraction, multiplication, division, a total ordering) and categories that provide axioms for these "features" (such as: commutativity, distributivity, compatibility of an order with arithmetic operations). The "features" largely correspond to magical Python methods for parents and their elements---hence, it could be implement by (abstract) `ParentMethods` and `ElementMethods`.

The axioms then require that the parent/element methods satisfy certain specifications, that give rise to tests of the test suite, and also (by mathematical theorems) you may get default implementations of the abstract parent/element methods, and you might automatically get further axioms when applying one axiom (such as: division ring plus finite implies commutative).

This model relies on the observation that you *must* have an additive and a multiplicative magma among the super categories, if you want to have distributivity: Their join is the most basic category that can carry this axiom.

> * Its actually a pretty minimal change of the existing code, the only thing that really changes is that we look for attributes that are tagged by being subclasses of the axiom class (i.e. in code) instead of having a blessed adjective as name.

Actually, from a practical point of view, I'd prefer to have something that works (i.e., this code) and move on to a different (better?) model later.

For example, I think the approach to use a proper database could also relatively easily be implemented on top of the existing code. Namely: The construction digraph will still be encoded by (1) axioms that are stored as (lazy/nested/...) class attributes of a base category, and (2) by an attribute of a category-with-axiom providing the default construction (`_base_category_class_and_axiom`). The only difference is that these attributes would be provided by the database, and *only* the database (as a single point of truth).

But I think it would be a mistake to do this presumably/hopefully "small" change now, i.e. before merging Nicolas' code.
 
> > There is precedency in Python for "magic" attribute names. For instance, an
> > object gets a length by implementing a `__len__` method on it.

> 
> True, and it is really unfair that if Guido van Rossum blesses a name with magical properties then that is automatically good Python and people explain it in every book about Python. Whereas if one of us declares a name special then it is bad practice and no Python book in the world gives a hoot about it.

+1, provided they the Sage documentation explains our magical methods as clearly as the Python books document magical Python methods.



---

archive/issue_comments_109189.json:
```json
{
    "body": "<a id='comment:4'></a>\nFTR - I'm taking care of the merge with the latest `develop` branch right now.",
    "created_at": "2014-01-16T16:25:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109189",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:4'></a>
FTR - I'm taking care of the merge with the latest `develop` branch right now.



---

archive/issue_comments_109190.json:
```json
{
    "body": "<a id='comment:405'></a>\nReplying to [vbraun](#comment%3A396):\n> Or, even better, with stand-alone axiom objects either using a `@require_axiom(Finite)` decorator or class syntax if you prefer:\n> \n> ```\n> sage: class Cs(Category):\n> ....:     class Finite_or_any_other_name(axioms.Finite):\n> ....:         class ParentMethods:\n> ....:             def foo(self):\n> ....:                 print \"I am a method on finite C's\"\n> ```\n\nThere's a peculiarity in this representation of the concept: with this paradigm\nit would be possible to implement multiple `axiom.Finite` subclasses on\n`Cs`. I'm not sure that's a desirable property. Although it could express\nWedderburn: The `Finite` and  `Commutative` attributes on `DivisionRings` could\nboth inherit from both `axiom.Finite` and `axiom.Commutative`. I'm not so sure\ndoing this is desirable. I would expect it's better to mandate that every\ncategory can implement an axiom at most once. And using fixed attribute names\ndoes that naturally, at the expense of forcing name choice.\n\nI wonder if \"name clashes\" in axioms are ever a real problem. I would hope that\nif two categories `A` and `B` have conflicting ideas over what the axiom\nnamed `d` must mean, then any common supercategory doesn't implement either\n(because it can't carry them). I don't think the different meanings will ever\nclash then.\n\nIf there is a common supercategory that implements one of the meanings of the\naxiom then the terminology is genuinely confusing and then the system rightly\npoints at a naming clash that needs resolving.",
    "created_at": "2014-01-16T16:39:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109190",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:405'></a>
Replying to [vbraun](#comment%3A396):
> Or, even better, with stand-alone axiom objects either using a `@require_axiom(Finite)` decorator or class syntax if you prefer:
> 
> ```
> sage: class Cs(Category):
> ....:     class Finite_or_any_other_name(axioms.Finite):
> ....:         class ParentMethods:
> ....:             def foo(self):
> ....:                 print "I am a method on finite C's"
> ```

There's a peculiarity in this representation of the concept: with this paradigm
it would be possible to implement multiple `axiom.Finite` subclasses on
`Cs`. I'm not sure that's a desirable property. Although it could express
Wedderburn: The `Finite` and  `Commutative` attributes on `DivisionRings` could
both inherit from both `axiom.Finite` and `axiom.Commutative`. I'm not so sure
doing this is desirable. I would expect it's better to mandate that every
category can implement an axiom at most once. And using fixed attribute names
does that naturally, at the expense of forcing name choice.

I wonder if "name clashes" in axioms are ever a real problem. I would hope that
if two categories `A` and `B` have conflicting ideas over what the axiom
named `d` must mean, then any common supercategory doesn't implement either
(because it can't carry them). I don't think the different meanings will ever
clash then.

If there is a common supercategory that implements one of the meanings of the
axiom then the terminology is genuinely confusing and then the system rightly
points at a naming clash that needs resolving.



---

archive/issue_comments_109191.json:
```json
{
    "body": "<a id='comment:406'></a>\nReplying to [nbruin](#comment%3A405):\n> There's a peculiarity in this representation of the concept: with this paradigm\n> it would be possible to implement multiple `axiom.Finite` subclasses on\n> `Cs`.\n\nYes, giving you additional freedom to only implement methods when certain combinations of axioms are applied:\n\n```\nclass Cs(Category):\n....:     class WithFoo(Foo):\n....:         class ParentMethods:\n....:             def foo(self): [...]\n....:     class WithBar(Bar):\n....:         class ParentMethods:\n....:             def bar(self): [...]\n....:     class WithFooAndBar(Foo, Bar):\n....:         class ParentMethods:\n....:             def baz(self): [...]\n```\n\n> I wonder if \"name clashes\" in axioms are ever a real problem. \n\nFunny that you would say that, as Atiyah's category of \"Real\" vector bundles would be another example of a likely name clash with what you'd commonly use \"Real\" for.\n\n> I would hope that\n> if two categories `A` and `B` have conflicting ideas over what the axiom\n> named `d` must mean, then any common supercategory doesn't implement either\n\nYes, I'm aware that you could use the same adjective provide that they are not joined by a common supercategory. It seems a bit fragile as adding new supercategories may then have very non-local consequences. Moreover, for differential operators, say, I think it would be possible (if highly unusual) to ask them to form a \"Rigid\" category. So they can't be separated by not having a common supercategory, at least not in a mathematically satisfying way.",
    "created_at": "2014-01-16T17:15:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109191",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:406'></a>
Replying to [nbruin](#comment%3A405):
> There's a peculiarity in this representation of the concept: with this paradigm
> it would be possible to implement multiple `axiom.Finite` subclasses on
> `Cs`.

Yes, giving you additional freedom to only implement methods when certain combinations of axioms are applied:

```
class Cs(Category):
....:     class WithFoo(Foo):
....:         class ParentMethods:
....:             def foo(self): [...]
....:     class WithBar(Bar):
....:         class ParentMethods:
....:             def bar(self): [...]
....:     class WithFooAndBar(Foo, Bar):
....:         class ParentMethods:
....:             def baz(self): [...]
```

> I wonder if "name clashes" in axioms are ever a real problem. 

Funny that you would say that, as Atiyah's category of "Real" vector bundles would be another example of a likely name clash with what you'd commonly use "Real" for.

> I would hope that
> if two categories `A` and `B` have conflicting ideas over what the axiom
> named `d` must mean, then any common supercategory doesn't implement either

Yes, I'm aware that you could use the same adjective provide that they are not joined by a common supercategory. It seems a bit fragile as adding new supercategories may then have very non-local consequences. Moreover, for differential operators, say, I think it would be possible (if highly unusual) to ask them to form a "Rigid" category. So they can't be separated by not having a common supercategory, at least not in a mathematically satisfying way.



---

archive/issue_comments_109192.json:
```json
{
    "body": "<a id='comment:407'></a>\nReplying to [SimonKing](#comment%3A403):\n> This model relies on the observation that you *must* have an additive and a multiplicative magma among the super categories, if you want to have distributivity: Their join is the most basic category that can carry this axiom.\n\nYes, and a stand-alone axiom class would be the ideal place to implement a `is_applicable_to(category)` method that could be implemented exactly as you say. And as implementer you don't have to figure out what that join is to find the right place for your code.",
    "created_at": "2014-01-16T17:24:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109192",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:407'></a>
Replying to [SimonKing](#comment%3A403):
> This model relies on the observation that you *must* have an additive and a multiplicative magma among the super categories, if you want to have distributivity: Their join is the most basic category that can carry this axiom.

Yes, and a stand-alone axiom class would be the ideal place to implement a `is_applicable_to(category)` method that could be implemented exactly as you say. And as implementer you don't have to figure out what that join is to find the right place for your code.



---

archive/issue_comments_109193.json:
```json
{
    "body": "**Changing commit** from \"[8045aa4a4b7ada735b3eb6055382f9b341a39f1e](https://github.com/sagemath/sagetrac-mirror/commit/8045aa4a4b7ada735b3eb6055382f9b341a39f1e)\" to \"[eb7b486c6fecac296052f980788e15e2ad1b59e4](https://github.com/sagemath/sagetrac-mirror/commit/eb7b486c6fecac296052f980788e15e2ad1b59e4)\".",
    "created_at": "2014-01-16T17:57:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109193",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[8045aa4a4b7ada735b3eb6055382f9b341a39f1e](https://github.com/sagemath/sagetrac-mirror/commit/8045aa4a4b7ada735b3eb6055382f9b341a39f1e)" to "[eb7b486c6fecac296052f980788e15e2ad1b59e4](https://github.com/sagemath/sagetrac-mirror/commit/eb7b486c6fecac296052f980788e15e2ad1b59e4)".



---

archive/issue_comments_109194.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/eb7b486c6fecac296052f980788e15e2ad1b59e4\">eb7b486</a></td><td><code>Merge branch 'develop' into public/ticket/10963</code></td></tr></table>\n",
    "created_at": "2014-01-16T17:57:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109194",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/eb7b486c6fecac296052f980788e15e2ad1b59e4">eb7b486</a></td><td><code>Merge branch 'develop' into public/ticket/10963</code></td></tr></table>




---

archive/issue_comments_109195.json:
```json
{
    "body": "<a id='comment:9'></a>\nAnother important issue that I think still needs discussion are the relations between different categories-with-axioms. It seems to me, thought I can't find it spelled out in the docs, that we want to allow arbitrary relations of the type\n\n```\ncategory1 * axiom2 = category3 * axiom4 * axiom5\n```\nI'm writing this as multiplication to stress the commutativity of axioms and the formal analogy with radical toric (or binomial) ideals. As usual in the presence of relations, one can either work with equivalence classes or normal forms (unique representatives). There is some talk about manually specifying some distinguished representative/default construction on this ticket, but I don't understand why that would be desirable. \n\nTo figure out all relations, we clearly need a Groebner basis for relations. There are some well-known facts about Buchberger's algorithm that ought be of importance to us:\n* It should not be implemented recursively\n* The \"greedy\" approach does not work: S-polynomials involving high-degree terms can and will give rise to lower-degree generators. In other words, you cannot expect to arrive at the normal form by removing axioms at each step.\n* Being explicit about term orders is key to the implementation\n\nThere is also a consistency issue about user-supplied axioms: They must not induce further relations for the categories and axioms that Sage ships with.",
    "created_at": "2014-01-16T18:28:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109195",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:9'></a>
Another important issue that I think still needs discussion are the relations between different categories-with-axioms. It seems to me, thought I can't find it spelled out in the docs, that we want to allow arbitrary relations of the type

```
category1 * axiom2 = category3 * axiom4 * axiom5
```
I'm writing this as multiplication to stress the commutativity of axioms and the formal analogy with radical toric (or binomial) ideals. As usual in the presence of relations, one can either work with equivalence classes or normal forms (unique representatives). There is some talk about manually specifying some distinguished representative/default construction on this ticket, but I don't understand why that would be desirable. 

To figure out all relations, we clearly need a Groebner basis for relations. There are some well-known facts about Buchberger's algorithm that ought be of importance to us:
* It should not be implemented recursively
* The "greedy" approach does not work: S-polynomials involving high-degree terms can and will give rise to lower-degree generators. In other words, you cannot expect to arrive at the normal form by removing axioms at each step.
* Being explicit about term orders is key to the implementation

There is also a consistency issue about user-supplied axioms: They must not induce further relations for the categories and axioms that Sage ships with.



---

archive/issue_comments_109196.json:
```json
{
    "body": "<a id='comment:410'></a>\nReplying to [vbraun](#comment%3A409):\n> Another important issue that I think still needs discussion are the relations between different categories-with-axioms. It seems to me, thought I can't find it spelled out in the docs, that we want to allow arbitrary relations of the type\n> \n> ```\n> category1 * axiom2 = category3 * axiom4 * axiom5\n> ```\n> I'm writing this as multiplication to stress the commutativity of axioms and the formal analogy with radical toric (or binomial) ideals.\n\nIt is clear that this can't work in full mathematical generality (since in principle there is an infinity of potential axioms to consider). But in a CAS, it could actually work. Let's discuss it:\n\n- At any point in time, we have a finite list of axioms (it may grow in future, though).\n- At any point in time, we have a finite set of \"basic categories\": By this, I mean categories that provide the above mentioned \"features\": `Sets` (provides `__contains__`), `Magmas` (provides (`__mul__`), `AdditiveMagmas` (provides `__add__`) and so on.\n- The union of the \"basic categories\" and the axioms generates a commutative monoid: Multiplying categories means forming the join, multiplying with axioms means applying them.\n- If I understand correctly, Nicolas has introduced an ordering on the set of categories anyway. In any case, it is clear that we *can* introduce an ordering on the commutative monoid.\n- The relations are, as you remark, binomial. Thus, the word problem in our commutative monoid modulo relations can be solved by means of Gr\u00f6bner bases.\n\nSo far, the approach looks good. However, here is a problem: How do we model the fact that the axiom `Distributive` does not apply to `Magmas` and does not apply to `AdditiveMagmas`, but does apply to `Magmas*AdditiveMagmas`?\n\nPerhaps we actually do not need to model this fact in or commutative\nmonoid. Any categorial construction corresponds to an element of the\nmonoid. Two constructions result in the same category if and only if the\nnormal forms (modulo relations) of the corresponding monoid elements coincide. Hence,\neach standard monomial is a potential label of a category. However, it should\nbe fine to assume that only a subset of the standard monomials actually occurs\nas label: `Magmas*Distributive` does not occur as label of a category, but\n`Magmas*AdditiveMagmas*Distributive` does occur.",
    "created_at": "2014-01-16T20:30:06Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109196",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:410'></a>
Replying to [vbraun](#comment%3A409):
> Another important issue that I think still needs discussion are the relations between different categories-with-axioms. It seems to me, thought I can't find it spelled out in the docs, that we want to allow arbitrary relations of the type
> 
> ```
> category1 * axiom2 = category3 * axiom4 * axiom5
> ```
> I'm writing this as multiplication to stress the commutativity of axioms and the formal analogy with radical toric (or binomial) ideals.

It is clear that this can't work in full mathematical generality (since in principle there is an infinity of potential axioms to consider). But in a CAS, it could actually work. Let's discuss it:

- At any point in time, we have a finite list of axioms (it may grow in future, though).
- At any point in time, we have a finite set of "basic categories": By this, I mean categories that provide the above mentioned "features": `Sets` (provides `__contains__`), `Magmas` (provides (`__mul__`), `AdditiveMagmas` (provides `__add__`) and so on.
- The union of the "basic categories" and the axioms generates a commutative monoid: Multiplying categories means forming the join, multiplying with axioms means applying them.
- If I understand correctly, Nicolas has introduced an ordering on the set of categories anyway. In any case, it is clear that we *can* introduce an ordering on the commutative monoid.
- The relations are, as you remark, binomial. Thus, the word problem in our commutative monoid modulo relations can be solved by means of Gröbner bases.

So far, the approach looks good. However, here is a problem: How do we model the fact that the axiom `Distributive` does not apply to `Magmas` and does not apply to `AdditiveMagmas`, but does apply to `Magmas*AdditiveMagmas`?

Perhaps we actually do not need to model this fact in or commutative
monoid. Any categorial construction corresponds to an element of the
monoid. Two constructions result in the same category if and only if the
normal forms (modulo relations) of the corresponding monoid elements coincide. Hence,
each standard monomial is a potential label of a category. However, it should
be fine to assume that only a subset of the standard monomials actually occurs
as label: `Magmas*Distributive` does not occur as label of a category, but
`Magmas*AdditiveMagmas*Distributive` does occur.



---

archive/issue_comments_109197.json:
```json
{
    "body": "<a id='comment:411'></a>\nPS:\n\nReplying to [vbraun](#comment%3A409):\n> There is also a consistency issue about user-supplied axioms: They must not induce further relations for the categories and axioms that Sage ships with.\n\nWhy?\n\nImagine Wedderburn lived today. We wouldn't know that all finite division rings are commutative. Hence, `Rings.Division().Finite()` and `Fields().Finite()` would be distinct categories. Then, Wedderburn proves his theorem. We add his theorem as a relation, and as a result we have a new relation between previously distinct categories in Sage. I don't think this would be a problem.\n\nThe only requirement: When adding a new axiom or a new basic category, the original commutative monoid must be extended, and the ordering of the enlarged monoid must be compatible with the ordering of the original monoid; The original monoid must be an ordered submonoid of the enlarged monoid. By this requirement, we can keep using the Gr\u00f6bner basis we had for the relations in the original monoid.",
    "created_at": "2014-01-16T20:37:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109197",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:411'></a>
PS:

Replying to [vbraun](#comment%3A409):
> There is also a consistency issue about user-supplied axioms: They must not induce further relations for the categories and axioms that Sage ships with.

Why?

Imagine Wedderburn lived today. We wouldn't know that all finite division rings are commutative. Hence, `Rings.Division().Finite()` and `Fields().Finite()` would be distinct categories. Then, Wedderburn proves his theorem. We add his theorem as a relation, and as a result we have a new relation between previously distinct categories in Sage. I don't think this would be a problem.

The only requirement: When adding a new axiom or a new basic category, the original commutative monoid must be extended, and the ordering of the enlarged monoid must be compatible with the ordering of the original monoid; The original monoid must be an ordered submonoid of the enlarged monoid. By this requirement, we can keep using the Gröbner basis we had for the relations in the original monoid.



---

archive/issue_comments_109198.json:
```json
{
    "body": "<a id='comment:2'></a>\nPPS: Actually the situation is even easier.\n\nIf we understand multiplication in the monoid as I have stated above, then all generators are idempotents. `C*C` is the join of `C` with itself (`C*C=C`), and applying the same axiom `A` twice is the same as applying it once (again, `A*A=A`).\n\nHence, we have a tool in Sage that can easily be instrumented to provide descriptions for categorial constructions and also to provide *unique* identifiers of categories: Polybori!",
    "created_at": "2014-01-16T20:45:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109198",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
PPS: Actually the situation is even easier.

If we understand multiplication in the monoid as I have stated above, then all generators are idempotents. `C*C` is the join of `C` with itself (`C*C=C`), and applying the same axiom `A` twice is the same as applying it once (again, `A*A=A`).

Hence, we have a tool in Sage that can easily be instrumented to provide descriptions for categorial constructions and also to provide *unique* identifiers of categories: Polybori!



---

archive/issue_comments_109199.json:
```json
{
    "body": "<a id='comment:3'></a>\nI agree that, as long as you don't try to express relations that combine mismatched categories/axioms, you shouldn't have to worry about that. \n\nThe potential problem with additional relations is that you might have already constructed distinct categories Rings + division + finite and Fields + finite. At that point I think its fine to require that Wedderburn has to restart Sage.\n\nI don't quite understand how Polybori solves this, `Z/2Z` has only idempotents but `Z/2Z[x]` does not. Of course you can add `x^2=x` as relation to the ideal. Or just work with square-free / radical ideals. Either way thats a bit of a technicality that does fit into this analogy.",
    "created_at": "2014-01-16T21:07:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109199",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:3'></a>
I agree that, as long as you don't try to express relations that combine mismatched categories/axioms, you shouldn't have to worry about that. 

The potential problem with additional relations is that you might have already constructed distinct categories Rings + division + finite and Fields + finite. At that point I think its fine to require that Wedderburn has to restart Sage.

I don't quite understand how Polybori solves this, `Z/2Z` has only idempotents but `Z/2Z[x]` does not. Of course you can add `x^2=x` as relation to the ideal. Or just work with square-free / radical ideals. Either way thats a bit of a technicality that does fit into this analogy.



---

archive/issue_comments_109200.json:
```json
{
    "body": "<a id='comment:414'></a>\nReplying to [vbraun](#comment%3A413):\n> At that point I think its fine to require that Wedderburn has to restart Sage.\n\nSure, that's what I meant.\n \n> I don't quite understand how Polybori solves this, `Z/2Z` has only idempotents but `Z/2Z[x]` does not.\n\n`x^2=x` is intrinsic in polybori. That's why I think polybori is the right tool for implementing the model: It provides an efficient Gr\u00f6bner basis implementation for rings generated by idempotents.\n\n```\nsage: P.<magma, additive_magma, ring, distributive, finite,division,commutative> = BooleanPolynomialRing()\nsage: magma*magma\nmagma\nsage: R = P*[ring*division*finite-ring*division*commutative*finite, ring-magma*additive_magma*distributive]\nsage: R.groebner_basis()\n[magma*additive_magma*distributive + ring, magma*ring + ring, additive_magma*ring + ring, ring*distributive + ring, ring*finite*division*commutative + ring*finite*division]\nsage: (magma*additive_magma*distributive*finite*division).reduce(R.groebner_basis())\nring*finite*division\nsage: (ring*commutative*finite*division).reduce(R.groebner_basis())\nring*finite*division\n```\n\nI think this is more or less what we want.",
    "created_at": "2014-01-16T21:51:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109200",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:414'></a>
Replying to [vbraun](#comment%3A413):
> At that point I think its fine to require that Wedderburn has to restart Sage.

Sure, that's what I meant.
 
> I don't quite understand how Polybori solves this, `Z/2Z` has only idempotents but `Z/2Z[x]` does not.

`x^2=x` is intrinsic in polybori. That's why I think polybori is the right tool for implementing the model: It provides an efficient Gröbner basis implementation for rings generated by idempotents.

```
sage: P.<magma, additive_magma, ring, distributive, finite,division,commutative> = BooleanPolynomialRing()
sage: magma*magma
magma
sage: R = P*[ring*division*finite-ring*division*commutative*finite, ring-magma*additive_magma*distributive]
sage: R.groebner_basis()
[magma*additive_magma*distributive + ring, magma*ring + ring, additive_magma*ring + ring, ring*distributive + ring, ring*finite*division*commutative + ring*finite*division]
sage: (magma*additive_magma*distributive*finite*division).reduce(R.groebner_basis())
ring*finite*division
sage: (ring*commutative*finite*division).reduce(R.groebner_basis())
ring*finite*division
```

I think this is more or less what we want.



---

archive/issue_comments_109201.json:
```json
{
    "body": "<a id='comment:5'></a>\nPS: Adding a generator `field` to our boolean polynomial ring, we get\n\n```\nsage: P.<magma, additive_magma, ring, field, distributive, finite, division, commutative> = BooleanPolynomialRing()\nsage: R = P*[field-ring*division*commutative, ring*division*finite-ring*division*commutative*finite, ring-magma*additive_magma*distributive]\nsage: (magma*additive_magma*distributive*finite*division).reduce(R.groebner_basis())\nfield*finite\nsage: (ring*commutative*finite*division).reduce(R.groebner_basis())\nfield*finite\n```",
    "created_at": "2014-01-16T21:54:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109201",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
PS: Adding a generator `field` to our boolean polynomial ring, we get

```
sage: P.<magma, additive_magma, ring, field, distributive, finite, division, commutative> = BooleanPolynomialRing()
sage: R = P*[field-ring*division*commutative, ring*division*finite-ring*division*commutative*finite, ring-magma*additive_magma*distributive]
sage: (magma*additive_magma*distributive*finite*division).reduce(R.groebner_basis())
field*finite
sage: (ring*commutative*finite*division).reduce(R.groebner_basis())
field*finite
```



---

archive/issue_comments_109202.json:
```json
{
    "body": "<a id='comment:416'></a>\nReplying to [SimonKing](#comment%3A403):\n> Actually, from a practical point of view, I'd prefer to have something that works (i.e., this code) and move on to a different (better?) model later.\n> ... lots of fun design ideas ...\n> But I think it would be a mistake to do this presumably/hopefully \"small\" change now, i.e. before merging Nicolas' code.\n\nYes, please!!!\n\nGuys, this is a very interesting discussion and we should pursue it;\nthere is a whole research area to explore. But I believe we should\nreally do that elsewhere. Here, we have a well defined task, namely to\ndevise a plan to finalize this ticket as soon as possible. There is a\nlot of code that has been waiting for the features way too long, and\nit's blocking the work of several developers. We also have a long\nbacklog of further important developments around categories\n(morphisms, ...).\n\nThe core question is what absolutely needs to be done *now* ?\n\n- Writing that last section in the documentation of axioms describing\n  the current core algorithm. I still have 2-3 hours to spend on\n  it. Hopefully that will be done tomorrow. Worst case by Monday.\n\n- Reviewing the documentation of axioms. Jean-Baptiste already did\n  some proofreading, but another pass is needed, especially for the\n  latest sections. Who can take care of this?\n\n- Deciding whether we want to keep the latest experimental changes by\n  Simon in the current branch.\n\n- Merging in my branch, with or without Simon's changes\n\n- Rerunning all tests\n\n- What else?\n\nThanks!\n                              Nicolas",
    "created_at": "2014-01-16T23:19:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109202",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:416'></a>
Replying to [SimonKing](#comment%3A403):
> Actually, from a practical point of view, I'd prefer to have something that works (i.e., this code) and move on to a different (better?) model later.
> ... lots of fun design ideas ...
> But I think it would be a mistake to do this presumably/hopefully "small" change now, i.e. before merging Nicolas' code.

Yes, please!!!

Guys, this is a very interesting discussion and we should pursue it;
there is a whole research area to explore. But I believe we should
really do that elsewhere. Here, we have a well defined task, namely to
devise a plan to finalize this ticket as soon as possible. There is a
lot of code that has been waiting for the features way too long, and
it's blocking the work of several developers. We also have a long
backlog of further important developments around categories
(morphisms, ...).

The core question is what absolutely needs to be done *now* ?

- Writing that last section in the documentation of axioms describing
  the current core algorithm. I still have 2-3 hours to spend on
  it. Hopefully that will be done tomorrow. Worst case by Monday.

- Reviewing the documentation of axioms. Jean-Baptiste already did
  some proofreading, but another pass is needed, especially for the
  latest sections. Who can take care of this?

- Deciding whether we want to keep the latest experimental changes by
  Simon in the current branch.

- Merging in my branch, with or without Simon's changes

- Rerunning all tests

- What else?

Thanks!
                              Nicolas



---

archive/issue_comments_109203.json:
```json
{
    "body": "<a id='comment:7'></a>\nJust two last comments and I stop participating here to the long term\ndesign discussion.\n\n- I believe the right conceptual setting for what we are doing is that\n  of lattices (certainly not an original claim; lattice theory has\n  been used for a long time for the concept analysis, analysis and\n  design of hierarchy of classes, and so on). That's where we should\n  be looking for data structures, algorithms, and possibly\n  implementations.\n\n- There might be a case for having Sage depend on some non trivial\n  pieces of external software (Polybori, Singular, ...) for its very\n  programming framework, and in particular for its startup. gcc itself\n  uses polyhedra software for loop optimization purposes (cloog), so\n  maybe that's not completely crazy. But that would certainly be a\n  hard sell, and with good reasons.\n\n  I so far went for a self-contained approach, even if this meant for\n  example a bit of duplicated code between the category code and that\n  for Sage lattices.",
    "created_at": "2014-01-16T23:36:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109203",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:7'></a>
Just two last comments and I stop participating here to the long term
design discussion.

- I believe the right conceptual setting for what we are doing is that
  of lattices (certainly not an original claim; lattice theory has
  been used for a long time for the concept analysis, analysis and
  design of hierarchy of classes, and so on). That's where we should
  be looking for data structures, algorithms, and possibly
  implementations.

- There might be a case for having Sage depend on some non trivial
  pieces of external software (Polybori, Singular, ...) for its very
  programming framework, and in particular for its startup. gcc itself
  uses polyhedra software for loop optimization purposes (cloog), so
  maybe that's not completely crazy. But that would certainly be a
  hard sell, and with good reasons.

  I so far went for a self-contained approach, even if this meant for
  example a bit of duplicated code between the category code and that
  for Sage lattices.



---

archive/issue_comments_109204.json:
```json
{
    "body": "<a id='comment:418'></a>\n> Guys, this is a very interesting discussion and we should pursue it;\n> there is a whole research area to explore. But I believe we should\n> really do that elsewhere. Here, we have a well defined task, namely to\n> devise a plan to finalize this ticket as soon as possible. There is a\n> lot of code that has been waiting for the features way too long, and\n> it's blocking the work of several developers. We also have a long\n> backlog of further important developments around categories\n> (morphisms, ...).\n\nNicolas, the review process of a ticket is *PRECISELY* where all design choices should be discussed. The reviewer's role is not to accept all design choices you made without discussing them. It is his role to check and understand each piece of your code and think whether it makes sense or not. The fact that you have a lot of things depending on this ticket is just a result of your own independent development in sage-combinat. THIS is why it takes 3 years to merge a ticket like this one. And now you come and use this argument to say \"Come on guys, a lot of thing already depend on this ticket, let's merge it quick and change things later\".\n\nThis is not fair. You should not think of the review as a bother, preventing you from getting tickets in Sage. The review is THE thing that makes your code not just \"your own thing\" but a piece of code that several people agree on. Something we think good for the software and want to have inside.\n\nYou should use the review as a test, to find out whether your code makes sense. Whether people understand it. If the reviewers do not understand what the code does from the doc, it means that the doc should be rewritten, and rewritten again until it is clear.\n\nHow many exchanges do you think it takes to implement a 10lines functions like Frederic's polynomials (#15662 for instance) ? The function's name is discussed, the efficiency of the algorithm, the correction. Hell, ten lines of code take several hours, and at the end the patch is good, tested and clear. We did our best, and there is no stuff \"left to be done\". And it is not very long ago that you began to write the doc explaining how it was to be used !\n\nThis is what you read at the beginnig on Knuth's books :\n\n\"Here is your book, the one your thousands of letters have asked us to publish. It has taken us years to do, checking and rechecking countless recipes to bring you only the best, only the interesting, only the perfect. Now we can say, without a shadow of a doubt, that every single one of them, if you follow the directions to the letter, will work for you exactly as well as it did for us, even if you have never cooked before.\"\n\nWe should build a software like that. We shouldn't write anything in there if we don't think that it is reliable, or that it will have to be rewritten again. Let's write something *GOOD*.\n\n> The core question is what absolutely needs to be done *now* ?\n\nThe only question is : \"what is the best way to do it ?\". And that's why every single line of a patch needs to be thought upon.\n\nPlease don't try to cut the discussions short.\n\nNathann",
    "created_at": "2014-01-16T23:37:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109204",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:418'></a>
> Guys, this is a very interesting discussion and we should pursue it;
> there is a whole research area to explore. But I believe we should
> really do that elsewhere. Here, we have a well defined task, namely to
> devise a plan to finalize this ticket as soon as possible. There is a
> lot of code that has been waiting for the features way too long, and
> it's blocking the work of several developers. We also have a long
> backlog of further important developments around categories
> (morphisms, ...).

Nicolas, the review process of a ticket is *PRECISELY* where all design choices should be discussed. The reviewer's role is not to accept all design choices you made without discussing them. It is his role to check and understand each piece of your code and think whether it makes sense or not. The fact that you have a lot of things depending on this ticket is just a result of your own independent development in sage-combinat. THIS is why it takes 3 years to merge a ticket like this one. And now you come and use this argument to say "Come on guys, a lot of thing already depend on this ticket, let's merge it quick and change things later".

This is not fair. You should not think of the review as a bother, preventing you from getting tickets in Sage. The review is THE thing that makes your code not just "your own thing" but a piece of code that several people agree on. Something we think good for the software and want to have inside.

You should use the review as a test, to find out whether your code makes sense. Whether people understand it. If the reviewers do not understand what the code does from the doc, it means that the doc should be rewritten, and rewritten again until it is clear.

How many exchanges do you think it takes to implement a 10lines functions like Frederic's polynomials (#15662 for instance) ? The function's name is discussed, the efficiency of the algorithm, the correction. Hell, ten lines of code take several hours, and at the end the patch is good, tested and clear. We did our best, and there is no stuff "left to be done". And it is not very long ago that you began to write the doc explaining how it was to be used !

This is what you read at the beginnig on Knuth's books :

"Here is your book, the one your thousands of letters have asked us to publish. It has taken us years to do, checking and rechecking countless recipes to bring you only the best, only the interesting, only the perfect. Now we can say, without a shadow of a doubt, that every single one of them, if you follow the directions to the letter, will work for you exactly as well as it did for us, even if you have never cooked before."

We should build a software like that. We shouldn't write anything in there if we don't think that it is reliable, or that it will have to be rewritten again. Let's write something *GOOD*.

> The core question is what absolutely needs to be done *now* ?

The only question is : "what is the best way to do it ?". And that's why every single line of a patch needs to be thought upon.

Please don't try to cut the discussions short.

Nathann



---

archive/issue_comments_109205.json:
```json
{
    "body": "<a id='comment:9'></a>\nNicolas, I like you and your contribution but I don't think you understood what I'm saying. So let me be completely blunt: This ticket is nowhere near ready to be merged, and I'm totally opposed to giving it positive review at this point. We really should have had this discussion before the first line was written. You failed to seek any external input when drafting it. There is no post to sage-devel about this. We even have a formal RFC process (SEP) for foundational changes which you did not pursue either. So if this is too late in the whole process for a basic discussion then that is your own fault.\n\nIMHO we have to at least get rid of the open-ended list of blessed adjectives that have special hidden/surprising meaning. This includes all cases where substrings of class names are matched. We can change the implementation details later, but whatever programming interface we fix now will be exceedingly difficult to change once this is merged. Its hard enough to communicate a design paradigm to the wider developer community, it would be entirely confusing to change it in a year.\n\nAnything else, including the implementation (but not the programming interface for specifying) relations could be left for later, I agree. But without having a reasonable idea of what kind of relations we want to support we can't devise a suitable programming interface. In particular, I think your current interface of specifying a list of `extra_super_categories()` is fundamentally flawed for the reasons that I stated.",
    "created_at": "2014-01-17T02:43:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109205",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:9'></a>
Nicolas, I like you and your contribution but I don't think you understood what I'm saying. So let me be completely blunt: This ticket is nowhere near ready to be merged, and I'm totally opposed to giving it positive review at this point. We really should have had this discussion before the first line was written. You failed to seek any external input when drafting it. There is no post to sage-devel about this. We even have a formal RFC process (SEP) for foundational changes which you did not pursue either. So if this is too late in the whole process for a basic discussion then that is your own fault.

IMHO we have to at least get rid of the open-ended list of blessed adjectives that have special hidden/surprising meaning. This includes all cases where substrings of class names are matched. We can change the implementation details later, but whatever programming interface we fix now will be exceedingly difficult to change once this is merged. Its hard enough to communicate a design paradigm to the wider developer community, it would be entirely confusing to change it in a year.

Anything else, including the implementation (but not the programming interface for specifying) relations could be left for later, I agree. But without having a reasonable idea of what kind of relations we want to support we can't devise a suitable programming interface. In particular, I think your current interface of specifying a list of `extra_super_categories()` is fundamentally flawed for the reasons that I stated.



---

archive/issue_comments_109206.json:
```json
{
    "body": "<a id='comment:420'></a>\nReplying to [vbraun](#comment%3A419):\n> Nicolas, I like you and your contribution but I don't think you\n> understood what I'm saying.\n\nI did. The discussion was honestly going out of topic, and I asked\nconcretely \"what else?\" had to be done now. Thanks for the second part\nof your message elaborating on that question.\n\n> So let me be completely blunt: This\n> ticket is nowhere near ready to be merged, and I'm totally opposed\n> to giving it positive review at this point. We really should have\n> had this discussion before the first line was written. You failed to\n> seek any external input when drafting it. There is no post to\n> sage-devel about this.\n\nLet's see:\n\n- I have been mentioning this ticket over and over on sage-devel, not\n  counting sage-combinat-devel. Here is a sample among those:\n\n  https://groups.google.com/forum/?fromgroups#!searchin/sage-devel/10963/sage-devel/1lZAr60N-8w/vHr6nOWrsfcJ\n  https://groups.google.com/forum/?fromgroups#!searchin/sage-devel/10963/sage-devel/chC1qH455Qs/NDiN3IOPLBgJ\n\n- I have made presentations about it in at least four Sage days.\n\n- Throughout the whole design process, I have had countless long\n  e-mail/trac/oral discussions with some of those that care most about\n  categories, in particular Florent Hivert and Simon King. Simon even\n  came to Orsay twice in good part to discuss about this.\n\n- The code has been publicly available all time through, with an easy\n  way to install it, try it, and see non trivial use cases\n  (sage -combinat install).\n\n- The code has been used by quite a few people.\n\nWith that, I believed that everybody interested in the category\ninfrastructure was aware that non trivial changes were coming. I would\nhave been happy to expand on the details if anyone had just asked.\n\nGranted: there was no framed official request for comments. Point\ntaken for next time.\n\n> We even have a formal RFC process (SEP) for foundational changes\n> which you did not pursue either.\n\nWhere is it formalized? How many time has it been used?\n\nI certainly can see the point of formalizing certain processes. Yet, I\nbelieve that this also has its limits. The point is that, if I had\npresented a draft of the current design two-three years ago, the\nreactions would have been: \"that's just all crazy overdesign\", \"what's\nthe point?\", or \"it can't be made to work reasonably\". And that would\nhave been perfectly fair: I was asking myself the very same question,\nand there indeed were some non trivial hurdles to overcome (e.g. the\nC3 business).\n\nFor such an infrastructure to be convincing, I think it has to be\nseriously battlefield tested, for otherwise it only leads to never\nending unsupported-by-facts discussions (I have seen sooo many of\nthose). The main point is how it feels in practice to write code using\nthe infrastructure, and in particular how it scales. Not counting: can\nSage start if we actually refactor the internals?  are there\nperformance issues? Can we get to all doctests passing? More than\nthat: you need (at least *I* need) several iterations of battlefield\ntesting (three complete rewrites in the case at hand) before\nconverging to a proper design; at least one that convinces me.\n\n\nThat being said, let's move to the interesting part.\n\n\n> IMHO we have to at least get rid of the open-ended list of blessed adjectives that have special hidden/surprising meaning. This includes all cases where substrings of class names are matched. We can change the implementation details later, but whatever programming interface we fix now will be exceedingly difficult to change once this is merged. Its hard enough to communicate a design paradigm to the wider developer community, it would be entirely confusing to change it in a year.\n> \n> Anything else, including the implementation (but not the programming interface for specifying) relations could be left for later, I agree. But without having a reasonable idea of what kind of relations we want to support we can't devise a suitable programming interface. In particular, I think your current interface of specifying a list of `extra_super_categories()` is fundamentally flawed for the reasons that I stated.\n\nVery well. I appreciate your suggestions, but so far none of them\nconvinced me. Well no, that's not right: I found the idiom\n{{{F(axiom.Finite, axiom.Commutative)}} very interesting though it\ndoes not buy the rest. In each case, either I see fine points where\nthey are likely to be unimplementable within the desired features, or\nI believe that they will make category code less nice to write.  I'd\nbe happy to be proven wrong, but it does not make any sense for me\nimplementing something I don't not believe in a priori. Alternatively,\nwe can spend a couple days discussing step by step the details.\n\nNo, as you have proven repeatedly, in particular with the git\ntransition, you are a man of action. If you are convinced some change\nis right and easy, prove me wrong by implementing a convincing\nprototype, say in a review branch. No need to be perfect. I am happy\npolishing the details.\n\nAs for the ``fundamentally flawed extra_super_categories()\ninterface''. It's not about relations in an algebra. It's about a\ncompletion computation in a lattice. And in this context I believe\nit's correct. Shall I write a formal proof of the algorithm? At least\nI would have the feeling to be investing my time for the day I would\nwrite a paper on the topic.\n\nBest,\n                                 Nicolas",
    "created_at": "2014-01-17T23:46:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109206",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:420'></a>
Replying to [vbraun](#comment%3A419):
> Nicolas, I like you and your contribution but I don't think you
> understood what I'm saying.

I did. The discussion was honestly going out of topic, and I asked
concretely "what else?" had to be done now. Thanks for the second part
of your message elaborating on that question.

> So let me be completely blunt: This
> ticket is nowhere near ready to be merged, and I'm totally opposed
> to giving it positive review at this point. We really should have
> had this discussion before the first line was written. You failed to
> seek any external input when drafting it. There is no post to
> sage-devel about this.

Let's see:

- I have been mentioning this ticket over and over on sage-devel, not
  counting sage-combinat-devel. Here is a sample among those:

  https://groups.google.com/forum/?fromgroups#!searchin/sage-devel/10963/sage-devel/1lZAr60N-8w/vHr6nOWrsfcJ
  https://groups.google.com/forum/?fromgroups#!searchin/sage-devel/10963/sage-devel/chC1qH455Qs/NDiN3IOPLBgJ

- I have made presentations about it in at least four Sage days.

- Throughout the whole design process, I have had countless long
  e-mail/trac/oral discussions with some of those that care most about
  categories, in particular Florent Hivert and Simon King. Simon even
  came to Orsay twice in good part to discuss about this.

- The code has been publicly available all time through, with an easy
  way to install it, try it, and see non trivial use cases
  (sage -combinat install).

- The code has been used by quite a few people.

With that, I believed that everybody interested in the category
infrastructure was aware that non trivial changes were coming. I would
have been happy to expand on the details if anyone had just asked.

Granted: there was no framed official request for comments. Point
taken for next time.

> We even have a formal RFC process (SEP) for foundational changes
> which you did not pursue either.

Where is it formalized? How many time has it been used?

I certainly can see the point of formalizing certain processes. Yet, I
believe that this also has its limits. The point is that, if I had
presented a draft of the current design two-three years ago, the
reactions would have been: "that's just all crazy overdesign", "what's
the point?", or "it can't be made to work reasonably". And that would
have been perfectly fair: I was asking myself the very same question,
and there indeed were some non trivial hurdles to overcome (e.g. the
C3 business).

For such an infrastructure to be convincing, I think it has to be
seriously battlefield tested, for otherwise it only leads to never
ending unsupported-by-facts discussions (I have seen sooo many of
those). The main point is how it feels in practice to write code using
the infrastructure, and in particular how it scales. Not counting: can
Sage start if we actually refactor the internals?  are there
performance issues? Can we get to all doctests passing? More than
that: you need (at least *I* need) several iterations of battlefield
testing (three complete rewrites in the case at hand) before
converging to a proper design; at least one that convinces me.


That being said, let's move to the interesting part.


> IMHO we have to at least get rid of the open-ended list of blessed adjectives that have special hidden/surprising meaning. This includes all cases where substrings of class names are matched. We can change the implementation details later, but whatever programming interface we fix now will be exceedingly difficult to change once this is merged. Its hard enough to communicate a design paradigm to the wider developer community, it would be entirely confusing to change it in a year.
> 
> Anything else, including the implementation (but not the programming interface for specifying) relations could be left for later, I agree. But without having a reasonable idea of what kind of relations we want to support we can't devise a suitable programming interface. In particular, I think your current interface of specifying a list of `extra_super_categories()` is fundamentally flawed for the reasons that I stated.

Very well. I appreciate your suggestions, but so far none of them
convinced me. Well no, that's not right: I found the idiom
{{{F(axiom.Finite, axiom.Commutative)}} very interesting though it
does not buy the rest. In each case, either I see fine points where
they are likely to be unimplementable within the desired features, or
I believe that they will make category code less nice to write.  I'd
be happy to be proven wrong, but it does not make any sense for me
implementing something I don't not believe in a priori. Alternatively,
we can spend a couple days discussing step by step the details.

No, as you have proven repeatedly, in particular with the git
transition, you are a man of action. If you are convinced some change
is right and easy, prove me wrong by implementing a convincing
prototype, say in a review branch. No need to be perfect. I am happy
polishing the details.

As for the ``fundamentally flawed extra_super_categories()
interface''. It's not about relations in an algebra. It's about a
completion computation in a lattice. And in this context I believe
it's correct. Shall I write a formal proof of the algorithm? At least
I would have the feeling to be investing my time for the day I would
write a paper on the topic.

Best,
                                 Nicolas



---

archive/issue_comments_109207.json:
```json
{
    "body": "<a id='comment:1'></a>\nBurying a post in a long thread titled \"RFC: a good name the category of algebras that are not necessarily associative nor unital\" or a poll whether that is an acceptable performance impact does not constitute an announcement in my book. For the SEP process at work, see e.g. the git transition http://wiki.sagemath.org/WorkflowSEP (wiki search will net you more info)\n\nReplying to [nthiery](#comment%3A420):\n> As for the ``fundamentally flawed extra_super_categories()\n> interface''. It's not about relations in an algebra. It's about a\n> completion computation in a lattice.\n\nI know. Binomial ideals are closely related to lattice ideals. It appears to be commutative algebra, but you actually never form non-trivial polynomials. \n\nStill, my point that you can't expect to arrive at the normal form by removing axioms at each step remains. So just listing supercategories is not a good way of supplying relations, you need a way to get a handle on all relations (without having to instantiate all categories on startup).\n\n> Alternatively, we can spend a couple days discussing step by step the details.\n\nPlease do, I'm interested in what you think is \"likely unimplementable\" in my proposal or how you are going to go about name conflicts in yours. I hate open-ended discussions at least as much as you. And I'm more than willing to push this forward, but I have to be convinced that I'm not pushing the car into a ditch...",
    "created_at": "2014-01-18T04:20:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109207",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:1'></a>
Burying a post in a long thread titled "RFC: a good name the category of algebras that are not necessarily associative nor unital" or a poll whether that is an acceptable performance impact does not constitute an announcement in my book. For the SEP process at work, see e.g. the git transition http://wiki.sagemath.org/WorkflowSEP (wiki search will net you more info)

Replying to [nthiery](#comment%3A420):
> As for the ``fundamentally flawed extra_super_categories()
> interface''. It's not about relations in an algebra. It's about a
> completion computation in a lattice.

I know. Binomial ideals are closely related to lattice ideals. It appears to be commutative algebra, but you actually never form non-trivial polynomials. 

Still, my point that you can't expect to arrive at the normal form by removing axioms at each step remains. So just listing supercategories is not a good way of supplying relations, you need a way to get a handle on all relations (without having to instantiate all categories on startup).

> Alternatively, we can spend a couple days discussing step by step the details.

Please do, I'm interested in what you think is "likely unimplementable" in my proposal or how you are going to go about name conflicts in yours. I hate open-ended discussions at least as much as you. And I'm more than willing to push this forward, but I have to be convinced that I'm not pushing the car into a ditch...



---

archive/issue_comments_109208.json:
```json
{
    "body": "<a id='comment:422'></a>\nReplying to [vbraun](#comment%3A419):\n> IMHO we have to at least get rid of the open-ended list of blessed adjectives that have special hidden/surprising meaning. This includes all cases where substrings of class names are matched. We can change the implementation details later, but whatever programming interface we fix now will be exceedingly difficult to change once this is merged.\n\nAs one of the reviewers, I can tell that Nicolas did seek other people's opinion, although this has partially happened in off-line discussions.\n\nYou are probably aware, but let's make this difference explicit: We have to\ndistinguish the *user interface* from the *programming interface*. I\nbelieve the user interface is nice and natural: Take a category ``C``, and\ntype ``C.Commutative()`` to create a new category obtained from ``C`` by\napplying an axiom. I think it makes sense to do it in this way. It would also\nmake sense to do it like `C.add_axiom(Axiom.Commutative)`. Anyway, the current\nuser interface is sufficiently nice IMHO.\n\nThe programming interface is less nice, as we have discussed. When adding a\nnew category-with-axiom, the programmer needs to provide a *default*\nconstruction, which can either be implicit by the choice of a name, or\nexplicit by providing a \"magical\" class attribute. This is on the new\ncategory; on the base category, another class attribute needs to be created,\nmost likely by a lazy import, or a nested class (which is then the class for\nthe new category).\n\nIn addition to that, there may be non-default constructions yielding the same\ncategory. One (minor) problem is that this additional constructions must not\nbe defined by class attributes (otherwise the assertions happening in the\ncode would complain) but by `SubcategoryMethods`.\n\nA major problem is: How to justify the choice of default versus non-default\nconstructions? Shouldn't there somehow be a globally consistency? And should\nthis concistency not be granted in an automatic way (because otherwise it\nisn't granted)?\n\n> Anything else, including the implementation (but not the programming interface for specifying) relations could be left for later, I agree.\n\nI am not sure if I agree on this statement: Is it really a problem to have a\nhandmade non-scalable (because of global consistency) programming interface\nnow and then replace it by a more automated scalable programming interface?\n\nActually I am more concerned about the implementation of the underlying\nlattice. As in the case of coercion, the lattice structure is given locally,\non the nodes. But some kind of global consistency is required (if you\nconcatenate coercions, then the result must be a coercion as well, but there\ncan be different coercion chains from parent A to parent B, and the\nconcatenation results must all coincide). Sometimes I find it rather\nfrustrating that the coercion lattice is encoded in this way, since fixing a\nglobal problem locally tends to be difficult.\n\nBut Gr\u00f6bner bases of toric ideals are, I think, a tool to treat global\nquestions locally. What do you think of the following attempt of a compromise?\n\n- The user interface `C.Commutative` is nice enough, let's keep it as\n  suggested by Nicolas, for now. In a later stage, if axioms start to get an\n  independent life, the syntax `C.add_axiom(axioms.Commutative)` might be\n  added.\n\n- For practical considerations, I would accept a temporary solution in the\n  programming interface: As we all know, a lot of patches depend on the \"more\n  functorial constructions\", and I guess it would be easier to change the way\n  of defining a default construction later in *one* go rather than in\n  hundred tiny steps (namely by breaking all the existing 100 patches that\n  depend on the functorial constructions). But I am not release manager,\n  perhaps I \"misunderestimate\" the problems.\n\n- *IF* we preserve the current programming interface, then we should add a\n  tool that allows to compute what *should* be the default construction of a\n  new category. As I have demonstrated above, this could be provided by\n  Gr\u00f6bner basis computations in boolean polynomial rings: Input a category\n  construction, output the \"normal form\" of this construction in the lattice,\n  which should then be taken as default construction. So, the programmer can\n  seek advice before doing a choice what to put into\n  `_base_category_class_and_axiom` resp. before chosing a name.\n\n- In a *later* step, this helper tool to achieve consistency could be the\n  fundament of a simpler programmatic interface. The programmer would state\n  somewhere in the code (or by calling a method of some object and then\n  storing an updated database in the Sage sources) that finite division rings\n  are commutative, and (perhaps by a database using labels that are standard\n  monomials in a boolean polynomial ring) would ensure that in all future Sage\n  sessions `Rings.Finite.Division` will coincide with `Fields.Finite`.",
    "created_at": "2014-01-18T10:13:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109208",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:422'></a>
Replying to [vbraun](#comment%3A419):
> IMHO we have to at least get rid of the open-ended list of blessed adjectives that have special hidden/surprising meaning. This includes all cases where substrings of class names are matched. We can change the implementation details later, but whatever programming interface we fix now will be exceedingly difficult to change once this is merged.

As one of the reviewers, I can tell that Nicolas did seek other people's opinion, although this has partially happened in off-line discussions.

You are probably aware, but let's make this difference explicit: We have to
distinguish the *user interface* from the *programming interface*. I
believe the user interface is nice and natural: Take a category ``C``, and
type ``C.Commutative()`` to create a new category obtained from ``C`` by
applying an axiom. I think it makes sense to do it in this way. It would also
make sense to do it like `C.add_axiom(Axiom.Commutative)`. Anyway, the current
user interface is sufficiently nice IMHO.

The programming interface is less nice, as we have discussed. When adding a
new category-with-axiom, the programmer needs to provide a *default*
construction, which can either be implicit by the choice of a name, or
explicit by providing a "magical" class attribute. This is on the new
category; on the base category, another class attribute needs to be created,
most likely by a lazy import, or a nested class (which is then the class for
the new category).

In addition to that, there may be non-default constructions yielding the same
category. One (minor) problem is that this additional constructions must not
be defined by class attributes (otherwise the assertions happening in the
code would complain) but by `SubcategoryMethods`.

A major problem is: How to justify the choice of default versus non-default
constructions? Shouldn't there somehow be a globally consistency? And should
this concistency not be granted in an automatic way (because otherwise it
isn't granted)?

> Anything else, including the implementation (but not the programming interface for specifying) relations could be left for later, I agree.

I am not sure if I agree on this statement: Is it really a problem to have a
handmade non-scalable (because of global consistency) programming interface
now and then replace it by a more automated scalable programming interface?

Actually I am more concerned about the implementation of the underlying
lattice. As in the case of coercion, the lattice structure is given locally,
on the nodes. But some kind of global consistency is required (if you
concatenate coercions, then the result must be a coercion as well, but there
can be different coercion chains from parent A to parent B, and the
concatenation results must all coincide). Sometimes I find it rather
frustrating that the coercion lattice is encoded in this way, since fixing a
global problem locally tends to be difficult.

But Gröbner bases of toric ideals are, I think, a tool to treat global
questions locally. What do you think of the following attempt of a compromise?

- The user interface `C.Commutative` is nice enough, let's keep it as
  suggested by Nicolas, for now. In a later stage, if axioms start to get an
  independent life, the syntax `C.add_axiom(axioms.Commutative)` might be
  added.

- For practical considerations, I would accept a temporary solution in the
  programming interface: As we all know, a lot of patches depend on the "more
  functorial constructions", and I guess it would be easier to change the way
  of defining a default construction later in *one* go rather than in
  hundred tiny steps (namely by breaking all the existing 100 patches that
  depend on the functorial constructions). But I am not release manager,
  perhaps I "misunderestimate" the problems.

- *IF* we preserve the current programming interface, then we should add a
  tool that allows to compute what *should* be the default construction of a
  new category. As I have demonstrated above, this could be provided by
  Gröbner basis computations in boolean polynomial rings: Input a category
  construction, output the "normal form" of this construction in the lattice,
  which should then be taken as default construction. So, the programmer can
  seek advice before doing a choice what to put into
  `_base_category_class_and_axiom` resp. before chosing a name.

- In a *later* step, this helper tool to achieve consistency could be the
  fundament of a simpler programmatic interface. The programmer would state
  somewhere in the code (or by calling a method of some object and then
  storing an updated database in the Sage sources) that finite division rings
  are commutative, and (perhaps by a database using labels that are standard
  monomials in a boolean polynomial ring) would ensure that in all future Sage
  sessions `Rings.Finite.Division` will coincide with `Fields.Finite`.



---

archive/issue_comments_109209.json:
```json
{
    "body": "<a id='comment:423'></a>\nReplying to [vbraun](#comment%3A421):\n> Still, my point that you can't expect to arrive at the normal form by removing axioms at each step remains.\n\nI agree that the semantic of _without_axioms and _without_axiom is\ncurrently not strongly specified (though I actually believe we could\nfind a well defined -- but not necessarily useful -- semantic).\n\nIn any case, this is a non issue because those methods are used\nnowhere in the algorithmic. One only recurse by one step on the\nbase_category, and the semantic of this is well defined. Granted, at\nthis point, you have to believe me or convince yourself from the code.\nAs I said, if you believe this is really worth it (how many pieces of\nSage's infrastructure have been formally proven?) I can go the step of\nproving formally the whole thing, but that will take a bit of time.\n\n_without_axioms is only used for finding heuristically a good _repr_.\nAnd it's been doing a good job so far. It's also used for implementing\n_without_axiom: as I mentioned earlier the semantic of the later is\nnot well defined, but is good enough for the single spot where I have\nhad a need for it (removing the ``facade'' axiom when playing with\nposets).\n\n> So just listing supercategories is not a good way of supplying relations, you need a way to get a handle on all relations (without having to instantiate all categories on startup).\n\nI believe the relations are trivial enough that you can lazily handle\nthem along the closure calculation. But I don't have enough room in\nthe margin to prove it here :-)\n\n> Please do, I'm interested in what you think is \"likely unimplementable\" in my proposal or how you are going to go about name conflicts in yours.\n\nThe point is \"within the desired feature set\". For the idiom:\n\n```\n    class C:\n        class Anyname(MyAxiom.Category):\n\t     ...\n```\n\n(1) You need to scan through the entries of ``C`` to decide whether\n    ``C`` implements ``MyAxiom``, right? In particular, you need to\n    evaluate all those entries to test the inheritance, which means\n    triggering lazy imports.\n\n    I think it's an important feature of the current design that you\n    can use a category and some of its axioms while completely\n    ignoring the others. For example, my upcoming tickets will add\n    rather large categories like Semigroups().JTrivial(); those\n    categories have no reason to be loaded upon starting Sage, whereas\n    Semigroups().Commutative() will be constructed.\n\n    In general, I believe one should refrain from evaluating all\n    entries of an object, for some of them might be lazy with good\n    reasons.\n\n(2) Either you define MyAxiom in a location of its own. But then you\n    loose some code locality (the code for the axiom is not tied to\n    the category defining it, which I find important). Or, as I\n    mentioned before, you take the risk of having non trivial\n    refactoring in case you generalize the axiom to a super category\n    later.\n\nAltogether the current design just follows by analogy standard OO\npractice: when a class C defines a method or attribute named ``a``,\nthis fixes the semantic of ``a`` for all subclasses. I don't see that\nthe names for our axioms would be soooo specifically keen to clashes\nthat we need to invent a new mechanism and deviate from standard\npractice. As usual, if a name is potentially ambiguous within its\nfield of application, then it should be made more explicit. That's\ne.g. what we do with \"Associative\" w.r.t. \"AdditiveAssociative\".\n\n\nFor the tuple _base_category_and_axiom: really, if you care, please\nhave a try yourself; it's a small piece of work anyway. I had given it\na shot at some point and then reverted my changes because it did not\nlook feel any better after. I'd be happy being proven wrong.\n\nCheers,\n                                Nicolas",
    "created_at": "2014-01-18T10:36:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109209",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:423'></a>
Replying to [vbraun](#comment%3A421):
> Still, my point that you can't expect to arrive at the normal form by removing axioms at each step remains.

I agree that the semantic of _without_axioms and _without_axiom is
currently not strongly specified (though I actually believe we could
find a well defined -- but not necessarily useful -- semantic).

In any case, this is a non issue because those methods are used
nowhere in the algorithmic. One only recurse by one step on the
base_category, and the semantic of this is well defined. Granted, at
this point, you have to believe me or convince yourself from the code.
As I said, if you believe this is really worth it (how many pieces of
Sage's infrastructure have been formally proven?) I can go the step of
proving formally the whole thing, but that will take a bit of time.

_without_axioms is only used for finding heuristically a good _repr_.
And it's been doing a good job so far. It's also used for implementing
_without_axiom: as I mentioned earlier the semantic of the later is
not well defined, but is good enough for the single spot where I have
had a need for it (removing the ``facade'' axiom when playing with
posets).

> So just listing supercategories is not a good way of supplying relations, you need a way to get a handle on all relations (without having to instantiate all categories on startup).

I believe the relations are trivial enough that you can lazily handle
them along the closure calculation. But I don't have enough room in
the margin to prove it here :-)

> Please do, I'm interested in what you think is "likely unimplementable" in my proposal or how you are going to go about name conflicts in yours.

The point is "within the desired feature set". For the idiom:

```
    class C:
        class Anyname(MyAxiom.Category):
	     ...
```

(1) You need to scan through the entries of ``C`` to decide whether
    ``C`` implements ``MyAxiom``, right? In particular, you need to
    evaluate all those entries to test the inheritance, which means
    triggering lazy imports.

    I think it's an important feature of the current design that you
    can use a category and some of its axioms while completely
    ignoring the others. For example, my upcoming tickets will add
    rather large categories like Semigroups().JTrivial(); those
    categories have no reason to be loaded upon starting Sage, whereas
    Semigroups().Commutative() will be constructed.

    In general, I believe one should refrain from evaluating all
    entries of an object, for some of them might be lazy with good
    reasons.

(2) Either you define MyAxiom in a location of its own. But then you
    loose some code locality (the code for the axiom is not tied to
    the category defining it, which I find important). Or, as I
    mentioned before, you take the risk of having non trivial
    refactoring in case you generalize the axiom to a super category
    later.

Altogether the current design just follows by analogy standard OO
practice: when a class C defines a method or attribute named ``a``,
this fixes the semantic of ``a`` for all subclasses. I don't see that
the names for our axioms would be soooo specifically keen to clashes
that we need to invent a new mechanism and deviate from standard
practice. As usual, if a name is potentially ambiguous within its
field of application, then it should be made more explicit. That's
e.g. what we do with "Associative" w.r.t. "AdditiveAssociative".


For the tuple _base_category_and_axiom: really, if you care, please
have a try yourself; it's a small piece of work anyway. I had given it
a shot at some point and then reverted my changes because it did not
look feel any better after. I'd be happy being proven wrong.

Cheers,
                                Nicolas



---

archive/issue_comments_109210.json:
```json
{
    "body": "<a id='comment:4'></a>\nFor the record: I somehow feel tempted to write a function that is able to test whether the choice of default construction is consistent. So, in the best case, we'll soon have a tool to prove Nicolas' model...",
    "created_at": "2014-01-18T11:32:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109210",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
For the record: I somehow feel tempted to write a function that is able to test whether the choice of default construction is consistent. So, in the best case, we'll soon have a tool to prove Nicolas' model...



---

archive/issue_comments_109211.json:
```json
{
    "body": "<a id='comment:5'></a>\nI have attached [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py), which provides routines to check whether Nicolas' local choice of default constructions for categories with axiom is globally consistent.\n\nIdea:\n\nFirst, we load all available subclasses of `Category`. Those that are not `CategoryWithAxiom` are \"basic\" (or atomic?) categories, and correspond to some generators of a boolean polynomial ring R. The remaining generators of this ring correspond to the available axioms (there is an exhaustive list).\n\nThen, for each category class, it is tested what other category class can be obtained by applying an axiom. Difficulty: Only the default construction can be given by a class attribute. All other constructions have to be given on the level of instances. Hence, if C is a category class and A is an axiom, then C.A might not be available. In this case, I try `C.an_instance().A().__class__.__base__` to get the class that is used to implement the result of applying axiom A to instances of category C.\n\nProblem: There are a couple of categories that do not provide instances! Hence, I couldn't test them. So, for now, we restrict on those cases where we find a way to apply axiom A to category class C, either by an attribute of the class C, or by using an instance of C.\n\nAs we all know, different constructions may yield the same result. This happens 20ish times. Now, each alternative construction yields a relation in the lattice that is modelled by the above mentioned boolean polynomial ring R. Hence, the next step is to create the relation ideal `Rel` of `R`.\n\nAnd now we are ready to test consistency of the choice of default constructions: For each category C with axiom, we have the famous `_base_category_class_and_axiom` attribute. Say, C is obtained from category class B by applying axiom A.\n\nB corresponds to a standard monomial b_monomial, that describes a construction of B. Axiom A corresponds to a generator of the ring R. The condition for consistency is simple: `b_monomial*R(A)` has to be a standard monomial with respect to `Rel`.\n\nAs it turns out, this is largely the case.\n\nProblematic cases:\n- There are 121 category classes that do no support `an_instance()`. So, we can't really vouch for complete consistency. Note, in particular, that `Modules.an_instance()` returns the category of rational vector space, hence, *not* and instance of the class `Modules`.\n- In two cases, applying an axiom to a category class does *not* return a category class:\n\n  ```\n  age: type(sage.categories.category_with_axiom.SmallTestObjects.Connected)\n  <type 'int'>\n  sage: type(sage.categories.category_with_axiom.SmallTestObjects.Commutative)\n  <type 'classobj'>\n  ```\n\nIn only two cases, my routine seems to find non-consistent choices.\n \n1. According to the routine, `Modules.WithBasis` should be `VectorSpaces.WithBasis`.  That's clearly an artefact of the above mentioned problem that `Modules.an_instance()` does not return a category of modules.\n2. In one nonsensical example, my routine finds this inconsistency:\n\n   ```\n   sage: from sage.categories.category_with_axiom import Blahs\n   sage: Blahs.Unital.Blue._base_category_class_and_axiom\n   (sage.categories.category_with_axiom.Blahs.Unital, 'Blue')\n   sage: Blahs().Blue()\n   Category of unital blahs\n   sage: Blahs().Blue() is Blahs().Blue().Unital() is Blahs().Unital()\n   True\n   ```\n   Axioms are supposed to commute. However, we get\n\n   ```\n   sage: Blahs().Blue().Unital() is Blahs().Unital().Blue()\n   False\n   sage: Blahs().Blue().Unital() is Blahs().Unital().Blue()\n   False\n   ```\n   It is thus no surprise that my routine complains here. I won't check now whether this example is *supposed* to demonstrate an illegal construction.\n\n**__Conclusion__**\n\n- I think the basic principle of the consistency check is sound. However, it is incomplete, since a lot of categories do not support `an_instance()`.\n- With the exception of the `Blahs().Unital()` example, Nicolas did a fine job to build the local data in a globally consistent way.\n- If we would go the opposite way, we could turn the consistency check into a method to *create* the default constructions of categories in an automated way (so that Nicolas does not need to choose them manually). Therefore, in the long run, we could have a database of category classes, using identifiers that are monomials with respect to some ideal Rel in a boolean polynomial ring R. Adding a new base category or adding a new axiom means to add more generators to R. Adding a theorem \"these two constructions yield the same category\" add a new generator to the ideal Rel. Global consistency is guaranteed by letting the default constructions correspond to standard monomials with respect to Rel. Note that this would also allow to deal with non-default constructions on the level of category classes and polynomial ideals, hence, without the problem that `an_instance()` often does not work.",
    "created_at": "2014-01-19T00:33:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109211",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
I have attached [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py), which provides routines to check whether Nicolas' local choice of default constructions for categories with axiom is globally consistent.

Idea:

First, we load all available subclasses of `Category`. Those that are not `CategoryWithAxiom` are "basic" (or atomic?) categories, and correspond to some generators of a boolean polynomial ring R. The remaining generators of this ring correspond to the available axioms (there is an exhaustive list).

Then, for each category class, it is tested what other category class can be obtained by applying an axiom. Difficulty: Only the default construction can be given by a class attribute. All other constructions have to be given on the level of instances. Hence, if C is a category class and A is an axiom, then C.A might not be available. In this case, I try `C.an_instance().A().__class__.__base__` to get the class that is used to implement the result of applying axiom A to instances of category C.

Problem: There are a couple of categories that do not provide instances! Hence, I couldn't test them. So, for now, we restrict on those cases where we find a way to apply axiom A to category class C, either by an attribute of the class C, or by using an instance of C.

As we all know, different constructions may yield the same result. This happens 20ish times. Now, each alternative construction yields a relation in the lattice that is modelled by the above mentioned boolean polynomial ring R. Hence, the next step is to create the relation ideal `Rel` of `R`.

And now we are ready to test consistency of the choice of default constructions: For each category C with axiom, we have the famous `_base_category_class_and_axiom` attribute. Say, C is obtained from category class B by applying axiom A.

B corresponds to a standard monomial b_monomial, that describes a construction of B. Axiom A corresponds to a generator of the ring R. The condition for consistency is simple: `b_monomial*R(A)` has to be a standard monomial with respect to `Rel`.

As it turns out, this is largely the case.

Problematic cases:
- There are 121 category classes that do no support `an_instance()`. So, we can't really vouch for complete consistency. Note, in particular, that `Modules.an_instance()` returns the category of rational vector space, hence, *not* and instance of the class `Modules`.
- In two cases, applying an axiom to a category class does *not* return a category class:

  ```
  age: type(sage.categories.category_with_axiom.SmallTestObjects.Connected)
  <type 'int'>
  sage: type(sage.categories.category_with_axiom.SmallTestObjects.Commutative)
  <type 'classobj'>
  ```

In only two cases, my routine seems to find non-consistent choices.
 
1. According to the routine, `Modules.WithBasis` should be `VectorSpaces.WithBasis`.  That's clearly an artefact of the above mentioned problem that `Modules.an_instance()` does not return a category of modules.
2. In one nonsensical example, my routine finds this inconsistency:

   ```
   sage: from sage.categories.category_with_axiom import Blahs
   sage: Blahs.Unital.Blue._base_category_class_and_axiom
   (sage.categories.category_with_axiom.Blahs.Unital, 'Blue')
   sage: Blahs().Blue()
   Category of unital blahs
   sage: Blahs().Blue() is Blahs().Blue().Unital() is Blahs().Unital()
   True
   ```
   Axioms are supposed to commute. However, we get

   ```
   sage: Blahs().Blue().Unital() is Blahs().Unital().Blue()
   False
   sage: Blahs().Blue().Unital() is Blahs().Unital().Blue()
   False
   ```
   It is thus no surprise that my routine complains here. I won't check now whether this example is *supposed* to demonstrate an illegal construction.

**__Conclusion__**

- I think the basic principle of the consistency check is sound. However, it is incomplete, since a lot of categories do not support `an_instance()`.
- With the exception of the `Blahs().Unital()` example, Nicolas did a fine job to build the local data in a globally consistent way.
- If we would go the opposite way, we could turn the consistency check into a method to *create* the default constructions of categories in an automated way (so that Nicolas does not need to choose them manually). Therefore, in the long run, we could have a database of category classes, using identifiers that are monomials with respect to some ideal Rel in a boolean polynomial ring R. Adding a new base category or adding a new axiom means to add more generators to R. Adding a theorem "these two constructions yield the same category" add a new generator to the ideal Rel. Global consistency is guaranteed by letting the default constructions correspond to standard monomials with respect to Rel. Note that this would also allow to deal with non-default constructions on the level of category classes and polynomial ideals, hence, without the problem that `an_instance()` often does not work.



---

archive/issue_comments_109212.json:
```json
{
    "body": "<a id='comment:426'></a>\nReplying to [nthiery](#comment%3A423):\n> The point is \"within the desired feature set\". For the idiom:\n> \n> ```\n>     class C:\n>         class Anyname(MyAxiom.Category):\n> \t     ...\n> ```\n> (1) You need to scan through the entries of ``C`` to decide whether\n>     ``C`` implements ``MyAxiom``, right?\n\nYes, of course. \n\nI also think that the code on this ticket suffers from a lot of abuse of lazy imports. They are a useful tool, but they don't absolve you from thinking about import order of modules. If you do, then you'll run into precisely the kind of hard-to-debug errors that we found. In particular, lazy imports that you have to resolve on startup are IMHO a sure sign of code smell.\n\nThis is yet another reason why I want to divorce axioms from categories. Axioms clearly ought to be lower than categories in the import priority, and moving them into separate files forces you to treat them as such.\n\n>     I think it's an important feature of the current design that you\n>     can use a category and some of its axioms while completely\n>     ignoring the others.\n\nAgreed.\n\n>     Either you define MyAxiom in a location of its own. But then you\n>     loose some code locality (the code for the axiom is not tied to\n>     the category defining it, which I find important).\n\nBut axioms are **not** tied to particular categories. They can be added to categories, but there is no need to have a unique \"most basic category\" for the axiom. And you yourself complained that its annoying to move the axiom code up in the category hierarchy occasionally.\n\n>     Or, as I\n>     mentioned before, you take the risk of having non trivial\n>     refactoring in case you generalize the axiom to a super category\n>     later.\n\nNo, you just move the import from your old category to your new category.\n\n> Altogether the current design just follows by analogy standard OO\n> practice: when a class C defines a method or attribute named ``a``,\n> this fixes the semantic of ``a`` for all subclasses. \n\nYou are deliberately omitting the other half of the story: If you have two unrelated classes `C` and `D` then `C.a` and `D.a` are unrelated in Python. And you are breaking that.",
    "created_at": "2014-01-19T01:35:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109212",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:426'></a>
Replying to [nthiery](#comment%3A423):
> The point is "within the desired feature set". For the idiom:
> 
> ```
>     class C:
>         class Anyname(MyAxiom.Category):
> 	     ...
> ```
> (1) You need to scan through the entries of ``C`` to decide whether
>     ``C`` implements ``MyAxiom``, right?

Yes, of course. 

I also think that the code on this ticket suffers from a lot of abuse of lazy imports. They are a useful tool, but they don't absolve you from thinking about import order of modules. If you do, then you'll run into precisely the kind of hard-to-debug errors that we found. In particular, lazy imports that you have to resolve on startup are IMHO a sure sign of code smell.

This is yet another reason why I want to divorce axioms from categories. Axioms clearly ought to be lower than categories in the import priority, and moving them into separate files forces you to treat them as such.

>     I think it's an important feature of the current design that you
>     can use a category and some of its axioms while completely
>     ignoring the others.

Agreed.

>     Either you define MyAxiom in a location of its own. But then you
>     loose some code locality (the code for the axiom is not tied to
>     the category defining it, which I find important).

But axioms are **not** tied to particular categories. They can be added to categories, but there is no need to have a unique "most basic category" for the axiom. And you yourself complained that its annoying to move the axiom code up in the category hierarchy occasionally.

>     Or, as I
>     mentioned before, you take the risk of having non trivial
>     refactoring in case you generalize the axiom to a super category
>     later.

No, you just move the import from your old category to your new category.

> Altogether the current design just follows by analogy standard OO
> practice: when a class C defines a method or attribute named ``a``,
> this fixes the semantic of ``a`` for all subclasses. 

You are deliberately omitting the other half of the story: If you have two unrelated classes `C` and `D` then `C.a` and `D.a` are unrelated in Python. And you are breaking that.



---

archive/issue_comments_109213.json:
```json
{
    "body": "<a id='comment:427'></a>\nReplying to [SimonKing](#comment%3A425):\n> I have attached [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py), which provides routines to check whether Nicolas' local choice of default constructions for categories with axiom is globally consistent.\n\nFun :-)\n\n> In this case, I try `C.an_instance().A().__class__.__base__` to get the class that is used to implement the result of applying axiom A to instances of category C.\n\nI believe that's the right approach for this need.\n\n> B corresponds to a standard monomial b_monomial, that describes a construction of B. Axiom A corresponds to a generator of the ring R. The condition for consistency is simple: `b_monomial*R(A)` has to be a standard monomial with respect to `Rel`.\n\nYou are taking some term order here, probably based on some order of\nthe axioms, right?\n\n> 2. In one nonsensical example, my routine finds this inconsistency ...\n> \n>    ```\n>    sage: Blahs().Blue().Unital() is Blahs().Unital().Blue()\n>    False\n>    sage: Blahs().Blue().Unital() is Blahs().Unital().Blue()\n>    False\n>    ```\n>    It is thus no surprise that my routine complains here. I won't check now whether this example is *supposed* to demonstrate an illegal construction.\n\nYup. This class demonstrates a possibly desirable but non-implemented\nfeature. See Blahs.Blue_extra_super_categories.\n\n> \n> **__Conclusion__**\n> \n> - I think the basic principle of the consistency check is sound. However, it is incomplete, since a lot of categories do not support `an_instance()`.\n\nQuestion: what about turning the problem upside down, and write a\nC._test_???  method that checks that everything is consistent within\nthe context of the super categories of ``C`` (and possibly all axiom\ncategories you can derive from those, though I guess it's not necessary)?\n\nSince every category class is supposed to be TestSuit'ed, we should\ncover all categories this way. Do you think we would get a global\nenough view?\n\nAn inconvenient is that this would be redundant: we would be checking\nover and over the consistency of the semigroup categories while\nchecking lower categories. This is, or not, a problem depending on the\ncost of the check.\n\n> - With the exception of the `Blahs().Unital()` example, Nicolas did a fine job to build the local data in a globally consistent way.\n\nAnd I believe that I have no merit in that. I haven't proven it\nformally yet, but I am pretty much convinced that as long as the two\nfollowing specifications (which I have now described in detail in the\ndocumentation) are satisfied:\n\n- Tree structure on the classes\n\n- If Ds() is a subcategory of Cs() and Ds().A() = Cs().A() then that\n  axiom should be implemented in Ds.A. And the mathematical theorem\n  stating the above equality should be implemented in Cs.\n\nthen the algorithmic works.\n\nI also believe we don't event need to impose a term order, but that I\nhave to think about.\n\n> - If we would go the opposite way, we could turn the consistency check into a method to *create* the default constructions of categories in an automated way (so that Nicolas does not need to choose them manually). Therefore, in the long run, we could have a database of category classes, using identifiers that are monomials with respect to some ideal Rel in a boolean polynomial ring R. Adding a new base category or adding a new axiom means to add more generators to R. Adding a theorem \"these two constructions yield the same category\" add a new generator to the ideal Rel. Global consistency is guaranteed by letting the default constructions correspond to standard monomials with respect to Rel. Note that this would also allow to deal with non-default constructions on the level of category classes and polynomial ideals, hence, without the problem that `an_instance()` often does not work.\n\nI always like consistency check. And that one has the bonus of being\nfun for commutative algebraist like us :-)\n\nOn the other hand, I believe that there is at this point no need to\nhave a tool for deciding where to put the axiom category. So far I\nhave always been putting the axiom category where mathematics told me\nto put it.\n\nThe point is that we are at this point only implementing well known\nfacts. And the goal of the infrastructure is only to make it easy to\nprovide only minimal information about those facts and have it derive\nthe immediate consequences.\n\nOne day might come where we will want to use the category\ninfrastructure to prove *new* facts. But then that would be going to a\ncompletely different level, and we should first discuss seriously with\nthe scientific communities that work on computer algebra and proofs.",
    "created_at": "2014-01-19T11:18:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109213",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:427'></a>
Replying to [SimonKing](#comment%3A425):
> I have attached [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py), which provides routines to check whether Nicolas' local choice of default constructions for categories with axiom is globally consistent.

Fun :-)

> In this case, I try `C.an_instance().A().__class__.__base__` to get the class that is used to implement the result of applying axiom A to instances of category C.

I believe that's the right approach for this need.

> B corresponds to a standard monomial b_monomial, that describes a construction of B. Axiom A corresponds to a generator of the ring R. The condition for consistency is simple: `b_monomial*R(A)` has to be a standard monomial with respect to `Rel`.

You are taking some term order here, probably based on some order of
the axioms, right?

> 2. In one nonsensical example, my routine finds this inconsistency ...
> 
>    ```
>    sage: Blahs().Blue().Unital() is Blahs().Unital().Blue()
>    False
>    sage: Blahs().Blue().Unital() is Blahs().Unital().Blue()
>    False
>    ```
>    It is thus no surprise that my routine complains here. I won't check now whether this example is *supposed* to demonstrate an illegal construction.

Yup. This class demonstrates a possibly desirable but non-implemented
feature. See Blahs.Blue_extra_super_categories.

> 
> **__Conclusion__**
> 
> - I think the basic principle of the consistency check is sound. However, it is incomplete, since a lot of categories do not support `an_instance()`.

Question: what about turning the problem upside down, and write a
C._test_???  method that checks that everything is consistent within
the context of the super categories of ``C`` (and possibly all axiom
categories you can derive from those, though I guess it's not necessary)?

Since every category class is supposed to be TestSuit'ed, we should
cover all categories this way. Do you think we would get a global
enough view?

An inconvenient is that this would be redundant: we would be checking
over and over the consistency of the semigroup categories while
checking lower categories. This is, or not, a problem depending on the
cost of the check.

> - With the exception of the `Blahs().Unital()` example, Nicolas did a fine job to build the local data in a globally consistent way.

And I believe that I have no merit in that. I haven't proven it
formally yet, but I am pretty much convinced that as long as the two
following specifications (which I have now described in detail in the
documentation) are satisfied:

- Tree structure on the classes

- If Ds() is a subcategory of Cs() and Ds().A() = Cs().A() then that
  axiom should be implemented in Ds.A. And the mathematical theorem
  stating the above equality should be implemented in Cs.

then the algorithmic works.

I also believe we don't event need to impose a term order, but that I
have to think about.

> - If we would go the opposite way, we could turn the consistency check into a method to *create* the default constructions of categories in an automated way (so that Nicolas does not need to choose them manually). Therefore, in the long run, we could have a database of category classes, using identifiers that are monomials with respect to some ideal Rel in a boolean polynomial ring R. Adding a new base category or adding a new axiom means to add more generators to R. Adding a theorem "these two constructions yield the same category" add a new generator to the ideal Rel. Global consistency is guaranteed by letting the default constructions correspond to standard monomials with respect to Rel. Note that this would also allow to deal with non-default constructions on the level of category classes and polynomial ideals, hence, without the problem that `an_instance()` often does not work.

I always like consistency check. And that one has the bonus of being
fun for commutative algebraist like us :-)

On the other hand, I believe that there is at this point no need to
have a tool for deciding where to put the axiom category. So far I
have always been putting the axiom category where mathematics told me
to put it.

The point is that we are at this point only implementing well known
facts. And the goal of the infrastructure is only to make it easy to
provide only minimal information about those facts and have it derive
the immediate consequences.

One day might come where we will want to use the category
infrastructure to prove *new* facts. But then that would be going to a
completely different level, and we should first discuss seriously with
the scientific communities that work on computer algebra and proofs.



---

archive/issue_comments_109214.json:
```json
{
    "body": "<a id='comment:428'></a>\nReplying to [vbraun](#comment%3A426):\n> I also think that the code on this ticket suffers from a lot of abuse of lazy imports. They are a useful tool, but they don't absolve you from thinking about import order of modules.\n\nPerhaps I misunderstand, but to me it seems the lazy imports are used in order to avoid that *all* category classes are imported at startup time: `PermutationGroups.Finite` should only be imported when it is actually needed, but not if you only intend to use `PermutationGroups`. Yet it should show up as an attribute. Do you think that, on top of that purpose, it is used to break import cycles?\n\n> In particular, lazy imports that you have to resolve on startup are IMHO a sure sign of code smell.\n\nSounds right. If something is imported at startup time anyway, then why should one not use a proper import?\n\n> >     Either you define MyAxiom in a location of its own. But then you\n> >     loose some code locality (the code for the axiom is not tied to\n> >     the category defining it, which I find important).\n\n> \n> But axioms are **not** tied to particular categories. They can be added to categories, but there is no need to have a unique \"most basic category\" for the axiom.\n\nAs I have mentioned earlier, it is simply a fact that you always have a \"most basic category\". Namely, it is the category that provides all notions that you need in order to formulate the axiom. E.g., `AdditiveMagmas` when you want to formulate `x+y==y+x`.\n\n> You are deliberately omitting the other half of the story: If you have two unrelated classes `C` and `D` then `C.a` and `D.a` are unrelated in Python. And you are breaking that.\n\nWell, if `a` is an axiom and `C` and `D` are categories and if `a` can be formulated in both `C` and `D`, then they are both sub-categories of the largest category `B` that allows to formulate `a`. In this sense, `C` and `D` *are* related.\n\nAnd that's another argument for considering the \"most basic category allowing to formulated an axiom\": It is natural (when you think of Python classes) to provide `a` as an attribute of `B`, and then `C` and `D` both inherit `B.a`. That said, it could very well be that because of some theorems axiom `a` implies properties of `C.a()` that are not part of what is provided by `B.a()`. And that's when (in Python)  you would override `B.a` in `C`.\n\nBut actually that's not the end of the story yet. We can provide `a` with a `__get__` method that does recognise whether `a` is bound to `B` or to `C`, and so we could make it so that `C.a` earns additional features that are not in `B.a`.",
    "created_at": "2014-01-19T12:54:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109214",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:428'></a>
Replying to [vbraun](#comment%3A426):
> I also think that the code on this ticket suffers from a lot of abuse of lazy imports. They are a useful tool, but they don't absolve you from thinking about import order of modules.

Perhaps I misunderstand, but to me it seems the lazy imports are used in order to avoid that *all* category classes are imported at startup time: `PermutationGroups.Finite` should only be imported when it is actually needed, but not if you only intend to use `PermutationGroups`. Yet it should show up as an attribute. Do you think that, on top of that purpose, it is used to break import cycles?

> In particular, lazy imports that you have to resolve on startup are IMHO a sure sign of code smell.

Sounds right. If something is imported at startup time anyway, then why should one not use a proper import?

> >     Either you define MyAxiom in a location of its own. But then you
> >     loose some code locality (the code for the axiom is not tied to
> >     the category defining it, which I find important).

> 
> But axioms are **not** tied to particular categories. They can be added to categories, but there is no need to have a unique "most basic category" for the axiom.

As I have mentioned earlier, it is simply a fact that you always have a "most basic category". Namely, it is the category that provides all notions that you need in order to formulate the axiom. E.g., `AdditiveMagmas` when you want to formulate `x+y==y+x`.

> You are deliberately omitting the other half of the story: If you have two unrelated classes `C` and `D` then `C.a` and `D.a` are unrelated in Python. And you are breaking that.

Well, if `a` is an axiom and `C` and `D` are categories and if `a` can be formulated in both `C` and `D`, then they are both sub-categories of the largest category `B` that allows to formulate `a`. In this sense, `C` and `D` *are* related.

And that's another argument for considering the "most basic category allowing to formulated an axiom": It is natural (when you think of Python classes) to provide `a` as an attribute of `B`, and then `C` and `D` both inherit `B.a`. That said, it could very well be that because of some theorems axiom `a` implies properties of `C.a()` that are not part of what is provided by `B.a()`. And that's when (in Python)  you would override `B.a` in `C`.

But actually that's not the end of the story yet. We can provide `a` with a `__get__` method that does recognise whether `a` is bound to `B` or to `C`, and so we could make it so that `C.a` earns additional features that are not in `B.a`.



---

archive/issue_comments_109215.json:
```json
{
    "body": "A routine to test whether the default choice of axiomatic category constructions is consistent",
    "created_at": "2014-01-19T15:11:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109215",
    "user": "https://github.com/simon-king-jena"
}
```

A routine to test whether the default choice of axiomatic category constructions is consistent



---

archive/attachments_014904.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "consistency.py",
    "asset_url": "tarball://root/attachments/ticket10963/consistency.py",
    "created_at": "2014-01-19T16:11:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket10963/consistency.py",
    "user": "https://github.com/simon-king-jena"
}
```



---

archive/issue_comments_109216.json:
```json
{
    "body": "<a id='comment:429'></a>\n**Attachment:** [consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py)\n\nReplying to [nthiery](#comment%3A427):\n> Replying to [SimonKing](#comment%3A425):\n> > I have attached [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py), \n\n... and updated it now, because of some previous typos.\n\n> > which provides routines to check whether Nicolas' local choice of default constructions for categories with axiom is globally consistent.\n\n> \n> Fun :-)\n\nAgreed, but I didn't tell how to use it. So, here it goes: Start sage and attach the file. Then:\n\n```\nsage: Bad, I,S,Rel = TestCategoryModel()\nImport all category classes\nCreate boolean polynomial ring with 168 generators\nCollect all available axiomatic constructions\n => Found 277 constructions for 256 category classes\n\n8 cases of alternative axiomatic constructions\nTesting that default constructions are compatible\nBad: <class 'sage.categories.category_with_axiom.Unital.Blue'> = <class 'sage.categories.category_with_axiom.Blahs.Unital'>.Blue\nexpected default Blahs*Unital\ngot Blahs*Blue*Unital\nBasis is given by Blahs*Unital\nbut Blahs*Blue*Unital is no standard monomial\n```\nWhat I find very strange: Apparently the number of alternative axiomatic constructions is not well-defined! Namely yesterday I got different figures.\n\nTo be investigated...\n\nAnyway, we find:\n\n```\nsage: Bad\n[(sage.categories.category_with_axiom.Unital.Blue,\n  Blahs*Blue*Unital,\n  Blahs*Unital)]\n```\nwhich means that `Blahs.Unital.Blue` should coincide with `Blahs.Unital`, which makes perfect sense since\n\n```\nsage: Blahs().Blue() is Blahs().Unital()\nTrue\n```\nand thus `Blahs().Unital().Blue()` should be the same as `Blahs().Blue().Blue()`, thus the same as `Blahs().Blue()`, which is `Blahs().Unital()`. However, we find\n\n```\nsage: Blahs().Unital().Blue() is Blahs().Blue()\nFalse\n```\nThis is a bug, which my test function correctly detects!\n\nMoreover, we have\n\n```\nsage: len(I)\n121\n```\nwhich means that 121 category classes do not give a reasonable answer when asked to return an instance.\n\nFinally,\n\n```\nsage: for rel in Rel.groebner_basis():\n....:    print rel\n....:     \nBlahs*DistributiveMagmasAndAdditiveMagmas*Flying*Facade*Finite*Commutative*Associative*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital + Blahs*DistributiveMagmasAndAdditiveMagmas*Flying*Finite*Commutative*Associative*Inverse*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital\nBlahs*DistributiveMagmasAndAdditiveMagmas*Flying*Finite*Infinite*Commutative*Associative*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital + Blahs*DistributiveMagmasAndAdditiveMagmas*Flying*Finite*Commutative*Associative*Inverse*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital\nBlahs*Flying*Unital + Blahs*Flying\nBlahs*Blue + Blahs*Unital\nTestObjects*Blue + TestObjects*Unital\nTestObjectsOverBaseRing*Blue + TestObjectsOverBaseRing*Unital\nDistributiveMagmasAndAdditiveMagmas*Facade*Finite*Commutative*Associative*Unital*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital + DistributiveMagmasAndAdditiveMagmas*Finite*Commutative*Associative*Inverse*Unital*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital\nDistributiveMagmasAndAdditiveMagmas*Finite*Infinite*Commutative*Associative*Unital*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital + DistributiveMagmasAndAdditiveMagmas*Finite*Commutative*Associative*Inverse*Unital*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital\n```\n\nAs we can see, most of the relations come from Nicolas' examples, but not from real mathematical theorems.\n\nOne thing really irritates me, though. Yesterday, I also saw relations\n\n```\nModules*VectorSpaces==VectorSpaces\n```\nwhich makes sense: The join of the module category over a base ring and the vector space category over the same base ring should be the vector space category, simply since in this case the module category coincides with the vector space category.\n\nSo, why am I not seeing the same relations today??\n\n> > In this case, I try `C.an_instance().A().__class__.__base__` to get the class that is used to implement the result of applying axiom A to instances of category C.\n\n> \n> I believe that's the right approach for this need.\n\nOK, but then we'd like to have 121 more implementations of `an_instance()`...\n \n> You are taking some term order here, probably based on some order of\n> the axioms, right?\n\nYes. That's another point that I should change. `BooleanPolynomialRing` apparently uses a lexicographic ordering by default. What I wanted was a degrevlex ordering: A construction involving fewer axioms should be preferred over a construction involving many axioms.\n\nAnyway. The generators of the ring correspond to\n1. All category classes that are not category-with-axiom, sorted (I don't know how Python sorts them).\n2. All axioms, in the same order as given in `sage.categories.category_with_axiom.all_axioms`.\n\nIs the sorting of category classes perhaps depending on the memory addresses of the classes? This would explain why I get different results on different runs.\n\n> >    It is thus no surprise that my routine complains here. I won't check now whether this example is *supposed* to demonstrate an illegal construction.\n\n> \n> Yup. This class demonstrates a possibly desirable but non-implemented\n> feature. See Blahs.Blue_extra_super_categories.\n\nWell, the reason for the complaint is that the axioms `Blue` and `Unital` do not commute. But applying axioms *has* to commute. Hence, the feature is not \"desirable but non-implemented\", but it is \"mathematically illegal\".\n \n> Question: what about turning the problem upside down, and write a\n> C._test_???  method that checks that everything is consistent within\n> the context of the super categories of ``C`` (and possibly all axiom\n> categories you can derive from those, though I guess it's not necessary)?\n\nConsistency is a global property. Hence, I think there is no way around to consider *all* category classes at once when testing consistency. It is clear that this must not happen during startup. Hence, as it is, the consistency test is a test that may be a tool for a developer wanting to add a new category.\n\nHowever, turning things \"upside down\" is what I want. But I mean a different thing.\n\nCurrently, my functions import all categories, extract from it the local information that define the category-with-axiom lattice, and then uses commutative algebra to assert that the local information gives a globally consistent picture.\n\nTurning this upside down would mean:\n- First of all, create a Boolean polynomial ring, whose generators correspond to the list of basic categories and axioms available in Sage (this list may grow). Fix a reasonable monomial ordering, best would be a degree ordering.\n- Create an ideal in this ring, whose generators are given by mathematical results such as Wedderburn's. Compute the Gr\u00f6bner basis. This Gr\u00f6bner basis could be computed once, stored, and then loaded at Sage startup time. Hence, Sage startup would not suffer from an expensive Gr\u00f6bner basis computation, it only is loading a fixed result.\n- When creating a category class, the Gr\u00f6bner basis helps to provide this class with the available axiomatic constructions (this is what you do with lazy imports and with `SubcategoryMethods`), and also determines a default construction for this class (this is the `_base_category_class_and_axiom` attribute). Commutative algebra ensures consistency of this local information. This would be implemented by a meta-class for `Category`.\n\nThis would be my approach to add more rigour to your category-with-axiom model, and replace handmade choices of default constructions by something that scales better.\n\n> Since every category class is supposed to be TestSuit'ed, we should\n> cover all categories this way. Do you think we would get a global\n> enough view?\n\nNo.\n\n> And I believe that I have no merit in that. I haven't proven it\n> formally yet, but I am pretty much convinced that as long as the two\n> following specifications (which I have now described in detail in the\n> documentation) are satisfied:\n> \n> - Tree structure on the classes\n\nWhich I totally don't like!\n\nNamely, as a consequence, you need to treat `DivisionRings.Finite` different from `Fields.Finite`: The latter is a (lazily imported) class stored as a class attribute, the former is a cached method obtained from Set() and will *only* work on instances, not on classes. This asymmetry is unfortunate, and I think using a metaclass that works with standard monomials corresponding to default axiomatic constructions is a nice way to make the implementation symmetric.\n\nYou see, if a developer wants to implement a new mathematical theorem on equality of two axiomatic constructions, then your model is a bit awkward: (S)he needs to pick one of the constructions to become a cached method on instances, while the other stays a class attribute. But which of them? Doing the wrong choice would mean subtle inconsistencies resulting in difficult to find bugs.\n\nIt seems obvious to me that we want that all axiomatic constructions can be implemented in the same way, and that there is no danger of wrong choices, because all choices will be made automatic by a method that is proven to yield well-defined results (namely: Computing normal forms using Gr\u00f6bner bases).\n\nIn other words: There is a tree structure in the set of standard monomials. We shouldn't force the developer to put the same tree structure *manually* into the class definitions.\n\n> I also believe we don't event need to impose a term order, but that I\n> have to think about.\n\nI think we at least want a degree order, so that applying three axioms will always be preferred over applying four axioms to get the same result.\n\n> On the other hand, I believe that there is at this point no need to\n> have a tool for deciding where to put the axiom category. So far I\n> have always been putting the axiom category where mathematics told me\n> to put it.\n\nWell, in the case of `Blahs.Blue.Unital`, you did wrong. I don't know if it was on purpose that you did wrong, but your example shows something that should never happen, namely axioms that do not commute.",
    "created_at": "2014-01-19T16:11:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109216",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:429'></a>
**Attachment:** [consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py)

Replying to [nthiery](#comment%3A427):
> Replying to [SimonKing](#comment%3A425):
> > I have attached [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py), 

... and updated it now, because of some previous typos.

> > which provides routines to check whether Nicolas' local choice of default constructions for categories with axiom is globally consistent.

> 
> Fun :-)

Agreed, but I didn't tell how to use it. So, here it goes: Start sage and attach the file. Then:

```
sage: Bad, I,S,Rel = TestCategoryModel()
Import all category classes
Create boolean polynomial ring with 168 generators
Collect all available axiomatic constructions
 => Found 277 constructions for 256 category classes

8 cases of alternative axiomatic constructions
Testing that default constructions are compatible
Bad: <class 'sage.categories.category_with_axiom.Unital.Blue'> = <class 'sage.categories.category_with_axiom.Blahs.Unital'>.Blue
expected default Blahs*Unital
got Blahs*Blue*Unital
Basis is given by Blahs*Unital
but Blahs*Blue*Unital is no standard monomial
```
What I find very strange: Apparently the number of alternative axiomatic constructions is not well-defined! Namely yesterday I got different figures.

To be investigated...

Anyway, we find:

```
sage: Bad
[(sage.categories.category_with_axiom.Unital.Blue,
  Blahs*Blue*Unital,
  Blahs*Unital)]
```
which means that `Blahs.Unital.Blue` should coincide with `Blahs.Unital`, which makes perfect sense since

```
sage: Blahs().Blue() is Blahs().Unital()
True
```
and thus `Blahs().Unital().Blue()` should be the same as `Blahs().Blue().Blue()`, thus the same as `Blahs().Blue()`, which is `Blahs().Unital()`. However, we find

```
sage: Blahs().Unital().Blue() is Blahs().Blue()
False
```
This is a bug, which my test function correctly detects!

Moreover, we have

```
sage: len(I)
121
```
which means that 121 category classes do not give a reasonable answer when asked to return an instance.

Finally,

```
sage: for rel in Rel.groebner_basis():
....:    print rel
....:     
Blahs*DistributiveMagmasAndAdditiveMagmas*Flying*Facade*Finite*Commutative*Associative*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital + Blahs*DistributiveMagmasAndAdditiveMagmas*Flying*Finite*Commutative*Associative*Inverse*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital
Blahs*DistributiveMagmasAndAdditiveMagmas*Flying*Finite*Infinite*Commutative*Associative*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital + Blahs*DistributiveMagmasAndAdditiveMagmas*Flying*Finite*Commutative*Associative*Inverse*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital
Blahs*Flying*Unital + Blahs*Flying
Blahs*Blue + Blahs*Unital
TestObjects*Blue + TestObjects*Unital
TestObjectsOverBaseRing*Blue + TestObjectsOverBaseRing*Unital
DistributiveMagmasAndAdditiveMagmas*Facade*Finite*Commutative*Associative*Unital*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital + DistributiveMagmasAndAdditiveMagmas*Finite*Commutative*Associative*Inverse*Unital*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital
DistributiveMagmasAndAdditiveMagmas*Finite*Infinite*Commutative*Associative*Unital*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital + DistributiveMagmasAndAdditiveMagmas*Finite*Commutative*Associative*Inverse*Unital*Division*NoZeroDivisors*AdditiveCommutative*AdditiveAssociative*AdditiveInverse*AdditiveUnital
```

As we can see, most of the relations come from Nicolas' examples, but not from real mathematical theorems.

One thing really irritates me, though. Yesterday, I also saw relations

```
Modules*VectorSpaces==VectorSpaces
```
which makes sense: The join of the module category over a base ring and the vector space category over the same base ring should be the vector space category, simply since in this case the module category coincides with the vector space category.

So, why am I not seeing the same relations today??

> > In this case, I try `C.an_instance().A().__class__.__base__` to get the class that is used to implement the result of applying axiom A to instances of category C.

> 
> I believe that's the right approach for this need.

OK, but then we'd like to have 121 more implementations of `an_instance()`...
 
> You are taking some term order here, probably based on some order of
> the axioms, right?

Yes. That's another point that I should change. `BooleanPolynomialRing` apparently uses a lexicographic ordering by default. What I wanted was a degrevlex ordering: A construction involving fewer axioms should be preferred over a construction involving many axioms.

Anyway. The generators of the ring correspond to
1. All category classes that are not category-with-axiom, sorted (I don't know how Python sorts them).
2. All axioms, in the same order as given in `sage.categories.category_with_axiom.all_axioms`.

Is the sorting of category classes perhaps depending on the memory addresses of the classes? This would explain why I get different results on different runs.

> >    It is thus no surprise that my routine complains here. I won't check now whether this example is *supposed* to demonstrate an illegal construction.

> 
> Yup. This class demonstrates a possibly desirable but non-implemented
> feature. See Blahs.Blue_extra_super_categories.

Well, the reason for the complaint is that the axioms `Blue` and `Unital` do not commute. But applying axioms *has* to commute. Hence, the feature is not "desirable but non-implemented", but it is "mathematically illegal".
 
> Question: what about turning the problem upside down, and write a
> C._test_???  method that checks that everything is consistent within
> the context of the super categories of ``C`` (and possibly all axiom
> categories you can derive from those, though I guess it's not necessary)?

Consistency is a global property. Hence, I think there is no way around to consider *all* category classes at once when testing consistency. It is clear that this must not happen during startup. Hence, as it is, the consistency test is a test that may be a tool for a developer wanting to add a new category.

However, turning things "upside down" is what I want. But I mean a different thing.

Currently, my functions import all categories, extract from it the local information that define the category-with-axiom lattice, and then uses commutative algebra to assert that the local information gives a globally consistent picture.

Turning this upside down would mean:
- First of all, create a Boolean polynomial ring, whose generators correspond to the list of basic categories and axioms available in Sage (this list may grow). Fix a reasonable monomial ordering, best would be a degree ordering.
- Create an ideal in this ring, whose generators are given by mathematical results such as Wedderburn's. Compute the Gröbner basis. This Gröbner basis could be computed once, stored, and then loaded at Sage startup time. Hence, Sage startup would not suffer from an expensive Gröbner basis computation, it only is loading a fixed result.
- When creating a category class, the Gröbner basis helps to provide this class with the available axiomatic constructions (this is what you do with lazy imports and with `SubcategoryMethods`), and also determines a default construction for this class (this is the `_base_category_class_and_axiom` attribute). Commutative algebra ensures consistency of this local information. This would be implemented by a meta-class for `Category`.

This would be my approach to add more rigour to your category-with-axiom model, and replace handmade choices of default constructions by something that scales better.

> Since every category class is supposed to be TestSuit'ed, we should
> cover all categories this way. Do you think we would get a global
> enough view?

No.

> And I believe that I have no merit in that. I haven't proven it
> formally yet, but I am pretty much convinced that as long as the two
> following specifications (which I have now described in detail in the
> documentation) are satisfied:
> 
> - Tree structure on the classes

Which I totally don't like!

Namely, as a consequence, you need to treat `DivisionRings.Finite` different from `Fields.Finite`: The latter is a (lazily imported) class stored as a class attribute, the former is a cached method obtained from Set() and will *only* work on instances, not on classes. This asymmetry is unfortunate, and I think using a metaclass that works with standard monomials corresponding to default axiomatic constructions is a nice way to make the implementation symmetric.

You see, if a developer wants to implement a new mathematical theorem on equality of two axiomatic constructions, then your model is a bit awkward: (S)he needs to pick one of the constructions to become a cached method on instances, while the other stays a class attribute. But which of them? Doing the wrong choice would mean subtle inconsistencies resulting in difficult to find bugs.

It seems obvious to me that we want that all axiomatic constructions can be implemented in the same way, and that there is no danger of wrong choices, because all choices will be made automatic by a method that is proven to yield well-defined results (namely: Computing normal forms using Gröbner bases).

In other words: There is a tree structure in the set of standard monomials. We shouldn't force the developer to put the same tree structure *manually* into the class definitions.

> I also believe we don't event need to impose a term order, but that I
> have to think about.

I think we at least want a degree order, so that applying three axioms will always be preferred over applying four axioms to get the same result.

> On the other hand, I believe that there is at this point no need to
> have a tool for deciding where to put the axiom category. So far I
> have always been putting the axiom category where mathematics told me
> to put it.

Well, in the case of `Blahs.Blue.Unital`, you did wrong. I don't know if it was on purpose that you did wrong, but your example shows something that should never happen, namely axioms that do not commute.



---

archive/issue_comments_109217.json:
```json
{
    "body": "<a id='comment:0'></a>\nSomething else, Nicolas: Did you push your latest commits? I can't see your latest additions to the documentation in the branch.",
    "created_at": "2014-01-19T18:02:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109217",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Something else, Nicolas: Did you push your latest commits? I can't see your latest additions to the documentation in the branch.



---

archive/issue_comments_109218.json:
```json
{
    "body": "<a id='comment:431'></a>\nReplying to [SimonKing](#comment%3A429):\n> OK, but then we'd like to have 121 more implementations of `an_instance()`...\n\nIt would be a good thing to have an_instance for all categories at\nsome point. Hopefully we can do that by providing just a couple\ngeneric implementations.\n\nNow, I am actually surprised that you get that many. Can you give a\ncouple examples where this fails? Have you tried the category_sample\nfunction?\n\n> Well, the reason for the complaint is that the axioms `Blue` and `Unital` do not commute. But applying axioms *has* to commute. Hence, the feature is not \"desirable but non-implemented\", but it is \"mathematically illegal\".\n\nNo. See below.\n\n> Consistency is a global property. Hence, I think there is no way around to consider *all* category classes at once when testing consistency.\n\nI am not sure. If there is some inconsistency, you can always work in\na sublattice (with bottom) that contains all the involved categories,\nrather than the full lattice. And I would not be surprised if it could\nbe argued that one could always choose such a sublattice with a\ncategory that is actually implemented in Sage. But anyway, let's not\npollute more this thread; we can discuss this later.\n\n> - Create an ideal in this ring, whose generators are given by mathematical results such as Wedderburn's. Compute the Gr\u00f6bner basis. This Gr\u00f6bner basis could be computed once, stored, and then loaded at Sage startup time. Hence, Sage startup would not suffer from an expensive Gr\u00f6bner basis computation, it only is loading a fixed result.\n\nRight. But Sage's startup would still require being able to manipulate\nsuch a Gr\u00f6bner basis in one form or the other. And one needs to make\nsure the Gr\u00f6bner basis is consistent with all the code (that is Sage's\ncompilation might require a Gr\u00f6bner basis computation). And that it\ncan be extended dynamically if users introduce new categories in their\nown library.\n\nI am certainly not saying it's not doable. But it introduces some\ncomplexity which has to be well motivated.\n\n> - When creating a category class, the Gr\u00f6bner basis helps to provide this class with the available axiomatic constructions (this is what you do with lazy imports and with `SubcategoryMethods`), and also determines a default construction for this class (this is the `_base_category_class_and_axiom` attribute). Commutative algebra ensures consistency of this local information. This would be implemented by a meta-class for `Category`.\n\n\n> This would be my approach to add more rigour to your category-with-axiom model, and replace handmade choices of default constructions by something that scales better.\n\nSorry, I can't resist; let me use the very argument that soo many\npeople have raised when saying that all that category stuff was just\noverdesign. \u00abBefore introducing non trivial design to solve a scaling\nissue, one needs to be sure there is one in practice\u00bb.  So far, I\nhaven't had a single time where I got bothered by that.\n\n> > Since every category class is supposed to be TestSuit'ed, we should\n> > cover all categories this way. Do you think we would get a global\n> > enough view?\n\n> \n> No.\n\nCan you give me a sketch of scenario where this would fail?\n\n> > And I believe that I have no merit in that. I haven't proven it\n> > formally yet, but I am pretty much convinced that as long as the two\n> > following specifications (which I have now described in detail in the\n> > documentation) are satisfied:\n> > \n> > - Tree structure on the classes\n\n> \n> Which I totally don't like!\n\n>\n> Namely, as a consequence, you need to treat `DivisionRings.Finite` different from `Fields.Finite`: The latter is a (lazily imported) class stored as a class attribute, the former is a cached method obtained from Set() and will *only* work on instances, not on classes. This asymmetry is unfortunate, and I think using a metaclass that works with standard monomials corresponding to default axiomatic constructions is a nice way to make the implementation symmetric.\n> \n> You see, if a developer wants to implement a new mathematical theorem on equality of two axiomatic constructions, then your model is a bit awkward: (S)he needs to pick one of the constructions to become a cached method on instances, while the other stays a class attribute. But which of them? Doing the wrong choice would mean subtle inconsistencies resulting in difficult to find bugs.\n\nNo I don't see.\n\nFor Fields vs Division rings, the asymmetry is *very* natural. You put\nthe class in Fields.Finite, because it's about stuff valid for finite\nfields. And you put in DivisionRings the theorem which tells you that\nin the context of division rings, the \"Finite\" axiom implies the\n\"commutative\" axioms.\n\nNote also that if you would do the converse (put the class in\nDivisionRings), you would see *immediately* the error: first you would\nnot know what to put in Fields.Finite_extra_super_categories. And\nsecond DivisionRings().Finite() would not coincide with\nFields().Finite(); and this is the first thing you would test. Nothing\n\"subtle\".\n\nThe same happened in every example of mathematical theorem I\nimplemented. And I believe this is a general feature; each time, the\ntheorem is telling you that, within a given category C, satisfying a\ngiven axiom gives you more structure i.e. you land in a subcategory.\n\nSo, until I am given a concrete example where it's actually awkward to\nput the mathematical theorem in one side rather than the other, I'll\nconsider this as a non issue.\n\n> It seems obvious to me that we want that all axiomatic constructions can be implemented in the same way, and that there is no danger of wrong choices, because all choices will be made automatic by a method that is proven to yield well-defined results (namely: Computing normal forms using Gr\u00f6bner bases).\n\nI believe, and will work on proving formally, that the current\nimplementation is perfectly well-defined and gives normal forms.\n\n> In other words: There is a tree structure in the set of standard monomials. We shouldn't force the developer to put the same tree structure *manually* into the class definitions.\n\nMaybe not. Or maybe yes. I agree there is a small inconvenient with\nthat tree structure because you have to make a choice between putting\nstuff in C.A.B or C.B.A (it's not so bad because I believe you can\nlocally make whatever choice you want). And if forces to create a few\nextraneous empty categories (really not that many).\n\nBut before ruling out the tree design choice, one needs to make sure\nthere is an alternative design choice that has:\n\n- a syntax at least as good\n- a similar performance\n- a robustness at least as good\n- someone willing to take the time to implement it\n\nAnyway, I read you agree that this is all for a later ticket, right?\nCan you please move the discussion to a different ticket? This ticket\nis already way too cluttered for people that will try to read the\ndiscussion later.\n\n> I think we at least want a degree order, so that applying three axioms will always be preferred over applying four axioms to get the same result.\n\nI'd rather not impose any limitation if there is no good reason for\nit. We should put the code wherever it's most natural mathematically\nto put it.\n\n> Well, in the case of `Blahs.Blue.Unital`, you did wrong. I don't know if it was on purpose that you did wrong, but your example shows something that should never happen, namely axioms that do not commute.\n\nNo I did not do wrong. It does demonstrates *on\npurpose* a *missing feature*: namely that you currently can't use the\nBlue_extra_super_categories mechanism in the category where the Blue\naxiom is defined. You can also see it as a demonstration of a\n*specified* limitation of the current specification: a category that\n*defines* an axiom also has to *implement* it.\n\nCheers,\n                           Nicolas",
    "created_at": "2014-01-19T18:15:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109218",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:431'></a>
Replying to [SimonKing](#comment%3A429):
> OK, but then we'd like to have 121 more implementations of `an_instance()`...

It would be a good thing to have an_instance for all categories at
some point. Hopefully we can do that by providing just a couple
generic implementations.

Now, I am actually surprised that you get that many. Can you give a
couple examples where this fails? Have you tried the category_sample
function?

> Well, the reason for the complaint is that the axioms `Blue` and `Unital` do not commute. But applying axioms *has* to commute. Hence, the feature is not "desirable but non-implemented", but it is "mathematically illegal".

No. See below.

> Consistency is a global property. Hence, I think there is no way around to consider *all* category classes at once when testing consistency.

I am not sure. If there is some inconsistency, you can always work in
a sublattice (with bottom) that contains all the involved categories,
rather than the full lattice. And I would not be surprised if it could
be argued that one could always choose such a sublattice with a
category that is actually implemented in Sage. But anyway, let's not
pollute more this thread; we can discuss this later.

> - Create an ideal in this ring, whose generators are given by mathematical results such as Wedderburn's. Compute the Gröbner basis. This Gröbner basis could be computed once, stored, and then loaded at Sage startup time. Hence, Sage startup would not suffer from an expensive Gröbner basis computation, it only is loading a fixed result.

Right. But Sage's startup would still require being able to manipulate
such a Gröbner basis in one form or the other. And one needs to make
sure the Gröbner basis is consistent with all the code (that is Sage's
compilation might require a Gröbner basis computation). And that it
can be extended dynamically if users introduce new categories in their
own library.

I am certainly not saying it's not doable. But it introduces some
complexity which has to be well motivated.

> - When creating a category class, the Gröbner basis helps to provide this class with the available axiomatic constructions (this is what you do with lazy imports and with `SubcategoryMethods`), and also determines a default construction for this class (this is the `_base_category_class_and_axiom` attribute). Commutative algebra ensures consistency of this local information. This would be implemented by a meta-class for `Category`.


> This would be my approach to add more rigour to your category-with-axiom model, and replace handmade choices of default constructions by something that scales better.

Sorry, I can't resist; let me use the very argument that soo many
people have raised when saying that all that category stuff was just
overdesign. «Before introducing non trivial design to solve a scaling
issue, one needs to be sure there is one in practice».  So far, I
haven't had a single time where I got bothered by that.

> > Since every category class is supposed to be TestSuit'ed, we should
> > cover all categories this way. Do you think we would get a global
> > enough view?

> 
> No.

Can you give me a sketch of scenario where this would fail?

> > And I believe that I have no merit in that. I haven't proven it
> > formally yet, but I am pretty much convinced that as long as the two
> > following specifications (which I have now described in detail in the
> > documentation) are satisfied:
> > 
> > - Tree structure on the classes

> 
> Which I totally don't like!

>
> Namely, as a consequence, you need to treat `DivisionRings.Finite` different from `Fields.Finite`: The latter is a (lazily imported) class stored as a class attribute, the former is a cached method obtained from Set() and will *only* work on instances, not on classes. This asymmetry is unfortunate, and I think using a metaclass that works with standard monomials corresponding to default axiomatic constructions is a nice way to make the implementation symmetric.
> 
> You see, if a developer wants to implement a new mathematical theorem on equality of two axiomatic constructions, then your model is a bit awkward: (S)he needs to pick one of the constructions to become a cached method on instances, while the other stays a class attribute. But which of them? Doing the wrong choice would mean subtle inconsistencies resulting in difficult to find bugs.

No I don't see.

For Fields vs Division rings, the asymmetry is *very* natural. You put
the class in Fields.Finite, because it's about stuff valid for finite
fields. And you put in DivisionRings the theorem which tells you that
in the context of division rings, the "Finite" axiom implies the
"commutative" axioms.

Note also that if you would do the converse (put the class in
DivisionRings), you would see *immediately* the error: first you would
not know what to put in Fields.Finite_extra_super_categories. And
second DivisionRings().Finite() would not coincide with
Fields().Finite(); and this is the first thing you would test. Nothing
"subtle".

The same happened in every example of mathematical theorem I
implemented. And I believe this is a general feature; each time, the
theorem is telling you that, within a given category C, satisfying a
given axiom gives you more structure i.e. you land in a subcategory.

So, until I am given a concrete example where it's actually awkward to
put the mathematical theorem in one side rather than the other, I'll
consider this as a non issue.

> It seems obvious to me that we want that all axiomatic constructions can be implemented in the same way, and that there is no danger of wrong choices, because all choices will be made automatic by a method that is proven to yield well-defined results (namely: Computing normal forms using Gröbner bases).

I believe, and will work on proving formally, that the current
implementation is perfectly well-defined and gives normal forms.

> In other words: There is a tree structure in the set of standard monomials. We shouldn't force the developer to put the same tree structure *manually* into the class definitions.

Maybe not. Or maybe yes. I agree there is a small inconvenient with
that tree structure because you have to make a choice between putting
stuff in C.A.B or C.B.A (it's not so bad because I believe you can
locally make whatever choice you want). And if forces to create a few
extraneous empty categories (really not that many).

But before ruling out the tree design choice, one needs to make sure
there is an alternative design choice that has:

- a syntax at least as good
- a similar performance
- a robustness at least as good
- someone willing to take the time to implement it

Anyway, I read you agree that this is all for a later ticket, right?
Can you please move the discussion to a different ticket? This ticket
is already way too cluttered for people that will try to read the
discussion later.

> I think we at least want a degree order, so that applying three axioms will always be preferred over applying four axioms to get the same result.

I'd rather not impose any limitation if there is no good reason for
it. We should put the code wherever it's most natural mathematically
to put it.

> Well, in the case of `Blahs.Blue.Unital`, you did wrong. I don't know if it was on purpose that you did wrong, but your example shows something that should never happen, namely axioms that do not commute.

No I did not do wrong. It does demonstrates *on
purpose* a *missing feature*: namely that you currently can't use the
Blue_extra_super_categories mechanism in the category where the Blue
axiom is defined. You can also see it as a demonstration of a
*specified* limitation of the current specification: a category that
*defines* an axiom also has to *implement* it.

Cheers,
                           Nicolas



---

archive/issue_comments_109219.json:
```json
{
    "body": "<a id='comment:432'></a>\nReplying to [SimonKing](#comment%3A430):\n> Something else, Nicolas: Did you push your latest commits? I can't see your latest additions to the documentation in the branch.\n\nNow yes!",
    "created_at": "2014-01-19T18:23:58Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109219",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:432'></a>
Replying to [SimonKing](#comment%3A430):
> Something else, Nicolas: Did you push your latest commits? I can't see your latest additions to the documentation in the branch.

Now yes!



---

archive/issue_comments_109220.json:
```json
{
    "body": "<a id='comment:433'></a>\nReplying to [nthiery](#comment%3A431):\n> Now, I am actually surprised that you get that many. Can you give a\n> couple examples where this fails?\n\nThe `TestCategoryModel()` from [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py) returns (among other things) a list of all category classes for which `an_instance()` does not return an instance of the class. This list seems to be stable.\n\nSide-note: The other tests do not seem stable yet: They differ from run to run. Anyway, I'll work on it.\n\nHere are the classes and the errors I am getting:\n\n```\n0 sage.combinat.ncsym.bases.NCSymDualBases AttributeError\n1 sage.categories.modules_with_basis.ModulesWithBasis.DualObjects TypeError\n2 sage.categories.algebra_functor.AlgebrasCategory AssertionError\n3 sage.categories.additive_magmas.AdditiveMagmas.Algebras AssertionError\n4 sage.categories.hopf_algebras.HopfAlgebras.DualCategory NotImplementedError\n5 sage.categories.additive_semigroups.AdditiveSemigroups.Algebras AssertionError\n6 sage.categories.category_types.AbelianCategory NotImplementedError\n7 sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases AttributeError\n8 sage.combinat.descent_algebra.DescentAlgebraBases AttributeError\n9 sage.categories.quotients.QuotientsCategory TypeError\n10 sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases AttributeError\n11 sage.categories.additive_magmas.AdditiveCommutative.Algebras AssertionError\n12 sage.categories.realizations.RealizationsCategory TypeError\n13 sage.combinat.ncsym.bases.MultiplicativeNCSymBases AttributeError\n14 sage.categories.sets_cat.Sets.CartesianProducts TypeError\n15 sage.categories.graded_modules.GradedModulesCategory KeyError\n16 sage.categories.sets_cat.Sets.Subobjects TypeError\n17 sage.categories.cartesian_product.CartesianProductsCategory TypeError\n18 sage.categories.magmas.Magmas.Realizations TypeError\n19 sage.categories.hopf_algebras.HopfAlgebras.Realizations TypeError\n20 sage.categories.groups.Groups.Algebras AssertionError\n21 sage.categories.magmas.Magmas.Algebras AssertionError\n22 sage.categories.isomorphic_objects.IsomorphicObjectsCategory TypeError\n23 sage.categories.sets_with_partial_maps.SetsWithPartialMaps.HomCategory TypeError\n24 sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations TypeError\n25 sage.combinat.sf.sfa.SymmetricFunctionsBases AttributeError\n26 sage.categories.category.HomCategory TypeError\n27 sage.categories.sets_cat.Sets.Subquotients TypeError\n28 sage.categories.algebras_with_basis.AlgebrasWithBasis.CartesianProducts TypeError\n29 sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.IsomorphicObjects TypeError\n30 sage.categories.sets_cat.Sets.Realizations TypeError\n31 sage.categories.realizations.Category_realization_of_parent NotImplementedError\n32 sage.categories.category_with_axiom.BrokenTestObjects NotImplementedError\n33 sage.categories.category.CategoryWithParameters NotImplementedError\n34 sage.categories.magmas.Commutative.Algebras AssertionError\n35 sage.categories.vector_spaces.VectorSpaces.DualObjects TypeError\n36 sage.categories.hopf_algebras.HopfAlgebras.Morphism NotImplementedError\n37 sage.categories.category_types.Category_in_ambient TypeError\n38 sage.categories.objects.Objects.HomCategory TypeError\n39 sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements AttributeError\n40 sage.categories.schemes.Schemes.HomCategory TypeError\n41 sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases AttributeError\n42 sage.categories.semigroups.Semigroups.Subquotients TypeError\n43 sage.categories.sets_cat.Sets.Algebras AssertionError\n44 sage.categories.coalgebras.Coalgebras.TensorProducts TypeError\n45 sage.categories.hecke_modules.HeckeModules.HomCategory TypeError\n46 sage.categories.category_types.Category_module NotImplementedError\n47 sage.categories.algebras.Algebras.CartesianProducts TypeError\n48 sage.categories.algebras_with_basis.AlgebrasWithBasis.TensorProducts TypeError\n49 sage.combinat.ncsym.bases.NCSymOrNCSymDualBases AttributeError\n50 sage.categories.subquotients.SubquotientsCategory TypeError\n51 sage.categories.algebras.Algebras.TensorProducts TypeError\n52 sage.categories.coalgebras.Coalgebras.DualObjects TypeError\n53 sage.categories.magmas.Unital.Algebras AssertionError\n54 sage.categories.additive_magmas.AdditiveUnital.Algebras AssertionError\n55 sage.categories.category_types.Category_ideal NotImplementedError\n56 sage.categories.modules_with_basis.ModulesWithBasis.HomCategory TypeError\n57 sage.categories.tensor.TensorProductsCategory TypeError\n58 sage.categories.algebras.Algebras.DualObjects TypeError\n59 sage.categories.semigroups.Semigroups.Quotients TypeError\n60 sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis.TensorProducts TypeError\n61 sage.categories.finite_sets.FiniteSets.Subquotients TypeError\n62 sage.categories.category_types.Category_over_base_ring NotImplementedError\n63 sage.categories.category_with_axiom.SmallTestObjects NotImplementedError\n64 sage.categories.hopf_algebras.HopfAlgebras.TensorProducts TypeError\n65 sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements AttributeError\n66 sage.categories.covariant_functorial_construction.CovariantConstructionCategory TypeError\n67 sage.categories.magmas.Magmas.CartesianProducts TypeError\n68 sage.categories.semigroups.Semigroups.CartesianProducts TypeError\n69 sage.categories.dual.DualObjectsCategory TypeError\n70 sage.categories.modules.Modules.EndCategory TypeError\n71 sage.categories.finite_sets.FiniteSets.Algebras AssertionError\n72 sage.algebras.iwahori_hecke_algebra.IwahoriHeckeAlgebra._BasesCategory AttributeError\n73 sage.categories.coalgebras.Coalgebras.WithRealizations TypeError\n74 sage.categories.subobjects.SubobjectsCategory TypeError\n75 sage.categories.sets_cat.Sets.WithRealizations TypeError\n76 sage.categories.additive_magmas.AdditiveUnital.WithRealizations TypeError\n77 sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.CartesianProducts TypeError\n78 sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts TypeError\n79 sage.categories.semigroups.Semigroups.Algebras AssertionError\n80 <class 'sage.categories.modules.Modules'> yields instance of <class 'sage.categories.vector_spaces.VectorSpaces_with_category'>\n81 sage.categories.modules.Modules.HomCategory TypeError\n82 sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative TypeError\n83 sage.categories.monoids.Monoids.WithRealizations TypeError\n84 sage.categories.covariant_functorial_construction.RegressiveCovariantConstructionCategory TypeError\n85 sage.categories.rings.Rings.HomCategory TypeError\n86 sage.categories.category_singleton.Category_singleton AssertionError\n87 sage.categories.category.Category NotImplementedError\n88 sage.categories.monoids.Monoids.Subquotients TypeError\n89 sage.combinat.ncsym.bases.NCSymBases AttributeError\n90 sage.categories.coalgebras.Coalgebras.Realizations TypeError\n91 sage.categories.with_realizations.WithRealizationsCategory TypeError\n92 sage.categories.sets_cat.Sets.IsomorphicObjects TypeError\n93 sage.categories.sets_cat.Sets.Quotients TypeError\n94 sage.categories.monoids.Monoids.CartesianProducts TypeError\n95 sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF AttributeError\n96 sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts TypeError\n97 sage.categories.magmas.Magmas.Subquotients TypeError\n98 sage.categories.category.JoinCategory TypeError\n99 sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis.WithRealizations TypeError\n100 sage.algebras.iwahori_hecke_algebra.IwahoriHeckeAlgebra_nonstandard._BasesCategory AttributeError\n101 sage.categories.sets_cat.Sets.HomCategory TypeError\n102 sage.categories.monoids.Monoids.Algebras AssertionError\n103 sage.categories.category_types.Category_over_base NotImplementedError\n104 sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.Algebras AssertionError\n105 sage.categories.category_with_axiom.BrokenTestObjects.Commutative NotImplementedError\n106 <class 'sage.categories.modules_with_basis.ModulesWithBasis'> yields instance of <class 'sage.categories.vector_spaces.VectorSpaces.WithBasis_with_category'>\n107 sage.categories.category_with_axiom.TestObjectsOverBaseRing.Unital TypeError\n108 sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional TypeError\n109 sage.categories.category_with_axiom.BrokenTestObjects.Finite NotImplementedError\n110 sage.categories.category_with_axiom.Commutative.Facade TypeError\n111 <class 'sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis'> yields instance of <class 'sage.categories.category.JoinCategory_with_category'>\n112 sage.categories.category_with_axiom.Commutative.FiniteDimensional TypeError\n113 <class 'sage.categories.modules.Modules.FiniteDimensional'> yields instance of <class 'sage.categories.category.JoinCategory_with_category'>\n114 sage.categories.category_with_axiom.SmallTestObjects.Finite NotImplementedError\n115 sage.categories.category_with_axiom.Commutative.Finite TypeError\n116 sage.categories.category_with_axiom.FiniteDimensional.Finite TypeError\n117 sage.categories.category_with_axiom.Commutative.Finite NotImplementedError\n118 sage.categories.category_with_axiom.FiniteDimensional.Unital TypeError\n119 sage.categories.category_with_axiom.Finite.Commutative NotImplementedError\n120 sage.categories.category_with_axiom.Unital.Commutative TypeError\n```\n\nIn examples 80, 106, 111 and 113, `C.an_instance()` does return something, but it does not return an instance of C.\n\nAnd please don't forget:\n\n```\nsage: type(sage.categories.category_with_axiom.SmallTestObjects.Connected)\n<type 'int'>\nsage: type(sage.categories.category_with_axiom.SmallTestObjects.Commutative)\n<type 'classobj'>\n```\nwhich are bugs, too.\n\n> Have you tried the category_sample\n> function?\n\nNever heard of it before, hence: No.\n \n> I am not sure. If there is some inconsistency, you can always work in\n> a sublattice (with bottom) that contains all the involved categories,\n> rather than the full lattice. And I would not be surprised if it could\n> be argued that one could always choose such a sublattice with a\n> category that is actually implemented in Sage.\n\nSublattice it is. But how big do you need to choose the sublattice in order to\ndetect the inconsistency? Since we already have Gr\u00f6bner bases in this thread:\nGenerally you'll need to consider elements of rather high degree in order to\ndetect all relations in small degree. Sure, in a boolean polynomial ring the\norder is bounded by the number of generators, as they are idempotent.\n\n> Right. But Sage's startup would still require being able to manipulate\n> such a Gr\u00f6bner basis in one form or the other. And one needs to make\n> sure the Gr\u00f6bner basis is consistent with all the code (that is Sage's\n> compilation might require a Gr\u00f6bner basis computation). And that it\n> can be extended dynamically if users introduce new categories in their\n> own library.\n\nExactly. If I had to choose between a Gr\u00f6bner basis computation in a boolean\npolynomial ring (which is a relatively moderate task due to idempotency) and\nthe requirement to manually do local choices that are globally consistent, I'd\ndo the former.\n\n> I am certainly not saying it's not doable. But it introduces some\n> complexity which has to be well motivated.\n\nAre you talking about *mathematical* complexity? Then my answer is that the\ncomplexity of the underlying local--global problem is there, whether we want\nit or not. And I'd rather have the complexity dealt with by a mathematical\ntheory (commutative algebra) than by the inspiration of all future developers\nof categories.\n\n> Sorry, I can't resist; let me use the very argument that soo many\n> people have raised when saying that all that category stuff was just\n> overdesign. \u00abBefore introducing non trivial design to solve a scaling\n> issue, one needs to be sure there is one in practice\u00bb.  So far, I\n> haven't had a single time where I got bothered by that.\n\nWith exception of the `Blahs.Unital.Blue` example, you mean...\n \n> For Fields vs Division rings, the asymmetry is *very* natural. You put\n> the class in Fields.Finite, because it's about stuff valid for finite\n> fields. And you put in DivisionRings the theorem which tells you that\n> in the context of division rings, the \"Finite\" axiom implies the\n> \"commutative\" axioms.\n\nThen consider the axiom `a*b==a*c => b==c` (I don't know an English word for\nit, thus call it \"k\u00fcrzbar\"). There are infinite \"k\u00fcrzbare\" rings that aren't\ndivision ring (e.g., the ring of integers). However, for finite rings, being\n\"k\u00fcrzbar\" and \"division\" are equivalent.\n\nSo, you have a perfectly symmetric formulation:\n`Rings.Finite.K\u00fcrzbar==Rings.Finite.Division`. So, how to choose a default? In\nthis particular example you could argue that both are equal to\n`Fields.Finite`. But generally?\n\nNext, imagine you have several of such symmetric statements. You *can* do a\nconsistent symmetry break---but that's probably equivalent to chosing a\nmonomial order in a polynomial ring.\n\n>  And\n> second DivisionRings().Finite() would not coincide with\n> Fields().Finite(); and this is the first thing you would test.\n\nWhy not? If I do\n\n```\nDivisionRings.Finite = FiniteFields # lazily imported from sage.categories.finite_fields\n```\nand\n\n```\nFields.Finite = FiniteFields # lazily imported from sage.categories.finite_fields\n```\nthen of course both are the same!\n\nThe only problem is that the current *implementation* would complain. And\nthat's what I think is a deficiency of the current implementation. Doing the\nabove is natural and easy syntax, and it should be supported.\n\n> I believe, and will work on proving formally, that the current\n> implementation is perfectly well-defined and gives normal forms.\n\nI am talking about people who want to extend the current implementation: Add\nnew axioms, new basic categories, and in particular new mathematical theorems\nabout categorial identities.\n \n> No I did not do wrong. It does demonstrates *on\n> purpose* a *missing feature*: namely that you currently can't use the\n> Blue_extra_super_categories mechanism in the category where the Blue\n> axiom is defined.\n\nYou talk about an implementation detail (`Blue_extra_super_categories`). I am\ntalking about the fact that in this example (made up) mathematical axioms do not commute.",
    "created_at": "2014-01-19T19:31:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109220",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:433'></a>
Replying to [nthiery](#comment%3A431):
> Now, I am actually surprised that you get that many. Can you give a
> couple examples where this fails?

The `TestCategoryModel()` from [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py) returns (among other things) a list of all category classes for which `an_instance()` does not return an instance of the class. This list seems to be stable.

Side-note: The other tests do not seem stable yet: They differ from run to run. Anyway, I'll work on it.

Here are the classes and the errors I am getting:

```
0 sage.combinat.ncsym.bases.NCSymDualBases AttributeError
1 sage.categories.modules_with_basis.ModulesWithBasis.DualObjects TypeError
2 sage.categories.algebra_functor.AlgebrasCategory AssertionError
3 sage.categories.additive_magmas.AdditiveMagmas.Algebras AssertionError
4 sage.categories.hopf_algebras.HopfAlgebras.DualCategory NotImplementedError
5 sage.categories.additive_semigroups.AdditiveSemigroups.Algebras AssertionError
6 sage.categories.category_types.AbelianCategory NotImplementedError
7 sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases AttributeError
8 sage.combinat.descent_algebra.DescentAlgebraBases AttributeError
9 sage.categories.quotients.QuotientsCategory TypeError
10 sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases AttributeError
11 sage.categories.additive_magmas.AdditiveCommutative.Algebras AssertionError
12 sage.categories.realizations.RealizationsCategory TypeError
13 sage.combinat.ncsym.bases.MultiplicativeNCSymBases AttributeError
14 sage.categories.sets_cat.Sets.CartesianProducts TypeError
15 sage.categories.graded_modules.GradedModulesCategory KeyError
16 sage.categories.sets_cat.Sets.Subobjects TypeError
17 sage.categories.cartesian_product.CartesianProductsCategory TypeError
18 sage.categories.magmas.Magmas.Realizations TypeError
19 sage.categories.hopf_algebras.HopfAlgebras.Realizations TypeError
20 sage.categories.groups.Groups.Algebras AssertionError
21 sage.categories.magmas.Magmas.Algebras AssertionError
22 sage.categories.isomorphic_objects.IsomorphicObjectsCategory TypeError
23 sage.categories.sets_with_partial_maps.SetsWithPartialMaps.HomCategory TypeError
24 sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations TypeError
25 sage.combinat.sf.sfa.SymmetricFunctionsBases AttributeError
26 sage.categories.category.HomCategory TypeError
27 sage.categories.sets_cat.Sets.Subquotients TypeError
28 sage.categories.algebras_with_basis.AlgebrasWithBasis.CartesianProducts TypeError
29 sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.IsomorphicObjects TypeError
30 sage.categories.sets_cat.Sets.Realizations TypeError
31 sage.categories.realizations.Category_realization_of_parent NotImplementedError
32 sage.categories.category_with_axiom.BrokenTestObjects NotImplementedError
33 sage.categories.category.CategoryWithParameters NotImplementedError
34 sage.categories.magmas.Commutative.Algebras AssertionError
35 sage.categories.vector_spaces.VectorSpaces.DualObjects TypeError
36 sage.categories.hopf_algebras.HopfAlgebras.Morphism NotImplementedError
37 sage.categories.category_types.Category_in_ambient TypeError
38 sage.categories.objects.Objects.HomCategory TypeError
39 sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements AttributeError
40 sage.categories.schemes.Schemes.HomCategory TypeError
41 sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases AttributeError
42 sage.categories.semigroups.Semigroups.Subquotients TypeError
43 sage.categories.sets_cat.Sets.Algebras AssertionError
44 sage.categories.coalgebras.Coalgebras.TensorProducts TypeError
45 sage.categories.hecke_modules.HeckeModules.HomCategory TypeError
46 sage.categories.category_types.Category_module NotImplementedError
47 sage.categories.algebras.Algebras.CartesianProducts TypeError
48 sage.categories.algebras_with_basis.AlgebrasWithBasis.TensorProducts TypeError
49 sage.combinat.ncsym.bases.NCSymOrNCSymDualBases AttributeError
50 sage.categories.subquotients.SubquotientsCategory TypeError
51 sage.categories.algebras.Algebras.TensorProducts TypeError
52 sage.categories.coalgebras.Coalgebras.DualObjects TypeError
53 sage.categories.magmas.Unital.Algebras AssertionError
54 sage.categories.additive_magmas.AdditiveUnital.Algebras AssertionError
55 sage.categories.category_types.Category_ideal NotImplementedError
56 sage.categories.modules_with_basis.ModulesWithBasis.HomCategory TypeError
57 sage.categories.tensor.TensorProductsCategory TypeError
58 sage.categories.algebras.Algebras.DualObjects TypeError
59 sage.categories.semigroups.Semigroups.Quotients TypeError
60 sage.categories.hopf_algebras_with_basis.HopfAlgebrasWithBasis.TensorProducts TypeError
61 sage.categories.finite_sets.FiniteSets.Subquotients TypeError
62 sage.categories.category_types.Category_over_base_ring NotImplementedError
63 sage.categories.category_with_axiom.SmallTestObjects NotImplementedError
64 sage.categories.hopf_algebras.HopfAlgebras.TensorProducts TypeError
65 sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements AttributeError
66 sage.categories.covariant_functorial_construction.CovariantConstructionCategory TypeError
67 sage.categories.magmas.Magmas.CartesianProducts TypeError
68 sage.categories.semigroups.Semigroups.CartesianProducts TypeError
69 sage.categories.dual.DualObjectsCategory TypeError
70 sage.categories.modules.Modules.EndCategory TypeError
71 sage.categories.finite_sets.FiniteSets.Algebras AssertionError
72 sage.algebras.iwahori_hecke_algebra.IwahoriHeckeAlgebra._BasesCategory AttributeError
73 sage.categories.coalgebras.Coalgebras.WithRealizations TypeError
74 sage.categories.subobjects.SubobjectsCategory TypeError
75 sage.categories.sets_cat.Sets.WithRealizations TypeError
76 sage.categories.additive_magmas.AdditiveUnital.WithRealizations TypeError
77 sage.categories.finite_enumerated_sets.FiniteEnumeratedSets.CartesianProducts TypeError
78 sage.categories.modules_with_basis.ModulesWithBasis.CartesianProducts TypeError
79 sage.categories.semigroups.Semigroups.Algebras AssertionError
80 <class 'sage.categories.modules.Modules'> yields instance of <class 'sage.categories.vector_spaces.VectorSpaces_with_category'>
81 sage.categories.modules.Modules.HomCategory TypeError
82 sage.categories.category_with_axiom.TestObjectsOverBaseRing.Commutative TypeError
83 sage.categories.monoids.Monoids.WithRealizations TypeError
84 sage.categories.covariant_functorial_construction.RegressiveCovariantConstructionCategory TypeError
85 sage.categories.rings.Rings.HomCategory TypeError
86 sage.categories.category_singleton.Category_singleton AssertionError
87 sage.categories.category.Category NotImplementedError
88 sage.categories.monoids.Monoids.Subquotients TypeError
89 sage.combinat.ncsym.bases.NCSymBases AttributeError
90 sage.categories.coalgebras.Coalgebras.Realizations TypeError
91 sage.categories.with_realizations.WithRealizationsCategory TypeError
92 sage.categories.sets_cat.Sets.IsomorphicObjects TypeError
93 sage.categories.sets_cat.Sets.Quotients TypeError
94 sage.categories.monoids.Monoids.CartesianProducts TypeError
95 sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF AttributeError
96 sage.categories.modules_with_basis.ModulesWithBasis.TensorProducts TypeError
97 sage.categories.magmas.Magmas.Subquotients TypeError
98 sage.categories.category.JoinCategory TypeError
99 sage.categories.graded_hopf_algebras_with_basis.GradedHopfAlgebrasWithBasis.WithRealizations TypeError
100 sage.algebras.iwahori_hecke_algebra.IwahoriHeckeAlgebra_nonstandard._BasesCategory AttributeError
101 sage.categories.sets_cat.Sets.HomCategory TypeError
102 sage.categories.monoids.Monoids.Algebras AssertionError
103 sage.categories.category_types.Category_over_base NotImplementedError
104 sage.categories.commutative_additive_groups.CommutativeAdditiveGroups.Algebras AssertionError
105 sage.categories.category_with_axiom.BrokenTestObjects.Commutative NotImplementedError
106 <class 'sage.categories.modules_with_basis.ModulesWithBasis'> yields instance of <class 'sage.categories.vector_spaces.VectorSpaces.WithBasis_with_category'>
107 sage.categories.category_with_axiom.TestObjectsOverBaseRing.Unital TypeError
108 sage.categories.category_with_axiom.TestObjectsOverBaseRing.FiniteDimensional TypeError
109 sage.categories.category_with_axiom.BrokenTestObjects.Finite NotImplementedError
110 sage.categories.category_with_axiom.Commutative.Facade TypeError
111 <class 'sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis'> yields instance of <class 'sage.categories.category.JoinCategory_with_category'>
112 sage.categories.category_with_axiom.Commutative.FiniteDimensional TypeError
113 <class 'sage.categories.modules.Modules.FiniteDimensional'> yields instance of <class 'sage.categories.category.JoinCategory_with_category'>
114 sage.categories.category_with_axiom.SmallTestObjects.Finite NotImplementedError
115 sage.categories.category_with_axiom.Commutative.Finite TypeError
116 sage.categories.category_with_axiom.FiniteDimensional.Finite TypeError
117 sage.categories.category_with_axiom.Commutative.Finite NotImplementedError
118 sage.categories.category_with_axiom.FiniteDimensional.Unital TypeError
119 sage.categories.category_with_axiom.Finite.Commutative NotImplementedError
120 sage.categories.category_with_axiom.Unital.Commutative TypeError
```

In examples 80, 106, 111 and 113, `C.an_instance()` does return something, but it does not return an instance of C.

And please don't forget:

```
sage: type(sage.categories.category_with_axiom.SmallTestObjects.Connected)
<type 'int'>
sage: type(sage.categories.category_with_axiom.SmallTestObjects.Commutative)
<type 'classobj'>
```
which are bugs, too.

> Have you tried the category_sample
> function?

Never heard of it before, hence: No.
 
> I am not sure. If there is some inconsistency, you can always work in
> a sublattice (with bottom) that contains all the involved categories,
> rather than the full lattice. And I would not be surprised if it could
> be argued that one could always choose such a sublattice with a
> category that is actually implemented in Sage.

Sublattice it is. But how big do you need to choose the sublattice in order to
detect the inconsistency? Since we already have Gröbner bases in this thread:
Generally you'll need to consider elements of rather high degree in order to
detect all relations in small degree. Sure, in a boolean polynomial ring the
order is bounded by the number of generators, as they are idempotent.

> Right. But Sage's startup would still require being able to manipulate
> such a Gröbner basis in one form or the other. And one needs to make
> sure the Gröbner basis is consistent with all the code (that is Sage's
> compilation might require a Gröbner basis computation). And that it
> can be extended dynamically if users introduce new categories in their
> own library.

Exactly. If I had to choose between a Gröbner basis computation in a boolean
polynomial ring (which is a relatively moderate task due to idempotency) and
the requirement to manually do local choices that are globally consistent, I'd
do the former.

> I am certainly not saying it's not doable. But it introduces some
> complexity which has to be well motivated.

Are you talking about *mathematical* complexity? Then my answer is that the
complexity of the underlying local--global problem is there, whether we want
it or not. And I'd rather have the complexity dealt with by a mathematical
theory (commutative algebra) than by the inspiration of all future developers
of categories.

> Sorry, I can't resist; let me use the very argument that soo many
> people have raised when saying that all that category stuff was just
> overdesign. «Before introducing non trivial design to solve a scaling
> issue, one needs to be sure there is one in practice».  So far, I
> haven't had a single time where I got bothered by that.

With exception of the `Blahs.Unital.Blue` example, you mean...
 
> For Fields vs Division rings, the asymmetry is *very* natural. You put
> the class in Fields.Finite, because it's about stuff valid for finite
> fields. And you put in DivisionRings the theorem which tells you that
> in the context of division rings, the "Finite" axiom implies the
> "commutative" axioms.

Then consider the axiom `a*b==a*c => b==c` (I don't know an English word for
it, thus call it "kürzbar"). There are infinite "kürzbare" rings that aren't
division ring (e.g., the ring of integers). However, for finite rings, being
"kürzbar" and "division" are equivalent.

So, you have a perfectly symmetric formulation:
`Rings.Finite.Kürzbar==Rings.Finite.Division`. So, how to choose a default? In
this particular example you could argue that both are equal to
`Fields.Finite`. But generally?

Next, imagine you have several of such symmetric statements. You *can* do a
consistent symmetry break---but that's probably equivalent to chosing a
monomial order in a polynomial ring.

>  And
> second DivisionRings().Finite() would not coincide with
> Fields().Finite(); and this is the first thing you would test.

Why not? If I do

```
DivisionRings.Finite = FiniteFields # lazily imported from sage.categories.finite_fields
```
and

```
Fields.Finite = FiniteFields # lazily imported from sage.categories.finite_fields
```
then of course both are the same!

The only problem is that the current *implementation* would complain. And
that's what I think is a deficiency of the current implementation. Doing the
above is natural and easy syntax, and it should be supported.

> I believe, and will work on proving formally, that the current
> implementation is perfectly well-defined and gives normal forms.

I am talking about people who want to extend the current implementation: Add
new axioms, new basic categories, and in particular new mathematical theorems
about categorial identities.
 
> No I did not do wrong. It does demonstrates *on
> purpose* a *missing feature*: namely that you currently can't use the
> Blue_extra_super_categories mechanism in the category where the Blue
> axiom is defined.

You talk about an implementation detail (`Blue_extra_super_categories`). I am
talking about the fact that in this example (made up) mathematical axioms do not commute.



---

archive/issue_comments_109221.json:
```json
{
    "body": "<a id='comment:4'></a>\nPS: In th above list of 121 category classes with failing `an_instance()`, there are of course many classes that probably should not be directly instantiated. So, the \"real\" list will be much shorter. Above list was found by an automatic procedure that simply imported all available subclasses of `Category` and tried `an_instance()` on them.",
    "created_at": "2014-01-19T19:42:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109221",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
PS: In th above list of 121 category classes with failing `an_instance()`, there are of course many classes that probably should not be directly instantiated. So, the "real" list will be much shorter. Above list was found by an automatic procedure that simply imported all available subclasses of `Category` and tried `an_instance()` on them.



---

archive/issue_comments_109222.json:
```json
{
    "body": "<a id='comment:435'></a>\nReplying to [nthiery](#comment%3A431):\n> Have you tried the category_sample function?\n\nNow I have, and I get a list of only 97 categories. `Blahs()` is missing. But anyway, thank you for the pointer.\n\n> Right. But Sage's startup would still require being able to manipulate\n> such a Gr\u00f6bner basis in one form or the other. And one needs to make\n> sure the Gr\u00f6bner basis is consistent with all the code (that is Sage's\n> compilation might require a Gr\u00f6bner basis computation).\n\nIn the code, you would provide the local data for the plain acyclic digraph structure of categories. The Gr\u00f6bner basis would be used to extract from it consistent local data of a spanning tree that is specified by the (fixed) choice of a monomial order. This does not happen at compile time, but only when a class is created (by a metaclass).\n\nThe only difference to the current implementation: Currently, you need to specify local data for the plain acyclic digraph and *at the same time* provide local data for a spanning tree (by moving some stuff into cached methods rather than class attributes) that is not explicitly specified (it is implicitly specified by the perceived asymmetry in statements of mathematical theorems).\n\nI indicated before: Making the database-metaclass-indexed-by-standard-monomials approach productive clearly is for a different ticket. However, creating a tool that asserts consistency of the *current* implementation is something that I see happening on *this* ticket. That's why I don't move the discussion to a different ticket, and that's why I keep working on [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py).\n\n> Sorry, I can't resist; let me use the very argument that soo many\n> people have raised when saying that all that category stuff was just\n> overdesign. \u00abBefore introducing non trivial design to solve a scaling\n> issue, one needs to be sure there is one in practice\u00bb.  So far, I\n> haven't had a single time where I got bothered by that.\n\nWell, in my early Sage days I occasionally complained that the source code of\ncategory stuff can hardly be found (thus, I improved `sage.misc.sageinspect`) and that\nthe category framework is responsible for slowing things down (thus, I made\nsome contributions in that regard). But I did not raise the very argument you\nare mentioning. So, I am clearly entitled to consider over-design to solve\nfar-fetched scalability issues `;-)`.\n\n> > > Since every category class is supposed to be TestSuit'ed, we should\n> > > cover all categories this way. Do you think we would get a global\n> > > enough view?\n\n> > \n> > No.\n\n> \n> Can you give me a sketch of scenario where this would fail?\n\nI am not saying that it would *necessarily* fail. However, a local test\n*may* fail. And rather than repeating the same local test over and over in the `TestSuite` of any category, I'd like to have *one* test\n(say, a doctest of `sage.categories.categories_with_axiom`) that takes into\naccount the whole digraph and is thus reliable.\n\n\n> I believe, and will work on proving formally, that the current\n> implementation is perfectly well-defined and gives normal forms.\n\nI believe it, too, and I am working on a formal proof (using commutative\nalgebra), modulo missing instances of some category classes.\n\nIn addition, the minimum of what I want is this: Provide a tool that\nasserts consistency of choices, so that future developers are prevented from\ndoing wrong choices when they extend the category-with-axiom framework.\n\nIt would be used as follows: Developer X implements a new category class C and\nwants to make it accessible by applying certain axioms to certain base\ncategories. Then, X can call a function that returns *the* correct choice of\na default construction, hence, *the* correct choice of \n`C._base_category_class_and_axiom` (*the*, because it should be uniquely\ndetermined after fixing a monomial order), which also tells where X should use\na (lazily imported) class attribute and where a cached method in the\n`SubcategoryMethods`.\n \n> Anyway, I read you agree that this is all for a later ticket, right?\n\nPartially. A concistency checker is something for here. A database-metaclass\nturning the checker into a productive tool to simplify the implementation of\nnew categories-with-axiom is for later.\n\n> Can you please move the discussion to a different ticket?\n\nSee reasoning above.\n\nBest regards,\n Simon",
    "created_at": "2014-01-19T21:28:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109222",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:435'></a>
Replying to [nthiery](#comment%3A431):
> Have you tried the category_sample function?

Now I have, and I get a list of only 97 categories. `Blahs()` is missing. But anyway, thank you for the pointer.

> Right. But Sage's startup would still require being able to manipulate
> such a Gröbner basis in one form or the other. And one needs to make
> sure the Gröbner basis is consistent with all the code (that is Sage's
> compilation might require a Gröbner basis computation).

In the code, you would provide the local data for the plain acyclic digraph structure of categories. The Gröbner basis would be used to extract from it consistent local data of a spanning tree that is specified by the (fixed) choice of a monomial order. This does not happen at compile time, but only when a class is created (by a metaclass).

The only difference to the current implementation: Currently, you need to specify local data for the plain acyclic digraph and *at the same time* provide local data for a spanning tree (by moving some stuff into cached methods rather than class attributes) that is not explicitly specified (it is implicitly specified by the perceived asymmetry in statements of mathematical theorems).

I indicated before: Making the database-metaclass-indexed-by-standard-monomials approach productive clearly is for a different ticket. However, creating a tool that asserts consistency of the *current* implementation is something that I see happening on *this* ticket. That's why I don't move the discussion to a different ticket, and that's why I keep working on [attachment:consistency.py](https://github.com/sagemath/sage/files/ticket10963/consistency.py).

> Sorry, I can't resist; let me use the very argument that soo many
> people have raised when saying that all that category stuff was just
> overdesign. «Before introducing non trivial design to solve a scaling
> issue, one needs to be sure there is one in practice».  So far, I
> haven't had a single time where I got bothered by that.

Well, in my early Sage days I occasionally complained that the source code of
category stuff can hardly be found (thus, I improved `sage.misc.sageinspect`) and that
the category framework is responsible for slowing things down (thus, I made
some contributions in that regard). But I did not raise the very argument you
are mentioning. So, I am clearly entitled to consider over-design to solve
far-fetched scalability issues `;-)`.

> > > Since every category class is supposed to be TestSuit'ed, we should
> > > cover all categories this way. Do you think we would get a global
> > > enough view?

> > 
> > No.

> 
> Can you give me a sketch of scenario where this would fail?

I am not saying that it would *necessarily* fail. However, a local test
*may* fail. And rather than repeating the same local test over and over in the `TestSuite` of any category, I'd like to have *one* test
(say, a doctest of `sage.categories.categories_with_axiom`) that takes into
account the whole digraph and is thus reliable.


> I believe, and will work on proving formally, that the current
> implementation is perfectly well-defined and gives normal forms.

I believe it, too, and I am working on a formal proof (using commutative
algebra), modulo missing instances of some category classes.

In addition, the minimum of what I want is this: Provide a tool that
asserts consistency of choices, so that future developers are prevented from
doing wrong choices when they extend the category-with-axiom framework.

It would be used as follows: Developer X implements a new category class C and
wants to make it accessible by applying certain axioms to certain base
categories. Then, X can call a function that returns *the* correct choice of
a default construction, hence, *the* correct choice of 
`C._base_category_class_and_axiom` (*the*, because it should be uniquely
determined after fixing a monomial order), which also tells where X should use
a (lazily imported) class attribute and where a cached method in the
`SubcategoryMethods`.
 
> Anyway, I read you agree that this is all for a later ticket, right?

Partially. A concistency checker is something for here. A database-metaclass
turning the checker into a productive tool to simplify the implementation of
new categories-with-axiom is for later.

> Can you please move the discussion to a different ticket?

See reasoning above.

Best regards,
 Simon



---

archive/issue_comments_109223.json:
```json
{
    "body": "<a id='comment:6'></a>\nAs indicated above, it seems natural to me that we prefer a \"short\"\nconstruction (start with a basic category and apply few axioms) over a \"long\"\nconstruction (involving a long chain of axioms. This means we would prefer a\ndegree order. However, it *really* matters what happens after comparing\ndegrees.\n\nIn all examples, I am using a degneglex order.\n\n- Start with the basic categories *reversedly* sorted by their name,\n  followed by the axioms in the *reversed* order given by\n  `sage.categories.categories_with_axioms.all_axioms`. Then, there is only one\n  complaint, namely: `Blahs.Unital.Blue` should coincide with\n  `Blahs.Unital`.\n\n- Start with the basic categories *directly* sorted by their name, followed\n  by the xioms in the *reversed* order given by\n  `sage.categories.categories_with_axioms.all_axioms`. Then, we additionally\n  find: `TestObjects.FiniteDimensional.Unital` should better be provided by\n  `Bars.Unital.FiniteDimensional`. Similarly for other educational examples in\n  `sage.categories.category_with_axiom`.\n\n- Start with the basic categories *reversedly* sorted by their name,\n  followed by the axioms in the *direct* order given by\n  `sage.categories.categories_with_axioms.all_axioms`. Then the problems are\n  similar to the previous case, in the educational examples in\n  `sage.categories.category_with_axiom`. Such as: `TestObjects.FiniteDimensional.Unital` should \n  better be provided by `TestObjects.Blue.FiniteDimensional`.\n\n- Start with the basic categories *directly* sorted by their name, followed\n  by the axioms in the *direct* order given by\n  `sage.categories.categories_with_axioms.all_axioms`. Again, problems with\n  the educational examples in `sage.categories.category_with_axiom`. Such as: \n  `TestObjectsOverBaseRing.Unital` should rather be provided as `TestObjectsOverBaseRing.Blue`.\n\nThis result is temporary, as I still seem to miss a couple of category\nclasses. However, what does it tell us?\n\nOn the plus side, all \"real\" examples work consistently.\n\nOn the negative side, a consistent choice of local spanning tree data does\ndepend on choosing a monomial order. This order is nowhere explicit, but with\nsome orders the choices made in educational examples fail. Who can guarantee\nthat the same will never happen in future real world examples, unless we make\nthe implicit order explicit?\n\nOn the neutral side, I am still not sure whether my consistency test is\nairtight and waterproof...",
    "created_at": "2014-01-19T23:05:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109223",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
As indicated above, it seems natural to me that we prefer a "short"
construction (start with a basic category and apply few axioms) over a "long"
construction (involving a long chain of axioms. This means we would prefer a
degree order. However, it *really* matters what happens after comparing
degrees.

In all examples, I am using a degneglex order.

- Start with the basic categories *reversedly* sorted by their name,
  followed by the axioms in the *reversed* order given by
  `sage.categories.categories_with_axioms.all_axioms`. Then, there is only one
  complaint, namely: `Blahs.Unital.Blue` should coincide with
  `Blahs.Unital`.

- Start with the basic categories *directly* sorted by their name, followed
  by the xioms in the *reversed* order given by
  `sage.categories.categories_with_axioms.all_axioms`. Then, we additionally
  find: `TestObjects.FiniteDimensional.Unital` should better be provided by
  `Bars.Unital.FiniteDimensional`. Similarly for other educational examples in
  `sage.categories.category_with_axiom`.

- Start with the basic categories *reversedly* sorted by their name,
  followed by the axioms in the *direct* order given by
  `sage.categories.categories_with_axioms.all_axioms`. Then the problems are
  similar to the previous case, in the educational examples in
  `sage.categories.category_with_axiom`. Such as: `TestObjects.FiniteDimensional.Unital` should 
  better be provided by `TestObjects.Blue.FiniteDimensional`.

- Start with the basic categories *directly* sorted by their name, followed
  by the axioms in the *direct* order given by
  `sage.categories.categories_with_axioms.all_axioms`. Again, problems with
  the educational examples in `sage.categories.category_with_axiom`. Such as: 
  `TestObjectsOverBaseRing.Unital` should rather be provided as `TestObjectsOverBaseRing.Blue`.

This result is temporary, as I still seem to miss a couple of category
classes. However, what does it tell us?

On the plus side, all "real" examples work consistently.

On the negative side, a consistent choice of local spanning tree data does
depend on choosing a monomial order. This order is nowhere explicit, but with
some orders the choices made in educational examples fail. Who can guarantee
that the same will never happen in future real world examples, unless we make
the implicit order explicit?

On the neutral side, I am still not sure whether my consistency test is
airtight and waterproof...



---

archive/issue_comments_109224.json:
```json
{
    "body": "<a id='comment:437'></a>\nHi Simon!\n\nShort answer for now. I have a longer answer from yesterday which did\nnot go through before I went to bed.\n\nReplying to [SimonKing](#comment%3A436):\n> As indicated above, it seems natural to me that we prefer a \"short\"\n> construction (start with a basic category and apply few axioms) over a \"long\"\n> construction (involving a long chain of axioms. This means we would prefer a\n> degree order. However, it *really* matters what happens after comparing\n> degrees.\n> \n> In all examples, I am using a degneglex order.\n> \n> - Start with the basic categories *reversedly* sorted by their name,\n>   followed by the axioms in the *reversed* order given by\n>   `sage.categories.categories_with_axioms.all_axioms`. Then, there is only one\n>   complaint, namely: `Blahs.Unital.Blue` should coincide with\n>   `Blahs.Unital`.\n> \n> - Start with the basic categories *directly* sorted by their name, followed\n>   by the xioms in the *reversed* order given by\n>   `sage.categories.categories_with_axioms.all_axioms`. Then, we additionally\n>   find: `TestObjects.FiniteDimensional.Unital` should better be provided by\n>   `Bars.Unital.FiniteDimensional`. Similarly for other educational examples in\n>   `sage.categories.category_with_axiom`.\n> \n> - Start with the basic categories *reversedly* sorted by their name,\n>   followed by the axioms in the *direct* order given by\n>   `sage.categories.categories_with_axioms.all_axioms`. Then the problems are\n>   similar to the previous case, in the educational examples in\n>   `sage.categories.category_with_axiom`. Such as: `TestObjects.FiniteDimensional.Unital` should \n>   better be provided by `TestObjects.Blue.FiniteDimensional`.\n> \n> - Start with the basic categories *directly* sorted by their name, followed\n>   by the axioms in the *direct* order given by\n>   `sage.categories.categories_with_axioms.all_axioms`. Again, problems with\n>   the educational examples in `sage.categories.category_with_axiom`. Such as: \n>   `TestObjectsOverBaseRing.Unital` should rather be provided as `TestObjectsOverBaseRing.Blue`.\n> \n> This result is temporary, as I still seem to miss a couple of category\n> classes. However, what does it tell us?\n> \n> On the plus side, all \"real\" examples work consistently.\n> \n> On the negative side, a consistent choice of local spanning tree data does\n> depend on choosing a monomial order. This order is nowhere explicit, but with\n> some orders the choices made in educational examples fail. Who can guarantee\n> that the same will never happen in future real world examples, unless we make\n> the implicit order explicit?\n\nLet me state it in bold: the current algorithm has been designed so\nthat *there is no local-global problem*. The global consistency\nconditions that you are trying to impose on the code are *not*\nrequired by the current specifications. You need a tree, but the tree\nneed not be that of standard monomials for whatever term order. One\ncan for example very well choose to implement an axiom category as\nCs.A.B in a category Cs, and in Ds.B.A in a subcategory.\n\nWhen I claimed the code was correct, I really meant that the\ninfrastructure algorithm was correct. That is, not only the current\ncategory code works properly, but every new category/axiom code\nwritten that respects the specifications given in the axiom\ndocumentation should work properly.\n\nYou are of course very well entitled to not believe me and I am glad\nthat you are checking my claims. Which is why I'll try today to\nformalize a proof of the infrastructure. One of the point is that the\nalgorithm computes a normal form, but that normal form is given by the\nlattice structure itself, without a need for a term order. The\ncomputations occur in a concrete lattice, not in the free lattice\nmodulo relations.\n\nIn the mean time, a hint is the fact that the algorithm gives correct\nresults even on examples where there are local choices that do not\nsatisfy your global consistency conditions (I am of course excluding\nthe example which breaks voluntarily the current specifications).\n\nCheers,\n                              Nicolas",
    "created_at": "2014-01-20T08:44:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109224",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:437'></a>
Hi Simon!

Short answer for now. I have a longer answer from yesterday which did
not go through before I went to bed.

Replying to [SimonKing](#comment%3A436):
> As indicated above, it seems natural to me that we prefer a "short"
> construction (start with a basic category and apply few axioms) over a "long"
> construction (involving a long chain of axioms. This means we would prefer a
> degree order. However, it *really* matters what happens after comparing
> degrees.
> 
> In all examples, I am using a degneglex order.
> 
> - Start with the basic categories *reversedly* sorted by their name,
>   followed by the axioms in the *reversed* order given by
>   `sage.categories.categories_with_axioms.all_axioms`. Then, there is only one
>   complaint, namely: `Blahs.Unital.Blue` should coincide with
>   `Blahs.Unital`.
> 
> - Start with the basic categories *directly* sorted by their name, followed
>   by the xioms in the *reversed* order given by
>   `sage.categories.categories_with_axioms.all_axioms`. Then, we additionally
>   find: `TestObjects.FiniteDimensional.Unital` should better be provided by
>   `Bars.Unital.FiniteDimensional`. Similarly for other educational examples in
>   `sage.categories.category_with_axiom`.
> 
> - Start with the basic categories *reversedly* sorted by their name,
>   followed by the axioms in the *direct* order given by
>   `sage.categories.categories_with_axioms.all_axioms`. Then the problems are
>   similar to the previous case, in the educational examples in
>   `sage.categories.category_with_axiom`. Such as: `TestObjects.FiniteDimensional.Unital` should 
>   better be provided by `TestObjects.Blue.FiniteDimensional`.
> 
> - Start with the basic categories *directly* sorted by their name, followed
>   by the axioms in the *direct* order given by
>   `sage.categories.categories_with_axioms.all_axioms`. Again, problems with
>   the educational examples in `sage.categories.category_with_axiom`. Such as: 
>   `TestObjectsOverBaseRing.Unital` should rather be provided as `TestObjectsOverBaseRing.Blue`.
> 
> This result is temporary, as I still seem to miss a couple of category
> classes. However, what does it tell us?
> 
> On the plus side, all "real" examples work consistently.
> 
> On the negative side, a consistent choice of local spanning tree data does
> depend on choosing a monomial order. This order is nowhere explicit, but with
> some orders the choices made in educational examples fail. Who can guarantee
> that the same will never happen in future real world examples, unless we make
> the implicit order explicit?

Let me state it in bold: the current algorithm has been designed so
that *there is no local-global problem*. The global consistency
conditions that you are trying to impose on the code are *not*
required by the current specifications. You need a tree, but the tree
need not be that of standard monomials for whatever term order. One
can for example very well choose to implement an axiom category as
Cs.A.B in a category Cs, and in Ds.B.A in a subcategory.

When I claimed the code was correct, I really meant that the
infrastructure algorithm was correct. That is, not only the current
category code works properly, but every new category/axiom code
written that respects the specifications given in the axiom
documentation should work properly.

You are of course very well entitled to not believe me and I am glad
that you are checking my claims. Which is why I'll try today to
formalize a proof of the infrastructure. One of the point is that the
algorithm computes a normal form, but that normal form is given by the
lattice structure itself, without a need for a term order. The
computations occur in a concrete lattice, not in the free lattice
modulo relations.

In the mean time, a hint is the fact that the algorithm gives correct
results even on examples where there are local choices that do not
satisfy your global consistency conditions (I am of course excluding
the example which breaks voluntarily the current specifications).

Cheers,
                              Nicolas



---

archive/issue_comments_109225.json:
```json
{
    "body": "<a id='comment:438'></a>\nReplying to [SimonKing](#comment%3A433):\n> Here are the classes and the errors I am getting:\n\nThanks!\n\nLet me go through a sample of the failures that represent all the\nothers.\n\n> ```\n> 0 sage.combinat.ncsym.bases.NCSymDualBases AttributeError\n> ```\n\nAh right, category_sample() is not looking outside of the\nsage.categories.all module. It should. This is now #15696.\n\nHmm, there will be a bunch of similar categories (basically in each\nalgebra `A` with several bases). They take `A` as first argument. We\nwill need to see how to treat them in #15696.\n\n> 1 sage.categories.modules_with_basis.ModulesWithBasis.DualObjects TypeError\n\nInteresting: we caught a bug. This should be a category over base ring\nand it's not. Of course, since this is currently unused, this went unnoticed.\n\nI added this to #15647.\n\n> 2 sage.categories.algebra_functor.AlgebrasCategory AssertionError\n\nAs you mentioned, like a couple others belows, this is not a category, but an abstract category class.\n\n> 3 sage.categories.additive_magmas.AdditiveMagmas.Algebras AssertionError\n\nOk, the default an_instance() fail for most functor categoryies\n(XXX.Algebras, XXX.Quotients, XXX.CartesianProducts, ...). It's\nprobably possible to fix all at once.\n\nI put this in #15696 too.\n\n> 32 sage.categories.category_with_axiom.BrokenTestObjects NotImplementedError\n\nOk, meant to be broken :-)\n\n> 63 sage.categories.category_with_axiom.SmallTestObjects NotImplementedError\n\nOh, right, this old test class is not used anymore! I removed it.\n\n> 107 sage.categories.category_with_axiom.TestObjectsOverBaseRing.Unital TypeError\n\nInteresting, bug again: they should have been\nCategoryWithAxiom_over_base_ring:\n\n```\nsage: TestSuite(TestObjectsOverBaseRing(QQ).FiniteDimensional()).run()\nFailure in _test_category_with_axiom:\nTraceback (most recent call last):\n  File \"/opt/sage-git/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py\", line 282, in run\n    test_method(tester = tester)\n  File \"/opt/sage-git/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py\", line 1337, in _test_category_with_axiom\n    tester.assertIsInstance(self, CategoryWithAxiom_over_base_ring)\n  File \"/opt/sage-git/local/lib/python/unittest/case.py\", line 969, in assertIsInstance\n    self.fail(self._formatMessage(msg, standardMsg))\n  File \"/opt/sage-git/local/lib/python/unittest/case.py\", line 412, in fail\n    raise self.failureException(msg)\nAssertionError: Category of finite dimensional test objects over base ring over Rational Field is not an instance of <class 'sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring'>\n```\n\nThis would have been caught with a TestSuite but there was none. I\njust fixed this and pushed.\n\n> 111 <class 'sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis'> yields instance of <class 'sage.categories.category.JoinCategory_with_category'>\n> 113 <class 'sage.categories.modules.Modules.FiniteDimensional'> yields instance of <class 'sage.categories.category.JoinCategory_with_category'>\n\nHmm, same gag as for Modules(QQ) -> VectorSpaces(QQ).\n\n> And please don't forget:\n> \n> ```\n> sage: type(sage.categories.category_with_axiom.SmallTestObjects.Connected)\n> <type 'int'>\n> sage: type(sage.categories.category_with_axiom.SmallTestObjects.Commutative)\n> <type 'classobj'>\n> ```\n> which are bugs, too.\n\nWell, they were *voluntary* bugs. I was using those at some point to\ntest the assertion checks in the code. Anyway, gone with the wind.\n\n\n\nAbout global consistency test w.r.t. consistency tests within the lattice of super categories:\n\n---\n\nLet's not waste more time on this. You are implementing it, you take\nthe final decision :-) I just meant to make sure you took into account\nthe advantages and inconvenient of both approaches (including the\ndeviation from TestSuite, that discovering the categories in the code\nis not immediate, that you need an_instance() to work, and that you\ncan't make use of the tests to know what are the relevant/interesting\ninput to feed the category constructor).\n\n\n> > I am certainly not saying it's not doable. But it introduces some\n> > complexity which has to be well motivated.\n\n> \n> Are you talking about *mathematical* complexity? Then my answer is that the\n> complexity of the underlying local--global problem is there, whether we want\n> it or not. And I'd rather have the complexity dealt with by a mathematical\n> theory (commutative algebra) than by the inspiration of all future developers\n> of categories.\n\nI am speaking of technical complexity, and that for solving what I\nbelieve to be a non issue. As I said, there should be no local-global\nproblem.\n\n\n\n> > So far, I haven't had a single time where I got bothered by that.\n\n> \n> With exception of the `Blahs.Unital.Blue` example, you mean...\n\nWell, it's not like it did strike me from behind. I made up this\nexample voluntarily to shake the system, see how it would behave when\nviolating the specifications, and document a potential limitation (I\nnever had an actual use case); and it failed as expected.\n\n> Then consider the axiom `a*b==a*c => b==c` (I don't know an English word for\n> it, thus call it \"k\u00fcrzbar\"). There are infinite \"k\u00fcrzbare\" rings that aren't\n> division ring (e.g., the ring of integers). However, for finite rings, being\n> \"k\u00fcrzbar\" and \"division\" are equivalent.\n> \n> So, you have a perfectly symmetric formulation:\n> `Rings.Finite.K\u00fcrzbar==Rings.Finite.Division`. So, how to choose a default?\n\n(from a quick googling, that's the cancellation property:\nhttp://en.wikipedia.org/wiki/Integral_domain).\n\nThis is not symmetric, because Rings().Division() is a subcategory of\nRings.Kurzbar(). Hence, the system already knows that\nRings().Finite().Division() is a subcategory of\nRings().Finite().K\u00fcrzbar(). The interesting part of the theorem, and\nthat that we need to teach Sage, is really about the reverse\ninclusion: namely that, in the context of Rings.Kurzbar, Finite\nimplies Division. Hence, this theorem is naturally implemented in\nRings.Kurzbar.Finite_extra_super_categories.\n\n> Next, imagine you have several of such symmetric statements. You *can* do a\n> consistent symmetry break---but that's probably equivalent to chosing a\n> monomial order in a polynomial ring.\n\nNo: the order is given by the subcategory relation, as above.\n\n> >  And\n> > second DivisionRings().Finite() would not coincide with\n> > Fields().Finite(); and this is the first thing you would test.\n\n> \n> Why not?\n\nThe purpose of my comment was to demonstrate that, in the current\nimplementation, if you make a mistake then this mistake is immediately\ncaught.\n\n> Doing the above (DivisionRings = Fields.Finite) is natural and easy syntax, and it should be supported.\n\nI agree it is rather natural. I actually tried (hard) to implement\nit. But knowingly decided against because not having the tree\nstructure was making the algorithmic really much more convoluted.\n\nAnd besides, the current syntax is not unnatural either. Granted, the\nname XXX_extra_super_categories is not great, but having to write a\nmethod to model something as important as a theorem is ok to me; if\nnot just because it gives a natural spot to document and test the\nmodeling of the theorem. And it's consistent with what we have been\ndoing everywhere else: the mathematical facts which relate the\ncategory together are implemented in the super_categories methods (and\ntheir variants like extra_super_categories).\n\n> > No I did not do wrong. It does demonstrates *on\n> > purpose* a *missing feature*: namely that you currently can't use the\n> > Blue_extra_super_categories mechanism in the category where the Blue\n> > axiom is defined.\n\n> \n> You talk about an implementation detail (`Blue_extra_super_categories`). I am\n> talking about the fact that in this example (made up) mathematical axioms do not commute.\n\nWell, yes, the specifications are voluntarily violated by this example\nand the infrastructure gives back wrong results (in the form of non\ncommuting axioms), which is the whole point of the example. Call it\nwhatever you like, but the infrastructure itself is behaving properly\nhere: garbage in, garbage out.\n\nI just added the following to the documentation of Blue_extra_super_categories:\n\n```\n        .. TODO::\n\n            Improve the infrastructure to detect and report this\n            violation of the specifications, if this is\n            easy. Otherwise, it's not so bad: when defining an axiom A\n            in a category ``Cs`` the first thing one is supposed to\n            doctest is that ``Cs().A()`` works. So the problem should\n            not go unnoticed.\n```\n\nCheers,\n                              Nicolas",
    "created_at": "2014-01-20T09:52:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109225",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:438'></a>
Replying to [SimonKing](#comment%3A433):
> Here are the classes and the errors I am getting:

Thanks!

Let me go through a sample of the failures that represent all the
others.

> ```
> 0 sage.combinat.ncsym.bases.NCSymDualBases AttributeError
> ```

Ah right, category_sample() is not looking outside of the
sage.categories.all module. It should. This is now #15696.

Hmm, there will be a bunch of similar categories (basically in each
algebra `A` with several bases). They take `A` as first argument. We
will need to see how to treat them in #15696.

> 1 sage.categories.modules_with_basis.ModulesWithBasis.DualObjects TypeError

Interesting: we caught a bug. This should be a category over base ring
and it's not. Of course, since this is currently unused, this went unnoticed.

I added this to #15647.

> 2 sage.categories.algebra_functor.AlgebrasCategory AssertionError

As you mentioned, like a couple others belows, this is not a category, but an abstract category class.

> 3 sage.categories.additive_magmas.AdditiveMagmas.Algebras AssertionError

Ok, the default an_instance() fail for most functor categoryies
(XXX.Algebras, XXX.Quotients, XXX.CartesianProducts, ...). It's
probably possible to fix all at once.

I put this in #15696 too.

> 32 sage.categories.category_with_axiom.BrokenTestObjects NotImplementedError

Ok, meant to be broken :-)

> 63 sage.categories.category_with_axiom.SmallTestObjects NotImplementedError

Oh, right, this old test class is not used anymore! I removed it.

> 107 sage.categories.category_with_axiom.TestObjectsOverBaseRing.Unital TypeError

Interesting, bug again: they should have been
CategoryWithAxiom_over_base_ring:

```
sage: TestSuite(TestObjectsOverBaseRing(QQ).FiniteDimensional()).run()
Failure in _test_category_with_axiom:
Traceback (most recent call last):
  File "/opt/sage-git/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py", line 282, in run
    test_method(tester = tester)
  File "/opt/sage-git/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py", line 1337, in _test_category_with_axiom
    tester.assertIsInstance(self, CategoryWithAxiom_over_base_ring)
  File "/opt/sage-git/local/lib/python/unittest/case.py", line 969, in assertIsInstance
    self.fail(self._formatMessage(msg, standardMsg))
  File "/opt/sage-git/local/lib/python/unittest/case.py", line 412, in fail
    raise self.failureException(msg)
AssertionError: Category of finite dimensional test objects over base ring over Rational Field is not an instance of <class 'sage.categories.category_with_axiom.CategoryWithAxiom_over_base_ring'>
```

This would have been caught with a TestSuite but there was none. I
just fixed this and pushed.

> 111 <class 'sage.categories.finite_dimensional_modules_with_basis.FiniteDimensionalModulesWithBasis'> yields instance of <class 'sage.categories.category.JoinCategory_with_category'>
> 113 <class 'sage.categories.modules.Modules.FiniteDimensional'> yields instance of <class 'sage.categories.category.JoinCategory_with_category'>

Hmm, same gag as for Modules(QQ) -> VectorSpaces(QQ).

> And please don't forget:
> 
> ```
> sage: type(sage.categories.category_with_axiom.SmallTestObjects.Connected)
> <type 'int'>
> sage: type(sage.categories.category_with_axiom.SmallTestObjects.Commutative)
> <type 'classobj'>
> ```
> which are bugs, too.

Well, they were *voluntary* bugs. I was using those at some point to
test the assertion checks in the code. Anyway, gone with the wind.



About global consistency test w.r.t. consistency tests within the lattice of super categories:

---

Let's not waste more time on this. You are implementing it, you take
the final decision :-) I just meant to make sure you took into account
the advantages and inconvenient of both approaches (including the
deviation from TestSuite, that discovering the categories in the code
is not immediate, that you need an_instance() to work, and that you
can't make use of the tests to know what are the relevant/interesting
input to feed the category constructor).


> > I am certainly not saying it's not doable. But it introduces some
> > complexity which has to be well motivated.

> 
> Are you talking about *mathematical* complexity? Then my answer is that the
> complexity of the underlying local--global problem is there, whether we want
> it or not. And I'd rather have the complexity dealt with by a mathematical
> theory (commutative algebra) than by the inspiration of all future developers
> of categories.

I am speaking of technical complexity, and that for solving what I
believe to be a non issue. As I said, there should be no local-global
problem.



> > So far, I haven't had a single time where I got bothered by that.

> 
> With exception of the `Blahs.Unital.Blue` example, you mean...

Well, it's not like it did strike me from behind. I made up this
example voluntarily to shake the system, see how it would behave when
violating the specifications, and document a potential limitation (I
never had an actual use case); and it failed as expected.

> Then consider the axiom `a*b==a*c => b==c` (I don't know an English word for
> it, thus call it "kürzbar"). There are infinite "kürzbare" rings that aren't
> division ring (e.g., the ring of integers). However, for finite rings, being
> "kürzbar" and "division" are equivalent.
> 
> So, you have a perfectly symmetric formulation:
> `Rings.Finite.Kürzbar==Rings.Finite.Division`. So, how to choose a default?

(from a quick googling, that's the cancellation property:
http://en.wikipedia.org/wiki/Integral_domain).

This is not symmetric, because Rings().Division() is a subcategory of
Rings.Kurzbar(). Hence, the system already knows that
Rings().Finite().Division() is a subcategory of
Rings().Finite().Kürzbar(). The interesting part of the theorem, and
that that we need to teach Sage, is really about the reverse
inclusion: namely that, in the context of Rings.Kurzbar, Finite
implies Division. Hence, this theorem is naturally implemented in
Rings.Kurzbar.Finite_extra_super_categories.

> Next, imagine you have several of such symmetric statements. You *can* do a
> consistent symmetry break---but that's probably equivalent to chosing a
> monomial order in a polynomial ring.

No: the order is given by the subcategory relation, as above.

> >  And
> > second DivisionRings().Finite() would not coincide with
> > Fields().Finite(); and this is the first thing you would test.

> 
> Why not?

The purpose of my comment was to demonstrate that, in the current
implementation, if you make a mistake then this mistake is immediately
caught.

> Doing the above (DivisionRings = Fields.Finite) is natural and easy syntax, and it should be supported.

I agree it is rather natural. I actually tried (hard) to implement
it. But knowingly decided against because not having the tree
structure was making the algorithmic really much more convoluted.

And besides, the current syntax is not unnatural either. Granted, the
name XXX_extra_super_categories is not great, but having to write a
method to model something as important as a theorem is ok to me; if
not just because it gives a natural spot to document and test the
modeling of the theorem. And it's consistent with what we have been
doing everywhere else: the mathematical facts which relate the
category together are implemented in the super_categories methods (and
their variants like extra_super_categories).

> > No I did not do wrong. It does demonstrates *on
> > purpose* a *missing feature*: namely that you currently can't use the
> > Blue_extra_super_categories mechanism in the category where the Blue
> > axiom is defined.

> 
> You talk about an implementation detail (`Blue_extra_super_categories`). I am
> talking about the fact that in this example (made up) mathematical axioms do not commute.

Well, yes, the specifications are voluntarily violated by this example
and the infrastructure gives back wrong results (in the form of non
commuting axioms), which is the whole point of the example. Call it
whatever you like, but the infrastructure itself is behaving properly
here: garbage in, garbage out.

I just added the following to the documentation of Blue_extra_super_categories:

```
        .. TODO::

            Improve the infrastructure to detect and report this
            violation of the specifications, if this is
            easy. Otherwise, it's not so bad: when defining an axiom A
            in a category ``Cs`` the first thing one is supposed to
            doctest is that ``Cs().A()`` works. So the problem should
            not go unnoticed.
```

Cheers,
                              Nicolas



---

archive/issue_comments_109226.json:
```json
{
    "body": "<a id='comment:439'></a>\nReplying to [SimonKing](#comment%3A435):\n> Well, in my early Sage days I occasionally complained that the source code of\n> category stuff can hardly be found (thus, I improved `sage.misc.sageinspect`) and that\n> the category framework is responsible for slowing things down (thus, I made\n> some contributions in that regard).\n\nThat's certainly right, and I am soo glad that you believed in the\ndesign and contributed so much making it not only a reality but a\nviable reality!\n\n> But I did not raise the very argument you are mentioning.\n> So, I am clearly entitled to consider over-design to solve\n> far-fetched scalability issues `;-)`.\n\n:-)\n\nIf this goes beyond \"considering\" be prepared to defend it\nthough. Besides we have a limited work power and have lots of concrete\nscalability issues (e.g. around morphisms) that we have to work on.\n\n> I am not saying that it would *necessarily* fail. However, a local test\n> *may* fail. And rather than repeating the same local test over and over in the `TestSuite` of any category, I'd like to have *one* test\n> (say, a doctest of `sage.categories.categories_with_axiom`) that takes into\n> account the whole digraph and is thus reliable.\n\nOh, I forgot on point in my other message. Promised I am not\ncommenting anymore on that after. An advantage of a local test is that\na category writer will typically run local TestSuite's immediately and\nglobal tests only from time to time.\n\n> Partially. A concistency checker is something for here. A database-metaclass\n> turning the checker into a productive tool to simplify the implementation of\n> new categories-with-axiom is for later.\n\nOk. I am yet to be convinced about the very relevance of the checker\n(since I believe there is no local/global consistency\nrequired). However, as a side effect, by working on it you revealed\nunrelated little bugs. Besides it's a small project and you are the\none spending time on it. So if this makes you more comfortable, go\nahead.\n\nCheers,\n                  Nicolas",
    "created_at": "2014-01-20T10:16:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109226",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:439'></a>
Replying to [SimonKing](#comment%3A435):
> Well, in my early Sage days I occasionally complained that the source code of
> category stuff can hardly be found (thus, I improved `sage.misc.sageinspect`) and that
> the category framework is responsible for slowing things down (thus, I made
> some contributions in that regard).

That's certainly right, and I am soo glad that you believed in the
design and contributed so much making it not only a reality but a
viable reality!

> But I did not raise the very argument you are mentioning.
> So, I am clearly entitled to consider over-design to solve
> far-fetched scalability issues `;-)`.

:-)

If this goes beyond "considering" be prepared to defend it
though. Besides we have a limited work power and have lots of concrete
scalability issues (e.g. around morphisms) that we have to work on.

> I am not saying that it would *necessarily* fail. However, a local test
> *may* fail. And rather than repeating the same local test over and over in the `TestSuite` of any category, I'd like to have *one* test
> (say, a doctest of `sage.categories.categories_with_axiom`) that takes into
> account the whole digraph and is thus reliable.

Oh, I forgot on point in my other message. Promised I am not
commenting anymore on that after. An advantage of a local test is that
a category writer will typically run local TestSuite's immediately and
global tests only from time to time.

> Partially. A concistency checker is something for here. A database-metaclass
> turning the checker into a productive tool to simplify the implementation of
> new categories-with-axiom is for later.

Ok. I am yet to be convinced about the very relevance of the checker
(since I believe there is no local/global consistency
required). However, as a side effect, by working on it you revealed
unrelated little bugs. Besides it's a small project and you are the
one spending time on it. So if this makes you more comfortable, go
ahead.

Cheers,
                  Nicolas



---

archive/issue_comments_109227.json:
```json
{
    "body": "<a id='comment:440'></a>\nReplying to [vbraun](#comment%3A426):\n> I also think that the code on this ticket suffers from a lot of abuse of lazy imports. They are a useful tool, but they don't absolve you from thinking about import order of modules.\n\nQuite on the contrary, the code is being thoughtfully specific about\nimport order. It's being explicit that, e.g., the Magmas category can\nbe imported and is fully functional without importing\nMagmas.Associative (i.e. Semigroups). On the other hand, importing\nSemigroups really requires importing Magmas before hand.\n\n> If you do, then you'll run into precisely the kind of hard-to-debug errors that we found. In particular, lazy imports that you have to resolve on startup are IMHO a sure sign of code smell.\n\nOh yes, it smells! But not for the reason you are pointing to. What's\nbad is that the corresponding categories are constructed on startup;\nand those are constructed because elsewhere in the Sage code some\nparents are constructed on startup.\n\nAnd I precisely **want** to leave those lazy imports in the code so that\nit continues to smell and entices people to reduce the number of\nparents (and therefore categories) constructed on startup.\n\nEach \"at_startup=True\" that will be removed will be a measure of progress.\n\n> You are deliberately omitting the other half of the story: If you have two unrelated classes `C` and `D` then `C.a` and `D.a` are unrelated in Python. And you are breaking that.\n\nNo, I am not!\n\nAh ah, but now maybe I see the source of the confusion. In order to\nmake sure that confusion is cleared, let me be very pedestrian, at the\nrisk of being pedantic (I apologize in advance if I am).\n\nMathematically speaking, you agree that an axiom *is* naturally tied\nto a most basic category, right? That which provides the language\nnecessary to express the semantic of the axiom.\n\nExpressing this tie in the code is very relevant: it makes the\ndeveloper/reader think about the semantic of the axiom and what\nstructure it is about. And it specifies the context in which the axiom\nis defined for (namely all subcategories).\n\nI believe, from experience, that the category is the right place to\nexpress this tie: in particular because looking at the code of the\ncategory exposes what its structure gives as new axioms and\nconstructions.\n\nWith that in mind, I have introduced the following definition in the\ndocumentation: a category *defines* an axiom if it's the most basic\ncategory where the axiom makes sense. This is where the axiom and its\nsemantic should be specified. A category *implements* an axiom if it\nprovides a category with axiom that gives additional code for its\nobjects satisfying the axiom. Of course, a category implementing an\naxiom should be a subcategory of that defining that axiom.\n\nThis is in exact parallel to classes defining (the semantic of) a\nmethod, respectively implementing a method. Attaching a semantic to a\nname in a class/category fixes the semantic of that name for every\nsubclass/subcategory. And it has the exact same name-clash\nlimitations. Two independent categories can very well *define* axioms\nwith the same name but different semantics. But there should be no\naxiom with that name in their super categories (otherwise the semantic\nof that name would already be fixed). And there should be no common\nsubcategory.\n\n\nIn practice in Sage, the category that actually defines an axiom might\noccasionally be a subcategory of the (mathematically speaking) most\nbasic category `C`. This can be typically because `C` is not yet\nmodeled, or for legacy reasons. Or possibly because one later\ndiscovers/wants to implement a better formulation of the semantic of\nthe axiom that requires less structure to be expressed. Hence the\npotential for later having to move up the definition of an\naxiom. That's just following a usual move-up-the class hierarchy\nrefactoring pattern.\n\n\nOk, off for lunch!\n\nCheers,\n                            Nicolas",
    "created_at": "2014-01-20T11:19:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109227",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:440'></a>
Replying to [vbraun](#comment%3A426):
> I also think that the code on this ticket suffers from a lot of abuse of lazy imports. They are a useful tool, but they don't absolve you from thinking about import order of modules.

Quite on the contrary, the code is being thoughtfully specific about
import order. It's being explicit that, e.g., the Magmas category can
be imported and is fully functional without importing
Magmas.Associative (i.e. Semigroups). On the other hand, importing
Semigroups really requires importing Magmas before hand.

> If you do, then you'll run into precisely the kind of hard-to-debug errors that we found. In particular, lazy imports that you have to resolve on startup are IMHO a sure sign of code smell.

Oh yes, it smells! But not for the reason you are pointing to. What's
bad is that the corresponding categories are constructed on startup;
and those are constructed because elsewhere in the Sage code some
parents are constructed on startup.

And I precisely **want** to leave those lazy imports in the code so that
it continues to smell and entices people to reduce the number of
parents (and therefore categories) constructed on startup.

Each "at_startup=True" that will be removed will be a measure of progress.

> You are deliberately omitting the other half of the story: If you have two unrelated classes `C` and `D` then `C.a` and `D.a` are unrelated in Python. And you are breaking that.

No, I am not!

Ah ah, but now maybe I see the source of the confusion. In order to
make sure that confusion is cleared, let me be very pedestrian, at the
risk of being pedantic (I apologize in advance if I am).

Mathematically speaking, you agree that an axiom *is* naturally tied
to a most basic category, right? That which provides the language
necessary to express the semantic of the axiom.

Expressing this tie in the code is very relevant: it makes the
developer/reader think about the semantic of the axiom and what
structure it is about. And it specifies the context in which the axiom
is defined for (namely all subcategories).

I believe, from experience, that the category is the right place to
express this tie: in particular because looking at the code of the
category exposes what its structure gives as new axioms and
constructions.

With that in mind, I have introduced the following definition in the
documentation: a category *defines* an axiom if it's the most basic
category where the axiom makes sense. This is where the axiom and its
semantic should be specified. A category *implements* an axiom if it
provides a category with axiom that gives additional code for its
objects satisfying the axiom. Of course, a category implementing an
axiom should be a subcategory of that defining that axiom.

This is in exact parallel to classes defining (the semantic of) a
method, respectively implementing a method. Attaching a semantic to a
name in a class/category fixes the semantic of that name for every
subclass/subcategory. And it has the exact same name-clash
limitations. Two independent categories can very well *define* axioms
with the same name but different semantics. But there should be no
axiom with that name in their super categories (otherwise the semantic
of that name would already be fixed). And there should be no common
subcategory.


In practice in Sage, the category that actually defines an axiom might
occasionally be a subcategory of the (mathematically speaking) most
basic category `C`. This can be typically because `C` is not yet
modeled, or for legacy reasons. Or possibly because one later
discovers/wants to implement a better formulation of the semantic of
the axiom that requires less structure to be expressed. Hence the
potential for later having to move up the definition of an
axiom. That's just following a usual move-up-the class hierarchy
refactoring pattern.


Ok, off for lunch!

Cheers,
                            Nicolas



---

archive/issue_comments_109228.json:
```json
{
    "body": "<a id='comment:441'></a>\nReplying to [nthiery](#comment%3A440):\n> Replying to [vbraun](#comment%3A426):\n> > I also think that the code on this ticket suffers from a lot of abuse of lazy imports. They are a useful tool, but they don't absolve you from thinking about import order of modules.\n\n> \n> Quite on the contrary, the code is being thoughtfully specific about\n> import order. It's being explicit that, e.g., the Magmas category can\n> be imported and is fully functional without importing\n> Magmas.Associative (i.e. Semigroups). On the other hand, importing\n> Semigroups really requires importing Magmas before hand.\n\n+1 (see my reply to Volker in [comment:428](#comment%3A428).\n\n> > You are deliberately omitting the other half of the story: If you have two unrelated classes `C` and `D` then `C.a` and `D.a` are unrelated in Python. And you are breaking that.\n\n> \n> No, I am not!\n\nLet's see if you give the same arguments that I gave in\ncomment:428... readingreadingreadin --- Yes, you do, so +1 `:-)`\n\n> Ok, off for lunch!\n\nBon appetit !",
    "created_at": "2014-01-20T12:17:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109228",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:441'></a>
Replying to [nthiery](#comment%3A440):
> Replying to [vbraun](#comment%3A426):
> > I also think that the code on this ticket suffers from a lot of abuse of lazy imports. They are a useful tool, but they don't absolve you from thinking about import order of modules.

> 
> Quite on the contrary, the code is being thoughtfully specific about
> import order. It's being explicit that, e.g., the Magmas category can
> be imported and is fully functional without importing
> Magmas.Associative (i.e. Semigroups). On the other hand, importing
> Semigroups really requires importing Magmas before hand.

+1 (see my reply to Volker in [comment:428](#comment%3A428).

> > You are deliberately omitting the other half of the story: If you have two unrelated classes `C` and `D` then `C.a` and `D.a` are unrelated in Python. And you are breaking that.

> 
> No, I am not!

Let's see if you give the same arguments that I gave in
comment:428... readingreadingreadin --- Yes, you do, so +1 `:-)`

> Ok, off for lunch!

Bon appetit !



---

archive/issue_comments_109229.json:
```json
{
    "body": "<a id='comment:442'></a>\n****Replying to [SimonKing](#comment%3A441):\n> +1 (see my reply to Volker in [comment:428](#comment%3A428).\n> comment:428... readingreadingreadin --- Yes, you do, so +1 `:-)`\n\nYes, sorry for the redundancy; I had formulated the answers in my head\nyesterday, and since the wording was slightly different, I decided it\nwould not hurt as a complement.",
    "created_at": "2014-01-20T13:09:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109229",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:442'></a>
****Replying to [SimonKing](#comment%3A441):
> +1 (see my reply to Volker in [comment:428](#comment%3A428).
> comment:428... readingreadingreadin --- Yes, you do, so +1 `:-)`

Yes, sorry for the redundancy; I had formulated the answers in my head
yesterday, and since the wording was slightly different, I decided it
would not hurt as a complement.



---

archive/issue_comments_109230.json:
```json
{
    "body": "<a id='comment:3'></a>\nDear Nicolas,\n\nit seems to me that I still don't see exactly where the theoretical model ends\nand where the implementation details start. Also, I am not sure if we talk\nabout the same when we both say \"consistency\". Therefore I try to formulate\nwhat I think you claim, asking you to correct where I am wrong, and also I\ngive you an example, asking you to explain to me how to implement it in your\nmodel and how your model detects the inconsistency in my example.\n\nFirst, a pledge: Could you please push your latest commits providing the\nlatest documentation?\n\nWe agree that we have an acyclic digraph, the nodes being categories, i.e.,\ninstances of category classes, the arrows being labelled with axioms that are\nbeing applied to the start point of the arrow and result in the end point of\nthe arrow.\n\nWe agree that we should single out a spanning tree. It is useful, e.g., for\ngetting a proper inheritance of Python classes (think of parent and element\nclasses).\n\nQuestions:\n\n- Do you claim that the choice of a spanning tree doesn't matter at all? Would any spanning tree work?\n\n- Do you claim that all theorems about categorial identities are and will in\n  future be *asymmetric*, so that they give a natural choice of a spanning\n  tree?\n\nNow let's assume we have chosen a spanning tree, and see how that choice can be/is implemented.\n\nFor specifying a spanning tree (or rather: forest) in an acyclic digraph, it\nis sufficient to choose one incoming arrow, for any node that has incoming\narrows. Agreed? This is done by the explicit or implicit definition of\n`C._base_category_class_and_axiom`.\n\nIn addition to that (and this is where I think the implementation deviates from the theoretical model), you say that at each node one should additionally mark the outgoing\narrows that belong to the spanning tree: The outgoing arrows belonging to the\nspanning tree result in class attributes, the other outgoing arrows result in\n(cached) subcategory methods. Is this a correct description? And somehow there\nare these `<Axiom name>_extra_super_categories` methods, which relate\nwith the non-spanning-tree-outgoing-arrows as well, right?\n\nThis gives rise to a couple of questions:\n\n- Of course, if you do specify the spanning tree both on incoming and outgoing\n  arrows, then this specification should be consistent. Is this what you mean\n  when you talk about a \"consistent choice\"? Then I agree that it is a purely\n  local problem. I don't think that one needs to test it in the `TestSuite`,\n  because you already test it in `__classget__`.\n\n- *Why* do you think that one needs to specify the spanning tree twice\n  (incoming and outgoing)?\n\nRelated with the second question: I know that in your current implementation,\none can not both define `DivisionRings.Finite = FiniteFields` and\n`Fields.Finite = FiniteFields`---but it seems to me that this is *only*\nbecause you chose to give the same data twice. So, can you explain '''in the\ntheoretical model''' why it is illegal to assign `DivisionRings.Finite = FiniteFields` and why it is needed to use all this\n`Finite_extra_supercategories` and cached subcategory methods magic?\n\nOr is it just because of the implementation? In this case, please elaborate (or\ngive a pointer to a place where you did elaborate already) why providing the\nsame data twice is important and an implementation is hardly doable without the duplication of information.\n\nNow I come to an example.\n\nAssume we have a category class `As`, and axioms `B, C, D, E, F` that can all\nbe called on `As()`. In principle, any subset of the axioms can be\nsuccessively applied to `As()` in any order.\n\nIf I was to implement it, I would provide class attributes `As.B, As.C, ...,\nAs.F` whose values are category-classes-with-axiom. Each of these classes has\n`_base_category_class_and_axiom = (As, 'B'/'C'/.../'F')`. Do you agree that\nthis is what one should do?\n\nNext, there are two axioms that need to hold for our category-with-axiom\nframework: Applying axioms is commutative, and applying axioms is\nidempotent. Hence, we need `As().B().C()==As().C().B()`. In other words,\n`As().B().C().__class__.__base__` has two incoming arrows, and we need to pick\none of them (say, the one labelled \"C\") in order to specify a tree. In\naddition to that, you say that one has to do something special with\n`As().C().B`: It can not be a class attribute but should be a subcategory method\nor so (I am still not buying why this is needed).\n\nSo, where are we? We have some categories, that are essentially labelled by\nsubsets (not ordered!) of axioms \"B\",...,\"F\", and by specifying a spanning\ntree we obtain labels that are *ordered* subsets of axioms \"B\",...,\"F\".\n\nNext, William Stein proves that `As().B().C()==As().E().F()`. Now, we can of\ncourse change the code so that `As().B().C` becomes a subcategory method\nreturning `As().E().F()`, and the old class `As.B.C` is removed.\n\nBut the point I want to make: This is not enough. We still can apply axioms\n\"B\", \"C\"  and \"D\" to `As().E().F()`. But we should have\n\n```\nAs().E().F().D().B().C()\n     == As().B().C().E().F().D()  # commutativity\n     == As().E().F().E().F().D()  # William's theorem\n     == As().E().E().F().F().D()  # commutativity\n     == As().E().F().D()          # idempotency\n     == As().D().E().F()          # I guess you are likely to choose the\n                                  # spanning tree by applying axioms in\n                                  # lexicographic order.\n```\nSo, a fix is needed! This is what *I* mean when I speak about consistency,\nand this is what I think is a difficult local--global problem.\n\nQuestions:\n\n1. Assume that a developer would simply make `As().B().C()` return\n   `As().E().F()`. This would be a bug, by the above reasoning. Would the\n   category-with-axiom framework detect this bug and raise an error on the\n   attempt to create `As().E().F().D().B().C()`? Can you demonstrate it in\n   the above example, and can you prove that it will always detect the bug?\n\n2. What does a developer need to do to fix the code?\n\n3. How can a developer determine what needs to be done to fix the code? In\n   the example above, I demonstrated one case that needed to be fixed. Do you\n   really require that the developer draws the whole category digraph on a\n   sheet of paper and traces (similar to the above reasoning) what has to be\n   done with the chosen spanning tree after merging two of its nodes?\n\n4. Do you provide any tool that tells the developer what needs to be done?\n\nFor the record: I think commutative algebra can be used to detect that there\nis a bug and could make a suggestion on how to fix the bug. Ceterum censeo: In\nthe long run (on a different ticket) a database of category classes can use\ncommutative algebra to deal with the above local--global problem so that\ndevelopers don't need to think about it when coding. The axioms shouldn't be\nprovided by coding nested classes or adding direct assignment of class\nattributes into the code, since this would be the job of the database.",
    "created_at": "2014-01-20T14:11:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109230",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Dear Nicolas,

it seems to me that I still don't see exactly where the theoretical model ends
and where the implementation details start. Also, I am not sure if we talk
about the same when we both say "consistency". Therefore I try to formulate
what I think you claim, asking you to correct where I am wrong, and also I
give you an example, asking you to explain to me how to implement it in your
model and how your model detects the inconsistency in my example.

First, a pledge: Could you please push your latest commits providing the
latest documentation?

We agree that we have an acyclic digraph, the nodes being categories, i.e.,
instances of category classes, the arrows being labelled with axioms that are
being applied to the start point of the arrow and result in the end point of
the arrow.

We agree that we should single out a spanning tree. It is useful, e.g., for
getting a proper inheritance of Python classes (think of parent and element
classes).

Questions:

- Do you claim that the choice of a spanning tree doesn't matter at all? Would any spanning tree work?

- Do you claim that all theorems about categorial identities are and will in
  future be *asymmetric*, so that they give a natural choice of a spanning
  tree?

Now let's assume we have chosen a spanning tree, and see how that choice can be/is implemented.

For specifying a spanning tree (or rather: forest) in an acyclic digraph, it
is sufficient to choose one incoming arrow, for any node that has incoming
arrows. Agreed? This is done by the explicit or implicit definition of
`C._base_category_class_and_axiom`.

In addition to that (and this is where I think the implementation deviates from the theoretical model), you say that at each node one should additionally mark the outgoing
arrows that belong to the spanning tree: The outgoing arrows belonging to the
spanning tree result in class attributes, the other outgoing arrows result in
(cached) subcategory methods. Is this a correct description? And somehow there
are these `<Axiom name>_extra_super_categories` methods, which relate
with the non-spanning-tree-outgoing-arrows as well, right?

This gives rise to a couple of questions:

- Of course, if you do specify the spanning tree both on incoming and outgoing
  arrows, then this specification should be consistent. Is this what you mean
  when you talk about a "consistent choice"? Then I agree that it is a purely
  local problem. I don't think that one needs to test it in the `TestSuite`,
  because you already test it in `__classget__`.

- *Why* do you think that one needs to specify the spanning tree twice
  (incoming and outgoing)?

Related with the second question: I know that in your current implementation,
one can not both define `DivisionRings.Finite = FiniteFields` and
`Fields.Finite = FiniteFields`---but it seems to me that this is *only*
because you chose to give the same data twice. So, can you explain '''in the
theoretical model''' why it is illegal to assign `DivisionRings.Finite = FiniteFields` and why it is needed to use all this
`Finite_extra_supercategories` and cached subcategory methods magic?

Or is it just because of the implementation? In this case, please elaborate (or
give a pointer to a place where you did elaborate already) why providing the
same data twice is important and an implementation is hardly doable without the duplication of information.

Now I come to an example.

Assume we have a category class `As`, and axioms `B, C, D, E, F` that can all
be called on `As()`. In principle, any subset of the axioms can be
successively applied to `As()` in any order.

If I was to implement it, I would provide class attributes `As.B, As.C, ...,
As.F` whose values are category-classes-with-axiom. Each of these classes has
`_base_category_class_and_axiom = (As, 'B'/'C'/.../'F')`. Do you agree that
this is what one should do?

Next, there are two axioms that need to hold for our category-with-axiom
framework: Applying axioms is commutative, and applying axioms is
idempotent. Hence, we need `As().B().C()==As().C().B()`. In other words,
`As().B().C().__class__.__base__` has two incoming arrows, and we need to pick
one of them (say, the one labelled "C") in order to specify a tree. In
addition to that, you say that one has to do something special with
`As().C().B`: It can not be a class attribute but should be a subcategory method
or so (I am still not buying why this is needed).

So, where are we? We have some categories, that are essentially labelled by
subsets (not ordered!) of axioms "B",...,"F", and by specifying a spanning
tree we obtain labels that are *ordered* subsets of axioms "B",...,"F".

Next, William Stein proves that `As().B().C()==As().E().F()`. Now, we can of
course change the code so that `As().B().C` becomes a subcategory method
returning `As().E().F()`, and the old class `As.B.C` is removed.

But the point I want to make: This is not enough. We still can apply axioms
"B", "C"  and "D" to `As().E().F()`. But we should have

```
As().E().F().D().B().C()
     == As().B().C().E().F().D()  # commutativity
     == As().E().F().E().F().D()  # William's theorem
     == As().E().E().F().F().D()  # commutativity
     == As().E().F().D()          # idempotency
     == As().D().E().F()          # I guess you are likely to choose the
                                  # spanning tree by applying axioms in
                                  # lexicographic order.
```
So, a fix is needed! This is what *I* mean when I speak about consistency,
and this is what I think is a difficult local--global problem.

Questions:

1. Assume that a developer would simply make `As().B().C()` return
   `As().E().F()`. This would be a bug, by the above reasoning. Would the
   category-with-axiom framework detect this bug and raise an error on the
   attempt to create `As().E().F().D().B().C()`? Can you demonstrate it in
   the above example, and can you prove that it will always detect the bug?

2. What does a developer need to do to fix the code?

3. How can a developer determine what needs to be done to fix the code? In
   the example above, I demonstrated one case that needed to be fixed. Do you
   really require that the developer draws the whole category digraph on a
   sheet of paper and traces (similar to the above reasoning) what has to be
   done with the chosen spanning tree after merging two of its nodes?

4. Do you provide any tool that tells the developer what needs to be done?

For the record: I think commutative algebra can be used to detect that there
is a bug and could make a suggestion on how to fix the bug. Ceterum censeo: In
the long run (on a different ticket) a database of category classes can use
commutative algebra to deal with the above local--global problem so that
developers don't need to think about it when coding. The axioms shouldn't be
provided by coding nested classes or adding direct assignment of class
attributes into the code, since this would be the job of the database.



---

archive/issue_comments_109231.json:
```json
{
    "body": "<a id='comment:4'></a>\nFirst, I just want to state my agreement with others' opinions (e.g. Nils's [comment:326](#comment%3A326), Volker's [comment:327](#comment%3A327)) that it would be extremely desirable to avoid using name parsing to deduce mathematical properties from Python names.\n\nSecond, I think the new method `CartesianProduct.summands()` is inaptly named.  The things of which a product is composed (also in the categorical sense, in my experience) are normally called *factors*!  Recall that in a category where both sums and product exist, they are usually not the same.  For example, in the category of sets, the sum is the disjoint union, and in the category of rings, the sum is the tensor product.  It makes sense that the components of which a product is composed should be called *factors* and the components of which a sum is composed should be called *summands*.",
    "created_at": "2014-01-20T14:23:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109231",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:4'></a>
First, I just want to state my agreement with others' opinions (e.g. Nils's [comment:326](#comment%3A326), Volker's [comment:327](#comment%3A327)) that it would be extremely desirable to avoid using name parsing to deduce mathematical properties from Python names.

Second, I think the new method `CartesianProduct.summands()` is inaptly named.  The things of which a product is composed (also in the categorical sense, in my experience) are normally called *factors*!  Recall that in a category where both sums and product exist, they are usually not the same.  For example, in the category of sets, the sum is the disjoint union, and in the category of rings, the sum is the tensor product.  It makes sense that the components of which a product is composed should be called *factors* and the components of which a sum is composed should be called *summands*.



---

archive/issue_comments_109232.json:
```json
{
    "body": "<a id='comment:445'></a>\nReplying to [pbruin](#comment%3A444):\n> Second, I think the new method `CartesianProduct.summands()` is inaptly named.  The things of which a product is composed (also in the categorical sense, in my experience) are normally called *factors*!  Recall that in a category where both sums and product exist, they are usually not the same.  For example, in the category of sets, the sum is the disjoint union, and in the category of rings, the sum is the tensor product.  It makes sense that the components of which a product is composed should be called *factors* and the components of which a sum is composed should be called *summands*.\n\nGranted, it's not perfect, but it's consistent with the other\npreexisting ``summand_`` methods in the context of cartesian products.\nI'd be happy to change it, but then we should change all of them at\nonce for consistency. IMHO This would be best handled in a followup\nticket since this one is already way too big. I am happy adding a\nwarning about the probable name change in the documentation though.\n\nAlso, I would like something different from ``factors'', since we will\nalso use it in the context of monoids (like for making cartesian\nproducts thereof), and `factors` would be ambiguous. Any suggestions?\n\nCheers,\n                                  Nicolas",
    "created_at": "2014-01-20T14:49:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109232",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:445'></a>
Replying to [pbruin](#comment%3A444):
> Second, I think the new method `CartesianProduct.summands()` is inaptly named.  The things of which a product is composed (also in the categorical sense, in my experience) are normally called *factors*!  Recall that in a category where both sums and product exist, they are usually not the same.  For example, in the category of sets, the sum is the disjoint union, and in the category of rings, the sum is the tensor product.  It makes sense that the components of which a product is composed should be called *factors* and the components of which a sum is composed should be called *summands*.

Granted, it's not perfect, but it's consistent with the other
preexisting ``summand_`` methods in the context of cartesian products.
I'd be happy to change it, but then we should change all of them at
once for consistency. IMHO This would be best handled in a followup
ticket since this one is already way too big. I am happy adding a
warning about the probable name change in the documentation though.

Also, I would like something different from ``factors'', since we will
also use it in the context of monoids (like for making cartesian
products thereof), and `factors` would be ambiguous. Any suggestions?

Cheers,
                                  Nicolas



---

archive/issue_comments_109233.json:
```json
{
    "body": "<a id='comment:6'></a>\n`cartesian_factors`?",
    "created_at": "2014-01-20T14:52:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109233",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
`cartesian_factors`?



---

archive/issue_comments_109234.json:
```json
{
    "body": "<a id='comment:447'></a>\nReplying to [SimonKing](#comment%3A443):\n> it seems to me that I still don't see exactly where the theoretical model ends\n> and where the implementation details start. Also, I am not sure if we talk\n> about the same when we both say \"consistency\". Therefore I try to formulate\n> what I think you claim, asking you to correct where I am wrong, and also I\n> give you an example, asking you to explain to me how to implement it in your\n> model and how your model detects the inconsistency in my example.\n\nGreat.\n\n> First, a pledge: Could you please push your latest commits providing the\n> latest documentation?\n\nIt's done (in my branch u/nthiery/ticket/10963). Ah, I had not\nrecompiled the doc recently on sagemath.org; done.\n\n> We agree that we should single out a spanning tree. It is useful, e.g., for\n> getting a proper inheritance of Python classes (think of parent and element\n> classes).\n\nMore importantly, it's useful for the algorithmic.\n\n> Questions:\n> \n> - Do you claim that the choice of a spanning tree doesn't matter at all? Would any spanning tree work?\n\nYes. Up to one extra constraint: if Cs().A() coincides with Ds().A(),\nwith Ds a subcategory of Cs, then the category with axiom should be in\nDs.A.\n\n> - Do you claim that all theorems about categorial identities are and will in\n>   future be *asymmetric*, so that they give a natural choice of a spanning\n>   tree?\n\nYes. Well, at least, all the use case I have met or foreseen so far\nare of this form.\n\n> In addition to that (and this is where I think the implementation deviates from the theoretical model), you say that at each node one should additionally mark the outgoing\n> arrows that belong to the spanning tree: The outgoing arrows belonging to the\n> spanning tree result in class attributes, the other outgoing arrows result in\n> (cached) subcategory methods. Is this a correct description?\n\nLet me refine it a bit: if Cs defines an axiom A, and Ds is a\nsubcategory, then Ds().A always results in the method\nCs.SubcategoryMethods.A whose job is to add the axiom. And if Ds\nfurther implements A in Ds.A, then the call Ds().A() will use that\nclass in the process.\n\n> And somehow there\n> are these `<Axiom name>_extra_super_categories` methods, which relate\n> with the non-spanning-tree-outgoing-arrows as well, right?\n\nIn general, the extra_super_categories method can be used to provide\nadditional inheritance information that can't be derived automatically\nby the system, e.g. is not a direct consequence of the commutativity\nof axioms.\n\n> This gives rise to a couple of questions:\n> \n> - Of course, if you do specify the spanning tree both on incoming and outgoing\n>   arrows, then this specification should be consistent. Is this what you mean\n>   when you talk about a \"consistent choice\"? Then I agree that it is a purely\n>   local problem. I don't think that one needs to test it in the `TestSuite`,\n>   because you already test it in `__classget__`.\n\nBy consistent I meant that the computed results are what we expect\nmathematically (including commutativity of axioms, ...).\n\n> - *Why* do you think that one needs to specify the spanning tree twice\n>   (incoming and outgoing)?\n\nAt the level of the classes and the code, the only algorithmically\nrelevant link is that of the form Sets.Finite = FiniteSets. The\nreverse link is only there to allow for calling FiniteSets() as\nsyntactic sugar for Sets().Finite(). Or Fields() for\nDivisionRings().Commutative().\n\nOf course, at the level of the categories, Sets().Finite() needs to\nhave a link to Sets() for the algorithmic to work, but that link can\nbe setup later at initialization.\n\n> Related with the second question: I know that in your current implementation,\n> one can not both define `DivisionRings.Finite = FiniteFields` and\n> `Fields.Finite = FiniteFields`---but it seems to me that this is *only*\n> because you chose to give the same data twice. So, can you explain '''in the\n> theoretical model''' why it is illegal to assign `DivisionRings.Finite = FiniteFields` and why it is needed to use all this\n> `Finite_extra_supercategories` and cached subcategory methods magic?\n> Or is it just because of the implementation? In this case, please elaborate (or\n> give a pointer to a place where you did elaborate already) why providing the\n> same data twice is important and an implementation is hardly doable without the duplication of information.\n\nFor the subcategory method magic, the answer is easy: If Cs defines\nthe axiom A, then I want Ds().A() to work for every subcategory Ds,\nwhether Ds implements A or not. Putting A in Cs.SubcategoryMethods\nmodels naturally that Cs defines the axiom for every subcategories.\n\nAbout not allowing DivisionRings.Finite=Fields.Finite, this is about\nthe algorithm (so not the model) which is highly recursive; without\nthat assumption, one needs to detect the situation to avoid running in\na recursion loop, and the detection is tricky. I will elaborate on it\nin the documentation and let you know when done.\n\n> Now I come to an example.\n\nGreat.\n\nI am going to play with it now and report. Did you have any specific\nideas on which subsets of axioms are actually implemented in your\nexample? Otherwise, I'll pick a couple typical situations.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-01-20T15:55:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109234",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:447'></a>
Replying to [SimonKing](#comment%3A443):
> it seems to me that I still don't see exactly where the theoretical model ends
> and where the implementation details start. Also, I am not sure if we talk
> about the same when we both say "consistency". Therefore I try to formulate
> what I think you claim, asking you to correct where I am wrong, and also I
> give you an example, asking you to explain to me how to implement it in your
> model and how your model detects the inconsistency in my example.

Great.

> First, a pledge: Could you please push your latest commits providing the
> latest documentation?

It's done (in my branch u/nthiery/ticket/10963). Ah, I had not
recompiled the doc recently on sagemath.org; done.

> We agree that we should single out a spanning tree. It is useful, e.g., for
> getting a proper inheritance of Python classes (think of parent and element
> classes).

More importantly, it's useful for the algorithmic.

> Questions:
> 
> - Do you claim that the choice of a spanning tree doesn't matter at all? Would any spanning tree work?

Yes. Up to one extra constraint: if Cs().A() coincides with Ds().A(),
with Ds a subcategory of Cs, then the category with axiom should be in
Ds.A.

> - Do you claim that all theorems about categorial identities are and will in
>   future be *asymmetric*, so that they give a natural choice of a spanning
>   tree?

Yes. Well, at least, all the use case I have met or foreseen so far
are of this form.

> In addition to that (and this is where I think the implementation deviates from the theoretical model), you say that at each node one should additionally mark the outgoing
> arrows that belong to the spanning tree: The outgoing arrows belonging to the
> spanning tree result in class attributes, the other outgoing arrows result in
> (cached) subcategory methods. Is this a correct description?

Let me refine it a bit: if Cs defines an axiom A, and Ds is a
subcategory, then Ds().A always results in the method
Cs.SubcategoryMethods.A whose job is to add the axiom. And if Ds
further implements A in Ds.A, then the call Ds().A() will use that
class in the process.

> And somehow there
> are these `<Axiom name>_extra_super_categories` methods, which relate
> with the non-spanning-tree-outgoing-arrows as well, right?

In general, the extra_super_categories method can be used to provide
additional inheritance information that can't be derived automatically
by the system, e.g. is not a direct consequence of the commutativity
of axioms.

> This gives rise to a couple of questions:
> 
> - Of course, if you do specify the spanning tree both on incoming and outgoing
>   arrows, then this specification should be consistent. Is this what you mean
>   when you talk about a "consistent choice"? Then I agree that it is a purely
>   local problem. I don't think that one needs to test it in the `TestSuite`,
>   because you already test it in `__classget__`.

By consistent I meant that the computed results are what we expect
mathematically (including commutativity of axioms, ...).

> - *Why* do you think that one needs to specify the spanning tree twice
>   (incoming and outgoing)?

At the level of the classes and the code, the only algorithmically
relevant link is that of the form Sets.Finite = FiniteSets. The
reverse link is only there to allow for calling FiniteSets() as
syntactic sugar for Sets().Finite(). Or Fields() for
DivisionRings().Commutative().

Of course, at the level of the categories, Sets().Finite() needs to
have a link to Sets() for the algorithmic to work, but that link can
be setup later at initialization.

> Related with the second question: I know that in your current implementation,
> one can not both define `DivisionRings.Finite = FiniteFields` and
> `Fields.Finite = FiniteFields`---but it seems to me that this is *only*
> because you chose to give the same data twice. So, can you explain '''in the
> theoretical model''' why it is illegal to assign `DivisionRings.Finite = FiniteFields` and why it is needed to use all this
> `Finite_extra_supercategories` and cached subcategory methods magic?
> Or is it just because of the implementation? In this case, please elaborate (or
> give a pointer to a place where you did elaborate already) why providing the
> same data twice is important and an implementation is hardly doable without the duplication of information.

For the subcategory method magic, the answer is easy: If Cs defines
the axiom A, then I want Ds().A() to work for every subcategory Ds,
whether Ds implements A or not. Putting A in Cs.SubcategoryMethods
models naturally that Cs defines the axiom for every subcategories.

About not allowing DivisionRings.Finite=Fields.Finite, this is about
the algorithm (so not the model) which is highly recursive; without
that assumption, one needs to detect the situation to avoid running in
a recursion loop, and the detection is tricky. I will elaborate on it
in the documentation and let you know when done.

> Now I come to an example.

Great.

I am going to play with it now and report. Did you have any specific
ideas on which subsets of axioms are actually implemented in your
example? Otherwise, I'll pick a couple typical situations.

Cheers,
                              Nicolas



---

archive/issue_comments_109235.json:
```json
{
    "body": "<a id='comment:448'></a>\nReplying to [nthiery](#comment%3A447):\n> > First, a pledge: Could you please push your latest commits providing the\n> > latest documentation?\n\n> \n> It's done (in my branch u/nthiery/ticket/10963). Ah, I had not\n> recompiled the doc recently on sagemath.org; done.\n\nThis is not the branch associated with this ticket. That's why I couldn't find it.",
    "created_at": "2014-01-20T16:12:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109235",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:448'></a>
Replying to [nthiery](#comment%3A447):
> > First, a pledge: Could you please push your latest commits providing the
> > latest documentation?

> 
> It's done (in my branch u/nthiery/ticket/10963). Ah, I had not
> recompiled the doc recently on sagemath.org; done.

This is not the branch associated with this ticket. That's why I couldn't find it.



---

archive/issue_comments_109236.json:
```json
{
    "body": "<a id='comment:449'></a>\nReplying to [nthiery](#comment%3A440):\n> Oh yes, it smells! But not for the reason you are pointing to. What's\n> bad is that the corresponding categories are constructed on startup;\n\nWell a few categories are always going to be constructed on startup, the majority shouldn't. \n\n> And I precisely **want** to leave those lazy imports in the code\n> Each \"at_startup=True\" that will be removed will be a measure of progress.\n\nI'm sorry, I overlooked the comment in your code that stated that you want to get rid of those imports-on-startup. Oh, no comment? In that case I'm sorry for not having any telepathic abilities to read your mind ;-)\n\n> Mathematically speaking, you agree that an axiom *is* naturally tied\n> to a most basic category, right? That which provides the language\n> necessary to express the semantic of the axiom.\n\nI agree that there is, mathematically speaking, always some join category that would be the most basic. But there is no need to require Sage developers to implement a common supercategory by hand. Of course you can, but the whole point of this ticket is to reduce the number of categories that you must construct by hand.",
    "created_at": "2014-01-20T16:50:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109236",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:449'></a>
Replying to [nthiery](#comment%3A440):
> Oh yes, it smells! But not for the reason you are pointing to. What's
> bad is that the corresponding categories are constructed on startup;

Well a few categories are always going to be constructed on startup, the majority shouldn't. 

> And I precisely **want** to leave those lazy imports in the code
> Each "at_startup=True" that will be removed will be a measure of progress.

I'm sorry, I overlooked the comment in your code that stated that you want to get rid of those imports-on-startup. Oh, no comment? In that case I'm sorry for not having any telepathic abilities to read your mind ;-)

> Mathematically speaking, you agree that an axiom *is* naturally tied
> to a most basic category, right? That which provides the language
> necessary to express the semantic of the axiom.

I agree that there is, mathematically speaking, always some join category that would be the most basic. But there is no need to require Sage developers to implement a common supercategory by hand. Of course you can, but the whole point of this ticket is to reduce the number of categories that you must construct by hand.



---

archive/issue_comments_109237.json:
```json
{
    "body": "<a id='comment:450'></a>\nReplying to [nthiery](#comment%3A445):\n\n> Granted, it's not perfect, but it's consistent with the other\n> preexisting ``summand_`` methods in the context of cartesian products.\n> I'd be happy to change it, but then we should change all of them at\n> once for consistency. IMHO This would be best handled in a followup\n> ticket since this one is already way too big. I am happy adding a\n> warning about the probable name change in the documentation though.\n\nThe existing `summand_*` methods I could find are\n\n```\nCartesianProduct.summand_projection()\nSets.CartesianProducts.ParentMethods.summand_projection()\nSets.CartesianProducts.ElementMethods.summand_projection()\nSets.CartesianProducts.ElementMethods.summand_split()\nCombinatorialFreeModule_CartesianProduct.summand_embedding()\nCombinatorialFreeModule_CartesianProduct.summand_projection()\n```\nMaybe the quickest solution is to insert better-named aliases for these, rename the method `summands()` introduced here, and later deprecate `summand_projection()` and `summand_split()` in a different ticket.\n\nMy first reflex would be to rename `summand_projection()` to `projection()` and `summand_split()` to `tuple()`.  If this is too conflict-prone, maybe using the prefix `cartesian_` suggested by Simon would be a solution?\n\nFor products of modules (the last two methods in the above list), calling the components \"summands\" is OK if and only if there are only finitely many summands/factors; in that case the product and sum coincide, since modules form an additive category.\n\n> Also, I would like something different from ``factors'', since we will\n> also use it in the context of monoids (like for making cartesian\n> products thereof), and `factors` would be ambiguous.\n\nI'm confused; isn't a Cartesian product of monoids just the Cartesian product of the underlying sets, with the obvious monoid structure?  Or do you mean that a generic monoid will have a `factors()` method that does something unrelated?",
    "created_at": "2014-01-20T17:10:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109237",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:450'></a>
Replying to [nthiery](#comment%3A445):

> Granted, it's not perfect, but it's consistent with the other
> preexisting ``summand_`` methods in the context of cartesian products.
> I'd be happy to change it, but then we should change all of them at
> once for consistency. IMHO This would be best handled in a followup
> ticket since this one is already way too big. I am happy adding a
> warning about the probable name change in the documentation though.

The existing `summand_*` methods I could find are

```
CartesianProduct.summand_projection()
Sets.CartesianProducts.ParentMethods.summand_projection()
Sets.CartesianProducts.ElementMethods.summand_projection()
Sets.CartesianProducts.ElementMethods.summand_split()
CombinatorialFreeModule_CartesianProduct.summand_embedding()
CombinatorialFreeModule_CartesianProduct.summand_projection()
```
Maybe the quickest solution is to insert better-named aliases for these, rename the method `summands()` introduced here, and later deprecate `summand_projection()` and `summand_split()` in a different ticket.

My first reflex would be to rename `summand_projection()` to `projection()` and `summand_split()` to `tuple()`.  If this is too conflict-prone, maybe using the prefix `cartesian_` suggested by Simon would be a solution?

For products of modules (the last two methods in the above list), calling the components "summands" is OK if and only if there are only finitely many summands/factors; in that case the product and sum coincide, since modules form an additive category.

> Also, I would like something different from ``factors'', since we will
> also use it in the context of monoids (like for making cartesian
> products thereof), and `factors` would be ambiguous.

I'm confused; isn't a Cartesian product of monoids just the Cartesian product of the underlying sets, with the obvious monoid structure?  Or do you mean that a generic monoid will have a `factors()` method that does something unrelated?



---

archive/issue_comments_109238.json:
```json
{
    "body": "<a id='comment:1'></a>\nI've started a branch that separates the axioms into independent classes at as an alternative. It is posted at #15701 so we can make use of the git/trac integration features.",
    "created_at": "2014-01-21T03:25:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109238",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:1'></a>
I've started a branch that separates the axioms into independent classes at as an alternative. It is posted at #15701 so we can make use of the git/trac integration features.



---

archive/issue_comments_109239.json:
```json
{
    "body": "<a id='comment:2'></a>\nOff-trac, Nicolas has shown me what happens in the example sketched in [comment:443](#comment%3A443). I think what he has shown to me is worth to be put into the docs, and also it indicates that Nicolas' approach is able to deal with non-trivial consequences of \"merging\" axioms. If Nicolas is not faster, I'll comment more on it later.",
    "created_at": "2014-01-21T15:17:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109239",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Off-trac, Nicolas has shown me what happens in the example sketched in [comment:443](#comment%3A443). I think what he has shown to me is worth to be put into the docs, and also it indicates that Nicolas' approach is able to deal with non-trivial consequences of "merging" axioms. If Nicolas is not faster, I'll comment more on it later.



---

archive/issue_comments_109240.json:
```json
{
    "body": "<a id='comment:3'></a>\nHere is the announced example. Since Nicolas did not post here, I do. But it is his example.\n\nRecall: I wanted to start with the category `As()`, with available axioms \"B\",...,\"F\". In the first place, there should be no relations between the axioms. Moreover, I somehow want that `As().B().C()` is implemented using a dedicated class (such as `FiniteFields()` uses a dedicated class) and no join category is needed at this point.\n\nThis can be done by a basic category `Bases` that defines the axioms:\n\n```python\nfrom sage.categories.category_singleton import Category_singleton\nfrom sage.categories.category_with_axiom import axiom, CategoryWithAxiom\nimport sage.categories.category_with_axiom\n\nsage.categories.category_with_axiom.all_axioms += (\"B\",\"C\",\"D\",\"E\",\"F\")\n\n# This is just here so that As is not the category that defines the axioms.\nclass Bases(Category_singleton):\n    def super_categories(self):\n        return [Objects()]\n\n    class SubcategoryMethods:\n        B = axiom(\"B\")\n        C = axiom(\"C\")\n        D = axiom(\"D\")\n        E = axiom(\"E\")\n        F = axiom(\"F\")\n\n    class B(CategoryWithAxiom):\n        pass\n    class C(CategoryWithAxiom):\n        pass\n    class D(CategoryWithAxiom):\n        pass\n    class E(CategoryWithAxiom):\n        pass\n    class F(CategoryWithAxiom):\n        pass\n```\nand then, `As` becomes\n\n```python\nclass As(Category_singleton):\n    def super_categories(self):\n        return [Bases()]\n\n    class B(CategoryWithAxiom):\n        class C(CategoryWithAxiom):\n            pass\n\n    class E(CategoryWithAxiom):\n        class F(CategoryWithAxiom):\n            pass\n\n    class D(CategoryWithAxiom):\n        pass\n```\nSimple enough! And nicely, the commutativity and idempotency of applying axioms is taken care of by the system:\n\n```\nsage: As().C().B() is As().B().C().B()\nTrue\nsage: type(As().B().C())\n<class '__main__.B.C_with_category'>\n```\nOf course, in the above implementation, one has a join category, if `D` and another axiom are involved:\n\n```\nsage: type(As().B().D())\n<class 'sage.categories.category.JoinCategory_with_category'>\n```\n\nAnd now, I assume that some theorem says that `As().B().C()==As().E().F()`. How to modify the above code? And in particular: Will the system automatically take care of the implications of the theorem? Again, I want a dedicated class for `As().B().C()`.\n\nHere is one way to modify the code (calling the result `As2` rather than `As`):\n\n```python\nclass As2(Category_singleton):\n    def super_categories(self):\n        return [Bases()]\n\n    class B(CategoryWithAxiom):\n        class C(CategoryWithAxiom):\n            def extra_super_categories(self):\n                return [Bases().E(), Bases().F()]\n\n    class E(CategoryWithAxiom):\n        def F_extra_super_categories(self):\n            return [Bases().B(), Bases().C()]\n```\nWhat does this code tell? Well, it tells that\n- `As().B().C()` uses a dedicated class, and that it additionally satisfies axioms E and F, by providing extra super categories.\n- `As().E().F()` has the additional axioms B and C. Note the asymmetry in the definition: It tells that `As().E().F()` will use the class `As.B.C`, and the output of `F_extra_super_categories` tells how to find this class.\n\nWhat I don't like is that we have a method `F_extra_super_categories`, whose name is then mangled. \n\nIn the first moment I thought that the asymmetry is not nice. However, on second thought, we *must* have asymmetry! After all, we want that `As.B.C` is used for `As().E().F()` and not the other way around.\n\nI believe that the above solution is simple enough, and it does address my concern: The following works out of the box.\n\n```\nsage: As2().B().C()        # it is recognised that axioms B, C, E and F hold\nCategory of b c e f as2\nsage: type(As2().E().F())  # the dedicated class is used\n<class '__main__.B.C_with_category'>\nsage: As2().B().F().D().E().C() is As2().B().C().D()\nTrue\n```\nThe last line means that the system finds non-trivial consequences of the theorem together with idempotency and commutativity.\n\nI don't think that the changes needed for implementing the theorem are totally obvious: One has to learn rules and naming conventions. However, if one has learnt these rules (which of course must be well documented) then implementing the theorem in the code seems to be fairly straight forward.",
    "created_at": "2014-01-21T21:40:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109240",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Here is the announced example. Since Nicolas did not post here, I do. But it is his example.

Recall: I wanted to start with the category `As()`, with available axioms "B",...,"F". In the first place, there should be no relations between the axioms. Moreover, I somehow want that `As().B().C()` is implemented using a dedicated class (such as `FiniteFields()` uses a dedicated class) and no join category is needed at this point.

This can be done by a basic category `Bases` that defines the axioms:

```python
from sage.categories.category_singleton import Category_singleton
from sage.categories.category_with_axiom import axiom, CategoryWithAxiom
import sage.categories.category_with_axiom

sage.categories.category_with_axiom.all_axioms += ("B","C","D","E","F")

# This is just here so that As is not the category that defines the axioms.
class Bases(Category_singleton):
    def super_categories(self):
        return [Objects()]

    class SubcategoryMethods:
        B = axiom("B")
        C = axiom("C")
        D = axiom("D")
        E = axiom("E")
        F = axiom("F")

    class B(CategoryWithAxiom):
        pass
    class C(CategoryWithAxiom):
        pass
    class D(CategoryWithAxiom):
        pass
    class E(CategoryWithAxiom):
        pass
    class F(CategoryWithAxiom):
        pass
```
and then, `As` becomes

```python
class As(Category_singleton):
    def super_categories(self):
        return [Bases()]

    class B(CategoryWithAxiom):
        class C(CategoryWithAxiom):
            pass

    class E(CategoryWithAxiom):
        class F(CategoryWithAxiom):
            pass

    class D(CategoryWithAxiom):
        pass
```
Simple enough! And nicely, the commutativity and idempotency of applying axioms is taken care of by the system:

```
sage: As().C().B() is As().B().C().B()
True
sage: type(As().B().C())
<class '__main__.B.C_with_category'>
```
Of course, in the above implementation, one has a join category, if `D` and another axiom are involved:

```
sage: type(As().B().D())
<class 'sage.categories.category.JoinCategory_with_category'>
```

And now, I assume that some theorem says that `As().B().C()==As().E().F()`. How to modify the above code? And in particular: Will the system automatically take care of the implications of the theorem? Again, I want a dedicated class for `As().B().C()`.

Here is one way to modify the code (calling the result `As2` rather than `As`):

```python
class As2(Category_singleton):
    def super_categories(self):
        return [Bases()]

    class B(CategoryWithAxiom):
        class C(CategoryWithAxiom):
            def extra_super_categories(self):
                return [Bases().E(), Bases().F()]

    class E(CategoryWithAxiom):
        def F_extra_super_categories(self):
            return [Bases().B(), Bases().C()]
```
What does this code tell? Well, it tells that
- `As().B().C()` uses a dedicated class, and that it additionally satisfies axioms E and F, by providing extra super categories.
- `As().E().F()` has the additional axioms B and C. Note the asymmetry in the definition: It tells that `As().E().F()` will use the class `As.B.C`, and the output of `F_extra_super_categories` tells how to find this class.

What I don't like is that we have a method `F_extra_super_categories`, whose name is then mangled. 

In the first moment I thought that the asymmetry is not nice. However, on second thought, we *must* have asymmetry! After all, we want that `As.B.C` is used for `As().E().F()` and not the other way around.

I believe that the above solution is simple enough, and it does address my concern: The following works out of the box.

```
sage: As2().B().C()        # it is recognised that axioms B, C, E and F hold
Category of b c e f as2
sage: type(As2().E().F())  # the dedicated class is used
<class '__main__.B.C_with_category'>
sage: As2().B().F().D().E().C() is As2().B().C().D()
True
```
The last line means that the system finds non-trivial consequences of the theorem together with idempotency and commutativity.

I don't think that the changes needed for implementing the theorem are totally obvious: One has to learn rules and naming conventions. However, if one has learnt these rules (which of course must be well documented) then implementing the theorem in the code seems to be fairly straight forward.



---

archive/issue_comments_109241.json:
```json
{
    "body": "<a id='comment:454'></a>\nReplying to [SimonKing](#comment%3A453):\n> Here is the announced example. Since Nicolas did not post here, I do.\n\nThanks Simon!\n\n> But it is his example.\n\nOr more precisely, my implementation of your example :-)\n\n> (which of course must be well documented)\n\nThere is a (not yet completely finalized) section about this in the documentation of axioms now (see Deduction Rules). Let me know if it's good enough.\n\nSpeaking of which: I have just pushed my work of the day. The join algorithm is described\nand partially formalized; however its companion _with_axiom is yet to\nbe done and they work hand in hand. Yet this should give some hints\nabout why it works.\n\nThis gave me the occasion to look back at the code, and I did some\nsmall simplifications; mostly clearing out a couple small features of\nthe join method that were needed at some point and not anymore.\n\nPushed on u/nthiery/ticket/10963; doc recompiled on sagemath.\n\nCheers,\n                     Nicolas",
    "created_at": "2014-01-21T22:25:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109241",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:454'></a>
Replying to [SimonKing](#comment%3A453):
> Here is the announced example. Since Nicolas did not post here, I do.

Thanks Simon!

> But it is his example.

Or more precisely, my implementation of your example :-)

> (which of course must be well documented)

There is a (not yet completely finalized) section about this in the documentation of axioms now (see Deduction Rules). Let me know if it's good enough.

Speaking of which: I have just pushed my work of the day. The join algorithm is described
and partially formalized; however its companion _with_axiom is yet to
be done and they work hand in hand. Yet this should give some hints
about why it works.

This gave me the occasion to look back at the code, and I did some
small simplifications; mostly clearing out a couple small features of
the join method that were needed at some point and not anymore.

Pushed on u/nthiery/ticket/10963; doc recompiled on sagemath.

Cheers,
                     Nicolas



---

archive/issue_comments_109242.json:
```json
{
    "body": "<a id='comment:455'></a>\nReplying to [nthiery](#comment%3A454):\n> Pushed on u/nthiery/ticket/10963; doc recompiled on sagemath.\n\nHow does it relate with the branch that is attached to this ticket? Does the attached branch contain commits that are not in your branch (e.g., my commit to make the lazy imports even safer, by using as_name)?\n\nAt some point, the work branch should be attached to the ticket, I suppose.",
    "created_at": "2014-01-21T22:44:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109242",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:455'></a>
Replying to [nthiery](#comment%3A454):
> Pushed on u/nthiery/ticket/10963; doc recompiled on sagemath.

How does it relate with the branch that is attached to this ticket? Does the attached branch contain commits that are not in your branch (e.g., my commit to make the lazy imports even safer, by using as_name)?

At some point, the work branch should be attached to the ticket, I suppose.



---

archive/issue_comments_109243.json:
```json
{
    "body": "<a id='comment:6'></a>\nI agree with Simon's explanations. And it illustrates the point that I'm trying to make, if you show the code to a Python programmer then he'll be quite astonished that it does what it does since it seemingly consists only of all a pile of apparently unrelated inner classes.\n\nThe question about unnecessary breaking of symmetry already arises at \n\n```\nclass As(Category_singleton):\n    class B(CategoryWithAxiom):\n        class C(CategoryWithAxiom):\n            pass\n```\nwhy As.B.C and not As.C.B? The only difference is the internal representation of the class. In particular, this explicitly specified order is not used in the printing order of the category-with-axiom. \n\nThe asymmetry in specifying the relations is also in addition (and unrelated) to the print sort order. \n\nThe only \"error message\" if you get the asymmetry wrong will be an infinite recursion.",
    "created_at": "2014-01-21T22:57:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109243",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:6'></a>
I agree with Simon's explanations. And it illustrates the point that I'm trying to make, if you show the code to a Python programmer then he'll be quite astonished that it does what it does since it seemingly consists only of all a pile of apparently unrelated inner classes.

The question about unnecessary breaking of symmetry already arises at 

```
class As(Category_singleton):
    class B(CategoryWithAxiom):
        class C(CategoryWithAxiom):
            pass
```
why As.B.C and not As.C.B? The only difference is the internal representation of the class. In particular, this explicitly specified order is not used in the printing order of the category-with-axiom. 

The asymmetry in specifying the relations is also in addition (and unrelated) to the print sort order. 

The only "error message" if you get the asymmetry wrong will be an infinite recursion.



---

archive/issue_comments_109244.json:
```json
{
    "body": "<a id='comment:457'></a>\nReplying to [vbraun](#comment%3A456):\n> I agree with Simon's explanations. And it illustrates the point that I'm trying to make,\n\nHence, you agree with my explanations, but not with my conclusions (namely that the example demonstrates that only the theorem needs to be implemented, but not its implications, and that implementing the theorem is fairly straightforward after learning the rules).\n\n> if you show the code to a Python programmer then he'll be quite astonished that it does what it does since it seemingly consists only of all a pile of apparently unrelated inner classes.\n\nWhat would the same programmer say about the abc module?\n\n> The question about unnecessary breaking of symmetry already arises at \n> \n> ```\n> class As(Category_singleton):\n>     class B(CategoryWithAxiom):\n>         class C(CategoryWithAxiom):\n>             pass\n> ```\n> why As.B.C and not As.C.B?\n\nI said that it only seemed unnecessary to me *at first*! And after all, the necessity to choose a spanning tree makes it fairly obvious that one has to make choices at some point.\n\nAnd a more symmetric solution is possible, too:\n\n```python\nfrom sage.misc.lazy_attribute import lazy_class_attribute\n\nclass CBAs(CategoryWithAxiom):\n    @lazy_class_attribute\n    def _base_category_class_and_axiom(cls):\n        return(As.B, \"C\")\n\nclass As(Category_singleton):\n    def super_categories(self):\n        return [Bases()]\n\n    class B(CategoryWithAxiom):\n        C = CBAs\n\n    class C(CategoryWithAxiom):\n        pass\n\n    class E(CategoryWithAxiom):\n        pass\n\n    class F(CategoryWithAxiom):\n        pass\n\n    class D(CategoryWithAxiom):\n        pass\n```\n\nThe only asymmetry is the choice of a spanning tree, as defined by `_base_category_class_and_axiom` and the corresponding thing to do at the starting point of the arrow that belongs to the spanning tree.\n\nAnd it still works:\n\n```\nsage: As().B().C() is As().C().B()\nTrue\nsage: As().B().C()\nCategory of c b as\nsage: type(_)\n<class '__main__.CBAs_with_category'>\n```\n\nSo, there is an asymmetry, but it is necessary.\n\n> The only \"error message\" if you get the asymmetry wrong will be an infinite recursion.\n\nYes, and this is unfortunate.",
    "created_at": "2014-01-21T23:33:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109244",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:457'></a>
Replying to [vbraun](#comment%3A456):
> I agree with Simon's explanations. And it illustrates the point that I'm trying to make,

Hence, you agree with my explanations, but not with my conclusions (namely that the example demonstrates that only the theorem needs to be implemented, but not its implications, and that implementing the theorem is fairly straightforward after learning the rules).

> if you show the code to a Python programmer then he'll be quite astonished that it does what it does since it seemingly consists only of all a pile of apparently unrelated inner classes.

What would the same programmer say about the abc module?

> The question about unnecessary breaking of symmetry already arises at 
> 
> ```
> class As(Category_singleton):
>     class B(CategoryWithAxiom):
>         class C(CategoryWithAxiom):
>             pass
> ```
> why As.B.C and not As.C.B?

I said that it only seemed unnecessary to me *at first*! And after all, the necessity to choose a spanning tree makes it fairly obvious that one has to make choices at some point.

And a more symmetric solution is possible, too:

```python
from sage.misc.lazy_attribute import lazy_class_attribute

class CBAs(CategoryWithAxiom):
    @lazy_class_attribute
    def _base_category_class_and_axiom(cls):
        return(As.B, "C")

class As(Category_singleton):
    def super_categories(self):
        return [Bases()]

    class B(CategoryWithAxiom):
        C = CBAs

    class C(CategoryWithAxiom):
        pass

    class E(CategoryWithAxiom):
        pass

    class F(CategoryWithAxiom):
        pass

    class D(CategoryWithAxiom):
        pass
```

The only asymmetry is the choice of a spanning tree, as defined by `_base_category_class_and_axiom` and the corresponding thing to do at the starting point of the arrow that belongs to the spanning tree.

And it still works:

```
sage: As().B().C() is As().C().B()
True
sage: As().B().C()
Category of c b as
sage: type(_)
<class '__main__.CBAs_with_category'>
```

So, there is an asymmetry, but it is necessary.

> The only "error message" if you get the asymmetry wrong will be an infinite recursion.

Yes, and this is unfortunate.



---

archive/issue_comments_109245.json:
```json
{
    "body": "<a id='comment:458'></a>\nReplying to [SimonKing](#comment%3A457):\n> implementing the theorem is fairly straightforward after learning the rules\n\nWell I agree that it works, but I don't think the implementation of the relation As+B+C = As+E+F is as concise as it could be phrased. \n\nOn the plus side, the `extra_super_categories` (I agree with the sentiment that there ought to be better names) mechanism is more general in that it allows to express implications (C1+A1+A2 => C2+A3) in addition to relations.  \n\n> What would the same programmer say about the abc module?\n\nIt precisely requires you to link, in code, your ABC to the virtual subclass:\n\n```\nFooABC.register(Foo)\nassert isinstance(Foo(), FooABC)\n```\nPEP 3119 could have said that Foo is automatically registered as virtual subclass of FooABC if there is a class of that name. This would have saved a line of code, but was afaik not even considered for the standard.\n\n> I said that it only seemed unnecessary to me *at first*! And after all, the necessity to choose a spanning tree makes it fairly obvious that one has to make choices at some point.\n\nYes, I agree that one must make choices. But some of the choices are inconsequential, why should I care about A.B.C vs A.C.B? Why am I forced to pick? There is already a total order on axioms implemented, can't that already be used to break the symmetry?",
    "created_at": "2014-01-22T00:52:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109245",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:458'></a>
Replying to [SimonKing](#comment%3A457):
> implementing the theorem is fairly straightforward after learning the rules

Well I agree that it works, but I don't think the implementation of the relation As+B+C = As+E+F is as concise as it could be phrased. 

On the plus side, the `extra_super_categories` (I agree with the sentiment that there ought to be better names) mechanism is more general in that it allows to express implications (C1+A1+A2 => C2+A3) in addition to relations.  

> What would the same programmer say about the abc module?

It precisely requires you to link, in code, your ABC to the virtual subclass:

```
FooABC.register(Foo)
assert isinstance(Foo(), FooABC)
```
PEP 3119 could have said that Foo is automatically registered as virtual subclass of FooABC if there is a class of that name. This would have saved a line of code, but was afaik not even considered for the standard.

> I said that it only seemed unnecessary to me *at first*! And after all, the necessity to choose a spanning tree makes it fairly obvious that one has to make choices at some point.

Yes, I agree that one must make choices. But some of the choices are inconsequential, why should I care about A.B.C vs A.C.B? Why am I forced to pick? There is already a total order on axioms implemented, can't that already be used to break the symmetry?



---

archive/issue_comments_109246.json:
```json
{
    "body": "<a id='comment:459'></a>\nReplying to [SimonKing](#comment%3A455):\n> Replying to [nthiery](#comment%3A454):\n> > Pushed on u/nthiery/ticket/10963\n\n> \n> How does it relate with the branch that is attached to this ticket? Does the attached branch contain commits that are not in your branch (e.g., my commit to make the lazy imports even safer, by using as_name)?\n\nI branched off right before that commit; actually that commit is the\nsingle reason for my branching off: since it was still to be\ndiscussed, I did not want to merge it right away in my changes, but I\ndid not want it either to look like I was discarding it by having the\nticket branch not contain that commit.\n\nCons for the commit: it's imposing a bit more redundant information on\nthe developer in many spots when there is an alternative three lines\nlocalized robust fix (no risk of forgetting a spot).\n\nPros for the commit: the developer might get used of not having to\nspecify as_name for similar lazy imported nested classes, and get\nsurprised in a different context.\n\nMy personal preference is without the commit.\n\n> At some point, the work branch should be attached to the ticket, I suppose.\n\nDefinitely!\n\nCheers,\n                               Nicolas",
    "created_at": "2014-01-22T07:28:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109246",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:459'></a>
Replying to [SimonKing](#comment%3A455):
> Replying to [nthiery](#comment%3A454):
> > Pushed on u/nthiery/ticket/10963

> 
> How does it relate with the branch that is attached to this ticket? Does the attached branch contain commits that are not in your branch (e.g., my commit to make the lazy imports even safer, by using as_name)?

I branched off right before that commit; actually that commit is the
single reason for my branching off: since it was still to be
discussed, I did not want to merge it right away in my changes, but I
did not want it either to look like I was discarding it by having the
ticket branch not contain that commit.

Cons for the commit: it's imposing a bit more redundant information on
the developer in many spots when there is an alternative three lines
localized robust fix (no risk of forgetting a spot).

Pros for the commit: the developer might get used of not having to
specify as_name for similar lazy imported nested classes, and get
surprised in a different context.

My personal preference is without the commit.

> At some point, the work branch should be attached to the ticket, I suppose.

Definitely!

Cheers,
                               Nicolas



---

archive/issue_comments_109247.json:
```json
{
    "body": "<a id='comment:460'></a>\nReplying to [vbraun](#comment%3A456):\n> I agree with Simon's explanations. And it illustrates the point that I'm trying to make, if you show the code to a Python programmer then he'll be quite astonished that it does what it does since it seemingly consists only of all a pile of apparently unrelated inner classes.\n\nWell, yes: there is no standard mixin mechanism in Python; so, if we\nwant to have some mixin mechanism (and we agree that we want some,\nright?), then whatever the syntax for that mechanism is, a Python\nprogrammer will need to learn it.\n\nCheers,\n                               Nicolas",
    "created_at": "2014-01-22T07:33:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109247",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:460'></a>
Replying to [vbraun](#comment%3A456):
> I agree with Simon's explanations. And it illustrates the point that I'm trying to make, if you show the code to a Python programmer then he'll be quite astonished that it does what it does since it seemingly consists only of all a pile of apparently unrelated inner classes.

Well, yes: there is no standard mixin mechanism in Python; so, if we
want to have some mixin mechanism (and we agree that we want some,
right?), then whatever the syntax for that mechanism is, a Python
programmer will need to learn it.

Cheers,
                               Nicolas



---

archive/issue_comments_109248.json:
```json
{
    "body": "<a id='comment:461'></a>\n> I said that it only seemed unnecessary to me *at first*! And after all, the necessity to choose a spanning tree makes it fairly obvious that one has to make choices at some point.\n\nPerhaps I understand nothing of what is happening here -- and I am quite prepared to hear it -- but in my own pagan way of doing things, and as you seem to be associating functions to set of axioms, I wondered why you don't associate functions to ... sets of axioms ?\n\nIt looks like your problem is that the user should \"decide\" if the function is a function of `A.B` or a function of `B.A` when what you have in mind is a function of `{A,B}`. Why don't you have a syntax which takes as information a set of axioms (and a category if needed), and let some code decide automatically where it should be put (pick your spanning tree) ?\n\nSomething like the fancy stuff you like, a metaclass which creates a class from its SET of axioms, and everything ? This class would not appear as a subclass of any categoy with axiom, it would just stand on its own somewhere, and be copied where it belongs, by some code the coder does not have to think about ?\n\nNathann\n\nP.S. : A \"spanning tree\" in a dag is usually not called a spanning tree but a spanning out-arborescence. We just don't like \"trees\" to be directed `:-P`",
    "created_at": "2014-01-22T08:52:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109248",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:461'></a>
> I said that it only seemed unnecessary to me *at first*! And after all, the necessity to choose a spanning tree makes it fairly obvious that one has to make choices at some point.

Perhaps I understand nothing of what is happening here -- and I am quite prepared to hear it -- but in my own pagan way of doing things, and as you seem to be associating functions to set of axioms, I wondered why you don't associate functions to ... sets of axioms ?

It looks like your problem is that the user should "decide" if the function is a function of `A.B` or a function of `B.A` when what you have in mind is a function of `{A,B}`. Why don't you have a syntax which takes as information a set of axioms (and a category if needed), and let some code decide automatically where it should be put (pick your spanning tree) ?

Something like the fancy stuff you like, a metaclass which creates a class from its SET of axioms, and everything ? This class would not appear as a subclass of any categoy with axiom, it would just stand on its own somewhere, and be copied where it belongs, by some code the coder does not have to think about ?

Nathann

P.S. : A "spanning tree" in a dag is usually not called a spanning tree but a spanning out-arborescence. We just don't like "trees" to be directed `:-P`



---

archive/issue_comments_109249.json:
```json
{
    "body": "<a id='comment:462'></a>\nReplying to [ncohen](#comment%3A461):\n> It looks like your problem is that the user should \"decide\" if the function is a function of `A.B` or a function of `B.A` when what you have in mind is a function of `{A,B}`. Why don't you have a syntax which takes as information a set of axioms (and a category if needed), and let some code decide automatically where it should be put (pick your spanning tree) ?\n\nHow could such syntax look like? Of course, we can have a separate class `ABs`, and then let both `As.B` and `Bs.A` point to it. But even when you write down the name `ABs`, you already have a choice to do---after all, why don't you chose `BAs` instead of `ABs`.\n\n> Something like the fancy stuff you like, a metaclass which creates a class from its SET of axioms, and everything ?\n\nWell, this is my suggestion for the future.\n\n> P.S. : A \"spanning tree\" in a dag is usually not called a spanning tree but a spanning out-arborescence. We just don't like \"trees\" to be directed `:-P`\n\nReally? I always thought of *rooted* trees (and that's what we have here) as being directed.",
    "created_at": "2014-01-22T09:20:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109249",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:462'></a>
Replying to [ncohen](#comment%3A461):
> It looks like your problem is that the user should "decide" if the function is a function of `A.B` or a function of `B.A` when what you have in mind is a function of `{A,B}`. Why don't you have a syntax which takes as information a set of axioms (and a category if needed), and let some code decide automatically where it should be put (pick your spanning tree) ?

How could such syntax look like? Of course, we can have a separate class `ABs`, and then let both `As.B` and `Bs.A` point to it. But even when you write down the name `ABs`, you already have a choice to do---after all, why don't you chose `BAs` instead of `ABs`.

> Something like the fancy stuff you like, a metaclass which creates a class from its SET of axioms, and everything ?

Well, this is my suggestion for the future.

> P.S. : A "spanning tree" in a dag is usually not called a spanning tree but a spanning out-arborescence. We just don't like "trees" to be directed `:-P`

Really? I always thought of *rooted* trees (and that's what we have here) as being directed.



---

archive/issue_comments_109250.json:
```json
{
    "body": "<a id='comment:463'></a>\nReplying to [vbraun](#comment%3A458):\n> Well I agree that it works, but I don't think the implementation of the relation As+B+C = As+E+F is as concise as it could be phrased.\n> \n> On the plus side, the `extra_super_categories` mechanism is more general in that it allows to express implications (C1+A1+A2 => C2+A3) in addition to relations.\n\nOr even C1+A1+A2 -> C3.\n\nAnother plus side is that it gives a natural spot (the docstring of\nthe method) to document and test the modeling of the theorem.\n\n> (I agree with the sentiment that there ought to be better names)\n\nDefinitely! We have been using `extra_super_categories` since 2009.\nIf someone has a suggestion for a better name it should be easy to\nchange it now or later while maintaining temporary backward\ncompatibility.\n\n> It precisely requires you to link, in code, your ABC to the virtual subclass:\n> \n> ```\n> FooABC.register(Foo)\n> assert isinstance(Foo(), FooABC)\n> ```\n> PEP 3119 could have said that Foo is automatically registered as virtual subclass of FooABC if there is a class of that name. This would have saved a line of code, but was afaik not even considered for the standard.\n\nAnd I would have definitely voted against it :-)\n\nNow let me recall that the guessing based on the name only occurs to\nenable the alias FiniteSets() -> Sets().Finite(). If you do\nSets().Finite() directly, it's not used at all. So it's just about\nimplementing a syntactic sugar, not about semantic.\n\nIn fact, I am not even sure we want to have that syntactic sugar at\nall in the long run. My main motivation for implementing it was for\nbackward compatibility. Later on, I definitely want to remove quite\nsome of the names like GradedAlgebrasWithBasis from the global name\nspace. Probably FiniteSets / FiniteGroups / ... too. And possibly\ncompletely deprecate the idiom FiniteSets(). Of course, we definitely\nwant to keep Fields(), Groups(), ...  but those don't use the guessing\nanyway.\n\nYes, yes Volker, that intention was yet not spelled out explicitly; I\nonce again relied on your telepathic abilities :-) I'll add now a\ncomment in the documentation about the recommended usage of\nSets().Finite() and the potential deprecation of FiniteSets().\n\nBtw: I don't want to handle this deprecation phase right now because\nthere is already enough on the plate of this ticket and because I\nbelieve we need to have people play around with the code before\ndeciding how far we want to do the deprecation.\n\nAltogether, I believe that for implementing a syntactic sugar, that\nfurther might be temporary or for which we can seek later another\nsolution, a little guess work is not great but ok.\n\nCheers,\n                                 Nicolas",
    "created_at": "2014-01-22T09:48:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109250",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:463'></a>
Replying to [vbraun](#comment%3A458):
> Well I agree that it works, but I don't think the implementation of the relation As+B+C = As+E+F is as concise as it could be phrased.
> 
> On the plus side, the `extra_super_categories` mechanism is more general in that it allows to express implications (C1+A1+A2 => C2+A3) in addition to relations.

Or even C1+A1+A2 -> C3.

Another plus side is that it gives a natural spot (the docstring of
the method) to document and test the modeling of the theorem.

> (I agree with the sentiment that there ought to be better names)

Definitely! We have been using `extra_super_categories` since 2009.
If someone has a suggestion for a better name it should be easy to
change it now or later while maintaining temporary backward
compatibility.

> It precisely requires you to link, in code, your ABC to the virtual subclass:
> 
> ```
> FooABC.register(Foo)
> assert isinstance(Foo(), FooABC)
> ```
> PEP 3119 could have said that Foo is automatically registered as virtual subclass of FooABC if there is a class of that name. This would have saved a line of code, but was afaik not even considered for the standard.

And I would have definitely voted against it :-)

Now let me recall that the guessing based on the name only occurs to
enable the alias FiniteSets() -> Sets().Finite(). If you do
Sets().Finite() directly, it's not used at all. So it's just about
implementing a syntactic sugar, not about semantic.

In fact, I am not even sure we want to have that syntactic sugar at
all in the long run. My main motivation for implementing it was for
backward compatibility. Later on, I definitely want to remove quite
some of the names like GradedAlgebrasWithBasis from the global name
space. Probably FiniteSets / FiniteGroups / ... too. And possibly
completely deprecate the idiom FiniteSets(). Of course, we definitely
want to keep Fields(), Groups(), ...  but those don't use the guessing
anyway.

Yes, yes Volker, that intention was yet not spelled out explicitly; I
once again relied on your telepathic abilities :-) I'll add now a
comment in the documentation about the recommended usage of
Sets().Finite() and the potential deprecation of FiniteSets().

Btw: I don't want to handle this deprecation phase right now because
there is already enough on the plate of this ticket and because I
believe we need to have people play around with the code before
deciding how far we want to do the deprecation.

Altogether, I believe that for implementing a syntactic sugar, that
further might be temporary or for which we can seek later another
solution, a little guess work is not great but ok.

Cheers,
                                 Nicolas



---

archive/issue_comments_109251.json:
```json
{
    "body": "<a id='comment:464'></a>\nReplying to [SimonKing](#comment%3A462):\n> Replying to [ncohen](#comment%3A461):\n> > It looks like your problem is that the user should \"decide\" if the function is a function of `A.B` or a function of `B.A` when what you have in mind is a function of `{A,B}`. Why don't you have a syntax which takes as information a set of axioms (and a category if needed), and let some code decide automatically where it should be put (pick your spanning tree) ?\n\nYes, I agree that this is a direction to explore (e.g. following\nSimon's database suggestions)! Yes we agree with Simon that this is\nfor a later iteration as this requires non trivial experimentation and\nimplementation work.\n\nNow I'd like to raise a point to mitigate the discussion. In most\npractical cases, we want to work incrementally. You'd rather describe\nFiniteFields as Fields with the axiom Finite rather than Magmas and\nAdditiveMagmas with all of the following axioms (besides Distributive):\n\n```\n    sage: Fields().axioms()\n    frozenset(['Division', 'AdditiveUnital', 'NoZeroDivisors', 'Commutative',\n               'AdditiveInverse', 'AdditiveAssociative', 'Unital',\n\t       'AdditiveCommutative', 'Associative'])\n```\n\nOk, a few of the above axioms are redundant but still, you see my\npoint, right?\n\nIn practice, among the 59 categories with axioms that are currently\nimplemented in Sage, almost all admitted a natural choice of base\ncategory and single axiom to add. Only in a few cases did I really\nmake a choice that felt mathematically arbitrary. That was essentially\nin this snippet of DistributiveMagmasAndAdditiveMagmas:\n\n```\n    class AdditiveAssociative(CategoryWithAxiom):\n        class AdditiveCommutative(CategoryWithAxiom):\n            class AdditiveUnital(CategoryWithAxiom):\n                class AdditiveInverse(CategoryWithAxiom):\n                    Associative = LazyImport('sage.categories.rngs', 'Rngs', at_startup=True)\n                class Associative(CategoryWithAxiom):\n                    Unital          = LazyImport('sage.categories.semirings', 'Semirings', at_startup=True)\n```\n\nAnd it's not even much worst than a syntax like\n\n```\n    {AdditiveAssociative,AdditiveCommutative,AdditiveUnital} -> ...\n```\n\n> Really? I always thought of *rooted* trees (and that's what we have here) as being directed.\n\nTrue, we should have added \"rooted\" everywhere in our discussion. But\nif Nathann believes \"out-arborescence\" is better, we could change to\nthat too.\n\nCheers,\n                                     Nicolas",
    "created_at": "2014-01-22T10:24:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109251",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:464'></a>
Replying to [SimonKing](#comment%3A462):
> Replying to [ncohen](#comment%3A461):
> > It looks like your problem is that the user should "decide" if the function is a function of `A.B` or a function of `B.A` when what you have in mind is a function of `{A,B}`. Why don't you have a syntax which takes as information a set of axioms (and a category if needed), and let some code decide automatically where it should be put (pick your spanning tree) ?

Yes, I agree that this is a direction to explore (e.g. following
Simon's database suggestions)! Yes we agree with Simon that this is
for a later iteration as this requires non trivial experimentation and
implementation work.

Now I'd like to raise a point to mitigate the discussion. In most
practical cases, we want to work incrementally. You'd rather describe
FiniteFields as Fields with the axiom Finite rather than Magmas and
AdditiveMagmas with all of the following axioms (besides Distributive):

```
    sage: Fields().axioms()
    frozenset(['Division', 'AdditiveUnital', 'NoZeroDivisors', 'Commutative',
               'AdditiveInverse', 'AdditiveAssociative', 'Unital',
	       'AdditiveCommutative', 'Associative'])
```

Ok, a few of the above axioms are redundant but still, you see my
point, right?

In practice, among the 59 categories with axioms that are currently
implemented in Sage, almost all admitted a natural choice of base
category and single axiom to add. Only in a few cases did I really
make a choice that felt mathematically arbitrary. That was essentially
in this snippet of DistributiveMagmasAndAdditiveMagmas:

```
    class AdditiveAssociative(CategoryWithAxiom):
        class AdditiveCommutative(CategoryWithAxiom):
            class AdditiveUnital(CategoryWithAxiom):
                class AdditiveInverse(CategoryWithAxiom):
                    Associative = LazyImport('sage.categories.rngs', 'Rngs', at_startup=True)
                class Associative(CategoryWithAxiom):
                    Unital          = LazyImport('sage.categories.semirings', 'Semirings', at_startup=True)
```

And it's not even much worst than a syntax like

```
    {AdditiveAssociative,AdditiveCommutative,AdditiveUnital} -> ...
```

> Really? I always thought of *rooted* trees (and that's what we have here) as being directed.

True, we should have added "rooted" everywhere in our discussion. But
if Nathann believes "out-arborescence" is better, we could change to
that too.

Cheers,
                                     Nicolas



---

archive/issue_comments_109252.json:
```json
{
    "body": "<a id='comment:465'></a>\nReplying to [pbruin](#comment%3A450):\n> The existing `summand_*` methods I could find are\n> \n> ```\n> CartesianProduct.summand_projection()\n> Sets.CartesianProducts.ParentMethods.summand_projection()\n> Sets.CartesianProducts.ElementMethods.summand_projection()\n> Sets.CartesianProducts.ElementMethods.summand_split()\n> CombinatorialFreeModule_CartesianProduct.summand_embedding()\n> CombinatorialFreeModule_CartesianProduct.summand_projection()\n> ```\n> Maybe the quickest solution is to insert better-named aliases for these, rename the method `summands()` introduced here, and later deprecate `summand_projection()` and `summand_split()` in a different ticket.\n> \n> My first reflex would be to rename `summand_projection()` to `projection()` and `summand_split()` to `tuple()`.\n\nIf you believe this is urgent enough to belong to #10963, then please\ngo ahead, and I'll review it.\n\n> If this is too conflict-prone, maybe using the prefix `cartesian_` suggested by Simon would be a solution?\n\nYes, we definitely want long explicit names to avoid conflicts.\n\n> For products of modules (the last two methods in the above list), calling the components \"summands\" is OK if and only if there are only finitely many summands/factors; in that case the product and sum coincide, since modules form an additive category.\n\nYup. CartesianProducts only covers finite cartesian products / finite\nsums, so that's ok. Hmm, this was apparently not spelled out\nexplicitly, but all the code makes this assumption. I just fixed that.\n\n> I'm confused; isn't a Cartesian product of monoids just the Cartesian product of the underlying sets, with the obvious monoid structure?\n\nYes!\n\n> Or do you mean that a generic monoid will have a `factors()` method that does something unrelated?\n\nTo raise any confusion: I mean that if you construct a monoid M as a\ncartesian product of other monoids, you would get a `M.factors()`\nmethod which would have nothing to do with the concept of\nfactorization in the monoid M.\n\nCheers,\n                          Nicolas",
    "created_at": "2014-01-22T10:38:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109252",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:465'></a>
Replying to [pbruin](#comment%3A450):
> The existing `summand_*` methods I could find are
> 
> ```
> CartesianProduct.summand_projection()
> Sets.CartesianProducts.ParentMethods.summand_projection()
> Sets.CartesianProducts.ElementMethods.summand_projection()
> Sets.CartesianProducts.ElementMethods.summand_split()
> CombinatorialFreeModule_CartesianProduct.summand_embedding()
> CombinatorialFreeModule_CartesianProduct.summand_projection()
> ```
> Maybe the quickest solution is to insert better-named aliases for these, rename the method `summands()` introduced here, and later deprecate `summand_projection()` and `summand_split()` in a different ticket.
> 
> My first reflex would be to rename `summand_projection()` to `projection()` and `summand_split()` to `tuple()`.

If you believe this is urgent enough to belong to #10963, then please
go ahead, and I'll review it.

> If this is too conflict-prone, maybe using the prefix `cartesian_` suggested by Simon would be a solution?

Yes, we definitely want long explicit names to avoid conflicts.

> For products of modules (the last two methods in the above list), calling the components "summands" is OK if and only if there are only finitely many summands/factors; in that case the product and sum coincide, since modules form an additive category.

Yup. CartesianProducts only covers finite cartesian products / finite
sums, so that's ok. Hmm, this was apparently not spelled out
explicitly, but all the code makes this assumption. I just fixed that.

> I'm confused; isn't a Cartesian product of monoids just the Cartesian product of the underlying sets, with the obvious monoid structure?

Yes!

> Or do you mean that a generic monoid will have a `factors()` method that does something unrelated?

To raise any confusion: I mean that if you construct a monoid M as a
cartesian product of other monoids, you would get a `M.factors()`
method which would have nothing to do with the concept of
factorization in the monoid M.

Cheers,
                          Nicolas



---

archive/issue_comments_109253.json:
```json
{
    "body": "<a id='comment:466'></a>\nReplying to [SimonKing](#comment%3A457):\n> > The only \"error message\" if you get the asymmetry wrong will be an infinite recursion.\n\n> \n> Yes, and this is unfortunate.\n\nAgreed: it could be usefully complemented by some hint at what the\nsource of the problem could be. That being said, the backtrace is\npretty useful to explore where the issue comes from (e.g. with post\nmortem debugging), and we would not want to completely suppress it.\n\nAnyway, that's an implementation detail that can most likely can be\nimproved later on by adding more sanity checks.",
    "created_at": "2014-01-22T11:32:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109253",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:466'></a>
Replying to [SimonKing](#comment%3A457):
> > The only "error message" if you get the asymmetry wrong will be an infinite recursion.

> 
> Yes, and this is unfortunate.

Agreed: it could be usefully complemented by some hint at what the
source of the problem could be. That being said, the backtrace is
pretty useful to explore where the issue comes from (e.g. with post
mortem debugging), and we would not want to completely suppress it.

Anyway, that's an implementation detail that can most likely can be
improved later on by adding more sanity checks.



---

archive/issue_comments_109254.json:
```json
{
    "body": "<a id='comment:467'></a>\nNathan raises a point that confuses me, too. Why is there a single defining axiom, the self._axiom attribute? It would be much more natural to have a list of defining axioms. For much of the work you are only looking at the list of implied `axioms()` anyways.\n\nReplying to [nthiery](#comment%3A464):\n> Well, yes: there is no standard mixin mechanism in Python\n\nThere is, multiple inheritance.\n\n> And I would have definitely voted against it :-)\n\nYou are of course entitled to your own opinion, but if you want to write a Python library that others can use then \"explicit is better than implicit\" is not up for vote. That train has long departed...\n\n> ```\n>     class AdditiveAssociative(CategoryWithAxiom):\n>         class AdditiveCommutative(CategoryWithAxiom):\n>             class AdditiveUnital(CategoryWithAxiom):\n>                 class AdditiveInverse(CategoryWithAxiom):\n>                     Associative = LazyImport('sage.categories.rngs', 'Rngs', at_startup=True)\n> ```\n\nAnd I hope we can all agree that five-fold nested classes are an abomination ;-)\n\nReplying to [SimonKing](#comment%3A462):\n> How could such syntax look like? Of course, we can have a separate class `ABs`, and then let both `As.B` and `Bs.A` point to it. But even when you write down the name `ABs`, you already have a choice to do---after all, why don't you chose `BAs` instead of `ABs`.\n\nThis is just a naming choice, it does not change the actual code (unless you go out of your way to make the code depend on the class name). You can even call it `Both_A_and_B`, or `_Implementation` if you want to stress the symmetry. It doesn't require you to nest class definitions.",
    "created_at": "2014-01-22T11:57:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109254",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:467'></a>
Nathan raises a point that confuses me, too. Why is there a single defining axiom, the self._axiom attribute? It would be much more natural to have a list of defining axioms. For much of the work you are only looking at the list of implied `axioms()` anyways.

Replying to [nthiery](#comment%3A464):
> Well, yes: there is no standard mixin mechanism in Python

There is, multiple inheritance.

> And I would have definitely voted against it :-)

You are of course entitled to your own opinion, but if you want to write a Python library that others can use then "explicit is better than implicit" is not up for vote. That train has long departed...

> ```
>     class AdditiveAssociative(CategoryWithAxiom):
>         class AdditiveCommutative(CategoryWithAxiom):
>             class AdditiveUnital(CategoryWithAxiom):
>                 class AdditiveInverse(CategoryWithAxiom):
>                     Associative = LazyImport('sage.categories.rngs', 'Rngs', at_startup=True)
> ```

And I hope we can all agree that five-fold nested classes are an abomination ;-)

Replying to [SimonKing](#comment%3A462):
> How could such syntax look like? Of course, we can have a separate class `ABs`, and then let both `As.B` and `Bs.A` point to it. But even when you write down the name `ABs`, you already have a choice to do---after all, why don't you chose `BAs` instead of `ABs`.

This is just a naming choice, it does not change the actual code (unless you go out of your way to make the code depend on the class name). You can even call it `Both_A_and_B`, or `_Implementation` if you want to stress the symmetry. It doesn't require you to nest class definitions.



---

archive/issue_comments_109255.json:
```json
{
    "body": "<a id='comment:468'></a>\nReplying to [vbraun](#comment%3A449):\n> Well a few categories are always going to be constructed on startup\n\nIn principle, we could imagine not having a single one; but I can live\nwith a couple.\n\n> I'm sorry, I overlooked the comment in your code that stated that you want to get rid of those imports-on-startup. Oh, no comment? In that case I'm sorry for not having any telepathic abilities to read your mind ;-)\n\nYou really should work on your sightseer skills; then you would have\nforeseen that this is now written in the documentation :-)\n\n> > Mathematically speaking, you agree that an axiom *is* naturally tied\n> > to a most basic category, right? That which provides the language\n> > necessary to express the semantic of the axiom.\n\n> \n> I agree that there is, mathematically speaking, always some join category that would be the most basic.\n> But there is no need to require Sage developers to implement a common supercategory by hand. Of course you can, but the whole point of this ticket is to reduce the number of categories that you must construct by hand.\n\nI agree: it's non optimal to have to implement a placeholder category\nMagmasAndAdditiveMagmas just to define the distributive\naxiom. Likewise for the chain\nDistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital\nI mentioned earlier. But this is well within the scope of the ticket\nwhich is to go from a potentially exponential number of placeholder\ncategories to just a couple.\n\nIt's certainly a compromise, but I believe it's a reasonable price to\npay (with the asymmetry discussed above) for the current feature set\n(in particular the ``C.Finite()`` idiom) and performance.\n\nWhat I find more annoying is that Sage can't currently be taught that\nMagmasAndAdditiveMagmas is the join of Magmas and AdditiveMagmas,\nwhich is why I did not yet implement MagmasAndAdditiveMagmas together\nwith its Distributive axiom. In the longer run, I would like to fix\nthis by making `join` more powerful, but that will need some thought\non an appropriate idiom.\n\nCheers,\n                           Nicolas",
    "created_at": "2014-01-22T12:03:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109255",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:468'></a>
Replying to [vbraun](#comment%3A449):
> Well a few categories are always going to be constructed on startup

In principle, we could imagine not having a single one; but I can live
with a couple.

> I'm sorry, I overlooked the comment in your code that stated that you want to get rid of those imports-on-startup. Oh, no comment? In that case I'm sorry for not having any telepathic abilities to read your mind ;-)

You really should work on your sightseer skills; then you would have
foreseen that this is now written in the documentation :-)

> > Mathematically speaking, you agree that an axiom *is* naturally tied
> > to a most basic category, right? That which provides the language
> > necessary to express the semantic of the axiom.

> 
> I agree that there is, mathematically speaking, always some join category that would be the most basic.
> But there is no need to require Sage developers to implement a common supercategory by hand. Of course you can, but the whole point of this ticket is to reduce the number of categories that you must construct by hand.

I agree: it's non optimal to have to implement a placeholder category
MagmasAndAdditiveMagmas just to define the distributive
axiom. Likewise for the chain
DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital
I mentioned earlier. But this is well within the scope of the ticket
which is to go from a potentially exponential number of placeholder
categories to just a couple.

It's certainly a compromise, but I believe it's a reasonable price to
pay (with the asymmetry discussed above) for the current feature set
(in particular the ``C.Finite()`` idiom) and performance.

What I find more annoying is that Sage can't currently be taught that
MagmasAndAdditiveMagmas is the join of Magmas and AdditiveMagmas,
which is why I did not yet implement MagmasAndAdditiveMagmas together
with its Distributive axiom. In the longer run, I would like to fix
this by making `join` more powerful, but that will need some thought
on an appropriate idiom.

Cheers,
                           Nicolas



---

archive/issue_comments_109256.json:
```json
{
    "body": "<a id='comment:469'></a>\nReplying to [nthiery](#comment%3A468):\n> I agree: it's non optimal to have to implement a placeholder category\n> MagmasAndAdditiveMagmas just to define the distributive\n> axiom. Likewise for the chain\n> DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital\n> I mentioned earlier. But this is well within the scope of the ticket\n> which is to go from a potentially exponential number of placeholder\n> categories to just a couple.\n> \n> ...\n> \n> What I find more annoying is that Sage can't currently be taught that\n> MagmasAndAdditiveMagmas is the join of Magmas and AdditiveMagmas,\n\n\nExactly! And it is one of the reasons why I prefer to move the whole logic into a dedicated database of category classes, perhaps based on boolean polynomial rings. If you input `Magmas*AdditiveMagmas*Distributive`, then this database would spit out the class that is labelled with this identifier (wherever it is implemented, as a nested class or in a separate Python module), and the label would make clear that what we consider is \"apply the `Distributive` axiom to the category labelled `Magmas*AdditiveMagmas`, which is the join of `Magmas` and `AdditiveMagmas`.",
    "created_at": "2014-01-22T12:15:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109256",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:469'></a>
Replying to [nthiery](#comment%3A468):
> I agree: it's non optimal to have to implement a placeholder category
> MagmasAndAdditiveMagmas just to define the distributive
> axiom. Likewise for the chain
> DistributiveMagmasAndAdditiveMagmas.AdditiveAssociative.AdditiveCommutative.AdditiveUnital
> I mentioned earlier. But this is well within the scope of the ticket
> which is to go from a potentially exponential number of placeholder
> categories to just a couple.
> 
> ...
> 
> What I find more annoying is that Sage can't currently be taught that
> MagmasAndAdditiveMagmas is the join of Magmas and AdditiveMagmas,


Exactly! And it is one of the reasons why I prefer to move the whole logic into a dedicated database of category classes, perhaps based on boolean polynomial rings. If you input `Magmas*AdditiveMagmas*Distributive`, then this database would spit out the class that is labelled with this identifier (wherever it is implemented, as a nested class or in a separate Python module), and the label would make clear that what we consider is "apply the `Distributive` axiom to the category labelled `Magmas*AdditiveMagmas`, which is the join of `Magmas` and `AdditiveMagmas`.



---

archive/issue_comments_109257.json:
```json
{
    "body": "<a id='comment:470'></a>\nReplying to [vbraun](#comment%3A467):\n> Nathan raises a point that confuses me, too. Why is there a single defining axiom, the self._axiom attribute? It would be much more natural to have a list of defining axioms. For much of the work you are only looking at the list of implied `axioms()` anyways.\n\nSee [comment:464]. One wants to be incremental in most cases\nanyway. The only thing is that the infrastructure currently forces to\nbe incremental by unit steps.\n\n> Replying to [nthiery](#comment%3A464):\n> > Well, yes: there is no standard mixin mechanism in Python\n\n> \n> There is, multiple inheritance.\n\nWell, that's for static mixin. And indeed you can use multiple\ninheritance together with dynamic classes to implement dynamic mixins\nwhich are gathered dynamically as we need. But there is no standard\nimplementation and syntax for dynamic mixins.\n\n> > And I would have definitely voted against it :-)\n\n> \n> You are of course entitled to your own opinion, but if you want to write a Python library that others can use then \"explicit is better than implicit\" is not up for vote. That train has long departed...\n\nNo, no, you got me wrong. Sorry for the ambiguity. I of course meant that I agreed with that train: in such a general situation that would have been horribly\nimplicit.\n\n> > ```\n> >     class AdditiveAssociative(CategoryWithAxiom):\n> >         class AdditiveCommutative(CategoryWithAxiom):\n> >             class AdditiveUnital(CategoryWithAxiom):\n> >                 class AdditiveInverse(CategoryWithAxiom):\n> >                     Associative = LazyImport('sage.categories.rngs', 'Rngs', at_startup=True)\n> > ```\n\n> \n> And I hope we can all agree that five-fold nested classes are an abomination ;-)\n\nWell, of course I would frown upon a large deeply nested class,\nbecause of indentation; it's certainly better to put such a class in a\nseparate file. But in a case like above, it's concise and very\nexpressive.\n\nI believe nested classes are an *opportunity* given to us by Python to\nstructure the code; it just has been under-exploited yet.",
    "created_at": "2014-01-22T12:29:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109257",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:470'></a>
Replying to [vbraun](#comment%3A467):
> Nathan raises a point that confuses me, too. Why is there a single defining axiom, the self._axiom attribute? It would be much more natural to have a list of defining axioms. For much of the work you are only looking at the list of implied `axioms()` anyways.

See [comment:464]. One wants to be incremental in most cases
anyway. The only thing is that the infrastructure currently forces to
be incremental by unit steps.

> Replying to [nthiery](#comment%3A464):
> > Well, yes: there is no standard mixin mechanism in Python

> 
> There is, multiple inheritance.

Well, that's for static mixin. And indeed you can use multiple
inheritance together with dynamic classes to implement dynamic mixins
which are gathered dynamically as we need. But there is no standard
implementation and syntax for dynamic mixins.

> > And I would have definitely voted against it :-)

> 
> You are of course entitled to your own opinion, but if you want to write a Python library that others can use then "explicit is better than implicit" is not up for vote. That train has long departed...

No, no, you got me wrong. Sorry for the ambiguity. I of course meant that I agreed with that train: in such a general situation that would have been horribly
implicit.

> > ```
> >     class AdditiveAssociative(CategoryWithAxiom):
> >         class AdditiveCommutative(CategoryWithAxiom):
> >             class AdditiveUnital(CategoryWithAxiom):
> >                 class AdditiveInverse(CategoryWithAxiom):
> >                     Associative = LazyImport('sage.categories.rngs', 'Rngs', at_startup=True)
> > ```

> 
> And I hope we can all agree that five-fold nested classes are an abomination ;-)

Well, of course I would frown upon a large deeply nested class,
because of indentation; it's certainly better to put such a class in a
separate file. But in a case like above, it's concise and very
expressive.

I believe nested classes are an *opportunity* given to us by Python to
structure the code; it just has been under-exploited yet.



---

archive/issue_comments_109258.json:
```json
{
    "body": "<a id='comment:471'></a>\nReplying to [nthiery](#comment%3A470):\n> Replying to [vbraun](#comment%3A467):\n> Why is there a single defining axiom, the self._axiom attribute?\n> See [comment:464]. One wants to be incremental in most cases\n> anyway.\n\nI'm not talking about the user interface with the successive `category.Axiom()` factory methods (implemented as actual methods or `__classcall__`). I'm talking about the code layout, where deeply nested classes are rather cumbersome. There, I don't want to be forced to add one axiom at a time if I only have code to attach to the case of multiple axioms. I especially don't want five-fold nested classes just to express that I want factory methods for those five. \n\n> But there is no standard implementation and syntax for dynamic mixins.\n\nTrue, but there are only two sane options: Either use some tricks to turn the static into dynamic mixins (the DWIM principle) or explicitly specify the dynamic mixins in a class atttribute. Really, that just boils down to using either inheritance or object composition to express relations between classes in code.\n\n> I believe nested classes are an *opportunity* given to us by Python to\n> structure the code; it just has been under-exploited yet.\n\nI'm happy with nested classes, but beyond level two it is quickly becoming an annoyance.",
    "created_at": "2014-01-22T13:50:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109258",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:471'></a>
Replying to [nthiery](#comment%3A470):
> Replying to [vbraun](#comment%3A467):
> Why is there a single defining axiom, the self._axiom attribute?
> See [comment:464]. One wants to be incremental in most cases
> anyway.

I'm not talking about the user interface with the successive `category.Axiom()` factory methods (implemented as actual methods or `__classcall__`). I'm talking about the code layout, where deeply nested classes are rather cumbersome. There, I don't want to be forced to add one axiom at a time if I only have code to attach to the case of multiple axioms. I especially don't want five-fold nested classes just to express that I want factory methods for those five. 

> But there is no standard implementation and syntax for dynamic mixins.

True, but there are only two sane options: Either use some tricks to turn the static into dynamic mixins (the DWIM principle) or explicitly specify the dynamic mixins in a class atttribute. Really, that just boils down to using either inheritance or object composition to express relations between classes in code.

> I believe nested classes are an *opportunity* given to us by Python to
> structure the code; it just has been under-exploited yet.

I'm happy with nested classes, but beyond level two it is quickly becoming an annoyance.



---

archive/issue_comments_109259.json:
```json
{
    "body": "<a id='comment:472'></a>\nHellooooo !!\n\n> How could such syntax look like? Of course, we can have a separate class `ABs`, and then let both `As.B` and `Bs.A` point to it. But even when you write down the name `ABs`, you already have a choice to do---after all, why don't you chose `BAs` instead of `ABs`.\n\nHmmmm... Well, I understand *NOTHING* of what the current syntax currently is, so I probably cannot help. The point is that in the end, the exact NAME of the class you create does not really matter much, as what is important is how you access it. You probably never instanciate the class itself (unless it has a sensible name of its own which is not a sequence of axioms). Thus it would be cool if you could just implement it wherever you wish, and have one of its fields be `_my_set_of_axioms = set([\"Finite\",\"Green\"])`. There is no specific order to respect anyway as the only technical information you provide is a set. And the spanning tree thing shouldn't even be the coder's problem. No reason why he should even be aware of its existence, as he only wants to implement a category with some given axioms.\n\n> Well, this is my suggestion for the future.\n\nOh. That looks like the kind of interface stuff that should be settled from the start. Everything which is \"for the future\" rarely gets implemented `:-P`\n\n> Really? I always thought of *rooted* trees (and that's what we have here) as being directed.\n\nAway from the root ? Toward the root ? That's what the out- in out-arborescence encodes. And they just avoid using the word \"tree\" for a directed graph. I don't say that it makes sense `:-P`\n\nNathann",
    "created_at": "2014-01-22T16:26:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109259",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:472'></a>
Hellooooo !!

> How could such syntax look like? Of course, we can have a separate class `ABs`, and then let both `As.B` and `Bs.A` point to it. But even when you write down the name `ABs`, you already have a choice to do---after all, why don't you chose `BAs` instead of `ABs`.

Hmmmm... Well, I understand *NOTHING* of what the current syntax currently is, so I probably cannot help. The point is that in the end, the exact NAME of the class you create does not really matter much, as what is important is how you access it. You probably never instanciate the class itself (unless it has a sensible name of its own which is not a sequence of axioms). Thus it would be cool if you could just implement it wherever you wish, and have one of its fields be `_my_set_of_axioms = set(["Finite","Green"])`. There is no specific order to respect anyway as the only technical information you provide is a set. And the spanning tree thing shouldn't even be the coder's problem. No reason why he should even be aware of its existence, as he only wants to implement a category with some given axioms.

> Well, this is my suggestion for the future.

Oh. That looks like the kind of interface stuff that should be settled from the start. Everything which is "for the future" rarely gets implemented `:-P`

> Really? I always thought of *rooted* trees (and that's what we have here) as being directed.

Away from the root ? Toward the root ? That's what the out- in out-arborescence encodes. And they just avoid using the word "tree" for a directed graph. I don't say that it makes sense `:-P`

Nathann



---

archive/issue_comments_109260.json:
```json
{
    "body": "<a id='comment:3'></a>\nEdit: Never mind, wrong branch.",
    "created_at": "2014-01-22T17:41:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109260",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:3'></a>
Edit: Never mind, wrong branch.



---

archive/issue_comments_109261.json:
```json
{
    "body": "<a id='comment:474'></a>\nReplying to [nthiery](#comment%3A465):\n> Replying to [pbruin](#comment%3A450):\n> > Maybe the quickest solution is to insert better-named aliases for these, rename the method `summands()` introduced here, and later deprecate `summand_projection()` and `summand_split()` in a different ticket.\n> > \n> > My first reflex would be to rename `summand_projection()` to `projection()` and `summand_split()` to `tuple()`.\n\n> \n> If you believe this is urgent enough to belong to #10963, then please\n> go ahead, and I'll review it.\n\nNot sure if 'urgent' is the right word, but it would be better to give method the right name from the start rather than using a less-than-ideal name for consistency with other less-than-ideal names...\n\n> To raise any confusion: I mean that if you construct a monoid M as a\n> cartesian product of other monoids, you would get a `M.factors()`\n> method which would have nothing to do with the concept of\n> factorization in the monoid M.\n\nI see.  How about\n\n```\nsummand_projection() -> cartesian_projection()\nsummand_split() -> cartesian_factors()\nsummands() -> cartesian_factors()\n```\nIn particular, the fact that the last two are equal would be nicely consistent with the fact that we already have `cartesian_product()` both for parents and for elements.",
    "created_at": "2014-01-22T18:56:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109261",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:474'></a>
Replying to [nthiery](#comment%3A465):
> Replying to [pbruin](#comment%3A450):
> > Maybe the quickest solution is to insert better-named aliases for these, rename the method `summands()` introduced here, and later deprecate `summand_projection()` and `summand_split()` in a different ticket.
> > 
> > My first reflex would be to rename `summand_projection()` to `projection()` and `summand_split()` to `tuple()`.

> 
> If you believe this is urgent enough to belong to #10963, then please
> go ahead, and I'll review it.

Not sure if 'urgent' is the right word, but it would be better to give method the right name from the start rather than using a less-than-ideal name for consistency with other less-than-ideal names...

> To raise any confusion: I mean that if you construct a monoid M as a
> cartesian product of other monoids, you would get a `M.factors()`
> method which would have nothing to do with the concept of
> factorization in the monoid M.

I see.  How about

```
summand_projection() -> cartesian_projection()
summand_split() -> cartesian_factors()
summands() -> cartesian_factors()
```
In particular, the fact that the last two are equal would be nicely consistent with the fact that we already have `cartesian_product()` both for parents and for elements.



---

archive/issue_comments_109262.json:
```json
{
    "body": "<a id='comment:5'></a>\nThis [sage-devel thread](https://groups.google.com/forum/#!topic/sage-devel/lODVhZRT4RE) is probably a good real-world example for how careful one should be messing about with attribute lookups and mro manipulations in python:\n\nTo avoid the need to explicitly chain parts of the `__init__` process, the category framework supplies `__init_extra__` hooks, which should get executed for all the classes in the mro. It does so by looking for `__init_extra__` entries in each of `[C.__dict__ for C in class.mro()]`, or something roughly equivalent.\n\nProblem: that doesn't test whether attributes are present if classes implement a custom `__getattr__`. And Parent does that, to ensure that dynamic classes get faked for `cdef` classes. So `__init_extra__` has never worked properly for `cdef` classes.\n\nIt may well be that axioms defer to already-existing black magic for these things, in which case this ticket doesn't really make things better or worse in this respect, but it is clear that the scenario above was not considered by the designers of the category framework before, so it's worth checking how the code here is affected by it.",
    "created_at": "2014-01-23T16:25:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109262",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:5'></a>
This [sage-devel thread](https://groups.google.com/forum/#!topic/sage-devel/lODVhZRT4RE) is probably a good real-world example for how careful one should be messing about with attribute lookups and mro manipulations in python:

To avoid the need to explicitly chain parts of the `__init__` process, the category framework supplies `__init_extra__` hooks, which should get executed for all the classes in the mro. It does so by looking for `__init_extra__` entries in each of `[C.__dict__ for C in class.mro()]`, or something roughly equivalent.

Problem: that doesn't test whether attributes are present if classes implement a custom `__getattr__`. And Parent does that, to ensure that dynamic classes get faked for `cdef` classes. So `__init_extra__` has never worked properly for `cdef` classes.

It may well be that axioms defer to already-existing black magic for these things, in which case this ticket doesn't really make things better or worse in this respect, but it is clear that the scenario above was not considered by the designers of the category framework before, so it's worth checking how the code here is affected by it.



---

archive/issue_comments_109263.json:
```json
{
    "body": "<a id='comment:476'></a>\nHi Nils!\n\nReplying to [nbruin](#comment%3A475):\n> This [sage-devel thread](https://groups.google.com/forum/#!topic/sage-devel/lODVhZRT4RE) is probably a good real-world example for how careful one should be messing about with attribute lookups and mro manipulations in python:\n> \n> To avoid the need to explicitly chain parts of the `__init__` process, the category framework supplies `__init_extra__` hooks, which should get executed for all the classes in the mro. It does so by looking for `__init_extra__` entries in each of `[C.__dict__ for C in class.mro()]`, or something roughly equivalent.\n> \n> Problem: that doesn't test whether attributes are present if classes implement a custom `__getattr__`. And Parent does that, to ensure that dynamic classes get faked for `cdef` classes. So `__init_extra__` has never worked properly for `cdef` classes.\n\nThanks for investigating!\n\nI definitely agree: playing with `__getattr__` is generally best\navoided, as it deviates from standard inheritance and is just a can of\nworm when it comes to robust introspection and the like. Back in 2009,\nit took a long discussion until I could make my point that the\napproach of changing the class of the parent to a subclass inheriting\nfrom the category classes was a much better solution :-)\n\nThe current `__getattr__` hack for Cython classes is just a\nworkaround, but as far as I know, we have no better solution for\nnow. And as long as this will be the case, the support for categories\nwill always be somewhat fragile for Cython classes. I am not surprised\nthat the `__init_extra__` fails. I probably stumbled on it at some point\nand I should have documented it in a ticket; this is now #15718: do\nyou mind adding some example from the discussion on sage-devel there?\nThanks!\n\nBut there is hope: I have discussed this a couple times with Robert\nBradshaw, and there is no theoretical obstacle in having a Cython\nclass support multiple inheritance from a hierarchy of *abstract\nclasses*. It just has not been implemented.\n\nAs a general comment, combining the performance of statically compiled\ncode with the flexibility that dynamical approaches give for\ngenericity is a hard problem that can't be tackled at once. I very\nmuch would like to see more developers that have a genuine need for\nCython classes get their hands dirty improving the category framework\nin this direction. In particular pushing for the appropriate\nfeature(s) in Cython. And fixing #15718 (which should be easy). But\nthat's for another thread, probably on sage-devel.\n\nBy the way:\n\n- As much as Cython can be critical for implementing elements, in\n  particular for low level arithmetic, as much one needs to consider\n  twice the added value of having a Cythoned parent.\n\n- The `__init_extra__` protocol is usually best avoided when it comes to\n  assigning values to attributes, as this is not a lazy enough. Lazy\n  attributes are a better bet, especially since Simon's hard work to\n  make them work properly for Cython classes.\n\n- The current protocol handling the .one() method is too convoluted,\n  in particular due handling backward compatibility. With a bit of\n  refactoring of legacy code, in particular around polynomials, it\n  probably could and should be simplified. Simon: do we already have a\n  ticket for this?\n\n> It may well be that axioms defer to already-existing black magic for these things, in which case this ticket doesn't really make things better or worse in this respect, but it is clear that the scenario above was not considered by the designers of the category framework before, so it's worth checking how the code here is affected by it.\n\nThis ticket is only about the construction of categories (which are\nPython classes), and all the magic happens at this level. So we should\nbe safe.\n\nCheers,\n                             Nicolas",
    "created_at": "2014-01-23T17:24:48Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109263",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:476'></a>
Hi Nils!

Replying to [nbruin](#comment%3A475):
> This [sage-devel thread](https://groups.google.com/forum/#!topic/sage-devel/lODVhZRT4RE) is probably a good real-world example for how careful one should be messing about with attribute lookups and mro manipulations in python:
> 
> To avoid the need to explicitly chain parts of the `__init__` process, the category framework supplies `__init_extra__` hooks, which should get executed for all the classes in the mro. It does so by looking for `__init_extra__` entries in each of `[C.__dict__ for C in class.mro()]`, or something roughly equivalent.
> 
> Problem: that doesn't test whether attributes are present if classes implement a custom `__getattr__`. And Parent does that, to ensure that dynamic classes get faked for `cdef` classes. So `__init_extra__` has never worked properly for `cdef` classes.

Thanks for investigating!

I definitely agree: playing with `__getattr__` is generally best
avoided, as it deviates from standard inheritance and is just a can of
worm when it comes to robust introspection and the like. Back in 2009,
it took a long discussion until I could make my point that the
approach of changing the class of the parent to a subclass inheriting
from the category classes was a much better solution :-)

The current `__getattr__` hack for Cython classes is just a
workaround, but as far as I know, we have no better solution for
now. And as long as this will be the case, the support for categories
will always be somewhat fragile for Cython classes. I am not surprised
that the `__init_extra__` fails. I probably stumbled on it at some point
and I should have documented it in a ticket; this is now #15718: do
you mind adding some example from the discussion on sage-devel there?
Thanks!

But there is hope: I have discussed this a couple times with Robert
Bradshaw, and there is no theoretical obstacle in having a Cython
class support multiple inheritance from a hierarchy of *abstract
classes*. It just has not been implemented.

As a general comment, combining the performance of statically compiled
code with the flexibility that dynamical approaches give for
genericity is a hard problem that can't be tackled at once. I very
much would like to see more developers that have a genuine need for
Cython classes get their hands dirty improving the category framework
in this direction. In particular pushing for the appropriate
feature(s) in Cython. And fixing #15718 (which should be easy). But
that's for another thread, probably on sage-devel.

By the way:

- As much as Cython can be critical for implementing elements, in
  particular for low level arithmetic, as much one needs to consider
  twice the added value of having a Cythoned parent.

- The `__init_extra__` protocol is usually best avoided when it comes to
  assigning values to attributes, as this is not a lazy enough. Lazy
  attributes are a better bet, especially since Simon's hard work to
  make them work properly for Cython classes.

- The current protocol handling the .one() method is too convoluted,
  in particular due handling backward compatibility. With a bit of
  refactoring of legacy code, in particular around polynomials, it
  probably could and should be simplified. Simon: do we already have a
  ticket for this?

> It may well be that axioms defer to already-existing black magic for these things, in which case this ticket doesn't really make things better or worse in this respect, but it is clear that the scenario above was not considered by the designers of the category framework before, so it's worth checking how the code here is affected by it.

This ticket is only about the construction of categories (which are
Python classes), and all the magic happens at this level. So we should
be safe.

Cheers,
                             Nicolas



---

archive/issue_comments_109264.json:
```json
{
    "body": "<a id='comment:477'></a>\nHi Peter!\n\nReplying to [pbruin](#comment%3A474):\n> Not sure if 'urgent' is the right word, but it would be better to give method the right name from the start rather than using a less-than-ideal name for consistency with other less-than-ideal names...\n\nAgreed: it's just a question of manpower :-)\n\n> > To raise any confusion: I mean that if you construct a monoid M as a\n> > cartesian product of other monoids, you would get a `M.factors()`\n> > method which would have nothing to do with the concept of\n> > factorization in the monoid M.\n\n> \n> I see.  How about\n> \n> ```\n> summand_projection() -> cartesian_projection()\n> summand_split() -> cartesian_factors()\n> summands() -> cartesian_factors()\n> ```\n> In particular, the fact that the last two are equal would be nicely consistent with the fact that we already have `cartesian_product()` both for parents and for elements.\n\nSounds reasonable to me. If nobody suggests a better suggestion now, please proceed!\n\nCheers,\n                             Nicolas",
    "created_at": "2014-01-23T17:28:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109264",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:477'></a>
Hi Peter!

Replying to [pbruin](#comment%3A474):
> Not sure if 'urgent' is the right word, but it would be better to give method the right name from the start rather than using a less-than-ideal name for consistency with other less-than-ideal names...

Agreed: it's just a question of manpower :-)

> > To raise any confusion: I mean that if you construct a monoid M as a
> > cartesian product of other monoids, you would get a `M.factors()`
> > method which would have nothing to do with the concept of
> > factorization in the monoid M.

> 
> I see.  How about
> 
> ```
> summand_projection() -> cartesian_projection()
> summand_split() -> cartesian_factors()
> summands() -> cartesian_factors()
> ```
> In particular, the fact that the last two are equal would be nicely consistent with the fact that we already have `cartesian_product()` both for parents and for elements.

Sounds reasonable to me. If nobody suggests a better suggestion now, please proceed!

Cheers,
                             Nicolas



---

archive/issue_comments_109265.json:
```json
{
    "body": "<a id='comment:478'></a>\nReplying to [nthiery](#comment%3A476):\n> - As much as Cython can be critical for implementing elements, in\n>   particular for low level arithmetic, as much one needs to consider\n>   twice the added value of having a Cythoned parent.\n\n+1. But things currently are as they are.\n \n> - The `__init_extra__` protocol is usually best avoided when it comes to\n>   assigning values to attributes, as this is not a lazy enough. Lazy\n>   attributes are a better bet, especially since Simon's hard work to\n>   make them work properly for Cython classes.\n\nOK, but in this particular example it is all about registering a coercion. That's not just done by a lazy attribute.\n\n> - The current protocol handling the .one() method is too convoluted,\n>   in particular due handling backward compatibility. With a bit of\n>   refactoring of legacy code, in particular around polynomials, it\n>   probably could and should be simplified. Simon: do we already have a\n>   ticket for this?\n\nNone that I am aware of.\n\n> This ticket is only about the construction of categories (which are\n> Python classes), and all the magic happens at this level. So we should\n> be safe.\n\n+1",
    "created_at": "2014-01-23T18:07:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109265",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:478'></a>
Replying to [nthiery](#comment%3A476):
> - As much as Cython can be critical for implementing elements, in
>   particular for low level arithmetic, as much one needs to consider
>   twice the added value of having a Cythoned parent.

+1. But things currently are as they are.
 
> - The `__init_extra__` protocol is usually best avoided when it comes to
>   assigning values to attributes, as this is not a lazy enough. Lazy
>   attributes are a better bet, especially since Simon's hard work to
>   make them work properly for Cython classes.

OK, but in this particular example it is all about registering a coercion. That's not just done by a lazy attribute.

> - The current protocol handling the .one() method is too convoluted,
>   in particular due handling backward compatibility. With a bit of
>   refactoring of legacy code, in particular around polynomials, it
>   probably could and should be simplified. Simon: do we already have a
>   ticket for this?

None that I am aware of.

> This ticket is only about the construction of categories (which are
> Python classes), and all the magic happens at this level. So we should
> be safe.

+1



---

archive/issue_comments_109266.json:
```json
{
    "body": "<a id='comment:479'></a>\nReplying to [nthiery](#comment%3A477):\n> > I see.  How about\n> > \n> > ```\n> > summand_projection() -> cartesian_projection()\n> > summand_split() -> cartesian_factors()\n> > summands() -> cartesian_factors()\n> > ```\n> > In particular, the fact that the last two are equal would be nicely consistent with the fact that we already have `cartesian_product()` both for parents and for elements.\n\n> \n> Sounds reasonable to me. If nobody suggests a better suggestion now, please proceed!\n\nI made these changes in a new branch, `u/pbruin/10963-rename_summand_methods` (based on this one).  It deprecates the `summand_*` methods of Cartesian products of sets, but not of `CombinatorialFreeModule`s (since products and sums of those are the same).",
    "created_at": "2014-01-27T14:35:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109266",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:479'></a>
Replying to [nthiery](#comment%3A477):
> > I see.  How about
> > 
> > ```
> > summand_projection() -> cartesian_projection()
> > summand_split() -> cartesian_factors()
> > summands() -> cartesian_factors()
> > ```
> > In particular, the fact that the last two are equal would be nicely consistent with the fact that we already have `cartesian_product()` both for parents and for elements.

> 
> Sounds reasonable to me. If nobody suggests a better suggestion now, please proceed!

I made these changes in a new branch, `u/pbruin/10963-rename_summand_methods` (based on this one).  It deprecates the `summand_*` methods of Cartesian products of sets, but not of `CombinatorialFreeModule`s (since products and sums of those are the same).



---

archive/issue_comments_109267.json:
```json
{
    "body": "<a id='comment:480'></a>\nReplying to [pbruin](#comment%3A479):\n> I made these changes in a new branch, `u/pbruin/10963-rename_summand_methods` (based on this one).  It deprecates the `summand_*` methods of Cartesian products of sets, but not of `CombinatorialFreeModule`s (since products and sums of those are the same).\n\nGreat, thanks a lot!\n\nI'll try to review this soon; hopefully tomorrow, network permitting.\n\nCheers,\n                  Nicolas",
    "created_at": "2014-01-27T22:55:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109267",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:480'></a>
Replying to [pbruin](#comment%3A479):
> I made these changes in a new branch, `u/pbruin/10963-rename_summand_methods` (based on this one).  It deprecates the `summand_*` methods of Cartesian products of sets, but not of `CombinatorialFreeModule`s (since products and sums of those are the same).

Great, thanks a lot!

I'll try to review this soon; hopefully tomorrow, network permitting.

Cheers,
                  Nicolas



---

archive/issue_comments_109268.json:
```json
{
    "body": "<a id='comment:1'></a>\nSome good news:\n\n- There actually is an easy workaround for implementing axioms like\n  Distributive whose highest category class is a join. Now I can do:\n\n  ```\n      sage: (CommutativeAdditiveGroups() & Monoids()).Distributive()\n      Category of rings\n  ```\n\n  It's not perfect though. The caveats are described in the\n  documentation: two are really minor, one a bit more annoying. But at\n  least it implements the above very natural notation right now until\n  a better solution is found!\n\n- The (sketch of) proof of the infrastructure is finished.\n\n  A nice feature is that the specifications were actually more\n  stringent than necessary, as I first found out while searching for\n  counter examples:\n\n  It actually would be very well possible to implement `FiniteFields` as\n  `DivisionRings.Finite` rather than as `Fields.Finite`!\n\n  The infinite recursions I was previously getting were apparently\n  just due to caveats in earlier implementations. With that, we could\n  possibly get rid of the ``A_extra_super_categories`` hook mechanism;\n  however this mechanism brings more flexibility in the organization\n  of the code, so I'd rather keep it.\n\n- The axiom documentation should be rather complete and in particular\n  include discussions for all the points that were raised recently on\n  the ticket.\n\nPushed to u/nthiery/ticket/10963 and compiled doc on [1], as usual.\n\nPlease check out and review!\n\nCheers,\n                                     Nicolas\n\n[1] http://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/category_with_axiom.html",
    "created_at": "2014-01-27T23:17:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109268",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:1'></a>
Some good news:

- There actually is an easy workaround for implementing axioms like
  Distributive whose highest category class is a join. Now I can do:

  ```
      sage: (CommutativeAdditiveGroups() & Monoids()).Distributive()
      Category of rings
  ```

  It's not perfect though. The caveats are described in the
  documentation: two are really minor, one a bit more annoying. But at
  least it implements the above very natural notation right now until
  a better solution is found!

- The (sketch of) proof of the infrastructure is finished.

  A nice feature is that the specifications were actually more
  stringent than necessary, as I first found out while searching for
  counter examples:

  It actually would be very well possible to implement `FiniteFields` as
  `DivisionRings.Finite` rather than as `Fields.Finite`!

  The infinite recursions I was previously getting were apparently
  just due to caveats in earlier implementations. With that, we could
  possibly get rid of the ``A_extra_super_categories`` hook mechanism;
  however this mechanism brings more flexibility in the organization
  of the code, so I'd rather keep it.

- The axiom documentation should be rather complete and in particular
  include discussions for all the points that were raised recently on
  the ticket.

Pushed to u/nthiery/ticket/10963 and compiled doc on [1], as usual.

Please check out and review!

Cheers,
                                     Nicolas

[1] http://sage.math.washington.edu/home/nthiery/sage-6.0/src/doc/output/html/en/reference/categories/sage/categories/category_with_axiom.html



---

archive/issue_comments_109269.json:
```json
{
    "body": "<a id='comment:2'></a>\nI'm agreeing with Simon more and more that we should separate out the whole code for finding the normal form for the catogory-with-axiom. Right now its buried in the whole category framework, you can't doctest it independently, and it requires duplicate information. Its also pretty hard to follow. Not to mention the whole `A_extra_super_categories` business. Moreover, if we ever want to use pre-computed information we have to do it anyways. It also parallels the aforementioned abc module, you define your categories and then register them with a category-axiom-manager. We can easily have some syntactic sugar to make the registration process automatic for inner classes. \n\nOnce you accept that, I don't see a reason to do category-with-axiom as composition. Just inherit and use a dynamic metaclass for Category to \n* build the category-with-axioms from the Axiom subclasses we inherit from\n* for any Axiom attribute: register that as an applicable axiom, generate a factory method, and register with the category-axiom-manager.\n\nSo in an example, the manual construction would be:\n\n```python\nclass Test1(Category):\n\n    def super_categories(self):\n        return []\n\n    Infinite1 = axioms.Infinite  # parsed by the metaclass\n        \n    Finite1 = axioms.Finite     \n\n\nclass FiniteTest1(Test1, axioms.Finite):\n     # ... extra code if desired ...\n\n\nassert Test1.Finite1() is FiniteTest1()\nTest1.Infinite1()    # automatically generated anonymous class\n```\n\nOr using inner class syntax \n\n```python\nclass Test2(Category):\n\n    def super_categories(self):\n        return []\n\n    Infinite2 = axioms.Infinite\n        \n    class Finite2(axioms.Finite):\n        # ... extra code if desired ...\n```\n\nUnless you define `FiniteTest1` in a separate module, the metaclass gets enough information to figure out where we provide a category-with-axioms and where it has to be dynamically generated. Any further relations must be provided explicitly. I'm currently working on a proof-of-concept code, will post that when its finished.",
    "created_at": "2014-01-28T01:25:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109269",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:2'></a>
I'm agreeing with Simon more and more that we should separate out the whole code for finding the normal form for the catogory-with-axiom. Right now its buried in the whole category framework, you can't doctest it independently, and it requires duplicate information. Its also pretty hard to follow. Not to mention the whole `A_extra_super_categories` business. Moreover, if we ever want to use pre-computed information we have to do it anyways. It also parallels the aforementioned abc module, you define your categories and then register them with a category-axiom-manager. We can easily have some syntactic sugar to make the registration process automatic for inner classes. 

Once you accept that, I don't see a reason to do category-with-axiom as composition. Just inherit and use a dynamic metaclass for Category to 
* build the category-with-axioms from the Axiom subclasses we inherit from
* for any Axiom attribute: register that as an applicable axiom, generate a factory method, and register with the category-axiom-manager.

So in an example, the manual construction would be:

```python
class Test1(Category):

    def super_categories(self):
        return []

    Infinite1 = axioms.Infinite  # parsed by the metaclass
        
    Finite1 = axioms.Finite     


class FiniteTest1(Test1, axioms.Finite):
     # ... extra code if desired ...


assert Test1.Finite1() is FiniteTest1()
Test1.Infinite1()    # automatically generated anonymous class
```

Or using inner class syntax 

```python
class Test2(Category):

    def super_categories(self):
        return []

    Infinite2 = axioms.Infinite
        
    class Finite2(axioms.Finite):
        # ... extra code if desired ...
```

Unless you define `FiniteTest1` in a separate module, the metaclass gets enough information to figure out where we provide a category-with-axioms and where it has to be dynamically generated. Any further relations must be provided explicitly. I'm currently working on a proof-of-concept code, will post that when its finished.



---

archive/issue_comments_109270.json:
```json
{
    "body": "<a id='comment:483'></a>\nReplying to [vbraun](#comment%3A482):\n> I'm agreeing with Simon more and more that we should separate out the whole code for finding the normal form for the catogory-with-axiom. Right now its buried in the whole category framework, you can't doctest it independently,\n\nAgreed (though, implementing arithmetic on some objects in the class\nfor those objects is not totally unusual).\n\n> and it requires duplicate information.\n\nRight (though only to support the notation FiniteGroups() which we may\nwant to deprecate anyway; see the discussion in the documentation).\n\n> Its also pretty hard to follow.\n\nPlease read the documentation and tell me if it clarifies things out.\n\n> ... We can easily have some syntactic sugar to make the registration process automatic for inner classes.\n> ... alternative proposal ...\n> I'm currently working on a proof-of-concept code, will post that when its finished.\n\nThanks! I am glad you are investigating improvements on the current\ninfrastructure. Some small comments:\n\n- Please include in your proof-of-concept an example showcasing that\n  we can properly support lazy importing categories with axioms.\n\n- Ah, another thing about the above potential notations: having\n  FiniteTest1 inherit from Test1 as idiom suggests that there is an\n  *Is A* relation between the category of finite test1s and the\n  category of test1s, which is wrong. Similarly, having FiniteTest1\n  inherit from axioms.Finite suggests that FiniteTest1 is an axiom,\n  when it actually is a category. I am not saying that those\n  violations of the basic rules of object oriented programming are\n  show stoppers if they bring convenient notations. But this is to be\n  put in balance with the inconvenients of the current\n  infrastructure. Or just fixed by exploring variants of the above\n  notations.\n\nBut back to the main point. As you said, the would-be\ncategory-with-axiom manager should support the current nested class\nsyntax. So, migrating over code using the current infrastructure\nshould be easy.\n\nHence, the most important question is: should the experimentation and implementation of this manager be for this ticket or for a follow-up ticket.\n\n                          Nicolas",
    "created_at": "2014-01-28T08:33:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109270",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:483'></a>
Replying to [vbraun](#comment%3A482):
> I'm agreeing with Simon more and more that we should separate out the whole code for finding the normal form for the catogory-with-axiom. Right now its buried in the whole category framework, you can't doctest it independently,

Agreed (though, implementing arithmetic on some objects in the class
for those objects is not totally unusual).

> and it requires duplicate information.

Right (though only to support the notation FiniteGroups() which we may
want to deprecate anyway; see the discussion in the documentation).

> Its also pretty hard to follow.

Please read the documentation and tell me if it clarifies things out.

> ... We can easily have some syntactic sugar to make the registration process automatic for inner classes.
> ... alternative proposal ...
> I'm currently working on a proof-of-concept code, will post that when its finished.

Thanks! I am glad you are investigating improvements on the current
infrastructure. Some small comments:

- Please include in your proof-of-concept an example showcasing that
  we can properly support lazy importing categories with axioms.

- Ah, another thing about the above potential notations: having
  FiniteTest1 inherit from Test1 as idiom suggests that there is an
  *Is A* relation between the category of finite test1s and the
  category of test1s, which is wrong. Similarly, having FiniteTest1
  inherit from axioms.Finite suggests that FiniteTest1 is an axiom,
  when it actually is a category. I am not saying that those
  violations of the basic rules of object oriented programming are
  show stoppers if they bring convenient notations. But this is to be
  put in balance with the inconvenients of the current
  infrastructure. Or just fixed by exploring variants of the above
  notations.

But back to the main point. As you said, the would-be
category-with-axiom manager should support the current nested class
syntax. So, migrating over code using the current infrastructure
should be easy.

Hence, the most important question is: should the experimentation and implementation of this manager be for this ticket or for a follow-up ticket.

                          Nicolas



---

archive/issue_comments_109271.json:
```json
{
    "body": "<a id='comment:484'></a>\nReplying to [nthiery](#comment%3A483):\n> - Ah, another thing about the above potential notations: having\n>   FiniteTest1 inherit from Test1 as idiom suggests that there is an\n>   *Is A* relation between the category of finite test1s and the\n>   category of test1s, which is wrong.\n\nCan you be more specific what the problem is? A `finite_foo` is a `foo`, but not the other way round. An immutable square is an immutable rectangle. \n\n>   Similarly, having FiniteTest1\n>   inherit from axioms.Finite suggests that FiniteTest1 is an axiom,\n>   when it actually is a category.\n\n`FiniteTest1` inherits first of all from `Category`. I presume you mean `Finite2`, which cannot inherit from `Test2` because it is an inner class. It could inherit directly from `Category` to make that clear(er), which I tend to agree with.\n\n> But back to the main point. As you said, the would-be\n> category-with-axiom manager should support the current nested class\n> syntax.\n\nExcept that the relations should be specified explicitly, as in e.g.\n\n```python\ncategory_axiom_model.add_relation(\n    [Rings(), axiom.Division(), axiom.Finite()],\n    [Fields(), axiom.Finite()],\n    description=\"Wedderburn's Theorem\")\n)\n```\nduring the instantiation of either Rings or Fields",
    "created_at": "2014-01-28T11:48:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109271",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:484'></a>
Replying to [nthiery](#comment%3A483):
> - Ah, another thing about the above potential notations: having
>   FiniteTest1 inherit from Test1 as idiom suggests that there is an
>   *Is A* relation between the category of finite test1s and the
>   category of test1s, which is wrong.

Can you be more specific what the problem is? A `finite_foo` is a `foo`, but not the other way round. An immutable square is an immutable rectangle. 

>   Similarly, having FiniteTest1
>   inherit from axioms.Finite suggests that FiniteTest1 is an axiom,
>   when it actually is a category.

`FiniteTest1` inherits first of all from `Category`. I presume you mean `Finite2`, which cannot inherit from `Test2` because it is an inner class. It could inherit directly from `Category` to make that clear(er), which I tend to agree with.

> But back to the main point. As you said, the would-be
> category-with-axiom manager should support the current nested class
> syntax.

Except that the relations should be specified explicitly, as in e.g.

```python
category_axiom_model.add_relation(
    [Rings(), axiom.Division(), axiom.Finite()],
    [Fields(), axiom.Finite()],
    description="Wedderburn's Theorem")
)
```
during the instantiation of either Rings or Fields



---

archive/issue_comments_109272.json:
```json
{
    "body": "<a id='comment:485'></a>\nReplying to [vbraun](#comment%3A484):\n> Replying to [nthiery](#comment%3A483):\n> > - Ah, another thing about the above potential notations: having\n> >   FiniteTest1 inherit from Test1 as idiom suggests that there is an\n> >   *Is A* relation between the category of finite test1s and the\n> >   category of test1s, which is wrong.\n\n> \n> Can you be more specific what the problem is? A `finite_foo` is a `foo`.\n\nDefinitely, and this modeled by the fact that\nFiniteFoos().parent_class inherits from Foos().parent_class. And\nsimilarly for element_class.\n\nWhat I meant however is that, at the level of categories, the\n\"super-category\" relation should not be modeled by inheritance. In our\nexample an instance of Foos models the category of all Foos. So the\ncategory of finite foos, a strict subset, cannot be an instance of\nFoos.\n\n> >   Similarly, having FiniteTest1\n> >   inherit from axioms.Finite suggests that FiniteTest1 is an axiom,\n> >   when it actually is a category.\n\n> \n> `FiniteTest1` inherits first of all from `Category`. I presume you mean `Finite2`, which cannot inherit from `Test2` because it is an inner class. It could inherit directly from `Category` to make that clear(er), which I tend to agree with.\n\nI really meant `FiniteTest1`. In:\n\n```\n    class FiniteTest1(Test1, axioms.Finite):\n```\neven if axioms.Finite appears second, it's still a superclass, and the\nisA relation should be satisfied.\n\n> Except that the relations should be specified explicitly, as in e.g.\n> \n> ```python\n> category_axiom_model.add_relation(\n>     [Rings(), axiom.Division(), axiom.Finite()],\n>     [Fields(), axiom.Finite()],\n>     description=\"Wedderburn's Theorem\")\n> )\n> ```\n> during the instantiation of either Rings or Fields\n\nHmm, let's see how it feels in practice at a larger scale. If this is\nonly needed for deduction rules, the refactoring would be easy.\n\nWhat time line do you foresee:\n- Having a proof of concept for the category-and-axiom-manager\n- Refactoring the whole code according to it\n- Getting it ready for integration\n\nBest,\n                              Nicolas",
    "created_at": "2014-01-29T06:04:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109272",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:485'></a>
Replying to [vbraun](#comment%3A484):
> Replying to [nthiery](#comment%3A483):
> > - Ah, another thing about the above potential notations: having
> >   FiniteTest1 inherit from Test1 as idiom suggests that there is an
> >   *Is A* relation between the category of finite test1s and the
> >   category of test1s, which is wrong.

> 
> Can you be more specific what the problem is? A `finite_foo` is a `foo`.

Definitely, and this modeled by the fact that
FiniteFoos().parent_class inherits from Foos().parent_class. And
similarly for element_class.

What I meant however is that, at the level of categories, the
"super-category" relation should not be modeled by inheritance. In our
example an instance of Foos models the category of all Foos. So the
category of finite foos, a strict subset, cannot be an instance of
Foos.

> >   Similarly, having FiniteTest1
> >   inherit from axioms.Finite suggests that FiniteTest1 is an axiom,
> >   when it actually is a category.

> 
> `FiniteTest1` inherits first of all from `Category`. I presume you mean `Finite2`, which cannot inherit from `Test2` because it is an inner class. It could inherit directly from `Category` to make that clear(er), which I tend to agree with.

I really meant `FiniteTest1`. In:

```
    class FiniteTest1(Test1, axioms.Finite):
```
even if axioms.Finite appears second, it's still a superclass, and the
isA relation should be satisfied.

> Except that the relations should be specified explicitly, as in e.g.
> 
> ```python
> category_axiom_model.add_relation(
>     [Rings(), axiom.Division(), axiom.Finite()],
>     [Fields(), axiom.Finite()],
>     description="Wedderburn's Theorem")
> )
> ```
> during the instantiation of either Rings or Fields

Hmm, let's see how it feels in practice at a larger scale. If this is
only needed for deduction rules, the refactoring would be easy.

What time line do you foresee:
- Having a proof of concept for the category-and-axiom-manager
- Refactoring the whole code according to it
- Getting it ready for integration

Best,
                              Nicolas



---

archive/issue_comments_109273.json:
```json
{
    "body": "<a id='comment:486'></a>\nReplying to [nthiery](#comment%3A485):\n> What I meant however is that, at the level of categories, the\n> \"super-category\" relation should not be modeled by inheritance.\n\nMust not, should not, need not? I agree, of course, that the category-relationship is unrelated to the object-relationship. But if its convenient to define your category by object-inheriting from another category, then why not?  \n\nI would prefer to treat axioms as independent from categories (i.e. they don't inherit from Category). That then also gives you a non-category object that you can use to represent the axiom. Now, since you always have to create (manually or dynamically) a new class for a category-with-axiom it might just as well inherit from the axiom class(es). Though if you think its confusing then I'm also open to using a special class attribute and composition.\n\nNow for something different. For the super categories, is the following what we really want? Its good enough for figuring out the methods, but does contradict the `super_category` documentation:\n\n```python\nclass Base(Category_singleton):\n    def super_categories(self):\n        return [Objects()]\n\n    class SubcategoryMethods:\n        A = axiom(\"A\")\n        B = axiom(\"B\")\n        C = axiom(\"C\")\n\n    class A(CategoryWithAxiom):\n        pass\n    class B(CategoryWithAxiom):\n        pass\n    class C(CategoryWithAxiom):\n        pass\n\nBase().A()     in Base.A().B().C().super_categories()     # True, even though not direct supercategory\nBase().A().B() in Base.A().B().C().super_categories()     # False\nBase().A().B() in Base.A().B().C().all_super_categories() # False\n```",
    "created_at": "2014-01-29T14:26:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109273",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:486'></a>
Replying to [nthiery](#comment%3A485):
> What I meant however is that, at the level of categories, the
> "super-category" relation should not be modeled by inheritance.

Must not, should not, need not? I agree, of course, that the category-relationship is unrelated to the object-relationship. But if its convenient to define your category by object-inheriting from another category, then why not?  

I would prefer to treat axioms as independent from categories (i.e. they don't inherit from Category). That then also gives you a non-category object that you can use to represent the axiom. Now, since you always have to create (manually or dynamically) a new class for a category-with-axiom it might just as well inherit from the axiom class(es). Though if you think its confusing then I'm also open to using a special class attribute and composition.

Now for something different. For the super categories, is the following what we really want? Its good enough for figuring out the methods, but does contradict the `super_category` documentation:

```python
class Base(Category_singleton):
    def super_categories(self):
        return [Objects()]

    class SubcategoryMethods:
        A = axiom("A")
        B = axiom("B")
        C = axiom("C")

    class A(CategoryWithAxiom):
        pass
    class B(CategoryWithAxiom):
        pass
    class C(CategoryWithAxiom):
        pass

Base().A()     in Base.A().B().C().super_categories()     # True, even though not direct supercategory
Base().A().B() in Base.A().B().C().super_categories()     # False
Base().A().B() in Base.A().B().C().all_super_categories() # False
```



---

archive/issue_comments_109274.json:
```json
{
    "body": "**Changing branch** from \"[public/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963)\" to \"[public/ticket/10963-doc-distributive](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963-doc-distributive)\".",
    "created_at": "2014-01-30T09:39:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109274",
    "user": "https://github.com/nthiery"
}
```

**Changing branch** from "[public/ticket/10963](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963)" to "[public/ticket/10963-doc-distributive](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963-doc-distributive)".



---

archive/issue_comments_109275.json:
```json
{
    "body": "**Changing commit** from \"[eb7b486c6fecac296052f980788e15e2ad1b59e4](https://github.com/sagemath/sagetrac-mirror/commit/eb7b486c6fecac296052f980788e15e2ad1b59e4)\" to \"[3e2003ded77192465cc3e99fec7fa64dae998950](https://github.com/sagemath/sagetrac-mirror/commit/3e2003ded77192465cc3e99fec7fa64dae998950)\".",
    "created_at": "2014-01-30T09:39:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109275",
    "user": "https://github.com/nthiery"
}
```

**Changing commit** from "[eb7b486c6fecac296052f980788e15e2ad1b59e4](https://github.com/sagemath/sagetrac-mirror/commit/eb7b486c6fecac296052f980788e15e2ad1b59e4)" to "[3e2003ded77192465cc3e99fec7fa64dae998950](https://github.com/sagemath/sagetrac-mirror/commit/3e2003ded77192465cc3e99fec7fa64dae998950)".



---

archive/issue_comments_109276.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e19385eb5e91db423f801d2af83fc71ee76fab3c\">e19385e</a></td><td><code>Axioms: various improvements + complete description of the algorithms for computing joins and adding axioms</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b957acf4309b29449333540ea59a031e02cfb583\">b957acf</a></td><td><code>Axioms: finished draft of documentation, implementation of `Distributive`, ...</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/40369681634f672838a9f6ba8523c8c983219260\">4036968</a></td><td><code>Fixed ReST typos</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e5c68aadce9e4efa50854c069cd985c36d892b30\">e5c68aa</a></td><td><code>Merged with develop (trivial manual merge with #15380)</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/db4e2807f18e3b0e13c5101f4531483ba64b6f91\">db4e280</a></td><td><code>15757: make sage.misc.superseded import lazily sage.rings.integer_ring</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c57640dab99e12a8fa94acc49cb4ee478704fcfe\">c57640d</a></td><td><code>Completely got rid of the dependency of sage.misc.superseded upon is_Integer thanks to suggestion of Jeroen</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d86c4dc52f847ac12aff6a017df82f9473c27ccd\">d86c4dc</a></td><td><code>Merge branch 'ticket/15757-superseded-is_Integer' into ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6b18661787e2d518fca76d0a22c4eb5a6ab49a08\">6b18661</a></td><td><code>Implementation of 15759</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/251da76284f87aaca63c88de1319ff2b29148c3f\">251da76</a></td><td><code>Merge branch 'ticket/15759' into ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/98a4407b8b66de7f63920de28376e46bb927517b\">98a4407</a></td><td><code>rename summand_* methods of Cartesian products</code></td></tr></table>\n",
    "created_at": "2014-01-30T09:39:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109276",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:7'></a>
**Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e19385eb5e91db423f801d2af83fc71ee76fab3c">e19385e</a></td><td><code>Axioms: various improvements + complete description of the algorithms for computing joins and adding axioms</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b957acf4309b29449333540ea59a031e02cfb583">b957acf</a></td><td><code>Axioms: finished draft of documentation, implementation of `Distributive`, ...</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/40369681634f672838a9f6ba8523c8c983219260">4036968</a></td><td><code>Fixed ReST typos</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e5c68aadce9e4efa50854c069cd985c36d892b30">e5c68aa</a></td><td><code>Merged with develop (trivial manual merge with #15380)</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/db4e2807f18e3b0e13c5101f4531483ba64b6f91">db4e280</a></td><td><code>15757: make sage.misc.superseded import lazily sage.rings.integer_ring</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c57640dab99e12a8fa94acc49cb4ee478704fcfe">c57640d</a></td><td><code>Completely got rid of the dependency of sage.misc.superseded upon is_Integer thanks to suggestion of Jeroen</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d86c4dc52f847ac12aff6a017df82f9473c27ccd">d86c4dc</a></td><td><code>Merge branch 'ticket/15757-superseded-is_Integer' into ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6b18661787e2d518fca76d0a22c4eb5a6ab49a08">6b18661</a></td><td><code>Implementation of 15759</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/251da76284f87aaca63c88de1319ff2b29148c3f">251da76</a></td><td><code>Merge branch 'ticket/15759' into ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/98a4407b8b66de7f63920de28376e46bb927517b">98a4407</a></td><td><code>rename summand_* methods of Cartesian products</code></td></tr></table>




---

archive/issue_comments_109277.json:
```json
{
    "body": "<a id='comment:8'></a>\n`T_T`\n\nIt is totally impossible to know which commits are being reviewed here and which are reviewed in other tickets `T_T`",
    "created_at": "2014-01-30T09:41:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109277",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:8'></a>
`T_T`

It is totally impossible to know which commits are being reviewed here and which are reviewed in other tickets `T_T`



---

archive/issue_comments_109278.json:
```json
{
    "body": "<a id='comment:9'></a>\nI'll be offline for a coupe hours; I'll comment more on the above commits later today.",
    "created_at": "2014-01-30T10:16:52Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109278",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:9'></a>
I'll be offline for a coupe hours; I'll comment more on the above commits later today.



---

archive/issue_comments_109279.json:
```json
{
    "body": "<a id='comment:0'></a>\nI'll be offline for a couple hours; I'll comment more on the above commits later today.",
    "created_at": "2014-01-30T10:17:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109279",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:0'></a>
I'll be offline for a couple hours; I'll comment more on the above commits later today.



---

archive/issue_comments_109280.json:
```json
{
    "body": "<a id='comment:1'></a>\nHi Peter,\n\nSorry it took longer than expected: I got distracted by #15757 and\ntwo tickets in my branch. By the way I merged in develop too since\nthere was a small conflict to resolve.\n\nI reviewed your commit 98a4407, and changed a couple more things\n(3e2003d). Please review the latter!\n\nNote: your commit was on top of Simon's \"as_name\" changes in\npublic/ticket/10963. Since it has not yet been settled whether we\nwanted to merge in those changes or not, I cherry picked your commit\nto put it on top of my branch which includes all the recent axiom\ndocumentation and so.\n\nSorry for the confusion I am still learning my way around best git\npractices ... To avoid future confusion, I moved my branch to a\npublic spot and made it the default branch for this ticket.\n\nCheers,\n                                  Nicolas",
    "created_at": "2014-01-30T14:46:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109280",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:1'></a>
Hi Peter,

Sorry it took longer than expected: I got distracted by #15757 and
two tickets in my branch. By the way I merged in develop too since
there was a small conflict to resolve.

I reviewed your commit 98a4407, and changed a couple more things
(3e2003d). Please review the latter!

Note: your commit was on top of Simon's "as_name" changes in
public/ticket/10963. Since it has not yet been settled whether we
wanted to merge in those changes or not, I cherry picked your commit
to put it on top of my branch which includes all the recent axiom
documentation and so.

Sorry for the confusion I am still learning my way around best git
practices ... To avoid future confusion, I moved my branch to a
public spot and made it the default branch for this ticket.

Cheers,
                                  Nicolas



---

archive/issue_events_085484.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-01-30T15:01:36Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85484"
}
```



---

archive/issue_events_085485.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-01-30T15:01:36Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85485"
}
```



---

archive/issue_comments_109281.json:
```json
{
    "body": "<a id='comment:3'></a>\nReplying to [vbraun](#comment%3A486):\n>  Must not, should not, need not?\n\nEh, eh, right, I indulged myself with a bit of pedantic picky-ness :-)\n\nI certainly agree about being pragmatic. As I said before, if a small\nabuse gives nice notations, while remaining safe and unambiguous,\nthat's ok for me.\n\n>  I agree, of course, that the category-\n>  relationship is unrelated to the object-relationship. But if its\n>  convenient to define your category by object-inheriting from another\n>  category, then why not?\n> \n>  I would prefer to treat axioms as independent from categories (i.e. they\n>  don't inherit from Category). That then also gives you a non-category\n>  object that you can use to represent the axiom. Now, since you always have\n>  to create (manually or dynamically) a new class for a category-with-axiom\n>  it might just as well inherit from the axiom class(es). Though if you\n>  think its confusing then I'm also open to using a special class attribute\n>  and composition.\n\nFor specifying the super/base category, I vote for using\ncomposition. The number of mathematical methods on categories (like\nis_abelian) that are incompatible with taking subcategories is bound\nto grow with time, together with the risk of obtaining mathematically\nincorrect results.\n\nFor the axiom side, that's probably ok, as I don't foresee much\nfeatures in the axiom classes (though I might be wrong). A variant\nwould be to use something like:\n\n```\n        class Finite(axioms.Finite.Category):\n             ...\n```\nand then there would be no issue.\n\n>  Now for something different. For the super categories, is the following\n>  what we really want? Its good enough for figuring out the methods, but\n>  does contradict the `super_category` documentation:\n>  ...\n\nAh yes, good point, the documentation must be made explicit about this\nbehavior: it's not really new, but is being pushed to the next level\nby axioms. I'll work on that.\n\nGiven that the number of categories that can be constructed in Sage is\npotentially exponential we really want to focus on the hierarchy of\nthose categories that are actually implemented (i.e. that are not\nconstructed as JoinCategory's). That's roughly the usual trick of\nrepresenting a lattice by the poset of its atoms.\n\nIn particular, the super_categories method is meant to return the\ndirect super categories in the hierarchy of *implemented* categories.\n\nNote that is_subcategory works as desired.\n\n     \t  \t\t       Nicolas",
    "created_at": "2014-01-30T15:12:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109281",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:3'></a>
Replying to [vbraun](#comment%3A486):
>  Must not, should not, need not?

Eh, eh, right, I indulged myself with a bit of pedantic picky-ness :-)

I certainly agree about being pragmatic. As I said before, if a small
abuse gives nice notations, while remaining safe and unambiguous,
that's ok for me.

>  I agree, of course, that the category-
>  relationship is unrelated to the object-relationship. But if its
>  convenient to define your category by object-inheriting from another
>  category, then why not?
> 
>  I would prefer to treat axioms as independent from categories (i.e. they
>  don't inherit from Category). That then also gives you a non-category
>  object that you can use to represent the axiom. Now, since you always have
>  to create (manually or dynamically) a new class for a category-with-axiom
>  it might just as well inherit from the axiom class(es). Though if you
>  think its confusing then I'm also open to using a special class attribute
>  and composition.

For specifying the super/base category, I vote for using
composition. The number of mathematical methods on categories (like
is_abelian) that are incompatible with taking subcategories is bound
to grow with time, together with the risk of obtaining mathematically
incorrect results.

For the axiom side, that's probably ok, as I don't foresee much
features in the axiom classes (though I might be wrong). A variant
would be to use something like:

```
        class Finite(axioms.Finite.Category):
             ...
```
and then there would be no issue.

>  Now for something different. For the super categories, is the following
>  what we really want? Its good enough for figuring out the methods, but
>  does contradict the `super_category` documentation:
>  ...

Ah yes, good point, the documentation must be made explicit about this
behavior: it's not really new, but is being pushed to the next level
by axioms. I'll work on that.

Given that the number of categories that can be constructed in Sage is
potentially exponential we really want to focus on the hierarchy of
those categories that are actually implemented (i.e. that are not
constructed as JoinCategory's). That's roughly the usual trick of
representing a lattice by the poset of its atoms.

In particular, the super_categories method is meant to return the
direct super categories in the hierarchy of *implemented* categories.

Note that is_subcategory works as desired.

     	  		       Nicolas



---

archive/issue_comments_109282.json:
```json
{
    "body": "<a id='comment:494'></a>\nReplying to [nthiery](#comment%3A491):\n> I reviewed your commit 98a4407, and changed a couple more things\n> (3e2003d). Please review the latter!\n\nThanks for looking at it!  There seems to be a typo (12963 instead of 10963 in various places).  Didn't you run into problems with using `deprecated_function_alias()` everywhere?  I tried this first, but (if I recall correctly) when running doctests there was a problem due to a circular import, and another error caused by applying `deprecated_function_alias()` to a `cached_method`.\n\nAs for which of `summand_embedding()` and `cartesian_embedding()` in `CombinatorialFreeModule` is the \"real\" one: you probably wanted to make the definitions look more symmetrical, and of course it makes no practical difference.  Just to explain my motivation for doing it the other way around than for `*_projection()`: for a direct sum it is the embeddings that exist by definition, while for a Cartesian product is is the projections.  The fact that you do have a `cartesian_embedding()` in this setting follows from a theorem (product = sum for modules), not a definition, so it seemed more natural to regard `summand_embedding()` as the \"primary\" notion.",
    "created_at": "2014-01-30T17:46:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109282",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:494'></a>
Replying to [nthiery](#comment%3A491):
> I reviewed your commit 98a4407, and changed a couple more things
> (3e2003d). Please review the latter!

Thanks for looking at it!  There seems to be a typo (12963 instead of 10963 in various places).  Didn't you run into problems with using `deprecated_function_alias()` everywhere?  I tried this first, but (if I recall correctly) when running doctests there was a problem due to a circular import, and another error caused by applying `deprecated_function_alias()` to a `cached_method`.

As for which of `summand_embedding()` and `cartesian_embedding()` in `CombinatorialFreeModule` is the "real" one: you probably wanted to make the definitions look more symmetrical, and of course it makes no practical difference.  Just to explain my motivation for doing it the other way around than for `*_projection()`: for a direct sum it is the embeddings that exist by definition, while for a Cartesian product is is the projections.  The fact that you do have a `cartesian_embedding()` in this setting follows from a theorem (product = sum for modules), not a definition, so it seemed more natural to regard `summand_embedding()` as the "primary" notion.



---

archive/issue_events_085486.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "milestone": "sage-6.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85486"
}
```



---

archive/issue_events_085487.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85487"
}
```



---

archive/issue_comments_109283.json:
```json
{
    "body": "<a id='comment:496'></a>\nReplying to [pbruin](#comment%3A494):\n> Thanks for looking at it!  There seems to be a typo (12963 instead of 10963 in various places).  Didn't you run into problems with using `deprecated_function_alias()` everywhere?  I tried this first, but (if I recall correctly) when running doctests there was a problem due to a circular import, and another error caused by applying `deprecated_function_alias()` to a `cached_method`.\n\nIndeed! That's why I got distracted by #15757 and #15759. It itched me\nnot to be able to use deprecated_function_alias :-)\n\nThanks for spotting the 12963's. I'll fix them now.\n\n> As for which of `summand_embedding()` and `cartesian_embedding()` in `CombinatorialFreeModule` is the \"real\" one: you probably wanted to make the definitions look more symmetrical, and of course it makes no practical difference.  Just to explain my motivation for doing it the other way around than for `*_projection()`: for a direct sum it is the embeddings that exist by definition, while for a Cartesian product is is the projections.  The fact that you do have a `cartesian_embedding()` in this setting follows from a theorem (product = sum for modules), not a definition, so it seemed more natural to regard `summand_embedding()` as the \"primary\" notion.\n\nAh ah, that's an interesting motivation indeed! Thanks for sharing\nit. I'll keep it in mind if this occurs elsewhere, in which case it\ncould well make much sense to introduce this subtlety.\n\nCheers,\n                    Nicolas",
    "created_at": "2014-01-31T08:54:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109283",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:496'></a>
Replying to [pbruin](#comment%3A494):
> Thanks for looking at it!  There seems to be a typo (12963 instead of 10963 in various places).  Didn't you run into problems with using `deprecated_function_alias()` everywhere?  I tried this first, but (if I recall correctly) when running doctests there was a problem due to a circular import, and another error caused by applying `deprecated_function_alias()` to a `cached_method`.

Indeed! That's why I got distracted by #15757 and #15759. It itched me
not to be able to use deprecated_function_alias :-)

Thanks for spotting the 12963's. I'll fix them now.

> As for which of `summand_embedding()` and `cartesian_embedding()` in `CombinatorialFreeModule` is the "real" one: you probably wanted to make the definitions look more symmetrical, and of course it makes no practical difference.  Just to explain my motivation for doing it the other way around than for `*_projection()`: for a direct sum it is the embeddings that exist by definition, while for a Cartesian product is is the projections.  The fact that you do have a `cartesian_embedding()` in this setting follows from a theorem (product = sum for modules), not a definition, so it seemed more natural to regard `summand_embedding()` as the "primary" notion.

Ah ah, that's an interesting motivation indeed! Thanks for sharing
it. I'll keep it in mind if this occurs elsewhere, in which case it
could well make much sense to introduce this subtlety.

Cheers,
                    Nicolas



---

archive/issue_comments_109284.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7\">c718f21</a></td><td><code>#10963: typo fix 12963 -> 10963</code></td></tr></table>\n",
    "created_at": "2014-01-31T09:05:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109284",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7">c718f21</a></td><td><code>#10963: typo fix 12963 -> 10963</code></td></tr></table>




---

archive/issue_comments_109285.json:
```json
{
    "body": "**Changing commit** from \"[3e2003ded77192465cc3e99fec7fa64dae998950](https://github.com/sagemath/sagetrac-mirror/commit/3e2003ded77192465cc3e99fec7fa64dae998950)\" to \"[c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7](https://github.com/sagemath/sagetrac-mirror/commit/c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7)\".",
    "created_at": "2014-01-31T09:05:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109285",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[3e2003ded77192465cc3e99fec7fa64dae998950](https://github.com/sagemath/sagetrac-mirror/commit/3e2003ded77192465cc3e99fec7fa64dae998950)" to "[c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7](https://github.com/sagemath/sagetrac-mirror/commit/c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7)".



---

archive/issue_comments_109286.json:
```json
{
    "body": "<a id='comment:498'></a>\nReplying to [nthiery](#comment%3A496):\n> Indeed! That's why I got distracted by #15757 and #15759. It itched me\n> not to be able to use deprecated_function_alias :-)\n\nGreat!  I'm glad this is now fixed.",
    "created_at": "2014-01-31T12:23:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109286",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:498'></a>
Replying to [nthiery](#comment%3A496):
> Indeed! That's why I got distracted by #15757 and #15759. It itched me
> not to be able to use deprecated_function_alias :-)

Great!  I'm glad this is now fixed.



---

archive/issue_comments_109287.json:
```json
{
    "body": "<a id='comment:9'></a>\nThe metaclass approach for inner categories as subcategories works now. I've switched it to attributes\n\n```python\nclass FiniteCommutativeTest1(CategoryWithAxioms):\n    __base_category_class__ = Test1\n    __axiom_classes__ = frozenset([axioms.Commutative, axioms.Finite])\n```\nbut inheritance from axioms works, too\n\n```python\nclass Test2(Category):\n    class FiniteCommutative2(InnerCategory, axioms.Finite, axioms.Commutative):\n        pass\n```\nsee https://github.com/sagemath/sagetrac-mirror/blob/develop/src/sage/categories/category_with_axioms.py?h=c520eb0bddcf6543d037dad3c7f0b808ae29b160\n\nI haven't implemented relations in the category manager, though one could keep that simple and leave more complicated things for later. One thing that I think is tricky is to derive rules from implications A => B => C => A, especially if `all_super_categories` is actually missing some super categories. \n\nTo answer your timeline question, I'd say less than a month.",
    "created_at": "2014-02-01T02:00:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109287",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:9'></a>
The metaclass approach for inner categories as subcategories works now. I've switched it to attributes

```python
class FiniteCommutativeTest1(CategoryWithAxioms):
    __base_category_class__ = Test1
    __axiom_classes__ = frozenset([axioms.Commutative, axioms.Finite])
```
but inheritance from axioms works, too

```python
class Test2(Category):
    class FiniteCommutative2(InnerCategory, axioms.Finite, axioms.Commutative):
        pass
```
see https://github.com/sagemath/sagetrac-mirror/blob/develop/src/sage/categories/category_with_axioms.py?h=c520eb0bddcf6543d037dad3c7f0b808ae29b160

I haven't implemented relations in the category manager, though one could keep that simple and leave more complicated things for later. One thing that I think is tricky is to derive rules from implications A => B => C => A, especially if `all_super_categories` is actually missing some super categories. 

To answer your timeline question, I'd say less than a month.



---

archive/issue_comments_109288.json:
```json
{
    "body": "<a id='comment:500'></a>\nHi Volker!\n\nReplying to [vbraun](#comment%3A499):\n> The metaclass approach for inner categories as subcategories works now. I've switched it to attributes\n> \n> ```python\n> class FiniteCommutativeTest1(CategoryWithAxioms):\n>     __base_category_class__ = Test1\n>     __axiom_classes__ = frozenset([axioms.Commutative, axioms.Finite])\n> ```\n> but inheritance from axioms works, too\n> \n> ```python\n> class Test2(Category):\n>     class FiniteCommutative2(InnerCategory, axioms.Finite, axioms.Commutative):\n>         pass\n> ```\n> see https://github.com/sagemath/sagetrac-mirror/blob/develop/src/sage/categories/category_with_axioms.py?h=c520eb0bddcf6543d037dad3c7f0b808ae29b160\n\nCool. Just 2 cents: a potential close variant could be:\n\n> ```python\n> class FiniteCommutativeTest1(axioms.Finite.Category, axioms.Commutative.Category):\n>     __base_category_class__ = Test1\n> ```\n> class Test2(Category):\n>     class FiniteCommutative2(axioms.Finite.Category, axioms.Commutative.Category):\n>         pass\n> }}}\n\nwhere `axioms.Finite.Category` (or some better name) would be a\nclass for the categories implementing the axiom Finite (and possibly\nother axioms) for some base category. Ah, maybe\n`_base_category_class_` since it's a Sage special attribute, not a\nPython one; but that's just a detail.\n\n> I haven't implemented relations in the category manager, though one could keep that simple and leave more complicated things for later.\n\nIf we support Wedderburn's like relations right now, and are\nreasonably convinced that we can eventually support everything that\nthe current infrastructure supports, sure.\n\n> One thing that I think is tricky is to derive rules from implications A => B => C => A, especially if `all_super_categories` is actually missing some super categories.\n\nOk. We agree that the current infrastructure has no problem with that,\nright?\n\n> To answer your timeline question, I'd say less than a month.\n\nOk.\n\nThanks for your work on exploring alternative implementation and\nsyntax! I still personally believe this belongs to a follow up ticket,\nbut this is an open debate. To substantiate this debate, it would be\nuseful that we clarify the scope of your proposal and implementation\nin progress, in particular about which issues / further features it's\naiming to address, and what could be the inconveniences.  Feel free to\nsave time and just answer yes/no for now if you are convinced about\nthe answer; your prototype will be the proof :-)\n\n- The main point is that it removes the current limitation that we can\n  add only a single axiom at a time, right? How many spots in the\n  current category code will be improved by this?\n\n- Will it allow for completely getting rid of the couple remaining\n  \"placeholder categories\", both statically and dynamically?\n\n- Will the proposal make for a cleaner implementation of axioms like\n  Distributive?\n\n  ```\n      sage: (CommutativeAdditiveGroups() & Monoids()).Distributive()\n      Category of rings\n  ```\n\n- Is it going to reuse the current join implementation, for example by\n  delegating the work to it by building the required arborescence\n  behind the scene? Or will the manager replace this piece too?  If\n  it's not using an arborescence of some kind, what kind of complexity\n  can we roughly expect to have?\n\n- Is it compatible with lazy importing categories with axioms?  (I am\n  ready to believe that this can be made to work, but one has to be a\n  bit careful in the join implementation).\n\n- Will the proposal allow for getting rid of the global list of\n  axioms/axiom names? If yes, how will the printing out be handled?\n\n- The proposal requires to get through the dictionary of the category\n  classes, right? At first sight this is making me nervous (though not\n  as much as if this was on instances). Is it guaranteed that this\n  won't trigger accidently, say, lazy imports that might be there for\n  other features (like functorial constructions)?\n\n- Will some class binding with `__classget__` be still needed? If\n  yes, how will the idiom `__base_category_class__ = Test1` work\n  if `Test1` is itself a `CategoryWithAxiom/InnerCategory`?\n\n- Where will the idiom `XXX.Finite()` be implemented? In particular,\n  will introspection on `XXX.Finite?` work as it currently does?\n\n- Where would be the natural place to put the axioms? If it's under\n  `axioms.*`, how will potential name clashes be handled?\n\nThanks!\n\nSomething that will be harder to evaluate without some large examples\n(e.g. refactoring a non trivial part of the current categories; say\neverything above `Fields()`), is whether the new infrastructure\nwill altogether be more practical as the current one. My current\nimpression is that it will require more imports, which can be\nannoying, and that defining new axioms will take a bit more work.\n\nCheers,\n                               Nicolas",
    "created_at": "2014-02-03T09:45:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109288",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:500'></a>
Hi Volker!

Replying to [vbraun](#comment%3A499):
> The metaclass approach for inner categories as subcategories works now. I've switched it to attributes
> 
> ```python
> class FiniteCommutativeTest1(CategoryWithAxioms):
>     __base_category_class__ = Test1
>     __axiom_classes__ = frozenset([axioms.Commutative, axioms.Finite])
> ```
> but inheritance from axioms works, too
> 
> ```python
> class Test2(Category):
>     class FiniteCommutative2(InnerCategory, axioms.Finite, axioms.Commutative):
>         pass
> ```
> see https://github.com/sagemath/sagetrac-mirror/blob/develop/src/sage/categories/category_with_axioms.py?h=c520eb0bddcf6543d037dad3c7f0b808ae29b160

Cool. Just 2 cents: a potential close variant could be:

> ```python
> class FiniteCommutativeTest1(axioms.Finite.Category, axioms.Commutative.Category):
>     __base_category_class__ = Test1
> ```
> class Test2(Category):
>     class FiniteCommutative2(axioms.Finite.Category, axioms.Commutative.Category):
>         pass
> }}}

where `axioms.Finite.Category` (or some better name) would be a
class for the categories implementing the axiom Finite (and possibly
other axioms) for some base category. Ah, maybe
`_base_category_class_` since it's a Sage special attribute, not a
Python one; but that's just a detail.

> I haven't implemented relations in the category manager, though one could keep that simple and leave more complicated things for later.

If we support Wedderburn's like relations right now, and are
reasonably convinced that we can eventually support everything that
the current infrastructure supports, sure.

> One thing that I think is tricky is to derive rules from implications A => B => C => A, especially if `all_super_categories` is actually missing some super categories.

Ok. We agree that the current infrastructure has no problem with that,
right?

> To answer your timeline question, I'd say less than a month.

Ok.

Thanks for your work on exploring alternative implementation and
syntax! I still personally believe this belongs to a follow up ticket,
but this is an open debate. To substantiate this debate, it would be
useful that we clarify the scope of your proposal and implementation
in progress, in particular about which issues / further features it's
aiming to address, and what could be the inconveniences.  Feel free to
save time and just answer yes/no for now if you are convinced about
the answer; your prototype will be the proof :-)

- The main point is that it removes the current limitation that we can
  add only a single axiom at a time, right? How many spots in the
  current category code will be improved by this?

- Will it allow for completely getting rid of the couple remaining
  "placeholder categories", both statically and dynamically?

- Will the proposal make for a cleaner implementation of axioms like
  Distributive?

  ```
      sage: (CommutativeAdditiveGroups() & Monoids()).Distributive()
      Category of rings
  ```

- Is it going to reuse the current join implementation, for example by
  delegating the work to it by building the required arborescence
  behind the scene? Or will the manager replace this piece too?  If
  it's not using an arborescence of some kind, what kind of complexity
  can we roughly expect to have?

- Is it compatible with lazy importing categories with axioms?  (I am
  ready to believe that this can be made to work, but one has to be a
  bit careful in the join implementation).

- Will the proposal allow for getting rid of the global list of
  axioms/axiom names? If yes, how will the printing out be handled?

- The proposal requires to get through the dictionary of the category
  classes, right? At first sight this is making me nervous (though not
  as much as if this was on instances). Is it guaranteed that this
  won't trigger accidently, say, lazy imports that might be there for
  other features (like functorial constructions)?

- Will some class binding with `__classget__` be still needed? If
  yes, how will the idiom `__base_category_class__ = Test1` work
  if `Test1` is itself a `CategoryWithAxiom/InnerCategory`?

- Where will the idiom `XXX.Finite()` be implemented? In particular,
  will introspection on `XXX.Finite?` work as it currently does?

- Where would be the natural place to put the axioms? If it's under
  `axioms.*`, how will potential name clashes be handled?

Thanks!

Something that will be harder to evaluate without some large examples
(e.g. refactoring a non trivial part of the current categories; say
everything above `Fields()`), is whether the new infrastructure
will altogether be more practical as the current one. My current
impression is that it will require more imports, which can be
annoying, and that defining new axioms will take a bit more work.

Cheers,
                               Nicolas



---

archive/issue_comments_109289.json:
```json
{
    "body": "<a id='comment:501'></a>\nReplying to [nthiery](#comment%3A500):\n> > \n> > ```python\n> > class Test2(Category):\n> >     class FiniteCommutative2(axioms.Finite.Category, axioms.Commutative.Category):\n> >         pass\n> > ```\n\nI decided on the special `InnerCategory` class as a marker for inner categories because it is unambiguous both \n\n* for Python: maybe you want an unrelated category nested inside your class without having it mangled by the metaclass,\n\n* for authors: even if the enclosing class is off-screen you know that you are declaring a subcategory.\n\nAlso, it simplifies the chicken-and-egg problem for the metaclass constructing the `Category` base. Technically, the `InnerCategory` is not a category since the usual Python rules would run the metaclass for the inner class first, whereas we want to assemble the outer class first.\n\n\n> `_base_category_class_` since it's a Sage special attribute, not a\n> Python one; but that's just a detail.\n\nI thought about that and decided on `__double__` underscores for attributes set by the metaclass. It makes it clear that they aren't quite your run-of-the-mill Sage hidden attributes, but that special rules apply. And it should be clear enough from the name that `__base_category_class__` is not an ordinary Python attribute.\n\n> > One thing that I think is tricky is to derive rules from implications A => B => C => A, especially if `all_super_categories` is actually missing some super categories.\n\n> \n> Ok. We agree that the current infrastructure has no problem with that,\n> right?\n\nI don't think so, it depends on exactly which super categories you pick. I certainly agree that it can work if your declared super categories are sufficiently close to the actual immediate super categories, but it seems difficult to a) get right and b) diagnose what goes wrong otherwise.\n\n> - The main point is that it removes the current limitation that we can\n>   add only a single axiom at a time, right? How many spots in the\n>   current category code will be improved by this?\n\nThe main point is that it separates class names from program flow. You can name your category classes any way you want, their relation has to be specified in code. It seemed natural to not restrict to a single axiom, but thats just a by-product.\n\n> - Will it allow for completely getting rid of the couple remaining\n>   \"placeholder categories\", both statically and dynamically?\n> - Is it going to reuse the current join implementation, for example by\n>   delegating the work to it by building the required arborescence\n>   behind the scene? Or will the manager replace this piece too?  If\n>   it's not using an arborescence of some kind, what kind of complexity\n>   can we roughly expect to have?\n\nI don't want to change the existing join implementation, so you need to dynamically generate category + single axiom if it is not defined statically. This is the `CategoryAxiomModel.construct_with_one_axiom` method. Which category classes to generate dynamically is the one place that involves choices, which is very clear in the implementation.\n\n> - Will the proposal make for a cleaner implementation of axioms like\n>   Distributive?\n> \n>   ```\n>       sage: (CommutativeAdditiveGroups() & Monoids()).Distributive()\n>       Category of rings\n>   ```\n\nEssentially I'm just forcing all category construction to go through a single factory object, which then can implement arbitrarily complicated rules. So in that sense, yes. Perhaps most importantly, it makes it easier to change the implementation of how the rules are applied.\n\n> - Is it compatible with lazy importing categories with axioms?  (I am\n>   ready to believe that this can be made to work, but one has to be a\n>   bit careful in the join implementation).\n\nI don't see any problem. Resolving the lazy import implicitly runs the metaclass to assemble the new classes, but that never generates join categories. Unless you manually construct a non-lazy join category in the lazily imported module, but that is asking for trouble either way.\n\n> - Will the proposal allow for getting rid of the global list of\n>   axioms/axiom names? If yes, how will the printing out be handled?\n\nUser-supplied axioms must be registered with the `axioms` factory object. Printing uses `Axiom._repr_`, which you can override if you like (defaults to `__class__.__name__`)\n\n> - The proposal requires to get through the dictionary of the category\n>   classes, right? At first sight this is making me nervous (though not\n>   as much as if this was on instances). Is it guaranteed that this\n>   won't trigger accidently, say, lazy imports that might be there for\n>   other features (like functorial constructions)?\n\nWe only have to do instance/subclass checks. There are hooks in Python for that, but they require a metaclass. In particular, lazy imports don't implement them. Also `__instancecheck__` is the wrong way (would be called on our metaclass) and `__subclasscheck__` does not give you access to the instance.\n\n> - Will some class binding with `__classget__` be still needed? If\n>   yes, how will the idiom `__base_category_class__ = Test1` work\n>   if `Test1` is itself a `CategoryWithAxiom/InnerCategory`?\n\nI don't think we need `__classget__`, the whole design is to construct the category class the way we want it on import. So there is no need to redirect attribute access later on.\n\n> - Where will the idiom `XXX.Finite()` be implemented? In particular,\n>   will introspection on `XXX.Finite?` work as it currently does?\n\nThose are all methods that end up callling `XXX.with_axiom(Finite)`. They are generated by the metaclass, so you can attach any doctstring you want. For a dynamic category+axiom there won't be a static source code, of course.\n\n> - Where would be the natural place to put the axioms? If it's under\n>   `axioms.*`, how will potential name clashes be handled?\n\nIMHO everything should go through the `axioms` factory object, which is also where the order is defined. You can implement your axioms anywhere you want. I've been trying to group them together by topic, though you could use individual files. Doesn't matter as long as you use the factory object.",
    "created_at": "2014-02-03T15:37:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109289",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:501'></a>
Replying to [nthiery](#comment%3A500):
> > 
> > ```python
> > class Test2(Category):
> >     class FiniteCommutative2(axioms.Finite.Category, axioms.Commutative.Category):
> >         pass
> > ```

I decided on the special `InnerCategory` class as a marker for inner categories because it is unambiguous both 

* for Python: maybe you want an unrelated category nested inside your class without having it mangled by the metaclass,

* for authors: even if the enclosing class is off-screen you know that you are declaring a subcategory.

Also, it simplifies the chicken-and-egg problem for the metaclass constructing the `Category` base. Technically, the `InnerCategory` is not a category since the usual Python rules would run the metaclass for the inner class first, whereas we want to assemble the outer class first.


> `_base_category_class_` since it's a Sage special attribute, not a
> Python one; but that's just a detail.

I thought about that and decided on `__double__` underscores for attributes set by the metaclass. It makes it clear that they aren't quite your run-of-the-mill Sage hidden attributes, but that special rules apply. And it should be clear enough from the name that `__base_category_class__` is not an ordinary Python attribute.

> > One thing that I think is tricky is to derive rules from implications A => B => C => A, especially if `all_super_categories` is actually missing some super categories.

> 
> Ok. We agree that the current infrastructure has no problem with that,
> right?

I don't think so, it depends on exactly which super categories you pick. I certainly agree that it can work if your declared super categories are sufficiently close to the actual immediate super categories, but it seems difficult to a) get right and b) diagnose what goes wrong otherwise.

> - The main point is that it removes the current limitation that we can
>   add only a single axiom at a time, right? How many spots in the
>   current category code will be improved by this?

The main point is that it separates class names from program flow. You can name your category classes any way you want, their relation has to be specified in code. It seemed natural to not restrict to a single axiom, but thats just a by-product.

> - Will it allow for completely getting rid of the couple remaining
>   "placeholder categories", both statically and dynamically?
> - Is it going to reuse the current join implementation, for example by
>   delegating the work to it by building the required arborescence
>   behind the scene? Or will the manager replace this piece too?  If
>   it's not using an arborescence of some kind, what kind of complexity
>   can we roughly expect to have?

I don't want to change the existing join implementation, so you need to dynamically generate category + single axiom if it is not defined statically. This is the `CategoryAxiomModel.construct_with_one_axiom` method. Which category classes to generate dynamically is the one place that involves choices, which is very clear in the implementation.

> - Will the proposal make for a cleaner implementation of axioms like
>   Distributive?
> 
>   ```
>       sage: (CommutativeAdditiveGroups() & Monoids()).Distributive()
>       Category of rings
>   ```

Essentially I'm just forcing all category construction to go through a single factory object, which then can implement arbitrarily complicated rules. So in that sense, yes. Perhaps most importantly, it makes it easier to change the implementation of how the rules are applied.

> - Is it compatible with lazy importing categories with axioms?  (I am
>   ready to believe that this can be made to work, but one has to be a
>   bit careful in the join implementation).

I don't see any problem. Resolving the lazy import implicitly runs the metaclass to assemble the new classes, but that never generates join categories. Unless you manually construct a non-lazy join category in the lazily imported module, but that is asking for trouble either way.

> - Will the proposal allow for getting rid of the global list of
>   axioms/axiom names? If yes, how will the printing out be handled?

User-supplied axioms must be registered with the `axioms` factory object. Printing uses `Axiom._repr_`, which you can override if you like (defaults to `__class__.__name__`)

> - The proposal requires to get through the dictionary of the category
>   classes, right? At first sight this is making me nervous (though not
>   as much as if this was on instances). Is it guaranteed that this
>   won't trigger accidently, say, lazy imports that might be there for
>   other features (like functorial constructions)?

We only have to do instance/subclass checks. There are hooks in Python for that, but they require a metaclass. In particular, lazy imports don't implement them. Also `__instancecheck__` is the wrong way (would be called on our metaclass) and `__subclasscheck__` does not give you access to the instance.

> - Will some class binding with `__classget__` be still needed? If
>   yes, how will the idiom `__base_category_class__ = Test1` work
>   if `Test1` is itself a `CategoryWithAxiom/InnerCategory`?

I don't think we need `__classget__`, the whole design is to construct the category class the way we want it on import. So there is no need to redirect attribute access later on.

> - Where will the idiom `XXX.Finite()` be implemented? In particular,
>   will introspection on `XXX.Finite?` work as it currently does?

Those are all methods that end up callling `XXX.with_axiom(Finite)`. They are generated by the metaclass, so you can attach any doctstring you want. For a dynamic category+axiom there won't be a static source code, of course.

> - Where would be the natural place to put the axioms? If it's under
>   `axioms.*`, how will potential name clashes be handled?

IMHO everything should go through the `axioms` factory object, which is also where the order is defined. You can implement your axioms anywhere you want. I've been trying to group them together by topic, though you could use individual files. Doesn't matter as long as you use the factory object.



---

archive/issue_comments_109290.json:
```json
{
    "body": "<a id='comment:502'></a>\nReplying to [vbraun](#comment%3A501):\n> I decided on the special `InnerCategory` class as a marker for inner categories because it is unambiguous both \n> \n> * for Python: maybe you want an unrelated category nested inside your class without having it mangled by the metaclass,\n> \n> * for authors: even if the enclosing class is off-screen you know that you are declaring a subcategory.\n\nThis ambiguity is already resolved by the fact that you are\nimplementing a category with axiom (which you know from the\ninheritance from Finite.Category).\n\n> I don't think so, it depends on exactly which super categories you pick. I certainly agree that it can work if your declared super categories are sufficiently close to the actual immediate super categories, but it seems difficult to a) get right and b) diagnose what goes wrong otherwise.\n\nIf you have concrete examples to test, I am interested! The only\nconstraints that you have to respect is that the\n`extra_super_categories` methods should return strict super\nclasses. As for diagnosing, you can check the stack and see which\n`extra_super_categories` methods got involved. Admittedly not for\na beginner, but I don't expect a beginner to implement non trivial\ncategories with axioms anyway.\n\n> The main point is that it separates class names from program flow. You can name your category classes any way you want,\n> their relation has to be specified in code.\n\nAnyway you want, except using the same name as for the axiom if you\nstill want to support `.Finite()` without `classget` magic! I\nbelieve being able to use the same name is a feature. And it's\nconsistent with what's done for functorial constructions.\n\n> It seemed natural to not restrict to a single axiom, but thats just a by-product.\n\nOk!\n\n> I don't want to change the existing join implementation, so you need to dynamically generate category + single axiom if it is not defined statically. This is the `CategoryAxiomModel.construct_with_one_axiom` method. Which category classes to generate dynamically is the one place that involves choices, which is very clear in the implementation.\n\nSounds reasonable! Of course we don't yet save on placeholder category\nclasses on the dynamical side.\n\n> > - Will the proposal make for a cleaner implementation of axioms like\n> >   Distributive?\n> > \n> >   ```\n> >       sage: (CommutativeAdditiveGroups() & Monoids()).Distributive()\n> >       Category of rings\n> >   ```\n\n> \n> Essentially I'm just forcing all category construction to go through a single factory object, which then can implement arbitrarily complicated rules. So in that sense, yes. Perhaps most importantly, it makes it easier to change the implementation of how the rules are applied.\n\nYou mean, upon computing the join of `Magmas()` and\n`AdditiveMagmas()` you would go through the factory object, and\nthat object would have a rule to construct\n`MagmasAndAdditiveMagmas()`? Can such a rule be implemented with a\ngood complexity?\n\n> I don't see any problem. Resolving the lazy import implicitly runs the metaclass to assemble the new classes, but that never generates join categories. Unless you manually construct a non-lazy join category in the lazily imported module, but that is asking for trouble either way.\n\nThe only thing is to make sure, upon adding a bunch of axioms to a\ngiven category, that you have lazy imported exactly those files needed\nso that the manager is aware of all the relevant axiom\ncategories. Given that you still go through the current join, that\nshould be alright.\n\n> User-supplied axioms must be registered with the `axioms` factory object. Printing uses `Axiom._repr_`, which you can override if you like (defaults to `__class__.__name__`)\n\nSorry for the ambiguity: I am speaking of the printing of the category\nwith axiom classes. From what I see below, there still is a global\nlist of axioms, so we can use that; the only difference is that it's\ncreated on the fly through a registering process. We could trivially\ndo the same with the current infrastructure. But it gets tricky when\nwe want to explicitly choose a given order to get nice printing.\nProbably we want some mixed strategy, with the most important axioms\nexplicitly ordered in a single point of the code, and the others added\non the fly later.\n\n> We only have to do instance/subclass checks. There are hooks in Python for that, but they require a metaclass. In particular, lazy imports don't implement them. Also `__instancecheck__` is the wrong way (would be called on our metaclass) and `__subclasscheck__` does not give you access to the instance.\n\nOk.\n\nI am still reluctant with that business. When we implement\nGroups.Finite, it's about the finite groups category. And I believe\nthe magic, if any, should reside in the nested class and not in\nGroups. For otherwise, we should do the same for consistency for\nfunctorial constructions. And if we want later to add yet another type\nof construction, beyond axioms and functorial constructions, the\nmetaclass of Groups will have to handle all of them, instead of having\neach nested class just handle its own specifics. So much for\nseparation of concerns.\n\n> I don't think we need `__classget__`, the whole design is to construct the category class the way we want it on import. So there is no need to redirect attribute access later on.\n\nExcept to allow for the same name for the category with axiom and the\n`.Finite` method.\n\n> > - Where would be the natural place to put the axioms? If it's under\n> >   `axioms.*`, how will potential name clashes be handled?\n\n> \n> IMHO everything should go through the `axioms` factory object, which is also where the order is defined. You can implement your axioms anywhere you want. I've been trying to group them together by topic, though you could use individual files. Doesn't matter as long as you use the factory object.\n\nIt matters in that you'll have to import them explicitly; so this\ncalls for some recommended scheme; otherwise we will spend time\nsearching for them.\n\nThanks for your answers! It clarifies the situation. Now I still\nbelieve it belongs to a later ticket, and I am not yet \n\nCheers,\n                             Nicolas",
    "created_at": "2014-02-03T16:49:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109290",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:502'></a>
Replying to [vbraun](#comment%3A501):
> I decided on the special `InnerCategory` class as a marker for inner categories because it is unambiguous both 
> 
> * for Python: maybe you want an unrelated category nested inside your class without having it mangled by the metaclass,
> 
> * for authors: even if the enclosing class is off-screen you know that you are declaring a subcategory.

This ambiguity is already resolved by the fact that you are
implementing a category with axiom (which you know from the
inheritance from Finite.Category).

> I don't think so, it depends on exactly which super categories you pick. I certainly agree that it can work if your declared super categories are sufficiently close to the actual immediate super categories, but it seems difficult to a) get right and b) diagnose what goes wrong otherwise.

If you have concrete examples to test, I am interested! The only
constraints that you have to respect is that the
`extra_super_categories` methods should return strict super
classes. As for diagnosing, you can check the stack and see which
`extra_super_categories` methods got involved. Admittedly not for
a beginner, but I don't expect a beginner to implement non trivial
categories with axioms anyway.

> The main point is that it separates class names from program flow. You can name your category classes any way you want,
> their relation has to be specified in code.

Anyway you want, except using the same name as for the axiom if you
still want to support `.Finite()` without `classget` magic! I
believe being able to use the same name is a feature. And it's
consistent with what's done for functorial constructions.

> It seemed natural to not restrict to a single axiom, but thats just a by-product.

Ok!

> I don't want to change the existing join implementation, so you need to dynamically generate category + single axiom if it is not defined statically. This is the `CategoryAxiomModel.construct_with_one_axiom` method. Which category classes to generate dynamically is the one place that involves choices, which is very clear in the implementation.

Sounds reasonable! Of course we don't yet save on placeholder category
classes on the dynamical side.

> > - Will the proposal make for a cleaner implementation of axioms like
> >   Distributive?
> > 
> >   ```
> >       sage: (CommutativeAdditiveGroups() & Monoids()).Distributive()
> >       Category of rings
> >   ```

> 
> Essentially I'm just forcing all category construction to go through a single factory object, which then can implement arbitrarily complicated rules. So in that sense, yes. Perhaps most importantly, it makes it easier to change the implementation of how the rules are applied.

You mean, upon computing the join of `Magmas()` and
`AdditiveMagmas()` you would go through the factory object, and
that object would have a rule to construct
`MagmasAndAdditiveMagmas()`? Can such a rule be implemented with a
good complexity?

> I don't see any problem. Resolving the lazy import implicitly runs the metaclass to assemble the new classes, but that never generates join categories. Unless you manually construct a non-lazy join category in the lazily imported module, but that is asking for trouble either way.

The only thing is to make sure, upon adding a bunch of axioms to a
given category, that you have lazy imported exactly those files needed
so that the manager is aware of all the relevant axiom
categories. Given that you still go through the current join, that
should be alright.

> User-supplied axioms must be registered with the `axioms` factory object. Printing uses `Axiom._repr_`, which you can override if you like (defaults to `__class__.__name__`)

Sorry for the ambiguity: I am speaking of the printing of the category
with axiom classes. From what I see below, there still is a global
list of axioms, so we can use that; the only difference is that it's
created on the fly through a registering process. We could trivially
do the same with the current infrastructure. But it gets tricky when
we want to explicitly choose a given order to get nice printing.
Probably we want some mixed strategy, with the most important axioms
explicitly ordered in a single point of the code, and the others added
on the fly later.

> We only have to do instance/subclass checks. There are hooks in Python for that, but they require a metaclass. In particular, lazy imports don't implement them. Also `__instancecheck__` is the wrong way (would be called on our metaclass) and `__subclasscheck__` does not give you access to the instance.

Ok.

I am still reluctant with that business. When we implement
Groups.Finite, it's about the finite groups category. And I believe
the magic, if any, should reside in the nested class and not in
Groups. For otherwise, we should do the same for consistency for
functorial constructions. And if we want later to add yet another type
of construction, beyond axioms and functorial constructions, the
metaclass of Groups will have to handle all of them, instead of having
each nested class just handle its own specifics. So much for
separation of concerns.

> I don't think we need `__classget__`, the whole design is to construct the category class the way we want it on import. So there is no need to redirect attribute access later on.

Except to allow for the same name for the category with axiom and the
`.Finite` method.

> > - Where would be the natural place to put the axioms? If it's under
> >   `axioms.*`, how will potential name clashes be handled?

> 
> IMHO everything should go through the `axioms` factory object, which is also where the order is defined. You can implement your axioms anywhere you want. I've been trying to group them together by topic, though you could use individual files. Doesn't matter as long as you use the factory object.

It matters in that you'll have to import them explicitly; so this
calls for some recommended scheme; otherwise we will spend time
searching for them.

Thanks for your answers! It clarifies the situation. Now I still
believe it belongs to a later ticket, and I am not yet 

Cheers,
                             Nicolas



---

archive/issue_comments_109291.json:
```json
{
    "body": "<a id='comment:503'></a>\nReplying to [nthiery](#comment%3A502):\n> This ambiguity is already resolved by the fact that you are\n> implementing a category with axiom (which you know from the\n> inheritance from Finite.Category).\n\nNot quite, the author might just want to implement an unrelated category-with-axioms. Or store an existing category in an attribute. I just think we should err on the side of being more explicit rather than less here, because if you accidentally trigger this mechanism you'll have a really bad time.\n\n> If you have concrete examples to test, I am interested! The only\n> constraints that you have to respect is that the\n> `extra_super_categories` methods should return strict super\n> classes.\n\nWell, as the most extreme case, they could just return nothing.\n\n> Anyway you want, except using the same name as for the axiom if you\n> still want to support `.Finite()` without `classget` magic\n\nAh, sorry, I also want this:\n\n```\nclass Test1(Category):\n    Infinite_or_any_other_name = subcategory_with_axioms(axioms.Infinite)  # parsed by the metaclass\n    FiniteCommutative = subcategory_with_axioms(axioms.Finite, axioms.Commutative)\n```\nwhich is in the url I linked but I haven't copied here.\n\nYou can, of course, use the same name. But you don't have to, and you have to put it into code if you do.\n\n> Sorry for the ambiguity: I am speaking of the printing of the category\n> with axiom classes.\n\nThe order of axioms (which is also the print order) is specified in the `axioms` object. So nothing changes there.\n\n> I am still reluctant with that business. When we implement\n> Groups.Finite, it's about the finite groups category. And I believe\n> the magic, if any, should reside in the nested class and not in\n> Groups. For otherwise, we should do the same for consistency for\n> functorial constructions. And if we want later to add yet another type\n> of construction, beyond axioms and functorial constructions, the\n> metaclass of Groups will have to handle all of them, instead of having\n> each nested class just handle its own specifics. So much for\n> separation of concerns.\n\nFair enough, but you can inherit from metaclasses as usual. So the standard OO mechanism for dealing with this concern apply. Even though I don't recommend having too many meta classes.",
    "created_at": "2014-02-03T17:14:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109291",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:503'></a>
Replying to [nthiery](#comment%3A502):
> This ambiguity is already resolved by the fact that you are
> implementing a category with axiom (which you know from the
> inheritance from Finite.Category).

Not quite, the author might just want to implement an unrelated category-with-axioms. Or store an existing category in an attribute. I just think we should err on the side of being more explicit rather than less here, because if you accidentally trigger this mechanism you'll have a really bad time.

> If you have concrete examples to test, I am interested! The only
> constraints that you have to respect is that the
> `extra_super_categories` methods should return strict super
> classes.

Well, as the most extreme case, they could just return nothing.

> Anyway you want, except using the same name as for the axiom if you
> still want to support `.Finite()` without `classget` magic

Ah, sorry, I also want this:

```
class Test1(Category):
    Infinite_or_any_other_name = subcategory_with_axioms(axioms.Infinite)  # parsed by the metaclass
    FiniteCommutative = subcategory_with_axioms(axioms.Finite, axioms.Commutative)
```
which is in the url I linked but I haven't copied here.

You can, of course, use the same name. But you don't have to, and you have to put it into code if you do.

> Sorry for the ambiguity: I am speaking of the printing of the category
> with axiom classes.

The order of axioms (which is also the print order) is specified in the `axioms` object. So nothing changes there.

> I am still reluctant with that business. When we implement
> Groups.Finite, it's about the finite groups category. And I believe
> the magic, if any, should reside in the nested class and not in
> Groups. For otherwise, we should do the same for consistency for
> functorial constructions. And if we want later to add yet another type
> of construction, beyond axioms and functorial constructions, the
> metaclass of Groups will have to handle all of them, instead of having
> each nested class just handle its own specifics. So much for
> separation of concerns.

Fair enough, but you can inherit from metaclasses as usual. So the standard OO mechanism for dealing with this concern apply. Even though I don't recommend having too many meta classes.



---

archive/issue_comments_109292.json:
```json
{
    "body": "<a id='comment:4'></a>\nBad news: I just observed a regression in the creation of polynomial rings.\n\nWith the current master, one has\n\n```\nsage: def test():\n....:     for p in prime_range(10000):\n....:         P = GF(p)['t','x','z']\n....:         \nsage: %time test()\nCPU times: user 4.95 s, sys: 0.09 s, total: 5.05 s\nWall time: 5.05 s\n```\nwhich is bad enough (it used to take half of the time two years ago).\n\nWith this ticket, one has\n\n```\nsage: def test():\n....:     for p in prime_range(10000):\n....:         P = GF(p)['t','x','z']\n....:         \nsage: %time test()\nCPU times: user 8.89 s, sys: 0.12 s, total: 9.01 s\nWall time: 9.02 s\n```\n`%prun` says:\n\n```\n    13516    2.688    0.000    2.711    0.000 dynamic_class.py:324(dynamic_class_internal)\n25801/11055    1.034    0.000   10.426    0.001 category.py:1920(join)\n     1229    0.725    0.001   17.076    0.014 polynomial_ring_constructor.py:569(_multi_variate)\n4913/3685    0.673    0.000    5.067    0.001 category_with_axiom.py:2070(super_categories)\n    28256    0.597    0.000    2.898    0.000 category.py:1864(_sort_uniq)\n   140033    0.591    0.000    2.401    0.000 {any}\n149908/137618    0.564    0.000    2.071    0.000 category.py:1371(is_subcategory)\n    14748    0.504    0.000    0.807    0.000 category.py:2756(_subcategory_hook_)\n   160943    0.439    0.000    1.353    0.000 category.py:1886(<genexpr>)\n    41768    0.421    0.000    0.515    0.000 {sorted}\n   175672    0.420    0.000    0.420    0.000 {isinstance}\n    30710    0.364    0.000    0.921    0.000 category.py:1806(_flatten_categories)\n   106875    0.355    0.000    0.557    0.000 category.py:1822(<genexpr>)\n    13511    0.354    0.000    4.731    0.000 category.py:436(__classcall__)\n14741/6141    0.330    0.000   10.581    0.002 category.py:1601(_with_axiom_as_tuple)\n    83830    0.329    0.000    0.527    0.000 category.py:675(_subcategory_hook_)\n    50121    0.291    0.000    0.600    0.000 category_types.py:282(_subcategory_hook_)\n   140093    0.289    0.000    0.289    0.000 {issubclass}\n27021/25791    0.224    0.000    0.608    0.000 category.py:2480(_make_named_class)\n    13510    0.205    0.000    3.420    0.000 category.py:467(__init__)\n13510/6142    0.198    0.000    9.498    0.002 category.py:996(_super_categories)\n    11053    0.191    0.000    2.960    0.000 category_types.py:342(__init__)\n11056/1229    0.185    0.000   10.547    0.009 category_with_axiom.py:1900(__classcall__)\n```\nThe time for taking the join is clearly not acceptable.\n\nI wonder if some trickery for a speed-up would be in order. After all, when we want to create the join of category of algebras over B with category of euclidean domains, and we already have the join of category of algebras over A with category of euclidean domains, then we could cheaply create a copy of the existing category and just replace the base.\n\nWell, not quite, further attributes depend on the base. But perhaps some recycling is possible.",
    "created_at": "2014-02-07T11:00:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109292",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
Bad news: I just observed a regression in the creation of polynomial rings.

With the current master, one has

```
sage: def test():
....:     for p in prime_range(10000):
....:         P = GF(p)['t','x','z']
....:         
sage: %time test()
CPU times: user 4.95 s, sys: 0.09 s, total: 5.05 s
Wall time: 5.05 s
```
which is bad enough (it used to take half of the time two years ago).

With this ticket, one has

```
sage: def test():
....:     for p in prime_range(10000):
....:         P = GF(p)['t','x','z']
....:         
sage: %time test()
CPU times: user 8.89 s, sys: 0.12 s, total: 9.01 s
Wall time: 9.02 s
```
`%prun` says:

```
    13516    2.688    0.000    2.711    0.000 dynamic_class.py:324(dynamic_class_internal)
25801/11055    1.034    0.000   10.426    0.001 category.py:1920(join)
     1229    0.725    0.001   17.076    0.014 polynomial_ring_constructor.py:569(_multi_variate)
4913/3685    0.673    0.000    5.067    0.001 category_with_axiom.py:2070(super_categories)
    28256    0.597    0.000    2.898    0.000 category.py:1864(_sort_uniq)
   140033    0.591    0.000    2.401    0.000 {any}
149908/137618    0.564    0.000    2.071    0.000 category.py:1371(is_subcategory)
    14748    0.504    0.000    0.807    0.000 category.py:2756(_subcategory_hook_)
   160943    0.439    0.000    1.353    0.000 category.py:1886(<genexpr>)
    41768    0.421    0.000    0.515    0.000 {sorted}
   175672    0.420    0.000    0.420    0.000 {isinstance}
    30710    0.364    0.000    0.921    0.000 category.py:1806(_flatten_categories)
   106875    0.355    0.000    0.557    0.000 category.py:1822(<genexpr>)
    13511    0.354    0.000    4.731    0.000 category.py:436(__classcall__)
14741/6141    0.330    0.000   10.581    0.002 category.py:1601(_with_axiom_as_tuple)
    83830    0.329    0.000    0.527    0.000 category.py:675(_subcategory_hook_)
    50121    0.291    0.000    0.600    0.000 category_types.py:282(_subcategory_hook_)
   140093    0.289    0.000    0.289    0.000 {issubclass}
27021/25791    0.224    0.000    0.608    0.000 category.py:2480(_make_named_class)
    13510    0.205    0.000    3.420    0.000 category.py:467(__init__)
13510/6142    0.198    0.000    9.498    0.002 category.py:996(_super_categories)
    11053    0.191    0.000    2.960    0.000 category_types.py:342(__init__)
11056/1229    0.185    0.000   10.547    0.009 category_with_axiom.py:1900(__classcall__)
```
The time for taking the join is clearly not acceptable.

I wonder if some trickery for a speed-up would be in order. After all, when we want to create the join of category of algebras over B with category of euclidean domains, and we already have the join of category of algebras over A with category of euclidean domains, then we could cheaply create a copy of the existing category and just replace the base.

Well, not quite, further attributes depend on the base. But perhaps some recycling is possible.



---

archive/issue_comments_109293.json:
```json
{
    "body": "<a id='comment:5'></a>\nI've thought about something similar in the context of specifying relations. For performance reasons, it would be nice to just deal with base category classes + axioms instead of category instances. The reason for why we deal with instances is, of course, that relations may depend on the base ring (module + base ring is field = vector space). But that could also be implemented by a BaseRingIsField (feel free to suggest better name) axiom.",
    "created_at": "2014-02-07T11:45:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109293",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:5'></a>
I've thought about something similar in the context of specifying relations. For performance reasons, it would be nice to just deal with base category classes + axioms instead of category instances. The reason for why we deal with instances is, of course, that relations may depend on the base ring (module + base ring is field = vector space). But that could also be implemented by a BaseRingIsField (feel free to suggest better name) axiom.



---

archive/issue_comments_109294.json:
```json
{
    "body": "<a id='comment:6'></a>\nAlong about a fairly similar line, I think this is pointing once again\nin the direction of using Algebras(Fields()) rather than\nAlgebras(QQ). I.e. that our current categories over base ring would be\nbetter parametrized by the category of the base ring. This would be\nconsistent with what we are actually doing under the hood for sharing\nthe parent and element classes. And this would open the path toward\nhaving Algebras / PolynomialRings / ... as functorial constructions,\nwhich would, among other things, resolve the current Modules /\nVectorSpaces hack.\n\nOf course this goes far beyond the scope of this ticket, but would be,\nfor example, a good brainstorm/coding sprint topic for Cernay. I\nforesee no obstruction, and think we can reasonably bet that the\nperformance issues that we get are really a side-effect of the\nconstruction of too many duplicated hierarchies of categories (for no\nreal added value) and will vanish soon.\n\nEspecially if we move on and get this ticket in, so that I/we can\nfinally get to work on follow ups likes this one :-)\n\nCheers,\n                              Nicolas",
    "created_at": "2014-02-07T13:34:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109294",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>
Along about a fairly similar line, I think this is pointing once again
in the direction of using Algebras(Fields()) rather than
Algebras(QQ). I.e. that our current categories over base ring would be
better parametrized by the category of the base ring. This would be
consistent with what we are actually doing under the hood for sharing
the parent and element classes. And this would open the path toward
having Algebras / PolynomialRings / ... as functorial constructions,
which would, among other things, resolve the current Modules /
VectorSpaces hack.

Of course this goes far beyond the scope of this ticket, but would be,
for example, a good brainstorm/coding sprint topic for Cernay. I
foresee no obstruction, and think we can reasonably bet that the
performance issues that we get are really a side-effect of the
construction of too many duplicated hierarchies of categories (for no
real added value) and will vanish soon.

Especially if we move on and get this ticket in, so that I/we can
finally get to work on follow ups likes this one :-)

Cheers,
                              Nicolas



---

archive/issue_comments_109295.json:
```json
{
    "body": "<a id='comment:507'></a>\nReplying to [SimonKing](#comment%3A504):\n> The time for taking the join is clearly not acceptable.\n\nYes, there probably is some room for optimization in the current join\nimplementation. But I'd rather rephrase the above as ``we are\ncomputing an unacceptable number of joins, because we are redoing over\nand over (10000 times!) very similar joins''.",
    "created_at": "2014-02-07T13:39:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109295",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:507'></a>
Replying to [SimonKing](#comment%3A504):
> The time for taking the join is clearly not acceptable.

Yes, there probably is some room for optimization in the current join
implementation. But I'd rather rephrase the above as ``we are
computing an unacceptable number of joins, because we are redoing over
and over (10000 times!) very similar joins''.



---

archive/issue_comments_109296.json:
```json
{
    "body": "<a id='comment:508'></a>\nReplying to [nthiery](#comment%3A506):\n> Along about a fairly similar line, I think this is pointing once again\n> in the direction of using Algebras(Fields()) rather than\n> Algebras(QQ).\n\nYes. What is the obstruction for doing so?\n\nI mean, I never understood why we store the base ring information twice (in the category and in the object). When we create any category with basering, we should accept a category instead of a ring.\n\nOr are there category operations where knowledge of the basering (and not just of the category of the basering) is needed?\n\nAnd would it really be particularly difficult to implement? Yes, we would certainly need to fix a lot of doc tests, and also I guess we would have to refine some test\n\n```\n    if R in self.category():\n```\nto\n\n```\n    if R in self.category() and self.base_ring().has_coerce_map_from(R.base_ring())\n```\n(which would actually be more correct than the current test `R in self.category()`, since this would be unaware of the coercion).\n\nAnd the `base_ring()` method should become an abstract method, since the category itself won't know about the basering (hence, couldn't provide a default parent method).\n\nWhat other complications would you expect?\n\n> which would, among other things, resolve the current Modules /\n> VectorSpaces hack.\n\nWould it? We would still want to see `Modules(Fields()) == VectorSpaces()`.\n\nWe could of course also keep the sub-categories where the basering is fixed. As Volker suggested, this amounts to providing an axiom, say, `FixedBaseRing`, so that we would have\n\n```\nsage: VectorSpaces().FixedBaseRing(QQ)\nCategory of vector spaces with fixed base ring Rational Field\n```\n\nFor left- and rightmodules, we might want two axioms, namely for the left and right basering.\n\n> Of course this goes far beyond the scope of this ticket,\n\nNo. Actually I think it *should* be done here. First, it would fight a regression introduced by this ticket. Second, as you stated, it would help making polynomial rings functorial constructions. So, it also matches the ticket's topic.\n\n> the\n> performance issues that we get are really a side-effect of the\n> construction of too many duplicated hierarchies of categories (for no\n> real added value) and will vanish soon.\n\nTo be more precise: We *currently* construct too many duplicated hierarchies of categories, which becomes a problem with *this* ticket, since it makes the construction a little slower, and hence the duplication really becomes noticeable. Arguably there are ideas whose scope fits perfectly within *this* ticket that could fix the duplicated constructions.\n\nI think the current situation is similar to #9138 and #11900/#11935: One ticket, namely #9138, made all rings use the category framework, but introduced a huge regression in some examples, which was noticed in some beta versions. The regressions were fixed on #11900 and #11935. It was (IIRC) *not* the case that #9138 was merged into a release and then the regression fixed later on, but it was merged only together with one (or both, I don't recall) of the other tickets.\n\nAnd similarly, we have here a ticket that certainly yields a huge conceptual improvement of the category framework, but would introduce (or make worse) some regression. We could of course open separate tickets to fix the regression. But these follow-up tickets might eventually be merged into a release version at the same time than this ticket.",
    "created_at": "2014-02-08T10:55:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109296",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:508'></a>
Replying to [nthiery](#comment%3A506):
> Along about a fairly similar line, I think this is pointing once again
> in the direction of using Algebras(Fields()) rather than
> Algebras(QQ).

Yes. What is the obstruction for doing so?

I mean, I never understood why we store the base ring information twice (in the category and in the object). When we create any category with basering, we should accept a category instead of a ring.

Or are there category operations where knowledge of the basering (and not just of the category of the basering) is needed?

And would it really be particularly difficult to implement? Yes, we would certainly need to fix a lot of doc tests, and also I guess we would have to refine some test

```
    if R in self.category():
```
to

```
    if R in self.category() and self.base_ring().has_coerce_map_from(R.base_ring())
```
(which would actually be more correct than the current test `R in self.category()`, since this would be unaware of the coercion).

And the `base_ring()` method should become an abstract method, since the category itself won't know about the basering (hence, couldn't provide a default parent method).

What other complications would you expect?

> which would, among other things, resolve the current Modules /
> VectorSpaces hack.

Would it? We would still want to see `Modules(Fields()) == VectorSpaces()`.

We could of course also keep the sub-categories where the basering is fixed. As Volker suggested, this amounts to providing an axiom, say, `FixedBaseRing`, so that we would have

```
sage: VectorSpaces().FixedBaseRing(QQ)
Category of vector spaces with fixed base ring Rational Field
```

For left- and rightmodules, we might want two axioms, namely for the left and right basering.

> Of course this goes far beyond the scope of this ticket,

No. Actually I think it *should* be done here. First, it would fight a regression introduced by this ticket. Second, as you stated, it would help making polynomial rings functorial constructions. So, it also matches the ticket's topic.

> the
> performance issues that we get are really a side-effect of the
> construction of too many duplicated hierarchies of categories (for no
> real added value) and will vanish soon.

To be more precise: We *currently* construct too many duplicated hierarchies of categories, which becomes a problem with *this* ticket, since it makes the construction a little slower, and hence the duplication really becomes noticeable. Arguably there are ideas whose scope fits perfectly within *this* ticket that could fix the duplicated constructions.

I think the current situation is similar to #9138 and #11900/#11935: One ticket, namely #9138, made all rings use the category framework, but introduced a huge regression in some examples, which was noticed in some beta versions. The regressions were fixed on #11900 and #11935. It was (IIRC) *not* the case that #9138 was merged into a release and then the regression fixed later on, but it was merged only together with one (or both, I don't recall) of the other tickets.

And similarly, we have here a ticket that certainly yields a huge conceptual improvement of the category framework, but would introduce (or make worse) some regression. We could of course open separate tickets to fix the regression. But these follow-up tickets might eventually be merged into a release version at the same time than this ticket.



---

archive/issue_comments_109297.json:
```json
{
    "body": "<a id='comment:509'></a>\nReplying to [SimonKing](#comment%3A508):\n> I think the current situation is similar to #9138 and #11900/#11935: One ticket, namely #9138, made all rings use the category framework, but introduced a huge regression in some examples, which was noticed in some beta versions. The regressions were fixed on #11900 and #11935. It was (IIRC) *not* the case that #9138 was merged into a release and then the regression fixed later on, but it was merged only together with one (or both, I don't recall) of the other tickets.\n\nYes, #9138 and #11900 were merged together, but #11935 was merged much later.",
    "created_at": "2014-02-08T11:10:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109297",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:509'></a>
Replying to [SimonKing](#comment%3A508):
> I think the current situation is similar to #9138 and #11900/#11935: One ticket, namely #9138, made all rings use the category framework, but introduced a huge regression in some examples, which was noticed in some beta versions. The regressions were fixed on #11900 and #11935. It was (IIRC) *not* the case that #9138 was merged into a release and then the regression fixed later on, but it was merged only together with one (or both, I don't recall) of the other tickets.

Yes, #9138 and #11900 were merged together, but #11935 was merged much later.



---

archive/issue_comments_109298.json:
```json
{
    "body": "<a id='comment:0'></a>\nI think we should avoid non-singleton axioms, which this would require:\n\n```\nsage: VectorSpaces().FixedBaseRing(GF(p))\n```\nWhile that would allow us to have only a single base category, you'd still end up with a different category for each `GF(p)` (and, therefore, independent joins). But nothing really depends on `p`, you just need to know that `GF(p)` is a prime. Really, whenever you allow an instance in the category framework depend directly on user input you'll run into performance issues when you create categories in a tight loop.\n\nI agree that we should at least have a plan for which direction this is moving, since it might change the way we specify relations.",
    "created_at": "2014-02-08T12:55:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109298",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:0'></a>
I think we should avoid non-singleton axioms, which this would require:

```
sage: VectorSpaces().FixedBaseRing(GF(p))
```
While that would allow us to have only a single base category, you'd still end up with a different category for each `GF(p)` (and, therefore, independent joins). But nothing really depends on `p`, you just need to know that `GF(p)` is a prime. Really, whenever you allow an instance in the category framework depend directly on user input you'll run into performance issues when you create categories in a tight loop.

I agree that we should at least have a plan for which direction this is moving, since it might change the way we specify relations.



---

archive/issue_comments_109299.json:
```json
{
    "body": "<a id='comment:1'></a>\nIt would be fairly easy to enable the following:\n\n```\nage: C = Algebras(Fields())\nsage: C\nCategory of algebras over Category of fields\nsage: C.super_categories()\n[Category of rings,\n Category of associative algebras over Category of fields,\n Category of unital algebras over Category of fields]\nsage: _[1].super_categories()\n[Category of rngs, Category of magmatic algebras over Category of fields]\nsage: _[1].super_categories()\n[Category of additive commutative additive associative additive unital distributive magmas and additive magmas,\n Category of modules over Category of fields]\nsage: _[1].super_categories()\n[Category of bimodules over Category of fields on the left and Category of fields on the right]\nsage: _[0].super_categories()\n[Category of left modules over Category of fields,\n Category of right modules over Category of fields]\nsage: _[0].super_categories()\n[Category of commutative additive groups]\n```\n\nI think we would then also want that the \"category of Bs over Category of fields\" is among the super categories of the \"category of Bs over Rational field\". But where to implement it? I tried to provide it in `Category_over_base.extra_super_categories()`, but this has not done the trick.",
    "created_at": "2014-02-08T12:59:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109299",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
It would be fairly easy to enable the following:

```
age: C = Algebras(Fields())
sage: C
Category of algebras over Category of fields
sage: C.super_categories()
[Category of rings,
 Category of associative algebras over Category of fields,
 Category of unital algebras over Category of fields]
sage: _[1].super_categories()
[Category of rngs, Category of magmatic algebras over Category of fields]
sage: _[1].super_categories()
[Category of additive commutative additive associative additive unital distributive magmas and additive magmas,
 Category of modules over Category of fields]
sage: _[1].super_categories()
[Category of bimodules over Category of fields on the left and Category of fields on the right]
sage: _[0].super_categories()
[Category of left modules over Category of fields,
 Category of right modules over Category of fields]
sage: _[0].super_categories()
[Category of commutative additive groups]
```

I think we would then also want that the "category of Bs over Category of fields" is among the super categories of the "category of Bs over Rational field". But where to implement it? I tried to provide it in `Category_over_base.extra_super_categories()`, but this has not done the trick.



---

archive/issue_comments_109300.json:
```json
{
    "body": "<a id='comment:2'></a>\nAha, I forgot: category with axiom overrides `Category_over_base.extra_super_categories`. Should it perhaps recurse?",
    "created_at": "2014-02-08T13:01:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109300",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Aha, I forgot: category with axiom overrides `Category_over_base.extra_super_categories`. Should it perhaps recurse?



---

archive/issue_comments_109301.json:
```json
{
    "body": "<a id='comment:3'></a>\nOr is `extra_super_categories` the wrong thing to look at here?\n\nCan you give me a pointer to the docs where it is explained what to put in `super_categories()` and what to put in `extra_super_categories()`?",
    "created_at": "2014-02-08T15:28:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109301",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Or is `extra_super_categories` the wrong thing to look at here?

Can you give me a pointer to the docs where it is explained what to put in `super_categories()` and what to put in `extra_super_categories()`?



---

archive/issue_comments_109302.json:
```json
{
    "body": "<a id='comment:514'></a>\nReplying to [SimonKing](#comment%3A508):\n> Replying to [nthiery](#comment%3A506):\n> > Along about a fairly similar line, I think this is pointing once again\n> > in the direction of using Algebras(Fields()) rather than\n> > Algebras(QQ).\n\n> \n> Yes. What is the obstruction for doing so?\n> \n> I mean, I never understood why we store the base ring information twice (in the category and in the object). When we create any category with basering, we should accept a category instead of a ring.\n> \n> Or are there category operations where knowledge of the basering (and not just of the category of the basering) is needed?\n\nThere are mathematical reasons why you might want to have this information: For\nthe category of R-modules to be abelian, one needs R\nspecified. So, from a category-theoretic point of view it would be desirable to\nhave an object \"left modules over R\", with \"R\" specified--otherwise you don't\nhave an object symbolizing the relevant abelian category. However, we're finding\nthat doing so is too costly for all objects, because most objects don't care\nabout their category.\n\nIt reminds me of the situation where `Integers(p)` doesn't construct itself to\nlie in `Fields()` because the primality test is too expensive in general. Would\nit be an idea to initially put things in the category `Modules(Rings())` and\nthen refine the category with the base ring if required?\n\nOne would need to very carefully analyse the situations that would have to\ntrigger a category refinement, which is particularly treacherous because the\ncategory refinement will have global effects, since the relevant module is a\nparent and hence likely globally unique: You could have a module that suddenly\nchanges category because some other piece of code somewhere decides it needs a\nfiner category (after all, this strange \"category\" of \"left modules over rings\"\nis partitioned in abelian categories of \"left R-modules\", parametrized by \"R\")\n\nOf course, as pointed out, it's not so clear we actually *need* the category to\never be refined, other than to accurately model mathematical theory. There's\nnothing actually hanging off the registration of the base with the category.\n\nSo, perhaps this can be taken as an argument for not registering the base in the\ncategory at all, for now: if we need it at some later point, we could try and\nimplement it via category refinement (and deal with all the dragons that come\nwith it)",
    "created_at": "2014-02-08T16:13:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109302",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:514'></a>
Replying to [SimonKing](#comment%3A508):
> Replying to [nthiery](#comment%3A506):
> > Along about a fairly similar line, I think this is pointing once again
> > in the direction of using Algebras(Fields()) rather than
> > Algebras(QQ).

> 
> Yes. What is the obstruction for doing so?
> 
> I mean, I never understood why we store the base ring information twice (in the category and in the object). When we create any category with basering, we should accept a category instead of a ring.
> 
> Or are there category operations where knowledge of the basering (and not just of the category of the basering) is needed?

There are mathematical reasons why you might want to have this information: For
the category of R-modules to be abelian, one needs R
specified. So, from a category-theoretic point of view it would be desirable to
have an object "left modules over R", with "R" specified--otherwise you don't
have an object symbolizing the relevant abelian category. However, we're finding
that doing so is too costly for all objects, because most objects don't care
about their category.

It reminds me of the situation where `Integers(p)` doesn't construct itself to
lie in `Fields()` because the primality test is too expensive in general. Would
it be an idea to initially put things in the category `Modules(Rings())` and
then refine the category with the base ring if required?

One would need to very carefully analyse the situations that would have to
trigger a category refinement, which is particularly treacherous because the
category refinement will have global effects, since the relevant module is a
parent and hence likely globally unique: You could have a module that suddenly
changes category because some other piece of code somewhere decides it needs a
finer category (after all, this strange "category" of "left modules over rings"
is partitioned in abelian categories of "left R-modules", parametrized by "R")

Of course, as pointed out, it's not so clear we actually *need* the category to
ever be refined, other than to accurately model mathematical theory. There's
nothing actually hanging off the registration of the base with the category.

So, perhaps this can be taken as an argument for not registering the base in the
category at all, for now: if we need it at some later point, we could try and
implement it via category refinement (and deal with all the dragons that come
with it)



---

archive/issue_comments_109303.json:
```json
{
    "body": "<a id='comment:515'></a>\nReplying to [nbruin](#comment%3A514):\n> So, perhaps this can be taken as an argument for not registering the base in the\n> category at all,\n\nIf we talk about operations on the parent: The parent knows the base ring, and thus the parent's category does not need to know the base ring as well.\n\nOnly when we have a pure categorical construction that is independent of any specific parent would we need the category to know about a specific base ring.",
    "created_at": "2014-02-08T19:32:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109303",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:515'></a>
Replying to [nbruin](#comment%3A514):
> So, perhaps this can be taken as an argument for not registering the base in the
> category at all,

If we talk about operations on the parent: The parent knows the base ring, and thus the parent's category does not need to know the base ring as well.

Only when we have a pure categorical construction that is independent of any specific parent would we need the category to know about a specific base ring.



---

archive/issue_comments_109304.json:
```json
{
    "body": "<a id='comment:516'></a>\nReplying to [SimonKing](#comment%3A515):\n> Only when we have a pure categorical construction that is independent of any specific parent would we need the category to know about a specific base ring.\n\nYes, the only thing I can think of at this time is where you want to represent, e.g., the tensor map, assigning to a pair of vector spaces (over the same base!), the tensor product of the two. The domain and codomain of that map would have to be categories with specified base.\n\nIf we end up needing categories with specified base in some cases, we may even be able to resolve the \"V in VectorSpaces(Rationals())\" without having to mess with the MRO: we could just do that test by comparing the registered base on both.",
    "created_at": "2014-02-08T21:38:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109304",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:516'></a>
Replying to [SimonKing](#comment%3A515):
> Only when we have a pure categorical construction that is independent of any specific parent would we need the category to know about a specific base ring.

Yes, the only thing I can think of at this time is where you want to represent, e.g., the tensor map, assigning to a pair of vector spaces (over the same base!), the tensor product of the two. The domain and codomain of that map would have to be categories with specified base.

If we end up needing categories with specified base in some cases, we may even be able to resolve the "V in VectorSpaces(Rationals())" without having to mess with the MRO: we could just do that test by comparing the registered base on both.



---

archive/issue_comments_109305.json:
```json
{
    "body": "<a id='comment:7'></a>\nDo I see that correctly: In the current implementation, it is impossible to pass an argument to an axiom.\n\nHence, we can do `Blas().Finite()`, but it would be syntactically impossible to define an axiom such as \"`FixedBaseRing`\", so that `Blas().FixedBaseRing(QQ)`. Or how would one define such thing?\n\nI tried this:\n\n```\nclass FixedBaseRing(CategoryWithAxiom):\n    def __init__(self, base_category, base_ring):\n        if base_ring not in base_category.base():\n            raise ValueError, \"The base ring %s ought to be an object in %s\"%(base_ring, base_category.base())\n        CategoryWithAxiom.__init__(self, base_category)\n        self.__base_ring = base_ring\n    class SubcategoryMethods:\n        def base_ring(self):\n            return self.__base_ring\n```\nand\n\n```\nsage: class MyCategoryOverBase(Category_over_base):            \n....:     def super_categories(self):\n....:         return [Objects()]\n....:     FixedBaseRing = FixedBaseRing\n....:     class SubcategoryMethods:\n....:         def FixedBaseRing(self, base_ring):\n....:             return self._with_axiom(\"FixedBaseRing\")(base_ring)\n....:         \nsage: C = MyCategoryOverBase(Rings())\n```\nbut got\n\n```\nsage: C.FixedBaseRing(QQ)\nTraceback (most recent call last):\n...\nTypeError: __init__() takes exactly 3 arguments (2 given)\n```\nwhich occurs internally when doing `C._with_axiom(\"FixedBaseRing\")`.\n\nIs there currently a way to implement this? Should `_with_axiom()` perhaps accept optional arguments, to be passed to the init method of the category-class-with-axiom, so that `C._with_axiom(\"FixedBaseRing\", QQ)` would happen internally?",
    "created_at": "2014-02-09T14:11:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109305",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Do I see that correctly: In the current implementation, it is impossible to pass an argument to an axiom.

Hence, we can do `Blas().Finite()`, but it would be syntactically impossible to define an axiom such as "`FixedBaseRing`", so that `Blas().FixedBaseRing(QQ)`. Or how would one define such thing?

I tried this:

```
class FixedBaseRing(CategoryWithAxiom):
    def __init__(self, base_category, base_ring):
        if base_ring not in base_category.base():
            raise ValueError, "The base ring %s ought to be an object in %s"%(base_ring, base_category.base())
        CategoryWithAxiom.__init__(self, base_category)
        self.__base_ring = base_ring
    class SubcategoryMethods:
        def base_ring(self):
            return self.__base_ring
```
and

```
sage: class MyCategoryOverBase(Category_over_base):            
....:     def super_categories(self):
....:         return [Objects()]
....:     FixedBaseRing = FixedBaseRing
....:     class SubcategoryMethods:
....:         def FixedBaseRing(self, base_ring):
....:             return self._with_axiom("FixedBaseRing")(base_ring)
....:         
sage: C = MyCategoryOverBase(Rings())
```
but got

```
sage: C.FixedBaseRing(QQ)
Traceback (most recent call last):
...
TypeError: __init__() takes exactly 3 arguments (2 given)
```
which occurs internally when doing `C._with_axiom("FixedBaseRing")`.

Is there currently a way to implement this? Should `_with_axiom()` perhaps accept optional arguments, to be passed to the init method of the category-class-with-axiom, so that `C._with_axiom("FixedBaseRing", QQ)` would happen internally?



---

archive/issue_comments_109306.json:
```json
{
    "body": "<a id='comment:8'></a>\nPart of the problem is this classcall method of category-with-axiom:\n\n```python\n    @staticmethod\n    def __classcall__(cls, *args, **options):\n        (base_category_class, axiom) = cls._base_category_class_and_axiom\n        if len(args) == 1 and not options and isinstance(args[0], base_category_class):\n            return super(CategoryWithAxiom, cls).__classcall__(cls, args[0])\n        else:\n            # The following fails with Modules(QQ), as the later returns\n            # VectorSpaces(QQ) which is not an instance of the\n            # base_category_class of ModulesWithBasis\n            # return cls(base_category_class(*args, **options))\n            return base_category_class(*args, **options)._with_axiom(axiom)\n```\nHence, when doing\n\n```\nsage: C.__class__.FixedBaseRing(C,QQ)\n```\nthen the additional argument `QQ` is passed to the init of `base_category_class`, which fails.",
    "created_at": "2014-02-09T14:16:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109306",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Part of the problem is this classcall method of category-with-axiom:

```python
    @staticmethod
    def __classcall__(cls, *args, **options):
        (base_category_class, axiom) = cls._base_category_class_and_axiom
        if len(args) == 1 and not options and isinstance(args[0], base_category_class):
            return super(CategoryWithAxiom, cls).__classcall__(cls, args[0])
        else:
            # The following fails with Modules(QQ), as the later returns
            # VectorSpaces(QQ) which is not an instance of the
            # base_category_class of ModulesWithBasis
            # return cls(base_category_class(*args, **options))
            return base_category_class(*args, **options)._with_axiom(axiom)
```
Hence, when doing

```
sage: C.__class__.FixedBaseRing(C,QQ)
```
then the additional argument `QQ` is passed to the init of `base_category_class`, which fails.



---

archive/issue_comments_109307.json:
```json
{
    "body": "<a id='comment:9'></a>\nIMHO it is a feature that you cannot pass an argument to an axiom. The last thing we need are two independent ways to add user-defined parameters to base categories. It also misses the point of mixin as providing methods but not state. There is already a way do deal with state, namely make `FixedBaseRing` into a category and form join categories.",
    "created_at": "2014-02-09T17:44:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109307",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:9'></a>
IMHO it is a feature that you cannot pass an argument to an axiom. The last thing we need are two independent ways to add user-defined parameters to base categories. It also misses the point of mixin as providing methods but not state. There is already a way do deal with state, namely make `FixedBaseRing` into a category and form join categories.



---

archive/issue_comments_109308.json:
```json
{
    "body": "<a id='comment:520'></a>\nReplying to [vbraun](#comment%3A519):\n> IMHO it is a feature that you cannot pass an argument to an axiom. The last thing we need are two independent ways to add user-defined parameters to base categories. It also misses the point of mixin as providing methods but not state. There is already a way do deal with state, namely make `FixedBaseRing` into a category and form join categories.\n\n+1.",
    "created_at": "2014-02-10T11:15:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109308",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:520'></a>
Replying to [vbraun](#comment%3A519):
> IMHO it is a feature that you cannot pass an argument to an axiom. The last thing we need are two independent ways to add user-defined parameters to base categories. It also misses the point of mixin as providing methods but not state. There is already a way do deal with state, namely make `FixedBaseRing` into a category and form join categories.

+1.



---

archive/issue_comments_109309.json:
```json
{
    "body": "<a id='comment:521'></a>\nReplying to [nthiery](#comment%3A520):\n> It also misses the point of mixin as providing methods but not state. There is already a way do deal with state, namely make `FixedBaseRing` into a category and form join categories.\n\nSo, the strategy would be this: The current \"Category over base ring\" should accept as input no a ring, but a subcategory of the category of rings. A polynomial ring should be initialised in the category of \"commutative algebras over Category of quotient fields\" (say), and should of course have its own reference to the base ring (say, the rational field).\n\nSince the parent and element classes only depend on the category of the base ring (by the current implementation), a category refinement would probably not be needed. But *if* needed, it would amount to take the join with the category \"`FixedBaseField(QQ)`, perhaps with super-categories \"`FixedBaseRing(QQ)`\".\n\nAdditional technical problem: We not only have base rings, but (for bimodules) left and right base rings. Should this be reflected in the \"`FixedBaseBla`\" categories as well?\n\nAnd another complication: We want to have categories expressing the fact that a field (not just a ring) is acting on the objects, and then want to compute the join. Is there an easy programmatic way to let an error be raised when someone tries to compute the join \"`Algebras(Fields()) & FixedBaseRing(ZZ)`\"?",
    "created_at": "2014-02-10T11:44:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109309",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:521'></a>
Replying to [nthiery](#comment%3A520):
> It also misses the point of mixin as providing methods but not state. There is already a way do deal with state, namely make `FixedBaseRing` into a category and form join categories.

So, the strategy would be this: The current "Category over base ring" should accept as input no a ring, but a subcategory of the category of rings. A polynomial ring should be initialised in the category of "commutative algebras over Category of quotient fields" (say), and should of course have its own reference to the base ring (say, the rational field).

Since the parent and element classes only depend on the category of the base ring (by the current implementation), a category refinement would probably not be needed. But *if* needed, it would amount to take the join with the category "`FixedBaseField(QQ)`, perhaps with super-categories "`FixedBaseRing(QQ)`".

Additional technical problem: We not only have base rings, but (for bimodules) left and right base rings. Should this be reflected in the "`FixedBaseBla`" categories as well?

And another complication: We want to have categories expressing the fact that a field (not just a ring) is acting on the objects, and then want to compute the join. Is there an easy programmatic way to let an error be raised when someone tries to compute the join "`Algebras(Fields()) & FixedBaseRing(ZZ)`"?



---

archive/issue_comments_109310.json:
```json
{
    "body": "<a id='comment:522'></a>\nReplying to [SimonKing](#comment%3A508):\n> Yes. What is the obstruction for doing so?\n\nI foresee no serious obstruction but taking the time to implement it,\nand go trough the code, decide in each case whether we want to use\n`Algebras(QQ)}} or {{{Algebras(Fields())`, and update the doctests\naccordingly. In most case, the latter idiom will be preferable,\nunless, as was mentioned in other comments, when we want to do\noperations on the category itself.\n\n> > which would, among other things, resolve the current Modules /\n> > VectorSpaces hack.\n\n> \n> Would it? We would still want to see `Modules(Fields()) == VectorSpaces()`.\n\nYes, but we would not need to make a special case for it. It would be\nan automatic side effect of the functorial construction.\n\n> > Of course this goes far beyond the scope of this ticket,\n\n> \n> No. Actually I think it *should* be done here. First, it would fight a regression introduced by this ticket. Second, as you stated, it would help making polynomial rings functorial constructions. So, it also matches the ticket's topic.\n\nWell, yes the ticket's topic ``more functorial constructions`` is\nrather broad. At this rate we could keep on working on it for years\n:-)\n\nSeriously: this ticket is really about axioms; by legacy reason it\ncontains a bunch of related stuff that would have been best in\nseparate tickets (I take the blame for it); let's not add more!\n\nI just created #15801 for this.\n\n> To be more precise: We *currently* construct too many duplicated\n> hierarchies of categories, which becomes a problem with *this*\n> ticket, since it makes the construction a little slower, and hence\n> the duplication really becomes noticeable. Arguably there are ideas\n> whose scope fits perfectly within *this* ticket that could fix the\n> duplicated constructions.\n\nAs you noted in your benchmarks, the regression already exists without\nthis ticket. This ticket certainly makes it worst, but not by orders\nof magnitude. I believe we can live with the regression between the\ntime #10963 ticket is merged and the next one is too. If both tickets\ncan go in the same release of Sage, so much the better, but that's it.\nAnd in the mean time we have a clean code base to work on.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-02-10T11:45:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109310",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:522'></a>
Replying to [SimonKing](#comment%3A508):
> Yes. What is the obstruction for doing so?

I foresee no serious obstruction but taking the time to implement it,
and go trough the code, decide in each case whether we want to use
`Algebras(QQ)}} or {{{Algebras(Fields())`, and update the doctests
accordingly. In most case, the latter idiom will be preferable,
unless, as was mentioned in other comments, when we want to do
operations on the category itself.

> > which would, among other things, resolve the current Modules /
> > VectorSpaces hack.

> 
> Would it? We would still want to see `Modules(Fields()) == VectorSpaces()`.

Yes, but we would not need to make a special case for it. It would be
an automatic side effect of the functorial construction.

> > Of course this goes far beyond the scope of this ticket,

> 
> No. Actually I think it *should* be done here. First, it would fight a regression introduced by this ticket. Second, as you stated, it would help making polynomial rings functorial constructions. So, it also matches the ticket's topic.

Well, yes the ticket's topic ``more functorial constructions`` is
rather broad. At this rate we could keep on working on it for years
:-)

Seriously: this ticket is really about axioms; by legacy reason it
contains a bunch of related stuff that would have been best in
separate tickets (I take the blame for it); let's not add more!

I just created #15801 for this.

> To be more precise: We *currently* construct too many duplicated
> hierarchies of categories, which becomes a problem with *this*
> ticket, since it makes the construction a little slower, and hence
> the duplication really becomes noticeable. Arguably there are ideas
> whose scope fits perfectly within *this* ticket that could fix the
> duplicated constructions.

As you noted in your benchmarks, the regression already exists without
this ticket. This ticket certainly makes it worst, but not by orders
of magnitude. I believe we can live with the regression between the
time #10963 ticket is merged and the next one is too. If both tickets
can go in the same release of Sage, so much the better, but that's it.
And in the mean time we have a clean code base to work on.

Cheers,
                              Nicolas



---

archive/issue_comments_109311.json:
```json
{
    "body": "<a id='comment:523'></a>\nReplying to [SimonKing](#comment%3A521):\n> ...\n\nDiscussion moved to #15801.",
    "created_at": "2014-02-10T11:56:58Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109311",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:523'></a>
Replying to [SimonKing](#comment%3A521):
> ...

Discussion moved to #15801.



---

archive/issue_comments_109312.json:
```json
{
    "body": "<a id='comment:524'></a>\n> To answer your timeline question, I'd say less than a month.\n\nWhat is the status on this? As you might be aware, there is a lot of code being developed that uses the features of this ticket!!!",
    "created_at": "2014-02-21T22:13:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109312",
    "user": "https://github.com/anneschilling"
}
```

<a id='comment:524'></a>
> To answer your timeline question, I'd say less than a month.

What is the status on this? As you might be aware, there is a lot of code being developed that uses the features of this ticket!!!



---

archive/issue_comments_109313.json:
```json
{
    "body": "<a id='comment:5'></a>\nI'm still waiting for a response to [comment:503](#comment%3A503) ...",
    "created_at": "2014-02-21T22:31:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109313",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:5'></a>
I'm still waiting for a response to [comment:503](#comment%3A503) ...



---

archive/issue_comments_109314.json:
```json
{
    "body": "<a id='comment:526'></a>\nReplying to [vbraun](#comment%3A525):\n> I'm still waiting for a response to [comment:503](#comment%3A503) ...\n\nOh, you are?\n\nHmm. I just came back to it. We are not quite on the same position (I\nprefer the current approach; you prefer yours), though not so far\neither, and I am not sure how to make the discussion move on.\n\nHonestly, it would be soooo much more efficient to explore this by\nworking together on concrete code in Cernay. If we could get this\nticket in now, it would allow to get a bunch of projects and people\nmoving. Whatever refactoring we do, it's not going to be fundamental\nchanges, and it's not like the code base will be so much bigger and\nhard to refactor in six weeks from now.\n\nTo get this ticket in now would require:\n\n- Someone reviewing my recent changes (primer and main documentation\n  of categories with axiom). Simon?\n- A few small extra improvements to that doc (probably an hour or two\n  of work on my side)\n- Double checking that things still merge and pass tests smoothly with\n  the latest beta release\n\nI won't have a good connection in the coming week, but I can try to\nsqueeze that in.\n\nCheers,\n                          Nicolas",
    "created_at": "2014-02-21T23:07:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109314",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:526'></a>
Replying to [vbraun](#comment%3A525):
> I'm still waiting for a response to [comment:503](#comment%3A503) ...

Oh, you are?

Hmm. I just came back to it. We are not quite on the same position (I
prefer the current approach; you prefer yours), though not so far
either, and I am not sure how to make the discussion move on.

Honestly, it would be soooo much more efficient to explore this by
working together on concrete code in Cernay. If we could get this
ticket in now, it would allow to get a bunch of projects and people
moving. Whatever refactoring we do, it's not going to be fundamental
changes, and it's not like the code base will be so much bigger and
hard to refactor in six weeks from now.

To get this ticket in now would require:

- Someone reviewing my recent changes (primer and main documentation
  of categories with axiom). Simon?
- A few small extra improvements to that doc (probably an hour or two
  of work on my side)
- Double checking that things still merge and pass tests smoothly with
  the latest beta release

I won't have a good connection in the coming week, but I can try to
squeeze that in.

Cheers,
                          Nicolas



---

archive/issue_comments_109315.json:
```json
{
    "body": "<a id='comment:7'></a>\nI disagree, we should definitely not merge this ticket until it is in a state that does not require any major changes. Anything else will just be huge pita for anybody trying to learn or use it. Sure we can merge it with a big fat warning \"DO NOT USE THE CODE HERE YET\" but then its easier to just not do it and keep it in a separate git branch. In fact, git makes it easy to have long-lived branches to work on big features. Nobody is stopping anyone from working on concrete code...\n\nIn other words, the main goal should not just be to get people moving, but also have them move in the right direction ;-)\n\nIn order to make progress, how about you explain what you don't like and we'll try to find an approach that makes everyone happy.",
    "created_at": "2014-02-22T07:12:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109315",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:7'></a>
I disagree, we should definitely not merge this ticket until it is in a state that does not require any major changes. Anything else will just be huge pita for anybody trying to learn or use it. Sure we can merge it with a big fat warning "DO NOT USE THE CODE HERE YET" but then its easier to just not do it and keep it in a separate git branch. In fact, git makes it easy to have long-lived branches to work on big features. Nobody is stopping anyone from working on concrete code...

In other words, the main goal should not just be to get people moving, but also have them move in the right direction ;-)

In order to make progress, how about you explain what you don't like and we'll try to find an approach that makes everyone happy.



---

archive/issue_comments_109316.json:
```json
{
    "body": "<a id='comment:528'></a>\nReplying to [nthiery](#comment%3A526):\n> Honestly, it would be soooo much more efficient to explore this by\n> working together on concrete code in Cernay.\n\nI can't attend it.\n\n> - Someone reviewing my recent changes (primer and main documentation\n>   of categories with axiom). Simon?\n\nWhat commits are these? I see\n\n```\n* c718f21 - (HEAD, ticket/10963) #10963: typo fix 12963 -> 10963 (vor 3 Wochen) <Nicolas M. Thi\u00e9ry>\n* 3e2003d - Reviewed Peter's renaming of summand_* methods of Cartesian products, using deprecated_function_alias (vor 3 Wochen\n) <Nicolas M. Thi\u00e9ry>\n* 98a4407 - rename summand_* methods of Cartesian products (vor 3 Wochen) <Peter Bruin>\n```\nand then some merge commits. Is what you want me to review further down in the log?",
    "created_at": "2014-02-22T07:31:48Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109316",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:528'></a>
Replying to [nthiery](#comment%3A526):
> Honestly, it would be soooo much more efficient to explore this by
> working together on concrete code in Cernay.

I can't attend it.

> - Someone reviewing my recent changes (primer and main documentation
>   of categories with axiom). Simon?

What commits are these? I see

```
* c718f21 - (HEAD, ticket/10963) #10963: typo fix 12963 -> 10963 (vor 3 Wochen) <Nicolas M. Thiéry>
* 3e2003d - Reviewed Peter's renaming of summand_* methods of Cartesian products, using deprecated_function_alias (vor 3 Wochen
) <Nicolas M. Thiéry>
* 98a4407 - rename summand_* methods of Cartesian products (vor 3 Wochen) <Peter Bruin>
```
and then some merge commits. Is what you want me to review further down in the log?



---

archive/issue_comments_109317.json:
```json
{
    "body": "<a id='comment:9'></a>\nThere is a merge conflict with the current develop branch. I'll try to fix that.",
    "created_at": "2014-02-22T11:51:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109317",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
There is a merge conflict with the current develop branch. I'll try to fix that.



---

archive/issue_comments_109318.json:
```json
{
    "body": "<a id='comment:0'></a>\nSorry, I keep confusing the three versions that I see when applying a merge tool.\n\nIs `EuclideanDomains.ElementMethods`  supposed to provide a gcd method? Or is this ticket *removing* the gcd method?",
    "created_at": "2014-02-22T11:57:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109318",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Sorry, I keep confusing the three versions that I see when applying a merge tool.

Is `EuclideanDomains.ElementMethods`  supposed to provide a gcd method? Or is this ticket *removing* the gcd method?



---

archive/issue_comments_109319.json:
```json
{
    "body": "<a id='comment:1'></a>\nAhaa! The gcd method is in the develop branch, introduced in #13441. I suppose we want to keep that in, and will push a merge accordingly.",
    "created_at": "2014-02-22T12:22:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109319",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Ahaa! The gcd method is in the develop branch, introduced in #13441. I suppose we want to keep that in, and will push a merge accordingly.



---

archive/issue_comments_109320.json:
```json
{
    "body": "**Changing commit** from \"[c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7](https://github.com/sagemath/sagetrac-mirror/commit/c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7)\" to \"[56c8eaaa369528e52d716f13752ad58e24438233](https://github.com/sagemath/sagetrac-mirror/commit/56c8eaaa369528e52d716f13752ad58e24438233)\".",
    "created_at": "2014-02-22T12:24:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109320",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7](https://github.com/sagemath/sagetrac-mirror/commit/c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7)" to "[56c8eaaa369528e52d716f13752ad58e24438233](https://github.com/sagemath/sagetrac-mirror/commit/56c8eaaa369528e52d716f13752ad58e24438233)".



---

archive/issue_comments_109321.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/56c8eaaa369528e52d716f13752ad58e24438233\">56c8eaa</a></td><td><code>Merge branch 'develop' into ticket/10963</code></td></tr></table>\n",
    "created_at": "2014-02-22T12:24:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109321",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/56c8eaaa369528e52d716f13752ad58e24438233">56c8eaa</a></td><td><code>Merge branch 'develop' into ticket/10963</code></td></tr></table>




---

archive/issue_comments_109322.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7ab3103368e46d33f37e135a9eb09a1e16a029a7\">7ab3103</a></td><td><code>Fixing some typos in the category primer and category_with_axioms</code></td></tr></table>\n",
    "created_at": "2014-02-23T17:57:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109322",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7ab3103368e46d33f37e135a9eb09a1e16a029a7">7ab3103</a></td><td><code>Fixing some typos in the category primer and category_with_axioms</code></td></tr></table>




---

archive/issue_comments_109323.json:
```json
{
    "body": "**Changing commit** from \"[56c8eaaa369528e52d716f13752ad58e24438233](https://github.com/sagemath/sagetrac-mirror/commit/56c8eaaa369528e52d716f13752ad58e24438233)\" to \"[7ab3103368e46d33f37e135a9eb09a1e16a029a7](https://github.com/sagemath/sagetrac-mirror/commit/7ab3103368e46d33f37e135a9eb09a1e16a029a7)\".",
    "created_at": "2014-02-23T17:57:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109323",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[56c8eaaa369528e52d716f13752ad58e24438233](https://github.com/sagemath/sagetrac-mirror/commit/56c8eaaa369528e52d716f13752ad58e24438233)" to "[7ab3103368e46d33f37e135a9eb09a1e16a029a7](https://github.com/sagemath/sagetrac-mirror/commit/7ab3103368e46d33f37e135a9eb09a1e16a029a7)".



---

archive/issue_comments_109324.json:
```json
{
    "body": "<a id='comment:4'></a>\nI worked on some details in the category primer and in the beginning of `sage.categories.category_with_axiom`. For now, I stopped reading, since I found the exposition a bit confusing. E.g., I don't like that it is first explained how to override `Sets().Finite` before explaining what `Sets().Finite` actually does. But I will probably not be able to work on it in the next couple of days and thus wanted to push some trivial fixes.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7ab3103368e46d33f37e135a9eb09a1e16a029a7\">7ab3103</a></td><td><code>Fixing some typos in the category primer and category_with_axioms</code></td></tr></table>\n",
    "created_at": "2014-02-23T18:02:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109324",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
I worked on some details in the category primer and in the beginning of `sage.categories.category_with_axiom`. For now, I stopped reading, since I found the exposition a bit confusing. E.g., I don't like that it is first explained how to override `Sets().Finite` before explaining what `Sets().Finite` actually does. But I will probably not be able to work on it in the next couple of days and thus wanted to push some trivial fixes.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7ab3103368e46d33f37e135a9eb09a1e16a029a7">7ab3103</a></td><td><code>Fixing some typos in the category primer and category_with_axioms</code></td></tr></table>




---

archive/issue_comments_109325.json:
```json
{
    "body": "<a id='comment:5'></a>\nPart of my confusion is due to those things:\n\n```\nsage: Semigroups().Finite\nCached version of <function Finite at 0xa4c2c6c>\nsage: Semigroups().__class__.Finite\n<class 'sage.categories.finite_semigroups.FiniteSemigroups'>\n```\nI think it needs to be explained in the doc both *how* and *why* `Semigroups()` does not use the attribute that is defined in its class.\n\nConcerning \"how\", sure, it is happening in `Semigroups().__dict__`. But what part of the code is putting the cached method into `__dict__`, overriding the (lazily imported) class \"`FiniteSemigroups`\" that is stored as a class attribute? Is it generally the case that a `SubcategoryMethod` overrides a class attribute on instances???\n\nConcerning \"why\": I think it is absolutely necessary to give a good rationale. After all, the cached method that `Semigroups()` inherits from `Sets.SubcategoryMethods` is eventually just returning `Semigroups.Finite()` (which is *not* inherited from `Sets.SubcategoryMethods`). So, what would change if `Semigroups().Finite` would be gotten from `Semigroups.Finite`?",
    "created_at": "2014-02-23T19:59:48Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109325",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
Part of my confusion is due to those things:

```
sage: Semigroups().Finite
Cached version of <function Finite at 0xa4c2c6c>
sage: Semigroups().__class__.Finite
<class 'sage.categories.finite_semigroups.FiniteSemigroups'>
```
I think it needs to be explained in the doc both *how* and *why* `Semigroups()` does not use the attribute that is defined in its class.

Concerning "how", sure, it is happening in `Semigroups().__dict__`. But what part of the code is putting the cached method into `__dict__`, overriding the (lazily imported) class "`FiniteSemigroups`" that is stored as a class attribute? Is it generally the case that a `SubcategoryMethod` overrides a class attribute on instances???

Concerning "why": I think it is absolutely necessary to give a good rationale. After all, the cached method that `Semigroups()` inherits from `Sets.SubcategoryMethods` is eventually just returning `Semigroups.Finite()` (which is *not* inherited from `Sets.SubcategoryMethods`). So, what would change if `Semigroups().Finite` would be gotten from `Semigroups.Finite`?



---

archive/issue_comments_109326.json:
```json
{
    "body": "<a id='comment:536'></a>\nHi Simon!\n\nReplying to [SimonKing](#comment%3A528):\n> Replying to [nthiery](#comment%3A526):\n> > Honestly, it would be soooo much more efficient to explore this by\n> > working together on concrete code in Cernay.\n\n> \n> I can't attend it.\n\nNo luck; we will miss you!\n\n> What commits are these?\n\n```\ncommit c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Fri Jan 31 09:59:13 2014 +0100\n\n    #10963: typo fix 12963 -> 10963\n\ncommit 3e2003ded77192465cc3e99fec7fa64dae998950\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Thu Jan 30 09:26:36 2014 +0100\n\n    Reviewed Peter's renaming of summand_* methods of Cartesian products, using deprecated_function_alias\n\ncommit 98a4407b8b66de7f63920de28376e46bb927517b\nAuthor: Peter Bruin <P.Bruin@warwick.ac.uk>\nDate:   Mon Jan 27 14:31:13 2014 +0000\n\n    rename summand_* methods of Cartesian products\n\ncommit 251da76284f87aaca63c88de1319ff2b29148c3f\nMerge: d86c4dc 6b18661\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Thu Jan 30 10:27:06 2014 +0100\n\n    Merge branch 'ticket/15759' into ticket/10963\n    \n        This is needed for using deprecated_function_alias in the category code.\n\ncommit d86c4dc52f847ac12aff6a017df82f9473c27ccd\nMerge: e5c68aa c57640d\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Thu Jan 30 10:26:00 2014 +0100\n\n    Merge branch 'ticket/15757-superseded-is_Integer' into ticket/10963\n    \n        This is needed for using deprecated_function_alias in the category code.\n\ncommit e5c68aadce9e4efa50854c069cd985c36d892b30\nMerge: 4036968 1bd3319\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Thu Jan 30 10:12:08 2014 +0100\n\n    Merged with develop (trivial manual merge with #15380)\n\ncommit 40369681634f672838a9f6ba8523c8c983219260\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Tue Jan 28 00:11:51 2014 +0100\n\n    Fixed ReST typos\n\ncommit b957acf4309b29449333540ea59a031e02cfb583\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Mon Jan 27 23:39:43 2014 +0100\n\n    Axioms: finished draft of documentation, implementation of `Distributive`, ...\n    \n    - Documentation of a workaround for axioms defined by a join category,\n      and implementation of the ``Distributive`` axiom.\n    \n    - (Sketch of) proof of correctness and complexity bound for adding\n      axioms and calculating joins.\n    - Some simplification of the specifications: the infrastructure is\n      actually more robust than expected! In particular, when adding an\n      axiom has non trivial fibers, the category with axiom class can be\n      put in any of categories of the fibers; not necessarily the largest\n      one. E.g. FiniteFields can be put alternatively in\n      DivisionRings.Finite instead of Fields.Finite.\n    \n    - Hopefuly reasonably complete design discussion, covering most points\n      raised by the reviewers.\n    - Misc small improvements to the primer and axiom documentation.\n    - Tree -> arborescence.\n    - Added synthetic example from the ticket discussion in the axiom doc.\n    \n    - Little simplification in DistributiveMagmasAndAdditiveMagmas for the\n      hierarchy of nested classes above Rings/Rngs.\n    - Trivial doctest update in sage.misc.c3_controlled\n\ncommit e19385eb5e91db423f801d2af83fc71ee76fab3c\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Thu Jan 23 00:02:59 2014 +0100\n\n    Axioms: various improvements + complete description of the algorithms for computing joins and adding axioms\n\ncommit 4c0c9a41836a4b7ef69e14d983e8c8e28db42954\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Thu Jan 23 00:01:22 2014 +0100\n\n    Specify that the CartesianProduct functor is about finite cartesian products\n\ncommit 08d863b19726e7aadec5d46ff361539c69b06537\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Tue Jan 21 23:11:29 2014 +0100\n\n    Axioms: partial documentation of the join algorithm + small simplification of its implementation\n    \n    - Documentation of the algorithm for computing joins\n      (but not yet of its companion _with_axiom)\n    - Small simplification of the join/_with_axiom methods by removing old scories and unused features\n    - Little optimization in _with_axiom_as_tuple (formely _with_axiom_categories):\n      Redundant categories in it are removed.\n    - Updated a doctests in c3_controlled (the result of _cmp_key is changed a tiny bit in one case)\n    - Improved documentation here and there\n\ncommit e1b20957f4cd152f05c1edeb1ff433aa7c7b129e\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Mon Jan 20 23:52:08 2014 +0100\n\n    Axioms: improved the documentation of the axioms method.\n\ncommit 48cb6d7a5e5120eeafc9666a8d6d1e5114c0229a\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Mon Jan 20 10:54:15 2014 +0100\n\n    Axioms: minor documentation improvements + fix test classes\n    \n    The test classes in sage.categories.category_with_axiom now inherit\n    from Category_singleton / Category_over_base_ring as appropriate.\n\ncommit c26f9f6a38f74eeed4a5f95fce025580dcd528df\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Sun Jan 19 19:19:52 2014 +0100\n\n    Extended documentation on axioms: defining new axioms (con't), algorithm (halfway), explanations in Blah.Blue\n\ncommit ef6b0e48a62b3d2381f83d36c5cb2aa8b0f648db\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Wed Jan 15 22:22:42 2014 +0100\n\n    Extended documentation on axioms: cleanup of specifications, proofreading, ...\n\ncommit b94d80a99ea54ebf1f690700744de73b24019e52\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Wed Jan 15 22:19:48 2014 +0100\n\n    missing newline\n\ncommit d620f4c8ff8b071edb7223698ad6e893564802b0\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Tue Jan 14 19:02:48 2014 +0100\n\n    Axioms and primer: proofreading by Jean-Baptiste\n\ncommit cd21929e4eb86346facb211eb0d9bcda8c906d3a\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Tue Jan 14 18:58:01 2014 +0100\n\n    Extended documentation on axioms: step 3 (deduction rules)\n\ncommit 770324b2f91ac478edd0430504c4434e1469f954\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Tue Jan 14 18:55:43 2014 +0100\n\n    Axioms: improved DivisionRings.Finite_extra_super_categories + documentation\n\ncommit be52d1cd5798b69a0929770b202c2a3f7c8eb03c\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Sat Jan 11 01:28:00 2014 +0100\n\n    Axioms: fixed typo in two doctests of the primer\n\ncommit c7ea9a1ee944e0be9817888a1a93b5d40df2cbf2\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Sat Jan 11 01:23:25 2014 +0100\n\n    Axioms: standardized _base_category_class_and_axiom to always be a tuple\n\ncommit 111719b0279889ecac2bde3e00cf3f030df02e41\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Sat Jan 11 01:22:46 2014 +0100\n\n    Extended documentation on axioms: step 3 (handling multiple axioms and tree structure of the classes)\n\ncommit 89923e5ee20ba3e1b9089556816535a5a70a5ed8\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Fri Jan 10 18:33:21 2014 +0100\n\n    Extended documentation on axioms: recovering the class of a category with axiom to add new code\n\ncommit 61768ddbf8edd89592f989525efd7889bfc46fb9\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Fri Jan 10 18:01:45 2014 +0100\n\n    Extended documentation on axioms: switching back gear; it's better after all to put the doc in the module than in CategoryWithAxiom class\n\ncommit 42b8f248818d2ec147c97eb8cb2e2378642bb3dc\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Fri Jan 10 17:33:40 2014 +0100\n\n    Extended documentation on axioms, step 2 (implementing an existing axiom in a new category + TODO)\n\ncommit 517bdac51b278b4ba6bf578d5503e46c00f6f5e6\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Fri Jan 10 17:30:58 2014 +0100\n\n    Axiom primer: added label for cross references\n\ncommit 48dc0c06e567d07a70f1b45018f1e2a02cd434e7\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Wed Jan 8 12:11:51 2014 +0100\n\n    Category with axioms: workaround limitation in lazy import to avoid lazy reimporting over and over\n\ncommit 478de48553d203516cddb47e0cb89c34ccc210ee\nAuthor: Nicolas M. Thi\u00e9ry <nthiery@users.sf.net>\nDate:   Tue Jan 7 15:40:43 2014 +0100\n\n    Categories with axioms: improved names for the protocol to recover how _base_category_class_and_axiom was set.\n```\n\nI guess the easiest is to do a diff w.r.t. develop+15757+15759 (btw:\ncould you have a look at the latter? You have the most expertise on\nthis matter).\n\nThanks!\n\nCheers from the Alps,\n                                 Nicolas",
    "created_at": "2014-02-24T07:42:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109326",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:536'></a>
Hi Simon!

Replying to [SimonKing](#comment%3A528):
> Replying to [nthiery](#comment%3A526):
> > Honestly, it would be soooo much more efficient to explore this by
> > working together on concrete code in Cernay.

> 
> I can't attend it.

No luck; we will miss you!

> What commits are these?

```
commit c718f218fbc726bf3cf7f4c3f20638c9b0c7eea7
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Fri Jan 31 09:59:13 2014 +0100

    #10963: typo fix 12963 -> 10963

commit 3e2003ded77192465cc3e99fec7fa64dae998950
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Thu Jan 30 09:26:36 2014 +0100

    Reviewed Peter's renaming of summand_* methods of Cartesian products, using deprecated_function_alias

commit 98a4407b8b66de7f63920de28376e46bb927517b
Author: Peter Bruin <P.Bruin@warwick.ac.uk>
Date:   Mon Jan 27 14:31:13 2014 +0000

    rename summand_* methods of Cartesian products

commit 251da76284f87aaca63c88de1319ff2b29148c3f
Merge: d86c4dc 6b18661
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Thu Jan 30 10:27:06 2014 +0100

    Merge branch 'ticket/15759' into ticket/10963
    
        This is needed for using deprecated_function_alias in the category code.

commit d86c4dc52f847ac12aff6a017df82f9473c27ccd
Merge: e5c68aa c57640d
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Thu Jan 30 10:26:00 2014 +0100

    Merge branch 'ticket/15757-superseded-is_Integer' into ticket/10963
    
        This is needed for using deprecated_function_alias in the category code.

commit e5c68aadce9e4efa50854c069cd985c36d892b30
Merge: 4036968 1bd3319
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Thu Jan 30 10:12:08 2014 +0100

    Merged with develop (trivial manual merge with #15380)

commit 40369681634f672838a9f6ba8523c8c983219260
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Tue Jan 28 00:11:51 2014 +0100

    Fixed ReST typos

commit b957acf4309b29449333540ea59a031e02cfb583
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Mon Jan 27 23:39:43 2014 +0100

    Axioms: finished draft of documentation, implementation of `Distributive`, ...
    
    - Documentation of a workaround for axioms defined by a join category,
      and implementation of the ``Distributive`` axiom.
    
    - (Sketch of) proof of correctness and complexity bound for adding
      axioms and calculating joins.
    - Some simplification of the specifications: the infrastructure is
      actually more robust than expected! In particular, when adding an
      axiom has non trivial fibers, the category with axiom class can be
      put in any of categories of the fibers; not necessarily the largest
      one. E.g. FiniteFields can be put alternatively in
      DivisionRings.Finite instead of Fields.Finite.
    
    - Hopefuly reasonably complete design discussion, covering most points
      raised by the reviewers.
    - Misc small improvements to the primer and axiom documentation.
    - Tree -> arborescence.
    - Added synthetic example from the ticket discussion in the axiom doc.
    
    - Little simplification in DistributiveMagmasAndAdditiveMagmas for the
      hierarchy of nested classes above Rings/Rngs.
    - Trivial doctest update in sage.misc.c3_controlled

commit e19385eb5e91db423f801d2af83fc71ee76fab3c
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Thu Jan 23 00:02:59 2014 +0100

    Axioms: various improvements + complete description of the algorithms for computing joins and adding axioms

commit 4c0c9a41836a4b7ef69e14d983e8c8e28db42954
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Thu Jan 23 00:01:22 2014 +0100

    Specify that the CartesianProduct functor is about finite cartesian products

commit 08d863b19726e7aadec5d46ff361539c69b06537
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Tue Jan 21 23:11:29 2014 +0100

    Axioms: partial documentation of the join algorithm + small simplification of its implementation
    
    - Documentation of the algorithm for computing joins
      (but not yet of its companion _with_axiom)
    - Small simplification of the join/_with_axiom methods by removing old scories and unused features
    - Little optimization in _with_axiom_as_tuple (formely _with_axiom_categories):
      Redundant categories in it are removed.
    - Updated a doctests in c3_controlled (the result of _cmp_key is changed a tiny bit in one case)
    - Improved documentation here and there

commit e1b20957f4cd152f05c1edeb1ff433aa7c7b129e
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Mon Jan 20 23:52:08 2014 +0100

    Axioms: improved the documentation of the axioms method.

commit 48cb6d7a5e5120eeafc9666a8d6d1e5114c0229a
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Mon Jan 20 10:54:15 2014 +0100

    Axioms: minor documentation improvements + fix test classes
    
    The test classes in sage.categories.category_with_axiom now inherit
    from Category_singleton / Category_over_base_ring as appropriate.

commit c26f9f6a38f74eeed4a5f95fce025580dcd528df
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Sun Jan 19 19:19:52 2014 +0100

    Extended documentation on axioms: defining new axioms (con't), algorithm (halfway), explanations in Blah.Blue

commit ef6b0e48a62b3d2381f83d36c5cb2aa8b0f648db
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Wed Jan 15 22:22:42 2014 +0100

    Extended documentation on axioms: cleanup of specifications, proofreading, ...

commit b94d80a99ea54ebf1f690700744de73b24019e52
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Wed Jan 15 22:19:48 2014 +0100

    missing newline

commit d620f4c8ff8b071edb7223698ad6e893564802b0
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Tue Jan 14 19:02:48 2014 +0100

    Axioms and primer: proofreading by Jean-Baptiste

commit cd21929e4eb86346facb211eb0d9bcda8c906d3a
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Tue Jan 14 18:58:01 2014 +0100

    Extended documentation on axioms: step 3 (deduction rules)

commit 770324b2f91ac478edd0430504c4434e1469f954
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Tue Jan 14 18:55:43 2014 +0100

    Axioms: improved DivisionRings.Finite_extra_super_categories + documentation

commit be52d1cd5798b69a0929770b202c2a3f7c8eb03c
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Sat Jan 11 01:28:00 2014 +0100

    Axioms: fixed typo in two doctests of the primer

commit c7ea9a1ee944e0be9817888a1a93b5d40df2cbf2
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Sat Jan 11 01:23:25 2014 +0100

    Axioms: standardized _base_category_class_and_axiom to always be a tuple

commit 111719b0279889ecac2bde3e00cf3f030df02e41
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Sat Jan 11 01:22:46 2014 +0100

    Extended documentation on axioms: step 3 (handling multiple axioms and tree structure of the classes)

commit 89923e5ee20ba3e1b9089556816535a5a70a5ed8
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Fri Jan 10 18:33:21 2014 +0100

    Extended documentation on axioms: recovering the class of a category with axiom to add new code

commit 61768ddbf8edd89592f989525efd7889bfc46fb9
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Fri Jan 10 18:01:45 2014 +0100

    Extended documentation on axioms: switching back gear; it's better after all to put the doc in the module than in CategoryWithAxiom class

commit 42b8f248818d2ec147c97eb8cb2e2378642bb3dc
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Fri Jan 10 17:33:40 2014 +0100

    Extended documentation on axioms, step 2 (implementing an existing axiom in a new category + TODO)

commit 517bdac51b278b4ba6bf578d5503e46c00f6f5e6
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Fri Jan 10 17:30:58 2014 +0100

    Axiom primer: added label for cross references

commit 48dc0c06e567d07a70f1b45018f1e2a02cd434e7
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Wed Jan 8 12:11:51 2014 +0100

    Category with axioms: workaround limitation in lazy import to avoid lazy reimporting over and over

commit 478de48553d203516cddb47e0cb89c34ccc210ee
Author: Nicolas M. Thiéry <nthiery@users.sf.net>
Date:   Tue Jan 7 15:40:43 2014 +0100

    Categories with axioms: improved names for the protocol to recover how _base_category_class_and_axiom was set.
```

I guess the easiest is to do a diff w.r.t. develop+15757+15759 (btw:
could you have a look at the latter? You have the most expertise on
this matter).

Thanks!

Cheers from the Alps,
                                 Nicolas



---

archive/issue_comments_109327.json:
```json
{
    "body": "<a id='comment:537'></a>\nHi Nicolas!\n\nReplying to [nthiery](#comment%3A536):\n> Replying to [SimonKing](#comment%3A528):\n> > What commits are these?\n\n> \n> ```\n> ...\n> ```\n> \n> I guess the easiest is to do a diff w.r.t. develop+15757+15759\n\n... or just read the text as it is, rather than the diff. As I have mentioned above, I think some info on the \"how\" and \"why\" is needed in `sage.categories.category_with_axiom`.\n\n> (btw:\n> could you have a look at the latter? You have the most expertise on\n> this matter).\n\nTrying to do so, but I can't promise that I'll be able to do substantial work this week.\n\nCheers,\n\n  Simon",
    "created_at": "2014-02-24T09:00:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109327",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:537'></a>
Hi Nicolas!

Replying to [nthiery](#comment%3A536):
> Replying to [SimonKing](#comment%3A528):
> > What commits are these?

> 
> ```
> ...
> ```
> 
> I guess the easiest is to do a diff w.r.t. develop+15757+15759

... or just read the text as it is, rather than the diff. As I have mentioned above, I think some info on the "how" and "why" is needed in `sage.categories.category_with_axiom`.

> (btw:
> could you have a look at the latter? You have the most expertise on
> this matter).

Trying to do so, but I can't promise that I'll be able to do substantial work this week.

Cheers,

  Simon



---

archive/issue_comments_109328.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759\".",
    "created_at": "2014-02-24T09:27:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109328",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759".



---

archive/issue_comments_109329.json:
```json
{
    "body": "<a id='comment:8'></a>\nBy the way: This ticket is \"needs info\". What info is needed?",
    "created_at": "2014-02-24T09:27:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109329",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
By the way: This ticket is "needs info". What info is needed?



---

archive/issue_comments_109330.json:
```json
{
    "body": "<a id='comment:539'></a>\nReplying to [vbraun](#comment%3A527):\n> I disagree, we should definitely not merge this ticket until it is in a state that does not require any major changes. Anything else will just be huge pita for anybody trying to learn or use it. Sure we can merge it with a big fat warning \"DO NOT USE THE CODE HERE YET\" but then its easier to just not do it and keep it in a separate git branch. In fact, git makes it easy to have long-lived branches to work on big features. Nobody is stopping anyone from working on concrete code...\n> In other words, the main goal should not just be to get people moving, but also have them move in the right direction ;-)\n\nIt is *not* a change of direction. The potential changes we are\ndiscussing here are either about the internals, or about a small\nsyntactical change: basically how the axiom and the base category are\nspecified. This means that if we decide to change this, there will\njust be 2-3 lines of code to change per new category with axiom.\n\nFor those already merged in Sage, this is trivial. For the others,\nwell, developers that are advanced enough to implement new categories\nwith axiom can handle a warning about a potential change of\nsyntax. This is all much easier than resolving conflicts, like the one\nSimon just found, that will rise as soon as tickets will want to, e.g.\nmove code to the better spots introduced by the newly available\ncategories.\n\nBesides, several tickets, like the NSMacdonald one, won't even need\nany change; they are just using, or extending, the new categories\nprovided by this ticket, not creating new ones. And getting them\nmerged is important: the ns one is (almost) ready and is an important\noutcome of our thematic semester at ICERM, and users are waiting for\nit. Other tickets represent large contributions of PhD students; they\nneed to be able to get definitely done with them and get credit for\nit.\n\n> In order to make progress, how about you explain what you don't like\n> and we'll try to find an approach that makes everyone happy.\n\nI want to have this discussion, but the last two months have proven\nthat it's unproductive to do it on trac (e.g. a minimum of two hours\nof developers time has been spent on the last two comments; what\nprogress have we actually done?).\n\nThis is in good part because there are a couple points for which we\ndon't have yet enough experience to take well informed decisions; so\nit's a lot about belief and intuition, which makes it harder to find a\nconsensus about. In such a situation, I believe that a decision that\nhas been battlefield tested for practicality over a non trivial period\non a non trivial body of code is as good as any other and one should\nproceed with it.\n\n\nAnyway, to recap, the main points are:\n\n(1) I believe that, when implementing a category with axiom Cs().A(),\n    enforcing that the nested class be Cs.A is a feature (it's a\n    simple rule, it's consistent both with OO practice and with what's\n    done for other category features, it's explicit enough to specify\n    which axiom is being implemented, ...)\n\n(2) I don't like having the outer class inspect all its attribute. The\n    logic better belongs to the inner class.\n\n(3) I believe that adding several axioms at once is not an urgent\nfeature. Yes, theoretically it looks good at the first sight; but\n    the balance between the extra amount of logic and the practical\n    gain is far from clear.\n\n    I actually started to steal the implementation from your branch\n    (creating automatically the necessary intermediate category with\n    axiom), but without using (2). And then dropped the idea because\n    it felt like introducing more confusing magic: those intermediate\n    categories would exist without an explicit class attached to\nthem. For example, this makes it more complicated to explain where\n    to add code (it currently reads as: ``if the category with axiom\n    already exists, put it in the associated class; otherwise create\n    it'').\n\n(4) I believe that, at this point, modeling the axioms themselves is\n    overdesign, for we don't actually have a serious use case.\n\n(5) I believe that the performance hit that we get when a category is\n    repeatedly created over many base rings can be solved in little\n    time once we can clear our mind from this ticket.\n\nHere are some points I'd be willing to change, against my own\nintuition, if the reviewers have a strong belief about them:\n\n- A change of syntax for specifying the base category class and axiom\n  when this information can't be guessed. E.g. using separate\n  attributes.\n\n- Proceeding with the implementation of (3), but without using (2).\n\n- Simon's as_name change\n\nBest,\n                             Nicolas",
    "created_at": "2014-02-25T23:29:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109330",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:539'></a>
Replying to [vbraun](#comment%3A527):
> I disagree, we should definitely not merge this ticket until it is in a state that does not require any major changes. Anything else will just be huge pita for anybody trying to learn or use it. Sure we can merge it with a big fat warning "DO NOT USE THE CODE HERE YET" but then its easier to just not do it and keep it in a separate git branch. In fact, git makes it easy to have long-lived branches to work on big features. Nobody is stopping anyone from working on concrete code...
> In other words, the main goal should not just be to get people moving, but also have them move in the right direction ;-)

It is *not* a change of direction. The potential changes we are
discussing here are either about the internals, or about a small
syntactical change: basically how the axiom and the base category are
specified. This means that if we decide to change this, there will
just be 2-3 lines of code to change per new category with axiom.

For those already merged in Sage, this is trivial. For the others,
well, developers that are advanced enough to implement new categories
with axiom can handle a warning about a potential change of
syntax. This is all much easier than resolving conflicts, like the one
Simon just found, that will rise as soon as tickets will want to, e.g.
move code to the better spots introduced by the newly available
categories.

Besides, several tickets, like the NSMacdonald one, won't even need
any change; they are just using, or extending, the new categories
provided by this ticket, not creating new ones. And getting them
merged is important: the ns one is (almost) ready and is an important
outcome of our thematic semester at ICERM, and users are waiting for
it. Other tickets represent large contributions of PhD students; they
need to be able to get definitely done with them and get credit for
it.

> In order to make progress, how about you explain what you don't like
> and we'll try to find an approach that makes everyone happy.

I want to have this discussion, but the last two months have proven
that it's unproductive to do it on trac (e.g. a minimum of two hours
of developers time has been spent on the last two comments; what
progress have we actually done?).

This is in good part because there are a couple points for which we
don't have yet enough experience to take well informed decisions; so
it's a lot about belief and intuition, which makes it harder to find a
consensus about. In such a situation, I believe that a decision that
has been battlefield tested for practicality over a non trivial period
on a non trivial body of code is as good as any other and one should
proceed with it.


Anyway, to recap, the main points are:

(1) I believe that, when implementing a category with axiom Cs().A(),
    enforcing that the nested class be Cs.A is a feature (it's a
    simple rule, it's consistent both with OO practice and with what's
    done for other category features, it's explicit enough to specify
    which axiom is being implemented, ...)

(2) I don't like having the outer class inspect all its attribute. The
    logic better belongs to the inner class.

(3) I believe that adding several axioms at once is not an urgent
feature. Yes, theoretically it looks good at the first sight; but
    the balance between the extra amount of logic and the practical
    gain is far from clear.

    I actually started to steal the implementation from your branch
    (creating automatically the necessary intermediate category with
    axiom), but without using (2). And then dropped the idea because
    it felt like introducing more confusing magic: those intermediate
    categories would exist without an explicit class attached to
them. For example, this makes it more complicated to explain where
    to add code (it currently reads as: ``if the category with axiom
    already exists, put it in the associated class; otherwise create
    it'').

(4) I believe that, at this point, modeling the axioms themselves is
    overdesign, for we don't actually have a serious use case.

(5) I believe that the performance hit that we get when a category is
    repeatedly created over many base rings can be solved in little
    time once we can clear our mind from this ticket.

Here are some points I'd be willing to change, against my own
intuition, if the reviewers have a strong belief about them:

- A change of syntax for specifying the base category class and axiom
  when this information can't be guessed. E.g. using separate
  attributes.

- Proceeding with the implementation of (3), but without using (2).

- Simon's as_name change

Best,
                             Nicolas



---

archive/issue_comments_109331.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,15 +1,20 @@\n This ticket implements:\n \n - Support for full subcategories defined by an axiom (Finite,\n-  Infinite, Facade, Commutative, Associative, Unital,\n-  Inverse, NoZeroDivisors, Division, FiniteDimensional, Connected,\n-  WithBasis, Irreducible), and joins thereof:\n+  Infinite, Facade, Commutative, Associative, Unital, Inverse,\n+  Distributive, NoZeroDivisors, Division, FiniteDimensional,\n+  Connected, WithBasis, Irreducible), and joins thereof:\n \n ```\n     sage: Groups() & Sets().Finite()\n     Category of finite groups\n+\n     sage: Algebras(QQ).Finite() & Monoids().Commutative()\n-    Join of Category of commutative algebras over Rational Field and Category of finite monoids\n+    Category of finite commutative algebras over Rational Field\n+\n+    sage: (Monoids() & CommutativeAdditiveGroups()).Distributive()\n+    Category of rings\n+\n     sage: Rings().Division() & Sets().Finite()\n     Category of finite fields\n ```\n@@ -40,12 +45,5 @@\n \n - More lazy imports, removed a bunch of unused imports, ...\n \n-Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.\n-\n This ticket is dedicated to the town of Megantic where I was so warmly welcomed and a good chunk of this ticket got implemented!\n \n-Apply:\n-\n-* [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)\n-* [attachment:trac_10963_doctest_correction-fc.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963_doctest_correction-fc.patch)\n-* [attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch)\n``````\n",
    "created_at": "2014-02-25T23:34:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109331",
    "user": "https://github.com/nthiery"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,15 +1,20 @@
 This ticket implements:
 
 - Support for full subcategories defined by an axiom (Finite,
-  Infinite, Facade, Commutative, Associative, Unital,
-  Inverse, NoZeroDivisors, Division, FiniteDimensional, Connected,
-  WithBasis, Irreducible), and joins thereof:
+  Infinite, Facade, Commutative, Associative, Unital, Inverse,
+  Distributive, NoZeroDivisors, Division, FiniteDimensional,
+  Connected, WithBasis, Irreducible), and joins thereof:
 
 ```
     sage: Groups() & Sets().Finite()
     Category of finite groups
+
     sage: Algebras(QQ).Finite() & Monoids().Commutative()
-    Join of Category of commutative algebras over Rational Field and Category of finite monoids
+    Category of finite commutative algebras over Rational Field
+
+    sage: (Monoids() & CommutativeAdditiveGroups()).Distributive()
+    Category of rings
+
     sage: Rings().Division() & Sets().Finite()
     Category of finite fields
 ```
@@ -40,12 +45,5 @@
 
 - More lazy imports, removed a bunch of unused imports, ...
 
-Patch developed on: http://combinat.sagemath.org/patches/file/tip/trac_10963-more_functorial_constructions-nt.patch.
-
 This ticket is dedicated to the town of Megantic where I was so warmly welcomed and a good chunk of this ticket got implemented!
 
-Apply:
-
-* [attachment:trac_10963-more_functorial_constructions-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-nt.patch)
-* [attachment:trac_10963_doctest_correction-fc.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963_doctest_correction-fc.patch)
-* [attachment:trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch](https://github.com/sagemath/sage/files/ticket10963/trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch)
``````




---

archive/issue_comments_109332.json:
```json
{
    "body": "<a id='comment:1'></a>\nReplying to [nthiery](#comment%3A539):\n> (1) I believe that, when implementing a category with axiom Cs().A(),\n>     enforcing that the nested class be Cs.A is a feature (it's a\n>     simple rule, it's consistent both with OO practice\n\nNo it is not OO practice, in fact it is a smack in the face of normal OO practice. This is and remains my main objection to the current syntax: Cs.A and Ds.A are supposed to be totally independent **unless** you choose to tie them together. First of all OO is about separation and encapsulation, and you violate that basic principle. You keep ignoring me and reiterate that its \"just OO\" when it is clearly not. Can you please address this issue?",
    "created_at": "2014-02-26T11:13:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109332",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:1'></a>
Replying to [nthiery](#comment%3A539):
> (1) I believe that, when implementing a category with axiom Cs().A(),
>     enforcing that the nested class be Cs.A is a feature (it's a
>     simple rule, it's consistent both with OO practice

No it is not OO practice, in fact it is a smack in the face of normal OO practice. This is and remains my main objection to the current syntax: Cs.A and Ds.A are supposed to be totally independent **unless** you choose to tie them together. First of all OO is about separation and encapsulation, and you violate that basic principle. You keep ignoring me and reiterate that its "just OO" when it is clearly not. Can you please address this issue?



---

archive/issue_comments_109333.json:
```json
{
    "body": "<a id='comment:2'></a>\n<rant>Nested classes have always been a problem to/for me. In Java, one can get performance problems via private access. I tried doing nested-classes in C++ with templates once and I couldn't get it to work. After looking into the STL, for example an iterator, they create the iterator outside of the container class, but have it referenced by the container class.</rant> In python, there's some technical things I'm not fully versed in, but it seems to be okay...at least to one level deep.\n\nWith that being said (and keeping in mind I'm probably missing something), if we wanted to have `Cs.A` and `Ds.A` be the same class, but `Cs` and `Ds` are \"unrelated\", then IMO `A` should be written as a separate (non-nested) class and it follows good OOP. Yet if `Cs.A` and `Ds.A` are written in each class, I don't see the conflict.\n\nThank you all for your work on this.\n\nPS - Nicolas, you numbering is off `:p`",
    "created_at": "2014-02-26T15:43:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109333",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>
<rant>Nested classes have always been a problem to/for me. In Java, one can get performance problems via private access. I tried doing nested-classes in C++ with templates once and I couldn't get it to work. After looking into the STL, for example an iterator, they create the iterator outside of the container class, but have it referenced by the container class.</rant> In python, there's some technical things I'm not fully versed in, but it seems to be okay...at least to one level deep.

With that being said (and keeping in mind I'm probably missing something), if we wanted to have `Cs.A` and `Ds.A` be the same class, but `Cs` and `Ds` are "unrelated", then IMO `A` should be written as a separate (non-nested) class and it follows good OOP. Yet if `Cs.A` and `Ds.A` are written in each class, I don't see the conflict.

Thank you all for your work on this.

PS - Nicolas, you numbering is off `:p`



---

archive/issue_comments_109334.json:
```json
{
    "body": "<a id='comment:543'></a>\nBack from vacations ...\n\nReplying to [vbraun](#comment%3A541):\n> Replying to [nthiery](#comment%3A539):\n> > (1) I believe that, when implementing a category with axiom Cs().A(),\n> >     enforcing that the nested class be Cs.A is a feature (it's a\n> >     simple rule, it's consistent both with OO practice\n\n> \n> No it is not OO practice, in fact it is a smack in the face of normal OO practice. This is and remains my main objection to the current syntax: Cs.A and Ds.A are supposed to be totally independent **unless** you choose to tie them together. First of all OO is about separation and encapsulation, and you violate that basic principle. You keep ignoring me and reiterate that its \"just OO\" when it is clearly not. Can you please address this issue?\n\nIt's such a pain to have this kind of discussions on trac since every\ntime you try to be synthetic you face the risk of a misunderstanding\nand it takes hours to clear that misunderstanding ...\n\nOk, let's go for it. I did not mean \"categories are just\nOO\". Otherwise we would not need categories in the first\nplace. Instead, categories build on OO, and try to reuse the same\nparadigms whenever possible. I did not mean either to argue about\nnested classes. Just about their names.\n\nSo, let me restate this point in detail: not all features of categories\npass to subcategories. Hence, even if Ds() a subcategory of Cs(), the\nclass Ds is not a subclass of Cs. So the hierarchy of categories is\nnot directly a hierarchy of classes. Yet, some features *do* pass to\nsubcategories; this include *covariant* functorial construction and\naxioms. Then it's natural to follow the usual OO paradigm where, when\nsomething in the hierarchy attaches a semantic to a name (e.g. by\ndeclaring a method with that name), the subthings in the hierarchy can\nimplement that semantic by reusing the same name.\n\n> You keep ignoring me\n\nHmm, really?\n\nThe design behind this ticket is certainly non trivial, and you have\nbeen raising natural questions about it. Answering those questions was\nan helpful guide for me to write down the 1500+ lines of documentation\nto expose the design decisions and the rationale behind. Now, I'd\nappreciate if you would acknowledge the efforts I put in writing this\ndocumentation, and use it as a basis for a constructive discussion.\n\n                         Nicolas",
    "created_at": "2014-03-04T15:03:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109334",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:543'></a>
Back from vacations ...

Replying to [vbraun](#comment%3A541):
> Replying to [nthiery](#comment%3A539):
> > (1) I believe that, when implementing a category with axiom Cs().A(),
> >     enforcing that the nested class be Cs.A is a feature (it's a
> >     simple rule, it's consistent both with OO practice

> 
> No it is not OO practice, in fact it is a smack in the face of normal OO practice. This is and remains my main objection to the current syntax: Cs.A and Ds.A are supposed to be totally independent **unless** you choose to tie them together. First of all OO is about separation and encapsulation, and you violate that basic principle. You keep ignoring me and reiterate that its "just OO" when it is clearly not. Can you please address this issue?

It's such a pain to have this kind of discussions on trac since every
time you try to be synthetic you face the risk of a misunderstanding
and it takes hours to clear that misunderstanding ...

Ok, let's go for it. I did not mean "categories are just
OO". Otherwise we would not need categories in the first
place. Instead, categories build on OO, and try to reuse the same
paradigms whenever possible. I did not mean either to argue about
nested classes. Just about their names.

So, let me restate this point in detail: not all features of categories
pass to subcategories. Hence, even if Ds() a subcategory of Cs(), the
class Ds is not a subclass of Cs. So the hierarchy of categories is
not directly a hierarchy of classes. Yet, some features *do* pass to
subcategories; this include *covariant* functorial construction and
axioms. Then it's natural to follow the usual OO paradigm where, when
something in the hierarchy attaches a semantic to a name (e.g. by
declaring a method with that name), the subthings in the hierarchy can
implement that semantic by reusing the same name.

> You keep ignoring me

Hmm, really?

The design behind this ticket is certainly non trivial, and you have
been raising natural questions about it. Answering those questions was
an helpful guide for me to write down the 1500+ lines of documentation
to expose the design decisions and the rationale behind. Now, I'd
appreciate if you would acknowledge the efforts I put in writing this
documentation, and use it as a basis for a constructive discussion.

                         Nicolas



---

archive/issue_comments_109335.json:
```json
{
    "body": "<a id='comment:544'></a>\nHi Travis!\n\nReplying to [tscrim](#comment%3A542):\n> <rant>Nested classes have always been a problem to/for me. In Java, one can get performance problems via private access. I tried doing nested-classes in C++ with templates once and I couldn't get it to work. After looking into the STL, for example an iterator, they create the iterator outside of the container class, but have it referenced by the container class.</rant> In python, there's some technical things I'm not fully versed in, but it seems to be okay...at least to one level deep.\n\nYeah, nested classes did not go without their issues in Python too,\nbut it was essentially in the various support tools (pickling,\ndocumentation) which had not yet been shaken out enough by intensive\nuse. Most of the issues have been fixed or reasonably worked around at\nthe beginning of categories (#9107 being an exception, but it's almost\ndone too).\n\n> PS - Nicolas, you numbering is off `:p`\n\nOops. Thanks for the notice! Fixed.",
    "created_at": "2014-03-04T15:12:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109335",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:544'></a>
Hi Travis!

Replying to [tscrim](#comment%3A542):
> <rant>Nested classes have always been a problem to/for me. In Java, one can get performance problems via private access. I tried doing nested-classes in C++ with templates once and I couldn't get it to work. After looking into the STL, for example an iterator, they create the iterator outside of the container class, but have it referenced by the container class.</rant> In python, there's some technical things I'm not fully versed in, but it seems to be okay...at least to one level deep.

Yeah, nested classes did not go without their issues in Python too,
but it was essentially in the various support tools (pickling,
documentation) which had not yet been shaken out enough by intensive
use. Most of the issues have been fixed or reasonably worked around at
the beginning of categories (#9107 being an exception, but it's almost
done too).

> PS - Nicolas, you numbering is off `:p`

Oops. Thanks for the notice! Fixed.



---

archive/issue_comments_109336.json:
```json
{
    "body": "<a id='comment:545'></a>\nReplying to [nthiery](#comment%3A543):\n> Then it's natural to follow the usual OO paradigm where, when something in the hierarchy attaches a semantic to a name (e.g. by declaring a method with that name), the subthings in the hierarchy can implement that semantic by reusing the same name\n\nThat is one piece of OO. But it is not the \"usual OO paradigm\" unless you also have encapsulation, that is, unrelated \"things\" being independent (in particular, sub-things of independent things being independent). Reusing (really: overriding) a name is supposed to replace one implementation with another, but the original and the replacement are still independent. Really, what you propose is more like a single flat namespace where each axiom is a global name. And that is not OOP.\n\n> [...]Now, I'd\n> appreciate if you would acknowledge the efforts I put in writing this\n> documentation, and use it as a basis for a constructive discussion.\n\nI certainly do acknowledge and appreciate your effort. But when it comes to reviewing I am supposed to be an advocate of other users, not of the author. And I think there is too much implicit magic and not enough syntax to explicitly tie together the axiom implementations. Which will hurt other users/developers when they first encounter the category code. Just documenting that axioms are implicit magic is IMHO not good enough when you can just make their relationship explicit.",
    "created_at": "2014-03-04T17:52:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109336",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:545'></a>
Replying to [nthiery](#comment%3A543):
> Then it's natural to follow the usual OO paradigm where, when something in the hierarchy attaches a semantic to a name (e.g. by declaring a method with that name), the subthings in the hierarchy can implement that semantic by reusing the same name

That is one piece of OO. But it is not the "usual OO paradigm" unless you also have encapsulation, that is, unrelated "things" being independent (in particular, sub-things of independent things being independent). Reusing (really: overriding) a name is supposed to replace one implementation with another, but the original and the replacement are still independent. Really, what you propose is more like a single flat namespace where each axiom is a global name. And that is not OOP.

> [...]Now, I'd
> appreciate if you would acknowledge the efforts I put in writing this
> documentation, and use it as a basis for a constructive discussion.

I certainly do acknowledge and appreciate your effort. But when it comes to reviewing I am supposed to be an advocate of other users, not of the author. And I think there is too much implicit magic and not enough syntax to explicitly tie together the axiom implementations. Which will hurt other users/developers when they first encounter the category code. Just documenting that axioms are implicit magic is IMHO not good enough when you can just make their relationship explicit.



---

archive/issue_comments_109337.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f1b6804c499bfdc9cd8a864f81f739d80783122d\">f1b6804</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into public/ticket/10963-doc-distributive</code></td></tr></table>\n",
    "created_at": "2014-03-04T18:22:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109337",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f1b6804c499bfdc9cd8a864f81f739d80783122d">f1b6804</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into public/ticket/10963-doc-distributive</code></td></tr></table>




---

archive/issue_comments_109338.json:
```json
{
    "body": "**Changing commit** from \"[7ab3103368e46d33f37e135a9eb09a1e16a029a7](https://github.com/sagemath/sagetrac-mirror/commit/7ab3103368e46d33f37e135a9eb09a1e16a029a7)\" to \"[f1b6804c499bfdc9cd8a864f81f739d80783122d](https://github.com/sagemath/sagetrac-mirror/commit/f1b6804c499bfdc9cd8a864f81f739d80783122d)\".",
    "created_at": "2014-03-04T18:22:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109338",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7ab3103368e46d33f37e135a9eb09a1e16a029a7](https://github.com/sagemath/sagetrac-mirror/commit/7ab3103368e46d33f37e135a9eb09a1e16a029a7)" to "[f1b6804c499bfdc9cd8a864f81f739d80783122d](https://github.com/sagemath/sagetrac-mirror/commit/f1b6804c499bfdc9cd8a864f81f739d80783122d)".



---

archive/issue_comments_109339.json:
```json
{
    "body": "<a id='comment:7'></a>\nI fixed merge conflicts in `categories/groups.py` and `categories/group_algebras.py`. Note to double-check when we agree on the final designs.",
    "created_at": "2014-03-04T18:23:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109339",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:7'></a>
I fixed merge conflicts in `categories/groups.py` and `categories/group_algebras.py`. Note to double-check when we agree on the final designs.



---

archive/issue_comments_109340.json:
```json
{
    "body": "<a id='comment:8'></a>\nHi Nicolas!\n\nWelcome back...\n\nCan you also please address my confusion about the following (see [comment:535](#comment%3A535)).\n\n```\nsage: Semigroups().Finite\nCached version of <function Finite at 0xa4c2c6c>\nsage: Semigroups().__class__.Finite\n<class 'sage.categories.finite_semigroups.FiniteSemigroups'>\n```\n\n`Semigroups` has a class attribute called `\"Finite\"`, that is a lazily imported class `FiniteSemigroups`. Fine.\n\nThe (unique) instance of `Semigroups` does, however, *not* inherit the attribute `\"Finite\"` from its class. Instead, it provides a cached method. Calling this cached method `Semigroups().Finite` does, however, just return an instance of `Semigroups.Finite`.\n\nThe three questions are:\n1. *Why* is `Semigroups.Finite` overridden on instances of `Semigroups`? After all, calling `Semigroups.Finite()` returns the same thing as `Semigroups().Finite()` (and is cached as well).\n2. *How* is `Semigroups.Finite` overridden on instances of `Semigroups`? I simply don't see at what point the cached method is put into `Semigroups().__dict__`.\n3. *Where* can the answers to 1. and 2. be found in the docs?\n\nBest regards,\n\nSimon",
    "created_at": "2014-03-04T19:01:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109340",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Hi Nicolas!

Welcome back...

Can you also please address my confusion about the following (see [comment:535](#comment%3A535)).

```
sage: Semigroups().Finite
Cached version of <function Finite at 0xa4c2c6c>
sage: Semigroups().__class__.Finite
<class 'sage.categories.finite_semigroups.FiniteSemigroups'>
```

`Semigroups` has a class attribute called `"Finite"`, that is a lazily imported class `FiniteSemigroups`. Fine.

The (unique) instance of `Semigroups` does, however, *not* inherit the attribute `"Finite"` from its class. Instead, it provides a cached method. Calling this cached method `Semigroups().Finite` does, however, just return an instance of `Semigroups.Finite`.

The three questions are:
1. *Why* is `Semigroups.Finite` overridden on instances of `Semigroups`? After all, calling `Semigroups.Finite()` returns the same thing as `Semigroups().Finite()` (and is cached as well).
2. *How* is `Semigroups.Finite` overridden on instances of `Semigroups`? I simply don't see at what point the cached method is put into `Semigroups().__dict__`.
3. *Where* can the answers to 1. and 2. be found in the docs?

Best regards,

Simon



---

archive/issue_comments_109341.json:
```json
{
    "body": "<a id='comment:549'></a>\nReplying to [SimonKing](#comment%3A548):\n> Can you also please address my confusion about the following (see [comment:535](#comment%3A535)).\n\nOops, thanks for the reminder.\n\n> The three questions are:\n> 1. *Why* is `Semigroups.Finite` overridden on instances of `Semigroups`?\n\nSo that, when `C` is a category, `C.Finite` always points to\nthe original `Finite` method, whether C implements or not this\naxiom (an implementation detail). In particular, introspection with\n`C.Finite?` always nicely gives the documentation of the axiom\nfrom the `Finite` method.\n\n> 2. *How* is `Semigroups.Finite` overridden on instances of `Semigroups`? I simply don't see at what point the cached method is put into `Semigroups().__dict__`.\n\nThat's implemented in `CategoryWithAxiom.__classget__`.\n\n> 3. *Where* can the answers to 1. and 2. be found in the docs?\n\nSee, in the category_with_axiom file, the notes in the section \"Simple\ncase involving a single predefined axiom\", the section \"Defining a new\naxiom\" and the documentation of `CategoryWithAxiom.__classget__`.\n\nI just spent some time refactoring those pieces of documentation with\nyour specific questions in mind. I hope it's better now!\n\nCommit to come in a couple minutes when I'll have finished recompiling\nSage and tested my changes ...\n\n> After all, calling `Semigroups.Finite()` returns the same thing as `Semigroups().Finite()` (and is cached as well).\n\nIndeed the overriding of `Semigroups().Finite` would not be absolutely necessary if we only cared about `Semigroups().Finite()` working, and not about introspection as above.\n\nStill `Semigroups.Finite()` kind of works by \"fluke\" at\nthis point. I am not sure we want to support this syntax in the long\nrun.  See also the section \"Making the category with axiom directly\ncallable\".\n\nCheers,\n                                Nicolas",
    "created_at": "2014-03-05T17:26:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109341",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:549'></a>
Replying to [SimonKing](#comment%3A548):
> Can you also please address my confusion about the following (see [comment:535](#comment%3A535)).

Oops, thanks for the reminder.

> The three questions are:
> 1. *Why* is `Semigroups.Finite` overridden on instances of `Semigroups`?

So that, when `C` is a category, `C.Finite` always points to
the original `Finite` method, whether C implements or not this
axiom (an implementation detail). In particular, introspection with
`C.Finite?` always nicely gives the documentation of the axiom
from the `Finite` method.

> 2. *How* is `Semigroups.Finite` overridden on instances of `Semigroups`? I simply don't see at what point the cached method is put into `Semigroups().__dict__`.

That's implemented in `CategoryWithAxiom.__classget__`.

> 3. *Where* can the answers to 1. and 2. be found in the docs?

See, in the category_with_axiom file, the notes in the section "Simple
case involving a single predefined axiom", the section "Defining a new
axiom" and the documentation of `CategoryWithAxiom.__classget__`.

I just spent some time refactoring those pieces of documentation with
your specific questions in mind. I hope it's better now!

Commit to come in a couple minutes when I'll have finished recompiling
Sage and tested my changes ...

> After all, calling `Semigroups.Finite()` returns the same thing as `Semigroups().Finite()` (and is cached as well).

Indeed the overriding of `Semigroups().Finite` would not be absolutely necessary if we only cared about `Semigroups().Finite()` working, and not about introspection as above.

Still `Semigroups.Finite()` kind of works by "fluke" at
this point. I am not sure we want to support this syntax in the long
run.  See also the section "Making the category with axiom directly
callable".

Cheers,
                                Nicolas



---

archive/issue_comments_109342.json:
```json
{
    "body": "<a id='comment:550'></a>\nReplying to [vbraun](#comment%3A545):\n> That is one piece of OO. But it is not the \"usual OO paradigm\" unless you also have encapsulation, that is, unrelated \"things\" being independent (in particular, sub-things of independent things being independent). Reusing (really: overriding) a name is supposed to replace one implementation with another, but the original and the replacement are still independent. Really, what you propose is more like a single flat namespace where each axiom is a global name. And that is not OOP.\n\nNo it's not a global name. We have already discussed this, and here is\nthe answer taken from the documentation around line 394 of\ncategory_with_axiom.py:\n\n```\n.. TOPIC:: Design note\n\n    Let us state again that, unlike what the existence of\n    ``all_axioms`` might suggests, the definition of an axiom is local\n    to a category and its subcategories. In particular, two\n    independent categories ``Cs()`` and ``Ds()`` can very well define\n    axioms with the same name and different semantics. As long as the\n    two hierarchies of subcategories don't intersect, this is not a\n    problem. And if they do intersect naturally (that is if one is\n    likely to create a parent belonging to both categories), this\n    probably means that the categories ``Cs`` and ``Ds`` are about\n    related enough areas of mathematics that one should clear the\n    ambiguity by having either the same semantic or different names.\n\n    This caveat is no different from that of name clashes in hierarchy\n    of classes involving multiple inheritance.\n```\n\n> I certainly do acknowledge and appreciate your effort.\n\n:-)\n\n> But when it comes to reviewing I am supposed to be an advocate of\n> other users, not of the author.\n\nCertainly. Now, when it comes to be an advocate of users, one thing to\nconsider is who around here has accumulated the most experience using,\nimplementing, teaching, and helping others use and implement\ncategories and axioms.\n\n> And I think there is too much implicit magic and not enough syntax\n> to explicitly tie together the axiom implementations. Which will\n> hurt other users/developers when they first encounter the category\n> code. Just documenting that axioms are implicit magic is IMHO not\n> good enough when you can just make their relationship explicit.\n\nI know, we disagree here. IMHO this is explicit enough:\n\n```\nclass Cs(Category):\n    ...\n    class Finite(CategoryWithAxiom):\n```\n\nEspecially since, if in doubt about the semantic of the ``Finite``\naxiom, one can just use introspection:\n\n```\n    sage: C = Cs()\n    sage: C.Finite?\n```\n\n                               Nicolas",
    "created_at": "2014-03-05T18:07:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109342",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:550'></a>
Replying to [vbraun](#comment%3A545):
> That is one piece of OO. But it is not the "usual OO paradigm" unless you also have encapsulation, that is, unrelated "things" being independent (in particular, sub-things of independent things being independent). Reusing (really: overriding) a name is supposed to replace one implementation with another, but the original and the replacement are still independent. Really, what you propose is more like a single flat namespace where each axiom is a global name. And that is not OOP.

No it's not a global name. We have already discussed this, and here is
the answer taken from the documentation around line 394 of
category_with_axiom.py:

```
.. TOPIC:: Design note

    Let us state again that, unlike what the existence of
    ``all_axioms`` might suggests, the definition of an axiom is local
    to a category and its subcategories. In particular, two
    independent categories ``Cs()`` and ``Ds()`` can very well define
    axioms with the same name and different semantics. As long as the
    two hierarchies of subcategories don't intersect, this is not a
    problem. And if they do intersect naturally (that is if one is
    likely to create a parent belonging to both categories), this
    probably means that the categories ``Cs`` and ``Ds`` are about
    related enough areas of mathematics that one should clear the
    ambiguity by having either the same semantic or different names.

    This caveat is no different from that of name clashes in hierarchy
    of classes involving multiple inheritance.
```

> I certainly do acknowledge and appreciate your effort.

:-)

> But when it comes to reviewing I am supposed to be an advocate of
> other users, not of the author.

Certainly. Now, when it comes to be an advocate of users, one thing to
consider is who around here has accumulated the most experience using,
implementing, teaching, and helping others use and implement
categories and axioms.

> And I think there is too much implicit magic and not enough syntax
> to explicitly tie together the axiom implementations. Which will
> hurt other users/developers when they first encounter the category
> code. Just documenting that axioms are implicit magic is IMHO not
> good enough when you can just make their relationship explicit.

I know, we disagree here. IMHO this is explicit enough:

```
class Cs(Category):
    ...
    class Finite(CategoryWithAxiom):
```

Especially since, if in doubt about the semantic of the ``Finite``
axiom, one can just use introspection:

```
    sage: C = Cs()
    sage: C.Finite?
```

                               Nicolas



---

archive/issue_comments_109343.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/977a940beba7ed96722a24e36cd81595336350ef\">977a940</a></td><td><code>Axioms: minor improvements here and there, and reworked explanations about the binding behavior of categories with axioms</code></td></tr></table>\n",
    "created_at": "2014-03-05T18:08:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109343",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/977a940beba7ed96722a24e36cd81595336350ef">977a940</a></td><td><code>Axioms: minor improvements here and there, and reworked explanations about the binding behavior of categories with axioms</code></td></tr></table>




---

archive/issue_comments_109344.json:
```json
{
    "body": "**Changing commit** from \"[f1b6804c499bfdc9cd8a864f81f739d80783122d](https://github.com/sagemath/sagetrac-mirror/commit/f1b6804c499bfdc9cd8a864f81f739d80783122d)\" to \"[977a940beba7ed96722a24e36cd81595336350ef](https://github.com/sagemath/sagetrac-mirror/commit/977a940beba7ed96722a24e36cd81595336350ef)\".",
    "created_at": "2014-03-05T18:08:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109344",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f1b6804c499bfdc9cd8a864f81f739d80783122d](https://github.com/sagemath/sagetrac-mirror/commit/f1b6804c499bfdc9cd8a864f81f739d80783122d)" to "[977a940beba7ed96722a24e36cd81595336350ef](https://github.com/sagemath/sagetrac-mirror/commit/977a940beba7ed96722a24e36cd81595336350ef)".



---

archive/issue_comments_109345.json:
```json
{
    "body": "<a id='comment:552'></a>\n> Certainly. Now, when it comes to be an advocate of users, one thing to\n> consider is who around here has accumulated the most experience using,\n> implementing, teaching, and helping others use and implement\n> categories and axioms.\n\nI don't trust the combinat/ code. There are bad designs choices in there from time to time, and known bugs are not always fixed. You cannot ask us to accept that the choices you made are good just because they have been made a long time ago. If you think that those design choices are good, then you have years of examples in mind that you can use to illustrate it.\n\nBut you have to illustrate it. That's why we review code, and don't just blindly trust the author.\n\nNathann",
    "created_at": "2014-03-05T18:26:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109345",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:552'></a>
> Certainly. Now, when it comes to be an advocate of users, one thing to
> consider is who around here has accumulated the most experience using,
> implementing, teaching, and helping others use and implement
> categories and axioms.

I don't trust the combinat/ code. There are bad designs choices in there from time to time, and known bugs are not always fixed. You cannot ask us to accept that the choices you made are good just because they have been made a long time ago. If you think that those design choices are good, then you have years of examples in mind that you can use to illustrate it.

But you have to illustrate it. That's why we review code, and don't just blindly trust the author.

Nathann



---

archive/issue_comments_109346.json:
```json
{
    "body": "<a id='comment:553'></a>\nReplying to [nthiery](#comment%3A550):\n> No it's not a global name.\n> \n> ```\n>     This caveat is no different from that of name clashes in hierarchy\n>     of classes involving multiple inheritance.\n> ```\n\nThat is incorrect, there are never name clashes in multiple inheritance. You can name your class anything you want, the only thing that counts is the the actual class as Python code. You can even have two classes with the same name in the same module and inherit from both. Absolutely no problem:\n\n```\nsage: class A(object):\n....:     x = 1\n....:     \nsage: a = A\nsage: class A(object):\n....:     x = 2\n....:     \nsage: class Multiple(A, a):\n....:     pass\n....: \nsage: Multiple.__mro__\n(__main__.Multiple, __main__.A, __main__.A, object)\nsage: Multiple.__mro__[1].x\n2\nsage: Multiple.__mro__[2].x\n1\n```\nThis is one of the fundamental promises of OO in general and the object system in Python in particular: The **name of a type does not matter**. Breaking that basic premise is a neat idea but not something that is fit to serve as the underpinning of a scientific Python library.\n\nI know you are talking about method names, but there you cannot have accidental clashes either. In the **very first line** of the class definition the programmer must specify the base classes and their order, so which method comes first in the MRO only reflects the programmer's choice. Accidental name clashes can only happen when there is no syntax to tie the related classes (or axioms, or \"things\", ...) together, and this is precisely what I'm worried about on this ticket.\n\n> Especially since, if in doubt about the semantic of the ``Finite``\n> axiom, one can just use introspection:\n\nBut that is precisely what I said is not good enough. First of all we must strive for readable code where relationships between classes (or axioms) are clear from looking at it. The best code is code that doesn't need to be documented. What if a user is trying to fix a bug that prevents Sage from starting up?",
    "created_at": "2014-03-05T21:02:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109346",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:553'></a>
Replying to [nthiery](#comment%3A550):
> No it's not a global name.
> 
> ```
>     This caveat is no different from that of name clashes in hierarchy
>     of classes involving multiple inheritance.
> ```

That is incorrect, there are never name clashes in multiple inheritance. You can name your class anything you want, the only thing that counts is the the actual class as Python code. You can even have two classes with the same name in the same module and inherit from both. Absolutely no problem:

```
sage: class A(object):
....:     x = 1
....:     
sage: a = A
sage: class A(object):
....:     x = 2
....:     
sage: class Multiple(A, a):
....:     pass
....: 
sage: Multiple.__mro__
(__main__.Multiple, __main__.A, __main__.A, object)
sage: Multiple.__mro__[1].x
2
sage: Multiple.__mro__[2].x
1
```
This is one of the fundamental promises of OO in general and the object system in Python in particular: The **name of a type does not matter**. Breaking that basic premise is a neat idea but not something that is fit to serve as the underpinning of a scientific Python library.

I know you are talking about method names, but there you cannot have accidental clashes either. In the **very first line** of the class definition the programmer must specify the base classes and their order, so which method comes first in the MRO only reflects the programmer's choice. Accidental name clashes can only happen when there is no syntax to tie the related classes (or axioms, or "things", ...) together, and this is precisely what I'm worried about on this ticket.

> Especially since, if in doubt about the semantic of the ``Finite``
> axiom, one can just use introspection:

But that is precisely what I said is not good enough. First of all we must strive for readable code where relationships between classes (or axioms) are clear from looking at it. The best code is code that doesn't need to be documented. What if a user is trying to fix a bug that prevents Sage from starting up?



---

archive/issue_comments_109347.json:
```json
{
    "body": "<a id='comment:554'></a>\nReplying to [ncohen](#comment%3A552):\n> If you think that those design choices are good, then you have years of examples in mind that you can use to illustrate it.\n> \n> But you have to illustrate it.\n\nWith pleasure. For a few use cases, see the changes in this ticket about:\n\n```\nsage/categories/algebra_ideals.py\nsage/categories/algebras.py\nsage/categories/algebras_with_basis.py\nsage/categories/coalgebras_with_basis.py\nsage/categories/commutative_additive_groups.py\nsage/categories/commutative_additive_monoids.py\nsage/categories/commutative_additive_semigroups.py\nsage/categories/commutative_algebras.py\nsage/categories/commutative_rings.py\nsage/categories/facade_sets.py\nsage/categories/fields.py\nsage/categories/finite_coxeter_groups.py\nsage/categories/finite_crystals.py\nsage/categories/finite_dimensional_algebras_with_basis.py\nsage/categories/finite_dimensional_bialgebras_with_basis.py\nsage/categories/finite_dimensional_coalgebras_with_basis.py\nsage/categories/finite_dimensional_hopf_algebras_with_basis.py\nsage/categories/finite_dimensional_modules_with_basis.py\nsage/categories/finite_enumerated_sets.py\nsage/categories/finite_fields.py\nsage/categories/finite_groups.py\nsage/categories/finite_lattice_posets.py\nsage/categories/finite_monoids.py\nsage/categories/finite_permutation_groups.py\nsage/categories/finite_posets.py\nsage/categories/finite_semigroups.py\nsage/categories/finite_sets.py\nsage/categories/finite_weyl_groups.py\nsage/categories/graded_algebras.py\nsage/categories/graded_algebras_with_basis.py\nsage/categories/graded_bialgebras.py\nsage/categories/graded_bialgebras_with_basis.py\nsage/categories/graded_coalgebras.py\nsage/categories/graded_coalgebras_with_basis.py\nsage/categories/graded_enumerated_sets.py\nsage/categories/graded_hopf_algebras.py\nsage/categories/graded_hopf_algebras_with_basis.py\nsage/categories/graded_modules.py\nsage/categories/graded_modules_with_basis.py\nsage/categories/groups.py\nsage/categories/hopf_algebras_with_basis.py\nsage/categories/infinite_enumerated_sets.py\nsage/categories/modules_with_basis.py\nsage/categories/monoid_algebras.py\nsage/categories/monoids.py\nsage/categories/non_unital_algebras.py\nsage/categories/rings.py\nsage/categories/semigroups.py\nsage/categories/sets_cat.py\n```\n\nYou can ask, e.g. Jean-Baptiste for more.\n\n> That's why we review code, and don't just blindly trust the author.\n\nCertainly. Did I ask for a blind trust? There has been 550 comments on\nthis ticket which had a strong influence on its implementation. Not\ncounting discussions elsewhere. Simon thoroughly reviewed it. Others\nhave been using it. Now there remains a couple spots where it comes to\nopinion against opinion. There are various ways to resolve this. With\nvarious consequences.\n\nAll I am saying is: \u00abyou don't have the monopoly of representing the\nusers\u00bb.",
    "created_at": "2014-03-05T21:33:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109347",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:554'></a>
Replying to [ncohen](#comment%3A552):
> If you think that those design choices are good, then you have years of examples in mind that you can use to illustrate it.
> 
> But you have to illustrate it.

With pleasure. For a few use cases, see the changes in this ticket about:

```
sage/categories/algebra_ideals.py
sage/categories/algebras.py
sage/categories/algebras_with_basis.py
sage/categories/coalgebras_with_basis.py
sage/categories/commutative_additive_groups.py
sage/categories/commutative_additive_monoids.py
sage/categories/commutative_additive_semigroups.py
sage/categories/commutative_algebras.py
sage/categories/commutative_rings.py
sage/categories/facade_sets.py
sage/categories/fields.py
sage/categories/finite_coxeter_groups.py
sage/categories/finite_crystals.py
sage/categories/finite_dimensional_algebras_with_basis.py
sage/categories/finite_dimensional_bialgebras_with_basis.py
sage/categories/finite_dimensional_coalgebras_with_basis.py
sage/categories/finite_dimensional_hopf_algebras_with_basis.py
sage/categories/finite_dimensional_modules_with_basis.py
sage/categories/finite_enumerated_sets.py
sage/categories/finite_fields.py
sage/categories/finite_groups.py
sage/categories/finite_lattice_posets.py
sage/categories/finite_monoids.py
sage/categories/finite_permutation_groups.py
sage/categories/finite_posets.py
sage/categories/finite_semigroups.py
sage/categories/finite_sets.py
sage/categories/finite_weyl_groups.py
sage/categories/graded_algebras.py
sage/categories/graded_algebras_with_basis.py
sage/categories/graded_bialgebras.py
sage/categories/graded_bialgebras_with_basis.py
sage/categories/graded_coalgebras.py
sage/categories/graded_coalgebras_with_basis.py
sage/categories/graded_enumerated_sets.py
sage/categories/graded_hopf_algebras.py
sage/categories/graded_hopf_algebras_with_basis.py
sage/categories/graded_modules.py
sage/categories/graded_modules_with_basis.py
sage/categories/groups.py
sage/categories/hopf_algebras_with_basis.py
sage/categories/infinite_enumerated_sets.py
sage/categories/modules_with_basis.py
sage/categories/monoid_algebras.py
sage/categories/monoids.py
sage/categories/non_unital_algebras.py
sage/categories/rings.py
sage/categories/semigroups.py
sage/categories/sets_cat.py
```

You can ask, e.g. Jean-Baptiste for more.

> That's why we review code, and don't just blindly trust the author.

Certainly. Did I ask for a blind trust? There has been 550 comments on
this ticket which had a strong influence on its implementation. Not
counting discussions elsewhere. Simon thoroughly reviewed it. Others
have been using it. Now there remains a couple spots where it comes to
opinion against opinion. There are various ways to resolve this. With
various consequences.

All I am saying is: «you don't have the monopoly of representing the
users».



---

archive/issue_comments_109348.json:
```json
{
    "body": "<a id='comment:555'></a>\nReplying to [vbraun](#comment%3A553):\n> I know you are talking about method names,\n\nPrecisely.\n\n> but there you cannot have accidental clashes either.\n\nOh yes we can. The analogue of our situation is as follow.\n\nTake two unrelated classes `C` and `D` that both *define* a method\n`x.foo()` but with different semantic. Take a subclass `E` of `C` and\n`D`, and `e` an instance of `E`. Then `e` is an instance of `C`. So\nwherever the method `e.foo()` comes from, it should implement the\nsemantic specified by `C`. But also that specified by `D`.\n\n> In the **very first line** of the class definition the programmer\n> must specify the base classes and their order, so which method comes\n> first in the MRO only reflects the programmer's choice.\n\nWhatever choice the programmer makes in the above situation, the\noutcome is semantically wrong.\n\nBesides, any hope to have a non-trivial control on the MRO for\nhierarchies of dozens of classes is illusory. It's way to non-local.\n\n> > Especially since, if in doubt about the semantic of the ``Finite``\n> > axiom, one can just use introspection:\n\n> \n> But that is precisely what I said is not good enough. First of all we must strive for readable code where relationships between classes (or axioms) are clear from looking at it. The best code is code that doesn't need to be documented. What if a user is trying to fix a bug that prevents Sage from starting up?\n\nThe axioms involved when starting Sage are: Finite, Infinite,\nAssociative, Unital, and a couple similar ones. I don't think the\nreader needs much explanations about their meaning.\n\nNow, yes, not all relationships can be read statically from the code,\nsince a lot is deduced dynamically. However:\n\n(1) We are modeling natural mathematical facts, so the reader can use\n    that information to understand the code.\n\n(2) That's the whole point: like in a math paper we write the\n    important lemmas; not all possible combinations thereof.",
    "created_at": "2014-03-05T22:05:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109348",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:555'></a>
Replying to [vbraun](#comment%3A553):
> I know you are talking about method names,

Precisely.

> but there you cannot have accidental clashes either.

Oh yes we can. The analogue of our situation is as follow.

Take two unrelated classes `C` and `D` that both *define* a method
`x.foo()` but with different semantic. Take a subclass `E` of `C` and
`D`, and `e` an instance of `E`. Then `e` is an instance of `C`. So
wherever the method `e.foo()` comes from, it should implement the
semantic specified by `C`. But also that specified by `D`.

> In the **very first line** of the class definition the programmer
> must specify the base classes and their order, so which method comes
> first in the MRO only reflects the programmer's choice.

Whatever choice the programmer makes in the above situation, the
outcome is semantically wrong.

Besides, any hope to have a non-trivial control on the MRO for
hierarchies of dozens of classes is illusory. It's way to non-local.

> > Especially since, if in doubt about the semantic of the ``Finite``
> > axiom, one can just use introspection:

> 
> But that is precisely what I said is not good enough. First of all we must strive for readable code where relationships between classes (or axioms) are clear from looking at it. The best code is code that doesn't need to be documented. What if a user is trying to fix a bug that prevents Sage from starting up?

The axioms involved when starting Sage are: Finite, Infinite,
Associative, Unital, and a couple similar ones. I don't think the
reader needs much explanations about their meaning.

Now, yes, not all relationships can be read statically from the code,
since a lot is deduced dynamically. However:

(1) We are modeling natural mathematical facts, so the reader can use
    that information to understand the code.

(2) That's the whole point: like in a math paper we write the
    important lemmas; not all possible combinations thereof.



---

archive/issue_comments_109349.json:
```json
{
    "body": "<a id='comment:556'></a>\nReplying to [nthiery](#comment%3A555):\n> > but there you cannot have accidental clashes either.\n\n> Take two unrelated classes `C` and `D` that both *define* a method\n> `x.foo()` but with different semantic. Take a subclass `E` of `C` and\n> `D` [...]\n\nThere is still no accidental clash. If you inherit from C and D then you get exactly what you ask for. Your example is simply one where the programmer actually does not want to inherit from both C and D. That is fine, you also have the possibility to inherit only from one of them or from neither. And you have that flexibility precisely because a) you have a clear and concise syntax for specifying the parents and b) distinct classes stay separate as long as you don't explictly tie them together.\n\n> (1) We are modeling natural mathematical facts, so the reader can use\n>     that information to understand the code.\n\nAll of Sage is about modeling natural mathematical facts. Just because you know Wedderburns theorem does not mean that everybody who ends up implementing a ring knows it. And it certainly does not mean that somebody who reads the code is going to expect that it is magically applied behind the scenes. In fact, I claim that it is quite astonishing when you encounter it for the first time. And if I may quote http://en.wikipedia.org/wiki/Principle_of_least_astonishment: \"If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature.\"",
    "created_at": "2014-03-05T22:52:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109349",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:556'></a>
Replying to [nthiery](#comment%3A555):
> > but there you cannot have accidental clashes either.

> Take two unrelated classes `C` and `D` that both *define* a method
> `x.foo()` but with different semantic. Take a subclass `E` of `C` and
> `D` [...]

There is still no accidental clash. If you inherit from C and D then you get exactly what you ask for. Your example is simply one where the programmer actually does not want to inherit from both C and D. That is fine, you also have the possibility to inherit only from one of them or from neither. And you have that flexibility precisely because a) you have a clear and concise syntax for specifying the parents and b) distinct classes stay separate as long as you don't explictly tie them together.

> (1) We are modeling natural mathematical facts, so the reader can use
>     that information to understand the code.

All of Sage is about modeling natural mathematical facts. Just because you know Wedderburns theorem does not mean that everybody who ends up implementing a ring knows it. And it certainly does not mean that somebody who reads the code is going to expect that it is magically applied behind the scenes. In fact, I claim that it is quite astonishing when you encounter it for the first time. And if I may quote http://en.wikipedia.org/wiki/Principle_of_least_astonishment: "If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature."



---

archive/issue_comments_109350.json:
```json
{
    "body": "<a id='comment:557'></a>\nReplying to [vbraun](#comment%3A556):\n> There is still no accidental clash. If you inherit from C and D then you get exactly what you ask for.\n\nI think the point Nicolas wants to make is: Sure, you can choose the base classes so that you either inherit from C or inherit from D; however, there is *no choice* that is **semantically** (not syntactically) a correct inheritance, if C.foo and D.foo have distinct specifications: The common subclass of C and D will either violate the specification of D.foo or of C.foo.\n\nThat said: In such a situation, you don't want to inherit simultaneously from C and D.",
    "created_at": "2014-03-05T23:11:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109350",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:557'></a>
Replying to [vbraun](#comment%3A556):
> There is still no accidental clash. If you inherit from C and D then you get exactly what you ask for.

I think the point Nicolas wants to make is: Sure, you can choose the base classes so that you either inherit from C or inherit from D; however, there is *no choice* that is **semantically** (not syntactically) a correct inheritance, if C.foo and D.foo have distinct specifications: The common subclass of C and D will either violate the specification of D.foo or of C.foo.

That said: In such a situation, you don't want to inherit simultaneously from C and D.



---

archive/issue_comments_109351.json:
```json
{
    "body": "<a id='comment:558'></a>\nReplying to [vbraun](#comment%3A556):\n> Replying to [nthiery](#comment%3A555):\n> > > but there you cannot have accidental clashes either.\n\n> > Take two unrelated classes `C` and `D` that both *define* a method\n> > `x.foo()` but with different semantic. Take a subclass `E` of `C` and\n> > `D` [...]\n\n> \n> There is still no accidental clash. If you inherit from C and D then you get exactly what you ask for.\n> Your example is simply one where the programmer actually does not want to inherit from both C and D.\n> That is fine, you also have the possibility to inherit only from one of them or from neither. \n\nThat's precisely my point. Similarly, if two independent categories Cs\nand Ds define an axiom with the same name but different semantic, and\nsomeone creates a subcategory Es of both Cs and Ds, then there is no\n*accidental* clash. The programmer actually does not want to build a\nsubcategory of both Cs and Ds. That's what I meant when I said that\naxioms are properly local in the current implementation.\n\n> And you have that flexibility precisely because a) you have a clear\n> and concise syntax for specifying the parents and b) distinct\n> classes stay separate as long as you don't explictly tie them\n> together.\n\nWell, I further claim that the programmer won't get a subcategory of\nboth Cs and Ds by accident, for the subcategory relations that are\ncomputed implicitly during joins are always *full* subcategory\nrelations: the structure and semantic does not change; you only gain\nmore knowledge allowing you to use better algorithms.\n\n> All of Sage is about modeling natural mathematical facts. Just\n> because you know Wedderburns theorem does not mean that everybody\n> who ends up implementing a ring knows it. And it certainly does not\n> mean that somebody who reads the code is going to expect that it is\n> magically applied behind the scenes. In fact, I claim that it is\n> quite astonishing when you encounter it for the first time.\n\nGood. I worked hard so that we could have this *pleasant* surprise :-)\n\n> And if I may quote\n> http://en.wikipedia.org/wiki/Principle_of_least_astonishment: \"If a\n> necessary feature has a high astonishment factor, it may be\n> necessary to redesign the feature.\"\n\nYes. And explicit is nice as well. But this is to be weighted against\nthe DRY principle.\n\nNow, what is your point about:\n\n(1) The syntax for implementing an axiom\n\n(2) Deduction rules like Wedderburn's theorem\n\n(3) The whole axioms and join business",
    "created_at": "2014-03-06T08:56:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109351",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:558'></a>
Replying to [vbraun](#comment%3A556):
> Replying to [nthiery](#comment%3A555):
> > > but there you cannot have accidental clashes either.

> > Take two unrelated classes `C` and `D` that both *define* a method
> > `x.foo()` but with different semantic. Take a subclass `E` of `C` and
> > `D` [...]

> 
> There is still no accidental clash. If you inherit from C and D then you get exactly what you ask for.
> Your example is simply one where the programmer actually does not want to inherit from both C and D.
> That is fine, you also have the possibility to inherit only from one of them or from neither. 

That's precisely my point. Similarly, if two independent categories Cs
and Ds define an axiom with the same name but different semantic, and
someone creates a subcategory Es of both Cs and Ds, then there is no
*accidental* clash. The programmer actually does not want to build a
subcategory of both Cs and Ds. That's what I meant when I said that
axioms are properly local in the current implementation.

> And you have that flexibility precisely because a) you have a clear
> and concise syntax for specifying the parents and b) distinct
> classes stay separate as long as you don't explictly tie them
> together.

Well, I further claim that the programmer won't get a subcategory of
both Cs and Ds by accident, for the subcategory relations that are
computed implicitly during joins are always *full* subcategory
relations: the structure and semantic does not change; you only gain
more knowledge allowing you to use better algorithms.

> All of Sage is about modeling natural mathematical facts. Just
> because you know Wedderburns theorem does not mean that everybody
> who ends up implementing a ring knows it. And it certainly does not
> mean that somebody who reads the code is going to expect that it is
> magically applied behind the scenes. In fact, I claim that it is
> quite astonishing when you encounter it for the first time.

Good. I worked hard so that we could have this *pleasant* surprise :-)

> And if I may quote
> http://en.wikipedia.org/wiki/Principle_of_least_astonishment: "If a
> necessary feature has a high astonishment factor, it may be
> necessary to redesign the feature."

Yes. And explicit is nice as well. But this is to be weighted against
the DRY principle.

Now, what is your point about:

(1) The syntax for implementing an axiom

(2) Deduction rules like Wedderburn's theorem

(3) The whole axioms and join business



---

archive/issue_comments_109352.json:
```json
{
    "body": "**Changing commit** from \"[977a940beba7ed96722a24e36cd81595336350ef](https://github.com/sagemath/sagetrac-mirror/commit/977a940beba7ed96722a24e36cd81595336350ef)\" to \"[ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4](https://github.com/sagemath/sagetrac-mirror/commit/ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4)\".",
    "created_at": "2014-03-06T11:20:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109352",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[977a940beba7ed96722a24e36cd81595336350ef](https://github.com/sagemath/sagetrac-mirror/commit/977a940beba7ed96722a24e36cd81595336350ef)" to "[ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4](https://github.com/sagemath/sagetrac-mirror/commit/ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4)".



---

archive/issue_comments_109353.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/acd58b308f4cd258cfb616a8f8b561db8cfe5292\">acd58b3</a></td><td><code>Fix failing tests due to little conflict when merging with #12141 (finite dimensional algebra)</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4\">ece5c97</a></td><td><code>Axioms: fixed merge with #15873</code></td></tr></table>\n",
    "created_at": "2014-03-06T11:20:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109353",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/acd58b308f4cd258cfb616a8f8b561db8cfe5292">acd58b3</a></td><td><code>Fix failing tests due to little conflict when merging with #12141 (finite dimensional algebra)</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4">ece5c97</a></td><td><code>Axioms: fixed merge with #15873</code></td></tr></table>




---

archive/issue_comments_109354.json:
```json
{
    "body": "<a id='comment:560'></a>\nReplying to [nthiery](#comment%3A558):\n> That's precisely my point. Similarly, if two independent categories Cs\n> and Ds define an axiom with the same name but different semantic, and\n> someone creates a subcategory Es of both Cs and Ds, then there is no\n> *accidental* clash.\n\nAnd what is the alternative in the category framework to creating a subcategory of both C and D? In Python it is clear that multiple inheritance is not the answer to everything, and you can e.g. use object composition to combine classes as an alternative. But here I don't see a way to avoid a name conflict, hence in the above situations the names truly do clash and the poor sap who wants to combine C and D for the first time is thoroughly screwed.\n\nIf there were some fundamental reason why we really need to have potentially clashing axiom names then I wouldn't even mind. But really this is all just to support your special subcategory syntax. As I've demonstrated you can even have subclass syntax without requiring special names. So why introduce this totally unnecessary trap for the unwary? To save one line of code required to make the axiom explict?\n\n> Good. I worked hard so that we could have this *pleasant* surprise :-)\n\nExcept my sentiment in [comment:380](#comment%3A380) was more along the lines of \"if Guido van Rossum were dead then he'd be turning in his grave right now\" ;-)\n\nAnyways, coming back to constructive suggestions: Lets just get rid of the subclass syntax. Really, that has no business on this ticket which is supposed to be the initial implementation of axioms. First you need to have a solid implementation of the axioms and relations, then you can think about beautifying the syntax. This just amounts to a lot of dedenting, inserting `_base_category_class_and_axiom` in the right places, and deleting some metaclass magic. Since \"manual\" construction of category-with-axioms is supposed to be always possible we also wouldn't have to publicize a programming interface that is going to be yanked away in the future. Once we are happy with the implementation we can think about providing a more concise syntax in a future ticket. But IMHO we should focus more on the implementation first, e.g. find ways to not do a potentially-infinite recursive computation on startup etc.",
    "created_at": "2014-03-06T13:26:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109354",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:560'></a>
Replying to [nthiery](#comment%3A558):
> That's precisely my point. Similarly, if two independent categories Cs
> and Ds define an axiom with the same name but different semantic, and
> someone creates a subcategory Es of both Cs and Ds, then there is no
> *accidental* clash.

And what is the alternative in the category framework to creating a subcategory of both C and D? In Python it is clear that multiple inheritance is not the answer to everything, and you can e.g. use object composition to combine classes as an alternative. But here I don't see a way to avoid a name conflict, hence in the above situations the names truly do clash and the poor sap who wants to combine C and D for the first time is thoroughly screwed.

If there were some fundamental reason why we really need to have potentially clashing axiom names then I wouldn't even mind. But really this is all just to support your special subcategory syntax. As I've demonstrated you can even have subclass syntax without requiring special names. So why introduce this totally unnecessary trap for the unwary? To save one line of code required to make the axiom explict?

> Good. I worked hard so that we could have this *pleasant* surprise :-)

Except my sentiment in [comment:380](#comment%3A380) was more along the lines of "if Guido van Rossum were dead then he'd be turning in his grave right now" ;-)

Anyways, coming back to constructive suggestions: Lets just get rid of the subclass syntax. Really, that has no business on this ticket which is supposed to be the initial implementation of axioms. First you need to have a solid implementation of the axioms and relations, then you can think about beautifying the syntax. This just amounts to a lot of dedenting, inserting `_base_category_class_and_axiom` in the right places, and deleting some metaclass magic. Since "manual" construction of category-with-axioms is supposed to be always possible we also wouldn't have to publicize a programming interface that is going to be yanked away in the future. Once we are happy with the implementation we can think about providing a more concise syntax in a future ticket. But IMHO we should focus more on the implementation first, e.g. find ways to not do a potentially-infinite recursive computation on startup etc.



---

archive/issue_comments_109355.json:
```json
{
    "body": "<a id='comment:561'></a>\nReplying to [vbraun](#comment%3A560):\n> And what is the alternative in the category framework to creating a subcategory of both C and D? In Python it is clear that multiple inheritance is not the answer to everything, and you can e.g. use object composition to combine classes as an alternative. But here I don't see a way to avoid a name conflict, hence in the above situations the names truly do clash and the poor sap who wants to combine C and D for the first time is thoroughly screwed.\n\nDo you have a single concrete use case?\n\nI don't see one. And if ever we have one, categories don't prevent\ncomposition more than usual classes; it will be time then to extend\nthe framework to nicely support whatever form of composition we will\ndesign based on concrete experience with concrete use cases.\n\nI am tired of speaking in the vague about hypothetical issues when\nthere are so many concrete problems that needs urgently to be worked\non.\n\n> Except my sentiment in [comment:380](#comment%3A380) was more along the lines of \"if Guido van Rossum were dead then he'd be turning in his grave right now\" ;-)\n\nI know. I have a strong opinion that the more Sage knows about\nmathematics, and uses this knowledge, the better code structure we\nwill have. This has motivated all the work I put into the category\ninfrastructure.\n\n> Anyways, coming back to constructive suggestions: Lets just get rid\n> of the subclass syntax. Really, that has no business on this ticket\n> which is supposed to be the initial implementation of axioms. First\n> you need to have a solid implementation of the axioms and relations,\n> then you can think about beautifying the syntax. This just amounts\n> to a lot of dedenting, inserting `_base_category_class_and_axiom` in\n> the right places, and deleting some metaclass magic. Since \"manual\"\n> construction of category-with-axioms is supposed to be always\n> possible we also wouldn't have to publicize a programming interface\n> that is going to be yanked away in the future. Once we are happy\n> with the implementation we can think about providing a more concise\n> syntax in a future ticket.\n\nWe have been using this nested class syntax for functorial constructions ever since the initial implementation of categories in 2009. It has proven a very practical way to structure the code, we\nnever had a problem with it, and developers learned it all right. I don't see why we should deviate from this syntax for axioms.\n\nNow, if you mean that we should also get rid of the nested class\nsyntax for functorial constructions as well, then fine, fine. Go\nahead. Take over the maintenance and development of categories. I am\nout of it.\n\n> But IMHO we should focus more on the implementation first, e.g. find\n> ways to not do a potentially-infinite recursive computation on\n> startup etc.\n\nThis problem is fixed.",
    "created_at": "2014-03-07T09:54:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109355",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:561'></a>
Replying to [vbraun](#comment%3A560):
> And what is the alternative in the category framework to creating a subcategory of both C and D? In Python it is clear that multiple inheritance is not the answer to everything, and you can e.g. use object composition to combine classes as an alternative. But here I don't see a way to avoid a name conflict, hence in the above situations the names truly do clash and the poor sap who wants to combine C and D for the first time is thoroughly screwed.

Do you have a single concrete use case?

I don't see one. And if ever we have one, categories don't prevent
composition more than usual classes; it will be time then to extend
the framework to nicely support whatever form of composition we will
design based on concrete experience with concrete use cases.

I am tired of speaking in the vague about hypothetical issues when
there are so many concrete problems that needs urgently to be worked
on.

> Except my sentiment in [comment:380](#comment%3A380) was more along the lines of "if Guido van Rossum were dead then he'd be turning in his grave right now" ;-)

I know. I have a strong opinion that the more Sage knows about
mathematics, and uses this knowledge, the better code structure we
will have. This has motivated all the work I put into the category
infrastructure.

> Anyways, coming back to constructive suggestions: Lets just get rid
> of the subclass syntax. Really, that has no business on this ticket
> which is supposed to be the initial implementation of axioms. First
> you need to have a solid implementation of the axioms and relations,
> then you can think about beautifying the syntax. This just amounts
> to a lot of dedenting, inserting `_base_category_class_and_axiom` in
> the right places, and deleting some metaclass magic. Since "manual"
> construction of category-with-axioms is supposed to be always
> possible we also wouldn't have to publicize a programming interface
> that is going to be yanked away in the future. Once we are happy
> with the implementation we can think about providing a more concise
> syntax in a future ticket.

We have been using this nested class syntax for functorial constructions ever since the initial implementation of categories in 2009. It has proven a very practical way to structure the code, we
never had a problem with it, and developers learned it all right. I don't see why we should deviate from this syntax for axioms.

Now, if you mean that we should also get rid of the nested class
syntax for functorial constructions as well, then fine, fine. Go
ahead. Take over the maintenance and development of categories. I am
out of it.

> But IMHO we should focus more on the implementation first, e.g. find
> ways to not do a potentially-infinite recursive computation on
> startup etc.

This problem is fixed.



---

archive/issue_comments_109356.json:
```json
{
    "body": "<a id='comment:2'></a>\nGiven that the discussion is going in round, I made a call for comments and votes on sage-devel:\n\nhttps://groups.google.com/d/msg/sage-devel/hupt_5776j0/p1HqnP03Xd0J\n\nI tried to give a fair account, but please complement it with your own\nview point if needed.",
    "created_at": "2014-03-07T12:18:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109356",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:2'></a>
Given that the discussion is going in round, I made a call for comments and votes on sage-devel:

https://groups.google.com/d/msg/sage-devel/hupt_5776j0/p1HqnP03Xd0J

I tried to give a fair account, but please complement it with your own
view point if needed.



---

archive/issue_comments_109357.json:
```json
{
    "body": "**Changing commit** from \"[ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4](https://github.com/sagemath/sagetrac-mirror/commit/ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4)\" to \"[8bbbfe7dc8e5e9c4fbba758424208e35070272c4](https://github.com/sagemath/sagetrac-mirror/commit/8bbbfe7dc8e5e9c4fbba758424208e35070272c4)\".",
    "created_at": "2014-03-11T05:43:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109357",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4](https://github.com/sagemath/sagetrac-mirror/commit/ece5c973b179319616ff99c3f2ddfd2b6dfcdfd4)" to "[8bbbfe7dc8e5e9c4fbba758424208e35070272c4](https://github.com/sagemath/sagetrac-mirror/commit/8bbbfe7dc8e5e9c4fbba758424208e35070272c4)".



---

archive/issue_comments_109358.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8bbbfe7dc8e5e9c4fbba758424208e35070272c4\">8bbbfe7</a></td><td><code>documentaton improvements</code></td></tr></table>\n",
    "created_at": "2014-03-11T05:43:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109358",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8bbbfe7dc8e5e9c4fbba758424208e35070272c4">8bbbfe7</a></td><td><code>documentaton improvements</code></td></tr></table>




---

archive/issue_comments_109359.json:
```json
{
    "body": "<a id='comment:4'></a>\nI am *not* reviewing this ticket (not enough skill), but I am trying to read up on the new features in the documentation. All commits I'm pushing, unless declared otherwise, fix minor issues I find with the latter. Please doublecheck them, because once again I am not exactly very competent at this...\n\nSome questions that I asked myself while reading the new categories primer and couldn't answer (some of them rhetorical, sorry):\n\n- What do you do if you have a subcategory A of a category B, but the notion of quotient objects in A is *NOT* a particular case (potentially with some extra structure) of the notion of quotient objects in B ? (I don't have any nice examples, but it's very easy to come up with examples for the similar notions of \"equalizer\", \"coproduct\" etc.) Am I allowed to override the `quotient` method on A? Can I expect that it will end up being always used on objects of A and never used on objects of B?\n\n- primer.py around line 890:\n\n```\nThis implementation specifies a data structure for the parents and the\nelements, and makes a promise: the implemented parent is a\nsemigroup. Then it fulfills the promise by implementing the basic\noperations ``product`` and ``semigroup_generators``. In exchange for\n```\nWhat promise does `semigroup_generators` fulfill? Why should a semigroup always come with such a method? Isn't `__contains__` more of a necessity?\n\n- This is not about something in the primer, but it's a question that has been preying on my mind for a while. When implementing a parent method like `product(self, a, b)` to multiply two elements `a` and `b`, can (should?) I WLOG assume that `a` and `b` are already in the parent `self`, or should I first cast them into `self`?\n\n- These TODOs, particularly the first one, might be helpful to fill out:\n\n```\n.. TODO::\n\n    - Specifying the category of a parent\n    - Adding code to an existing parent\n```\nParticularly the first one sounds very important.\n\n- The primer mentions `Sets().Algebras(QQ)` as an example. What exactly does this mean? The repr string (\"Category of set algebras over Rational Field\") isn't very helpful, and an annoyance of mixins is that they don't have documentation.\n\n- The notions of \"subcategory\" and \"full subcategory\" used in the primer (and probably in the rest of the doc?) conflict with mathematics. For example, this (line 1236) is mathematically false:\n\n```\n    sage: Algebras(QQ).FiniteDimensional().is_subcategory( Modules(QQ).FiniteDimensional() )\n    True\n```\nA subcategory in accordance with mathematical notation cannot have any extra structure unless it is predetermined by its existence (like inverses in groups). If you want to keep to this usage of the notion in Sage, PLEASE HEAVILY DOCUMENT IT. The claim that all subcategories are automatically full (line 1100) is also mistaken; if it is supposed to mean that Sage only knows how to deal with full subcategories (i.e., if I define a subcategory, then Sage will automatically regard any morphism of the big category as a morphism of the small one), then again THIS SHOULD BE DOCUMENTED.\n\n- Curious question: Is there any connection between the AdditiveAssociative and Associative axioms? I.e., does the former profit from methods bound to the latter in any way? Whether yes or not, this might use a brief mention in the doc.\n\n- Line 1377 of the primer:\n\n```\n``C.super_categories()`` *must* return a list of categories, namely\nthe *immediate* super categories of `C`.\n```\nDoes this mean that it is FORBIDDEN to provide non-immediate supercategories (i.e., categories with some supercategories inbetween)? This is somewhat important because if true, it means that one has to be particularly careful when introducing new categories into the graph, and remove all redundant paths when doing so. Again, something that the reader should be warned about. But I'm hoping that this is not the case, as I don't see a reason why this should be required.\n\n- Do the primer, along with the module-wide doc of `category_with_axiom.py`, document everything one needs to know when introducing new categories into the framework? I'm planning to read the latter in foreseeable time.\n\nPlease don't get me wrong -- most of the primer is very readable and indeed quite fun to read. I'd in fact be happy if all of Sage's documentation was like that...\n\nThanks a lot!",
    "created_at": "2014-03-11T06:02:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109359",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:4'></a>
I am *not* reviewing this ticket (not enough skill), but I am trying to read up on the new features in the documentation. All commits I'm pushing, unless declared otherwise, fix minor issues I find with the latter. Please doublecheck them, because once again I am not exactly very competent at this...

Some questions that I asked myself while reading the new categories primer and couldn't answer (some of them rhetorical, sorry):

- What do you do if you have a subcategory A of a category B, but the notion of quotient objects in A is *NOT* a particular case (potentially with some extra structure) of the notion of quotient objects in B ? (I don't have any nice examples, but it's very easy to come up with examples for the similar notions of "equalizer", "coproduct" etc.) Am I allowed to override the `quotient` method on A? Can I expect that it will end up being always used on objects of A and never used on objects of B?

- primer.py around line 890:

```
This implementation specifies a data structure for the parents and the
elements, and makes a promise: the implemented parent is a
semigroup. Then it fulfills the promise by implementing the basic
operations ``product`` and ``semigroup_generators``. In exchange for
```
What promise does `semigroup_generators` fulfill? Why should a semigroup always come with such a method? Isn't `__contains__` more of a necessity?

- This is not about something in the primer, but it's a question that has been preying on my mind for a while. When implementing a parent method like `product(self, a, b)` to multiply two elements `a` and `b`, can (should?) I WLOG assume that `a` and `b` are already in the parent `self`, or should I first cast them into `self`?

- These TODOs, particularly the first one, might be helpful to fill out:

```
.. TODO::

    - Specifying the category of a parent
    - Adding code to an existing parent
```
Particularly the first one sounds very important.

- The primer mentions `Sets().Algebras(QQ)` as an example. What exactly does this mean? The repr string ("Category of set algebras over Rational Field") isn't very helpful, and an annoyance of mixins is that they don't have documentation.

- The notions of "subcategory" and "full subcategory" used in the primer (and probably in the rest of the doc?) conflict with mathematics. For example, this (line 1236) is mathematically false:

```
    sage: Algebras(QQ).FiniteDimensional().is_subcategory( Modules(QQ).FiniteDimensional() )
    True
```
A subcategory in accordance with mathematical notation cannot have any extra structure unless it is predetermined by its existence (like inverses in groups). If you want to keep to this usage of the notion in Sage, PLEASE HEAVILY DOCUMENT IT. The claim that all subcategories are automatically full (line 1100) is also mistaken; if it is supposed to mean that Sage only knows how to deal with full subcategories (i.e., if I define a subcategory, then Sage will automatically regard any morphism of the big category as a morphism of the small one), then again THIS SHOULD BE DOCUMENTED.

- Curious question: Is there any connection between the AdditiveAssociative and Associative axioms? I.e., does the former profit from methods bound to the latter in any way? Whether yes or not, this might use a brief mention in the doc.

- Line 1377 of the primer:

```
``C.super_categories()`` *must* return a list of categories, namely
the *immediate* super categories of `C`.
```
Does this mean that it is FORBIDDEN to provide non-immediate supercategories (i.e., categories with some supercategories inbetween)? This is somewhat important because if true, it means that one has to be particularly careful when introducing new categories into the graph, and remove all redundant paths when doing so. Again, something that the reader should be warned about. But I'm hoping that this is not the case, as I don't see a reason why this should be required.

- Do the primer, along with the module-wide doc of `category_with_axiom.py`, document everything one needs to know when introducing new categories into the framework? I'm planning to read the latter in foreseeable time.

Please don't get me wrong -- most of the primer is very readable and indeed quite fun to read. I'd in fact be happy if all of Sage's documentation was like that...

Thanks a lot!



---

archive/issue_comments_109360.json:
```json
{
    "body": "**Changing commit** from \"[8bbbfe7dc8e5e9c4fbba758424208e35070272c4](https://github.com/sagemath/sagetrac-mirror/commit/8bbbfe7dc8e5e9c4fbba758424208e35070272c4)\" to \"[5c9ac79fb7207b179fc3717570fb078f40d526a0](https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0)\".",
    "created_at": "2014-03-11T20:47:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109360",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[8bbbfe7dc8e5e9c4fbba758424208e35070272c4](https://github.com/sagemath/sagetrac-mirror/commit/8bbbfe7dc8e5e9c4fbba758424208e35070272c4)" to "[5c9ac79fb7207b179fc3717570fb078f40d526a0](https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0)".



---

archive/issue_comments_109361.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0\">5c9ac79</a></td><td><code>more doc fixes</code></td></tr></table>\n",
    "created_at": "2014-03-11T20:47:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109361",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0">5c9ac79</a></td><td><code>more doc fixes</code></td></tr></table>




---

archive/issue_comments_109362.json:
```json
{
    "body": "<a id='comment:6'></a>\nPart 2: the beginning of `sage/categories/category_with_axiom.py`.\n\n- I don't understand this:\n\n```\n    - From an object oriented point of view, any subcategory ``Cs()``\n      of :class:`~sage.categories.sets_cat.Sets` inherits from a ``Finite`` method, and ``Cs``\n      can complement this method with extra data (here a mixin class)\n      in the form of a class attribute ``Cs.Finite``.\n```\n\"inherits from\" should be \"inherits\", right? What does \"extra data (here a mixin class)\" mean? Should a class attribute (not a class method) really override a method? Or does \"class attribute\" mean \"class method\" here? And what does this paragraph actually say? That I can override any method from a higher-up category? Isn't that clear anyway?\n\n- This reads weird:\n\n```\n    This is undoubtedly a code smell. Nethertheless it should be kept as\n    is, first to resolve the import order properly, and more\n    importantly as a reminder that the category would be best not\n    constructed upon Sage's startup. This to entice developpers to\n    reduce the number of parents (and therefore categories) that are\n    constructed upon startup. Each \"at_startup=True\" that will be\n    removed will be a measure of progress in this direction.\n```\n\"it should be kept as is\" probably was intended to mean that the warnings at startup time should be preserved, not that the lazy import at startup time should be preserved. I don't understand the use of \"entice\" in this paragraph.\n\n- I don't understand this:\n\n```\n.. NOTE::\n\n    In principle, due to a limitation of :class:`LazyImport` with\n    nested classes (see :trac:`15648`), one should pass the option\n    ``as_name`` to :class:`LazyImport`::\n\n        Finite = LazyImport('sage.categories.finite_groups', 'FiniteGroups', as_name='Finite')\n\n    in order to prevent ``Groups.Finite`` to keep on reimporting\n    ``FiniteGroups``.\n\n    Given that passing this option introduces some redundancy and is\n    error prone, the axiom infrastructure includes a little workaround\n    which makes the ``as_name`` unnecessary in this case.\n```\nBut it sounds like something that can eventually bite me in the ass. Can I have some more detail?\n\n- Line 251:\n\n```\nWe don't recommend using this syntax which may eventually be\ndeprecated.\n```\nWhat syntax? `Algebras.WithBasis(QQ)`? What is the general pattern here (other than \"declaration of base needlessly delayed\")?\n\n- My 2 cents on one of the pain-in-the-ass issues: I do *not* oppose the syntax-based guessing of base category class and axiom, as long as it is used as a last resort and can always be manually overridden if it turns out to be less than smart. After all, am I seeing it right that if it *does* return a guess, the guess is guaranteed to be correct (`assert getattr(base_category_class, axiom, None) is cls`)? If this is indeed the case, you should proudly point this out in the documentation, because \"heuristic\" and \"guesses\" are words that make people like myself very scared. (Also, maybe add some instructions for users of categories on how to add doctests that verify that it is successful at guessing?)\n\n- Why talk of arborescences rather than just rooted trees? Do you want to stress a poset/digraph structure?\n\n- Wait...\n\n```\nFor example, the fact that a cartesian product of associative magmas\n(i.e. of semigroups) is associative\n```\nReally? Isn't that the typical associativity-up-to-equivalence situation where the equivalence can usually be ignored in proofs but comes back with a vengeance if taken too lightly in code? Specifically, is ((1,2),3) == (1,(2,3)) ?\n\nI'll have to stop here because I want to update sage to beta4. The new commit I'm pushing is mostly harmless doc edits, and I hope they won't take long to review.\n\nThe doc still is very good!\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0\">5c9ac79</a></td><td><code>more doc fixes</code></td></tr></table>\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0\">5c9ac79</a></td><td><code>more doc fixes</code></td></tr></table>\n",
    "created_at": "2014-03-11T20:47:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109362",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:6'></a>
Part 2: the beginning of `sage/categories/category_with_axiom.py`.

- I don't understand this:

```
    - From an object oriented point of view, any subcategory ``Cs()``
      of :class:`~sage.categories.sets_cat.Sets` inherits from a ``Finite`` method, and ``Cs``
      can complement this method with extra data (here a mixin class)
      in the form of a class attribute ``Cs.Finite``.
```
"inherits from" should be "inherits", right? What does "extra data (here a mixin class)" mean? Should a class attribute (not a class method) really override a method? Or does "class attribute" mean "class method" here? And what does this paragraph actually say? That I can override any method from a higher-up category? Isn't that clear anyway?

- This reads weird:

```
    This is undoubtedly a code smell. Nethertheless it should be kept as
    is, first to resolve the import order properly, and more
    importantly as a reminder that the category would be best not
    constructed upon Sage's startup. This to entice developpers to
    reduce the number of parents (and therefore categories) that are
    constructed upon startup. Each "at_startup=True" that will be
    removed will be a measure of progress in this direction.
```
"it should be kept as is" probably was intended to mean that the warnings at startup time should be preserved, not that the lazy import at startup time should be preserved. I don't understand the use of "entice" in this paragraph.

- I don't understand this:

```
.. NOTE::

    In principle, due to a limitation of :class:`LazyImport` with
    nested classes (see :trac:`15648`), one should pass the option
    ``as_name`` to :class:`LazyImport`::

        Finite = LazyImport('sage.categories.finite_groups', 'FiniteGroups', as_name='Finite')

    in order to prevent ``Groups.Finite`` to keep on reimporting
    ``FiniteGroups``.

    Given that passing this option introduces some redundancy and is
    error prone, the axiom infrastructure includes a little workaround
    which makes the ``as_name`` unnecessary in this case.
```
But it sounds like something that can eventually bite me in the ass. Can I have some more detail?

- Line 251:

```
We don't recommend using this syntax which may eventually be
deprecated.
```
What syntax? `Algebras.WithBasis(QQ)`? What is the general pattern here (other than "declaration of base needlessly delayed")?

- My 2 cents on one of the pain-in-the-ass issues: I do *not* oppose the syntax-based guessing of base category class and axiom, as long as it is used as a last resort and can always be manually overridden if it turns out to be less than smart. After all, am I seeing it right that if it *does* return a guess, the guess is guaranteed to be correct (`assert getattr(base_category_class, axiom, None) is cls`)? If this is indeed the case, you should proudly point this out in the documentation, because "heuristic" and "guesses" are words that make people like myself very scared. (Also, maybe add some instructions for users of categories on how to add doctests that verify that it is successful at guessing?)

- Why talk of arborescences rather than just rooted trees? Do you want to stress a poset/digraph structure?

- Wait...

```
For example, the fact that a cartesian product of associative magmas
(i.e. of semigroups) is associative
```
Really? Isn't that the typical associativity-up-to-equivalence situation where the equivalence can usually be ignored in proofs but comes back with a vengeance if taken too lightly in code? Specifically, is ((1,2),3) == (1,(2,3)) ?

I'll have to stop here because I want to update sage to beta4. The new commit I'm pushing is mostly harmless doc edits, and I hope they won't take long to review.

The doc still is very good!

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0">5c9ac79</a></td><td><code>more doc fixes</code></td></tr></table>

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0">5c9ac79</a></td><td><code>more doc fixes</code></td></tr></table>




---

archive/issue_comments_109363.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4cd76af11b574392811ab52237e83ddb5fc5d424\">4cd76af</a></td><td><code>repeat some #8389 edits to make a cleaner merge with 6.2.beta4</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/777ea6587cfce214f466f433f66b98acf22553cb\">777ea65</a></td><td><code>manual merge</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5422cbc169f4cbc94fddeb3d00bea351536a36db\">5422cbc</a></td><td><code>localize imports</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4\">1cdc128</a></td><td><code>I can't count</code></td></tr></table>\n",
    "created_at": "2014-03-11T22:31:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109363",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4cd76af11b574392811ab52237e83ddb5fc5d424">4cd76af</a></td><td><code>repeat some #8389 edits to make a cleaner merge with 6.2.beta4</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/777ea6587cfce214f466f433f66b98acf22553cb">777ea65</a></td><td><code>manual merge</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5422cbc169f4cbc94fddeb3d00bea351536a36db">5422cbc</a></td><td><code>localize imports</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4">1cdc128</a></td><td><code>I can't count</code></td></tr></table>




---

archive/issue_comments_109364.json:
```json
{
    "body": "**Changing commit** from \"[5c9ac79fb7207b179fc3717570fb078f40d526a0](https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0)\" to \"[1cdc128a85851dd007b3b77ec53a4853a10e1de4](https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4)\".",
    "created_at": "2014-03-11T22:31:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109364",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[5c9ac79fb7207b179fc3717570fb078f40d526a0](https://github.com/sagemath/sagetrac-mirror/commit/5c9ac79fb7207b179fc3717570fb078f40d526a0)" to "[1cdc128a85851dd007b3b77ec53a4853a10e1de4](https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4)".



---

archive/issue_comments_109365.json:
```json
{
    "body": "<a id='comment:8'></a>\nI've just pushed a (manual) merge with develop, and, while at that, banished two imports in `src/sage/categories/rings.py` into the one method where they were used (these were new imports from #8389). I haven't run all the doctests, but the .rst file I changed passes, and so do all `src/sage/rings/` and `src/sage/categories` files except for one test:\n\n```\n            sage: FF = IntegerModRing(29)\n            sage: TestSuite(FF).run()\n```\nThis is now tracked at #15919.",
    "created_at": "2014-03-11T22:32:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109365",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:8'></a>
I've just pushed a (manual) merge with develop, and, while at that, banished two imports in `src/sage/categories/rings.py` into the one method where they were used (these were new imports from #8389). I haven't run all the doctests, but the .rst file I changed passes, and so do all `src/sage/rings/` and `src/sage/categories` files except for one test:

```
            sage: FF = IntegerModRing(29)
            sage: TestSuite(FF).run()
```
This is now tracked at #15919.



---

archive/issue_comments_109366.json:
```json
{
    "body": "<a id='comment:569'></a>\nReplying to [darij](#comment%3A564):\n> I am *not* reviewing this ticket (not enough skill), but I am trying to read up on the new features in the documentation. All commits I'm pushing, unless declared otherwise, fix minor issues I find with the latter. Please doublecheck them, because once again I am not exactly very competent at this...\n\nProofreading the documentation is an important piece of the review!\nAnd being in the target audience you are specifically fit for it. So\nthanks a lot!\n\n> - What do you do if you have a subcategory A of a category B, but the notion of quotient objects in A is *NOT* a particular case (potentially with some extra structure) of the notion of quotient objects in B ? (I don't have any nice examples, but it's very easy to come up with examples for the similar notions of \"equalizer\", \"coproduct\" etc.) Am I allowed to override the `quotient` method on A? Can I expect that it will end up being always used on objects of A and never used on objects of B?\n\nNot sure what you mean. I guess that would be easier to discuss on a\nconcrete example.\n\n> - primer.py around line 890:\n> \n> ```\n> This implementation specifies a data structure for the parents and the\n> elements, and makes a promise: the implemented parent is a\n> semigroup. Then it fulfills the promise by implementing the basic\n> operations ``product`` and ``semigroup_generators``. In exchange for\n> ```\n> What promise does `semigroup_generators` fulfill? Why should a semigroup always come with such a method? Isn't `__contains__` more of a necessity?\n\nIt's a finite semigroup (the \"finite\" was missing above; I just added\nit and will push later on). So implementing the product and the\nsemigroup generators is one of the ways to define everything. Another\nway would indeed be to provide `__contains__`.\n\n\n\n> - This is not about something in the primer, but it's a question that has been preying on my mind for a while. When implementing a parent method like `product(self, a, b)` to multiply two elements `a` and `b`, can (should?) I WLOG assume that `a` and `b` are already in the parent `self`, or should I first cast them into `self`?\n\nIt's appropriate to check that they are indeed in `self`, typically\nusing `self.is_parent_of(a)`, and raise a value error otherwise.\n\n> - These TODOs, particularly the first one, might be helpful to fill out:\n> \n> ```\n> .. TODO::\n> \n>     - Specifying the category of a parent\n>     - Adding code to an existing parent\n> ```\n> Particularly the first one sounds very important.\n\nDefinitely. But there is already enough on the plate for this ticket!\n\n> - The primer mentions `Sets().Algebras(QQ)` as an example. What exactly does this mean? The repr string (\"Category of set algebras over Rational Field\") isn't very helpful,\n\nAgreed. The \"right\" piece of documentation is in\nsage.categories.algebra_functor.AlgebrasCategory. This documentation\nshould really be in Sets().Algebras but this is unrelated to this\nticket and should be fixed elsewhere. Feel free to open a ticket!\n\n> and an annoyance of mixins is that they don't have documentation.\n\nWell, you actually can provide documentation for them. But in most\ncase it would be extremely redundant to have to do it, so we should be\nthinking about ways this documentation could be constructed\nautomatically.\n\n> - The notions of \"subcategory\" and \"full subcategory\" used in the\n> primer (and probably in the rest of the doc?) conflict with\n> mathematics.  A subcategory in accordance with mathematical notation\n> cannot have any extra structure unless it is predetermined by its\n> existence (like inverses in groups). If you want to keep to this\n> usage of the notion in Sage, PLEASE HEAVILY DOCUMENT IT.\n\nReally? I used those definitions from http://en.wikipedia.org/wiki/Subcategory:\n\n``In mathematics, a subcategory of a category C is a category S whose\nobjects are objects in C and whose morphisms are morphisms in C with\nthe same identities and composition of morphisms''\n\n``A full subcategory is one that includes all morphisms between objects of S''\n\n> For example, this (line 1236) is mathematically false:\n> \n> ```\n>     sage: Algebras(QQ).FiniteDimensional().is_subcategory( Modules(QQ).FiniteDimensional() )\n>     True\n> ```\n\nAccording to the above definitions, this is definitely not a full\nsubcategory, but it is a subcategory.\n\n> The claim that all subcategories are automatically full (line 1100) is also mistaken; if it is supposed to mean that Sage only knows how to deal with full subcategories (i.e., if I define a subcategory, then Sage will automatically regard any morphism of the big category as a morphism of the small one), then again THIS SHOULD BE DOCUMENTED.\n\nThe claim on line 1100 is only about subcategories defined by an\naxiom. Those are full subcategories.\n\n> - Curious question: Is there any connection between the AdditiveAssociative and Associative axioms? I.e., does the former profit from methods bound to the latter in any way? Whether yes or not, this might use a brief mention in the doc.\n\nNo, alas no. The hierarchies for additive XXX and for multiplicative\nXXX are completely independent of each other. That's very annoying,\nbecause this means everything is duplicated.\n\nI know of no computer algebra system that has a good solution for\nthis, and any great idea to tackle this is more than welcome.\n\nI am not sure how to phrase this in the primer, but feel free to\nintroduce some lines on the topic wherever you may see fit.\n\n> - Line 1377 of the primer:\n> \n> ```\n> ``C.super_categories()`` *must* return a list of categories, namely\n> the *immediate* super categories of `C`.\n> ```\n> Does this mean that it is FORBIDDEN to provide non-immediate supercategories (i.e., categories with some supercategories inbetween)? This is somewhat important because if true, it means that one has to be particularly careful when introducing new categories into the graph, and remove all redundant paths when doing so. Again, something that the reader should be warned about. But I'm hoping that this is not the case, as I don't see a reason why this should be required.\n\nWhat's really important is that you provide at least all the immediate\nsuper categories, which already requires some care when inserting new\ncategories.\n\nNow, I agree with you that it would be better if the system did not\nmind if there occasionally were non immediate super categories\ntoo. This actually probably is already the case, but I would want to\ntriple check the code before I relax this specification. In fact, we\nalready are already massaging the super_categories by sorting them; it\ncould make sense to remove duplicates at the same occasion, but I am\nnot sure about the overhead. Since this specification precedes this\nticket, that's anyway for latter.\n\nNow if you believe the above comment is important to mention, feel\nfree to add a note right now.\n\n> - Do the primer, along with the module-wide doc of `category_with_axiom.py`, document everything one needs to know when introducing new categories into the framework? I'm planning to read the latter in foreseeable time.\n\nTogether with the documentation of `Category`, I believe yes!  But\nplease make up your own mind. And feel free to add a word in the\nprimer about this.\n\n> Please don't get me wrong\n\nI am not. This is super constructive!\n\n> most of the primer is very readable and indeed quite fun to\n> read. I'd in fact be happy if all of Sage's documentation was like\n> that...\n\n:-)\n\nCheers,\n                      Nicolas\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4cd76af11b574392811ab52237e83ddb5fc5d424\">4cd76af</a></td><td><code>repeat some #8389 edits to make a cleaner merge with 6.2.beta4</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/777ea6587cfce214f466f433f66b98acf22553cb\">777ea65</a></td><td><code>manual merge</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5422cbc169f4cbc94fddeb3d00bea351536a36db\">5422cbc</a></td><td><code>localize imports</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4\">1cdc128</a></td><td><code>I can't count</code></td></tr></table>\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4cd76af11b574392811ab52237e83ddb5fc5d424\">4cd76af</a></td><td><code>repeat some #8389 edits to make a cleaner merge with 6.2.beta4</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/777ea6587cfce214f466f433f66b98acf22553cb\">777ea65</a></td><td><code>manual merge</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5422cbc169f4cbc94fddeb3d00bea351536a36db\">5422cbc</a></td><td><code>localize imports</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4\">1cdc128</a></td><td><code>I can't count</code></td></tr></table>\n",
    "created_at": "2014-03-11T23:16:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109366",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:569'></a>
Replying to [darij](#comment%3A564):
> I am *not* reviewing this ticket (not enough skill), but I am trying to read up on the new features in the documentation. All commits I'm pushing, unless declared otherwise, fix minor issues I find with the latter. Please doublecheck them, because once again I am not exactly very competent at this...

Proofreading the documentation is an important piece of the review!
And being in the target audience you are specifically fit for it. So
thanks a lot!

> - What do you do if you have a subcategory A of a category B, but the notion of quotient objects in A is *NOT* a particular case (potentially with some extra structure) of the notion of quotient objects in B ? (I don't have any nice examples, but it's very easy to come up with examples for the similar notions of "equalizer", "coproduct" etc.) Am I allowed to override the `quotient` method on A? Can I expect that it will end up being always used on objects of A and never used on objects of B?

Not sure what you mean. I guess that would be easier to discuss on a
concrete example.

> - primer.py around line 890:
> 
> ```
> This implementation specifies a data structure for the parents and the
> elements, and makes a promise: the implemented parent is a
> semigroup. Then it fulfills the promise by implementing the basic
> operations ``product`` and ``semigroup_generators``. In exchange for
> ```
> What promise does `semigroup_generators` fulfill? Why should a semigroup always come with such a method? Isn't `__contains__` more of a necessity?

It's a finite semigroup (the "finite" was missing above; I just added
it and will push later on). So implementing the product and the
semigroup generators is one of the ways to define everything. Another
way would indeed be to provide `__contains__`.



> - This is not about something in the primer, but it's a question that has been preying on my mind for a while. When implementing a parent method like `product(self, a, b)` to multiply two elements `a` and `b`, can (should?) I WLOG assume that `a` and `b` are already in the parent `self`, or should I first cast them into `self`?

It's appropriate to check that they are indeed in `self`, typically
using `self.is_parent_of(a)`, and raise a value error otherwise.

> - These TODOs, particularly the first one, might be helpful to fill out:
> 
> ```
> .. TODO::
> 
>     - Specifying the category of a parent
>     - Adding code to an existing parent
> ```
> Particularly the first one sounds very important.

Definitely. But there is already enough on the plate for this ticket!

> - The primer mentions `Sets().Algebras(QQ)` as an example. What exactly does this mean? The repr string ("Category of set algebras over Rational Field") isn't very helpful,

Agreed. The "right" piece of documentation is in
sage.categories.algebra_functor.AlgebrasCategory. This documentation
should really be in Sets().Algebras but this is unrelated to this
ticket and should be fixed elsewhere. Feel free to open a ticket!

> and an annoyance of mixins is that they don't have documentation.

Well, you actually can provide documentation for them. But in most
case it would be extremely redundant to have to do it, so we should be
thinking about ways this documentation could be constructed
automatically.

> - The notions of "subcategory" and "full subcategory" used in the
> primer (and probably in the rest of the doc?) conflict with
> mathematics.  A subcategory in accordance with mathematical notation
> cannot have any extra structure unless it is predetermined by its
> existence (like inverses in groups). If you want to keep to this
> usage of the notion in Sage, PLEASE HEAVILY DOCUMENT IT.

Really? I used those definitions from http://en.wikipedia.org/wiki/Subcategory:

``In mathematics, a subcategory of a category C is a category S whose
objects are objects in C and whose morphisms are morphisms in C with
the same identities and composition of morphisms''

``A full subcategory is one that includes all morphisms between objects of S''

> For example, this (line 1236) is mathematically false:
> 
> ```
>     sage: Algebras(QQ).FiniteDimensional().is_subcategory( Modules(QQ).FiniteDimensional() )
>     True
> ```

According to the above definitions, this is definitely not a full
subcategory, but it is a subcategory.

> The claim that all subcategories are automatically full (line 1100) is also mistaken; if it is supposed to mean that Sage only knows how to deal with full subcategories (i.e., if I define a subcategory, then Sage will automatically regard any morphism of the big category as a morphism of the small one), then again THIS SHOULD BE DOCUMENTED.

The claim on line 1100 is only about subcategories defined by an
axiom. Those are full subcategories.

> - Curious question: Is there any connection between the AdditiveAssociative and Associative axioms? I.e., does the former profit from methods bound to the latter in any way? Whether yes or not, this might use a brief mention in the doc.

No, alas no. The hierarchies for additive XXX and for multiplicative
XXX are completely independent of each other. That's very annoying,
because this means everything is duplicated.

I know of no computer algebra system that has a good solution for
this, and any great idea to tackle this is more than welcome.

I am not sure how to phrase this in the primer, but feel free to
introduce some lines on the topic wherever you may see fit.

> - Line 1377 of the primer:
> 
> ```
> ``C.super_categories()`` *must* return a list of categories, namely
> the *immediate* super categories of `C`.
> ```
> Does this mean that it is FORBIDDEN to provide non-immediate supercategories (i.e., categories with some supercategories inbetween)? This is somewhat important because if true, it means that one has to be particularly careful when introducing new categories into the graph, and remove all redundant paths when doing so. Again, something that the reader should be warned about. But I'm hoping that this is not the case, as I don't see a reason why this should be required.

What's really important is that you provide at least all the immediate
super categories, which already requires some care when inserting new
categories.

Now, I agree with you that it would be better if the system did not
mind if there occasionally were non immediate super categories
too. This actually probably is already the case, but I would want to
triple check the code before I relax this specification. In fact, we
already are already massaging the super_categories by sorting them; it
could make sense to remove duplicates at the same occasion, but I am
not sure about the overhead. Since this specification precedes this
ticket, that's anyway for latter.

Now if you believe the above comment is important to mention, feel
free to add a note right now.

> - Do the primer, along with the module-wide doc of `category_with_axiom.py`, document everything one needs to know when introducing new categories into the framework? I'm planning to read the latter in foreseeable time.

Together with the documentation of `Category`, I believe yes!  But
please make up your own mind. And feel free to add a word in the
primer about this.

> Please don't get me wrong

I am not. This is super constructive!

> most of the primer is very readable and indeed quite fun to
> read. I'd in fact be happy if all of Sage's documentation was like
> that...

:-)

Cheers,
                      Nicolas

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4cd76af11b574392811ab52237e83ddb5fc5d424">4cd76af</a></td><td><code>repeat some #8389 edits to make a cleaner merge with 6.2.beta4</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/777ea6587cfce214f466f433f66b98acf22553cb">777ea65</a></td><td><code>manual merge</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5422cbc169f4cbc94fddeb3d00bea351536a36db">5422cbc</a></td><td><code>localize imports</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4">1cdc128</a></td><td><code>I can't count</code></td></tr></table>

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4cd76af11b574392811ab52237e83ddb5fc5d424">4cd76af</a></td><td><code>repeat some #8389 edits to make a cleaner merge with 6.2.beta4</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/777ea6587cfce214f466f433f66b98acf22553cb">777ea65</a></td><td><code>manual merge</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5422cbc169f4cbc94fddeb3d00bea351536a36db">5422cbc</a></td><td><code>localize imports</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4">1cdc128</a></td><td><code>I can't count</code></td></tr></table>




---

archive/issue_comments_109367.json:
```json
{
    "body": "<a id='comment:0'></a>\nBy the way: thanks for improving the doc of FiniteMonoids and\nFiniteSemigroups. As you will have noticed, I have moved up some of\nthose improvements to Monoids and Semigroups. Please check!\n\nIn general the main documentation strings of categories would need\nsome love. I think we first need to have a brainstorm to decide on\nsome common format to make them more uniform and systematic. And also\nto automatize part of the process, in particular for mixin\nclasses. Since (most of) those documentations predates this ticket\n(they may have been moved around though), this is orthogonal to this\nticket.\n\nOtherwise said: unless you spot trivial typos to fix, don't worry\nabout those documentations strings.\n\nOff to bed!\n\nCheers,\n                     Nicolas",
    "created_at": "2014-03-11T23:25:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109367",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:0'></a>
By the way: thanks for improving the doc of FiniteMonoids and
FiniteSemigroups. As you will have noticed, I have moved up some of
those improvements to Monoids and Semigroups. Please check!

In general the main documentation strings of categories would need
some love. I think we first need to have a brainstorm to decide on
some common format to make them more uniform and systematic. And also
to automatize part of the process, in particular for mixin
classes. Since (most of) those documentations predates this ticket
(they may have been moved around though), this is orthogonal to this
ticket.

Otherwise said: unless you spot trivial typos to fix, don't worry
about those documentations strings.

Off to bed!

Cheers,
                     Nicolas



---

archive/issue_comments_109368.json:
```json
{
    "body": "<a id='comment:1'></a>\nThere are some performance and leaking issues with the proposed code here. They\nhave been mentioned before, but they got swamped in more theoretical design\ndiscussions. Consider for instance with sage 6.2.beta4:\n\n```\nsage: import gc\nsage: from collections import Counter\nsage: before={id(c) for c in gc.get_objects()}\nsage: %time for n in [1..5000]: x=(matrix(Integers(n),2,2,1))\nCPU times: user 2.81 s, sys: 21 ms, total: 2.83 s\nWall time: 2.83 s\nsage: gc.collect()\n8373\nsage: gc.collect()\n918\nsage: after=[c for c in gc.get_objects() if id(c) not in before]\nsage: [c for c in Counter([str(type(a)) for a in after]).items() if c[1] > 4000]\n[]\n```\nand with the patch:\n\n```\nsage: import gc\nsage: from collections import Counter\nsage: before={id(c) for c in gc.get_objects()}\nsage: %time for n in [1..5000]: x=(matrix(Integers(n),2,2,1))\nCPU times: user 13.1 s, sys: 131 ms, total: 13.2 s\nWall time: 13.3 s\nsage: gc.collect()\n1480\nsage: gc.collect()\n0\nsage: after=[c for c in gc.get_objects() if id(c) not in before]\nsage: [c for c in Counter([str(type(a)) for a in after]).items() if c[1] > 4000]\n[(\"<class 'sage.categories.algebras.Algebras_with_category'>\", 5000),\n (\"<class 'weakref.KeyedRef'>\", 85682),\n (\"<type 'weakref'>\", 65846),\n (\"<type 'sage.structure.coerce_dict.TripleDict'>\", 10001),\n (\"<type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>\", 40677),\n (\"<type 'function'>\", 37336),\n (\"<type 'tuple'>\", 326404),\n (\"<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>\", 5000),\n (\"<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>\", 5000),\n (\"<type 'sage.misc.cachefunc.CachedMethodCaller'>\", 30002),\n (\"<class 'sage.categories.bimodules.Bimodules_with_category'>\", 5000),\n (\"<type 'builtin_function_or_method'>\", 30173),\n (\"<class 'sage.rings.ideal.Ideal_pid'>\", 5000),\n (\"<class 'sage.categories.homset.Homset_with_category'>\", 5000),\n (\"<type 'dict'>\", 111638),\n (\"<class 'sage.categories.left_modules.LeftModules_with_category'>\", 5000),\n (\"<type 'cell'>\", 71409),\n (\"<class 'sage.categories.right_modules.RightModules_with_category'>\", 5000),\n (\"<type 'sage.structure.coerce_dict.MonoDictEraser'>\", 20003),\n (\"<type 'list'>\", 101980),\n (\"<class 'sage.structure.dynamic_class.DynamicClasscallMetaclass'>\", 35672),\n (\"<type 'sage.structure.coerce_dict.TripleDictEraser'>\", 10001),\n (\"<type 'instancemethod'>\", 10021),\n (\"<type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>\", 138253),\n (\"<class 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic_with_category'>\", 5000),\n (\"<type 'sage.structure.coerce_dict.MonoDict'>\", 20003),\n (\"<type 'staticmethod'>\", 35734),\n (\"<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>\", 5000),\n (\"<type 'frozenset'>\", 30671),\n (\"<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>\", 5000),\n (\"<class 'sage.categories.modules.Modules_with_category'>\", 5000)]\n```\nAs you can see, much slower execution and much leakier behaviour (even without\nthe patch this kind of stuff is very liable to leak but as you can see, this\npatch makes it much worse). Note that we have to sort types by their string\nrepresentation, because for each of these `..._with_category` types, the 5000 instances are in fact unique types with identical print names. So the memory load is even higher (types are fairly heavy data structures). As you can see, categories are eternal (they get cached) and since they store a reference to their base, they nail the base ring in memory too. We'll have to merge this ticket together with a ticket that moves base ring references out of the categories, since the constructions introduced in this ticket make the problem urgent.",
    "created_at": "2014-03-12T02:01:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109368",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:1'></a>
There are some performance and leaking issues with the proposed code here. They
have been mentioned before, but they got swamped in more theoretical design
discussions. Consider for instance with sage 6.2.beta4:

```
sage: import gc
sage: from collections import Counter
sage: before={id(c) for c in gc.get_objects()}
sage: %time for n in [1..5000]: x=(matrix(Integers(n),2,2,1))
CPU times: user 2.81 s, sys: 21 ms, total: 2.83 s
Wall time: 2.83 s
sage: gc.collect()
8373
sage: gc.collect()
918
sage: after=[c for c in gc.get_objects() if id(c) not in before]
sage: [c for c in Counter([str(type(a)) for a in after]).items() if c[1] > 4000]
[]
```
and with the patch:

```
sage: import gc
sage: from collections import Counter
sage: before={id(c) for c in gc.get_objects()}
sage: %time for n in [1..5000]: x=(matrix(Integers(n),2,2,1))
CPU times: user 13.1 s, sys: 131 ms, total: 13.2 s
Wall time: 13.3 s
sage: gc.collect()
1480
sage: gc.collect()
0
sage: after=[c for c in gc.get_objects() if id(c) not in before]
sage: [c for c in Counter([str(type(a)) for a in after]).items() if c[1] > 4000]
[("<class 'sage.categories.algebras.Algebras_with_category'>", 5000),
 ("<class 'weakref.KeyedRef'>", 85682),
 ("<type 'weakref'>", 65846),
 ("<type 'sage.structure.coerce_dict.TripleDict'>", 10001),
 ("<type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>", 40677),
 ("<type 'function'>", 37336),
 ("<type 'tuple'>", 326404),
 ("<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>", 5000),
 ("<class 'sage.categories.magmatic_algebras.MagmaticAlgebras_with_category'>", 5000),
 ("<type 'sage.misc.cachefunc.CachedMethodCaller'>", 30002),
 ("<class 'sage.categories.bimodules.Bimodules_with_category'>", 5000),
 ("<type 'builtin_function_or_method'>", 30173),
 ("<class 'sage.rings.ideal.Ideal_pid'>", 5000),
 ("<class 'sage.categories.homset.Homset_with_category'>", 5000),
 ("<type 'dict'>", 111638),
 ("<class 'sage.categories.left_modules.LeftModules_with_category'>", 5000),
 ("<type 'cell'>", 71409),
 ("<class 'sage.categories.right_modules.RightModules_with_category'>", 5000),
 ("<type 'sage.structure.coerce_dict.MonoDictEraser'>", 20003),
 ("<type 'list'>", 101980),
 ("<class 'sage.structure.dynamic_class.DynamicClasscallMetaclass'>", 35672),
 ("<type 'sage.structure.coerce_dict.TripleDictEraser'>", 10001),
 ("<type 'instancemethod'>", 10021),
 ("<type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>", 138253),
 ("<class 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic_with_category'>", 5000),
 ("<type 'sage.structure.coerce_dict.MonoDict'>", 20003),
 ("<type 'staticmethod'>", 35734),
 ("<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>", 5000),
 ("<type 'frozenset'>", 30671),
 ("<class 'sage.categories.associative_algebras.AssociativeAlgebras_with_category'>", 5000),
 ("<class 'sage.categories.modules.Modules_with_category'>", 5000)]
```
As you can see, much slower execution and much leakier behaviour (even without
the patch this kind of stuff is very liable to leak but as you can see, this
patch makes it much worse). Note that we have to sort types by their string
representation, because for each of these `..._with_category` types, the 5000 instances are in fact unique types with identical print names. So the memory load is even higher (types are fairly heavy data structures). As you can see, categories are eternal (they get cached) and since they store a reference to their base, they nail the base ring in memory too. We'll have to merge this ticket together with a ticket that moves base ring references out of the categories, since the constructions introduced in this ticket make the problem urgent.



---

archive/issue_comments_109369.json:
```json
{
    "body": "<a id='comment:572'></a>\nThanks a lot for the explanations. I'll reply in more detail once I've taken some more stabs at the doctest failure (high chances that it can be fixed simply and in a separate ticket). Did you push your changes? I don't see anything new. (Yes, pushing the doc higher up sounds like a good idea, and is what I should have done. No, I'm not fixing docs of concrete categories systematically; I just stumbled across these two and had to look up Wikipedia to understand whether it's Semigroup or Monoid that has the unity.)\n\nReplying to [nthiery](#comment%3A569):\n> Proofreading the documentation is an important piece of the review!\n> And being in the target audience you are specifically fit for it. So\n> thanks a lot!\n\nYou're welcome -- I'll need this ticket eventually.\n\n> > - What do you do if you have a subcategory A of a category B, but the notion of quotient objects in A is *NOT* a particular case (potentially with some extra structure) of the notion of quotient objects in B ? (I don't have any nice examples, but it's very easy to come up with examples for the similar notions of \"equalizer\", \"coproduct\" etc.) Am I allowed to override the `quotient` method on A? Can I expect that it will end up being always used on objects of A and never used on objects of B?\n\n> \n> Not sure what you mean. I guess that would be easier to discuss on a\n> concrete example.\n\nI'll try to think of an example with quotients (that does not involve schemes...). For direct products, for example the direct product of two groups in the category of groups is their free product ( http://en.wikipedia.org/wiki/Free_product ), while the direct product of two abelian groups in the category of abelian groups is their cartesian product. If you have two abelian groups A and B, their direct product as groups is not the same as their direct product as monoids, not even as a monoid!\n\n> > - primer.py around line 890:\n> > \n> > ```\n> > This implementation specifies a data structure for the parents and the\n> > elements, and makes a promise: the implemented parent is a\n> > semigroup. Then it fulfills the promise by implementing the basic\n> > operations ``product`` and ``semigroup_generators``. In exchange for\n> > ```\n> > What promise does `semigroup_generators` fulfill? Why should a semigroup always come with such a method? Isn't `__contains__` more of a necessity?\n\n> \n> It's a finite semigroup (the \"finite\" was missing above; I just added\n> it and will push later on). So implementing the product and the\n> semigroup generators is one of the ways to define everything. Another\n> way would indeed be to provide `__contains__`.\n\nOK, but is this necessary? What exactly is the promise that is being fulfilled?\n\n> It's appropriate to check that they are indeed in `self`, typically\n> using `self.is_parent_of(a)`, and raise a value error otherwise.\n\nAha, thanks.\n\n> > - These TODOs, particularly the first one, might be helpful to fill out:\n> > \n> > ```\n> > .. TODO::\n> > \n> >     - Specifying the category of a parent\n> >     - Adding code to an existing parent\n> > ```\n> > Particularly the first one sounds very important.\n\n> \n> Definitely. But there is already enough on the plate for this ticket!\n\nI know -- but it is hard to review something without understanding more fundamental things!\n\n> > - The primer mentions `Sets().Algebras(QQ)` as an example. What exactly does this mean? The repr string (\"Category of set algebras over Rational Field\") isn't very helpful,\n\n> \n> Agreed. The \"right\" piece of documentation is in\n> sage.categories.algebra_functor.AlgebrasCategory. This documentation\n> should really be in Sets().Algebras but this is unrelated to this\n> ticket and should be fixed elsewhere. Feel free to open a ticket!\n\nI don't understand. My original point was that these algebras appear as examples in the doc of the categories framework, and needlessly confusing examples should be removed/replaced. But now I've gotten really curious what a set algebra is! I assume the lack of doc is a good reason to open a new ticket, but what exactly should I suggest in that ticket?\n\n> Well, you actually can provide documentation for them. But in most\n> case it would be extremely redundant to have to do it, so we should be\n> thinking about ways this documentation could be constructed\n> automatically.\n\nYes, this really might be a task for a later patch.\n\n> > - The notions of \"subcategory\" and \"full subcategory\" used in the\n> > primer (and probably in the rest of the doc?) conflict with\n> > mathematics.  A subcategory in accordance with mathematical notation\n> > cannot have any extra structure unless it is predetermined by its\n> > existence (like inverses in groups). If you want to keep to this\n> > usage of the notion in Sage, PLEASE HEAVILY DOCUMENT IT.\n\n> \n> Really? I used those definitions from http://en.wikipedia.org/wiki/Subcategory:\n> \n> ``In mathematics, a subcategory of a category C is a category S whose\n> objects are objects in C and whose morphisms are morphisms in C with\n> the same identities and composition of morphisms''\n\nThe problem is that \"whose objects are objects in C\" is meant literally here, not in the sense of \"whose objects have a C-structure (among other data)\". A graded algebra is a graded module, but it also carries a multiplicative structure. This would not be possible if the category of graded algebras were a subcategory of the category of graded modules. (When you look at the \"formal definition\" on wikipedia, it says that \"A subcategory S of C is given by\n\n* a subcollection of objects of C, denoted ob(S),\n* a subcollection of morphisms of C, denoted hom(S)\"\n\nsatisfying several axioms. This does not leave any space for additional structure on the objects.)\n\n> ``A full subcategory is one that includes all morphisms between objects of S''\n> \n> > For example, this (line 1236) is mathematically false:\n> > \n> > ```\n> >     sage: Algebras(QQ).FiniteDimensional().is_subcategory( Modules(QQ).FiniteDimensional() )\n> >     True\n> > ```\n\n> \n> According to the above definitions, this is definitely not a full\n> subcategory, but it is a subcategory.\n\nIt is not, for the same reason that graded algebras don't form a subcategory of graded modules.\n\n(By the way, if you don't require algebras to have a unity, then graded modules can be regarded as a subcategory of graded algebras! Just consider every graded module as a graded algebra with multiplication being identically 0. And this is in fact a full subcategory, because any morphism of graded modules preserves this stupid multiplication.)\n\n> > The claim that all subcategories are automatically full (line 1100) is also mistaken; if it is supposed to mean that Sage only knows how to deal with full subcategories (i.e., if I define a subcategory, then Sage will automatically regard any morphism of the big category as a morphism of the small one), then again THIS SHOULD BE DOCUMENTED.\n\n> \n> The claim on line 1100 is only about subcategories defined by an\n> axiom. Those are full subcategories.\n\nUnital magmas are not a full subcategory of magmas! A morphism of unital magmas is not any arbitrary morphism of magmas, but a morphism of magmas that preserves the unity. I've seen textbooks getting this wrong, so I'm not surprised here, but please fix this before it can cause damage to Sage.\n\nThat said, why the focus on full subcategories? Fullness is a property of morphisms, and as far as I know morphisms have not been used very often in Sage so far (and there are issues like #15381 that make their use dangerous). Do you have any applications in mind for full subcategories as opposed to any subcategories?\n\n> > - Curious question: Is there any connection between the AdditiveAssociative and Associative axioms? I.e., does the former profit from methods bound to the latter in any way? Whether yes or not, this might use a brief mention in the doc.\n\n> \n> No, alas no. The hierarchies for additive XXX and for multiplicative\n> XXX are completely independent of each other. That's very annoying,\n> because this means everything is duplicated.\n\nThat's fine, just please add a sentence about this. A good place seems to be after line 1142 which says half of it. Generally, are the names of the operators in axioms hardcoded? If so, that would be good to point out lest the reader expect more polymorphism than is there.\n\n> What's really important is that you provide at least all the immediate\n> super categories, which already requires some care when inserting new\n> categories.\n> \n> Now, I agree with you that it would be better if the system did not\n> mind if there occasionally were non immediate super categories\n> too. This actually probably is already the case, but I would want to\n> triple check the code before I relax this specification. In fact, we\n> already are already massaging the super_categories by sorting them; it\n> could make sense to remove duplicates at the same occasion, but I am\n> not sure about the overhead. Since this specification precedes this\n> ticket, that's anyway for latter.\n\nHmm. Should I open a new ticket for this?\n\n> Together with the documentation of `Category`, I believe yes!  But\n> please make up your own mind.\n\nNice! (I probably can't make up my own mind about this, since reading the whole source is over my head.)\n\nBest regards,\nDarij",
    "created_at": "2014-03-12T02:03:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109369",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:572'></a>
Thanks a lot for the explanations. I'll reply in more detail once I've taken some more stabs at the doctest failure (high chances that it can be fixed simply and in a separate ticket). Did you push your changes? I don't see anything new. (Yes, pushing the doc higher up sounds like a good idea, and is what I should have done. No, I'm not fixing docs of concrete categories systematically; I just stumbled across these two and had to look up Wikipedia to understand whether it's Semigroup or Monoid that has the unity.)

Replying to [nthiery](#comment%3A569):
> Proofreading the documentation is an important piece of the review!
> And being in the target audience you are specifically fit for it. So
> thanks a lot!

You're welcome -- I'll need this ticket eventually.

> > - What do you do if you have a subcategory A of a category B, but the notion of quotient objects in A is *NOT* a particular case (potentially with some extra structure) of the notion of quotient objects in B ? (I don't have any nice examples, but it's very easy to come up with examples for the similar notions of "equalizer", "coproduct" etc.) Am I allowed to override the `quotient` method on A? Can I expect that it will end up being always used on objects of A and never used on objects of B?

> 
> Not sure what you mean. I guess that would be easier to discuss on a
> concrete example.

I'll try to think of an example with quotients (that does not involve schemes...). For direct products, for example the direct product of two groups in the category of groups is their free product ( http://en.wikipedia.org/wiki/Free_product ), while the direct product of two abelian groups in the category of abelian groups is their cartesian product. If you have two abelian groups A and B, their direct product as groups is not the same as their direct product as monoids, not even as a monoid!

> > - primer.py around line 890:
> > 
> > ```
> > This implementation specifies a data structure for the parents and the
> > elements, and makes a promise: the implemented parent is a
> > semigroup. Then it fulfills the promise by implementing the basic
> > operations ``product`` and ``semigroup_generators``. In exchange for
> > ```
> > What promise does `semigroup_generators` fulfill? Why should a semigroup always come with such a method? Isn't `__contains__` more of a necessity?

> 
> It's a finite semigroup (the "finite" was missing above; I just added
> it and will push later on). So implementing the product and the
> semigroup generators is one of the ways to define everything. Another
> way would indeed be to provide `__contains__`.

OK, but is this necessary? What exactly is the promise that is being fulfilled?

> It's appropriate to check that they are indeed in `self`, typically
> using `self.is_parent_of(a)`, and raise a value error otherwise.

Aha, thanks.

> > - These TODOs, particularly the first one, might be helpful to fill out:
> > 
> > ```
> > .. TODO::
> > 
> >     - Specifying the category of a parent
> >     - Adding code to an existing parent
> > ```
> > Particularly the first one sounds very important.

> 
> Definitely. But there is already enough on the plate for this ticket!

I know -- but it is hard to review something without understanding more fundamental things!

> > - The primer mentions `Sets().Algebras(QQ)` as an example. What exactly does this mean? The repr string ("Category of set algebras over Rational Field") isn't very helpful,

> 
> Agreed. The "right" piece of documentation is in
> sage.categories.algebra_functor.AlgebrasCategory. This documentation
> should really be in Sets().Algebras but this is unrelated to this
> ticket and should be fixed elsewhere. Feel free to open a ticket!

I don't understand. My original point was that these algebras appear as examples in the doc of the categories framework, and needlessly confusing examples should be removed/replaced. But now I've gotten really curious what a set algebra is! I assume the lack of doc is a good reason to open a new ticket, but what exactly should I suggest in that ticket?

> Well, you actually can provide documentation for them. But in most
> case it would be extremely redundant to have to do it, so we should be
> thinking about ways this documentation could be constructed
> automatically.

Yes, this really might be a task for a later patch.

> > - The notions of "subcategory" and "full subcategory" used in the
> > primer (and probably in the rest of the doc?) conflict with
> > mathematics.  A subcategory in accordance with mathematical notation
> > cannot have any extra structure unless it is predetermined by its
> > existence (like inverses in groups). If you want to keep to this
> > usage of the notion in Sage, PLEASE HEAVILY DOCUMENT IT.

> 
> Really? I used those definitions from http://en.wikipedia.org/wiki/Subcategory:
> 
> ``In mathematics, a subcategory of a category C is a category S whose
> objects are objects in C and whose morphisms are morphisms in C with
> the same identities and composition of morphisms''

The problem is that "whose objects are objects in C" is meant literally here, not in the sense of "whose objects have a C-structure (among other data)". A graded algebra is a graded module, but it also carries a multiplicative structure. This would not be possible if the category of graded algebras were a subcategory of the category of graded modules. (When you look at the "formal definition" on wikipedia, it says that "A subcategory S of C is given by

* a subcollection of objects of C, denoted ob(S),
* a subcollection of morphisms of C, denoted hom(S)"

satisfying several axioms. This does not leave any space for additional structure on the objects.)

> ``A full subcategory is one that includes all morphisms between objects of S''
> 
> > For example, this (line 1236) is mathematically false:
> > 
> > ```
> >     sage: Algebras(QQ).FiniteDimensional().is_subcategory( Modules(QQ).FiniteDimensional() )
> >     True
> > ```

> 
> According to the above definitions, this is definitely not a full
> subcategory, but it is a subcategory.

It is not, for the same reason that graded algebras don't form a subcategory of graded modules.

(By the way, if you don't require algebras to have a unity, then graded modules can be regarded as a subcategory of graded algebras! Just consider every graded module as a graded algebra with multiplication being identically 0. And this is in fact a full subcategory, because any morphism of graded modules preserves this stupid multiplication.)

> > The claim that all subcategories are automatically full (line 1100) is also mistaken; if it is supposed to mean that Sage only knows how to deal with full subcategories (i.e., if I define a subcategory, then Sage will automatically regard any morphism of the big category as a morphism of the small one), then again THIS SHOULD BE DOCUMENTED.

> 
> The claim on line 1100 is only about subcategories defined by an
> axiom. Those are full subcategories.

Unital magmas are not a full subcategory of magmas! A morphism of unital magmas is not any arbitrary morphism of magmas, but a morphism of magmas that preserves the unity. I've seen textbooks getting this wrong, so I'm not surprised here, but please fix this before it can cause damage to Sage.

That said, why the focus on full subcategories? Fullness is a property of morphisms, and as far as I know morphisms have not been used very often in Sage so far (and there are issues like #15381 that make their use dangerous). Do you have any applications in mind for full subcategories as opposed to any subcategories?

> > - Curious question: Is there any connection between the AdditiveAssociative and Associative axioms? I.e., does the former profit from methods bound to the latter in any way? Whether yes or not, this might use a brief mention in the doc.

> 
> No, alas no. The hierarchies for additive XXX and for multiplicative
> XXX are completely independent of each other. That's very annoying,
> because this means everything is duplicated.

That's fine, just please add a sentence about this. A good place seems to be after line 1142 which says half of it. Generally, are the names of the operators in axioms hardcoded? If so, that would be good to point out lest the reader expect more polymorphism than is there.

> What's really important is that you provide at least all the immediate
> super categories, which already requires some care when inserting new
> categories.
> 
> Now, I agree with you that it would be better if the system did not
> mind if there occasionally were non immediate super categories
> too. This actually probably is already the case, but I would want to
> triple check the code before I relax this specification. In fact, we
> already are already massaging the super_categories by sorting them; it
> could make sense to remove duplicates at the same occasion, but I am
> not sure about the overhead. Since this specification precedes this
> ticket, that's anyway for latter.

Hmm. Should I open a new ticket for this?

> Together with the documentation of `Category`, I believe yes!  But
> please make up your own mind.

Nice! (I probably can't make up my own mind about this, since reading the whole source is over my head.)

Best regards,
Darij



---

archive/issue_comments_109370.json:
```json
{
    "body": "<a id='comment:573'></a>\nReplying to [nthiery](#comment%3A569):\n> > What promise does `semigroup_generators` fulfill? Why should a semigroup always come with such a method? Isn't `__contains__` more of a necessity?\n\n> \n> It's a finite semigroup (the \"finite\" was missing above; I just added\n> it and will push later on). So implementing the product and the\n> semigroup generators is one of the ways to define everything. Another\n> way would indeed be to provide `__contains__`.\n\n`__contains__` is implemented by `sage.structure.parent.Parent`. Hence, provided that we all want to derive our parent classes from Parent so that we also inherit the coercion system, `__contains__` isn't a problem.\n\n> It's appropriate to check that they are indeed in `self`, typically\n> using `self.is_parent_of(a)`, and raise a value error otherwise.\n\nAhaha. So, this is all not connected with Sage's coercion system? Bad.\n\nFirst of all, why do you write `self.is_parent_of(a)`? Shouldn't it be `a.parent() is self`? If `.is_parent_of()` is implemented in a Python fail, then the latter idiom should also be faster.\n\nAnd secondly, why would it *not* send all arguments to the given parent first? That's what we do in the default `__call__` method of morphisms, too.\n\n> I know of no computer algebra system that has a good solution for\n> this, and any great idea to tackle this is more than welcome.\n\nThat's something that I brought up before. We have categories with axiom, but we should also have \"category with structure\" (that's a bad wording): Some categories merely define operators. E.g., Sets() defines the `in` operator, (multiplicative) Magmas() defines `*`, and `AdditiveMagmas()` defines `+`. Each axiom is formulated in terms of these operators, and in particular, each axiom requires some operators being present. E.g., `Distributive` requires that we are in a sub-category of `Magmas()&AdditiveMagmas()`.\n\nSo, in the example you mention (\"code duplication of `Magmas().Associative()` and `AdditiveMagmas().Associative()`\"), one could make it so that\n- we have `Magmas(operator.mul)` and `Magmas(operator.add)` (the latter replacing `AdditiveMagmas`), and\n- the `Associative` axiom by default applies to *the* operator of a category (provided there is only one), respectively has an optional argument naming the operator in question. Say, we would have `(Magmas(operator.mul)&Magmas(operator.add)).Associative(operator.add)` being the same as `Magmas(operator.mul)&Magmas(operator.add).Associative()`.\n\nAnd since the choice of an operator is arbitrary/generic, we could avoid some code duplication.\n\nBest regards,\nSimon",
    "created_at": "2014-03-12T07:54:52Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109370",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:573'></a>
Replying to [nthiery](#comment%3A569):
> > What promise does `semigroup_generators` fulfill? Why should a semigroup always come with such a method? Isn't `__contains__` more of a necessity?

> 
> It's a finite semigroup (the "finite" was missing above; I just added
> it and will push later on). So implementing the product and the
> semigroup generators is one of the ways to define everything. Another
> way would indeed be to provide `__contains__`.

`__contains__` is implemented by `sage.structure.parent.Parent`. Hence, provided that we all want to derive our parent classes from Parent so that we also inherit the coercion system, `__contains__` isn't a problem.

> It's appropriate to check that they are indeed in `self`, typically
> using `self.is_parent_of(a)`, and raise a value error otherwise.

Ahaha. So, this is all not connected with Sage's coercion system? Bad.

First of all, why do you write `self.is_parent_of(a)`? Shouldn't it be `a.parent() is self`? If `.is_parent_of()` is implemented in a Python fail, then the latter idiom should also be faster.

And secondly, why would it *not* send all arguments to the given parent first? That's what we do in the default `__call__` method of morphisms, too.

> I know of no computer algebra system that has a good solution for
> this, and any great idea to tackle this is more than welcome.

That's something that I brought up before. We have categories with axiom, but we should also have "category with structure" (that's a bad wording): Some categories merely define operators. E.g., Sets() defines the `in` operator, (multiplicative) Magmas() defines `*`, and `AdditiveMagmas()` defines `+`. Each axiom is formulated in terms of these operators, and in particular, each axiom requires some operators being present. E.g., `Distributive` requires that we are in a sub-category of `Magmas()&AdditiveMagmas()`.

So, in the example you mention ("code duplication of `Magmas().Associative()` and `AdditiveMagmas().Associative()`"), one could make it so that
- we have `Magmas(operator.mul)` and `Magmas(operator.add)` (the latter replacing `AdditiveMagmas`), and
- the `Associative` axiom by default applies to *the* operator of a category (provided there is only one), respectively has an optional argument naming the operator in question. Say, we would have `(Magmas(operator.mul)&Magmas(operator.add)).Associative(operator.add)` being the same as `Magmas(operator.mul)&Magmas(operator.add).Associative()`.

And since the choice of an operator is arbitrary/generic, we could avoid some code duplication.

Best regards,
Simon



---

archive/issue_comments_109371.json:
```json
{
    "body": "<a id='comment:574'></a>\nReplying to [nbruin](#comment%3A571):\n> There are some performance and leaking issues with the proposed code here. They\n> have been mentioned before, but they got swamped in more theoretical design\n> discussions. Consider for instance with sage 6.2.beta4:\n> \n> ```\n> ...\n> ```\n> As you can see, much slower execution and much leakier behaviour (even without\n> the patch this kind of stuff is very liable to leak but as you can see, this\n> patch makes it much worse). Note that we have to sort types by their string\n> representation, because for each of these `..._with_category` types, the 5000 instances are in fact unique types with identical print names. So the memory load is even higher (types are fairly heavy data structures). As you can see, categories are eternal (they get cached) and since they store a reference to their base, they nail the base ring in memory too. We'll have to merge this ticket together with a ticket that moves base ring references out of the categories, since the constructions introduced in this ticket make the problem urgent.\n\nThanks much for the specific data and setup code to construct it.\n\nYes, this is #15801 which we discussed earlier here and that I\nmentioned in the post on sage-devel. The fix is straightforward: move\naway from what was done in Axiom,MuPAD,... (it does not scale) and\nhave those categories be indexed by the category of the base ring, not\nthe base ring itself. The only thing is that this will probably\nrequire updating a bunch of doctests here and there, so I'd rather\nimplement #15801 once this ticket is merged or at the very least\nguaranteed to be final so as not to have to spend a lot of time\nresolving conflicts.\n\nCheers,\n                           Nicolas",
    "created_at": "2014-03-12T08:14:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109371",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:574'></a>
Replying to [nbruin](#comment%3A571):
> There are some performance and leaking issues with the proposed code here. They
> have been mentioned before, but they got swamped in more theoretical design
> discussions. Consider for instance with sage 6.2.beta4:
> 
> ```
> ...
> ```
> As you can see, much slower execution and much leakier behaviour (even without
> the patch this kind of stuff is very liable to leak but as you can see, this
> patch makes it much worse). Note that we have to sort types by their string
> representation, because for each of these `..._with_category` types, the 5000 instances are in fact unique types with identical print names. So the memory load is even higher (types are fairly heavy data structures). As you can see, categories are eternal (they get cached) and since they store a reference to their base, they nail the base ring in memory too. We'll have to merge this ticket together with a ticket that moves base ring references out of the categories, since the constructions introduced in this ticket make the problem urgent.

Thanks much for the specific data and setup code to construct it.

Yes, this is #15801 which we discussed earlier here and that I
mentioned in the post on sage-devel. The fix is straightforward: move
away from what was done in Axiom,MuPAD,... (it does not scale) and
have those categories be indexed by the category of the base ring, not
the base ring itself. The only thing is that this will probably
require updating a bunch of doctests here and there, so I'd rather
implement #15801 once this ticket is merged or at the very least
guaranteed to be final so as not to have to spend a lot of time
resolving conflicts.

Cheers,
                           Nicolas



---

archive/issue_comments_109372.json:
```json
{
    "body": "<a id='comment:575'></a>\nReplying to [SimonKing](#comment%3A573):\n> `__contains__` is implemented by `sage.structure.parent.Parent`. Hence, provided that we all want to derive our parent classes from Parent so that we also inherit the coercion system, `__contains__` isn't a problem.\n\nRight, though the `__contains__` from Parent does nothing but delegate\nto the constructor. If you want, for example, to test whether a given\nmatrix belongs to a matrix group, you need to implement that\nsomewhere.\n\n> > It's appropriate to check that they are indeed in `self`, typically\n> > using `self.is_parent_of(a)`, and raise a value error otherwise.\n\n> \n> First of all, why do you write `self.is_parent_of(a)`? Shouldn't it be `a.parent() is self`? If `.is_parent_of()` is implemented in a Python fail, then the latter idiom should also be faster.\n\nThe main point of is_parent_of is that it can be made to work\nuniformly whether self is a facade or not. It certainly should be\nCythonized, advertized, ...\n\n> Ahaha. So, this is all not connected with Sage's coercion system? Bad.\n> ...\n> And secondly, why would it *not* send all arguments to the given parent first? That's what we do in the default `__call__` method of morphisms, too.\n\nFor morphisms, which know explicitly about their domain and codomain,\nthis can be fine, in particular because the handling of the coercion\nis done once for all morphisms. But when implementing a Python method,\nI am strongly in favor, from experience with trying both, of not\nhaving coercions:\n\n- It gives more responsibility to the method implementer.\n- Mistakes can go unnoticed because the system will have found some\n  way to do some coercion.\n\n> > I know of no computer algebra system that has a good solution for\n> > this, and any great idea to tackle this is more than welcome.\n\n> \n> That's something that I brought up before.\n\nMe too ...\n\n> We have categories with axiom, but we should also have \"category with structure\" (that's a bad wording): Some categories merely define operators. E.g., Sets() defines the `in` operator, (multiplicative) Magmas() defines `*`, and `AdditiveMagmas()` defines `+`. Each axiom is formulated in terms of these operators, and in particular, each axiom requires some operators being present. E.g., `Distributive` requires that we are in a sub-category of `Magmas()&AdditiveMagmas()`.\n\n> So, in the example you mention (\"code duplication of `Magmas().Associative()` and `AdditiveMagmas().Associative()`\"), one could make it so that\n> - we have `Magmas(operator.mul)` and `Magmas(operator.add)` (the latter replacing `AdditiveMagmas`), and\n> - the `Associative` axiom by default applies to *the* operator of a category (provided there is only one), respectively has an optional argument naming the operator in question. Say, we would have `(Magmas(operator.mul)&Magmas(operator.add)).Associative(operator.add)` being the same as `Magmas(operator.mul)&Magmas(operator.add).Associative()`.\n> \n> And since the choice of an operator is arbitrary/generic, we could avoid some code duplication.\n\nThe difficulty is that this is not only about a single operator /\nmethod. But a bunch of them: in one case '+,-,zero,sum,...' in the\nother '*,/,one,prod,factor,...'. Sharing something between the two\nhierarchies of categories is only really useful if you can write\ngeneric code that applies in both situation; for that you need somehow\nto plug the right operations in the right spots in the code. That's\nkind of what we are doing manually for e.g. cayley_graph, but doing\nthis systematically is a different beast from what we have been doing\nso far with just usual inheritance.\n\nAnyway, discussion to be moved to a different ticket.\n\nCheers,\n                            Nicolas",
    "created_at": "2014-03-12T08:44:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109372",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:575'></a>
Replying to [SimonKing](#comment%3A573):
> `__contains__` is implemented by `sage.structure.parent.Parent`. Hence, provided that we all want to derive our parent classes from Parent so that we also inherit the coercion system, `__contains__` isn't a problem.

Right, though the `__contains__` from Parent does nothing but delegate
to the constructor. If you want, for example, to test whether a given
matrix belongs to a matrix group, you need to implement that
somewhere.

> > It's appropriate to check that they are indeed in `self`, typically
> > using `self.is_parent_of(a)`, and raise a value error otherwise.

> 
> First of all, why do you write `self.is_parent_of(a)`? Shouldn't it be `a.parent() is self`? If `.is_parent_of()` is implemented in a Python fail, then the latter idiom should also be faster.

The main point of is_parent_of is that it can be made to work
uniformly whether self is a facade or not. It certainly should be
Cythonized, advertized, ...

> Ahaha. So, this is all not connected with Sage's coercion system? Bad.
> ...
> And secondly, why would it *not* send all arguments to the given parent first? That's what we do in the default `__call__` method of morphisms, too.

For morphisms, which know explicitly about their domain and codomain,
this can be fine, in particular because the handling of the coercion
is done once for all morphisms. But when implementing a Python method,
I am strongly in favor, from experience with trying both, of not
having coercions:

- It gives more responsibility to the method implementer.
- Mistakes can go unnoticed because the system will have found some
  way to do some coercion.

> > I know of no computer algebra system that has a good solution for
> > this, and any great idea to tackle this is more than welcome.

> 
> That's something that I brought up before.

Me too ...

> We have categories with axiom, but we should also have "category with structure" (that's a bad wording): Some categories merely define operators. E.g., Sets() defines the `in` operator, (multiplicative) Magmas() defines `*`, and `AdditiveMagmas()` defines `+`. Each axiom is formulated in terms of these operators, and in particular, each axiom requires some operators being present. E.g., `Distributive` requires that we are in a sub-category of `Magmas()&AdditiveMagmas()`.

> So, in the example you mention ("code duplication of `Magmas().Associative()` and `AdditiveMagmas().Associative()`"), one could make it so that
> - we have `Magmas(operator.mul)` and `Magmas(operator.add)` (the latter replacing `AdditiveMagmas`), and
> - the `Associative` axiom by default applies to *the* operator of a category (provided there is only one), respectively has an optional argument naming the operator in question. Say, we would have `(Magmas(operator.mul)&Magmas(operator.add)).Associative(operator.add)` being the same as `Magmas(operator.mul)&Magmas(operator.add).Associative()`.
> 
> And since the choice of an operator is arbitrary/generic, we could avoid some code duplication.

The difficulty is that this is not only about a single operator /
method. But a bunch of them: in one case '+,-,zero,sum,...' in the
other '*,/,one,prod,factor,...'. Sharing something between the two
hierarchies of categories is only really useful if you can write
generic code that applies in both situation; for that you need somehow
to plug the right operations in the right spots in the code. That's
kind of what we are doing manually for e.g. cayley_graph, but doing
this systematically is a different beast from what we have been doing
so far with just usual inheritance.

Anyway, discussion to be moved to a different ticket.

Cheers,
                            Nicolas



---

archive/issue_comments_109373.json:
```json
{
    "body": "<a id='comment:576'></a>\nReplying to [darij](#comment%3A566):\n> Part 2: the beginning of `sage/categories/category_with_axiom.py`.\n> \n> - I don't understand this:\n> \n> ```\n>     - From an object oriented point of view, any subcategory ``Cs()``\n>       of :class:`~sage.categories.sets_cat.Sets` inherits from a ``Finite`` method, and ``Cs``\n>       can complement this method with extra data (here a mixin class)\n>       in the form of a class attribute ``Cs.Finite``.\n> ```\n> \"inherits from\" should be \"inherits\", right?\n\nYes.\n\n> What does \"extra data (here a mixin class)\" mean? Should a class attribute (not a class method) really override a method? Or does \"class attribute\" mean \"class method\" here? And what does this paragraph actually say? That I can override any method from a higher-up category? Isn't that clear anyway?\n\nOk, let me try a variant:\n\n```\n     - From an object oriented point of view, any subcategory ``Cs()``\n       of :class:`~sage.categories.sets_cat.Sets` inherits a\n       ``Finite`` method.  To complement this method, ``Cs`` would\n       usually override it with a method ``Cs.Finite`` which would\n       make a super call to ``Sets.Finite``, and then do extra stuff.\n\n       In the case at hand, ``Cs`` also wants to complement\n       ``Sets.Finite``, though not by doing more stuff, but by\n       providing it with an additional mixin class containing the code\n       for finite Cs. To keep the analogy, this mixin class is to be\n       put in ``Cs.Finite``.\n```\n\n> - This reads weird:\n> \n> ```\n>     This is undoubtedly a code smell. Nethertheless it should be kept as\n>     is, first to resolve the import order properly, and more\n>     importantly as a reminder that the category would be best not\n>     constructed upon Sage's startup. This to entice developpers to\n>     reduce the number of parents (and therefore categories) that are\n>     constructed upon startup. Each \"at_startup=True\" that will be\n>     removed will be a measure of progress in this direction.\n> ```\n> \"it should be kept as is\" probably was intended to mean that the warnings at startup time should be preserved, not that the lazy import at startup time should be preserved.\n\nYes!\n\n> I don't understand the use of \"entice\" in this paragraph.\n\nI was looking for something stronger than \"encourage\" ...\n\n> - I don't understand this:\n> \n> ```\n> .. NOTE::\n> \n>     In principle, due to a limitation of :class:`LazyImport` with\n>     nested classes (see :trac:`15648`), one should pass the option\n>     ``as_name`` to :class:`LazyImport`::\n> \n>         Finite = LazyImport('sage.categories.finite_groups', 'FiniteGroups', as_name='Finite')\n> \n>     in order to prevent ``Groups.Finite`` to keep on reimporting\n>     ``FiniteGroups``.\n> \n>     Given that passing this option introduces some redundancy and is\n>     error prone, the axiom infrastructure includes a little workaround\n>     which makes the ``as_name`` unnecessary in this case.\n> ```\n> But it sounds like something that can eventually bite me in the ass. Can I have some more detail?\n\nYes, in general you need to be careful when using LazyImport for\nnested classes. See #15648. If that nested class implements an axiom,\nyou are safe though.\n\n\n> - Line 251:\n> \n> ```\n> We don't recommend using this syntax which may eventually be\n> deprecated.\n> ```\n> What syntax? `Algebras.WithBasis(QQ)`?\n\nYes.\n\n> What is the general pattern here (other than \"declaration of base needlessly delayed\")?\n\nIt's more like that there already is a syntax for this, namely\nAlgebras(QQ).WithBasis(), and that syntax bears nicely a meaning:\nAmong the QQ-algebras, give me those with a basis. Whereas the meaning\nof Algebras.WithBasis(QQ) is not so clear; first because the class\nAlgebras (not the object Algebras()) does not really model anything;\nsecond because the syntax suggests that you are doing two unrelated\nthings at the same time: asking for the algebras endowed with a\ndistinguished basis, and asking for those with QQ as base ring.\n\n\n> - My 2 cents on one of the pain-in-the-ass issues: I do *not* oppose the syntax-based guessing of base category class and axiom, as long as it is used as a last resort and can always be manually overridden if it turns out to be less than smart. After all, am I seeing it right that if it *does* return a guess, the guess is guaranteed to be correct (`assert getattr(base_category_class, axiom, None) is cls`)?\n\nThat's right!\n\n> If this is indeed the case, you should proudly point this out in the documentation, because \"heuristic\" and \"guesses\" are words that make people like myself very scared. (Also, maybe add some instructions for users of categories on how to add doctests that verify that it is successful at guessing?)\n\nGood point. I'll do that now!\n\n> - Why talk of arborescences rather than just rooted trees? Do you want to stress a poset/digraph structure?\n\nWell it used to be rooted trees (actually rooted forests). But Nathann\nasked for arborescences :-)\n\n> - Wait...\n> \n> ```\n> For example, the fact that a cartesian product of associative magmas\n> (i.e. of semigroups) is associative\n> ```\n> Really? Isn't that the typical associativity-up-to-equivalence situation where the equivalence can usually be ignored in proofs but comes back with a vengeance if taken too lightly in code? Specifically, is ((1,2),3) == (1,(2,3)) ?\n\nHere we are not speaking about the associativity of the cartesian\nproduct, but the associativity of the componentwise * operation.\n\n\nFor all of the above: I would very much appreciate if you could use my\nanswers (assuming they indeed clarified the confusion) to rephrase the\ndocumentation as you see fit. Indeed, as a reader, you have a much\nbetter idea on how it's perceived, and what needs to be fixed to avoid\nthe confusion in the first place.\n\nThanks!\n\t\t\tNicolas",
    "created_at": "2014-03-12T09:19:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109373",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:576'></a>
Replying to [darij](#comment%3A566):
> Part 2: the beginning of `sage/categories/category_with_axiom.py`.
> 
> - I don't understand this:
> 
> ```
>     - From an object oriented point of view, any subcategory ``Cs()``
>       of :class:`~sage.categories.sets_cat.Sets` inherits from a ``Finite`` method, and ``Cs``
>       can complement this method with extra data (here a mixin class)
>       in the form of a class attribute ``Cs.Finite``.
> ```
> "inherits from" should be "inherits", right?

Yes.

> What does "extra data (here a mixin class)" mean? Should a class attribute (not a class method) really override a method? Or does "class attribute" mean "class method" here? And what does this paragraph actually say? That I can override any method from a higher-up category? Isn't that clear anyway?

Ok, let me try a variant:

```
     - From an object oriented point of view, any subcategory ``Cs()``
       of :class:`~sage.categories.sets_cat.Sets` inherits a
       ``Finite`` method.  To complement this method, ``Cs`` would
       usually override it with a method ``Cs.Finite`` which would
       make a super call to ``Sets.Finite``, and then do extra stuff.

       In the case at hand, ``Cs`` also wants to complement
       ``Sets.Finite``, though not by doing more stuff, but by
       providing it with an additional mixin class containing the code
       for finite Cs. To keep the analogy, this mixin class is to be
       put in ``Cs.Finite``.
```

> - This reads weird:
> 
> ```
>     This is undoubtedly a code smell. Nethertheless it should be kept as
>     is, first to resolve the import order properly, and more
>     importantly as a reminder that the category would be best not
>     constructed upon Sage's startup. This to entice developpers to
>     reduce the number of parents (and therefore categories) that are
>     constructed upon startup. Each "at_startup=True" that will be
>     removed will be a measure of progress in this direction.
> ```
> "it should be kept as is" probably was intended to mean that the warnings at startup time should be preserved, not that the lazy import at startup time should be preserved.

Yes!

> I don't understand the use of "entice" in this paragraph.

I was looking for something stronger than "encourage" ...

> - I don't understand this:
> 
> ```
> .. NOTE::
> 
>     In principle, due to a limitation of :class:`LazyImport` with
>     nested classes (see :trac:`15648`), one should pass the option
>     ``as_name`` to :class:`LazyImport`::
> 
>         Finite = LazyImport('sage.categories.finite_groups', 'FiniteGroups', as_name='Finite')
> 
>     in order to prevent ``Groups.Finite`` to keep on reimporting
>     ``FiniteGroups``.
> 
>     Given that passing this option introduces some redundancy and is
>     error prone, the axiom infrastructure includes a little workaround
>     which makes the ``as_name`` unnecessary in this case.
> ```
> But it sounds like something that can eventually bite me in the ass. Can I have some more detail?

Yes, in general you need to be careful when using LazyImport for
nested classes. See #15648. If that nested class implements an axiom,
you are safe though.


> - Line 251:
> 
> ```
> We don't recommend using this syntax which may eventually be
> deprecated.
> ```
> What syntax? `Algebras.WithBasis(QQ)`?

Yes.

> What is the general pattern here (other than "declaration of base needlessly delayed")?

It's more like that there already is a syntax for this, namely
Algebras(QQ).WithBasis(), and that syntax bears nicely a meaning:
Among the QQ-algebras, give me those with a basis. Whereas the meaning
of Algebras.WithBasis(QQ) is not so clear; first because the class
Algebras (not the object Algebras()) does not really model anything;
second because the syntax suggests that you are doing two unrelated
things at the same time: asking for the algebras endowed with a
distinguished basis, and asking for those with QQ as base ring.


> - My 2 cents on one of the pain-in-the-ass issues: I do *not* oppose the syntax-based guessing of base category class and axiom, as long as it is used as a last resort and can always be manually overridden if it turns out to be less than smart. After all, am I seeing it right that if it *does* return a guess, the guess is guaranteed to be correct (`assert getattr(base_category_class, axiom, None) is cls`)?

That's right!

> If this is indeed the case, you should proudly point this out in the documentation, because "heuristic" and "guesses" are words that make people like myself very scared. (Also, maybe add some instructions for users of categories on how to add doctests that verify that it is successful at guessing?)

Good point. I'll do that now!

> - Why talk of arborescences rather than just rooted trees? Do you want to stress a poset/digraph structure?

Well it used to be rooted trees (actually rooted forests). But Nathann
asked for arborescences :-)

> - Wait...
> 
> ```
> For example, the fact that a cartesian product of associative magmas
> (i.e. of semigroups) is associative
> ```
> Really? Isn't that the typical associativity-up-to-equivalence situation where the equivalence can usually be ignored in proofs but comes back with a vengeance if taken too lightly in code? Specifically, is ((1,2),3) == (1,(2,3)) ?

Here we are not speaking about the associativity of the cartesian
product, but the associativity of the componentwise * operation.


For all of the above: I would very much appreciate if you could use my
answers (assuming they indeed clarified the confusion) to rephrase the
documentation as you see fit. Indeed, as a reader, you have a much
better idea on how it's perceived, and what needs to be fixed to avoid
the confusion in the first place.

Thanks!
			Nicolas



---

archive/issue_comments_109374.json:
```json
{
    "body": "<a id='comment:577'></a>\n> Well it used to be rooted trees (actually rooted forests). But Nathann\n> asked for arborescences :-)\n\nAhahah. I asked for a great many things which will not be taken into account, but I do not care much about that. In graph theory it would be (sligthly) incorrect, but in this context honestly there is no problem with \"trees\". The fact that it disturbs people is a proof, and I don't think many graph guys will read this doc anyway `:-P`\n\nNathann",
    "created_at": "2014-03-12T09:46:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109374",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:577'></a>
> Well it used to be rooted trees (actually rooted forests). But Nathann
> asked for arborescences :-)

Ahahah. I asked for a great many things which will not be taken into account, but I do not care much about that. In graph theory it would be (sligthly) incorrect, but in this context honestly there is no problem with "trees". The fact that it disturbs people is a proof, and I don't think many graph guys will read this doc anyway `:-P`

Nathann



---

archive/issue_comments_109375.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1eee7a4e133c94514a006b2462a6c5624e5ce7c4\">1eee7a4</a></td><td><code>Axioms: proofread Darij's review changes, and explain why finite semigroups are currently enumerated sets</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2fc85e467d744fc7519a1b3080f94a55b5d20899\">2fc85e4</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into categories/axioms-10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/16d530dfc1838a6b497afac03e1e2b13be24795d\">16d530d</a></td><td><code>Axioms: implement Darij's suggestion; base_category_class does a deduction attempt, not a guessing</code></td></tr></table>\n",
    "created_at": "2014-03-12T14:36:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109375",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1eee7a4e133c94514a006b2462a6c5624e5ce7c4">1eee7a4</a></td><td><code>Axioms: proofread Darij's review changes, and explain why finite semigroups are currently enumerated sets</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2fc85e467d744fc7519a1b3080f94a55b5d20899">2fc85e4</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into categories/axioms-10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/16d530dfc1838a6b497afac03e1e2b13be24795d">16d530d</a></td><td><code>Axioms: implement Darij's suggestion; base_category_class does a deduction attempt, not a guessing</code></td></tr></table>




---

archive/issue_comments_109376.json:
```json
{
    "body": "**Changing commit** from \"[1cdc128a85851dd007b3b77ec53a4853a10e1de4](https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4)\" to \"[16d530dfc1838a6b497afac03e1e2b13be24795d](https://github.com/sagemath/sagetrac-mirror/commit/16d530dfc1838a6b497afac03e1e2b13be24795d)\".",
    "created_at": "2014-03-12T14:36:01Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109376",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1cdc128a85851dd007b3b77ec53a4853a10e1de4](https://github.com/sagemath/sagetrac-mirror/commit/1cdc128a85851dd007b3b77ec53a4853a10e1de4)" to "[16d530dfc1838a6b497afac03e1e2b13be24795d](https://github.com/sagemath/sagetrac-mirror/commit/16d530dfc1838a6b497afac03e1e2b13be24795d)".



---

archive/issue_comments_109377.json:
```json
{
    "body": "<a id='comment:579'></a>\nReplying to [nthiery](#comment%3A576):\n> > If this is indeed the case, you should proudly point this out in the documentation, because \"heuristic\" and \"guesses\" are words that make people like myself very scared. (Also, maybe add some instructions for users of categories on how to add doctests that verify that it is successful at guessing?)\n\n> \n> Good point. I'll do that now!\n\nActually you are really really right. The term \"guess\" was a terrible\nchoice, as it wrongly suggests that the result might be incorrect,\nwhen in fact it's either correct or an explicit error is raised. I\nshould have called this from the beginning a \"deduction attempt\".\nThis would probably have saved on a lot of discussions above.\n\nI updated the code and documentation accordingly, and pushed (together\nwith the other little change I had mentioned yesterday).\n\nThanks much for pointing this out!\n\n                                  Nicolas",
    "created_at": "2014-03-12T14:48:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109377",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:579'></a>
Replying to [nthiery](#comment%3A576):
> > If this is indeed the case, you should proudly point this out in the documentation, because "heuristic" and "guesses" are words that make people like myself very scared. (Also, maybe add some instructions for users of categories on how to add doctests that verify that it is successful at guessing?)

> 
> Good point. I'll do that now!

Actually you are really really right. The term "guess" was a terrible
choice, as it wrongly suggests that the result might be incorrect,
when in fact it's either correct or an explicit error is raised. I
should have called this from the beginning a "deduction attempt".
This would probably have saved on a lot of discussions above.

I updated the code and documentation accordingly, and pushed (together
with the other little change I had mentioned yesterday).

Thanks much for pointing this out!

                                  Nicolas



---

archive/issue_comments_109378.json:
```json
{
    "body": "<a id='comment:580'></a>\n****Replying to [ncohen](#comment%3A577):\n> Ahahah. I asked for a great many things which will not be taken into account,\n\nI actually did take quite a few of your suggestions into account when\nI worked on the primer, in particular about adding appropriate cross\nlinks :-)\n\n> but I do not care much about that. In graph theory it would be (sligthly) incorrect, but in this context honestly there is no problem with \"trees\". The fact that it disturbs people is a proof, and I don't think many graph guys will read this doc anyway `:-P`\n\nI have no preference on that matter. Opinions anyone?\n\nCheers,\n                                 Nicolas",
    "created_at": "2014-03-12T14:51:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109378",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:580'></a>
****Replying to [ncohen](#comment%3A577):
> Ahahah. I asked for a great many things which will not be taken into account,

I actually did take quite a few of your suggestions into account when
I worked on the primer, in particular about adding appropriate cross
links :-)

> but I do not care much about that. In graph theory it would be (sligthly) incorrect, but in this context honestly there is no problem with "trees". The fact that it disturbs people is a proof, and I don't think many graph guys will read this doc anyway `:-P`

I have no preference on that matter. Opinions anyone?

Cheers,
                                 Nicolas



---

archive/issue_comments_109379.json:
```json
{
    "body": "<a id='comment:1'></a>\nThanks for the changes, Nicolas! I'll return to work on them when I'm back to Boston. I see what you meant by saying that semigroups generators need to provided now. Your \u200b1eee7a4 and 16d530d changes look fine to me. I'm not sure what exactly was merged in 2fc85e4; were we having two #10963 branches all along?\n\nWhat was the reason to change \"tree\" to \"arborescence\"? (The only places where I've ever read about arborescences were using that notion to clarify that the roots are \"on top\". But what is \"top\" here?)",
    "created_at": "2014-03-12T14:55:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109379",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:1'></a>
Thanks for the changes, Nicolas! I'll return to work on them when I'm back to Boston. I see what you meant by saying that semigroups generators need to provided now. Your ​1eee7a4 and 16d530d changes look fine to me. I'm not sure what exactly was merged in 2fc85e4; were we having two #10963 branches all along?

What was the reason to change "tree" to "arborescence"? (The only places where I've ever read about arborescences were using that notion to clarify that the roots are "on top". But what is "top" here?)



---

archive/issue_comments_109380.json:
```json
{
    "body": "<a id='comment:582'></a>\nReplying to [nthiery](#comment%3A574):\n> require updating a bunch of doctests here and there, so I'd rather\n> implement #15801 once this ticket is merged or at the very least\n> guaranteed to be final so as not to have to spend a lot of time\n> resolving conflicts.\n\nThe sounds sensible. It will have to be the latter, since the kind of leak that presently gets reintroduced will kill a bunch of multimodular linear algebra methods over QQ and ZZ (among others, the default implementation for finding the kernel of a not-very-small matrix over QQ)",
    "created_at": "2014-03-12T14:57:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109380",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:582'></a>
Replying to [nthiery](#comment%3A574):
> require updating a bunch of doctests here and there, so I'd rather
> implement #15801 once this ticket is merged or at the very least
> guaranteed to be final so as not to have to spend a lot of time
> resolving conflicts.

The sounds sensible. It will have to be the latter, since the kind of leak that presently gets reintroduced will kill a bunch of multimodular linear algebra methods over QQ and ZZ (among others, the default implementation for finding the kernel of a not-very-small matrix over QQ)



---

archive/issue_comments_109381.json:
```json
{
    "body": "**Work Issues:** merge with #15801 once things stabilize",
    "created_at": "2014-03-12T14:57:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109381",
    "user": "https://github.com/nbruin"
}
```

**Work Issues:** merge with #15801 once things stabilize



---

archive/issue_comments_109382.json:
```json
{
    "body": "<a id='comment:3'></a>\nIn other news, I'm still trying to understand why `Sets().Algebras(QQ)` needs to make sense. This here is seriously weird:\n\n```\nsage: Sets().example()\nSet of prime numbers (basic implementation)\nsage: Sets().example().algebra(QQ)\nFree module generated by Set of prime numbers (basic implementation) over Rational Field\nsage: Sets().example().algebra(QQ) in Algebras(QQ)\nFalse\nsage: Sets().example().algebra(QQ) in Sets().Algebras(QQ)\nTrue\n```\n\nIs it possible that \"set algebra\" is just a misnomer for \"set module\" (free module of a set)? I'm *not* asking you to change this; but it really needs to be documented both in the primer and at module level.",
    "created_at": "2014-03-12T15:41:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109382",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:3'></a>
In other news, I'm still trying to understand why `Sets().Algebras(QQ)` needs to make sense. This here is seriously weird:

```
sage: Sets().example()
Set of prime numbers (basic implementation)
sage: Sets().example().algebra(QQ)
Free module generated by Set of prime numbers (basic implementation) over Rational Field
sage: Sets().example().algebra(QQ) in Algebras(QQ)
False
sage: Sets().example().algebra(QQ) in Sets().Algebras(QQ)
True
```

Is it possible that "set algebra" is just a misnomer for "set module" (free module of a set)? I'm *not* asking you to change this; but it really needs to be documented both in the primer and at module level.



---

archive/issue_comments_109383.json:
```json
{
    "body": "<a id='comment:4'></a>\nCould this be the problem ?\n\n```\nsage: Sets().Algebras(QQ).is_subcategory(Algebras(QQ))\nFalse\n```\n\nNathann",
    "created_at": "2014-03-12T15:50:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109383",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:4'></a>
Could this be the problem ?

```
sage: Sets().Algebras(QQ).is_subcategory(Algebras(QQ))
False
```

Nathann



---

archive/issue_comments_109384.json:
```json
{
    "body": "<a id='comment:585'></a>\nReplying to [darij](#comment%3A583):\n> In other news, I'm still trying to understand why `Sets().Algebras(QQ)` needs to make sense. This here is seriously weird:\n> \n> ```\n> sage: Sets().example()\n> Set of prime numbers (basic implementation)\n> sage: Sets().example().algebra(QQ)\n> Free module generated by Set of prime numbers (basic implementation) over Rational Field\n> sage: Sets().example().algebra(QQ) in Algebras(QQ)\n> False\n> sage: Sets().example().algebra(QQ) in Sets().Algebras(QQ)\n> True\n> ```\n> \n> Is it possible that \"set algebra\" is just a misnomer for \"set module\" (free module of a set)? I'm *not* asking you to change this; but it really needs to be documented both in the primer and at module level.\n\nThe above results are correct but, as you point out, the name\n\"algebra\" is certainly a misnomer.\n\nIn general, if S is a parent and F a field, S.algebra(F) constructs\nthe F-free module FS with basis indexed by S, endowed with whatever\nstructure can be induced from that of S. Typically, if S is a\nmagma/monoid/group, you get the magma/monoid/group algebra. For a\ngroup, it actually gives a Hopf algebra. Same thing for additive\nmagmas/monoids/groups. With #14102, if S is a root lattice, the action\nof the Weyl group and the like get lifted to FS too.\n\nIn other words, in most practical use cases, you indeed get an\nalgebra; actually \"the algebra\"; hence the name. But I agree that in\nthe other cases the name is misleading. Still we need a uniform name,\nand so far nobody came up with something better ...\n\nIn the mean time, I am all for improving the documentation of the\nalgebra method of parents and Algebras methods of the\ncategories. Should I just throw in the above paragraphs there?\n\nThis probably does not need to be discussed in the primer though,\ngiven that it barely mentions the algebra construction.\n\nCheers,\n                               Nicolas",
    "created_at": "2014-03-12T21:23:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109384",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:585'></a>
Replying to [darij](#comment%3A583):
> In other news, I'm still trying to understand why `Sets().Algebras(QQ)` needs to make sense. This here is seriously weird:
> 
> ```
> sage: Sets().example()
> Set of prime numbers (basic implementation)
> sage: Sets().example().algebra(QQ)
> Free module generated by Set of prime numbers (basic implementation) over Rational Field
> sage: Sets().example().algebra(QQ) in Algebras(QQ)
> False
> sage: Sets().example().algebra(QQ) in Sets().Algebras(QQ)
> True
> ```
> 
> Is it possible that "set algebra" is just a misnomer for "set module" (free module of a set)? I'm *not* asking you to change this; but it really needs to be documented both in the primer and at module level.

The above results are correct but, as you point out, the name
"algebra" is certainly a misnomer.

In general, if S is a parent and F a field, S.algebra(F) constructs
the F-free module FS with basis indexed by S, endowed with whatever
structure can be induced from that of S. Typically, if S is a
magma/monoid/group, you get the magma/monoid/group algebra. For a
group, it actually gives a Hopf algebra. Same thing for additive
magmas/monoids/groups. With #14102, if S is a root lattice, the action
of the Weyl group and the like get lifted to FS too.

In other words, in most practical use cases, you indeed get an
algebra; actually "the algebra"; hence the name. But I agree that in
the other cases the name is misleading. Still we need a uniform name,
and so far nobody came up with something better ...

In the mean time, I am all for improving the documentation of the
algebra method of parents and Algebras methods of the
categories. Should I just throw in the above paragraphs there?

This probably does not need to be discussed in the primer though,
given that it barely mentions the algebra construction.

Cheers,
                               Nicolas



---

archive/issue_comments_109385.json:
```json
{
    "body": "<a id='comment:6'></a>\nYes, please add these explanations to the doc, and replace the `Sets().Algebras()` example in the primer by (say) `Monoids().Algebras()`. Thank you!\n\nIn other news, here is some stuff from pyflakes:\n\n```\nsrc/sage/categories/groups.py:530: 'Algebras' imported but unused\nsrc/sage/categories/weyl_groups.py:101: 'sage' imported but unused\nsrc/sage/categories/pushout.py:5: 'from basic import *' used; unable to detect undefined names\nsrc/sage/categories/pushout.py:1121: local variable 'OverlappingGens' is assigned to but never used\nsrc/sage/categories/pushout.py:1457: 'PolynomialRing' imported but unused\nsrc/sage/categories/pushout.py:2391: 'QQ' imported but unused\nsrc/sage/categories/graded_modules_with_basis.py:13: 'cached_method' imported but unused\nsrc/sage/categories/finite_enumerated_sets.py:503: '__builtin__' imported but unused\nsrc/sage/categories/discrete_valuation.py:18: 'Category' imported but unused\nsrc/sage/categories/__init__.py:29: 'primer' imported but unused\nsrc/sage/categories/euclidean_domains.py:11: 'Category' imported but unused\nsrc/sage/categories/euclidean_domains.py:14: 'cached_method' imported but unused\nsrc/sage/categories/category.py:110: 'sage' imported but unused\nsrc/sage/categories/rings.py:914: 'is_SymbolicVariable' imported but unused\nsrc/sage/categories/rings.py:925: local variable 'msg' is assigned to but never used\nsrc/sage/categories/distributive_magmas_and_additive_magmas.py:13: 'AdditiveMagmas' imported but unused\nsrc/sage/categories/distributive_magmas_and_additive_magmas.py:14: 'Magmas' imported but unused\n```\nNot all of these are bugs! (pyflakes isn't aware of things like lazy imports and classes used in eval statements etc.) But probably you know best which of these are actually unused, which ones are important, and which ones will be important soon.",
    "created_at": "2014-03-12T21:34:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109385",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:6'></a>
Yes, please add these explanations to the doc, and replace the `Sets().Algebras()` example in the primer by (say) `Monoids().Algebras()`. Thank you!

In other news, here is some stuff from pyflakes:

```
src/sage/categories/groups.py:530: 'Algebras' imported but unused
src/sage/categories/weyl_groups.py:101: 'sage' imported but unused
src/sage/categories/pushout.py:5: 'from basic import *' used; unable to detect undefined names
src/sage/categories/pushout.py:1121: local variable 'OverlappingGens' is assigned to but never used
src/sage/categories/pushout.py:1457: 'PolynomialRing' imported but unused
src/sage/categories/pushout.py:2391: 'QQ' imported but unused
src/sage/categories/graded_modules_with_basis.py:13: 'cached_method' imported but unused
src/sage/categories/finite_enumerated_sets.py:503: '__builtin__' imported but unused
src/sage/categories/discrete_valuation.py:18: 'Category' imported but unused
src/sage/categories/__init__.py:29: 'primer' imported but unused
src/sage/categories/euclidean_domains.py:11: 'Category' imported but unused
src/sage/categories/euclidean_domains.py:14: 'cached_method' imported but unused
src/sage/categories/category.py:110: 'sage' imported but unused
src/sage/categories/rings.py:914: 'is_SymbolicVariable' imported but unused
src/sage/categories/rings.py:925: local variable 'msg' is assigned to but never used
src/sage/categories/distributive_magmas_and_additive_magmas.py:13: 'AdditiveMagmas' imported but unused
src/sage/categories/distributive_magmas_and_additive_magmas.py:14: 'Magmas' imported but unused
```
Not all of these are bugs! (pyflakes isn't aware of things like lazy imports and classes used in eval statements etc.) But probably you know best which of these are actually unused, which ones are important, and which ones will be important soon.



---

archive/issue_comments_109386.json:
```json
{
    "body": "<a id='comment:587'></a>\nReplying to [nthiery](#comment%3A585):\n> In general, if S is a parent and F a field, S.algebra(F) constructs\n> the F-free module FS with basis indexed by S, endowed with whatever\n> structure can be induced from that of S. Typically, if S is a\n> magma/monoid/group, you get the magma/monoid/group algebra. For a\n> group, it actually gives a Hopf algebra.\n\nDoesn't that mean you construct a free F-module that happens to have some extra structure thanks to S? The free F-algebra indexed by S would seem to me to be the free F-module spanned by the free monoid on S. Hence, this \"associative algebra\" functor would belong on monoids, not on sets.\n\n> Same thing for additive magmas/monoids/groups.\n\nIs that the same thing? If S is an additive group and the addition induces the additive relations on the F-module generators, it seems to me you'd not get the free F-module FS. If S is a free abelian group on X, you'd get the free F-module FX.\n\n> With #14102, if S is a root lattice, the action\n> of the Weyl group and the like get lifted to FS too.\n\nNice! So in this case we have a free abelian group S with a W-action (a W-group, I guess) and the functor now gives us W-F-algebras. That makes perfect sense, but now we are working in yet another category (I don't think that in this case the term \"algebra\" will lead to confusion, because you're getting something with *more* structure, not less than the name suggests)\n\n> In other words, in most practical use cases, you indeed get an\n> algebra; actually \"the algebra\"; hence the name.\n\nNo, only when you do this with a monoid. (or a magma if you like your algebras non-associative)\n\n> Still we need a uniform name,\n\nI don't think you do. The construction is nice and functorial over multiplicative monoids (magmas if you want to treat associativity as an axiom).\n\nOutside monoids there is a construction that produces the same setwise result (the free F-module), but it's a functor into a different category.\n\nF-algebras do not form a full subcategory of F-modules, so treating the two functors as separate makes a lot of sense.\n\n(it doesn't have much to do with this ticket, though).",
    "created_at": "2014-03-12T22:39:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109386",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:587'></a>
Replying to [nthiery](#comment%3A585):
> In general, if S is a parent and F a field, S.algebra(F) constructs
> the F-free module FS with basis indexed by S, endowed with whatever
> structure can be induced from that of S. Typically, if S is a
> magma/monoid/group, you get the magma/monoid/group algebra. For a
> group, it actually gives a Hopf algebra.

Doesn't that mean you construct a free F-module that happens to have some extra structure thanks to S? The free F-algebra indexed by S would seem to me to be the free F-module spanned by the free monoid on S. Hence, this "associative algebra" functor would belong on monoids, not on sets.

> Same thing for additive magmas/monoids/groups.

Is that the same thing? If S is an additive group and the addition induces the additive relations on the F-module generators, it seems to me you'd not get the free F-module FS. If S is a free abelian group on X, you'd get the free F-module FX.

> With #14102, if S is a root lattice, the action
> of the Weyl group and the like get lifted to FS too.

Nice! So in this case we have a free abelian group S with a W-action (a W-group, I guess) and the functor now gives us W-F-algebras. That makes perfect sense, but now we are working in yet another category (I don't think that in this case the term "algebra" will lead to confusion, because you're getting something with *more* structure, not less than the name suggests)

> In other words, in most practical use cases, you indeed get an
> algebra; actually "the algebra"; hence the name.

No, only when you do this with a monoid. (or a magma if you like your algebras non-associative)

> Still we need a uniform name,

I don't think you do. The construction is nice and functorial over multiplicative monoids (magmas if you want to treat associativity as an axiom).

Outside monoids there is a construction that produces the same setwise result (the free F-module), but it's a functor into a different category.

F-algebras do not form a full subcategory of F-modules, so treating the two functors as separate makes a lot of sense.

(it doesn't have much to do with this ticket, though).



---

archive/issue_comments_109387.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8e83e4238ae83a829cbe1a1c4c4cfc5072224f72\">8e83e42</a></td><td><code>Axioms: primer: specifying the category of a parent and using it to add code + promise thingy</code></td></tr></table>\n",
    "created_at": "2014-03-12T22:44:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109387",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8e83e4238ae83a829cbe1a1c4c4cfc5072224f72">8e83e42</a></td><td><code>Axioms: primer: specifying the category of a parent and using it to add code + promise thingy</code></td></tr></table>




---

archive/issue_comments_109388.json:
```json
{
    "body": "**Changing commit** from \"[16d530dfc1838a6b497afac03e1e2b13be24795d](https://github.com/sagemath/sagetrac-mirror/commit/16d530dfc1838a6b497afac03e1e2b13be24795d)\" to \"[8e83e4238ae83a829cbe1a1c4c4cfc5072224f72](https://github.com/sagemath/sagetrac-mirror/commit/8e83e4238ae83a829cbe1a1c4c4cfc5072224f72)\".",
    "created_at": "2014-03-12T22:44:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109388",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[16d530dfc1838a6b497afac03e1e2b13be24795d](https://github.com/sagemath/sagetrac-mirror/commit/16d530dfc1838a6b497afac03e1e2b13be24795d)" to "[8e83e4238ae83a829cbe1a1c4c4cfc5072224f72](https://github.com/sagemath/sagetrac-mirror/commit/8e83e4238ae83a829cbe1a1c4c4cfc5072224f72)".



---

archive/issue_comments_109389.json:
```json
{
    "body": "<a id='comment:589'></a>\nReplying to [darij](#comment%3A572):\n> I'll try to think of an example with quotients (that does not involve schemes...). For direct products, for example the direct product of two groups in the category of groups is their free product ( http://en.wikipedia.org/wiki/Free_product ), while the direct product of two abelian groups in the category of abelian groups is their cartesian product. If you have two abelian groups A and B, their direct product as groups is not the same as their direct product as monoids, not even as a monoid!\n\nYes! That's precisely why there is basically nothing about \"direct products\" in\nthe category infrastructure: the fact that it's not covariant (aka\nuniform across categories) means there is nothing we can share\nautomatically. This is unlike cartesian products or quotients!\n\nJust to state the obvious about the covariance for quotients (or\nequivalently homomorphic images): take B a subcategory of A, and Y an\nhomomorphic image in B; since B-morphisms are A-morphisms, Y is also\nan homomorphic image in A).\n\n> > It's a finite semigroup (the \"finite\" was missing above; I just added\n> > it and will push later on). So implementing the product and the\n> > semigroup generators is one of the ways to define everything. Another\n> > way would indeed be to provide `__contains__`.\n\n> \n> OK, but is this necessary? What exactly is the promise that is being fulfilled?\n\nI tried to improve the phrasing. Please check.\n\n> I know -- but it is hard to review something without understanding more fundamental things!\n\nFair enough. Let it be Christmas! Done.\n\n> > > - The primer mentions `Sets().Algebras(QQ)` as an example. What exactly does this mean? The repr string (\"Category of set algebras over Rational Field\") isn't very helpful,\n\n> > \n> > Agreed. The \"right\" piece of documentation is in\n> > sage.categories.algebra_functor.AlgebrasCategory. This documentation\n> > should really be in Sets().Algebras but this is unrelated to this\n> > ticket and should be fixed elsewhere. Feel free to open a ticket!\n\n> \n> I don't understand. My original point was that these algebras appear as examples in the doc of the categories framework, and needlessly confusing examples should be removed/replaced. But now I've gotten really curious what a set algebra is! I assume the lack of doc is a good reason to open a new ticket, but what exactly should I suggest in that ticket?\n\nOh, I see your point now. Ok, that can be easily\nimproved. Done. Please check!\n\n> The problem is that \"whose objects are objects in C\" is meant literally here, not in the sense of \"whose objects have a C-structure (among other data)\". A graded algebra is a graded module, but it also carries a multiplicative structure. This would not be possible if the category of graded algebras were a subcategory of the category of graded modules. (When you look at the \"formal definition\" on wikipedia, it says that \"A subcategory S of C is given by\n> \n> * a subcollection of objects of C, denoted ob(S),\n> * a subcollection of morphisms of C, denoted hom(S)\"\n> \n> satisfying several axioms. This does not leave any space for additional structure on the objects.)\n\nAh, interesting, you are the first one to raise this point :-) So far,\nI was taking for granted that it was natural to consider the\nadditional structure as being \"encoded\" in the morphisms. Ok, we\nprobably need to clarify this, even though we are just following the\nterminology that is in use in other systems like Axiom, ...\n\n> That said, why the focus on full subcategories? Fullness is a property of morphisms, and as far as I know morphisms have not been used very often in Sage so far (and there are issues like #15381 that make their use dangerous). Do you have any applications in mind for full subcategories as opposed to any subcategories?\n\nYes indeed! One of the very next steps is precisely to improve the\nsupport for morphisms (see #10668). And without the full subcategory\nbusiness, there is not much homsets stuff to inherit and share between\ncategories.\n\n> Unital magmas are not a full subcategory of magmas! A morphism of unital magmas is not any arbitrary morphism of magmas, but a morphism of magmas that preserves the unity. I've seen textbooks getting this wrong, so I'm not surprised here, but please fix this before it can cause damage to Sage.\n\nAh right, I had thrown this under the carpet so far, but it probably\nneeds to be uncovered a bit.\n\nThe point is that often, in practice, what's useful in similar\nsituations is actually the full subcategory, even if mathematically\nspeaking the natural category is not the full one. For example, for\nModulesWithBasis (modules with a distinguished basis), we definitely\nwant to use the distinguished bases to compute with morphisms. But\nrestricting to morphisms that preserve the distinguished bases would\nbe really boring.\n\nI haven't made up my mind about the proper way to handle this; as you\nmention above this is currently rather harmless because there isn't\nthat much generic stuff for morphisms.\n\nBut I see your point; it's probably best to not get into the details\nuntil things are settled by just not using the \"full subcategory\"\nterminology; I have started doing this in the primer, and will have to\ncheck about this elsewhere.\n\n> That's fine, just please add a sentence about this. A good place seems to be after line 1142 which says half of it. Generally, are the names of the operators in axioms hardcoded? If so, that would be good to point out lest the reader expect more polymorphism than is there.\n\nDone. A full note actually, inspired by the discussion above. Please check.\n\n> Nice! (I probably can't make up my own mind about this, since reading the whole source is over my head.)\n\nJust to make sure: I just meant the main docstring of Category.\n\nThanks again for the useful discussion!\n\nCheers,\n                               Nicolas\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8e83e4238ae83a829cbe1a1c4c4cfc5072224f72\">8e83e42</a></td><td><code>Axioms: primer: specifying the category of a parent and using it to add code + promise thingy</code></td></tr></table>\n",
    "created_at": "2014-03-13T00:20:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109389",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:589'></a>
Replying to [darij](#comment%3A572):
> I'll try to think of an example with quotients (that does not involve schemes...). For direct products, for example the direct product of two groups in the category of groups is their free product ( http://en.wikipedia.org/wiki/Free_product ), while the direct product of two abelian groups in the category of abelian groups is their cartesian product. If you have two abelian groups A and B, their direct product as groups is not the same as their direct product as monoids, not even as a monoid!

Yes! That's precisely why there is basically nothing about "direct products" in
the category infrastructure: the fact that it's not covariant (aka
uniform across categories) means there is nothing we can share
automatically. This is unlike cartesian products or quotients!

Just to state the obvious about the covariance for quotients (or
equivalently homomorphic images): take B a subcategory of A, and Y an
homomorphic image in B; since B-morphisms are A-morphisms, Y is also
an homomorphic image in A).

> > It's a finite semigroup (the "finite" was missing above; I just added
> > it and will push later on). So implementing the product and the
> > semigroup generators is one of the ways to define everything. Another
> > way would indeed be to provide `__contains__`.

> 
> OK, but is this necessary? What exactly is the promise that is being fulfilled?

I tried to improve the phrasing. Please check.

> I know -- but it is hard to review something without understanding more fundamental things!

Fair enough. Let it be Christmas! Done.

> > > - The primer mentions `Sets().Algebras(QQ)` as an example. What exactly does this mean? The repr string ("Category of set algebras over Rational Field") isn't very helpful,

> > 
> > Agreed. The "right" piece of documentation is in
> > sage.categories.algebra_functor.AlgebrasCategory. This documentation
> > should really be in Sets().Algebras but this is unrelated to this
> > ticket and should be fixed elsewhere. Feel free to open a ticket!

> 
> I don't understand. My original point was that these algebras appear as examples in the doc of the categories framework, and needlessly confusing examples should be removed/replaced. But now I've gotten really curious what a set algebra is! I assume the lack of doc is a good reason to open a new ticket, but what exactly should I suggest in that ticket?

Oh, I see your point now. Ok, that can be easily
improved. Done. Please check!

> The problem is that "whose objects are objects in C" is meant literally here, not in the sense of "whose objects have a C-structure (among other data)". A graded algebra is a graded module, but it also carries a multiplicative structure. This would not be possible if the category of graded algebras were a subcategory of the category of graded modules. (When you look at the "formal definition" on wikipedia, it says that "A subcategory S of C is given by
> 
> * a subcollection of objects of C, denoted ob(S),
> * a subcollection of morphisms of C, denoted hom(S)"
> 
> satisfying several axioms. This does not leave any space for additional structure on the objects.)

Ah, interesting, you are the first one to raise this point :-) So far,
I was taking for granted that it was natural to consider the
additional structure as being "encoded" in the morphisms. Ok, we
probably need to clarify this, even though we are just following the
terminology that is in use in other systems like Axiom, ...

> That said, why the focus on full subcategories? Fullness is a property of morphisms, and as far as I know morphisms have not been used very often in Sage so far (and there are issues like #15381 that make their use dangerous). Do you have any applications in mind for full subcategories as opposed to any subcategories?

Yes indeed! One of the very next steps is precisely to improve the
support for morphisms (see #10668). And without the full subcategory
business, there is not much homsets stuff to inherit and share between
categories.

> Unital magmas are not a full subcategory of magmas! A morphism of unital magmas is not any arbitrary morphism of magmas, but a morphism of magmas that preserves the unity. I've seen textbooks getting this wrong, so I'm not surprised here, but please fix this before it can cause damage to Sage.

Ah right, I had thrown this under the carpet so far, but it probably
needs to be uncovered a bit.

The point is that often, in practice, what's useful in similar
situations is actually the full subcategory, even if mathematically
speaking the natural category is not the full one. For example, for
ModulesWithBasis (modules with a distinguished basis), we definitely
want to use the distinguished bases to compute with morphisms. But
restricting to morphisms that preserve the distinguished bases would
be really boring.

I haven't made up my mind about the proper way to handle this; as you
mention above this is currently rather harmless because there isn't
that much generic stuff for morphisms.

But I see your point; it's probably best to not get into the details
until things are settled by just not using the "full subcategory"
terminology; I have started doing this in the primer, and will have to
check about this elsewhere.

> That's fine, just please add a sentence about this. A good place seems to be after line 1142 which says half of it. Generally, are the names of the operators in axioms hardcoded? If so, that would be good to point out lest the reader expect more polymorphism than is there.

Done. A full note actually, inspired by the discussion above. Please check.

> Nice! (I probably can't make up my own mind about this, since reading the whole source is over my head.)

Just to make sure: I just meant the main docstring of Category.

Thanks again for the useful discussion!

Cheers,
                               Nicolas

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8e83e4238ae83a829cbe1a1c4c4cfc5072224f72">8e83e42</a></td><td><code>Axioms: primer: specifying the category of a parent and using it to add code + promise thingy</code></td></tr></table>




---

archive/issue_comments_109390.json:
```json
{
    "body": "**Changing commit** from \"[8e83e4238ae83a829cbe1a1c4c4cfc5072224f72](https://github.com/sagemath/sagetrac-mirror/commit/8e83e4238ae83a829cbe1a1c4c4cfc5072224f72)\" to \"[5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0](https://github.com/sagemath/sagetrac-mirror/commit/5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0)\".",
    "created_at": "2014-03-13T00:29:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109390",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[8e83e4238ae83a829cbe1a1c4c4cfc5072224f72](https://github.com/sagemath/sagetrac-mirror/commit/8e83e4238ae83a829cbe1a1c4c4cfc5072224f72)" to "[5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0](https://github.com/sagemath/sagetrac-mirror/commit/5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0)".



---

archive/issue_comments_109391.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0\">5ab0a43</a></td><td><code>Axioms: improvements to the primer and documentation following Darij's suggestions</code></td></tr></table>\n",
    "created_at": "2014-03-13T00:29:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109391",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0">5ab0a43</a></td><td><code>Axioms: improvements to the primer and documentation following Darij's suggestions</code></td></tr></table>




---

archive/issue_comments_109392.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d6a0e608f9b4b7023dd742a57e62486833b6fa97\">d6a0e60</a></td><td><code>Axioms: Fixed some unused imports in categories</code></td></tr></table>\n",
    "created_at": "2014-03-13T08:52:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109392",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d6a0e608f9b4b7023dd742a57e62486833b6fa97">d6a0e60</a></td><td><code>Axioms: Fixed some unused imports in categories</code></td></tr></table>




---

archive/issue_comments_109393.json:
```json
{
    "body": "**Changing commit** from \"[5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0](https://github.com/sagemath/sagetrac-mirror/commit/5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0)\" to \"[d6a0e608f9b4b7023dd742a57e62486833b6fa97](https://github.com/sagemath/sagetrac-mirror/commit/d6a0e608f9b4b7023dd742a57e62486833b6fa97)\".",
    "created_at": "2014-03-13T08:52:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109393",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0](https://github.com/sagemath/sagetrac-mirror/commit/5ab0a4317e9cf4aa2a2d08eec7240c30988eabd0)" to "[d6a0e608f9b4b7023dd742a57e62486833b6fa97](https://github.com/sagemath/sagetrac-mirror/commit/d6a0e608f9b4b7023dd742a57e62486833b6fa97)".



---

archive/issue_comments_109394.json:
```json
{
    "body": "<a id='comment:592'></a>\nReplying to [darij](#comment%3A586):\n> Yes, please add these explanations to the doc, and replace the `Sets().Algebras()` example in the primer by (say) `Monoids().Algebras()`. Thank you!\n\nDone.\n\n> In other news, here is some stuff from pyflakes:\n> ...\n\nThanks; I had not run pyflakes systematically in a while. I fixed\nthose in the files relevant to this ticket.",
    "created_at": "2014-03-13T08:54:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109394",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:592'></a>
Replying to [darij](#comment%3A586):
> Yes, please add these explanations to the doc, and replace the `Sets().Algebras()` example in the primer by (say) `Monoids().Algebras()`. Thank you!

Done.

> In other news, here is some stuff from pyflakes:
> ...

Thanks; I had not run pyflakes systematically in a while. I fixed
those in the files relevant to this ticket.



---

archive/issue_comments_109395.json:
```json
{
    "body": "<a id='comment:593'></a>\nReplying to [nbruin](#comment%3A587):\n> Doesn't that mean you construct a free F-module that happens to have some extra structure thanks to S?\n\nYes, to be precise, the free F-module FS whose basis is indexed by S\n(the linear span of S for short).\n\n> > Same thing for additive magmas/monoids/groups.\n\n> \n> Is that the same thing? If S is an additive group and the addition induces the additive relations on the F-module generators,\n\nIn this construction, the addition on S induces the *multiplication*\non FS. E.g., if S is an additive group, FS is the usual group algebra\nof S.\n\n> > In other words, in most practical use cases, you indeed get an\n> > algebra; actually \"the algebra\"; hence the name.\n\n> \n> No, only when you do this with a monoid. (or a magma if you like your algebras non-associative)\n\nOr even a partial magma :-) Those are not yet implement but we already\nhad the need for them!\n\nAnd of course, by the above, also partial additive magmas.\n\nThose two cases are the only ones where something non trivial is\nimplemented. So at this point the statement \"in most practical use\ncase\" definitely holds :-)\n\nBut upcoming use cases include:\n\n- \"combinatorial\" G-module structure on the linear span of a finite\n  set S endowed with the action of a group G (or semigroup, ...).\n\n- Module structure on the linear span of a crystal S\n\n- ...\n\n> > Still we need a uniform name,\n\n> \n> I don't think you do. The construction is nice and functorial over multiplicative monoids (magmas if you want to treat associativity as an axiom).\n> \n> Outside monoids there is a construction that produces the same setwise result (the free F-module), but it's a functor into a different category.\n> \n> F-algebras do not form a full subcategory of F-modules, so treating the two functors as separate makes a lot of sense.\n\nYes, like CartesianProducts, TensorProducts, and the like, it's indeed\nnot a functor, but a functorial construction (i.e. a collection of\nfunctors). By default, the functor associated to the category of the\nobject is applied, but you can specify which functor you want to apply\nby specifying the category.\n\n> (it doesn't have much to do with this ticket, though).\n\nYup.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-03-13T09:14:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109395",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:593'></a>
Replying to [nbruin](#comment%3A587):
> Doesn't that mean you construct a free F-module that happens to have some extra structure thanks to S?

Yes, to be precise, the free F-module FS whose basis is indexed by S
(the linear span of S for short).

> > Same thing for additive magmas/monoids/groups.

> 
> Is that the same thing? If S is an additive group and the addition induces the additive relations on the F-module generators,

In this construction, the addition on S induces the *multiplication*
on FS. E.g., if S is an additive group, FS is the usual group algebra
of S.

> > In other words, in most practical use cases, you indeed get an
> > algebra; actually "the algebra"; hence the name.

> 
> No, only when you do this with a monoid. (or a magma if you like your algebras non-associative)

Or even a partial magma :-) Those are not yet implement but we already
had the need for them!

And of course, by the above, also partial additive magmas.

Those two cases are the only ones where something non trivial is
implemented. So at this point the statement "in most practical use
case" definitely holds :-)

But upcoming use cases include:

- "combinatorial" G-module structure on the linear span of a finite
  set S endowed with the action of a group G (or semigroup, ...).

- Module structure on the linear span of a crystal S

- ...

> > Still we need a uniform name,

> 
> I don't think you do. The construction is nice and functorial over multiplicative monoids (magmas if you want to treat associativity as an axiom).
> 
> Outside monoids there is a construction that produces the same setwise result (the free F-module), but it's a functor into a different category.
> 
> F-algebras do not form a full subcategory of F-modules, so treating the two functors as separate makes a lot of sense.

Yes, like CartesianProducts, TensorProducts, and the like, it's indeed
not a functor, but a functorial construction (i.e. a collection of
functors). By default, the functor associated to the category of the
object is applied, but you can specify which functor you want to apply
by specifying the category.

> (it doesn't have much to do with this ticket, though).

Yup.

Cheers,
                              Nicolas



---

archive/issue_comments_109396.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/914d5f057996b982993ab54cb31819a53ac38faa\">914d5f0</a></td><td><code>Axioms: documentation: systematic check about full vs non full subcategories + minor improvements</code></td></tr></table>\n",
    "created_at": "2014-03-13T09:38:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109396",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/914d5f057996b982993ab54cb31819a53ac38faa">914d5f0</a></td><td><code>Axioms: documentation: systematic check about full vs non full subcategories + minor improvements</code></td></tr></table>




---

archive/issue_comments_109397.json:
```json
{
    "body": "**Changing commit** from \"[d6a0e608f9b4b7023dd742a57e62486833b6fa97](https://github.com/sagemath/sagetrac-mirror/commit/d6a0e608f9b4b7023dd742a57e62486833b6fa97)\" to \"[914d5f057996b982993ab54cb31819a53ac38faa](https://github.com/sagemath/sagetrac-mirror/commit/914d5f057996b982993ab54cb31819a53ac38faa)\".",
    "created_at": "2014-03-13T09:38:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109397",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[d6a0e608f9b4b7023dd742a57e62486833b6fa97](https://github.com/sagemath/sagetrac-mirror/commit/d6a0e608f9b4b7023dd742a57e62486833b6fa97)" to "[914d5f057996b982993ab54cb31819a53ac38faa](https://github.com/sagemath/sagetrac-mirror/commit/914d5f057996b982993ab54cb31819a53ac38faa)".



---

archive/issue_comments_109398.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #15919\".",
    "created_at": "2014-03-13T09:55:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109398",
    "user": "https://github.com/nthiery"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #15919".



---

archive/issue_events_085488.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2014-03-13T09:57:59Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "rename": {
        "from": "More functorial constructions",
        "to": "Axioms and more functorial constructions"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85488"
}
```



---

archive/issue_comments_109399.json:
```json
{
    "body": "**Changing commit** from \"[914d5f057996b982993ab54cb31819a53ac38faa](https://github.com/sagemath/sagetrac-mirror/commit/914d5f057996b982993ab54cb31819a53ac38faa)\" to \"[1afc63b0c30caf9553a367b1bb4a61b57be446c0](https://github.com/sagemath/sagetrac-mirror/commit/1afc63b0c30caf9553a367b1bb4a61b57be446c0)\".",
    "created_at": "2014-03-13T16:10:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109399",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[914d5f057996b982993ab54cb31819a53ac38faa](https://github.com/sagemath/sagetrac-mirror/commit/914d5f057996b982993ab54cb31819a53ac38faa)" to "[1afc63b0c30caf9553a367b1bb4a61b57be446c0](https://github.com/sagemath/sagetrac-mirror/commit/1afc63b0c30caf9553a367b1bb4a61b57be446c0)".



---

archive/issue_comments_109400.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1afc63b0c30caf9553a367b1bb4a61b57be446c0\">1afc63b</a></td><td><code>Axioms: fixed documentation compilation</code></td></tr></table>\n",
    "created_at": "2014-03-13T16:10:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109400",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1afc63b0c30caf9553a367b1bb4a61b57be446c0">1afc63b</a></td><td><code>Axioms: fixed documentation compilation</code></td></tr></table>




---

archive/issue_comments_109401.json:
```json
{
    "body": "<a id='comment:8'></a>\nThanks for the updates, Nicolas! With some belatement due to a cancelled flight and a flu, I'm resuming the \"review\" of the doc.",
    "created_at": "2014-03-16T17:47:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109401",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:8'></a>
Thanks for the updates, Nicolas! With some belatement due to a cancelled flight and a flu, I'm resuming the "review" of the doc.



---

archive/issue_comments_109402.json:
```json
{
    "body": "<a id='comment:9'></a>\nWhat does this mean? (sets_cat.py)\n\n```\n            Similarly, on , we obtain for additive magmas, monoids, groups.\n```",
    "created_at": "2014-03-16T20:10:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109402",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:9'></a>
What does this mean? (sets_cat.py)

```
            Similarly, on , we obtain for additive magmas, monoids, groups.
```



---

archive/issue_comments_109403.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a02ee1781e79c08b0c3c7551655cc7e51ff116bf\">a02ee17</a></td><td><code>some more changes to documentation -- please check (Cunningham's law)</code></td></tr></table>\n",
    "created_at": "2014-03-16T23:17:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109403",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a02ee1781e79c08b0c3c7551655cc7e51ff116bf">a02ee17</a></td><td><code>some more changes to documentation -- please check (Cunningham's law)</code></td></tr></table>




---

archive/issue_comments_109404.json:
```json
{
    "body": "**Changing commit** from \"[1afc63b0c30caf9553a367b1bb4a61b57be446c0](https://github.com/sagemath/sagetrac-mirror/commit/1afc63b0c30caf9553a367b1bb4a61b57be446c0)\" to \"[a02ee1781e79c08b0c3c7551655cc7e51ff116bf](https://github.com/sagemath/sagetrac-mirror/commit/a02ee1781e79c08b0c3c7551655cc7e51ff116bf)\".",
    "created_at": "2014-03-16T23:17:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109404",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1afc63b0c30caf9553a367b1bb4a61b57be446c0](https://github.com/sagemath/sagetrac-mirror/commit/1afc63b0c30caf9553a367b1bb4a61b57be446c0)" to "[a02ee1781e79c08b0c3c7551655cc7e51ff116bf](https://github.com/sagemath/sagetrac-mirror/commit/a02ee1781e79c08b0c3c7551655cc7e51ff116bf)".



---

archive/issue_comments_109405.json:
```json
{
    "body": "<a id='comment:1'></a>\nMade some edits (more are to follow). I'm unhappy with how I handled the \"code smell\" paragraph (but then again, I don't understand it very well myself), and am unsure if the \"extra data\" paragraph is now correct (please check!). Also, the `BrokenTestObjects` class seems to have neither docs nor doctests, so I'm wondering why it's there (if it is to illustrate something, please illustrate it rather than removing it!).",
    "created_at": "2014-03-16T23:20:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109405",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:1'></a>
Made some edits (more are to follow). I'm unhappy with how I handled the "code smell" paragraph (but then again, I don't understand it very well myself), and am unsure if the "extra data" paragraph is now correct (please check!). Also, the `BrokenTestObjects` class seems to have neither docs nor doctests, so I'm wondering why it's there (if it is to illustrate something, please illustrate it rather than removing it!).



---

archive/issue_comments_109406.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f2ceccfb4fbd4cea8daf58c3294af98133ba1b23\">f2ceccf</a></td><td><code>some possibly wrong comments on subcategories</code></td></tr></table>\n",
    "created_at": "2014-03-18T22:01:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109406",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f2ceccfb4fbd4cea8daf58c3294af98133ba1b23">f2ceccf</a></td><td><code>some possibly wrong comments on subcategories</code></td></tr></table>




---

archive/issue_comments_109407.json:
```json
{
    "body": "**Changing commit** from \"[a02ee1781e79c08b0c3c7551655cc7e51ff116bf](https://github.com/sagemath/sagetrac-mirror/commit/a02ee1781e79c08b0c3c7551655cc7e51ff116bf)\" to \"[f2ceccfb4fbd4cea8daf58c3294af98133ba1b23](https://github.com/sagemath/sagetrac-mirror/commit/f2ceccfb4fbd4cea8daf58c3294af98133ba1b23)\".",
    "created_at": "2014-03-18T22:01:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109407",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[a02ee1781e79c08b0c3c7551655cc7e51ff116bf](https://github.com/sagemath/sagetrac-mirror/commit/a02ee1781e79c08b0c3c7551655cc7e51ff116bf)" to "[f2ceccfb4fbd4cea8daf58c3294af98133ba1b23](https://github.com/sagemath/sagetrac-mirror/commit/f2ceccfb4fbd4cea8daf58c3294af98133ba1b23)".



---

archive/issue_comments_109408.json:
```json
{
    "body": "<a id='comment:603'></a>\nReplying to [nthiery](#comment%3A589):\n> Replying to [darij](#comment%3A572):\n> > I'll try to think of an example with quotients (that does not involve schemes...). For direct products, for example the direct product of two groups in the category of groups is their free product ( http://en.wikipedia.org/wiki/Free_product ), while the direct product of two abelian groups in the category of abelian groups is their cartesian product. If you have two abelian groups A and B, their direct product as groups is not the same as their direct product as monoids, not even as a monoid!\n\n> \n> Yes! That's precisely why there is basically nothing about \"direct products\" in\n> the category infrastructure: the fact that it's not covariant (aka\n> uniform across categories) means there is nothing we can share\n> automatically. This is unlike cartesian products or quotients!\n> \n> Just to state the obvious about the covariance for quotients (or\n> equivalently homomorphic images): take B a subcategory of A, and Y an\n> homomorphic image in B; since B-morphisms are A-morphisms, Y is also\n> an homomorphic image in A).\n\nOK, now I see what you mean by \"covariant\" :) The problem is that the quotient is a certain *universal* homomorphic image, and a quotient in B (despite still being a homomorphic image in A) will not always have this universality property in A.\n\nI'm still at a loss for a good counterexample; these are rare, but fundamentally there is no difference between quotients and direct products here: neither is more universal than the other. There are some easy counterexamples if your notion of a \"quotient\" includes coequalizers (not just cokernels, which are the narrowest reading of the word \"quotient\") and your notion of a \"subcategory\" is the wider sense in which you are using this word (i.e., rings form a subcategory of additive groups).\n\n```\nIndeed, take two ring homomorphisms from ZZ[x] to\nZZ[x,y], the first one sending x to x, the second\none sending x to y. Their coequalizer (roughly\nspeaking, \"ZZ[x,y] modulo identifying images under\nthe first homomorphism with corresponding images\nunder the second\") is\n\n- the additive group ZZ[x,y] modulo the additive\n  subgroup <x-y, x^2-y^2, x^3-y^3, ...>, if you\n  are working in the category of additive groups;\n\n- the ring ZZ[x,y] modulo the ideal generated by\n  x-y, x^2-y^2, x^3-y^3, ..., if you are working\n  in the category of rings.\n\nThe former is bigger than the latter, because e.g.\nthe difference x^2y^3-x^3y^2 is in the ideal but\nnot in the additive subgroup.\n```\n\nEDIT: For a counterexample that fits everyone's wishes, a friend of mine just reminded me that quotients of sheaves are not generally the same as quotients of sheaves when regarded as presheaves. See http://mathoverflow.net/questions/19119/why-must-one-sheafify-quotients-of-sheaves . Here, the quotient when constructed in A is not generally in B.\n\n> Fair enough. Let it be Christmas! Done.\n\nThanks a lot!\n\n> Oh, I see your point now. Ok, that can be easily\n> improved. Done. Please check!\n\nCleared up, thank you.\n\n> Ah, interesting, you are the first one to raise this point :-) So far,\n> I was taking for granted that it was natural to consider the\n> additional structure as being \"encoded\" in the morphisms. Ok, we\n> probably need to clarify this, even though we are just following the\n> terminology that is in use in other systems like Axiom, ...\n\nI fear this will come up in practice a lot, e.g., when you consider Lie algebras which have a grading and a filtration, and the filtration is *not* the one you would get from the grading. (These appear everywhere.) So I'm not very happy to have \"graded Xes\" as a subcategory of \"Xes\"...\n\nAnyway I've added some doc now. Is it on the right track?\n\n> Yes indeed! One of the very next steps is precisely to improve the\n> support for morphisms (see #10668). And without the full subcategory\n> business, there is not much homsets stuff to inherit and share between\n> categories.\n\nWell... any operation on the homset of a big category is also an operation on the homset of any subcategory, if \"subcategory\" is understood in the mathematical sense. Maybe by saying \"full subcategory\" you really mean \"subcategory in the mathematical sense\", i.e. subcategory without additional data?\n\n> The point is that often, in practice, what's useful in similar\n> situations is actually the full subcategory, even if mathematically\n> speaking the natural category is not the full one. For example, for\n> ModulesWithBasis (modules with a distinguished basis), we definitely\n> want to use the distinguished bases to compute with morphisms. But\n> restricting to morphisms that preserve the distinguished bases would\n> be really boring.\n\nGood point -- this is probably the right statement to make about full subcategories.\n\n> Done. A full note actually, inspired by the discussion above. Please check.\n\nWell explained. (No, I'm not saying this is something that needs to be fixed; only documented. I don't see much of an advantage in having operation-polymorphic axioms.)\n\nBest regards,\\\\\nDarij",
    "created_at": "2014-03-18T22:41:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109408",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:603'></a>
Replying to [nthiery](#comment%3A589):
> Replying to [darij](#comment%3A572):
> > I'll try to think of an example with quotients (that does not involve schemes...). For direct products, for example the direct product of two groups in the category of groups is their free product ( http://en.wikipedia.org/wiki/Free_product ), while the direct product of two abelian groups in the category of abelian groups is their cartesian product. If you have two abelian groups A and B, their direct product as groups is not the same as their direct product as monoids, not even as a monoid!

> 
> Yes! That's precisely why there is basically nothing about "direct products" in
> the category infrastructure: the fact that it's not covariant (aka
> uniform across categories) means there is nothing we can share
> automatically. This is unlike cartesian products or quotients!
> 
> Just to state the obvious about the covariance for quotients (or
> equivalently homomorphic images): take B a subcategory of A, and Y an
> homomorphic image in B; since B-morphisms are A-morphisms, Y is also
> an homomorphic image in A).

OK, now I see what you mean by "covariant" :) The problem is that the quotient is a certain *universal* homomorphic image, and a quotient in B (despite still being a homomorphic image in A) will not always have this universality property in A.

I'm still at a loss for a good counterexample; these are rare, but fundamentally there is no difference between quotients and direct products here: neither is more universal than the other. There are some easy counterexamples if your notion of a "quotient" includes coequalizers (not just cokernels, which are the narrowest reading of the word "quotient") and your notion of a "subcategory" is the wider sense in which you are using this word (i.e., rings form a subcategory of additive groups).

```
Indeed, take two ring homomorphisms from ZZ[x] to
ZZ[x,y], the first one sending x to x, the second
one sending x to y. Their coequalizer (roughly
speaking, "ZZ[x,y] modulo identifying images under
the first homomorphism with corresponding images
under the second") is

- the additive group ZZ[x,y] modulo the additive
  subgroup <x-y, x^2-y^2, x^3-y^3, ...>, if you
  are working in the category of additive groups;

- the ring ZZ[x,y] modulo the ideal generated by
  x-y, x^2-y^2, x^3-y^3, ..., if you are working
  in the category of rings.

The former is bigger than the latter, because e.g.
the difference x^2y^3-x^3y^2 is in the ideal but
not in the additive subgroup.
```

EDIT: For a counterexample that fits everyone's wishes, a friend of mine just reminded me that quotients of sheaves are not generally the same as quotients of sheaves when regarded as presheaves. See http://mathoverflow.net/questions/19119/why-must-one-sheafify-quotients-of-sheaves . Here, the quotient when constructed in A is not generally in B.

> Fair enough. Let it be Christmas! Done.

Thanks a lot!

> Oh, I see your point now. Ok, that can be easily
> improved. Done. Please check!

Cleared up, thank you.

> Ah, interesting, you are the first one to raise this point :-) So far,
> I was taking for granted that it was natural to consider the
> additional structure as being "encoded" in the morphisms. Ok, we
> probably need to clarify this, even though we are just following the
> terminology that is in use in other systems like Axiom, ...

I fear this will come up in practice a lot, e.g., when you consider Lie algebras which have a grading and a filtration, and the filtration is *not* the one you would get from the grading. (These appear everywhere.) So I'm not very happy to have "graded Xes" as a subcategory of "Xes"...

Anyway I've added some doc now. Is it on the right track?

> Yes indeed! One of the very next steps is precisely to improve the
> support for morphisms (see #10668). And without the full subcategory
> business, there is not much homsets stuff to inherit and share between
> categories.

Well... any operation on the homset of a big category is also an operation on the homset of any subcategory, if "subcategory" is understood in the mathematical sense. Maybe by saying "full subcategory" you really mean "subcategory in the mathematical sense", i.e. subcategory without additional data?

> The point is that often, in practice, what's useful in similar
> situations is actually the full subcategory, even if mathematically
> speaking the natural category is not the full one. For example, for
> ModulesWithBasis (modules with a distinguished basis), we definitely
> want to use the distinguished bases to compute with morphisms. But
> restricting to morphisms that preserve the distinguished bases would
> be really boring.

Good point -- this is probably the right statement to make about full subcategories.

> Done. A full note actually, inspired by the discussion above. Please check.

Well explained. (No, I'm not saying this is something that needs to be fixed; only documented. I don't see much of an advantage in having operation-polymorphic axioms.)

Best regards,\\
Darij



---

archive/issue_comments_109409.json:
```json
{
    "body": "**Changing commit** from \"[f2ceccfb4fbd4cea8daf58c3294af98133ba1b23](https://github.com/sagemath/sagetrac-mirror/commit/f2ceccfb4fbd4cea8daf58c3294af98133ba1b23)\" to \"[26fc3d2ced29fc27bf371fb8cb519dc004bb073e](https://github.com/sagemath/sagetrac-mirror/commit/26fc3d2ced29fc27bf371fb8cb519dc004bb073e)\".",
    "created_at": "2014-03-19T07:25:06Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109409",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f2ceccfb4fbd4cea8daf58c3294af98133ba1b23](https://github.com/sagemath/sagetrac-mirror/commit/f2ceccfb4fbd4cea8daf58c3294af98133ba1b23)" to "[26fc3d2ced29fc27bf371fb8cb519dc004bb073e](https://github.com/sagemath/sagetrac-mirror/commit/26fc3d2ced29fc27bf371fb8cb519dc004bb073e)".



---

archive/issue_comments_109410.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/26fc3d2ced29fc27bf371fb8cb519dc004bb073e\">26fc3d2</a></td><td><code>further little fixes</code></td></tr></table>\n",
    "created_at": "2014-03-19T07:25:06Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109410",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/26fc3d2ced29fc27bf371fb8cb519dc004bb073e">26fc3d2</a></td><td><code>further little fixes</code></td></tr></table>




---

archive/issue_comments_109411.json:
```json
{
    "body": "<a id='comment:5'></a>\nI've just lost a post I was trying to make by entrusting it to Firefox and the fucking trac server. Well, it wasn't very interesting anyway. Basically I've finished reading the `category_with_axiom.py` class-level doc; I don't have much to comment on it (but please check my commits because they can contain landmines). I have ignored the remarks about `Category_singleton` because I have no idea what it is (if it is important, it deserves to be at least mentioned in the primer -- but this isn't related to #10963), and I didn't really understand the algorithm: its recursive structure reminds me of Buchberger's, but I don't see where the list of categories to join ever becomes smaller -- i.e. how redundancy is removed; also, it probably would help to clarify if your ``Bs`` range over all supercategories (proper, I assume?) or only the intermediate ones. Is there a way to reword the algorithm in terms of semilattices given by generators and relations, without any mention of categories and Sage? I feel it would somewhat simplify understanding.\n\nThat said (and the comments on lag, memory leaks and the unclarity of subcategories notwithstanding), the doc is still very well-written.",
    "created_at": "2014-03-19T07:33:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109411",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:5'></a>
I've just lost a post I was trying to make by entrusting it to Firefox and the fucking trac server. Well, it wasn't very interesting anyway. Basically I've finished reading the `category_with_axiom.py` class-level doc; I don't have much to comment on it (but please check my commits because they can contain landmines). I have ignored the remarks about `Category_singleton` because I have no idea what it is (if it is important, it deserves to be at least mentioned in the primer -- but this isn't related to #10963), and I didn't really understand the algorithm: its recursive structure reminds me of Buchberger's, but I don't see where the list of categories to join ever becomes smaller -- i.e. how redundancy is removed; also, it probably would help to clarify if your ``Bs`` range over all supercategories (proper, I assume?) or only the intermediate ones. Is there a way to reword the algorithm in terms of semilattices given by generators and relations, without any mention of categories and Sage? I feel it would somewhat simplify understanding.

That said (and the comments on lag, memory leaks and the unclarity of subcategories notwithstanding), the doc is still very well-written.



---

archive/issue_comments_109412.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cd4f5f92cd415902ea2118292954a5685c6f8cfd\">cd4f5f9</a></td><td><code>Trac 10963: proofread Darij's changes to the documentation and some more little improvements there</code></td></tr></table>\n",
    "created_at": "2014-03-31T12:35:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109412",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cd4f5f92cd415902ea2118292954a5685c6f8cfd">cd4f5f9</a></td><td><code>Trac 10963: proofread Darij's changes to the documentation and some more little improvements there</code></td></tr></table>




---

archive/issue_comments_109413.json:
```json
{
    "body": "**Changing commit** from \"[26fc3d2ced29fc27bf371fb8cb519dc004bb073e](https://github.com/sagemath/sagetrac-mirror/commit/26fc3d2ced29fc27bf371fb8cb519dc004bb073e)\" to \"[cd4f5f92cd415902ea2118292954a5685c6f8cfd](https://github.com/sagemath/sagetrac-mirror/commit/cd4f5f92cd415902ea2118292954a5685c6f8cfd)\".",
    "created_at": "2014-03-31T12:35:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109413",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[26fc3d2ced29fc27bf371fb8cb519dc004bb073e](https://github.com/sagemath/sagetrac-mirror/commit/26fc3d2ced29fc27bf371fb8cb519dc004bb073e)" to "[cd4f5f92cd415902ea2118292954a5685c6f8cfd](https://github.com/sagemath/sagetrac-mirror/commit/cd4f5f92cd415902ea2118292954a5685c6f8cfd)".



---

archive/issue_comments_109414.json:
```json
{
    "body": "<a id='comment:607'></a>\nHi Darij!\n\nSorry for being slow; I have been traveling lately. And thanks for all\nthe proofreading and improvements!\n\nI just pushed some proofreading.\n\nReplying to [darij](#comment%3A603):\n> OK, now I see what you mean by \"covariant\" :) The problem is that the quotient is a certain *universal* homomorphic image, and a quotient in B (despite still being a homomorphic image in A) will not always have this universality property in A.\n\nAnd I see what you mean by \"quotient\" :-) It's more general than what\nI had in mind. In Sage, the category of quotients in A is really about\nobjects Y of A that are endowed with a distinguished surjective\nA-morphism X->Y from some object X of A (and a section of this\nmorphism). See the description in:\n\n    sage: S = Sets()\n    sage: S.Subquotients?\n\nMaybe the name \"Quotients\" is misleading, and should be replaced (in\nsome later ticket) by something like \"HomomorphicImages\".\n\nIn this restricted setting do you still see any issue?\n\n> I fear this will come up in practice a lot, e.g., when you consider Lie algebras which have a grading and a filtration, and the filtration is *not* the one you would get from the grading. (These appear everywhere.) So I'm not very happy to have \"graded Xes\" as a subcategory of \"Xes\"...\n> Anyway I've added some doc now. Is it on the right track?\n\nI tried to improve the description of what subcategories are.\n\nOne thing is that \"GradedXXX\" is not about the objects of XXX that can\nbe endowed with a grading (like e.g. the trivial grading), but about\nobjects of XXX endowed with a distinguished grading. Thus in the above\ncase you could have an unrelated category (say FilteredLieAlgebras),\nand a construction taking a graded lie algebra and endowing it with\nthe filtration induced by its grading, but also other constructions\nendowing it with other filtrations.\n\nCheers,\n                               Nicolas",
    "created_at": "2014-03-31T13:40:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109414",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:607'></a>
Hi Darij!

Sorry for being slow; I have been traveling lately. And thanks for all
the proofreading and improvements!

I just pushed some proofreading.

Replying to [darij](#comment%3A603):
> OK, now I see what you mean by "covariant" :) The problem is that the quotient is a certain *universal* homomorphic image, and a quotient in B (despite still being a homomorphic image in A) will not always have this universality property in A.

And I see what you mean by "quotient" :-) It's more general than what
I had in mind. In Sage, the category of quotients in A is really about
objects Y of A that are endowed with a distinguished surjective
A-morphism X->Y from some object X of A (and a section of this
morphism). See the description in:

    sage: S = Sets()
    sage: S.Subquotients?

Maybe the name "Quotients" is misleading, and should be replaced (in
some later ticket) by something like "HomomorphicImages".

In this restricted setting do you still see any issue?

> I fear this will come up in practice a lot, e.g., when you consider Lie algebras which have a grading and a filtration, and the filtration is *not* the one you would get from the grading. (These appear everywhere.) So I'm not very happy to have "graded Xes" as a subcategory of "Xes"...
> Anyway I've added some doc now. Is it on the right track?

I tried to improve the description of what subcategories are.

One thing is that "GradedXXX" is not about the objects of XXX that can
be endowed with a grading (like e.g. the trivial grading), but about
objects of XXX endowed with a distinguished grading. Thus in the above
case you could have an unrelated category (say FilteredLieAlgebras),
and a construction taking a graded lie algebra and endowing it with
the filtration induced by its grading, but also other constructions
endowing it with other filtrations.

Cheers,
                               Nicolas



---

archive/issue_comments_109415.json:
```json
{
    "body": "<a id='comment:608'></a>\nReplying to [darij](#comment%3A605):\n> I've just lost a post I was trying to make by entrusting it to Firefox and the fucking trac server.\n\nLuckily, there is a good workaround: using the It's All Text extension:\n\n    https://addons.mozilla.org/fr/firefox/addon/its-all-text/\n\nNever lost a post since then :-)\n\n>  Basically I've finished reading the `category_with_axiom.py` class-level doc; I don't have much to comment on it (but please check my commits because they can contain landmines). I have ignored the remarks about `Category_singleton` because I have no idea what it is (if it is important, it deserves to be at least mentioned in the primer -- but this isn't related to #10963),\n\nThere is a link to the documentation of Category_singleton, which states:\n\n```\n    A base class for implementing singleton category\n\n    A *singleton* category is a category whose class takes no\n    parameters like ``Fields()`` or ``Rings()``. See also the\n    `Singleton design pattern <http://en.wikipedia.org/wiki/Singleton_pattern>`_.\n\n    This is a subclass of :class:`Category`, with a couple\n    optimizations for singleton categories.\n```\n\nIs this enough?\n\n> and I didn't really understand the algorithm: its recursive structure reminds me of Buchberger's, but I don't see where the list of categories to join ever becomes smaller -- i.e. how redundancy is removed;\n\nTheoretically speaking, one is calculating the upper set of all the\nsuper categories (proper or not) of the result, starting from some\nseeds and making it bigger and bigger and bigger until it's\n\"closed\". In particular, it never gets smaller.\n\nOf course, in practice, it's best to describe such an upper set by its\nminimal elements. And with some luck, there are only few of them, if\nnot just one at the end.\n\n> also, it probably would help to clarify if your ``Bs`` range over all supercategories (proper, I assume?) or only the intermediate ones.\n\nOnly the direct super categories. I just made the change and will push\nsoon.\n\n> Is there a way to reword the algorithm in terms of semilattices given by generators and relations, without any mention of categories and Sage? I feel it would somewhat simplify understanding.\n\nI believe that doing it in term of generators and relations (like\ne.g. Simon did) just makes it seemingly harder because it suggests\nthere could be various issues of term ordering, confluence, ...\n\nIt's more about having a semilattice and some operations on it (adding\ncertain axioms), and computing closures of upper sets under those\noperations. I am not sure that making an abstract model for this would\nmake the algorithm easier to understand. I could try though if you\nhave a strong opinion about this.\n\n> That said (and the comments on lag, memory leaks and the unclarity of subcategories notwithstanding), the doc is still very well-written.\n\n:-)\n\nPlease proofread my latest change, and state whether you think the\ndocumentation part of this ticket is good to go!",
    "created_at": "2014-03-31T14:07:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109415",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:608'></a>
Replying to [darij](#comment%3A605):
> I've just lost a post I was trying to make by entrusting it to Firefox and the fucking trac server.

Luckily, there is a good workaround: using the It's All Text extension:

    https://addons.mozilla.org/fr/firefox/addon/its-all-text/

Never lost a post since then :-)

>  Basically I've finished reading the `category_with_axiom.py` class-level doc; I don't have much to comment on it (but please check my commits because they can contain landmines). I have ignored the remarks about `Category_singleton` because I have no idea what it is (if it is important, it deserves to be at least mentioned in the primer -- but this isn't related to #10963),

There is a link to the documentation of Category_singleton, which states:

```
    A base class for implementing singleton category

    A *singleton* category is a category whose class takes no
    parameters like ``Fields()`` or ``Rings()``. See also the
    `Singleton design pattern <http://en.wikipedia.org/wiki/Singleton_pattern>`_.

    This is a subclass of :class:`Category`, with a couple
    optimizations for singleton categories.
```

Is this enough?

> and I didn't really understand the algorithm: its recursive structure reminds me of Buchberger's, but I don't see where the list of categories to join ever becomes smaller -- i.e. how redundancy is removed;

Theoretically speaking, one is calculating the upper set of all the
super categories (proper or not) of the result, starting from some
seeds and making it bigger and bigger and bigger until it's
"closed". In particular, it never gets smaller.

Of course, in practice, it's best to describe such an upper set by its
minimal elements. And with some luck, there are only few of them, if
not just one at the end.

> also, it probably would help to clarify if your ``Bs`` range over all supercategories (proper, I assume?) or only the intermediate ones.

Only the direct super categories. I just made the change and will push
soon.

> Is there a way to reword the algorithm in terms of semilattices given by generators and relations, without any mention of categories and Sage? I feel it would somewhat simplify understanding.

I believe that doing it in term of generators and relations (like
e.g. Simon did) just makes it seemingly harder because it suggests
there could be various issues of term ordering, confluence, ...

It's more about having a semilattice and some operations on it (adding
certain axioms), and computing closures of upper sets under those
operations. I am not sure that making an abstract model for this would
make the algorithm easier to understand. I could try though if you
have a strong opinion about this.

> That said (and the comments on lag, memory leaks and the unclarity of subcategories notwithstanding), the doc is still very well-written.

:-)

Please proofread my latest change, and state whether you think the
documentation part of this ticket is good to go!



---

archive/issue_comments_109416.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338\">76728d6</a></td><td><code>Trac 10963: micro improvement to the documentation of the algorithm, upon Darij's suggestion</code></td></tr></table>\n",
    "created_at": "2014-03-31T14:08:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109416",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338">76728d6</a></td><td><code>Trac 10963: micro improvement to the documentation of the algorithm, upon Darij's suggestion</code></td></tr></table>




---

archive/issue_comments_109417.json:
```json
{
    "body": "**Changing commit** from \"[cd4f5f92cd415902ea2118292954a5685c6f8cfd](https://github.com/sagemath/sagetrac-mirror/commit/cd4f5f92cd415902ea2118292954a5685c6f8cfd)\" to \"[76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338](https://github.com/sagemath/sagetrac-mirror/commit/76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338)\".",
    "created_at": "2014-03-31T14:08:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109417",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[cd4f5f92cd415902ea2118292954a5685c6f8cfd](https://github.com/sagemath/sagetrac-mirror/commit/cd4f5f92cd415902ea2118292954a5685c6f8cfd)" to "[76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338](https://github.com/sagemath/sagetrac-mirror/commit/76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338)".



---

archive/issue_comments_109418.json:
```json
{
    "body": "**Changing commit** from \"[76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338](https://github.com/sagemath/sagetrac-mirror/commit/76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338)\" to \"[70972db40325a944ac3175b3e78421321a1cb8b5](https://github.com/sagemath/sagetrac-mirror/commit/70972db40325a944ac3175b3e78421321a1cb8b5)\".",
    "created_at": "2014-04-09T01:53:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109418",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338](https://github.com/sagemath/sagetrac-mirror/commit/76728d6e269cb1c3c67cd0b3e60cf2d0bde5a338)" to "[70972db40325a944ac3175b3e78421321a1cb8b5](https://github.com/sagemath/sagetrac-mirror/commit/70972db40325a944ac3175b3e78421321a1cb8b5)".



---

archive/issue_comments_109419.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/641483077a0d1c4a748e54930ce2ac56be72720e\">6414830</a></td><td><code>Merge branch 'develop' into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1b93d6eaac78bccdc329695bbb5190e69a3b9905\">1b93d6e</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/28b39a2dd201033ccf0237a1c1dac042a987df17\">28b39a2</a></td><td><code>Merge branch 'develop' into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/70972db40325a944ac3175b3e78421321a1cb8b5\">70972db</a></td><td><code>Merge branch 'develop' into public/ticket/10963-doc-distributive</code></td></tr></table>\n",
    "created_at": "2014-04-09T01:53:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109419",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/641483077a0d1c4a748e54930ce2ac56be72720e">6414830</a></td><td><code>Merge branch 'develop' into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1b93d6eaac78bccdc329695bbb5190e69a3b9905">1b93d6e</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/28b39a2dd201033ccf0237a1c1dac042a987df17">28b39a2</a></td><td><code>Merge branch 'develop' into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/70972db40325a944ac3175b3e78421321a1cb8b5">70972db</a></td><td><code>Merge branch 'develop' into public/ticket/10963-doc-distributive</code></td></tr></table>




---

archive/issue_comments_109420.json:
```json
{
    "body": "**Changing commit** from \"[70972db40325a944ac3175b3e78421321a1cb8b5](https://github.com/sagemath/sagetrac-mirror/commit/70972db40325a944ac3175b3e78421321a1cb8b5)\" to \"[e1110da9cf2d07b6c7a51d7c949340a1b0e3e836](https://github.com/sagemath/sagetrac-mirror/commit/e1110da9cf2d07b6c7a51d7c949340a1b0e3e836)\".",
    "created_at": "2014-04-09T10:32:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109420",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[70972db40325a944ac3175b3e78421321a1cb8b5](https://github.com/sagemath/sagetrac-mirror/commit/70972db40325a944ac3175b3e78421321a1cb8b5)" to "[e1110da9cf2d07b6c7a51d7c949340a1b0e3e836](https://github.com/sagemath/sagetrac-mirror/commit/e1110da9cf2d07b6c7a51d7c949340a1b0e3e836)".



---

archive/issue_comments_109421.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e1110da9cf2d07b6c7a51d7c949340a1b0e3e836\">e1110da</a></td><td><code>Trac 10963: added little note in Category._super_categories</code></td></tr></table>\n",
    "created_at": "2014-04-09T10:32:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109421",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e1110da9cf2d07b6c7a51d7c949340a1b0e3e836">e1110da</a></td><td><code>Trac 10963: added little note in Category._super_categories</code></td></tr></table>




---

archive/issue_comments_109422.json:
```json
{
    "body": "**Changing commit** from \"[e1110da9cf2d07b6c7a51d7c949340a1b0e3e836](https://github.com/sagemath/sagetrac-mirror/commit/e1110da9cf2d07b6c7a51d7c949340a1b0e3e836)\" to \"[ad718de24229c30d40134b35e6803b852a97f86c](https://github.com/sagemath/sagetrac-mirror/commit/ad718de24229c30d40134b35e6803b852a97f86c)\".",
    "created_at": "2014-04-09T10:45:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109422",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[e1110da9cf2d07b6c7a51d7c949340a1b0e3e836](https://github.com/sagemath/sagetrac-mirror/commit/e1110da9cf2d07b6c7a51d7c949340a1b0e3e836)" to "[ad718de24229c30d40134b35e6803b852a97f86c](https://github.com/sagemath/sagetrac-mirror/commit/ad718de24229c30d40134b35e6803b852a97f86c)".



---

archive/issue_comments_109423.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ad718de24229c30d40134b35e6803b852a97f86c\">ad718de</a></td><td><code>Trac 10963: added mathematical definitions to the documentation of a bunch of axioms</code></td></tr></table>\n",
    "created_at": "2014-04-09T10:45:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109423",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ad718de24229c30d40134b35e6803b852a97f86c">ad718de</a></td><td><code>Trac 10963: added mathematical definitions to the documentation of a bunch of axioms</code></td></tr></table>




---

archive/issue_comments_109424.json:
```json
{
    "body": "**Changing commit** from \"[ad718de24229c30d40134b35e6803b852a97f86c](https://github.com/sagemath/sagetrac-mirror/commit/ad718de24229c30d40134b35e6803b852a97f86c)\" to \"[7db4ef08c23c9aeb096203dcbb4bad41ea328599](https://github.com/sagemath/sagetrac-mirror/commit/7db4ef08c23c9aeb096203dcbb4bad41ea328599)\".",
    "created_at": "2014-04-11T01:35:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109424",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ad718de24229c30d40134b35e6803b852a97f86c](https://github.com/sagemath/sagetrac-mirror/commit/ad718de24229c30d40134b35e6803b852a97f86c)" to "[7db4ef08c23c9aeb096203dcbb4bad41ea328599](https://github.com/sagemath/sagetrac-mirror/commit/7db4ef08c23c9aeb096203dcbb4bad41ea328599)".



---

archive/issue_comments_109425.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7db4ef08c23c9aeb096203dcbb4bad41ea328599\">7db4ef0</a></td><td><code>Trac 10963: Fixed repr for the symmetric group algebra by improving a bit the generic repr methods in the categories</code></td></tr></table>\n",
    "created_at": "2014-04-11T01:35:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109425",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7db4ef08c23c9aeb096203dcbb4bad41ea328599">7db4ef0</a></td><td><code>Trac 10963: Fixed repr for the symmetric group algebra by improving a bit the generic repr methods in the categories</code></td></tr></table>




---

archive/issue_comments_109426.json:
```json
{
    "body": "**Changing commit** from \"[7db4ef08c23c9aeb096203dcbb4bad41ea328599](https://github.com/sagemath/sagetrac-mirror/commit/7db4ef08c23c9aeb096203dcbb4bad41ea328599)\" to \"[367d72e6473c6050fd6fda628af17e8bcd59bde9](https://github.com/sagemath/sagetrac-mirror/commit/367d72e6473c6050fd6fda628af17e8bcd59bde9)\".",
    "created_at": "2014-04-11T01:39:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109426",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7db4ef08c23c9aeb096203dcbb4bad41ea328599](https://github.com/sagemath/sagetrac-mirror/commit/7db4ef08c23c9aeb096203dcbb4bad41ea328599)" to "[367d72e6473c6050fd6fda628af17e8bcd59bde9](https://github.com/sagemath/sagetrac-mirror/commit/367d72e6473c6050fd6fda628af17e8bcd59bde9)".



---

archive/issue_comments_109427.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/367d72e6473c6050fd6fda628af17e8bcd59bde9\">367d72e</a></td><td><code>Trac 10963: fixed trivial doctest failure</code></td></tr></table>\n",
    "created_at": "2014-04-11T01:39:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109427",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/367d72e6473c6050fd6fda628af17e8bcd59bde9">367d72e</a></td><td><code>Trac 10963: fixed trivial doctest failure</code></td></tr></table>




---

archive/issue_comments_109428.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8919180873bd9f94f9ff4ef0e0bafd7d5685ddae\">8919180</a></td><td><code>Trac 10963: reverted change that was meant to be put in #15801</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d1b53748c7720604e88c197f1f7a3689381e31b4\">d1b5374</a></td><td><code>Trac 10963: reverted change that required #15801 for no good reason</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4580db1aa3733d541f74b949bffdd38170460744\">4580db1</a></td><td><code>Trac 10963: fixed trivial doctest failures</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f44661fd23ad8e4a5e67109a0a47677cc4fd2113\">f44661f</a></td><td><code>Trac 15801: added repr in HeckeModule_free_module (the generic one in modules with basis can't handle it anymore)</code></td></tr></table>\n",
    "created_at": "2014-04-11T10:03:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109428",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8919180873bd9f94f9ff4ef0e0bafd7d5685ddae">8919180</a></td><td><code>Trac 10963: reverted change that was meant to be put in #15801</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d1b53748c7720604e88c197f1f7a3689381e31b4">d1b5374</a></td><td><code>Trac 10963: reverted change that required #15801 for no good reason</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4580db1aa3733d541f74b949bffdd38170460744">4580db1</a></td><td><code>Trac 10963: fixed trivial doctest failures</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f44661fd23ad8e4a5e67109a0a47677cc4fd2113">f44661f</a></td><td><code>Trac 15801: added repr in HeckeModule_free_module (the generic one in modules with basis can't handle it anymore)</code></td></tr></table>




---

archive/issue_comments_109429.json:
```json
{
    "body": "**Changing commit** from \"[367d72e6473c6050fd6fda628af17e8bcd59bde9](https://github.com/sagemath/sagetrac-mirror/commit/367d72e6473c6050fd6fda628af17e8bcd59bde9)\" to \"[f44661fd23ad8e4a5e67109a0a47677cc4fd2113](https://github.com/sagemath/sagetrac-mirror/commit/f44661fd23ad8e4a5e67109a0a47677cc4fd2113)\".",
    "created_at": "2014-04-11T10:03:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109429",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[367d72e6473c6050fd6fda628af17e8bcd59bde9](https://github.com/sagemath/sagetrac-mirror/commit/367d72e6473c6050fd6fda628af17e8bcd59bde9)" to "[f44661fd23ad8e4a5e67109a0a47677cc4fd2113](https://github.com/sagemath/sagetrac-mirror/commit/f44661fd23ad8e4a5e67109a0a47677cc4fd2113)".



---

archive/issue_comments_109430.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/feab04a37ffb764b885dcefb63bb4a926977cee7\">feab04a</a></td><td><code>manual merge with 6.2.beta8</code></td></tr></table>\n",
    "created_at": "2014-04-15T01:30:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109430",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/feab04a37ffb764b885dcefb63bb4a926977cee7">feab04a</a></td><td><code>manual merge with 6.2.beta8</code></td></tr></table>




---

archive/issue_comments_109431.json:
```json
{
    "body": "**Changing commit** from \"[f44661fd23ad8e4a5e67109a0a47677cc4fd2113](https://github.com/sagemath/sagetrac-mirror/commit/f44661fd23ad8e4a5e67109a0a47677cc4fd2113)\" to \"[feab04a37ffb764b885dcefb63bb4a926977cee7](https://github.com/sagemath/sagetrac-mirror/commit/feab04a37ffb764b885dcefb63bb4a926977cee7)\".",
    "created_at": "2014-04-15T01:30:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109431",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f44661fd23ad8e4a5e67109a0a47677cc4fd2113](https://github.com/sagemath/sagetrac-mirror/commit/f44661fd23ad8e4a5e67109a0a47677cc4fd2113)" to "[feab04a37ffb764b885dcefb63bb4a926977cee7](https://github.com/sagemath/sagetrac-mirror/commit/feab04a37ffb764b885dcefb63bb4a926977cee7)".



---

archive/issue_comments_109432.json:
```json
{
    "body": "<a id='comment:7'></a>\nI've just pushed a merge to make the branch green again. Just to doublecheck, removing the `cardinality` method in `src/sage/categories/enumerated_sets.py` was intention, right?\n\nAlso, sorry for the long silence on this ticket, and thanks for your replies.\n\nThanks for the reference to the doc of `Subquotients`; that said, `Quotients` as well (and maybe even more so) needs documentation.\n\n(There is a typo in the doc of `Subquotients` btw: the two `\\mapsto` signs should be `\\to` signs. And the maps `l` and `r` shouldn't be called structure-preserving; in usual cases, only `r` is structure-preserving (and this is precisely what that equation says). I'd fix these myself but I can't be assed to find the source file containing the docstring -- just writing `Subquotients??` in the terminal does not show me where the doc is located, which if you ask me is another bug of our caching system.)\n\nI guess I can't really say if I am happy with `Quotients` before I know how they are used. The documentation at least explains the purpose to me. I think the subtleties will emerge when we start implementing (lowercase) `quotient` methods to return actual quotients of parents; if we aren't careful about distinguishing between different ground categories then, we will run into trouble.\n\nI still disagree with the idea of having GradedLieAlgebras a subcategory of LieAlgebras. \"Sub\" implies injectivity throughout mathematics; forgetful functors are not injective. IMHO the whole point of speaking in categories is to piggyback on existing mathematical intuition of the user. This is completely against that intuition.",
    "created_at": "2014-04-15T01:49:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109432",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:7'></a>
I've just pushed a merge to make the branch green again. Just to doublecheck, removing the `cardinality` method in `src/sage/categories/enumerated_sets.py` was intention, right?

Also, sorry for the long silence on this ticket, and thanks for your replies.

Thanks for the reference to the doc of `Subquotients`; that said, `Quotients` as well (and maybe even more so) needs documentation.

(There is a typo in the doc of `Subquotients` btw: the two `\mapsto` signs should be `\to` signs. And the maps `l` and `r` shouldn't be called structure-preserving; in usual cases, only `r` is structure-preserving (and this is precisely what that equation says). I'd fix these myself but I can't be assed to find the source file containing the docstring -- just writing `Subquotients??` in the terminal does not show me where the doc is located, which if you ask me is another bug of our caching system.)

I guess I can't really say if I am happy with `Quotients` before I know how they are used. The documentation at least explains the purpose to me. I think the subtleties will emerge when we start implementing (lowercase) `quotient` methods to return actual quotients of parents; if we aren't careful about distinguishing between different ground categories then, we will run into trouble.

I still disagree with the idea of having GradedLieAlgebras a subcategory of LieAlgebras. "Sub" implies injectivity throughout mathematics; forgetful functors are not injective. IMHO the whole point of speaking in categories is to piggyback on existing mathematical intuition of the user. This is completely against that intuition.



---

archive/issue_comments_109433.json:
```json
{
    "body": "**Changing commit** from \"[feab04a37ffb764b885dcefb63bb4a926977cee7](https://github.com/sagemath/sagetrac-mirror/commit/feab04a37ffb764b885dcefb63bb4a926977cee7)\" to \"[ce2193e9d6f179d2d51812c6af002697ccfbaa8c](https://github.com/sagemath/sagetrac-mirror/commit/ce2193e9d6f179d2d51812c6af002697ccfbaa8c)\".",
    "created_at": "2014-04-15T02:33:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109433",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[feab04a37ffb764b885dcefb63bb4a926977cee7](https://github.com/sagemath/sagetrac-mirror/commit/feab04a37ffb764b885dcefb63bb4a926977cee7)" to "[ce2193e9d6f179d2d51812c6af002697ccfbaa8c](https://github.com/sagemath/sagetrac-mirror/commit/ce2193e9d6f179d2d51812c6af002697ccfbaa8c)".



---

archive/issue_comments_109434.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8eaaa9975dd72399a6987f00ed1848d3e5d5cf65\">8eaaa99</a></td><td><code>Merge branch 'develop' into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ce2193e9d6f179d2d51812c6af002697ccfbaa8c\">ce2193e</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into public/ticket/10963-doc-distributive</code></td></tr></table>\n",
    "created_at": "2014-04-15T02:33:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109434",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8eaaa9975dd72399a6987f00ed1848d3e5d5cf65">8eaaa99</a></td><td><code>Merge branch 'develop' into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ce2193e9d6f179d2d51812c6af002697ccfbaa8c">ce2193e</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into public/ticket/10963-doc-distributive</code></td></tr></table>




---

archive/issue_comments_109435.json:
```json
{
    "body": "<a id='comment:619'></a>\nReplying to [darij](#comment%3A617): \n> I still disagree with the idea of having GradedLieAlgebras a subcategory of LieAlgebras. \"Sub\" implies injectivity throughout mathematics; forgetful functors are not injective. IMHO the whole point of speaking in categories is to piggyback on existing mathematical intuition of the user. This is completely against that intuition.\n\nI strongly support your opinion.  An example that annoys me a lot (already present before this ticket) is\n\n```\nsage: C = Sets(); D = Groups()\nsage: D.is_subcategory(C)\nTrue  # expected False\n```\nIn my humble opinion, either this should return `False`, or the name `is_subcategory()` should be changed so that it does not go against the established meaning of the notion of subcategory.  I would be much happier if the syntax would be something like `C.has_coerce_functor_from(D)` or `D.has_coerce_functor_to(C)`.  (This is just a first idea that came to mind, suggested by `has_coerce_map_from()` for parents, but maybe the analogy is not strong enough for that.)",
    "created_at": "2014-04-15T08:35:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109435",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:619'></a>
Replying to [darij](#comment%3A617): 
> I still disagree with the idea of having GradedLieAlgebras a subcategory of LieAlgebras. "Sub" implies injectivity throughout mathematics; forgetful functors are not injective. IMHO the whole point of speaking in categories is to piggyback on existing mathematical intuition of the user. This is completely against that intuition.

I strongly support your opinion.  An example that annoys me a lot (already present before this ticket) is

```
sage: C = Sets(); D = Groups()
sage: D.is_subcategory(C)
True  # expected False
```
In my humble opinion, either this should return `False`, or the name `is_subcategory()` should be changed so that it does not go against the established meaning of the notion of subcategory.  I would be much happier if the syntax would be something like `C.has_coerce_functor_from(D)` or `D.has_coerce_functor_to(C)`.  (This is just a first idea that came to mind, suggested by `has_coerce_map_from()` for parents, but maybe the analogy is not strong enough for that.)



---

archive/issue_comments_109436.json:
```json
{
    "body": "<a id='comment:620'></a>\nReplying to [pbruin](#comment%3A619):\n> I strongly support your opinion.  An example that annoys me a lot (already present before this ticket) is\n> \n> ```\n> sage: C = Sets(); D = Groups()\n> sage: D.is_subcategory(C)\n> True  # expected False\n> ```\n> In my humble opinion, either this should return `False`, or the name `is_subcategory()` should be changed so that it does not go against the established meaning of the notion of subcategory.\n\nI don't get what you mean. Are you arguing that groups aren't necessarily sets? Sure, all what we need is an object G together with a (inversion) morphism G->G and a (multiplication) morphism GxG->G.\n\nWould it be difficult to fix that, by removing `Sets()` from the list of super-categories in all places where it is not requested by mathematical axioms? I don't think so.\n\nBut then, we must not forget that \"parents\" in Sage's notion are objects in some category containing elements. In other words, parents *are* sets. Hence, the category for each implemented group in Sage would then necessarily change from `Groups()` to `Groups()&Sets()`.",
    "created_at": "2014-04-15T09:31:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109436",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:620'></a>
Replying to [pbruin](#comment%3A619):
> I strongly support your opinion.  An example that annoys me a lot (already present before this ticket) is
> 
> ```
> sage: C = Sets(); D = Groups()
> sage: D.is_subcategory(C)
> True  # expected False
> ```
> In my humble opinion, either this should return `False`, or the name `is_subcategory()` should be changed so that it does not go against the established meaning of the notion of subcategory.

I don't get what you mean. Are you arguing that groups aren't necessarily sets? Sure, all what we need is an object G together with a (inversion) morphism G->G and a (multiplication) morphism GxG->G.

Would it be difficult to fix that, by removing `Sets()` from the list of super-categories in all places where it is not requested by mathematical axioms? I don't think so.

But then, we must not forget that "parents" in Sage's notion are objects in some category containing elements. In other words, parents *are* sets. Hence, the category for each implemented group in Sage would then necessarily change from `Groups()` to `Groups()&Sets()`.



---

archive/issue_comments_109437.json:
```json
{
    "body": "<a id='comment:621'></a>\nReplying to [SimonKing](#comment%3A620):\n> Replying to [pbruin](#comment%3A619):\n> > I strongly support your opinion.  An example that annoys me a lot (already present before this ticket) is\n> > \n> > ```\n> > sage: C = Sets(); D = Groups()\n> > sage: D.is_subcategory(C)\n> > True  # expected False\n> > ```\n> > In my humble opinion, either this should return `False`, or the name `is_subcategory()` should be changed so that it does not go against the established meaning of the notion of subcategory.\n\n> \n> I don't get what you mean. Are you arguing that groups aren't necessarily sets? Sure, all what we need is an object G together with a (inversion) morphism G->G and a (multiplication) morphism GxG->G.\n\nIn some sense I am indeed saying that groups are not necessarily sets, but not in the way you interpret it.  I insist that \"a group is not a set\" in the sense that a group is not *just* a set; it is a set *together with additional structure* (namely a multiplication map satisfying certain axioms implying existence of identity and inverse).\n\nThe fact that this extra structure is part of the definition entails that the category **Groups** of groups is not a subcategory of the category **Sets**, in the sense that the functor sending a group to its underlying set (and a group homomorphism to itself viewed as a map on sets) does *not* give **Groups** the structure of a subcategory of **Sets**.\n\nIn fact, part of the definition of \"D is a subcategory of C\" is that the objects of D form a subclass of the objects of C.  This property is not satisfied for **Groups** and **Sets** under the forgetful functor.\n\nFor example, if *S* = {*a*, *b*} is your favourite set of two elements (say *a* = {} and *b* = {{}}), then you can make *S* into a group in exactly two ways, namely by endowing it either with the multiplication table\n\n```\n | a  b\n-------\na| a  b\nb| b  a\n```\nor with the multiplication table\n\n```\n | a  b\n-------\na| b  a\nb| a  b\n```\nThis means that there are exactly *two* objects of **Groups** corresponding to the object *S* of **Sets** (i.e. whose underlying set is *S*).\n\n(As an aside, it is probably also true that you can realise **Groups** as a subcategory of **Sets** as follows.  Consider a group *G* given by a set *S* and a multiplication map *m*: *S* x *S* -> *S*.  Then *m* can be identified with a set, namely the set of all ordered triples (*a*, *b*, *c*) in *S* x *S* x *S* such that *m*(*a*, *b*) = *c*.  It seems to me that associating to *G* the set *m* (not *S* as you might think) does realise **Groups** as a subcategory of **Sets**; however, this is certainly not what is normally meant by saying that \"groups are sets\".)\n\nIn short, \"groups are sets\" is only true in the loose sense that there is a forgetful functor **Groups** -> **Sets** (sending *G* to *S* in the above notation), not that this functor is a subcategory relation.",
    "created_at": "2014-04-15T11:14:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109437",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:621'></a>
Replying to [SimonKing](#comment%3A620):
> Replying to [pbruin](#comment%3A619):
> > I strongly support your opinion.  An example that annoys me a lot (already present before this ticket) is
> > 
> > ```
> > sage: C = Sets(); D = Groups()
> > sage: D.is_subcategory(C)
> > True  # expected False
> > ```
> > In my humble opinion, either this should return `False`, or the name `is_subcategory()` should be changed so that it does not go against the established meaning of the notion of subcategory.

> 
> I don't get what you mean. Are you arguing that groups aren't necessarily sets? Sure, all what we need is an object G together with a (inversion) morphism G->G and a (multiplication) morphism GxG->G.

In some sense I am indeed saying that groups are not necessarily sets, but not in the way you interpret it.  I insist that "a group is not a set" in the sense that a group is not *just* a set; it is a set *together with additional structure* (namely a multiplication map satisfying certain axioms implying existence of identity and inverse).

The fact that this extra structure is part of the definition entails that the category **Groups** of groups is not a subcategory of the category **Sets**, in the sense that the functor sending a group to its underlying set (and a group homomorphism to itself viewed as a map on sets) does *not* give **Groups** the structure of a subcategory of **Sets**.

In fact, part of the definition of "D is a subcategory of C" is that the objects of D form a subclass of the objects of C.  This property is not satisfied for **Groups** and **Sets** under the forgetful functor.

For example, if *S* = {*a*, *b*} is your favourite set of two elements (say *a* = {} and *b* = {{}}), then you can make *S* into a group in exactly two ways, namely by endowing it either with the multiplication table

```
 | a  b
-------
a| a  b
b| b  a
```
or with the multiplication table

```
 | a  b
-------
a| b  a
b| a  b
```
This means that there are exactly *two* objects of **Groups** corresponding to the object *S* of **Sets** (i.e. whose underlying set is *S*).

(As an aside, it is probably also true that you can realise **Groups** as a subcategory of **Sets** as follows.  Consider a group *G* given by a set *S* and a multiplication map *m*: *S* x *S* -> *S*.  Then *m* can be identified with a set, namely the set of all ordered triples (*a*, *b*, *c*) in *S* x *S* x *S* such that *m*(*a*, *b*) = *c*.  It seems to me that associating to *G* the set *m* (not *S* as you might think) does realise **Groups** as a subcategory of **Sets**; however, this is certainly not what is normally meant by saying that "groups are sets".)

In short, "groups are sets" is only true in the loose sense that there is a forgetful functor **Groups** -> **Sets** (sending *G* to *S* in the above notation), not that this functor is a subcategory relation.



---

archive/issue_comments_109438.json:
```json
{
    "body": "<a id='comment:622'></a>\nReplying to [pbruin](#comment%3A621):\n> In short, \"groups are sets\" is only true in the loose sense that there is a forgetful functor **Groups** -> **Sets** (sending *G* to *S* in the above notation), not that this functor is a subcategory relation.\n\nOK, now I get it (hopefully). The forgetful functor is not injective.\n\nSo, how to implement it? We want that `Groups().parent_class` is derived from `Sets().parent_class` since there is a forgetful functor, but we want that `Groups()` is not a subcategory of `Sets()`.",
    "created_at": "2014-04-15T11:53:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109438",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:622'></a>
Replying to [pbruin](#comment%3A621):
> In short, "groups are sets" is only true in the loose sense that there is a forgetful functor **Groups** -> **Sets** (sending *G* to *S* in the above notation), not that this functor is a subcategory relation.

OK, now I get it (hopefully). The forgetful functor is not injective.

So, how to implement it? We want that `Groups().parent_class` is derived from `Sets().parent_class` since there is a forgetful functor, but we want that `Groups()` is not a subcategory of `Sets()`.



---

archive/issue_comments_109439.json:
```json
{
    "body": "<a id='comment:623'></a>\nReplying to [SimonKing](#comment%3A622):\n> Replying to [pbruin](#comment%3A621):\n> > In short, \"groups are sets\" is only true in the loose sense that there is a forgetful functor **Groups** -> **Sets** (sending *G* to *S* in the above notation), not that this functor is a subcategory relation.\n\n> \n> OK, now I get it (hopefully). The forgetful functor is not injective.\n> \n> So, how to implement it? We want that `Groups().parent_class` is derived from `Sets().parent_class` since there is a forgetful functor, but we want that `Groups()` is not a subcategory of `Sets()`.\n\nYes, exactly.  We definitely want groups and their elements to inherit functionality from sets and their elements; the mathematical notion of subcategory is just not the right one to govern such inheritance.\n\nThe fact that we want a weaker notion than subcategories is somewhat analogous to the situation with rings (for example): there is a notion of one ring being a subring of another, a weaker notion of a ring admitting a canonical homomorphism into another, and the coercion mechanism mainly relies on the weaker notion.\n\n```\nsage: ZZ.is_subring(QQ)\nTrue\nsage: ZZ.is_subring(Zmod(4))\nFalse\nsage: Zmod(4).coerce_map_from(ZZ)\nNatural morphism:\n  From: Integer Ring\n  To:   Ring of integers modulo 4\n```\nIt would be nice to have an analougous distinction for categories: a method `is_subcategory()` whose return value reflects the usual mathematical notion of subcategories, and another method `has_coerce_functor_from()`, `has_coerce_functor_to()` or something similar.  The latter would implement this weaker notion of having a canonical functor (doing what is currently done by `is_subcategory()`), which should remain the more appropriate notion to control inheritance of parent (and element) methods.",
    "created_at": "2014-04-15T13:24:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109439",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:623'></a>
Replying to [SimonKing](#comment%3A622):
> Replying to [pbruin](#comment%3A621):
> > In short, "groups are sets" is only true in the loose sense that there is a forgetful functor **Groups** -> **Sets** (sending *G* to *S* in the above notation), not that this functor is a subcategory relation.

> 
> OK, now I get it (hopefully). The forgetful functor is not injective.
> 
> So, how to implement it? We want that `Groups().parent_class` is derived from `Sets().parent_class` since there is a forgetful functor, but we want that `Groups()` is not a subcategory of `Sets()`.

Yes, exactly.  We definitely want groups and their elements to inherit functionality from sets and their elements; the mathematical notion of subcategory is just not the right one to govern such inheritance.

The fact that we want a weaker notion than subcategories is somewhat analogous to the situation with rings (for example): there is a notion of one ring being a subring of another, a weaker notion of a ring admitting a canonical homomorphism into another, and the coercion mechanism mainly relies on the weaker notion.

```
sage: ZZ.is_subring(QQ)
True
sage: ZZ.is_subring(Zmod(4))
False
sage: Zmod(4).coerce_map_from(ZZ)
Natural morphism:
  From: Integer Ring
  To:   Ring of integers modulo 4
```
It would be nice to have an analougous distinction for categories: a method `is_subcategory()` whose return value reflects the usual mathematical notion of subcategories, and another method `has_coerce_functor_from()`, `has_coerce_functor_to()` or something similar.  The latter would implement this weaker notion of having a canonical functor (doing what is currently done by `is_subcategory()`), which should remain the more appropriate notion to control inheritance of parent (and element) methods.



---

archive/issue_comments_109440.json:
```json
{
    "body": "<a id='comment:4'></a>\nI don't think we should use *any* functor, but only forgetful functors to derive additional structure. So I'd call the method `has_forgetful_functor_to()` and use that to inherit structure. Moreover, it would be a nice feature to have coerce maps between categories and I'd use the normal mechanism of `_has_coerce_map_from_()` (since functors are the morphisms in the category of [concrete] categories right?).",
    "created_at": "2014-04-15T15:11:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109440",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:4'></a>
I don't think we should use *any* functor, but only forgetful functors to derive additional structure. So I'd call the method `has_forgetful_functor_to()` and use that to inherit structure. Moreover, it would be a nice feature to have coerce maps between categories and I'd use the normal mechanism of `_has_coerce_map_from_()` (since functors are the morphisms in the category of [concrete] categories right?).



---

archive/issue_comments_109441.json:
```json
{
    "body": "<a id='comment:5'></a>\nFrom the primer:\n\n```\nWe have seen above that, for example, the category of groups is\nconsidered by Sage as a subcategory of the category of sets. For\ncategory purists, this is not quite correct: namely, a group is not a\nset; instead, one can recover the underlying set by forgetting the\nmultiplicative structure. However, it would be impractical to have to\nexplicitly forget the multiplicative structure whenever one wanted to\napply on a group an operation defined on sets. In object oriented\nparlance, we really want the relation \"a group *is a* set\", so that\ngroups can inherit code implemented on sets.\n\nTherefore, in Sage, as well as in most systems with a similar category\nframework, we use this slightly abusive definition of subcategory:\n\nA category ``Ds()`` is a *subcategory* of the category ``Cs()`` if, up\nto implicitly applying the appropriate forgetful functor, every object\nof ``Ds()`` is an object of ``Cs()``. Reciprocally, ``Cs()`` is in\nthis case a *super category* of ``Ds()``.\n```\n\nThis is the correct hierarchy relation that we want for organizing the\ncode.\n\nThis hierarchy relation has been called \"subcategory\" in Sage since\n2007, following the other systems with a category mechanism (Axiom,\nMuPAD, ... and actually GAP as well). If you believe that the implicit\napplication of the forgetful functor makes it abusive to call this\n\"subcategory\", or if you think we *also* want to model the \"pure\nsubcategories relation\", we can debate the pros and cons. But this\nbelongs to a separate new ticket.\n\nCheers,\n                          Nicolas",
    "created_at": "2014-04-15T15:36:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109441",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>
From the primer:

```
We have seen above that, for example, the category of groups is
considered by Sage as a subcategory of the category of sets. For
category purists, this is not quite correct: namely, a group is not a
set; instead, one can recover the underlying set by forgetting the
multiplicative structure. However, it would be impractical to have to
explicitly forget the multiplicative structure whenever one wanted to
apply on a group an operation defined on sets. In object oriented
parlance, we really want the relation "a group *is a* set", so that
groups can inherit code implemented on sets.

Therefore, in Sage, as well as in most systems with a similar category
framework, we use this slightly abusive definition of subcategory:

A category ``Ds()`` is a *subcategory* of the category ``Cs()`` if, up
to implicitly applying the appropriate forgetful functor, every object
of ``Ds()`` is an object of ``Cs()``. Reciprocally, ``Cs()`` is in
this case a *super category* of ``Ds()``.
```

This is the correct hierarchy relation that we want for organizing the
code.

This hierarchy relation has been called "subcategory" in Sage since
2007, following the other systems with a category mechanism (Axiom,
MuPAD, ... and actually GAP as well). If you believe that the implicit
application of the forgetful functor makes it abusive to call this
"subcategory", or if you think we *also* want to model the "pure
subcategories relation", we can debate the pros and cons. But this
belongs to a separate new ticket.

Cheers,
                          Nicolas



---

archive/issue_comments_109442.json:
```json
{
    "body": "<a id='comment:6'></a>\nI'm not for it being implicit, just renamed. However I'm happy pushing it to a separate ticket since it was in Sage before #10963.",
    "created_at": "2014-04-15T15:49:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109442",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>
I'm not for it being implicit, just renamed. However I'm happy pushing it to a separate ticket since it was in Sage before #10963.



---

archive/issue_comments_109443.json:
```json
{
    "body": "<a id='comment:627'></a>\nHello Nicolas,\n> From the primer:\n\n(More precisely, from a section of the primer introduced in *this ticket*...)\n> \n> ```\n> We have seen above that, for example, the category of groups is\n> considered by Sage as a subcategory of the category of sets. For\n> category purists, this is not quite correct: namely, a group is not a\n> set; instead, one can recover the underlying set by forgetting the\n> multiplicative structure. However, it would be impractical to have to\n> explicitly forget the multiplicative structure whenever one wanted to\n> apply on a group an operation defined on sets. In object oriented\n> parlance, we really want the relation \"a group *is a* set\", so that\n> groups can inherit code implemented on sets.\n> \n> Therefore, in Sage, as well as in most systems with a similar category\n> framework, we use this slightly abusive definition of subcategory:\n> \n> A category ``Ds()`` is a *subcategory* of the category ``Cs()`` if, up\n> to implicitly applying the appropriate forgetful functor, every object\n> of ``Ds()`` is an object of ``Cs()``. Reciprocally, ``Cs()`` is in\n> this case a *super category* of ``Ds()``.\n> ```\n> \n> This is the correct hierarchy relation that we want for organizing the\n> code.\n\nI do agree with the above motivation for having this hierarchy.  Since Darij raised this point in [comment:617](#comment%3A617), I just wanted to state my agreement with his opinion that it should not be called \"subcategory\".  In other words, this section of the primer would be a good justification for the *existence* of this hierarchy, but it currently reads like an attempt at justifying a design decision to *name* this the subcategory relation, overriding existing mathematical terminology.\n> This hierarchy relation has been called \"subcategory\" in Sage since\n> 2007, following the other systems with a category mechanism (Axiom,\n> MuPAD, ... and actually GAP as well).\n\nNot out of disrespect for the terminology used by Sage and other computer algebra systems, but the subcategory relation in the mathematical sense has been called \"subcategory\" since the 1940s.  I admit never having used Axiom, MuPAD or GAP, but from browsing the documentation of those systems, I get the impression that Sage is moving (or has already moved) far beyond them.  Hence, given the goal of creating a more flexible framework than the type of relatively fixed hierarchy of those systems, of transparently combining functorial constructions, building new categories dynamically etc., I think it is exceedingly important to be extremely careful about both the design and the terminology.  Whenever some construction in Sage conflicts (in name or content) with existing mathematical usage, one at least has to take seriously the possibility that this will create subtle and less subtle problems (if only confused users) in the long run.\n> If you believe that the implicit\n> application of the forgetful functor makes it abusive to call this\n> \"subcategory\", or if you think we *also* want to model the \"pure\n> subcategories relation\", we can debate the pros and cons. But this\n> belongs to a separate new ticket.\n\nCertainly, I do not want to say that something should be done about it here and now.\n\nFor the moment, in the primer, would it perhaps be an option to just *document* that this relation is currently called \"subcategory\" in Sage and not attempt to *justify* this terminology?  (And maybe to consider rewording the mention of \"category purists\"; not that I consider myself one... 8-) )\n\nFinally, let me stress that I greatly value the work done by you and other people on this part of the infrastructure of Sage.  Please view my comments as evidence that this infrastructure is important enough to me to spend some time and energy to discuss the issues involved in \"getting it right\".",
    "created_at": "2014-04-15T16:57:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109443",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:627'></a>
Hello Nicolas,
> From the primer:

(More precisely, from a section of the primer introduced in *this ticket*...)
> 
> ```
> We have seen above that, for example, the category of groups is
> considered by Sage as a subcategory of the category of sets. For
> category purists, this is not quite correct: namely, a group is not a
> set; instead, one can recover the underlying set by forgetting the
> multiplicative structure. However, it would be impractical to have to
> explicitly forget the multiplicative structure whenever one wanted to
> apply on a group an operation defined on sets. In object oriented
> parlance, we really want the relation "a group *is a* set", so that
> groups can inherit code implemented on sets.
> 
> Therefore, in Sage, as well as in most systems with a similar category
> framework, we use this slightly abusive definition of subcategory:
> 
> A category ``Ds()`` is a *subcategory* of the category ``Cs()`` if, up
> to implicitly applying the appropriate forgetful functor, every object
> of ``Ds()`` is an object of ``Cs()``. Reciprocally, ``Cs()`` is in
> this case a *super category* of ``Ds()``.
> ```
> 
> This is the correct hierarchy relation that we want for organizing the
> code.

I do agree with the above motivation for having this hierarchy.  Since Darij raised this point in [comment:617](#comment%3A617), I just wanted to state my agreement with his opinion that it should not be called "subcategory".  In other words, this section of the primer would be a good justification for the *existence* of this hierarchy, but it currently reads like an attempt at justifying a design decision to *name* this the subcategory relation, overriding existing mathematical terminology.
> This hierarchy relation has been called "subcategory" in Sage since
> 2007, following the other systems with a category mechanism (Axiom,
> MuPAD, ... and actually GAP as well).

Not out of disrespect for the terminology used by Sage and other computer algebra systems, but the subcategory relation in the mathematical sense has been called "subcategory" since the 1940s.  I admit never having used Axiom, MuPAD or GAP, but from browsing the documentation of those systems, I get the impression that Sage is moving (or has already moved) far beyond them.  Hence, given the goal of creating a more flexible framework than the type of relatively fixed hierarchy of those systems, of transparently combining functorial constructions, building new categories dynamically etc., I think it is exceedingly important to be extremely careful about both the design and the terminology.  Whenever some construction in Sage conflicts (in name or content) with existing mathematical usage, one at least has to take seriously the possibility that this will create subtle and less subtle problems (if only confused users) in the long run.
> If you believe that the implicit
> application of the forgetful functor makes it abusive to call this
> "subcategory", or if you think we *also* want to model the "pure
> subcategories relation", we can debate the pros and cons. But this
> belongs to a separate new ticket.

Certainly, I do not want to say that something should be done about it here and now.

For the moment, in the primer, would it perhaps be an option to just *document* that this relation is currently called "subcategory" in Sage and not attempt to *justify* this terminology?  (And maybe to consider rewording the mention of "category purists"; not that I consider myself one... 8-) )

Finally, let me stress that I greatly value the work done by you and other people on this part of the infrastructure of Sage.  Please view my comments as evidence that this infrastructure is important enough to me to spend some time and energy to discuss the issues involved in "getting it right".



---

archive/issue_comments_109444.json:
```json
{
    "body": "<a id='comment:628'></a>\nReplying to [tscrim](#comment%3A624):\n> I don't think we should use *any* functor, but only forgetful functors to derive additional structure. So I'd call the method `has_forgetful_functor_to()` and use that to inherit structure. Moreover, it would be a nice feature to have coerce maps between categories and I'd use the normal mechanism of `_has_coerce_map_from_()` (since functors are the morphisms in the category of [concrete] categories right?).\n\nOne problem with the terminology \"forgetful functor\" is that it is not a well-defined notion; see [http://mathoverflow.net/questions/19405/definition-of-forgetful-functor](http://mathoverflow.net/questions/19405/definition-of-forgetful-functor).  Moreover, one important example would be the inclusion functor of a subcategory (in the mathematical sense), which does not actually forget any structure.  So I'm not sure `has_forgetful_functor_to()` would be the best name.  (Although I'm also not terribly happy with my own idea of using the terminology of coercion here.)\n\nAnyway, as I wrote above, I agree that this belongs to a separate ticket.",
    "created_at": "2014-04-15T17:05:09Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109444",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:628'></a>
Replying to [tscrim](#comment%3A624):
> I don't think we should use *any* functor, but only forgetful functors to derive additional structure. So I'd call the method `has_forgetful_functor_to()` and use that to inherit structure. Moreover, it would be a nice feature to have coerce maps between categories and I'd use the normal mechanism of `_has_coerce_map_from_()` (since functors are the morphisms in the category of [concrete] categories right?).

One problem with the terminology "forgetful functor" is that it is not a well-defined notion; see [http://mathoverflow.net/questions/19405/definition-of-forgetful-functor](http://mathoverflow.net/questions/19405/definition-of-forgetful-functor).  Moreover, one important example would be the inclusion functor of a subcategory (in the mathematical sense), which does not actually forget any structure.  So I'm not sure `has_forgetful_functor_to()` would be the best name.  (Although I'm also not terribly happy with my own idea of using the terminology of coercion here.)

Anyway, as I wrote above, I agree that this belongs to a separate ticket.



---

archive/issue_comments_109445.json:
```json
{
    "body": "<a id='comment:629'></a>\nHi!\n\nBack from kids duty (which I made into a backcountry camping getaway:\nI am not complaining :-) )!\n\nReplying to [pbruin](#comment%3A627):\n> Hello Nicolas,\n> > From the primer:\n\n> (More precisely, from a section of the primer introduced in *this ticket*...)\n\nFollowing a request of Darij on this ticket, though not directly about\nthis ticket :-)\n\n> Not out of disrespect for the terminology used by Sage and other computer algebra systems, but the subcategory relation in the mathematical sense has been called \"subcategory\" since the 1940s.\n\nSure! I just wanted to point out that there is already a community of\npeople that has been using this terminology for a long while; so if a\ndecision is made to change it, whoever takes on the task in the\ncorresponding ticket will have to handle backward compatibility and\ntraining.\n\nMaybe it's not so bad after all: in the code the relation appears\nessentially under the name \"super-category\". So if one can accept\nsuper-category as not being the opposite of \"sub-category\" (I\ncertainly can), and if there is a good alternative name for\n\"sub-category\" (I just tried a couple online antonym dictionaries, and\nso far found nothing better than \"inferior\"), things should be easy to\nchange.\n\n> Certainly, I do not want to say that something should be done about it here and now.\n\nIf we can just change the \"subcategory\" terminology without changing\nthe current code, let's proceed now. Otherwise, please open a ticket!\n\n> For the moment, in the primer, would it perhaps be an option to just *document* that this relation is currently called \"subcategory\" in Sage and not attempt to *justify* this terminology?  (And maybe to consider rewording the mention of \"category purists\"; not that I consider myself one... 8-) )\n\nFeel free to proceed and rework the phrasing to whatever seems\nappropriate to you! Please keep the \"justification\" part in one form\nor the other though: it was really meant to point out the relevance of\nthis hierarchy relation between categories and its natural connection\nto object oriented design; not to support the terminology.\n\n> I admit never having used Axiom, MuPAD or GAP, but from browsing the documentation of those systems, I get the impression that Sage is moving (or has already moved) far beyond them.\n> ...\n> Finally, let me stress that I greatly value the work done by you and other people on this part of the infrastructure of Sage.  Please view my comments as evidence that this infrastructure is important enough to me to spend some time and energy to discuss the issues involved in \"getting it right\".\n\n:-)\n\nCheers,\n                             Nicolas",
    "created_at": "2014-04-17T15:29:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109445",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:629'></a>
Hi!

Back from kids duty (which I made into a backcountry camping getaway:
I am not complaining :-) )!

Replying to [pbruin](#comment%3A627):
> Hello Nicolas,
> > From the primer:

> (More precisely, from a section of the primer introduced in *this ticket*...)

Following a request of Darij on this ticket, though not directly about
this ticket :-)

> Not out of disrespect for the terminology used by Sage and other computer algebra systems, but the subcategory relation in the mathematical sense has been called "subcategory" since the 1940s.

Sure! I just wanted to point out that there is already a community of
people that has been using this terminology for a long while; so if a
decision is made to change it, whoever takes on the task in the
corresponding ticket will have to handle backward compatibility and
training.

Maybe it's not so bad after all: in the code the relation appears
essentially under the name "super-category". So if one can accept
super-category as not being the opposite of "sub-category" (I
certainly can), and if there is a good alternative name for
"sub-category" (I just tried a couple online antonym dictionaries, and
so far found nothing better than "inferior"), things should be easy to
change.

> Certainly, I do not want to say that something should be done about it here and now.

If we can just change the "subcategory" terminology without changing
the current code, let's proceed now. Otherwise, please open a ticket!

> For the moment, in the primer, would it perhaps be an option to just *document* that this relation is currently called "subcategory" in Sage and not attempt to *justify* this terminology?  (And maybe to consider rewording the mention of "category purists"; not that I consider myself one... 8-) )

Feel free to proceed and rework the phrasing to whatever seems
appropriate to you! Please keep the "justification" part in one form
or the other though: it was really meant to point out the relevance of
this hierarchy relation between categories and its natural connection
to object oriented design; not to support the terminology.

> I admit never having used Axiom, MuPAD or GAP, but from browsing the documentation of those systems, I get the impression that Sage is moving (or has already moved) far beyond them.
> ...
> Finally, let me stress that I greatly value the work done by you and other people on this part of the infrastructure of Sage.  Please view my comments as evidence that this infrastructure is important enough to me to spend some time and energy to discuss the issues involved in "getting it right".

:-)

Cheers,
                             Nicolas



---

archive/issue_comments_109446.json:
```json
{
    "body": "<a id='comment:630'></a>\nReplying to [darij](#comment%3A617):\n> I've just pushed a merge to make the branch green again.\n\nThanks.\n\n> Just to doublecheck, removing the `cardinality` method in `src/sage/categories/enumerated_sets.py` was intention, right?\n\nMore precisely it was intentionally moved up to sets.py. Thanks for\ndouble checking though!\n\n> Thanks for the reference to the doc of `Subquotients`; that said, `Quotients` as well (and maybe even more so) needs documentation.\n\nIsn't the cross-reference to Subquotients enough? I'd like to avoid\nduplicating the detailed explanations there. I have added a ``(in fact\nhomomorphic image)'' in Quotients to be more specific though.\n\n> (There is a typo in the doc of `Subquotients` btw: the two `\\mapsto` signs should be `\\to` signs.\n\nFixed. Thanks!\n\n> And the maps `l` and `r` shouldn't be called structure-preserving; in usual cases, only `r` is structure-preserving (and this is precisely what that equation says).\n\nRight; it can be confusing to think of `l` as structure preserving. I\nchanged the phrase to only state that `r` is structure\npreserving. It's not perfect though, as we don't want to require `r`\nto be a morphism (if not just because B' might not even be a\nsubobject), and the specific definition of structure preserving which\nis stated and is the one we need in practice is not just about r, but\nabout the pair r and l. Anyway, probably good enough for now.\n\n>  I'd fix these myself but I can't be assed to find the source file containing the docstring -- just writing `Subquotients??` in the terminal does not show me where the doc is located, which if you ask me is another bug of our caching system.)\n\nYes that's annoying; this indeed pops back every now and then despite\nall the hard work Simon has been putting on that. Typical workarounds I use:\n\n```\n   sage: C = Sets()\n   sage: C.Subquotients.f??\n```\nor:\n\n```\n   sage: C.Subquotients.__module__\n```\n\n> I guess I can't really say if I am happy with `Quotients` before I know how they are used. The documentation at least explains the purpose to me. I think the subtleties will emerge when we start implementing (lowercase) `quotient` methods to return actual quotients of parents; if we aren't careful about distinguishing between different ground categories then, we will run into trouble.\n\nOn the category side, the infrastructure is definitely meant to be\nused by calling `C.Quotients()` to specify explicitly the ground\ncategory `C`. That's what `quotient` methods should do; and, unless\nthere is no ambiguity from the input (e.g. a quotient of a polynomial\nring by an ideal), they should actually request `C` to the user.\n\nCheers,\n                 Nicolas",
    "created_at": "2014-04-17T16:17:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109446",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:630'></a>
Replying to [darij](#comment%3A617):
> I've just pushed a merge to make the branch green again.

Thanks.

> Just to doublecheck, removing the `cardinality` method in `src/sage/categories/enumerated_sets.py` was intention, right?

More precisely it was intentionally moved up to sets.py. Thanks for
double checking though!

> Thanks for the reference to the doc of `Subquotients`; that said, `Quotients` as well (and maybe even more so) needs documentation.

Isn't the cross-reference to Subquotients enough? I'd like to avoid
duplicating the detailed explanations there. I have added a ``(in fact
homomorphic image)'' in Quotients to be more specific though.

> (There is a typo in the doc of `Subquotients` btw: the two `\mapsto` signs should be `\to` signs.

Fixed. Thanks!

> And the maps `l` and `r` shouldn't be called structure-preserving; in usual cases, only `r` is structure-preserving (and this is precisely what that equation says).

Right; it can be confusing to think of `l` as structure preserving. I
changed the phrase to only state that `r` is structure
preserving. It's not perfect though, as we don't want to require `r`
to be a morphism (if not just because B' might not even be a
subobject), and the specific definition of structure preserving which
is stated and is the one we need in practice is not just about r, but
about the pair r and l. Anyway, probably good enough for now.

>  I'd fix these myself but I can't be assed to find the source file containing the docstring -- just writing `Subquotients??` in the terminal does not show me where the doc is located, which if you ask me is another bug of our caching system.)

Yes that's annoying; this indeed pops back every now and then despite
all the hard work Simon has been putting on that. Typical workarounds I use:

```
   sage: C = Sets()
   sage: C.Subquotients.f??
```
or:

```
   sage: C.Subquotients.__module__
```

> I guess I can't really say if I am happy with `Quotients` before I know how they are used. The documentation at least explains the purpose to me. I think the subtleties will emerge when we start implementing (lowercase) `quotient` methods to return actual quotients of parents; if we aren't careful about distinguishing between different ground categories then, we will run into trouble.

On the category side, the infrastructure is definitely meant to be
used by calling `C.Quotients()` to specify explicitly the ground
category `C`. That's what `quotient` methods should do; and, unless
there is no ambiguity from the input (e.g. a quotient of a polynomial
ring by an ideal), they should actually request `C` to the user.

Cheers,
                 Nicolas



---

archive/issue_comments_109447.json:
```json
{
    "body": "**Changing commit** from \"[ce2193e9d6f179d2d51812c6af002697ccfbaa8c](https://github.com/sagemath/sagetrac-mirror/commit/ce2193e9d6f179d2d51812c6af002697ccfbaa8c)\" to \"[268345f966b19589088e9b0dc84f183e4f45f545](https://github.com/sagemath/sagetrac-mirror/commit/268345f966b19589088e9b0dc84f183e4f45f545)\".",
    "created_at": "2014-04-17T16:34:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109447",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ce2193e9d6f179d2d51812c6af002697ccfbaa8c](https://github.com/sagemath/sagetrac-mirror/commit/ce2193e9d6f179d2d51812c6af002697ccfbaa8c)" to "[268345f966b19589088e9b0dc84f183e4f45f545](https://github.com/sagemath/sagetrac-mirror/commit/268345f966b19589088e9b0dc84f183e4f45f545)".



---

archive/issue_comments_109448.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/268345f966b19589088e9b0dc84f183e4f45f545\">268345f</a></td><td><code>Trac 10963: attempt at improving the wording for quotients/subquotients</code></td></tr></table>\n",
    "created_at": "2014-04-17T16:34:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109448",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/268345f966b19589088e9b0dc84f183e4f45f545">268345f</a></td><td><code>Trac 10963: attempt at improving the wording for quotients/subquotients</code></td></tr></table>




---

archive/issue_comments_109449.json:
```json
{
    "body": "<a id='comment:632'></a>\nChanges to the documentation of Quotients and the like pushed. Please\ncheck and improve in whatever way you deem appropriate!",
    "created_at": "2014-04-17T16:36:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109449",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:632'></a>
Changes to the documentation of Quotients and the like pushed. Please
check and improve in whatever way you deem appropriate!



---

archive/issue_comments_109450.json:
```json
{
    "body": "<a id='comment:633'></a>\nReplying to [nthiery](#comment%3A629):\n> Maybe it's not so bad after all: in the code the relation appears\n> essentially under the name \"super-category\". So if one can accept\n> super-category as not being the opposite of \"sub-category\" (I\n> certainly can), and if there is a good alternative name for\n> \"sub-category\" (I just tried a couple online antonym dictionaries, and\n> so far found nothing better than \"inferior\"), things should be easy to\n> change.\n\nThat is a very good point; I certainly accept that using either of the two words \"subcategory\" and \"supercategory\" does not mean that one has to admit the other as meaning the exact opposite.\n\nAfter thinking about it for a while, I could only come up with exactly one alternative, but one that I am starting to find very appealing: why don't we call this relation *refinement*?\n\nWhat I like about this word is that it evokes both a state of being (so `is_refinement()` is close enough to `is_subcategory()`) and the *process* of refining (a category being refined into another one by adding axioms and/or extra structure).  It has a slight vagueness about it, like \"forgetful functor\", since neither of the two terms has a nice mathematical definition.\n\nOne could say that \"the (Sage) category `D` is a refinement of the category `C`\" has exactly the same meaning as \"Sage knows about a forgetful functor from `D` to `C`\" and also as \"`C` is in Sage's hierarchy of supercategories of `D`\".  It probably doesn't hurt to reiterate that this common meaning refers to the internal category hierarchy of Sage, not necessarily to a mathematical definition.\n\nLet me give a few arguments why the name \"refinement\" would fit in well with existing code:\n- `sage.structure.CategoryObject` has a method `_refine_category_()` whose job is exactly to place the object into what we currently call a subcategory, but what I propose to call refinement.\n- `ForgetfulFunctor_generic` currently claims to represent \"The forgetful functor, i.e. embedding of a subcategory\"; this would be made both more general and more in line with the existing use of \"forgetful functor\" and \"subcategory\" if the description were changed to \"The forgetful functor corresponding to a refinement of categories\" or something similar.\n- In (almost) all current uses of `X.is_subcategory()` in the Sage library (there are actually not that many), `X` is visibly a category, and is often even called `category`.  Changing `category.is_subcategory(...)` into `category.is_refinement(...)` does not remove any expressiveness; almost on the contrary.\n- \"Refinement\" is one character and two syllables shorter than \"subcategory\". 8-)\n\nI am very interested to hear any opinions about this proposed terminology!  If we end up wanting to change the name, we can decide later whether we want to do it here or in a new ticket.  There would not be huge amount of code to change, but it might still be a bit much for this ticket.",
    "created_at": "2014-04-18T00:35:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109450",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:633'></a>
Replying to [nthiery](#comment%3A629):
> Maybe it's not so bad after all: in the code the relation appears
> essentially under the name "super-category". So if one can accept
> super-category as not being the opposite of "sub-category" (I
> certainly can), and if there is a good alternative name for
> "sub-category" (I just tried a couple online antonym dictionaries, and
> so far found nothing better than "inferior"), things should be easy to
> change.

That is a very good point; I certainly accept that using either of the two words "subcategory" and "supercategory" does not mean that one has to admit the other as meaning the exact opposite.

After thinking about it for a while, I could only come up with exactly one alternative, but one that I am starting to find very appealing: why don't we call this relation *refinement*?

What I like about this word is that it evokes both a state of being (so `is_refinement()` is close enough to `is_subcategory()`) and the *process* of refining (a category being refined into another one by adding axioms and/or extra structure).  It has a slight vagueness about it, like "forgetful functor", since neither of the two terms has a nice mathematical definition.

One could say that "the (Sage) category `D` is a refinement of the category `C`" has exactly the same meaning as "Sage knows about a forgetful functor from `D` to `C`" and also as "`C` is in Sage's hierarchy of supercategories of `D`".  It probably doesn't hurt to reiterate that this common meaning refers to the internal category hierarchy of Sage, not necessarily to a mathematical definition.

Let me give a few arguments why the name "refinement" would fit in well with existing code:
- `sage.structure.CategoryObject` has a method `_refine_category_()` whose job is exactly to place the object into what we currently call a subcategory, but what I propose to call refinement.
- `ForgetfulFunctor_generic` currently claims to represent "The forgetful functor, i.e. embedding of a subcategory"; this would be made both more general and more in line with the existing use of "forgetful functor" and "subcategory" if the description were changed to "The forgetful functor corresponding to a refinement of categories" or something similar.
- In (almost) all current uses of `X.is_subcategory()` in the Sage library (there are actually not that many), `X` is visibly a category, and is often even called `category`.  Changing `category.is_subcategory(...)` into `category.is_refinement(...)` does not remove any expressiveness; almost on the contrary.
- "Refinement" is one character and two syllables shorter than "subcategory". 8-)

I am very interested to hear any opinions about this proposed terminology!  If we end up wanting to change the name, we can decide later whether we want to do it here or in a new ticket.  There would not be huge amount of code to change, but it might still be a bit much for this ticket.



---

archive/issue_comments_109451.json:
```json
{
    "body": "<a id='comment:634'></a>\nReplying to [pbruin](#comment%3A633):\n\n> - `sage.structure.CategoryObject` has a method `_refine_category_()` whose job is exactly to place the object into what we currently call a subcategory, but what I propose to call refinement.\n\nThat's actually a rather bad example. This method mutates category objects, which are hashable and hence are supposed to be immutable. Worse: they tend to be `UniqueRepresentation` and hence should *really* be immutable, because unrelated code may hold a reference to the same object. Under those circumstances the only category change that has a remote change of not wreaking havoc is one to a subcategory in the mathematical sense of the word. So if your interpretation of the term \"refinement\" is adopted, this method would have to be renamed.",
    "created_at": "2014-04-18T01:42:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109451",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:634'></a>
Replying to [pbruin](#comment%3A633):

> - `sage.structure.CategoryObject` has a method `_refine_category_()` whose job is exactly to place the object into what we currently call a subcategory, but what I propose to call refinement.

That's actually a rather bad example. This method mutates category objects, which are hashable and hence are supposed to be immutable. Worse: they tend to be `UniqueRepresentation` and hence should *really* be immutable, because unrelated code may hold a reference to the same object. Under those circumstances the only category change that has a remote change of not wreaking havoc is one to a subcategory in the mathematical sense of the word. So if your interpretation of the term "refinement" is adopted, this method would have to be renamed.



---

archive/issue_comments_109452.json:
```json
{
    "body": "<a id='comment:635'></a>\nReplying to [nbruin](#comment%3A634):\n> > - `sage.structure.CategoryObject` has a method `_refine_category_()` whose job is exactly to place the object into what we currently call a subcategory, but what I propose to call refinement.\n\n> \n> That's actually a rather bad example. This method mutates category objects, which are hashable and hence are supposed to be immutable.\n\n`_refine_category_()` is not meant to mutate an object. And in fact it only does if hash and/or comparison depend on, say, the type of the object or of course on the category. But I think it is a bug (and even a punch in Python's face) to make comparison depend on the type of an object. `_refine_category_()` is not to blame for such bugs.\n\nBut it is a bad example for a different reason: I think `_refine_category_` should only be used for changing the category to a sub-category **in the mathematical sense of the word**. I think using it to refine an object of `Sets()` to an object of `Groups()` would be wrong!\n\nAnd I even think it should only be used on a *full* sub-category. This is since coercions are cached, and coercion maps are supposed to be morphisms: Suppose you have objects O1 and O2 belonging to a category C, and there is a coercion phi from O1 to O2 in category C. If you then refine to a non-full sub-category D, then it could be that phi is *not* a morphism in D. Hence, it would not be a coercion any longer.\n\nSo, as soon as we have a working framework for full subcategories versus subcategories versus \"refinements\", `_refine_category_()` is one of the first applications. And I agree that then a name change will be needed. Suggestion: `_interprete_in_full_subcategory_()`.",
    "created_at": "2014-04-18T07:31:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109452",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:635'></a>
Replying to [nbruin](#comment%3A634):
> > - `sage.structure.CategoryObject` has a method `_refine_category_()` whose job is exactly to place the object into what we currently call a subcategory, but what I propose to call refinement.

> 
> That's actually a rather bad example. This method mutates category objects, which are hashable and hence are supposed to be immutable.

`_refine_category_()` is not meant to mutate an object. And in fact it only does if hash and/or comparison depend on, say, the type of the object or of course on the category. But I think it is a bug (and even a punch in Python's face) to make comparison depend on the type of an object. `_refine_category_()` is not to blame for such bugs.

But it is a bad example for a different reason: I think `_refine_category_` should only be used for changing the category to a sub-category **in the mathematical sense of the word**. I think using it to refine an object of `Sets()` to an object of `Groups()` would be wrong!

And I even think it should only be used on a *full* sub-category. This is since coercions are cached, and coercion maps are supposed to be morphisms: Suppose you have objects O1 and O2 belonging to a category C, and there is a coercion phi from O1 to O2 in category C. If you then refine to a non-full sub-category D, then it could be that phi is *not* a morphism in D. Hence, it would not be a coercion any longer.

So, as soon as we have a working framework for full subcategories versus subcategories versus "refinements", `_refine_category_()` is one of the first applications. And I agree that then a name change will be needed. Suggestion: `_interprete_in_full_subcategory_()`.



---

archive/issue_comments_109453.json:
```json
{
    "body": "<a id='comment:636'></a>\nReplying to [pbruin](#comment%3A633):\n> That is a very good point; I certainly accept that using either of the two words \"subcategory\" and \"supercategory\" does not mean that one has to admit the other as meaning the exact opposite.\n\n> If we end up wanting to change the name, we can decide later whether we want to do it here or in a new ticket.  There would not be huge amount of code to change, but it might still be a bit much for this ticket.\n\nYour comment just made me realize that we would actually need to\nchange some pieces of the code (at least renaming the is_subcategory\nmethod!), and not just some phrasing in the primer. Thus, since this\nis not directly related to this ticket, this definitely belongs to a\nseparate ticket.\n\nI have created #16183. Please keep up this interesting discussion there!\n\nPeter: would you mind adding some links back from #16183 to the\nspecific comments here, and make a brief summary of the discussion so\nfar there?\n\nCheers,\n                               Nicolas",
    "created_at": "2014-04-18T08:03:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109453",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:636'></a>
Replying to [pbruin](#comment%3A633):
> That is a very good point; I certainly accept that using either of the two words "subcategory" and "supercategory" does not mean that one has to admit the other as meaning the exact opposite.

> If we end up wanting to change the name, we can decide later whether we want to do it here or in a new ticket.  There would not be huge amount of code to change, but it might still be a bit much for this ticket.

Your comment just made me realize that we would actually need to
change some pieces of the code (at least renaming the is_subcategory
method!), and not just some phrasing in the primer. Thus, since this
is not directly related to this ticket, this definitely belongs to a
separate ticket.

I have created #16183. Please keep up this interesting discussion there!

Peter: would you mind adding some links back from #16183 to the
specific comments here, and make a brief summary of the discussion so
far there?

Cheers,
                               Nicolas



---

archive/issue_comments_109454.json:
```json
{
    "body": "<a id='comment:637'></a>\nReplying to [nthiery](#comment%3A636):\n> I have created #16183. Please keep up this interesting discussion there!\n> \n> Peter: would you mind adding some links back from #16183 to the\n> specific comments here, and make a brief summary of the discussion so\n> far there?\n\nThanks! I'll have a go at it after Easter.",
    "created_at": "2014-04-18T08:42:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109454",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:637'></a>
Replying to [nthiery](#comment%3A636):
> I have created #16183. Please keep up this interesting discussion there!
> 
> Peter: would you mind adding some links back from #16183 to the
> specific comments here, and make a brief summary of the discussion so
> far there?

Thanks! I'll have a go at it after Easter.



---

archive/issue_comments_109455.json:
```json
{
    "body": "<a id='comment:8'></a>\nHi Nicolas,\n\non sage-devel, you wrote that you could make a list of commits that need a technical review for this ticket to be finished. Can you post this list, please?\n\nCheers,\nSimon",
    "created_at": "2014-04-22T07:24:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109455",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Hi Nicolas,

on sage-devel, you wrote that you could make a list of commits that need a technical review for this ticket to be finished. Can you post this list, please?

Cheers,
Simon



---

archive/issue_comments_109456.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/18a4a74779e45d5ac8662affc40d46b773e3c495\">18a4a74</a></td><td><code>Trac 10963: improve explanation of Sage notion of subcategories</code></td></tr></table>\n",
    "created_at": "2014-04-22T11:36:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109456",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/18a4a74779e45d5ac8662affc40d46b773e3c495">18a4a74</a></td><td><code>Trac 10963: improve explanation of Sage notion of subcategories</code></td></tr></table>




---

archive/issue_comments_109457.json:
```json
{
    "body": "**Changing commit** from \"[268345f966b19589088e9b0dc84f183e4f45f545](https://github.com/sagemath/sagetrac-mirror/commit/268345f966b19589088e9b0dc84f183e4f45f545)\" to \"[18a4a74779e45d5ac8662affc40d46b773e3c495](https://github.com/sagemath/sagetrac-mirror/commit/18a4a74779e45d5ac8662affc40d46b773e3c495)\".",
    "created_at": "2014-04-22T11:36:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109457",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[268345f966b19589088e9b0dc84f183e4f45f545](https://github.com/sagemath/sagetrac-mirror/commit/268345f966b19589088e9b0dc84f183e4f45f545)" to "[18a4a74779e45d5ac8662affc40d46b773e3c495](https://github.com/sagemath/sagetrac-mirror/commit/18a4a74779e45d5ac8662affc40d46b773e3c495)".



---

archive/issue_comments_109458.json:
```json
{
    "body": "<a id='comment:640'></a>\nReplying to [nthiery](#comment%3A629):\n> Replying to [pbruin](#comment%3A627):\n> > For the moment, in the primer, would it perhaps be an option to just *document* that this relation is currently called \"subcategory\" in Sage and not attempt to *justify* this terminology?  (And maybe to consider rewording the mention of \"category purists\"; not that I consider myself one... 8-) )\n\n> Feel free to proceed and rework the phrasing to whatever seems\n> appropriate to you! Please keep the \"justification\" part in one form\n> or the other though: it was really meant to point out the relevance of\n> this hierarchy relation between categories and its natural connection\n> to object oriented design; not to support the terminology.\n\nI have just pushed a commit for this; I hope that it strikes the right balance, and that the note referring to a possible future change in #16183 is appropriate.",
    "created_at": "2014-04-22T11:39:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109458",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:640'></a>
Replying to [nthiery](#comment%3A629):
> Replying to [pbruin](#comment%3A627):
> > For the moment, in the primer, would it perhaps be an option to just *document* that this relation is currently called "subcategory" in Sage and not attempt to *justify* this terminology?  (And maybe to consider rewording the mention of "category purists"; not that I consider myself one... 8-) )

> Feel free to proceed and rework the phrasing to whatever seems
> appropriate to you! Please keep the "justification" part in one form
> or the other though: it was really meant to point out the relevance of
> this hierarchy relation between categories and its natural connection
> to object oriented design; not to support the terminology.

I have just pushed a commit for this; I hope that it strikes the right balance, and that the note referring to a possible future change in #16183 is appropriate.



---

archive/issue_comments_109459.json:
```json
{
    "body": "<a id='comment:641'></a>\nHi Simon!\n\nReplying to [SimonKing](#comment%3A638):\n> on sage-devel, you wrote that you could make a list of commits that need a technical review for this ticket to be finished. Can you post this list, please?\n\nThe following list should be correct (I took the log between develop\nand my branch, and removed commits about documentation or merges)::\n\n```\n4580db1 Trac 10963: fixed trivial doctest failures\n367d72e Trac 10963: fixed trivial doctest failure\n7db4ef0 Trac 10963: Fixed repr for the symmetric group algebra by improving a bit the generic repr methods in the categories\ne1110da Trac 10963: added little note in Category._super_categories\nd6a0e60 Axioms: Fixed some unused imports in categories\n4cd76af repeat some #8389 edits to make a cleaner merge with 6.2.beta4\nece5c97 Axioms: fixed merge with #15873\nacd58b3 Fix failing tests due to little conflict when merging with #12141 (finite dimensional algebra)\n977a940 Axioms: minor improvements here and there, and reworked explanations about the binding behavior of categories with axioms\nb957acf Axioms: finished draft of documentation, implementation of `Distributive`, ...\ne19385e Axioms: various improvements + complete description of the algorithms for computing joins and adding axioms\n4c0c9a4 Specify that the CartesianProduct functor is about finite cartesian products\n08d863b Axioms: partial documentation of the join algorithm + small simplification of its implementation\n770324b Axioms: improved DivisionRings.Finite_extra_super_categories + documentation\nbe52d1c Axioms: fixed typo in two doctests of the primer\nc7ea9a1 Axioms: standardized _base_category_class_and_axiom to always be a tuple\n48dc0c06 Category with axioms: workaround limitation in lazy import to avoid lazy reimporting over and over\n478de48 Categories with axioms: improved names for the protocol to recover how _base_category_class_and_axiom was set.\n32b3c4e Improved the guessing logic for categories with axioms + typo fixes\nec34036 Fixed failing doctest in integer_mod_ring.py from (my bad) merging.\n100e66f Trac 10963: Provide doctests for the changed behaviour of a lazy class attribute\nbdefe0d trac 10963: Avoid access to a lazy class attribute while it is being computed\n8eaf51a Trac 10963: Avoid infinite recursion in cached function\n0c907cf Reverted cached_function to weak_cached_function.\n588c276 Fixed ncsym/bases.py doctest.\na410d05 typos and unused imports\nb21dde5 duplication introduced in my own merge removed\n```\n\nIn practice, it might be easier to make a diff w.r.t. what you had\nreviewed last fall (typically 80d55fe+develop), and ignore the\ndocumentation pieces (which should be the largest piece).\n\nLet me know if you need more details!\n\nI still have to check Darij's and Peter's latest commits.\n\nCheers,\n                                    Nicolas",
    "created_at": "2014-04-22T17:52:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109459",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:641'></a>
Hi Simon!

Replying to [SimonKing](#comment%3A638):
> on sage-devel, you wrote that you could make a list of commits that need a technical review for this ticket to be finished. Can you post this list, please?

The following list should be correct (I took the log between develop
and my branch, and removed commits about documentation or merges)::

```
4580db1 Trac 10963: fixed trivial doctest failures
367d72e Trac 10963: fixed trivial doctest failure
7db4ef0 Trac 10963: Fixed repr for the symmetric group algebra by improving a bit the generic repr methods in the categories
e1110da Trac 10963: added little note in Category._super_categories
d6a0e60 Axioms: Fixed some unused imports in categories
4cd76af repeat some #8389 edits to make a cleaner merge with 6.2.beta4
ece5c97 Axioms: fixed merge with #15873
acd58b3 Fix failing tests due to little conflict when merging with #12141 (finite dimensional algebra)
977a940 Axioms: minor improvements here and there, and reworked explanations about the binding behavior of categories with axioms
b957acf Axioms: finished draft of documentation, implementation of `Distributive`, ...
e19385e Axioms: various improvements + complete description of the algorithms for computing joins and adding axioms
4c0c9a4 Specify that the CartesianProduct functor is about finite cartesian products
08d863b Axioms: partial documentation of the join algorithm + small simplification of its implementation
770324b Axioms: improved DivisionRings.Finite_extra_super_categories + documentation
be52d1c Axioms: fixed typo in two doctests of the primer
c7ea9a1 Axioms: standardized _base_category_class_and_axiom to always be a tuple
48dc0c06 Category with axioms: workaround limitation in lazy import to avoid lazy reimporting over and over
478de48 Categories with axioms: improved names for the protocol to recover how _base_category_class_and_axiom was set.
32b3c4e Improved the guessing logic for categories with axioms + typo fixes
ec34036 Fixed failing doctest in integer_mod_ring.py from (my bad) merging.
100e66f Trac 10963: Provide doctests for the changed behaviour of a lazy class attribute
bdefe0d trac 10963: Avoid access to a lazy class attribute while it is being computed
8eaf51a Trac 10963: Avoid infinite recursion in cached function
0c907cf Reverted cached_function to weak_cached_function.
588c276 Fixed ncsym/bases.py doctest.
a410d05 typos and unused imports
b21dde5 duplication introduced in my own merge removed
```

In practice, it might be easier to make a diff w.r.t. what you had
reviewed last fall (typically 80d55fe+develop), and ignore the
documentation pieces (which should be the largest piece).

Let me know if you need more details!

I still have to check Darij's and Peter's latest commits.

Cheers,
                                    Nicolas



---

archive/issue_comments_109460.json:
```json
{
    "body": "**Changing commit** from \"[18a4a74779e45d5ac8662affc40d46b773e3c495](https://github.com/sagemath/sagetrac-mirror/commit/18a4a74779e45d5ac8662affc40d46b773e3c495)\" to \"[5c271c939a5fe9527e3c654f12653044ea3c19a9](https://github.com/sagemath/sagetrac-mirror/commit/5c271c939a5fe9527e3c654f12653044ea3c19a9)\".",
    "created_at": "2014-04-22T21:54:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109460",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[18a4a74779e45d5ac8662affc40d46b773e3c495](https://github.com/sagemath/sagetrac-mirror/commit/18a4a74779e45d5ac8662affc40d46b773e3c495)" to "[5c271c939a5fe9527e3c654f12653044ea3c19a9](https://github.com/sagemath/sagetrac-mirror/commit/5c271c939a5fe9527e3c654f12653044ea3c19a9)".



---

archive/issue_comments_109461.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5c271c939a5fe9527e3c654f12653044ea3c19a9\">5c271c9</a></td><td><code>Trac 10963: improve explanation of Sage notion of subcategories (proofreading/rewording)</code></td></tr></table>\n",
    "created_at": "2014-04-22T21:54:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109461",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5c271c939a5fe9527e3c654f12653044ea3c19a9">5c271c9</a></td><td><code>Trac 10963: improve explanation of Sage notion of subcategories (proofreading/rewording)</code></td></tr></table>




---

archive/issue_comments_109462.json:
```json
{
    "body": "<a id='comment:643'></a>\nReplying to [pbruin](#comment%3A640):\n> I have just pushed a commit for this; I hope that it strikes the right balance,\n\nYes it does! Thanks much for the much improved formulation. I further\nreorganized the sentences to make that section more concise and to the\npoint. Please double check.\n\n> and that the note referring to a possible future change in #16183 is appropriate.\n\nDefinitely.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-04-22T21:59:58Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109462",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:643'></a>
Replying to [pbruin](#comment%3A640):
> I have just pushed a commit for this; I hope that it strikes the right balance,

Yes it does! Thanks much for the much improved formulation. I further
reorganized the sentences to make that section more concise and to the
point. Please double check.

> and that the note referring to a possible future change in #16183 is appropriate.

Definitely.

Cheers,
                              Nicolas



---

archive/issue_comments_109463.json:
```json
{
    "body": "**Changing commit** from \"[5c271c939a5fe9527e3c654f12653044ea3c19a9](https://github.com/sagemath/sagetrac-mirror/commit/5c271c939a5fe9527e3c654f12653044ea3c19a9)\" to \"[d0664d163996065e9638c4462894744af02afb9e](https://github.com/sagemath/sagetrac-mirror/commit/d0664d163996065e9638c4462894744af02afb9e)\".",
    "created_at": "2014-04-22T22:13:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109463",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[5c271c939a5fe9527e3c654f12653044ea3c19a9](https://github.com/sagemath/sagetrac-mirror/commit/5c271c939a5fe9527e3c654f12653044ea3c19a9)" to "[d0664d163996065e9638c4462894744af02afb9e](https://github.com/sagemath/sagetrac-mirror/commit/d0664d163996065e9638c4462894744af02afb9e)".



---

archive/issue_comments_109464.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d0664d163996065e9638c4462894744af02afb9e\">d0664d1</a></td><td><code>Trac 10963: three typo fixes suggested by Darij</code></td></tr></table>\n",
    "created_at": "2014-04-22T22:13:50Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109464",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d0664d163996065e9638c4462894744af02afb9e">d0664d1</a></td><td><code>Trac 10963: three typo fixes suggested by Darij</code></td></tr></table>




---

archive/issue_comments_109465.json:
```json
{
    "body": "<a id='comment:5'></a>\nWho merges? (I want to avoid another diamond of merges...)",
    "created_at": "2014-04-23T04:45:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109465",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:5'></a>
Who merges? (I want to avoid another diamond of merges...)



---

archive/issue_comments_109466.json:
```json
{
    "body": "**Changing commit** from \"[d0664d163996065e9638c4462894744af02afb9e](https://github.com/sagemath/sagetrac-mirror/commit/d0664d163996065e9638c4462894744af02afb9e)\" to \"[3009d90f00b751fbfa0436423b40b62746b8d7e7](https://github.com/sagemath/sagetrac-mirror/commit/3009d90f00b751fbfa0436423b40b62746b8d7e7)\".",
    "created_at": "2014-04-23T08:04:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109466",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[d0664d163996065e9638c4462894744af02afb9e](https://github.com/sagemath/sagetrac-mirror/commit/d0664d163996065e9638c4462894744af02afb9e)" to "[3009d90f00b751fbfa0436423b40b62746b8d7e7](https://github.com/sagemath/sagetrac-mirror/commit/3009d90f00b751fbfa0436423b40b62746b8d7e7)".



---

archive/issue_comments_109467.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3009d90f00b751fbfa0436423b40b62746b8d7e7\">3009d90</a></td><td><code>Trac 10963: little documentation improvements suggested by Darij</code></td></tr></table>\n",
    "created_at": "2014-04-23T08:04:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109467",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3009d90f00b751fbfa0436423b40b62746b8d7e7">3009d90</a></td><td><code>Trac 10963: little documentation improvements suggested by Darij</code></td></tr></table>




---

archive/issue_comments_109468.json:
```json
{
    "body": "**Changing commit** from \"[3009d90f00b751fbfa0436423b40b62746b8d7e7](https://github.com/sagemath/sagetrac-mirror/commit/3009d90f00b751fbfa0436423b40b62746b8d7e7)\" to \"[02db670a7fea03736327c93f31bf9a657f99b68d](https://github.com/sagemath/sagetrac-mirror/commit/02db670a7fea03736327c93f31bf9a657f99b68d)\".",
    "created_at": "2014-04-23T08:24:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109468",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[3009d90f00b751fbfa0436423b40b62746b8d7e7](https://github.com/sagemath/sagetrac-mirror/commit/3009d90f00b751fbfa0436423b40b62746b8d7e7)" to "[02db670a7fea03736327c93f31bf9a657f99b68d](https://github.com/sagemath/sagetrac-mirror/commit/02db670a7fea03736327c93f31bf9a657f99b68d)".



---

archive/issue_comments_109469.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/02db670a7fea03736327c93f31bf9a657f99b68d\">02db670</a></td><td><code>Trac 10963: minor edits to \"On the category hierarchy\"</code></td></tr></table>\n",
    "created_at": "2014-04-23T08:24:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109469",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/02db670a7fea03736327c93f31bf9a657f99b68d">02db670</a></td><td><code>Trac 10963: minor edits to "On the category hierarchy"</code></td></tr></table>




---

archive/issue_comments_109470.json:
```json
{
    "body": "<a id='comment:648'></a>\nReplying to [git](#comment%3A647):\n> Branch pushed to git repo; I updated commit sha1. **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/02db670a7fea03736327c93f31bf9a657f99b68d\">02db670</a></td><td><code>Trac 10963: minor edits to \"On the category hierarchy\"</code></td></tr></table>\n\nThanks Peter. Reviewed.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3bb48cb009c0df9570272b5837513de4793dfa82\">3bb48cb</a></td><td><code>Merge branch 'develop = 6.2.rc0' into categories/axioms-10963</code></td></tr></table>\n",
    "created_at": "2014-04-24T10:18:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109470",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:648'></a>
Replying to [git](#comment%3A647):
> Branch pushed to git repo; I updated commit sha1. **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/02db670a7fea03736327c93f31bf9a657f99b68d">02db670</a></td><td><code>Trac 10963: minor edits to "On the category hierarchy"</code></td></tr></table>

Thanks Peter. Reviewed.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3bb48cb009c0df9570272b5837513de4793dfa82">3bb48cb</a></td><td><code>Merge branch 'develop = 6.2.rc0' into categories/axioms-10963</code></td></tr></table>




---

archive/issue_comments_109471.json:
```json
{
    "body": "**Changing commit** from \"[02db670a7fea03736327c93f31bf9a657f99b68d](https://github.com/sagemath/sagetrac-mirror/commit/02db670a7fea03736327c93f31bf9a657f99b68d)\" to \"[3bb48cb009c0df9570272b5837513de4793dfa82](https://github.com/sagemath/sagetrac-mirror/commit/3bb48cb009c0df9570272b5837513de4793dfa82)\".",
    "created_at": "2014-04-24T10:18:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109471",
    "user": "https://github.com/nthiery"
}
```

**Changing commit** from "[02db670a7fea03736327c93f31bf9a657f99b68d](https://github.com/sagemath/sagetrac-mirror/commit/02db670a7fea03736327c93f31bf9a657f99b68d)" to "[3bb48cb009c0df9570272b5837513de4793dfa82](https://github.com/sagemath/sagetrac-mirror/commit/3bb48cb009c0df9570272b5837513de4793dfa82)".



---

archive/issue_comments_109472.json:
```json
{
    "body": "**Changing work issues** from \"merge with #15801 once things stabilize\" to \"To be merged simultaneously with #15801\".",
    "created_at": "2014-04-24T10:20:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109472",
    "user": "https://github.com/nthiery"
}
```

**Changing work issues** from "merge with #15801 once things stabilize" to "To be merged simultaneously with #15801".



---

archive/issue_events_085489.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2014-04-24T10:20:23Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85489"
}
```



---

archive/issue_events_085490.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2014-04-24T10:20:23Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85490"
}
```



---

archive/issue_comments_109473.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d6a21a1c02328d6d43e666addd0a55abc990db55\">d6a21a1</a></td><td><code>various fixes to subquotient doc and some other changes -- PLEASE CHECK as these may mirror my misunderstandings</code></td></tr></table>\n",
    "created_at": "2014-04-24T20:14:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109473",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d6a21a1c02328d6d43e666addd0a55abc990db55">d6a21a1</a></td><td><code>various fixes to subquotient doc and some other changes -- PLEASE CHECK as these may mirror my misunderstandings</code></td></tr></table>




---

archive/issue_comments_109474.json:
```json
{
    "body": "**Changing commit** from \"[3bb48cb009c0df9570272b5837513de4793dfa82](https://github.com/sagemath/sagetrac-mirror/commit/3bb48cb009c0df9570272b5837513de4793dfa82)\" to \"[d6a21a1c02328d6d43e666addd0a55abc990db55](https://github.com/sagemath/sagetrac-mirror/commit/d6a21a1c02328d6d43e666addd0a55abc990db55)\".",
    "created_at": "2014-04-24T20:14:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109474",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[3bb48cb009c0df9570272b5837513de4793dfa82](https://github.com/sagemath/sagetrac-mirror/commit/3bb48cb009c0df9570272b5837513de4793dfa82)" to "[d6a21a1c02328d6d43e666addd0a55abc990db55](https://github.com/sagemath/sagetrac-mirror/commit/d6a21a1c02328d6d43e666addd0a55abc990db55)".



---

archive/issue_comments_109475.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d085c0396bfc084c1242c4b988ebcd6860a32008\">d085c03</a></td><td><code>more minor edits</code></td></tr></table>\n",
    "created_at": "2014-04-24T20:30:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109475",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d085c0396bfc084c1242c4b988ebcd6860a32008">d085c03</a></td><td><code>more minor edits</code></td></tr></table>




---

archive/issue_comments_109476.json:
```json
{
    "body": "**Changing commit** from \"[d6a21a1c02328d6d43e666addd0a55abc990db55](https://github.com/sagemath/sagetrac-mirror/commit/d6a21a1c02328d6d43e666addd0a55abc990db55)\" to \"[d085c0396bfc084c1242c4b988ebcd6860a32008](https://github.com/sagemath/sagetrac-mirror/commit/d085c0396bfc084c1242c4b988ebcd6860a32008)\".",
    "created_at": "2014-04-24T20:30:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109476",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[d6a21a1c02328d6d43e666addd0a55abc990db55](https://github.com/sagemath/sagetrac-mirror/commit/d6a21a1c02328d6d43e666addd0a55abc990db55)" to "[d085c0396bfc084c1242c4b988ebcd6860a32008](https://github.com/sagemath/sagetrac-mirror/commit/d085c0396bfc084c1242c4b988ebcd6860a32008)".



---

archive/issue_comments_109477.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b0f0ac2292c26374467d617229f14ec5c6c6bbd8\">b0f0ac2</a></td><td><code>further corrections (in my opinion) on subquotients</code></td></tr></table>\n",
    "created_at": "2014-04-24T20:37:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109477",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b0f0ac2292c26374467d617229f14ec5c6c6bbd8">b0f0ac2</a></td><td><code>further corrections (in my opinion) on subquotients</code></td></tr></table>




---

archive/issue_comments_109478.json:
```json
{
    "body": "**Changing commit** from \"[d085c0396bfc084c1242c4b988ebcd6860a32008](https://github.com/sagemath/sagetrac-mirror/commit/d085c0396bfc084c1242c4b988ebcd6860a32008)\" to \"[b0f0ac2292c26374467d617229f14ec5c6c6bbd8](https://github.com/sagemath/sagetrac-mirror/commit/b0f0ac2292c26374467d617229f14ec5c6c6bbd8)\".",
    "created_at": "2014-04-24T20:37:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109478",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[d085c0396bfc084c1242c4b988ebcd6860a32008](https://github.com/sagemath/sagetrac-mirror/commit/d085c0396bfc084c1242c4b988ebcd6860a32008)" to "[b0f0ac2292c26374467d617229f14ec5c6c6bbd8](https://github.com/sagemath/sagetrac-mirror/commit/b0f0ac2292c26374467d617229f14ec5c6c6bbd8)".



---

archive/issue_comments_109479.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1f4b58b7b37090b77d36c06ceabe6a2066b73251\">1f4b58b</a></td><td><code>Trac 10963: proofread Darij's changes</code></td></tr></table>\n",
    "created_at": "2014-04-24T23:54:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109479",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1f4b58b7b37090b77d36c06ceabe6a2066b73251">1f4b58b</a></td><td><code>Trac 10963: proofread Darij's changes</code></td></tr></table>




---

archive/issue_comments_109480.json:
```json
{
    "body": "**Changing commit** from \"[b0f0ac2292c26374467d617229f14ec5c6c6bbd8](https://github.com/sagemath/sagetrac-mirror/commit/b0f0ac2292c26374467d617229f14ec5c6c6bbd8)\" to \"[1f4b58b7b37090b77d36c06ceabe6a2066b73251](https://github.com/sagemath/sagetrac-mirror/commit/1f4b58b7b37090b77d36c06ceabe6a2066b73251)\".",
    "created_at": "2014-04-24T23:54:53Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109480",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[b0f0ac2292c26374467d617229f14ec5c6c6bbd8](https://github.com/sagemath/sagetrac-mirror/commit/b0f0ac2292c26374467d617229f14ec5c6c6bbd8)" to "[1f4b58b7b37090b77d36c06ceabe6a2066b73251](https://github.com/sagemath/sagetrac-mirror/commit/1f4b58b7b37090b77d36c06ceabe6a2066b73251)".



---

archive/issue_comments_109481.json:
```json
{
    "body": "**Changing commit** from \"[1f4b58b7b37090b77d36c06ceabe6a2066b73251](https://github.com/sagemath/sagetrac-mirror/commit/1f4b58b7b37090b77d36c06ceabe6a2066b73251)\" to \"[99df3fa4c2932045236686dd2baaf236e9e3c01c](https://github.com/sagemath/sagetrac-mirror/commit/99df3fa4c2932045236686dd2baaf236e9e3c01c)\".",
    "created_at": "2014-04-25T03:48:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109481",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1f4b58b7b37090b77d36c06ceabe6a2066b73251](https://github.com/sagemath/sagetrac-mirror/commit/1f4b58b7b37090b77d36c06ceabe6a2066b73251)" to "[99df3fa4c2932045236686dd2baaf236e9e3c01c](https://github.com/sagemath/sagetrac-mirror/commit/99df3fa4c2932045236686dd2baaf236e9e3c01c)".



---

archive/issue_comments_109482.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/99df3fa4c2932045236686dd2baaf236e9e3c01c\">99df3fa</a></td><td><code>some more edits</code></td></tr></table>\n",
    "created_at": "2014-04-25T03:48:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109482",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/99df3fa4c2932045236686dd2baaf236e9e3c01c">99df3fa</a></td><td><code>some more edits</code></td></tr></table>




---

archive/issue_comments_109483.json:
```json
{
    "body": "**Changing commit** from \"[99df3fa4c2932045236686dd2baaf236e9e3c01c](https://github.com/sagemath/sagetrac-mirror/commit/99df3fa4c2932045236686dd2baaf236e9e3c01c)\" to \"[c79f266577c4e9058e5323411dc8f65382e3f74a](https://github.com/sagemath/sagetrac-mirror/commit/c79f266577c4e9058e5323411dc8f65382e3f74a)\".",
    "created_at": "2014-04-25T09:22:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109483",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[99df3fa4c2932045236686dd2baaf236e9e3c01c](https://github.com/sagemath/sagetrac-mirror/commit/99df3fa4c2932045236686dd2baaf236e9e3c01c)" to "[c79f266577c4e9058e5323411dc8f65382e3f74a](https://github.com/sagemath/sagetrac-mirror/commit/c79f266577c4e9058e5323411dc8f65382e3f74a)".



---

archive/issue_comments_109484.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c79f266577c4e9058e5323411dc8f65382e3f74a\">c79f266</a></td><td><code>Trac 10963: proofread Darij's changes</code></td></tr></table>\n",
    "created_at": "2014-04-25T09:22:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109484",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c79f266577c4e9058e5323411dc8f65382e3f74a">c79f266</a></td><td><code>Trac 10963: proofread Darij's changes</code></td></tr></table>




---

archive/issue_comments_109485.json:
```json
{
    "body": "**Changing commit** from \"[c79f266577c4e9058e5323411dc8f65382e3f74a](https://github.com/sagemath/sagetrac-mirror/commit/c79f266577c4e9058e5323411dc8f65382e3f74a)\" to \"[1c7c1450c548cbca70b6364d37694e7387b69d99](https://github.com/sagemath/sagetrac-mirror/commit/1c7c1450c548cbca70b6364d37694e7387b69d99)\".",
    "created_at": "2014-04-25T13:30:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109485",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[c79f266577c4e9058e5323411dc8f65382e3f74a](https://github.com/sagemath/sagetrac-mirror/commit/c79f266577c4e9058e5323411dc8f65382e3f74a)" to "[1c7c1450c548cbca70b6364d37694e7387b69d99](https://github.com/sagemath/sagetrac-mirror/commit/1c7c1450c548cbca70b6364d37694e7387b69d99)".



---

archive/issue_comments_109486.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1c7c1450c548cbca70b6364d37694e7387b69d99\">1c7c145</a></td><td><code>Trac 10963: proofreading of Darij's doc change and minor further edits</code></td></tr></table>\n",
    "created_at": "2014-04-25T13:30:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109486",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1c7c1450c548cbca70b6364d37694e7387b69d99">1c7c145</a></td><td><code>Trac 10963: proofreading of Darij's doc change and minor further edits</code></td></tr></table>




---

archive/issue_comments_109487.json:
```json
{
    "body": "**Changing commit** from \"[1c7c1450c548cbca70b6364d37694e7387b69d99](https://github.com/sagemath/sagetrac-mirror/commit/1c7c1450c548cbca70b6364d37694e7387b69d99)\" to \"[d48dee44104147bf3ca41b8d27aee336cec23e88](https://github.com/sagemath/sagetrac-mirror/commit/d48dee44104147bf3ca41b8d27aee336cec23e88)\".",
    "created_at": "2014-04-25T14:17:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109487",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1c7c1450c548cbca70b6364d37694e7387b69d99](https://github.com/sagemath/sagetrac-mirror/commit/1c7c1450c548cbca70b6364d37694e7387b69d99)" to "[d48dee44104147bf3ca41b8d27aee336cec23e88](https://github.com/sagemath/sagetrac-mirror/commit/d48dee44104147bf3ca41b8d27aee336cec23e88)".



---

archive/issue_comments_109488.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d48dee44104147bf3ca41b8d27aee336cec23e88\">d48dee4</a></td><td><code>Trac 10963: trivial doctest update w.r.t. #16125 (Implement method `_an_element_` for Words)</code></td></tr></table>\n",
    "created_at": "2014-04-25T14:17:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109488",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d48dee44104147bf3ca41b8d27aee336cec23e88">d48dee4</a></td><td><code>Trac 10963: trivial doctest update w.r.t. #16125 (Implement method `_an_element_` for Words)</code></td></tr></table>




---

archive/issue_comments_109489.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3\">7d3cd9b</a></td><td><code>Trac 10963: trivial doctest update w.r.t. merge of develop (matrix spaces now have one more method)</code></td></tr></table>\n",
    "created_at": "2014-04-25T14:19:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109489",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3">7d3cd9b</a></td><td><code>Trac 10963: trivial doctest update w.r.t. merge of develop (matrix spaces now have one more method)</code></td></tr></table>




---

archive/issue_comments_109490.json:
```json
{
    "body": "**Changing commit** from \"[d48dee44104147bf3ca41b8d27aee336cec23e88](https://github.com/sagemath/sagetrac-mirror/commit/d48dee44104147bf3ca41b8d27aee336cec23e88)\" to \"[7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3](https://github.com/sagemath/sagetrac-mirror/commit/7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3)\".",
    "created_at": "2014-04-25T14:19:07Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109490",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[d48dee44104147bf3ca41b8d27aee336cec23e88](https://github.com/sagemath/sagetrac-mirror/commit/d48dee44104147bf3ca41b8d27aee336cec23e88)" to "[7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3](https://github.com/sagemath/sagetrac-mirror/commit/7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3)".



---

archive/issue_comments_109491.json:
```json
{
    "body": "**Changing commit** from \"[7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3](https://github.com/sagemath/sagetrac-mirror/commit/7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3)\" to \"[a432952112158f8df6a060f896c47a8416a0c053](https://github.com/sagemath/sagetrac-mirror/commit/a432952112158f8df6a060f896c47a8416a0c053)\".",
    "created_at": "2014-04-25T14:29:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109491",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3](https://github.com/sagemath/sagetrac-mirror/commit/7d3cd9b7163566b75f1c24ea4703f070e7f0c1e3)" to "[a432952112158f8df6a060f896c47a8416a0c053](https://github.com/sagemath/sagetrac-mirror/commit/a432952112158f8df6a060f896c47a8416a0c053)".



---

archive/issue_comments_109492.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a432952112158f8df6a060f896c47a8416a0c053\">a432952</a></td><td><code>Trac 10963: trivial doctest update w.r.t. #15240 (Switch lattice polytopes to point collections)</code></td></tr></table>\n",
    "created_at": "2014-04-25T14:29:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109492",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a432952112158f8df6a060f896c47a8416a0c053">a432952</a></td><td><code>Trac 10963: trivial doctest update w.r.t. #15240 (Switch lattice polytopes to point collections)</code></td></tr></table>




---

archive/issue_comments_109493.json:
```json
{
    "body": "**Changing commit** from \"[a432952112158f8df6a060f896c47a8416a0c053](https://github.com/sagemath/sagetrac-mirror/commit/a432952112158f8df6a060f896c47a8416a0c053)\" to \"[dc87588985049c54a0074c39c081cf06432eae79](https://github.com/sagemath/sagetrac-mirror/commit/dc87588985049c54a0074c39c081cf06432eae79)\".",
    "created_at": "2014-04-25T19:21:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109493",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[a432952112158f8df6a060f896c47a8416a0c053](https://github.com/sagemath/sagetrac-mirror/commit/a432952112158f8df6a060f896c47a8416a0c053)" to "[dc87588985049c54a0074c39c081cf06432eae79](https://github.com/sagemath/sagetrac-mirror/commit/dc87588985049c54a0074c39c081cf06432eae79)".



---

archive/issue_comments_109494.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/dc87588985049c54a0074c39c081cf06432eae79\">dc87588</a></td><td><code>clarifying Subobjects and Quotients interfaces</code></td></tr></table>\n",
    "created_at": "2014-04-25T19:21:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109494",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/dc87588985049c54a0074c39c081cf06432eae79">dc87588</a></td><td><code>clarifying Subobjects and Quotients interfaces</code></td></tr></table>




---

archive/issue_comments_109495.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/be5150fc941f1b9261ed4a8401699dff5d21c432\">be5150f</a></td><td><code>some questions</code></td></tr></table>\n",
    "created_at": "2014-04-25T19:35:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109495",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/be5150fc941f1b9261ed4a8401699dff5d21c432">be5150f</a></td><td><code>some questions</code></td></tr></table>




---

archive/issue_comments_109496.json:
```json
{
    "body": "**Changing commit** from \"[dc87588985049c54a0074c39c081cf06432eae79](https://github.com/sagemath/sagetrac-mirror/commit/dc87588985049c54a0074c39c081cf06432eae79)\" to \"[be5150fc941f1b9261ed4a8401699dff5d21c432](https://github.com/sagemath/sagetrac-mirror/commit/be5150fc941f1b9261ed4a8401699dff5d21c432)\".",
    "created_at": "2014-04-25T19:35:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109496",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[dc87588985049c54a0074c39c081cf06432eae79](https://github.com/sagemath/sagetrac-mirror/commit/dc87588985049c54a0074c39c081cf06432eae79)" to "[be5150fc941f1b9261ed4a8401699dff5d21c432](https://github.com/sagemath/sagetrac-mirror/commit/be5150fc941f1b9261ed4a8401699dff5d21c432)".



---

archive/issue_comments_109497.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a\">3a0e8f7</a></td><td><code>clarification of my clarification</code></td></tr></table>\n",
    "created_at": "2014-04-25T19:44:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109497",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a">3a0e8f7</a></td><td><code>clarification of my clarification</code></td></tr></table>




---

archive/issue_comments_109498.json:
```json
{
    "body": "**Changing commit** from \"[be5150fc941f1b9261ed4a8401699dff5d21c432](https://github.com/sagemath/sagetrac-mirror/commit/be5150fc941f1b9261ed4a8401699dff5d21c432)\" to \"[3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a](https://github.com/sagemath/sagetrac-mirror/commit/3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a)\".",
    "created_at": "2014-04-25T19:44:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109498",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[be5150fc941f1b9261ed4a8401699dff5d21c432](https://github.com/sagemath/sagetrac-mirror/commit/be5150fc941f1b9261ed4a8401699dff5d21c432)" to "[3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a](https://github.com/sagemath/sagetrac-mirror/commit/3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a)".



---

archive/issue_comments_109499.json:
```json
{
    "body": "**Changing commit** from \"[3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a](https://github.com/sagemath/sagetrac-mirror/commit/3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a)\" to \"[86235d4269b7eaf76f0109a38e71841c1fe277b2](https://github.com/sagemath/sagetrac-mirror/commit/86235d4269b7eaf76f0109a38e71841c1fe277b2)\".",
    "created_at": "2014-04-25T20:18:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109499",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a](https://github.com/sagemath/sagetrac-mirror/commit/3a0e8f7bb892ac9b01fd03fbe15e01ca1f35859a)" to "[86235d4269b7eaf76f0109a38e71841c1fe277b2](https://github.com/sagemath/sagetrac-mirror/commit/86235d4269b7eaf76f0109a38e71841c1fe277b2)".



---

archive/issue_comments_109500.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/86235d4269b7eaf76f0109a38e71841c1fe277b2\">86235d4</a></td><td><code>Trac 10963: clarification^3 about subobjects</code></td></tr></table>\n",
    "created_at": "2014-04-25T20:18:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109500",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/86235d4269b7eaf76f0109a38e71841c1fe277b2">86235d4</a></td><td><code>Trac 10963: clarification^3 about subobjects</code></td></tr></table>




---

archive/issue_comments_109501.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/08ea0692cde064ffd54d8c5f195dc499e4d1faaa\">08ea069</a></td><td><code>Trac 10963: suppressed now useless category example MyGroupAlgebra + tiny doc improvement</code></td></tr></table>\n",
    "created_at": "2014-04-25T20:26:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109501",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/08ea0692cde064ffd54d8c5f195dc499e4d1faaa">08ea069</a></td><td><code>Trac 10963: suppressed now useless category example MyGroupAlgebra + tiny doc improvement</code></td></tr></table>




---

archive/issue_comments_109502.json:
```json
{
    "body": "**Changing commit** from \"[86235d4269b7eaf76f0109a38e71841c1fe277b2](https://github.com/sagemath/sagetrac-mirror/commit/86235d4269b7eaf76f0109a38e71841c1fe277b2)\" to \"[08ea0692cde064ffd54d8c5f195dc499e4d1faaa](https://github.com/sagemath/sagetrac-mirror/commit/08ea0692cde064ffd54d8c5f195dc499e4d1faaa)\".",
    "created_at": "2014-04-25T20:26:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109502",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[86235d4269b7eaf76f0109a38e71841c1fe277b2](https://github.com/sagemath/sagetrac-mirror/commit/86235d4269b7eaf76f0109a38e71841c1fe277b2)" to "[08ea0692cde064ffd54d8c5f195dc499e4d1faaa](https://github.com/sagemath/sagetrac-mirror/commit/08ea0692cde064ffd54d8c5f195dc499e4d1faaa)".



---

archive/issue_comments_109503.json:
```json
{
    "body": "<a id='comment:5'></a>\nFor the record, `make ptestlong` passes smoothly with the current branch together with the little change mentionned on [#15919 comment:16](https://github.com/sagemath/sage/issues/15919#comment:16).",
    "created_at": "2014-04-25T20:59:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109503",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>
For the record, `make ptestlong` passes smoothly with the current branch together with the little change mentionned on [#15919 comment:16](https://github.com/sagemath/sage/issues/15919#comment:16).



---

archive/issue_comments_109504.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1441304d4d256387f03ed7d23fdff264acafedb1\">1441304</a></td><td><code>some final fixes</code></td></tr></table>\n",
    "created_at": "2014-04-25T22:50:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109504",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1441304d4d256387f03ed7d23fdff264acafedb1">1441304</a></td><td><code>some final fixes</code></td></tr></table>




---

archive/issue_comments_109505.json:
```json
{
    "body": "**Changing commit** from \"[08ea0692cde064ffd54d8c5f195dc499e4d1faaa](https://github.com/sagemath/sagetrac-mirror/commit/08ea0692cde064ffd54d8c5f195dc499e4d1faaa)\" to \"[1441304d4d256387f03ed7d23fdff264acafedb1](https://github.com/sagemath/sagetrac-mirror/commit/1441304d4d256387f03ed7d23fdff264acafedb1)\".",
    "created_at": "2014-04-25T22:50:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109505",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[08ea0692cde064ffd54d8c5f195dc499e4d1faaa](https://github.com/sagemath/sagetrac-mirror/commit/08ea0692cde064ffd54d8c5f195dc499e4d1faaa)" to "[1441304d4d256387f03ed7d23fdff264acafedb1](https://github.com/sagemath/sagetrac-mirror/commit/1441304d4d256387f03ed7d23fdff264acafedb1)".



---

archive/issue_comments_109506.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/16ec0f394ada4e9e101259934a03d1d6175fc727\">16ec0f3</a></td><td><code>some more question(able edits)</code></td></tr></table>\n",
    "created_at": "2014-04-26T06:10:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109506",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/16ec0f394ada4e9e101259934a03d1d6175fc727">16ec0f3</a></td><td><code>some more question(able edits)</code></td></tr></table>




---

archive/issue_comments_109507.json:
```json
{
    "body": "**Changing commit** from \"[1441304d4d256387f03ed7d23fdff264acafedb1](https://github.com/sagemath/sagetrac-mirror/commit/1441304d4d256387f03ed7d23fdff264acafedb1)\" to \"[16ec0f394ada4e9e101259934a03d1d6175fc727](https://github.com/sagemath/sagetrac-mirror/commit/16ec0f394ada4e9e101259934a03d1d6175fc727)\".",
    "created_at": "2014-04-26T06:10:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109507",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1441304d4d256387f03ed7d23fdff264acafedb1](https://github.com/sagemath/sagetrac-mirror/commit/1441304d4d256387f03ed7d23fdff264acafedb1)" to "[16ec0f394ada4e9e101259934a03d1d6175fc727](https://github.com/sagemath/sagetrac-mirror/commit/16ec0f394ada4e9e101259934a03d1d6175fc727)".



---

archive/issue_comments_109508.json:
```json
{
    "body": "<a id='comment:8'></a>\nI'm done with my sightseeing tour through this branch. I am not calling it a review because that would imply some kind of systematic approach (which I never followed), but I hope it was nevertheless of use. My general impression is that the code introduced in this ticket is rather good, and it is definitely a worthy addition to Sage (once speed regressions are fixed) -- among other things, it fixes two scary and still mysterious bugs (#15475), which is not even advertised; the doc is now very readable. This does not mean that all issues I have brought up in this discussion are resolved or invalid; I am hoping that the remainder of them gets dealt with in other places (#15647 and #15927 are two things that come into my mind, but I'd also want a task for making examples for the new functionality). It seems to me that a majority of them are design flaws and quality problems inherited from the old code (which is, frankly, bad as far as I can tell -- but I know few places in Sage where old code is good). Nicolas had good reasons to be annoyed by me raising this dust in a ticket not really related -- it's just that for me, there was no difference between old and new code, since I was seeing most of src/sage/categories for the first time. Many thanks to Nicolas and Simon for the quick and thorough reponses and explanations on my edits. I'm wishing I could take some more looks at the category_with_axiom algorithm, but I fear I am really out of time for this now...\n\nThere's one final commit waiting for one of you, and one final question: is src/sage/categories/examples/hopf_algebras_with_basis.py still up-to-date? I'm not advocating for deletion, just asking if it is misleading in any way. While it shares much code with the now-removed group algebra examples and also is not in `GroupAlgebras`, it isn't necessarily wrong (noone said it had to be a GroupAlgebra anyway).\n\nEDIT: *two* final commits. Seriously. I should learn counting...\n\nThank you once again, and here's hoping for a speedy merge...",
    "created_at": "2014-04-26T06:23:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109508",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:8'></a>
I'm done with my sightseeing tour through this branch. I am not calling it a review because that would imply some kind of systematic approach (which I never followed), but I hope it was nevertheless of use. My general impression is that the code introduced in this ticket is rather good, and it is definitely a worthy addition to Sage (once speed regressions are fixed) -- among other things, it fixes two scary and still mysterious bugs (#15475), which is not even advertised; the doc is now very readable. This does not mean that all issues I have brought up in this discussion are resolved or invalid; I am hoping that the remainder of them gets dealt with in other places (#15647 and #15927 are two things that come into my mind, but I'd also want a task for making examples for the new functionality). It seems to me that a majority of them are design flaws and quality problems inherited from the old code (which is, frankly, bad as far as I can tell -- but I know few places in Sage where old code is good). Nicolas had good reasons to be annoyed by me raising this dust in a ticket not really related -- it's just that for me, there was no difference between old and new code, since I was seeing most of src/sage/categories for the first time. Many thanks to Nicolas and Simon for the quick and thorough reponses and explanations on my edits. I'm wishing I could take some more looks at the category_with_axiom algorithm, but I fear I am really out of time for this now...

There's one final commit waiting for one of you, and one final question: is src/sage/categories/examples/hopf_algebras_with_basis.py still up-to-date? I'm not advocating for deletion, just asking if it is misleading in any way. While it shares much code with the now-removed group algebra examples and also is not in `GroupAlgebras`, it isn't necessarily wrong (noone said it had to be a GroupAlgebra anyway).

EDIT: *two* final commits. Seriously. I should learn counting...

Thank you once again, and here's hoping for a speedy merge...



---

archive/issue_comments_109509.json:
```json
{
    "body": "<a id='comment:9'></a>\nHow did you guys manage to build Sage?\n\nWhen I checkout the current branch and do \"make\", it fails. So, I did \"make distclean\", followed by make, but it fails. Here is what I get:\n\n```\n./bootstrap -d\nmake[1]: Entering directory `/home/king/Sage/git/sage'\nrm -rf config configure build/Makefile-auto.in\nmake[1]: Leaving directory `/home/king/Sage/git/sage'\n./bootstrap: Zeile 29: aclocal: Kommando nicht gefunden.\nBootstrap failed, downloading required files instead.\nfind: `/home/king/Sage/git/sage/local/var/lib/sage/installed': Datei oder Verzeichnis nicht gefunden\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 --:--:--  0:00:01 --:--:--     0\ncurl: (22) The requested URL returned error: 404 Not Found\nError: downloading configure-23.tar.gz failed\nmake: *** [configure] Fehler 1\n```\nAny idea what I could do to get Sage to work?",
    "created_at": "2014-04-26T07:46:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109509",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
How did you guys manage to build Sage?

When I checkout the current branch and do "make", it fails. So, I did "make distclean", followed by make, but it fails. Here is what I get:

```
./bootstrap -d
make[1]: Entering directory `/home/king/Sage/git/sage'
rm -rf config configure build/Makefile-auto.in
make[1]: Leaving directory `/home/king/Sage/git/sage'
./bootstrap: Zeile 29: aclocal: Kommando nicht gefunden.
Bootstrap failed, downloading required files instead.
find: `/home/king/Sage/git/sage/local/var/lib/sage/installed': Datei oder Verzeichnis nicht gefunden
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:--  0:00:01 --:--:--     0
curl: (22) The requested URL returned error: 404 Not Found
Error: downloading configure-23.tar.gz failed
make: *** [configure] Fehler 1
```
Any idea what I could do to get Sage to work?



---

archive/issue_comments_109510.json:
```json
{
    "body": "<a id='comment:0'></a>\nSimon, see: https://groups.google.com/forum/#!topic/sage-devel/VYKd5khIrhU -- it seems to have come from the recent server migration.",
    "created_at": "2014-04-26T12:16:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109510",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:0'></a>
Simon, see: https://groups.google.com/forum/#!topic/sage-devel/VYKd5khIrhU -- it seems to have come from the recent server migration.



---

archive/issue_comments_109511.json:
```json
{
    "body": "**Changing commit** from \"[16ec0f394ada4e9e101259934a03d1d6175fc727](https://github.com/sagemath/sagetrac-mirror/commit/16ec0f394ada4e9e101259934a03d1d6175fc727)\" to \"[23222255c8fba75ac4449ad851428d2a86116a8e](https://github.com/sagemath/sagetrac-mirror/commit/23222255c8fba75ac4449ad851428d2a86116a8e)\".",
    "created_at": "2014-04-26T14:28:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109511",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[16ec0f394ada4e9e101259934a03d1d6175fc727](https://github.com/sagemath/sagetrac-mirror/commit/16ec0f394ada4e9e101259934a03d1d6175fc727)" to "[23222255c8fba75ac4449ad851428d2a86116a8e](https://github.com/sagemath/sagetrac-mirror/commit/23222255c8fba75ac4449ad851428d2a86116a8e)".



---

archive/issue_comments_109512.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/23222255c8fba75ac4449ad851428d2a86116a8e\">2322225</a></td><td><code>Trac 10963: Answer's to Darij's questions + minor edits + suppressed broken Monoids.Algebras.ParentMethods.an_element</code></td></tr></table>\n",
    "created_at": "2014-04-26T14:28:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109512",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/23222255c8fba75ac4449ad851428d2a86116a8e">2322225</a></td><td><code>Trac 10963: Answer's to Darij's questions + minor edits + suppressed broken Monoids.Algebras.ParentMethods.an_element</code></td></tr></table>




---

archive/issue_comments_109513.json:
```json
{
    "body": "<a id='comment:672'></a>\nReplying to [darij](#comment%3A668):\n> I'm done with my sightseeing tour through this branch.\n\nGreat, thanks for all the hard work!\n\n> ... but I hope it was nevertheless of use.\n\nNo question about that! The documentation was much improved thanks to\nyour proofreading and suggestions.\n\n> My general impression is that the code introduced in this ticket is rather good, and it is definitely a worthy addition to Sage\n\n:-)\n\n> (once speed regressions are fixed)\n\nFor the record: up to final positive review on #15801, they are.\n\n> Nicolas had good reasons to be annoyed by me raising this dust in a ticket not really related\n\nOh well, on this ticket I resigned myself to \u00abBoire le calice jusqu'\u00e0\nla lie\u00bb. In any cases, it was not wasted time: you have been a driving\nforce getting the documentation better. And at the end of the day, I\nam quite glad of the side effect of this ticket drawing attention to\nthe category framework and getting more people well acquainted with\nit.\n\n> There's one final commit waiting for one of you,\n\nReviewed and pushed! Ball on your side :-)\n\n> EDIT: *two* final commits. Seriously. I should learn counting...\n\nAs Florent would say: ``there are three kinds of people in the world:\nthose that can count and those that cannot``.\n\n> and one final question: is src/sage/categories/examples/hopf_algebras_with_basis.py still up-to-date? I'm not advocating for deletion, just asking if it is misleading in any way. While it shares much code with the now-removed group algebra examples and also is not in `GroupAlgebras`, it isn't necessarily wrong (noone said it had to be a GroupAlgebra anyway).\n\nThanks for double checking on this: yes, it still fits its purpose: to\nillustrate how one can implement a Hopf algebra \"from scratch\".\n\n> Thank you once again, and here's hoping for a speedy merge...\n\nYou bet :-)\n\nCheers,\n                                  Nicolas",
    "created_at": "2014-04-26T14:45:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109513",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:672'></a>
Replying to [darij](#comment%3A668):
> I'm done with my sightseeing tour through this branch.

Great, thanks for all the hard work!

> ... but I hope it was nevertheless of use.

No question about that! The documentation was much improved thanks to
your proofreading and suggestions.

> My general impression is that the code introduced in this ticket is rather good, and it is definitely a worthy addition to Sage

:-)

> (once speed regressions are fixed)

For the record: up to final positive review on #15801, they are.

> Nicolas had good reasons to be annoyed by me raising this dust in a ticket not really related

Oh well, on this ticket I resigned myself to «Boire le calice jusqu'à
la lie». In any cases, it was not wasted time: you have been a driving
force getting the documentation better. And at the end of the day, I
am quite glad of the side effect of this ticket drawing attention to
the category framework and getting more people well acquainted with
it.

> There's one final commit waiting for one of you,

Reviewed and pushed! Ball on your side :-)

> EDIT: *two* final commits. Seriously. I should learn counting...

As Florent would say: ``there are three kinds of people in the world:
those that can count and those that cannot``.

> and one final question: is src/sage/categories/examples/hopf_algebras_with_basis.py still up-to-date? I'm not advocating for deletion, just asking if it is misleading in any way. While it shares much code with the now-removed group algebra examples and also is not in `GroupAlgebras`, it isn't necessarily wrong (noone said it had to be a GroupAlgebra anyway).

Thanks for double checking on this: yes, it still fits its purpose: to
illustrate how one can implement a Hopf algebra "from scratch".

> Thank you once again, and here's hoping for a speedy merge...

You bet :-)

Cheers,
                                  Nicolas



---

archive/issue_comments_109514.json:
```json
{
    "body": "<a id='comment:673'></a>\nReplying to [nthiery](#comment%3A672):\n> > Thank you once again, and here's hoping for a speedy merge...\n\n> \n> You bet :-)\n\nWhat is currently holding me from reviewing is what I have mentioned in [comment:669](#comment%3A669). Meanwhile the error has changed from `404 Not Found` to `403 Forbidden`. Kind of a progress.",
    "created_at": "2014-04-26T16:32:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109514",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:673'></a>
Replying to [nthiery](#comment%3A672):
> > Thank you once again, and here's hoping for a speedy merge...

> 
> You bet :-)

What is currently holding me from reviewing is what I have mentioned in [comment:669](#comment%3A669). Meanwhile the error has changed from `404 Not Found` to `403 Forbidden`. Kind of a progress.



---

archive/issue_comments_109515.json:
```json
{
    "body": "<a id='comment:4'></a>\nSwitching dependency from #15919 to #16244 since the former ticket has been split in two and we only need the latter.",
    "created_at": "2014-04-26T21:25:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109515",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:4'></a>
Switching dependency from #15919 to #16244 since the former ticket has been split in two and we only need the latter.



---

archive/issue_comments_109516.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #15919\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #16244\".",
    "created_at": "2014-04-26T21:25:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109516",
    "user": "https://github.com/nthiery"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #15919" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #16244".



---

archive/issue_comments_109517.json:
```json
{
    "body": "<a id='comment:5'></a>\nMeanwhile the problem with `403 Forbidden` has been resolved.\n\nIs the change in the dependencies relevant for obtaining the to-be-reviewed sources? I suppose that the commits of all the dependencies are present in the attached branch!",
    "created_at": "2014-04-26T21:34:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109517",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
Meanwhile the problem with `403 Forbidden` has been resolved.

Is the change in the dependencies relevant for obtaining the to-be-reviewed sources? I suppose that the commits of all the dependencies are present in the attached branch!



---

archive/issue_comments_109518.json:
```json
{
    "body": "<a id='comment:6'></a>\nI haven't yet merged in #14284 (except on test branches I haven't pushed) since it's not yet 100% certain which of the possible routes we want to take. But it sounds likely that #14284 will be positive reviewed soon. And in any case, it just causes one failing test (in integer_ring.pyx IIRC); so this should not go in the way of your review.",
    "created_at": "2014-04-26T21:47:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109518",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>
I haven't yet merged in #14284 (except on test branches I haven't pushed) since it's not yet 100% certain which of the possible routes we want to take. But it sounds likely that #14284 will be positive reviewed soon. And in any case, it just causes one failing test (in integer_ring.pyx IIRC); so this should not go in the way of your review.



---

archive/issue_comments_109519.json:
```json
{
    "body": "<a id='comment:7'></a>\nMethinks this is not good:\n\n```\nsage: Modules(QQ).super_categories()\n[Category of modules over Rational Field]\n```\n\nEDIT: On the other hand:\n\n```\nsage: Modules(QQ).super_categories()[0].super_categories()\n[Category of bimodules over Rational Field on the left and Rational Field on the right]\n```\nso it's not the end of the world.",
    "created_at": "2014-04-27T03:22:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109519",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:7'></a>
Methinks this is not good:

```
sage: Modules(QQ).super_categories()
[Category of modules over Rational Field]
```

EDIT: On the other hand:

```
sage: Modules(QQ).super_categories()[0].super_categories()
[Category of bimodules over Rational Field on the left and Rational Field on the right]
```
so it's not the end of the world.



---

archive/issue_comments_109520.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f7e1a6bba29372bd197de88c9db3a6e866b001a2\">f7e1a6b</a></td><td><code>clarifying symmetry requirement on modules, which is absolutely necessary seeing that `__mul__` and `__rmul__` are defined to be the same thing</code></td></tr></table>\n",
    "created_at": "2014-04-27T03:27:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109520",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f7e1a6bba29372bd197de88c9db3a6e866b001a2">f7e1a6b</a></td><td><code>clarifying symmetry requirement on modules, which is absolutely necessary seeing that `__mul__` and `__rmul__` are defined to be the same thing</code></td></tr></table>




---

archive/issue_comments_109521.json:
```json
{
    "body": "**Changing commit** from \"[23222255c8fba75ac4449ad851428d2a86116a8e](https://github.com/sagemath/sagetrac-mirror/commit/23222255c8fba75ac4449ad851428d2a86116a8e)\" to \"[f7e1a6bba29372bd197de88c9db3a6e866b001a2](https://github.com/sagemath/sagetrac-mirror/commit/f7e1a6bba29372bd197de88c9db3a6e866b001a2)\".",
    "created_at": "2014-04-27T03:27:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109521",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[23222255c8fba75ac4449ad851428d2a86116a8e](https://github.com/sagemath/sagetrac-mirror/commit/23222255c8fba75ac4449ad851428d2a86116a8e)" to "[f7e1a6bba29372bd197de88c9db3a6e866b001a2](https://github.com/sagemath/sagetrac-mirror/commit/f7e1a6bba29372bd197de88c9db3a6e866b001a2)".



---

archive/issue_comments_109522.json:
```json
{
    "body": "<a id='comment:9'></a>\nNicolas: Thanks for this and sorry for not noticing the ridiculous an_example method myself! I've pushed a response commit. I am still not happy with your edit on the graded issue because it feels like you are trying to brush the actual bug under the rug. The current use of `dual` is *wrong* and an abuse of functorial construction; as you have seen by my comment, it caused me to misunderstand things. It will have to be fixed (`Algebras().Duals()` will no longer be a subcategory of `Coalgebras()`, and the duals of combinatorial Hopf algebras will be called using `graded_dual()`), but for now it really ought to have big red warning signs around it.",
    "created_at": "2014-04-27T03:37:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109522",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:9'></a>
Nicolas: Thanks for this and sorry for not noticing the ridiculous an_example method myself! I've pushed a response commit. I am still not happy with your edit on the graded issue because it feels like you are trying to brush the actual bug under the rug. The current use of `dual` is *wrong* and an abuse of functorial construction; as you have seen by my comment, it caused me to misunderstand things. It will have to be fixed (`Algebras().Duals()` will no longer be a subcategory of `Coalgebras()`, and the duals of combinatorial Hopf algebras will be called using `graded_dual()`), but for now it really ought to have big red warning signs around it.



---

archive/issue_comments_109523.json:
```json
{
    "body": "<a id='comment:680'></a>\nReplying to [darij](#comment%3A677):\n> Methinks this is not good:\n> \n> ```\n> sage: Modules(QQ).super_categories()\n> [Category of modules over Rational Field]\n> ```\n\nHave you checked what `Modules(QQ)` returns? See the documentation of `Modules`.",
    "created_at": "2014-04-27T05:39:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109523",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:680'></a>
Replying to [darij](#comment%3A677):
> Methinks this is not good:
> 
> ```
> sage: Modules(QQ).super_categories()
> [Category of modules over Rational Field]
> ```

Have you checked what `Modules(QQ)` returns? See the documentation of `Modules`.



---

archive/issue_comments_109524.json:
```json
{
    "body": "<a id='comment:1'></a>\nYeah, as I've edited into my post, it's not an actual error. Somewhat confusing, might be good to document, but otherwise perfectly fine.",
    "created_at": "2014-04-27T05:40:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109524",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:1'></a>
Yeah, as I've edited into my post, it's not an actual error. Somewhat confusing, might be good to document, but otherwise perfectly fine.



---

archive/issue_comments_109525.json:
```json
{
    "body": "<a id='comment:682'></a>\nReplying to [git](#comment%3A678):\n> Branch pushed to git repo; I updated commit sha1. **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f7e1a6bba29372bd197de88c9db3a6e866b001a2\">f7e1a6b</a></td><td><code>clarifying symmetry requirement on modules, which is absolutely necessary seeing that `__mul__` and `__rmul__` are defined to be the same thing</code></td></tr></table>\n\nThey are not defined the same way! And indeed:\n\n```\nsage: F = FreeAlgebra(QQ,2,'a')\nsage: a0,a1 = F.gens()\nsage: V = CombinatorialFreeModule(F, [1,2,3])\nsage: v = V.an_element()\nsage: (a0*v)*a1\n2*a0*a1*B[1] + 2*a0*a1*B[2] + 3*a0*a1*B[3]\nsage: a1*(a0*v)\n2*a1*a0*B[1] + 2*a1*a0*B[2] + 3*a1*a0*B[3]\n```\n\nBeware that '__rmul__' in Python takes its arguments in reverse order\nwhich can indeed be confusing.\n\nI am not claiming that all modules implemented in Sage are clean in\nthis respect, but the category code by itself does not prevent non\nsymmetry.\n\nWith this in mind, I'd rather revert this piece of the last commit.\n\nCheers,\n                                   Nicolas",
    "created_at": "2014-04-27T20:21:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109525",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:682'></a>
Replying to [git](#comment%3A678):
> Branch pushed to git repo; I updated commit sha1. **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f7e1a6bba29372bd197de88c9db3a6e866b001a2">f7e1a6b</a></td><td><code>clarifying symmetry requirement on modules, which is absolutely necessary seeing that `__mul__` and `__rmul__` are defined to be the same thing</code></td></tr></table>

They are not defined the same way! And indeed:

```
sage: F = FreeAlgebra(QQ,2,'a')
sage: a0,a1 = F.gens()
sage: V = CombinatorialFreeModule(F, [1,2,3])
sage: v = V.an_element()
sage: (a0*v)*a1
2*a0*a1*B[1] + 2*a0*a1*B[2] + 3*a0*a1*B[3]
sage: a1*(a0*v)
2*a1*a0*B[1] + 2*a1*a0*B[2] + 3*a1*a0*B[3]
```

Beware that '__rmul__' in Python takes its arguments in reverse order
which can indeed be confusing.

I am not claiming that all modules implemented in Sage are clean in
this respect, but the category code by itself does not prevent non
symmetry.

With this in mind, I'd rather revert this piece of the last commit.

Cheers,
                                   Nicolas



---

archive/issue_comments_109526.json:
```json
{
    "body": "<a id='comment:3'></a>\nOK, I guess I don't understand the inner workings of `__mul__` and `__rmul__`. Could you explain them to me?\n\nIf the Modules *category* is suited for nonsymmetric bimodules (without having to manually override certain non-abstract methods in every subcategory), then my edit on that file indeed should be reverted; thanks for spotting that. But there still should be warning signs around this class that it really allows for bimodules. And I fear that the dispatching of Modules(field) to VectorSpaces(field) is strictly speaking incorrect in this case.\n\nEDIT: What about ModulesWithBasis in this case? Does this basis have to be a basis for the left module structure or for the right one?",
    "created_at": "2014-04-27T20:28:08Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109526",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:3'></a>
OK, I guess I don't understand the inner workings of `__mul__` and `__rmul__`. Could you explain them to me?

If the Modules *category* is suited for nonsymmetric bimodules (without having to manually override certain non-abstract methods in every subcategory), then my edit on that file indeed should be reverted; thanks for spotting that. But there still should be warning signs around this class that it really allows for bimodules. And I fear that the dispatching of Modules(field) to VectorSpaces(field) is strictly speaking incorrect in this case.

EDIT: What about ModulesWithBasis in this case? Does this basis have to be a basis for the left module structure or for the right one?



---

archive/issue_comments_109527.json:
```json
{
    "body": "**Changing commit** from \"[f7e1a6bba29372bd197de88c9db3a6e866b001a2](https://github.com/sagemath/sagetrac-mirror/commit/f7e1a6bba29372bd197de88c9db3a6e866b001a2)\" to \"[72735421026786100353f4756b16874e73a9cfe6](https://github.com/sagemath/sagetrac-mirror/commit/72735421026786100353f4756b16874e73a9cfe6)\".",
    "created_at": "2014-04-27T21:18:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109527",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f7e1a6bba29372bd197de88c9db3a6e866b001a2](https://github.com/sagemath/sagetrac-mirror/commit/f7e1a6bba29372bd197de88c9db3a6e866b001a2)" to "[72735421026786100353f4756b16874e73a9cfe6](https://github.com/sagemath/sagetrac-mirror/commit/72735421026786100353f4756b16874e73a9cfe6)".



---

archive/issue_comments_109528.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/72735421026786100353f4756b16874e73a9cfe6\">7273542</a></td><td><code>Trac 10963: polishing in the documentation of the modules and friends categories</code></td></tr></table>\n",
    "created_at": "2014-04-27T21:18:29Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109528",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/72735421026786100353f4756b16874e73a9cfe6">7273542</a></td><td><code>Trac 10963: polishing in the documentation of the modules and friends categories</code></td></tr></table>




---

archive/issue_comments_109529.json:
```json
{
    "body": "<a id='comment:685'></a>\nReplying to [darij](#comment%3A683):\n> OK, I guess I don't understand the inner workings of `__mul__` and `__rmul__`. Could you explain them to me?\n\nI am not sure I can do better than:\n\nhttps://docs.python.org/2/reference/datamodel.html\n\n> If the Modules *category* is suited for nonsymmetric bimodules (without having to manually override certain non-abstract methods in every subcategory), then my edit on that file indeed should be reverted; thanks for spotting that. But there still should be warning signs around this class that it really allows for bimodules.\n\nI reverted the change, and replaced it with a bunch of warnings.\n\n> And I fear that the dispatching of Modules(field) to VectorSpaces(field) is strictly speaking incorrect in this case.\n\nLooking up wikipedia, VectorSpaces are actually defined as left-vector\nspaces. So I guess that's not so bad. Really it's saying that you can\ndo all your usual linear algebra on the left or on the right at you\npreference.\n\n> EDIT: What about ModulesWithBasis in this case? Does this basis have to be a basis for the left module structure or for the right one?\n\nBoth I guess. And in all practical use cases so far, multiplication on\nthe left and on the right are both more or less supposed to be\nmultiplication on the coefficients. In MuPAD we had started to explore\nsituations where this was not the case (e.g. with polynomials whose\nmonomials skew-commuted with their coefficients).\n\nCheers,\n                                 Nicolas",
    "created_at": "2014-04-27T21:54:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109529",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:685'></a>
Replying to [darij](#comment%3A683):
> OK, I guess I don't understand the inner workings of `__mul__` and `__rmul__`. Could you explain them to me?

I am not sure I can do better than:

https://docs.python.org/2/reference/datamodel.html

> If the Modules *category* is suited for nonsymmetric bimodules (without having to manually override certain non-abstract methods in every subcategory), then my edit on that file indeed should be reverted; thanks for spotting that. But there still should be warning signs around this class that it really allows for bimodules.

I reverted the change, and replaced it with a bunch of warnings.

> And I fear that the dispatching of Modules(field) to VectorSpaces(field) is strictly speaking incorrect in this case.

Looking up wikipedia, VectorSpaces are actually defined as left-vector
spaces. So I guess that's not so bad. Really it's saying that you can
do all your usual linear algebra on the left or on the right at you
preference.

> EDIT: What about ModulesWithBasis in this case? Does this basis have to be a basis for the left module structure or for the right one?

Both I guess. And in all practical use cases so far, multiplication on
the left and on the right are both more or less supposed to be
multiplication on the coefficients. In MuPAD we had started to explore
situations where this was not the case (e.g. with polynomials whose
monomials skew-commuted with their coefficients).

Cheers,
                                 Nicolas



---

archive/issue_comments_109530.json:
```json
{
    "body": "<a id='comment:686'></a>\nReplying to [nthiery](#comment%3A685):\n> Replying to [darij](#comment%3A683):\n> > OK, I guess I don't understand the inner workings of `__mul__` and `__rmul__`. Could you explain them to me?\n\n> \n> I am not sure I can do better than:\n> \n> https://docs.python.org/2/reference/datamodel.html\n\nNo, what I mean is this:\n\n```\n            from sage.structure.element import get_coercion_model\n            import operator\n            return get_coercion_model().bin_op(left, right, operator.mul)\n```\nWhat does `get_coercion_model` actually do?\n\n> > If the Modules *category* is suited for nonsymmetric bimodules (without having to manually override certain non-abstract methods in every subcategory), then my edit on that file indeed should be reverted; thanks for spotting that. But there still should be warning signs around this class that it really allows for bimodules.\n\n> \n> I reverted the change, and replaced it with a bunch of warnings.\n\nVery well. I'd only put a WARNING in the doc of Modules rather than just a TODO. Basically, we _don't know_ so far whether Modules will stand for bimodules or symmetric bimodules, and we are asking for users to assume neither. This is a bug, not just a task that has to be eventually done.\n\n> Looking up wikipedia, VectorSpaces are actually defined as left-vector\n> spaces. So I guess that's not so bad. Really it's saying that you can\n> do all your usual linear algebra on the left or on the right at you\n> preference.\n\nI don't understand what you are saying here, and I'm not sure if you are understanding what I was saying. A bimodule over a field is an additive group with *two commuting* vector space structures. For example, you can make the field QQ(x) of rational functions in x over the rational numbers QQ into a QQ(x)-QQ(x)-bimodule as follows:\n\nr m = r * m (product of rational functions) for r in the ring QQ(x) and m in the bimodule QQ(x);\n\nm r = m * r(x^2)\n(again product of rational functions) for r in the ring QQ(x) and m in the bimodule QQ(x).\n\nAs a left QQ(x)-module, QQ(x) has basis (1) (just consisting of one element). As a right QQ(x)-module, it has basis (1, x). So \"left bases\" and \"right bases\" are two different things, and I don't see how a notion of a \"basis\" of a (non-symmetric) bimodule can be made sense of.\n\nFor a more down-to-earth example: The quaternions are a bimodule over the complex numbers. (1+j, i+k) is a right CC-vector space basis (easy to check) but not a left CC-vector space basis (since i(1+j) = i+k).\n\nSimilarly for duals.",
    "created_at": "2014-04-27T23:05:31Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109530",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:686'></a>
Replying to [nthiery](#comment%3A685):
> Replying to [darij](#comment%3A683):
> > OK, I guess I don't understand the inner workings of `__mul__` and `__rmul__`. Could you explain them to me?

> 
> I am not sure I can do better than:
> 
> https://docs.python.org/2/reference/datamodel.html

No, what I mean is this:

```
            from sage.structure.element import get_coercion_model
            import operator
            return get_coercion_model().bin_op(left, right, operator.mul)
```
What does `get_coercion_model` actually do?

> > If the Modules *category* is suited for nonsymmetric bimodules (without having to manually override certain non-abstract methods in every subcategory), then my edit on that file indeed should be reverted; thanks for spotting that. But there still should be warning signs around this class that it really allows for bimodules.

> 
> I reverted the change, and replaced it with a bunch of warnings.

Very well. I'd only put a WARNING in the doc of Modules rather than just a TODO. Basically, we _don't know_ so far whether Modules will stand for bimodules or symmetric bimodules, and we are asking for users to assume neither. This is a bug, not just a task that has to be eventually done.

> Looking up wikipedia, VectorSpaces are actually defined as left-vector
> spaces. So I guess that's not so bad. Really it's saying that you can
> do all your usual linear algebra on the left or on the right at you
> preference.

I don't understand what you are saying here, and I'm not sure if you are understanding what I was saying. A bimodule over a field is an additive group with *two commuting* vector space structures. For example, you can make the field QQ(x) of rational functions in x over the rational numbers QQ into a QQ(x)-QQ(x)-bimodule as follows:

r m = r * m (product of rational functions) for r in the ring QQ(x) and m in the bimodule QQ(x);

m r = m * r(x^2)
(again product of rational functions) for r in the ring QQ(x) and m in the bimodule QQ(x).

As a left QQ(x)-module, QQ(x) has basis (1) (just consisting of one element). As a right QQ(x)-module, it has basis (1, x). So "left bases" and "right bases" are two different things, and I don't see how a notion of a "basis" of a (non-symmetric) bimodule can be made sense of.

For a more down-to-earth example: The quaternions are a bimodule over the complex numbers. (1+j, i+k) is a right CC-vector space basis (easy to check) but not a left CC-vector space basis (since i(1+j) = i+k).

Similarly for duals.



---

archive/issue_comments_109531.json:
```json
{
    "body": "<a id='comment:687'></a>\nReplying to [nthiery](#comment%3A676):\n> I haven't yet merged in #14284 (except on test branches I haven't pushed) since it's not yet 100% certain which of the possible routes we want to take. But it sounds likely that #14284 will be positive reviewed soon.\n\nWhat ticket are you talking about? Certainly not #14284, which was closed a year ago.\n\nIn any case, something needs to be done about the error.",
    "created_at": "2014-04-28T14:12:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109531",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:687'></a>
Replying to [nthiery](#comment%3A676):
> I haven't yet merged in #14284 (except on test branches I haven't pushed) since it's not yet 100% certain which of the possible routes we want to take. But it sounds likely that #14284 will be positive reviewed soon.

What ticket are you talking about? Certainly not #14284, which was closed a year ago.

In any case, something needs to be done about the error.



---

archive/issue_comments_109532.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d9b5fcd5df001b38300788a963279bc0c8edf4b6\">d9b5fcd</a></td><td><code>Added warning about iterator objects.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2a5eaa5afc10079d97a122e50372eb19c06d390a\">2a5eaa5</a></td><td><code>Fixed double-colon.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5d2d335a2e833dfa58589a6453cd011ce05ccb4b\">5d2d335</a></td><td><code>Merge branch 'develop' into u/tscrim/ticket/15919</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f9b59fac8d518a946debc3555a43bdfaea4f1f90\">f9b59fa</a></td><td><code>Merge branch 'develop=6.2.rc0' into ticket/15919-unrank</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bbd22f1422f7b643a55afabeb44cfd8204b7dd3b\">bbd22f1</a></td><td><code>- Use `__getitem__` only on sequences and Parents not in EnumeratedSets</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/382b9ff1fb969c6f9e01318c654a0e57cc74c89a\">382b9ff</a></td><td><code>Merge branch 'u/nthiery/ticket/15919' of trac.sagemath.org:sage into u/tscrim/ticket/15919</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/79d469861431ac8d6be5ad4edeace1c6ac8a62c8\">79d4698</a></td><td><code>Some last very minor tweaks to ranker.py.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e8e383706eb7931bbcaa08efc5490a7ca6ed4f4c\">e8e3837</a></td><td><code>Merge branch 'u/tscrim/ticket/15919' of trac.sagemath.org:sage into u/tscrim/16244-test_suite_logic</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c5e55d3155722f4a474931eabf42b5382397a5d0\">c5e55d3</a></td><td><code>Merge branch 'u/tscrim/16244-test_suite_logic' into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1d9720f961087e06645355dcc455a204f6c0497e\">1d9720f</a></td><td><code>Partial lookthrough fixes for documentation formatting & python3.</code></td></tr></table>\n",
    "created_at": "2014-04-28T16:08:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109532",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d9b5fcd5df001b38300788a963279bc0c8edf4b6">d9b5fcd</a></td><td><code>Added warning about iterator objects.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2a5eaa5afc10079d97a122e50372eb19c06d390a">2a5eaa5</a></td><td><code>Fixed double-colon.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5d2d335a2e833dfa58589a6453cd011ce05ccb4b">5d2d335</a></td><td><code>Merge branch 'develop' into u/tscrim/ticket/15919</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f9b59fac8d518a946debc3555a43bdfaea4f1f90">f9b59fa</a></td><td><code>Merge branch 'develop=6.2.rc0' into ticket/15919-unrank</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bbd22f1422f7b643a55afabeb44cfd8204b7dd3b">bbd22f1</a></td><td><code>- Use `__getitem__` only on sequences and Parents not in EnumeratedSets</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/382b9ff1fb969c6f9e01318c654a0e57cc74c89a">382b9ff</a></td><td><code>Merge branch 'u/nthiery/ticket/15919' of trac.sagemath.org:sage into u/tscrim/ticket/15919</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/79d469861431ac8d6be5ad4edeace1c6ac8a62c8">79d4698</a></td><td><code>Some last very minor tweaks to ranker.py.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e8e383706eb7931bbcaa08efc5490a7ca6ed4f4c">e8e3837</a></td><td><code>Merge branch 'u/tscrim/ticket/15919' of trac.sagemath.org:sage into u/tscrim/16244-test_suite_logic</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c5e55d3155722f4a474931eabf42b5382397a5d0">c5e55d3</a></td><td><code>Merge branch 'u/tscrim/16244-test_suite_logic' into public/ticket/10963-doc-distributive</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1d9720f961087e06645355dcc455a204f6c0497e">1d9720f</a></td><td><code>Partial lookthrough fixes for documentation formatting & python3.</code></td></tr></table>




---

archive/issue_comments_109533.json:
```json
{
    "body": "**Changing commit** from \"[72735421026786100353f4756b16874e73a9cfe6](https://github.com/sagemath/sagetrac-mirror/commit/72735421026786100353f4756b16874e73a9cfe6)\" to \"[1d9720f961087e06645355dcc455a204f6c0497e](https://github.com/sagemath/sagetrac-mirror/commit/1d9720f961087e06645355dcc455a204f6c0497e)\".",
    "created_at": "2014-04-28T16:08:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109533",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[72735421026786100353f4756b16874e73a9cfe6](https://github.com/sagemath/sagetrac-mirror/commit/72735421026786100353f4756b16874e73a9cfe6)" to "[1d9720f961087e06645355dcc455a204f6c0497e](https://github.com/sagemath/sagetrac-mirror/commit/1d9720f961087e06645355dcc455a204f6c0497e)".



---

archive/issue_comments_109534.json:
```json
{
    "body": "<a id='comment:9'></a>\nI've merged in (the latest) #16244 and #15919 and started going through and looking specifically formatting issues and getting things ready for python3. I'm also reading the new code and doc as well, but moving pass things I don't understand. I'll do more this afternoon and evening.",
    "created_at": "2014-04-28T16:12:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109534",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:9'></a>
I've merged in (the latest) #16244 and #15919 and started going through and looking specifically formatting issues and getting things ready for python3. I'm also reading the new code and doc as well, but moving pass things I don't understand. I'll do more this afternoon and evening.



---

archive/issue_comments_109535.json:
```json
{
    "body": "<a id='comment:690'></a>\nReplying to [SimonKing](#comment%3A687):\n> Replying to [nthiery](#comment%3A676):\n> > I haven't yet merged in #14284 (except on test branches I haven't pushed) since it's not yet 100% certain which of the possible routes we want to take. But it sounds likely that #14284 will be positive reviewed soon.\n\n> \n> What ticket are you talking about? Certainly not #14284, which was closed a year ago.\n> In any case, something needs to be done about the error.\n\nOups. I obviously meant the ticket I just added as dependency: #16244; it does the job of fixing the error.",
    "created_at": "2014-04-28T17:15:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109535",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:690'></a>
Replying to [SimonKing](#comment%3A687):
> Replying to [nthiery](#comment%3A676):
> > I haven't yet merged in #14284 (except on test branches I haven't pushed) since it's not yet 100% certain which of the possible routes we want to take. But it sounds likely that #14284 will be positive reviewed soon.

> 
> What ticket are you talking about? Certainly not #14284, which was closed a year ago.
> In any case, something needs to be done about the error.

Oups. I obviously meant the ticket I just added as dependency: #16244; it does the job of fixing the error.



---

archive/issue_comments_109536.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/59d73760c528cca3ede00c8b0fc951131c79f473\">59d7376</a></td><td><code>Trac 10963: proofread Travis's review changes</code></td></tr></table>\n",
    "created_at": "2014-04-28T20:45:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109536",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/59d73760c528cca3ede00c8b0fc951131c79f473">59d7376</a></td><td><code>Trac 10963: proofread Travis's review changes</code></td></tr></table>




---

archive/issue_comments_109537.json:
```json
{
    "body": "**Changing commit** from \"[1d9720f961087e06645355dcc455a204f6c0497e](https://github.com/sagemath/sagetrac-mirror/commit/1d9720f961087e06645355dcc455a204f6c0497e)\" to \"[59d73760c528cca3ede00c8b0fc951131c79f473](https://github.com/sagemath/sagetrac-mirror/commit/59d73760c528cca3ede00c8b0fc951131c79f473)\".",
    "created_at": "2014-04-28T20:45:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109537",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1d9720f961087e06645355dcc455a204f6c0497e](https://github.com/sagemath/sagetrac-mirror/commit/1d9720f961087e06645355dcc455a204f6c0497e)" to "[59d73760c528cca3ede00c8b0fc951131c79f473](https://github.com/sagemath/sagetrac-mirror/commit/59d73760c528cca3ede00c8b0fc951131c79f473)".



---

archive/issue_comments_109538.json:
```json
{
    "body": "<a id='comment:692'></a>\nHi Travis,\n\nReplying to [tscrim](#comment%3A689):\n> I've merged in (the latest) #16244 and #15919\n\nThanks! #15919 was not strictly necessary but that's ok.\n\n> and started going through and looking specifically formatting issues and getting things ready for python3. I'm also reading the new code and doc as well, but moving pass things I don't understand. I'll do more this afternoon and evening.\n\nThe good thing is that I am now sure that none of the follow up\npatches in the queue is going to apply cleanly :-)\n\nNo, honestly, I really appreciate the time you are spending improving\nthe code. But this is to be kept in balance; this ticket is about the\ninfrastructure, not about rewriting all the category code perfectly.\nIf you only changed code that was anyway changed by this ticket,\nforget this comment.\n\nI proofread your edits and just made a minor changes. For the record,\nI have tried indenting long join category output as:\n\n```\n\n    Join of Category of ...\n        and Category of ...\n```\n\nIs there a strong rationale for changing things like:\n\n```\n     if ...:\n          return ...\n     else:\n          return ...\n```\nto\n\n```\n     if ...:\n          return ...\n     return ...\n```\n\nI agree that the latter syntax can express well certain situations;\ntypically when one gets rid of a special case before attacking the\ngeneral case. But other than this, it's a matter of taste, and I would\nnot change systematically code in one way or the other. Or?\n\nThanks again, \n                            Nicolas",
    "created_at": "2014-04-28T21:10:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109538",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:692'></a>
Hi Travis,

Replying to [tscrim](#comment%3A689):
> I've merged in (the latest) #16244 and #15919

Thanks! #15919 was not strictly necessary but that's ok.

> and started going through and looking specifically formatting issues and getting things ready for python3. I'm also reading the new code and doc as well, but moving pass things I don't understand. I'll do more this afternoon and evening.

The good thing is that I am now sure that none of the follow up
patches in the queue is going to apply cleanly :-)

No, honestly, I really appreciate the time you are spending improving
the code. But this is to be kept in balance; this ticket is about the
infrastructure, not about rewriting all the category code perfectly.
If you only changed code that was anyway changed by this ticket,
forget this comment.

I proofread your edits and just made a minor changes. For the record,
I have tried indenting long join category output as:

```

    Join of Category of ...
        and Category of ...
```

Is there a strong rationale for changing things like:

```
     if ...:
          return ...
     else:
          return ...
```
to

```
     if ...:
          return ...
     return ...
```

I agree that the latter syntax can express well certain situations;
typically when one gets rid of a special case before attacking the
general case. But other than this, it's a matter of taste, and I would
not change systematically code in one way or the other. Or?

Thanks again, 
                            Nicolas



---

archive/issue_comments_109539.json:
```json
{
    "body": "<a id='comment:3'></a>\nI'm only making changes in the changed code from what I see in the diff. I'll make sure to indent the long join categories as I go along. The if/else thing is more of a pet peeve of mine, especially when there are large indent blocks floating around. IDK, I always feel it makes it easier to read usually *shrugs*.",
    "created_at": "2014-04-28T21:42:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109539",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:3'></a>
I'm only making changes in the changed code from what I see in the diff. I'll make sure to indent the long join categories as I go along. The if/else thing is more of a pet peeve of mine, especially when there are large indent blocks floating around. IDK, I always feel it makes it easier to read usually *shrugs*.



---

archive/issue_comments_109540.json:
```json
{
    "body": "<a id='comment:694'></a>\nHi Darij,\n\nReplying to [darij](#comment%3A686):\n> No, what I mean is this:\n\nSorry for the RTFM :-)\n\n> ```\n>             from sage.structure.element import get_coercion_model\n>             import operator\n>             return get_coercion_model().bin_op(left, right, operator.mul)\n> ```\n> What does `get_coercion_model` actually do?\n\n`get_coercion_model()` just returns the coercion model, that is Sage's\n\"database\" of coercions. For bin_op, see sage.structure.coerce.pyx:\n\n```\n    cpdef bin_op(self, x, y, op):\n        \"\"\"\n        Execute the operation op on x and y. It first looks for an action\n        corresponding to op, and failing that, it tries to coerces x and y\n        into the a common parent and calls op on them.\n        ...\n```\n\nSee also Simon's tutorial which says a few things about coercion::\n\n http://www.sagemath.org/doc/thematic_tutorials/coercion_and_categories.html\n\n> Very well. I'd only put a WARNING in the doc of Modules rather than just a TODO. Basically, we _don't know_ so far whether Modules will stand for bimodules or symmetric bimodules, and we are asking for users to assume neither. This is a bug, not just a task that has to be eventually done.\n\nIt's not a bug, it's explicitly unspecified behavior :-)\n\nHonestly, that's ok. Let's move on rather than spending still more\ntime on things outside of the scope of this ticket.\n\n> I don't understand what you are saying here, and I'm not sure if you are understanding what I was saying. A bimodule over a field is an additive group with *two commuting* vector space structures. For example, you can make the field QQ(x) of rational functions in x over the rational numbers QQ into a QQ(x)-QQ(x)-bimodule as follows:\n> \n> r m = r * m (product of rational functions) for r in the ring QQ(x) and m in the bimodule QQ(x);\n> \n> m r = m * r(x^2)\n> (again product of rational functions) for r in the ring QQ(x) and m in the bimodule QQ(x).\n> \n> As a left QQ(x)-module, QQ(x) has basis (1) (just consisting of one element). As a right QQ(x)-module, it has basis (1, x). So \"left bases\" and \"right bases\" are two different things, and I don't see how a notion of a \"basis\" of a (non-symmetric) bimodule can be made sense of.\n> \n> For a more down-to-earth example: The quaternions are a bimodule over the complex numbers. (1+j, i+k) is a right CC-vector space basis (easy to check) but not a left CC-vector space basis (since i(1+j) = i+k).\n\nIndeed. But this is not really relevant to our `VectorSpaces()`, since\nthe latter says nothing about bases.\n\nAs for `VectorSpaces().WithBasis()`, since it does not say whether the\ndistinguished basis is a left basis or a right basis, it's not\nunreasonable for the user to assume that it should be a basis on both\nsides.\n\nAnyway, if you want to proceed with this discussion on better\nspecifying the modules / vector spaces / ... categories, please open a\nseparate ticket.\n\nCheers,\n                               Nicolas\n\nPS: I like that comment 666 is from git about \"some final fixes\".",
    "created_at": "2014-04-28T21:56:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109540",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:694'></a>
Hi Darij,

Replying to [darij](#comment%3A686):
> No, what I mean is this:

Sorry for the RTFM :-)

> ```
>             from sage.structure.element import get_coercion_model
>             import operator
>             return get_coercion_model().bin_op(left, right, operator.mul)
> ```
> What does `get_coercion_model` actually do?

`get_coercion_model()` just returns the coercion model, that is Sage's
"database" of coercions. For bin_op, see sage.structure.coerce.pyx:

```
    cpdef bin_op(self, x, y, op):
        """
        Execute the operation op on x and y. It first looks for an action
        corresponding to op, and failing that, it tries to coerces x and y
        into the a common parent and calls op on them.
        ...
```

See also Simon's tutorial which says a few things about coercion::

 http://www.sagemath.org/doc/thematic_tutorials/coercion_and_categories.html

> Very well. I'd only put a WARNING in the doc of Modules rather than just a TODO. Basically, we _don't know_ so far whether Modules will stand for bimodules or symmetric bimodules, and we are asking for users to assume neither. This is a bug, not just a task that has to be eventually done.

It's not a bug, it's explicitly unspecified behavior :-)

Honestly, that's ok. Let's move on rather than spending still more
time on things outside of the scope of this ticket.

> I don't understand what you are saying here, and I'm not sure if you are understanding what I was saying. A bimodule over a field is an additive group with *two commuting* vector space structures. For example, you can make the field QQ(x) of rational functions in x over the rational numbers QQ into a QQ(x)-QQ(x)-bimodule as follows:
> 
> r m = r * m (product of rational functions) for r in the ring QQ(x) and m in the bimodule QQ(x);
> 
> m r = m * r(x^2)
> (again product of rational functions) for r in the ring QQ(x) and m in the bimodule QQ(x).
> 
> As a left QQ(x)-module, QQ(x) has basis (1) (just consisting of one element). As a right QQ(x)-module, it has basis (1, x). So "left bases" and "right bases" are two different things, and I don't see how a notion of a "basis" of a (non-symmetric) bimodule can be made sense of.
> 
> For a more down-to-earth example: The quaternions are a bimodule over the complex numbers. (1+j, i+k) is a right CC-vector space basis (easy to check) but not a left CC-vector space basis (since i(1+j) = i+k).

Indeed. But this is not really relevant to our `VectorSpaces()`, since
the latter says nothing about bases.

As for `VectorSpaces().WithBasis()`, since it does not say whether the
distinguished basis is a left basis or a right basis, it's not
unreasonable for the user to assume that it should be a basis on both
sides.

Anyway, if you want to proceed with this discussion on better
specifying the modules / vector spaces / ... categories, please open a
separate ticket.

Cheers,
                               Nicolas

PS: I like that comment 666 is from git about "some final fixes".



---

archive/issue_comments_109541.json:
```json
{
    "body": "<a id='comment:695'></a>\nReplying to [tscrim](#comment%3A693):\n> I'm only making changes in the changed code from what I see in the diff. I'll make sure to indent the long join categories as I go along.\n\nGreat, thanks.\n\n> The if/else thing is more of a pet peeve of mine, especially when there are large indent blocks floating around.  IDK, I always feel it makes it easier to read usually *shrugs*.\n\nAgreed, large indent blocks can be good use case too. I actually tend\nto have the same peeve and have a hard time convincing some of my\ncolleagues about its reasonable use in teaching.\n\nAnyway, for small if/else's like the recent ones where there is not a\ncompelling reason (a non trivial indentation reduction, or strong\nintention to distinguish special case / general case) let's limit\nchanges and leave the code as it is.\n\nCheers,\n                       Nicolas",
    "created_at": "2014-04-28T22:11:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109541",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:695'></a>
Replying to [tscrim](#comment%3A693):
> I'm only making changes in the changed code from what I see in the diff. I'll make sure to indent the long join categories as I go along.

Great, thanks.

> The if/else thing is more of a pet peeve of mine, especially when there are large indent blocks floating around.  IDK, I always feel it makes it easier to read usually *shrugs*.

Agreed, large indent blocks can be good use case too. I actually tend
to have the same peeve and have a hard time convincing some of my
colleagues about its reasonable use in teaching.

Anyway, for small if/else's like the recent ones where there is not a
compelling reason (a non trivial indentation reduction, or strong
intention to distinguish special case / general case) let's limit
changes and leave the code as it is.

Cheers,
                       Nicolas



---

archive/issue_comments_109542.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2180b1a79878d734ac275079a271bf88da1e17f3\">2180b1a</a></td><td><code>nix da</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2f9efcd4d8d9cfd3358e8f50aae44321d057ef90\">2f9efcd</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of git://trac.sagemath.org/sage into 10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/14f3712a5c7f0fe5f5ebce2584684bff670152d2\">14f3712</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of git://trac.sagemath.org/sage into 10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/98f0839bed3a830d667b918dfda9c7c8e8e92b9c\">98f0839</a></td><td><code>post-apocalyptic edits</code></td></tr></table>\n",
    "created_at": "2014-04-29T01:49:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109542",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2180b1a79878d734ac275079a271bf88da1e17f3">2180b1a</a></td><td><code>nix da</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2f9efcd4d8d9cfd3358e8f50aae44321d057ef90">2f9efcd</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of git://trac.sagemath.org/sage into 10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/14f3712a5c7f0fe5f5ebce2584684bff670152d2">14f3712</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of git://trac.sagemath.org/sage into 10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/98f0839bed3a830d667b918dfda9c7c8e8e92b9c">98f0839</a></td><td><code>post-apocalyptic edits</code></td></tr></table>




---

archive/issue_comments_109543.json:
```json
{
    "body": "**Changing commit** from \"[59d73760c528cca3ede00c8b0fc951131c79f473](https://github.com/sagemath/sagetrac-mirror/commit/59d73760c528cca3ede00c8b0fc951131c79f473)\" to \"[98f0839bed3a830d667b918dfda9c7c8e8e92b9c](https://github.com/sagemath/sagetrac-mirror/commit/98f0839bed3a830d667b918dfda9c7c8e8e92b9c)\".",
    "created_at": "2014-04-29T01:49:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109543",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[59d73760c528cca3ede00c8b0fc951131c79f473](https://github.com/sagemath/sagetrac-mirror/commit/59d73760c528cca3ede00c8b0fc951131c79f473)" to "[98f0839bed3a830d667b918dfda9c7c8e8e92b9c](https://github.com/sagemath/sagetrac-mirror/commit/98f0839bed3a830d667b918dfda9c7c8e8e92b9c)".



---

archive/issue_comments_109544.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/55a36d645af080eac9c67e224ef809922ed21b82\">55a36d6</a></td><td><code>post-apocalyptic edits (correct this time)</code></td></tr></table>\n",
    "created_at": "2014-04-29T01:56:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109544",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/55a36d645af080eac9c67e224ef809922ed21b82">55a36d6</a></td><td><code>post-apocalyptic edits (correct this time)</code></td></tr></table>




---

archive/issue_comments_109545.json:
```json
{
    "body": "**Changing commit** from \"[98f0839bed3a830d667b918dfda9c7c8e8e92b9c](https://github.com/sagemath/sagetrac-mirror/commit/98f0839bed3a830d667b918dfda9c7c8e8e92b9c)\" to \"[55a36d645af080eac9c67e224ef809922ed21b82](https://github.com/sagemath/sagetrac-mirror/commit/55a36d645af080eac9c67e224ef809922ed21b82)\".",
    "created_at": "2014-04-29T01:56:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109545",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[98f0839bed3a830d667b918dfda9c7c8e8e92b9c](https://github.com/sagemath/sagetrac-mirror/commit/98f0839bed3a830d667b918dfda9c7c8e8e92b9c)" to "[55a36d645af080eac9c67e224ef809922ed21b82](https://github.com/sagemath/sagetrac-mirror/commit/55a36d645af080eac9c67e224ef809922ed21b82)".



---

archive/issue_comments_109546.json:
```json
{
    "body": "<a id='comment:698'></a>\nHi Nicolas,\n\nThanks for clearing up the bin_op code!\n\nReplying to [nthiery](#comment%3A694):\n> It's not a bug, it's explicitly unspecified behavior :-)\n\nI don't think a mention in a TODO block under the examples section is very explicit. Added a warning; do you find its wording overly alarmist?\n\nSorry for the forced push; I need to learn not messing up my branches...\n\n> Anyway, if you want to proceed with this discussion on better\n> specifying the modules / vector spaces / ... categories, please open a\n> separate ticket.\n\nI'll continue this in #16247.\n\nBest regards,\\\\\nDarij\n\n> PS: I like that comment 666 is from git about \"some final fixes\".\n\nI hope rapture is to follow soon as this is merged...",
    "created_at": "2014-04-29T02:00:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109546",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:698'></a>
Hi Nicolas,

Thanks for clearing up the bin_op code!

Replying to [nthiery](#comment%3A694):
> It's not a bug, it's explicitly unspecified behavior :-)

I don't think a mention in a TODO block under the examples section is very explicit. Added a warning; do you find its wording overly alarmist?

Sorry for the forced push; I need to learn not messing up my branches...

> Anyway, if you want to proceed with this discussion on better
> specifying the modules / vector spaces / ... categories, please open a
> separate ticket.

I'll continue this in #16247.

Best regards,\\
Darij

> PS: I like that comment 666 is from git about "some final fixes".

I hope rapture is to follow soon as this is merged...



---

archive/issue_comments_109547.json:
```json
{
    "body": "**Changing commit** from \"[55a36d645af080eac9c67e224ef809922ed21b82](https://github.com/sagemath/sagetrac-mirror/commit/55a36d645af080eac9c67e224ef809922ed21b82)\" to \"[72663b7ae83183d9cd867c5cb6184cf6826b88f3](https://github.com/sagemath/sagetrac-mirror/commit/72663b7ae83183d9cd867c5cb6184cf6826b88f3)\".",
    "created_at": "2014-04-29T20:30:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109547",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[55a36d645af080eac9c67e224ef809922ed21b82](https://github.com/sagemath/sagetrac-mirror/commit/55a36d645af080eac9c67e224ef809922ed21b82)" to "[72663b7ae83183d9cd867c5cb6184cf6826b88f3](https://github.com/sagemath/sagetrac-mirror/commit/72663b7ae83183d9cd867c5cb6184cf6826b88f3)".



---

archive/issue_comments_109548.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2cf2d41b801f2e47351e20bf8f6c497dae1fa60d\">2cf2d41</a></td><td><code>Swapped if/else in unital_algebras.py</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d2b83d40dd215ba03dad78b265ca5fbc11d9f1c8\">d2b83d4</a></td><td><code>Some more minor tweaks, formatting, and python3.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/76f308e5300b1a571957ae4afaeded7c983f3ec3\">76f308e</a></td><td><code>Remainder of doc formatting and python3.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/72663b7ae83183d9cd867c5cb6184cf6826b88f3\">72663b7</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into public/ticket/10963-doc-distributive</code></td></tr></table>\n",
    "created_at": "2014-04-29T20:30:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109548",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2cf2d41b801f2e47351e20bf8f6c497dae1fa60d">2cf2d41</a></td><td><code>Swapped if/else in unital_algebras.py</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d2b83d40dd215ba03dad78b265ca5fbc11d9f1c8">d2b83d4</a></td><td><code>Some more minor tweaks, formatting, and python3.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/76f308e5300b1a571957ae4afaeded7c983f3ec3">76f308e</a></td><td><code>Remainder of doc formatting and python3.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/72663b7ae83183d9cd867c5cb6184cf6826b88f3">72663b7</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into public/ticket/10963-doc-distributive</code></td></tr></table>




---

archive/issue_comments_109549.json:
```json
{
    "body": "<a id='comment:0'></a>\nOkay, I'm done with my pass-through. Doc should build cleanly.",
    "created_at": "2014-04-29T20:34:27Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109549",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:0'></a>
Okay, I'm done with my pass-through. Doc should build cleanly.



---

archive/issue_comments_109550.json:
```json
{
    "body": "**Changing commit** from \"[72663b7ae83183d9cd867c5cb6184cf6826b88f3](https://github.com/sagemath/sagetrac-mirror/commit/72663b7ae83183d9cd867c5cb6184cf6826b88f3)\" to \"[655b1f8878349a53f63db9dec460b54ef2389559](https://github.com/sagemath/sagetrac-mirror/commit/655b1f8878349a53f63db9dec460b54ef2389559)\".",
    "created_at": "2014-04-29T23:33:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109550",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[72663b7ae83183d9cd867c5cb6184cf6826b88f3](https://github.com/sagemath/sagetrac-mirror/commit/72663b7ae83183d9cd867c5cb6184cf6826b88f3)" to "[655b1f8878349a53f63db9dec460b54ef2389559](https://github.com/sagemath/sagetrac-mirror/commit/655b1f8878349a53f63db9dec460b54ef2389559)".



---

archive/issue_comments_109551.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/655b1f8878349a53f63db9dec460b54ef2389559\">655b1f8</a></td><td><code>Trac 10963: Proofread latest changes by Darij and Travis + minor doc edits</code></td></tr></table>\n",
    "created_at": "2014-04-29T23:33:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109551",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/655b1f8878349a53f63db9dec460b54ef2389559">655b1f8</a></td><td><code>Trac 10963: Proofread latest changes by Darij and Travis + minor doc edits</code></td></tr></table>




---

archive/issue_comments_109552.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/14d44490f5990f9e8e9c30931cd1782cebdf2372\">14d4449</a></td><td><code>Trac 10963: Minor doc edit</code></td></tr></table>\n",
    "created_at": "2014-04-29T23:35:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109552",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/14d44490f5990f9e8e9c30931cd1782cebdf2372">14d4449</a></td><td><code>Trac 10963: Minor doc edit</code></td></tr></table>




---

archive/issue_comments_109553.json:
```json
{
    "body": "**Changing commit** from \"[655b1f8878349a53f63db9dec460b54ef2389559](https://github.com/sagemath/sagetrac-mirror/commit/655b1f8878349a53f63db9dec460b54ef2389559)\" to \"[14d44490f5990f9e8e9c30931cd1782cebdf2372](https://github.com/sagemath/sagetrac-mirror/commit/14d44490f5990f9e8e9c30931cd1782cebdf2372)\".",
    "created_at": "2014-04-29T23:35:54Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109553",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[655b1f8878349a53f63db9dec460b54ef2389559](https://github.com/sagemath/sagetrac-mirror/commit/655b1f8878349a53f63db9dec460b54ef2389559)" to "[14d44490f5990f9e8e9c30931cd1782cebdf2372](https://github.com/sagemath/sagetrac-mirror/commit/14d44490f5990f9e8e9c30931cd1782cebdf2372)".



---

archive/issue_comments_109554.json:
```json
{
    "body": "<a id='comment:703'></a>\nReplying to [tscrim](#comment%3A700):\n> Okay, I'm done with my pass-through. Doc should build cleanly.\n\nThanks very much! I proofread it and made just minor changes.\n\nJust one thing: I reverted the punctuation of the inline \"MATH\"\nenvironments for consistency with all the other occurrence in Sage.\n(whether that's the appropriate policy is debatable, but this ticket\nis not a place to discuss this policy, and consistency goes first).\n\nIn one spot, I also reverted a minor stylistic change in the code (in\ngeneral, I like the ``not xxx`` idiom, but in this case I favor the\nconsistency of the condition between the if and elif).\n\nI did a couple more minor edits prompted by yours.\n\nCheers,\n                                 Nicolas\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/655b1f8878349a53f63db9dec460b54ef2389559\">655b1f8</a></td><td><code>Trac 10963: Proofread latest changes by Darij and Travis + minor doc edits</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/14d44490f5990f9e8e9c30931cd1782cebdf2372\">14d4449</a></td><td><code>Trac 10963: Minor doc edit</code></td></tr></table>\n",
    "created_at": "2014-04-29T23:36:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109554",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:703'></a>
Replying to [tscrim](#comment%3A700):
> Okay, I'm done with my pass-through. Doc should build cleanly.

Thanks very much! I proofread it and made just minor changes.

Just one thing: I reverted the punctuation of the inline "MATH"
environments for consistency with all the other occurrence in Sage.
(whether that's the appropriate policy is debatable, but this ticket
is not a place to discuss this policy, and consistency goes first).

In one spot, I also reverted a minor stylistic change in the code (in
general, I like the ``not xxx`` idiom, but in this case I favor the
consistency of the condition between the if and elif).

I did a couple more minor edits prompted by yours.

Cheers,
                                 Nicolas

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/655b1f8878349a53f63db9dec460b54ef2389559">655b1f8</a></td><td><code>Trac 10963: Proofread latest changes by Darij and Travis + minor doc edits</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/14d44490f5990f9e8e9c30931cd1782cebdf2372">14d4449</a></td><td><code>Trac 10963: Minor doc edit</code></td></tr></table>




---

archive/issue_comments_109555.json:
```json
{
    "body": "<a id='comment:4'></a>\nAgreeing with your rewrite of my warning in modules.py, Nicolas; that's a wording I can fully back up.\n\nYou've got an \"a an\" typ in src/sage/categories/additive_semigroups.py.",
    "created_at": "2014-04-29T23:37:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109555",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:4'></a>
Agreeing with your rewrite of my warning in modules.py, Nicolas; that's a wording I can fully back up.

You've got an "a an" typ in src/sage/categories/additive_semigroups.py.



---

archive/issue_comments_109556.json:
```json
{
    "body": "**Changing commit** from \"[14d44490f5990f9e8e9c30931cd1782cebdf2372](https://github.com/sagemath/sagetrac-mirror/commit/14d44490f5990f9e8e9c30931cd1782cebdf2372)\" to \"[9d7762f4f92b627986117d44842ea8abf89f1253](https://github.com/sagemath/sagetrac-mirror/commit/9d7762f4f92b627986117d44842ea8abf89f1253)\".",
    "created_at": "2014-04-29T23:39:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109556",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[14d44490f5990f9e8e9c30931cd1782cebdf2372](https://github.com/sagemath/sagetrac-mirror/commit/14d44490f5990f9e8e9c30931cd1782cebdf2372)" to "[9d7762f4f92b627986117d44842ea8abf89f1253](https://github.com/sagemath/sagetrac-mirror/commit/9d7762f4f92b627986117d44842ea8abf89f1253)".



---

archive/issue_comments_109557.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9d7762f4f92b627986117d44842ea8abf89f1253\">9d7762f</a></td><td><code>Trac 10963: fixed typo</code></td></tr></table>\n",
    "created_at": "2014-04-29T23:39:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109557",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9d7762f4f92b627986117d44842ea8abf89f1253">9d7762f</a></td><td><code>Trac 10963: fixed typo</code></td></tr></table>




---

archive/issue_comments_109558.json:
```json
{
    "body": "<a id='comment:706'></a>\nReplying to [darij](#comment%3A704):\n\nWow, that was a quick answer :-)\n\n> Agreeing with your rewrite of my warning in modules.py, Nicolas; that's a wording I can fully back up.\n\nCool.\n\n> You've got an \"a an\" typ in src/sage/categories/additive_semigroups.py.\n\nFixed. Thanks for spotting!",
    "created_at": "2014-04-29T23:41:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109558",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:706'></a>
Replying to [darij](#comment%3A704):

Wow, that was a quick answer :-)

> Agreeing with your rewrite of my warning in modules.py, Nicolas; that's a wording I can fully back up.

Cool.

> You've got an "a an" typ in src/sage/categories/additive_semigroups.py.

Fixed. Thanks for spotting!



---

archive/issue_comments_109559.json:
```json
{
    "body": "**Changing commit** from \"[9d7762f4f92b627986117d44842ea8abf89f1253](https://github.com/sagemath/sagetrac-mirror/commit/9d7762f4f92b627986117d44842ea8abf89f1253)\" to \"[70e7b323cbdd928b9b05182e950bcdc90d2182bc](https://github.com/sagemath/sagetrac-mirror/commit/70e7b323cbdd928b9b05182e950bcdc90d2182bc)\".",
    "created_at": "2014-04-30T00:14:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109559",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[9d7762f4f92b627986117d44842ea8abf89f1253](https://github.com/sagemath/sagetrac-mirror/commit/9d7762f4f92b627986117d44842ea8abf89f1253)" to "[70e7b323cbdd928b9b05182e950bcdc90d2182bc](https://github.com/sagemath/sagetrac-mirror/commit/70e7b323cbdd928b9b05182e950bcdc90d2182bc)".



---

archive/issue_comments_109560.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/70e7b323cbdd928b9b05182e950bcdc90d2182bc\">70e7b32</a></td><td><code>Fixed some more typos and back to \"if not blah:\".</code></td></tr></table>\n",
    "created_at": "2014-04-30T00:14:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109560",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/70e7b323cbdd928b9b05182e950bcdc90d2182bc">70e7b32</a></td><td><code>Fixed some more typos and back to "if not blah:".</code></td></tr></table>




---

archive/issue_comments_109561.json:
```json
{
    "body": "<a id='comment:8'></a>\nIf you really prefer the `if len(categories) == 0:`, then I won't revert it again. However the `if not categories:` is 2x faster:\n\n```\nsage: p = []\nsage: %timeit if p == []: pass\n10000000 loops, best of 3: 197 ns per loop\nsage: %timeit if not p: pass\n10000000 loops, best of 3: 103 ns per loop\n# This test is unfair since it is a machine int vs a Sage int\nsage: %timeit if len(p) == 0: pass\n1000000 loops, best of 3: 627 ns per loop\nsage: a = int(0)\nsage: %timeit if len(p) == a: pass\n1000000 loops, best of 3: 255 ns per loop\nsage: p = range(1000)\nsage: %timeit if p == []: pass\n10000000 loops, best of 3: 178 ns per loop\nsage: %timeit if not p: pass\n10000000 loops, best of 3: 90.6 ns per loop\nsage: %timeit if len(p) == 0: pass     # Again this is unfair\n1000000 loops, best of 3: 616 ns per loop\nsage: %timeit if len(p) == a: pass\n1000000 loops, best of 3: 247 ns per loop\n```\nEDIT - and as I remember, we compute a large number of join categories (although this is probably a micro-optimization :P)",
    "created_at": "2014-04-30T00:18:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109561",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>
If you really prefer the `if len(categories) == 0:`, then I won't revert it again. However the `if not categories:` is 2x faster:

```
sage: p = []
sage: %timeit if p == []: pass
10000000 loops, best of 3: 197 ns per loop
sage: %timeit if not p: pass
10000000 loops, best of 3: 103 ns per loop
# This test is unfair since it is a machine int vs a Sage int
sage: %timeit if len(p) == 0: pass
1000000 loops, best of 3: 627 ns per loop
sage: a = int(0)
sage: %timeit if len(p) == a: pass
1000000 loops, best of 3: 255 ns per loop
sage: p = range(1000)
sage: %timeit if p == []: pass
10000000 loops, best of 3: 178 ns per loop
sage: %timeit if not p: pass
10000000 loops, best of 3: 90.6 ns per loop
sage: %timeit if len(p) == 0: pass     # Again this is unfair
1000000 loops, best of 3: 616 ns per loop
sage: %timeit if len(p) == a: pass
1000000 loops, best of 3: 247 ns per loop
```
EDIT - and as I remember, we compute a large number of join categories (although this is probably a micro-optimization :P)



---

archive/issue_comments_109562.json:
```json
{
    "body": "<a id='comment:9'></a>\nHmm. Does this mean our coercion system is slowing down comparisons of ints with 0? Couldn't that be fixed by defining a global int_0?",
    "created_at": "2014-04-30T00:20:13Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109562",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:9'></a>
Hmm. Does this mean our coercion system is slowing down comparisons of ints with 0? Couldn't that be fixed by defining a global int_0?



---

archive/issue_comments_109563.json:
```json
{
    "body": "<a id='comment:0'></a>\nThe point is that it is going through our coercion system, it has to as they are different types; whereas the comparison of machine ints does not (well, at least they are the same type [and w/o parents] and their equality test is directly in the ALU -- IDK if they completely avoid the coercion system). Although if this was written in a `.py` file, the actual speed should be the `len(p) == a`. Actually...there might also be some overhead from the secret `Integer(0)` after doing the preparsing... In any case, it's an unfair test. If you want to know more, you'll have to ask someone much more knowledgeable about this core functionality than I.",
    "created_at": "2014-04-30T02:25:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109563",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:0'></a>
The point is that it is going through our coercion system, it has to as they are different types; whereas the comparison of machine ints does not (well, at least they are the same type [and w/o parents] and their equality test is directly in the ALU -- IDK if they completely avoid the coercion system). Although if this was written in a `.py` file, the actual speed should be the `len(p) == a`. Actually...there might also be some overhead from the secret `Integer(0)` after doing the preparsing... In any case, it's an unfair test. If you want to know more, you'll have to ask someone much more knowledgeable about this core functionality than I.



---

archive/issue_comments_109564.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fe1c1c5b6291d548c85d8565068737001675b30a\">fe1c1c5</a></td><td><code>Trac 10963: Removed the old _join helper function in category.py (why was it still there???)</code></td></tr></table>\n",
    "created_at": "2014-04-30T08:00:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109564",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fe1c1c5b6291d548c85d8565068737001675b30a">fe1c1c5</a></td><td><code>Trac 10963: Removed the old _join helper function in category.py (why was it still there???)</code></td></tr></table>




---

archive/issue_comments_109565.json:
```json
{
    "body": "**Changing commit** from \"[70e7b323cbdd928b9b05182e950bcdc90d2182bc](https://github.com/sagemath/sagetrac-mirror/commit/70e7b323cbdd928b9b05182e950bcdc90d2182bc)\" to \"[fe1c1c5b6291d548c85d8565068737001675b30a](https://github.com/sagemath/sagetrac-mirror/commit/fe1c1c5b6291d548c85d8565068737001675b30a)\".",
    "created_at": "2014-04-30T08:00:03Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109565",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[70e7b323cbdd928b9b05182e950bcdc90d2182bc](https://github.com/sagemath/sagetrac-mirror/commit/70e7b323cbdd928b9b05182e950bcdc90d2182bc)" to "[fe1c1c5b6291d548c85d8565068737001675b30a](https://github.com/sagemath/sagetrac-mirror/commit/fe1c1c5b6291d548c85d8565068737001675b30a)".



---

archive/issue_comments_109566.json:
```json
{
    "body": "<a id='comment:712'></a>\nReplying to [tscrim](#comment%3A710):\n> The point is that it is going through our coercion system, it has to as they are different types; whereas the comparison of machine ints does not (well, at least they are the same type [and w/o parents] and their equality test is directly in the ALU -- IDK if they completely avoid the coercion system).\n\nYes, an equality test between two Python integers is completely\nPython's affair. Our coercion system does not interfer. I'd be scared otherwise :-)\n\nAs for the question at hand: allright. The optimization is a bit less relatively negligible than I thought (about 10% in the trivial branches):\n\n```\nsage: %timeit Category.join([])\n100000 loops, best of 3: 2.43 \u00b5s per loop\nsage: S = Sets()\nsage: %timeit Category.join([S])\n1000000 loops, best of 3: 811 ns per loop\nsage: %timeit Category.join([S, S])\n100000 loops, best of 3: 8.85 \u00b5s per loop\nsage: G = Groups(); H = Monoids().Finite()\nsage: %timeit Category.join([G,H])\n100000 loops, best of 3: 9.16 \u00b5s per loop\n```\n\nTravis's commit made me spot that the corpse of the old _join helper\nfunction in category.py was still lying around. Strange it feels like\nthe third time I removed it. There must have been some glitch when the\npatches were imported into git. Anyway, gone with the wind.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fe1c1c5b6291d548c85d8565068737001675b30a\">fe1c1c5</a></td><td><code>Trac 10963: Removed the old _join helper function in category.py (why was it still there???)</code></td></tr></table>\n",
    "created_at": "2014-04-30T08:09:11Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109566",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:712'></a>
Replying to [tscrim](#comment%3A710):
> The point is that it is going through our coercion system, it has to as they are different types; whereas the comparison of machine ints does not (well, at least they are the same type [and w/o parents] and their equality test is directly in the ALU -- IDK if they completely avoid the coercion system).

Yes, an equality test between two Python integers is completely
Python's affair. Our coercion system does not interfer. I'd be scared otherwise :-)

As for the question at hand: allright. The optimization is a bit less relatively negligible than I thought (about 10% in the trivial branches):

```
sage: %timeit Category.join([])
100000 loops, best of 3: 2.43 µs per loop
sage: S = Sets()
sage: %timeit Category.join([S])
1000000 loops, best of 3: 811 ns per loop
sage: %timeit Category.join([S, S])
100000 loops, best of 3: 8.85 µs per loop
sage: G = Groups(); H = Monoids().Finite()
sage: %timeit Category.join([G,H])
100000 loops, best of 3: 9.16 µs per loop
```

Travis's commit made me spot that the corpse of the old _join helper
function in category.py was still lying around. Strange it feels like
the third time I removed it. There must have been some glitch when the
patches were imported into git. Anyway, gone with the wind.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fe1c1c5b6291d548c85d8565068737001675b30a">fe1c1c5</a></td><td><code>Trac 10963: Removed the old _join helper function in category.py (why was it still there???)</code></td></tr></table>




---

archive/issue_comments_109567.json:
```json
{
    "body": "<a id='comment:3'></a>\nDarij, Travis, it sounds like we are in great shape doc-wise, thanks to\nyour hard work!\n\nThere \"just\" remains the rest :-) \n\nSimon, is there anything we can do to help?\n\nCheers,\n                                Nicolas",
    "created_at": "2014-04-30T08:10:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109567",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:3'></a>
Darij, Travis, it sounds like we are in great shape doc-wise, thanks to
your hard work!

There "just" remains the rest :-) 

Simon, is there anything we can do to help?

Cheers,
                                Nicolas



---

archive/issue_comments_109568.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6ca20acaef8beef30ad9030e9fdb9925fbb27a85\">6ca20ac</a></td><td><code>Remove erroneous double colons from semigroups doc</code></td></tr></table>\n",
    "created_at": "2014-05-01T21:21:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109568",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6ca20acaef8beef30ad9030e9fdb9925fbb27a85">6ca20ac</a></td><td><code>Remove erroneous double colons from semigroups doc</code></td></tr></table>




---

archive/issue_comments_109569.json:
```json
{
    "body": "**Changing commit** from \"[fe1c1c5b6291d548c85d8565068737001675b30a](https://github.com/sagemath/sagetrac-mirror/commit/fe1c1c5b6291d548c85d8565068737001675b30a)\" to \"[6ca20acaef8beef30ad9030e9fdb9925fbb27a85](https://github.com/sagemath/sagetrac-mirror/commit/6ca20acaef8beef30ad9030e9fdb9925fbb27a85)\".",
    "created_at": "2014-05-01T21:21:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109569",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[fe1c1c5b6291d548c85d8565068737001675b30a](https://github.com/sagemath/sagetrac-mirror/commit/fe1c1c5b6291d548c85d8565068737001675b30a)" to "[6ca20acaef8beef30ad9030e9fdb9925fbb27a85](https://github.com/sagemath/sagetrac-mirror/commit/6ca20acaef8beef30ad9030e9fdb9925fbb27a85)".



---

archive/issue_comments_109570.json:
```json
{
    "body": "<a id='comment:715'></a>\nReplying to [git](#comment%3A714):\n> Branch pushed to git repo; I updated commit sha1. **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6ca20acaef8beef30ad9030e9fdb9925fbb27a85\">6ca20ac</a></td><td><code>Remove erroneous double colons from semigroups doc</code></td></tr></table>\n\n+1",
    "created_at": "2014-05-01T22:11:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109570",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:715'></a>
Replying to [git](#comment%3A714):
> Branch pushed to git repo; I updated commit sha1. **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6ca20acaef8beef30ad9030e9fdb9925fbb27a85">6ca20ac</a></td><td><code>Remove erroneous double colons from semigroups doc</code></td></tr></table>

+1



---

archive/issue_comments_109571.json:
```json
{
    "body": "<a id='comment:6'></a>\nSo we ended up with a zombie red herring. :p\n\nSimon, what can we do to help?",
    "created_at": "2014-05-03T19:22:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109571",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>
So we ended up with a zombie red herring. :p

Simon, what can we do to help?



---

archive/issue_comments_109572.json:
```json
{
    "body": "<a id='comment:717'></a>\nReplying to [tscrim](#comment%3A716):\n> So we ended up with a zombie red herring. :p\n\nI don't understand that.\n\n> Simon, what can we do to help?\n\nReview #12630 `:-P`",
    "created_at": "2014-05-03T20:43:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109572",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:717'></a>
Replying to [tscrim](#comment%3A716):
> So we ended up with a zombie red herring. :p

I don't understand that.

> Simon, what can we do to help?

Review #12630 `:-P`



---

archive/issue_comments_109573.json:
```json
{
    "body": "<a id='comment:8'></a>\nThe `_join` method exhibited zombie-like behaviors by seemingly returning from the dead, and the issue about the `if` statement was a [red herring](http://en.wikipedia.org/wiki/Red_herring) because it was part of the `_join`.",
    "created_at": "2014-05-03T21:17:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109573",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>
The `_join` method exhibited zombie-like behaviors by seemingly returning from the dead, and the issue about the `if` statement was a [red herring](http://en.wikipedia.org/wiki/Red_herring) because it was part of the `_join`.



---

archive/issue_comments_109574.json:
```json
{
    "body": "<a id='comment:9'></a>\nI will not spend much time on the doc, since y'all have put a lot of work and discussion already. Perhaps you can tell me if you think the following topic is covered. We distinguish between the category that defines an axiom and the category that implements an axiom. Is this distinction clearly stated in the doc? And do the docs provide clear enough examples showing what possibilities/tools are there for defining and what possibilities/tools are there for implementing an axiom?",
    "created_at": "2014-05-03T21:42:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109574",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
I will not spend much time on the doc, since y'all have put a lot of work and discussion already. Perhaps you can tell me if you think the following topic is covered. We distinguish between the category that defines an axiom and the category that implements an axiom. Is this distinction clearly stated in the doc? And do the docs provide clear enough examples showing what possibilities/tools are there for defining and what possibilities/tools are there for implementing an axiom?



---

archive/issue_comments_109575.json:
```json
{
    "body": "<a id='comment:0'></a>\nI see changes such as\n\n```diff\n-        return \"%s algebras over %s\"%(self.base_category()._repr_object_names()[:-1], self.base_ring())\n+        return \"{} algebras over {}\".format(self.base_category()._repr_object_names()[:-1],\n+                                            self.base_ring())\n```\nWhy is `foo.format(bar)` better than `foo%bar`?",
    "created_at": "2014-05-03T23:09:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109575",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
I see changes such as

```diff
-        return "%s algebras over %s"%(self.base_category()._repr_object_names()[:-1], self.base_ring())
+        return "{} algebras over {}".format(self.base_category()._repr_object_names()[:-1],
+                                            self.base_ring())
```
Why is `foo.format(bar)` better than `foo%bar`?



---

archive/issue_comments_109576.json:
```json
{
    "body": "<a id='comment:1'></a>\nPython 3 compliance: http://stackoverflow.com/questions/13945749/string-formatting-in-python-3",
    "created_at": "2014-05-03T23:12:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109576",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:1'></a>
Python 3 compliance: http://stackoverflow.com/questions/13945749/string-formatting-in-python-3



---

archive/issue_comments_109577.json:
```json
{
    "body": "<a id='comment:722'></a>\nReplying to [tscrim](#comment%3A718):\n> The `_join` method exhibited zombie-like behaviors by seemingly returning from the dead, and the issue about the `if` statement was a [red herring](http://en.wikipedia.org/wiki/Red_herring) because it was part of the `_join`.\n\n:-)",
    "created_at": "2014-05-04T07:26:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109577",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:722'></a>
Replying to [tscrim](#comment%3A718):
> The `_join` method exhibited zombie-like behaviors by seemingly returning from the dead, and the issue about the `if` statement was a [red herring](http://en.wikipedia.org/wiki/Red_herring) because it was part of the `_join`.

:-)



---

archive/issue_comments_109578.json:
```json
{
    "body": "<a id='comment:723'></a>\nReplying to [darij](#comment%3A721):\n> Python 3 compliance: http://stackoverflow.com/questions/13945749/string-formatting-in-python-3\n\nMore a matter of taste though, since both syntax work in Python 3.",
    "created_at": "2014-05-04T07:29:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109578",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:723'></a>
Replying to [darij](#comment%3A721):
> Python 3 compliance: http://stackoverflow.com/questions/13945749/string-formatting-in-python-3

More a matter of taste though, since both syntax work in Python 3.



---

archive/issue_comments_109579.json:
```json
{
    "body": "<a id='comment:724'></a>\nReplying to [SimonKing](#comment%3A719):\n> Is this distinction clearly stated in the doc? And do the docs provide clear enough examples showing what possibilities/tools are there for defining and what possibilities/tools are there for implementing an axiom?\n\nYes, in the category_with_axiom main documentation:\n\n- Section \"Implementing axioms\"\n- Section \"Defining an axiom\"\n- Subsection \"Axioms\" in the Section \"Specifications\"\n\nWell, I am not the one to say if it was clear enough, by Darij seemed\nhappy with them :-)\n\nCheers,\n                                Nicolas",
    "created_at": "2014-05-04T07:42:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109579",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:724'></a>
Replying to [SimonKing](#comment%3A719):
> Is this distinction clearly stated in the doc? And do the docs provide clear enough examples showing what possibilities/tools are there for defining and what possibilities/tools are there for implementing an axiom?

Yes, in the category_with_axiom main documentation:

- Section "Implementing axioms"
- Section "Defining an axiom"
- Subsection "Axioms" in the Section "Specifications"

Well, I am not the one to say if it was clear enough, by Darij seemed
happy with them :-)

Cheers,
                                Nicolas



---

archive/issue_comments_109580.json:
```json
{
    "body": "**Changing commit** from \"[6ca20acaef8beef30ad9030e9fdb9925fbb27a85](https://github.com/sagemath/sagetrac-mirror/commit/6ca20acaef8beef30ad9030e9fdb9925fbb27a85)\" to \"[c7ffaf53dbcfd221274967f0d507aa1a1c33db42](https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42)\".",
    "created_at": "2014-05-04T07:43:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109580",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[6ca20acaef8beef30ad9030e9fdb9925fbb27a85](https://github.com/sagemath/sagetrac-mirror/commit/6ca20acaef8beef30ad9030e9fdb9925fbb27a85)" to "[c7ffaf53dbcfd221274967f0d507aa1a1c33db42](https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42)".



---

archive/issue_comments_109581.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42\">c7ffaf5</a></td><td><code>Trac 10963: if not blah in the non zombie non red herring (minor)</code></td></tr></table>\n",
    "created_at": "2014-05-04T07:43:00Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109581",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42">c7ffaf5</a></td><td><code>Trac 10963: if not blah in the non zombie non red herring (minor)</code></td></tr></table>




---

archive/issue_comments_109582.json:
```json
{
    "body": "<a id='comment:726'></a>\nReplying to [git](#comment%3A725):\n> Branch pushed to git repo; I updated commit sha1. **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42\">c7ffaf5</a></td><td><code>Trac 10963: if not blah in the non zombie non red herring (minor)</code></td></tr></table>\n\nThe second hunk of this commit clearly needs to be reverted. It would work around the cache for homsets, wouldn't it?",
    "created_at": "2014-05-04T08:29:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109582",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:726'></a>
Replying to [git](#comment%3A725):
> Branch pushed to git repo; I updated commit sha1. **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42">c7ffaf5</a></td><td><code>Trac 10963: if not blah in the non zombie non red herring (minor)</code></td></tr></table>

The second hunk of this commit clearly needs to be reverted. It would work around the cache for homsets, wouldn't it?



---

archive/issue_comments_109583.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/db5ccf443c64b42d84c23ce9a5b7e8e327e073d1\">db5ccf4</a></td><td><code>Re-enable the cache for homsets. Minor changes in docs</code></td></tr></table>\n",
    "created_at": "2014-05-04T09:10:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109583",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/db5ccf443c64b42d84c23ce9a5b7e8e327e073d1">db5ccf4</a></td><td><code>Re-enable the cache for homsets. Minor changes in docs</code></td></tr></table>




---

archive/issue_comments_109584.json:
```json
{
    "body": "**Changing commit** from \"[c7ffaf53dbcfd221274967f0d507aa1a1c33db42](https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42)\" to \"[db5ccf443c64b42d84c23ce9a5b7e8e327e073d1](https://github.com/sagemath/sagetrac-mirror/commit/db5ccf443c64b42d84c23ce9a5b7e8e327e073d1)\".",
    "created_at": "2014-05-04T09:10:24Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109584",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[c7ffaf53dbcfd221274967f0d507aa1a1c33db42](https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42)" to "[db5ccf443c64b42d84c23ce9a5b7e8e327e073d1](https://github.com/sagemath/sagetrac-mirror/commit/db5ccf443c64b42d84c23ce9a5b7e8e327e073d1)".



---

archive/issue_comments_109585.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5ca347fa95db15d7207d4321e2f84ddc4457eb08\">5ca347f</a></td><td><code>Merge branch 'develop' into ticket/10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/96fa89eaefdbb020d748e42ab23b9a7545621a14\">96fa89e</a></td><td><code>Remove some trailing whitespace</code></td></tr></table>\n",
    "created_at": "2014-05-04T09:17:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109585",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5ca347fa95db15d7207d4321e2f84ddc4457eb08">5ca347f</a></td><td><code>Merge branch 'develop' into ticket/10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/96fa89eaefdbb020d748e42ab23b9a7545621a14">96fa89e</a></td><td><code>Remove some trailing whitespace</code></td></tr></table>




---

archive/issue_comments_109586.json:
```json
{
    "body": "**Changing commit** from \"[db5ccf443c64b42d84c23ce9a5b7e8e327e073d1](https://github.com/sagemath/sagetrac-mirror/commit/db5ccf443c64b42d84c23ce9a5b7e8e327e073d1)\" to \"[96fa89eaefdbb020d748e42ab23b9a7545621a14](https://github.com/sagemath/sagetrac-mirror/commit/96fa89eaefdbb020d748e42ab23b9a7545621a14)\".",
    "created_at": "2014-05-04T09:17:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109586",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[db5ccf443c64b42d84c23ce9a5b7e8e327e073d1](https://github.com/sagemath/sagetrac-mirror/commit/db5ccf443c64b42d84c23ce9a5b7e8e327e073d1)" to "[96fa89eaefdbb020d748e42ab23b9a7545621a14](https://github.com/sagemath/sagetrac-mirror/commit/96fa89eaefdbb020d748e42ab23b9a7545621a14)".



---

archive/issue_comments_109587.json:
```json
{
    "body": "<a id='comment:9'></a>\nOuch. I just mistakenly pushed a superfluous merge with the \"develop\" branch. Well, it doesn't hurt, but it is ugly. And I still don't like that the git people would consider fixing such accidents as bad, because of changing history.",
    "created_at": "2014-05-04T09:20:33Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109587",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Ouch. I just mistakenly pushed a superfluous merge with the "develop" branch. Well, it doesn't hurt, but it is ugly. And I still don't like that the git people would consider fixing such accidents as bad, because of changing history.



---

archive/issue_comments_109588.json:
```json
{
    "body": "<a id='comment:0'></a>\nIs there any mathematical difference between `sage.categories.magmatic_algebras.MagmaticAlgebras(...)` and `Magmas().Algebras(...)`? I see that the former is considered a super category of the latter. But why are they not the same?",
    "created_at": "2014-05-04T15:11:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109588",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Is there any mathematical difference between `sage.categories.magmatic_algebras.MagmaticAlgebras(...)` and `Magmas().Algebras(...)`? I see that the former is considered a super category of the latter. But why are they not the same?



---

archive/issue_comments_109589.json:
```json
{
    "body": "<a id='comment:1'></a>\nAhan! I think the difference is that a magmatic algebra has no basis, whereas an algebra over a fixed magma does have a basis, namely indexed by the elements of the magma. Right?",
    "created_at": "2014-05-04T15:18:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109589",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Ahan! I think the difference is that a magmatic algebra has no basis, whereas an algebra over a fixed magma does have a basis, namely indexed by the elements of the magma. Right?



---

archive/issue_comments_109590.json:
```json
{
    "body": "<a id='comment:732'></a>\n'Replying to [SimonKing](#comment%3A729):\n> And I still don't like that the git people would consider fixing such accidents as bad, because of changing history.\n\nIt's only bad if you rewrite history *someone else depends on*, which is very unlikely if that piece of history only exists for a short time.",
    "created_at": "2014-05-04T15:37:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109590",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:732'></a>
'Replying to [SimonKing](#comment%3A729):
> And I still don't like that the git people would consider fixing such accidents as bad, because of changing history.

It's only bad if you rewrite history *someone else depends on*, which is very unlikely if that piece of history only exists for a short time.



---

archive/issue_comments_109591.json:
```json
{
    "body": "<a id='comment:3'></a>\nThe element methods of Algebras(...) used to provide a copy of `sage.structure.element.AlgebraElement.__mul__` (implementing the coercion framework), but now it is gone. Is this a wise decision? Generally I'd say that one *should* start with `sage.structure.element.AlgebraElement` when one is implementing elements of an algebra.\n\nHowever, because of subtle bug in Cython, it is I think possible to create a Python class inheriting from `sage.categories.map.Map` and `sage.structure.element.AlgebraElement`, but then certain cdef attributes of the two base classes will be confused (hence, the two base classes are actually incompatible, but Cython does not notice).\n\nHence, there will be cases (such as endomorphism rings) where one has an algebra formed by maps, and one can not use `sage.structure.element.AlgebraElement` as a base class. It would then be very handy if one could inherit coercion from the category's element_class.",
    "created_at": "2014-05-04T15:38:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109591",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
The element methods of Algebras(...) used to provide a copy of `sage.structure.element.AlgebraElement.__mul__` (implementing the coercion framework), but now it is gone. Is this a wise decision? Generally I'd say that one *should* start with `sage.structure.element.AlgebraElement` when one is implementing elements of an algebra.

However, because of subtle bug in Cython, it is I think possible to create a Python class inheriting from `sage.categories.map.Map` and `sage.structure.element.AlgebraElement`, but then certain cdef attributes of the two base classes will be confused (hence, the two base classes are actually incompatible, but Cython does not notice).

Hence, there will be cases (such as endomorphism rings) where one has an algebra formed by maps, and one can not use `sage.structure.element.AlgebraElement` as a base class. It would then be very handy if one could inherit coercion from the category's element_class.



---

archive/issue_comments_109592.json:
```json
{
    "body": "<a id='comment:734'></a>\nReplying to [nbruin](#comment%3A732):\n> It's only bad if you rewrite history *someone else depends on*, which is very unlikely if that piece of history only exists for a short time.\n\nWell, I'm not gonna change the commit. After all, the develop branch will be merged at some point anyway, right?\n\nIf I should better remove the merge commit, then please tell me how.",
    "created_at": "2014-05-04T15:40:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109592",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:734'></a>
Replying to [nbruin](#comment%3A732):
> It's only bad if you rewrite history *someone else depends on*, which is very unlikely if that piece of history only exists for a short time.

Well, I'm not gonna change the commit. After all, the develop branch will be merged at some point anyway, right?

If I should better remove the merge commit, then please tell me how.



---

archive/issue_comments_109593.json:
```json
{
    "body": "<a id='comment:5'></a>\nWTF we still have the fucking double inheritance landmine and we haven't even figured out how to make it fail in obvious ways? How do we ever want Sage to scale?\n\n@simon-king-jena: about magmatic algebras vs. magma algebras -- the former are algebras minus the associativity and unitality axioms (thus a generalization of algebras), whereas the latter are free modules over magmas equipped with a magmatic algebra structure induced by the magma's multiplication (thus a generalization of group algebras). So the difference is not just in the existence of a basis; it is in the existence of a (distinguished) *multiplicative* basis.\n\nAbout git pushing, just to give my 5 cents: I usually don't hesitate to force-push over a branch in which I made a merging mistake if said mistake is just a few hours old. The probability of anyone basing on that branch is rather low. Generally dependent branches seem to be a rarity around here.",
    "created_at": "2014-05-04T16:01:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109593",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:5'></a>
WTF we still have the fucking double inheritance landmine and we haven't even figured out how to make it fail in obvious ways? How do we ever want Sage to scale?

@simon-king-jena: about magmatic algebras vs. magma algebras -- the former are algebras minus the associativity and unitality axioms (thus a generalization of algebras), whereas the latter are free modules over magmas equipped with a magmatic algebra structure induced by the magma's multiplication (thus a generalization of group algebras). So the difference is not just in the existence of a basis; it is in the existence of a (distinguished) *multiplicative* basis.

About git pushing, just to give my 5 cents: I usually don't hesitate to force-push over a branch in which I made a merging mistake if said mistake is just a few hours old. The probability of anyone basing on that branch is rather low. Generally dependent branches seem to be a rarity around here.



---

archive/issue_comments_109594.json:
```json
{
    "body": "<a id='comment:736'></a>\nReplying to [darij](#comment%3A735):\n> WTF we still have the fucking double inheritance landmine and we haven't even figured out how to make it fail in obvious ways? How do we ever want Sage to scale?\n\nWell, I once made an easy and obviously failing example, but I was too lazy to look it up on sage-devel or cython-users. But I think it has not been fixed upstream.\n\n\n> About git pushing, just to give my 5 cents: I usually don't hesitate to force-push over a branch in which I made a merging mistake if said mistake is just a few hours old. The probability of anyone basing on that branch is rather low. Generally dependent branches seem to be a rarity around here.\n\nCan you please tell me how to pop the merge commit? What git commands?",
    "created_at": "2014-05-04T16:38:47Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109594",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:736'></a>
Replying to [darij](#comment%3A735):
> WTF we still have the fucking double inheritance landmine and we haven't even figured out how to make it fail in obvious ways? How do we ever want Sage to scale?

Well, I once made an easy and obviously failing example, but I was too lazy to look it up on sage-devel or cython-users. But I think it has not been fixed upstream.


> About git pushing, just to give my 5 cents: I usually don't hesitate to force-push over a branch in which I made a merging mistake if said mistake is just a few hours old. The probability of anyone basing on that branch is rather low. Generally dependent branches seem to be a rarity around here.

Can you please tell me how to pop the merge commit? What git commands?



---

archive/issue_comments_109595.json:
```json
{
    "body": "<a id='comment:737'></a>\nReplying to [SimonKing](#comment%3A736):\n> > About git pushing, just to give my 5 cents: I usually don't hesitate to force-push over a branch in which I made a merging mistake if said mistake is just a few hours old. The probability of anyone basing on that branch is rather low. Generally dependent branches seem to be a rarity around here.\n\n> \n> Can you please tell me how to pop the merge commit? What git commands?\n\nWhat I usually do is:\n\ngit checkout [hex of the commit just before the merge, or whatever commit you want to return to; you can find out the hex using gitk or by looking at the branch here on trac]\n\ngit checkout -b 10963corrected\n\ngit push --force 10963corrected:public/ticket/10963-doc-distributive\n\ngit branch -D [old local branch containing the useless merge]\n\nThis is probably more complicated than necessary...\n\nAnyway, I wouldn't bother with this in this ticket.",
    "created_at": "2014-05-04T16:50:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109595",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:737'></a>
Replying to [SimonKing](#comment%3A736):
> > About git pushing, just to give my 5 cents: I usually don't hesitate to force-push over a branch in which I made a merging mistake if said mistake is just a few hours old. The probability of anyone basing on that branch is rather low. Generally dependent branches seem to be a rarity around here.

> 
> Can you please tell me how to pop the merge commit? What git commands?

What I usually do is:

git checkout [hex of the commit just before the merge, or whatever commit you want to return to; you can find out the hex using gitk or by looking at the branch here on trac]

git checkout -b 10963corrected

git push --force 10963corrected:public/ticket/10963-doc-distributive

git branch -D [old local branch containing the useless merge]

This is probably more complicated than necessary...

Anyway, I wouldn't bother with this in this ticket.



---

archive/issue_comments_109596.json:
```json
{
    "body": "<a id='comment:738'></a>\nReplying to [darij](#comment%3A737):\n> Replying to [SimonKing](#comment%3A736):\n> What I usually do is:\n> \n> git checkout [hex of the commit just before the merge, or whatever commit you want to return to; you can find out the hex using gitk or by looking at the branch here on trac]\n> \n> git checkout -b 10963corrected\n> \n> git push --force 10963corrected:public/ticket/10963-doc-distributive\n\nWhat about the commit that comes *after* the merge?\n\n> Anyway, I wouldn't bother with this in this ticket.\n\nOK.",
    "created_at": "2014-05-04T18:30:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109596",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:738'></a>
Replying to [darij](#comment%3A737):
> Replying to [SimonKing](#comment%3A736):
> What I usually do is:
> 
> git checkout [hex of the commit just before the merge, or whatever commit you want to return to; you can find out the hex using gitk or by looking at the branch here on trac]
> 
> git checkout -b 10963corrected
> 
> git push --force 10963corrected:public/ticket/10963-doc-distributive

What about the commit that comes *after* the merge?

> Anyway, I wouldn't bother with this in this ticket.

OK.



---

archive/issue_comments_109597.json:
```json
{
    "body": "<a id='comment:739'></a>\nReplying to [SimonKing](#comment%3A726):\n> Replying to [git](#comment%3A725):\n> > Branch pushed to git repo; I updated commit sha1. New commits:\n\n> |                                                                                                                                                 |                                                                   |\n> |-------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------|\n> |[c7ffaf5](https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42)|`Trac 10963: if not blah in the non zombie non red herring (minor)`|\n> \n> The second hunk of this commit clearly needs to be reverted. It would work around the cache for homsets, wouldn't it?\n\nYikes! How did I introduce this change?!? Oh well, probably some\nzombie of a debugging session. I should have double checked my diff.\n\nThanks for catching this!\n\nCheers,\n                             Nicolas",
    "created_at": "2014-05-04T21:11:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109597",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:739'></a>
Replying to [SimonKing](#comment%3A726):
> Replying to [git](#comment%3A725):
> > Branch pushed to git repo; I updated commit sha1. New commits:

> |                                                                                                                                                 |                                                                   |
> |-------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------|
> |[c7ffaf5](https://github.com/sagemath/sagetrac-mirror/commit/c7ffaf53dbcfd221274967f0d507aa1a1c33db42)|`Trac 10963: if not blah in the non zombie non red herring (minor)`|
> 
> The second hunk of this commit clearly needs to be reverted. It would work around the cache for homsets, wouldn't it?

Yikes! How did I introduce this change?!? Oh well, probably some
zombie of a debugging session. I should have double checked my diff.

Thanks for catching this!

Cheers,
                             Nicolas



---

archive/issue_comments_109598.json:
```json
{
    "body": "<a id='comment:0'></a>\nI find some comments in `category_with_axiom.py` hard to understand.\n\n```\n        else:\n            # The following fails with Modules(QQ), as the later returns\n            # VectorSpaces(QQ) which is not an instance of the\n            # base_category_class of ModulesWithBasis\n            # return cls(base_category_class(*args, **options))\n            return base_category_class(*args, **options)._with_axiom(axiom)\n```\nWhat is the relation with `Modules`? After all, neither `Modules` nor `VectorSpaces` are subclasses of `CategoryWithAxiom`.",
    "created_at": "2014-05-04T21:20:22Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109598",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
I find some comments in `category_with_axiom.py` hard to understand.

```
        else:
            # The following fails with Modules(QQ), as the later returns
            # VectorSpaces(QQ) which is not an instance of the
            # base_category_class of ModulesWithBasis
            # return cls(base_category_class(*args, **options))
            return base_category_class(*args, **options)._with_axiom(axiom)
```
What is the relation with `Modules`? After all, neither `Modules` nor `VectorSpaces` are subclasses of `CategoryWithAxiom`.



---

archive/issue_comments_109599.json:
```json
{
    "body": "<a id='comment:1'></a>\nWhat I mean is: This part of `CategoryWithAxiom.__classcall__` is responsible for making `ModulesWithBasis(QQ)` result in `VectorSpacesWithBasis(QQ)`, and it *uses* `Modules(QQ)==VectorSpaces(QQ)`. I'll try to rephrase the comment.",
    "created_at": "2014-05-04T21:28:42Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109599",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
What I mean is: This part of `CategoryWithAxiom.__classcall__` is responsible for making `ModulesWithBasis(QQ)` result in `VectorSpacesWithBasis(QQ)`, and it *uses* `Modules(QQ)==VectorSpaces(QQ)`. I'll try to rephrase the comment.



---

archive/issue_comments_109600.json:
```json
{
    "body": "<a id='comment:742'></a>\nReplying to [SimonKing](#comment%3A741):\n> What I mean is: This part of `CategoryWithAxiom.__classcall__` is responsible for making `ModulesWithBasis(QQ)` result in `VectorSpacesWithBasis(QQ)`, and it *uses* `Modules(QQ)==VectorSpaces(QQ)`. I'll try to rephrase the comment.\n\nA better formulation is welcome. Btw, maybe starting with \"The following would fail\" would make it clearer that the comment applies to the commented out idiom.",
    "created_at": "2014-05-04T21:33:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109600",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:742'></a>
Replying to [SimonKing](#comment%3A741):
> What I mean is: This part of `CategoryWithAxiom.__classcall__` is responsible for making `ModulesWithBasis(QQ)` result in `VectorSpacesWithBasis(QQ)`, and it *uses* `Modules(QQ)==VectorSpaces(QQ)`. I'll try to rephrase the comment.

A better formulation is welcome. Btw, maybe starting with "The following would fail" would make it clearer that the comment applies to the commented out idiom.



---

archive/issue_comments_109601.json:
```json
{
    "body": "<a id='comment:743'></a>\nReplying to [SimonKing](#comment%3A733):\n> The element methods of Algebras(...) used to provide a copy of `sage.structure.element.AlgebraElement.__mul__` (implementing the coercion framework), but now it is gone. Is this a wise decision?\n\nIt's now `Magmas.ElementMethods.__mul__`. So we should be good.\n\n> Generally I'd say that one *should* start with `sage.structure.element.AlgebraElement` when one is implementing elements of an algebra.\n> \n> However, because of subtle bug in Cython, it is I think possible to create a Python class inheriting from `sage.categories.map.Map` and `sage.structure.element.AlgebraElement`, but then certain cdef attributes of the two base classes will be confused (hence, the two base classes are actually incompatible, but Cython does not notice).\n> \n> Hence, there will be cases (such as endomorphism rings) where one has an algebra formed by maps, and one can not use `sage.structure.element.AlgebraElement` as a base class. It would then be very handy if one could inherit coercion from the category's element_class.\n\nMost of our algebras based on CombinatorialFreeModule also don't\ninherit from AlgebraElement, as this is only relevant when the\nelements are \"small\" with a very fast arithmetic.\n\nBtw: last year Robert told me that it was now possible to implement\nCython functions with binding behavior. We should really explore this\nat some point to Cythonize all the low level methods in the categories\nlike `__mul__`. But that's for another ticket!\n\nCheers,\n                                  Nicolas",
    "created_at": "2014-05-04T21:45:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109601",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:743'></a>
Replying to [SimonKing](#comment%3A733):
> The element methods of Algebras(...) used to provide a copy of `sage.structure.element.AlgebraElement.__mul__` (implementing the coercion framework), but now it is gone. Is this a wise decision?

It's now `Magmas.ElementMethods.__mul__`. So we should be good.

> Generally I'd say that one *should* start with `sage.structure.element.AlgebraElement` when one is implementing elements of an algebra.
> 
> However, because of subtle bug in Cython, it is I think possible to create a Python class inheriting from `sage.categories.map.Map` and `sage.structure.element.AlgebraElement`, but then certain cdef attributes of the two base classes will be confused (hence, the two base classes are actually incompatible, but Cython does not notice).
> 
> Hence, there will be cases (such as endomorphism rings) where one has an algebra formed by maps, and one can not use `sage.structure.element.AlgebraElement` as a base class. It would then be very handy if one could inherit coercion from the category's element_class.

Most of our algebras based on CombinatorialFreeModule also don't
inherit from AlgebraElement, as this is only relevant when the
elements are "small" with a very fast arithmetic.

Btw: last year Robert told me that it was now possible to implement
Cython functions with binding behavior. We should really explore this
at some point to Cythonize all the low level methods in the categories
like `__mul__`. But that's for another ticket!

Cheers,
                                  Nicolas



---

archive/issue_comments_109602.json:
```json
{
    "body": "<a id='comment:4'></a>\nWhat I currently do not understand is\n\n```\n        if len(args) == 1 and not options and isinstance(args[0], base_category_class):\n            return super(CategoryWithAxiom, cls).__classcall__(cls, args[0])\n```\nDoes this ever occur? Would it not fail if all arguments are passed by name (then, `args=()`!)? In what situation would one have `args[0]` being an instance of the base_category_class?",
    "created_at": "2014-05-04T21:48:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109602",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
What I currently do not understand is

```
        if len(args) == 1 and not options and isinstance(args[0], base_category_class):
            return super(CategoryWithAxiom, cls).__classcall__(cls, args[0])
```
Does this ever occur? Would it not fail if all arguments are passed by name (then, `args=()`!)? In what situation would one have `args[0]` being an instance of the base_category_class?



---

archive/issue_comments_109603.json:
```json
{
    "body": "<a id='comment:745'></a>\nReplying to [nthiery](#comment%3A743):\n> It's now `Magmas.ElementMethods.__mul__`. So we should be good.\n\nOK.\n \n> Most of our algebras based on CombinatorialFreeModule also don't\n> inherit from AlgebraElement, as this is only relevant when the\n> elements are \"small\" with a very fast arithmetic.\n\nAhem, is \"small elements with a very fast arithmetic\" not the typical case?\n \n> Btw: last year Robert told me that it was now possible to implement\n> Cython functions with binding behavior. We should really explore this\n> at some point to Cythonize all the low level methods in the categories\n> like `__mul__`. But that's for another ticket!\n\nOK. Also, I'd like to move `sage.categories.category` and `sage.categories.category_with_axiom` to Cython (but keeping `Category` and `CategoryWithAxiom` Python classes, as they use metaclasses), so that one can accelerate the basic algorithms, such as computing the join.",
    "created_at": "2014-05-04T21:52:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109603",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:745'></a>
Replying to [nthiery](#comment%3A743):
> It's now `Magmas.ElementMethods.__mul__`. So we should be good.

OK.
 
> Most of our algebras based on CombinatorialFreeModule also don't
> inherit from AlgebraElement, as this is only relevant when the
> elements are "small" with a very fast arithmetic.

Ahem, is "small elements with a very fast arithmetic" not the typical case?
 
> Btw: last year Robert told me that it was now possible to implement
> Cython functions with binding behavior. We should really explore this
> at some point to Cythonize all the low level methods in the categories
> like `__mul__`. But that's for another ticket!

OK. Also, I'd like to move `sage.categories.category` and `sage.categories.category_with_axiom` to Cython (but keeping `Category` and `CategoryWithAxiom` Python classes, as they use metaclasses), so that one can accelerate the basic algorithms, such as computing the join.



---

archive/issue_comments_109604.json:
```json
{
    "body": "<a id='comment:746'></a>\nReplying to [SimonKing](#comment%3A744):\n> What I currently do not understand is\n> \n> ```\n>         if len(args) == 1 and not options and isinstance(args[0], base_category_class):\n>             return super(CategoryWithAxiom, cls).__classcall__(cls, args[0])\n> ```\n> Does this ever occur? Would it not fail if all arguments are passed by name (then, `args=()`!)? In what situation would one have `args[0]` being an instance of the base_category_class?  \n\nI just checked (by inserting print statements) that it does occur. But I don't understand why.",
    "created_at": "2014-05-04T21:55:12Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109604",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:746'></a>
Replying to [SimonKing](#comment%3A744):
> What I currently do not understand is
> 
> ```
>         if len(args) == 1 and not options and isinstance(args[0], base_category_class):
>             return super(CategoryWithAxiom, cls).__classcall__(cls, args[0])
> ```
> Does this ever occur? Would it not fail if all arguments are passed by name (then, `args=()`!)? In what situation would one have `args[0]` being an instance of the base_category_class?  

I just checked (by inserting print statements) that it does occur. But I don't understand why.



---

archive/issue_comments_109605.json:
```json
{
    "body": "<a id='comment:747'></a>\nReplying to [SimonKing](#comment%3A746):\n> Replying to [SimonKing](#comment%3A744):\n> > What I currently do not understand is ...\n> > Does this ever occur? Would it not fail if all arguments are passed by name (then, `args=()`!)? In what situation would one have `args[0]` being an instance of the base_category_class?  \n\n> \n> I just checked (by inserting print statements) that it does occur. But I don't understand why.\n\nLet `B=Cs.A` be a subclass of CategoryWithAxiom. At the end of the day\nall the idioms like `Cs().A()`, `Cs()._with_axiom(\"A\")`, `B()`, ...\nconstruct the category with axiom by calling B(Cs()).\n\nHope this helps ...\n\nCheers,\n                            Nicolas",
    "created_at": "2014-05-04T22:06:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109605",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:747'></a>
Replying to [SimonKing](#comment%3A746):
> Replying to [SimonKing](#comment%3A744):
> > What I currently do not understand is ...
> > Does this ever occur? Would it not fail if all arguments are passed by name (then, `args=()`!)? In what situation would one have `args[0]` being an instance of the base_category_class?  

> 
> I just checked (by inserting print statements) that it does occur. But I don't understand why.

Let `B=Cs.A` be a subclass of CategoryWithAxiom. At the end of the day
all the idioms like `Cs().A()`, `Cs()._with_axiom("A")`, `B()`, ...
construct the category with axiom by calling B(Cs()).

Hope this helps ...

Cheers,
                            Nicolas



---

archive/issue_comments_109606.json:
```json
{
    "body": "<a id='comment:748'></a>\nReplying to [SimonKing](#comment%3A745):\n> OK. Also, I'd like to move `sage.categories.category` and `sage.categories.category_with_axiom` to Cython (but keeping `Category` and `CategoryWithAxiom` Python classes, as they use metaclasses), so that one can accelerate the basic algorithms, such as computing the join.\n\nYes, certainly worth trying! I am not hoping for much gain though, as\nthose algorithms are mostly calling methods around, rather than doing\nthings like list manipulation or the like. Then, unless I am wrong and\nthere is a real gain, I'll prefer keeping those files in Python to\nmake debugging easier.",
    "created_at": "2014-05-04T22:10:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109606",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:748'></a>
Replying to [SimonKing](#comment%3A745):
> OK. Also, I'd like to move `sage.categories.category` and `sage.categories.category_with_axiom` to Cython (but keeping `Category` and `CategoryWithAxiom` Python classes, as they use metaclasses), so that one can accelerate the basic algorithms, such as computing the join.

Yes, certainly worth trying! I am not hoping for much gain though, as
those algorithms are mostly calling methods around, rather than doing
things like list manipulation or the like. Then, unless I am wrong and
there is a real gain, I'll prefer keeping those files in Python to
make debugging easier.



---

archive/issue_comments_109607.json:
```json
{
    "body": "<a id='comment:749'></a>\nReplying to [SimonKing](#comment%3A745):\n> Ahem, is \"small elements with a very fast arithmetic\" not the typical case?\n\nAt least not for my typical application :-)",
    "created_at": "2014-05-04T22:13:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109607",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:749'></a>
Replying to [SimonKing](#comment%3A745):
> Ahem, is "small elements with a very fast arithmetic" not the typical case?

At least not for my typical application :-)



---

archive/issue_comments_109608.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/aa07ba19487569ef26772c51092c4d5342faff7c\">aa07ba1</a></td><td><code>trac #16269: Working around \"officially not a bug\"</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d22e245049e26dd10522d3514603868701a286fb\">d22e245</a></td><td><code>trac #16269: missing __iter__</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f262faa2796f58bd05fdc5d7c46d3cb84d59eb62\">f262faa</a></td><td><code>trac #16269: Merged with 6.2.rc1</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/338cc5b99fe50f435d2f6600eea46cffa372305a\">338cc5b</a></td><td><code>trac #16269: Reviewer's remarks</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8ac32c2d6854519a96eb1ce261240a0ee8537cb3\">8ac32c2</a></td><td><code>#16280: Fix call for FiniteEnumeratedSet's of plain Python objects</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4e274542d24211d57e9f6d99562c56385235721a\">4e27454</a></td><td><code>#16280: Trivial doctest fixes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f67d82e378c4337dcf8cde49d2ca7d6e5b774086\">f67d82e</a></td><td><code>trac #16269: Merged with #16280</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0a54b68c242cc6541108b709170c35b3a79515b8\">0a54b68</a></td><td><code>Trac 16269: little improvements + line folding in the doctest output</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b5ad803eeb1e72e8f276416e7267a351ac314ed2\">b5ad803</a></td><td><code>Trac 16269 (or follow up): optimize CartesianProduct._cartesian_product_of_elements</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d2bc8b2d3523e3d5e295cd727286053ecc334534\">d2bc8b2</a></td><td><code>Merge cartesian product functionalities from '#16269 and #16288' into categories/axioms-10963</code></td></tr></table>\n",
    "created_at": "2014-05-04T23:03:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109608",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **Last 10 new commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/aa07ba19487569ef26772c51092c4d5342faff7c">aa07ba1</a></td><td><code>trac #16269: Working around "officially not a bug"</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d22e245049e26dd10522d3514603868701a286fb">d22e245</a></td><td><code>trac #16269: missing __iter__</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f262faa2796f58bd05fdc5d7c46d3cb84d59eb62">f262faa</a></td><td><code>trac #16269: Merged with 6.2.rc1</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/338cc5b99fe50f435d2f6600eea46cffa372305a">338cc5b</a></td><td><code>trac #16269: Reviewer's remarks</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8ac32c2d6854519a96eb1ce261240a0ee8537cb3">8ac32c2</a></td><td><code>#16280: Fix call for FiniteEnumeratedSet's of plain Python objects</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4e274542d24211d57e9f6d99562c56385235721a">4e27454</a></td><td><code>#16280: Trivial doctest fixes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f67d82e378c4337dcf8cde49d2ca7d6e5b774086">f67d82e</a></td><td><code>trac #16269: Merged with #16280</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0a54b68c242cc6541108b709170c35b3a79515b8">0a54b68</a></td><td><code>Trac 16269: little improvements + line folding in the doctest output</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b5ad803eeb1e72e8f276416e7267a351ac314ed2">b5ad803</a></td><td><code>Trac 16269 (or follow up): optimize CartesianProduct._cartesian_product_of_elements</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d2bc8b2d3523e3d5e295cd727286053ecc334534">d2bc8b2</a></td><td><code>Merge cartesian product functionalities from '#16269 and #16288' into categories/axioms-10963</code></td></tr></table>




---

archive/issue_comments_109609.json:
```json
{
    "body": "**Changing commit** from \"[96fa89eaefdbb020d748e42ab23b9a7545621a14](https://github.com/sagemath/sagetrac-mirror/commit/96fa89eaefdbb020d748e42ab23b9a7545621a14)\" to \"[d2bc8b2d3523e3d5e295cd727286053ecc334534](https://github.com/sagemath/sagetrac-mirror/commit/d2bc8b2d3523e3d5e295cd727286053ecc334534)\".",
    "created_at": "2014-05-04T23:03:35Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109609",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[96fa89eaefdbb020d748e42ab23b9a7545621a14](https://github.com/sagemath/sagetrac-mirror/commit/96fa89eaefdbb020d748e42ab23b9a7545621a14)" to "[d2bc8b2d3523e3d5e295cd727286053ecc334534](https://github.com/sagemath/sagetrac-mirror/commit/d2bc8b2d3523e3d5e295cd727286053ecc334534)".



---

archive/issue_comments_109610.json:
```json
{
    "body": "<a id='comment:1'></a>\nFor the record: all long tests still pass after this merge.",
    "created_at": "2014-05-04T23:46:38Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109610",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:1'></a>
For the record: all long tests still pass after this merge.



---

archive/issue_comments_109611.json:
```json
{
    "body": "<a id='comment:2'></a>\nCurrently for elements to work with matrices (and free modules I believe), elements need to inherit from `RingElement` (and hence `AlgebraElement`). See #15947 for some discussion and #14848 for a use case.",
    "created_at": "2014-05-05T00:07:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109611",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>
Currently for elements to work with matrices (and free modules I believe), elements need to inherit from `RingElement` (and hence `AlgebraElement`). See #15947 for some discussion and #14848 for a use case.



---

archive/issue_comments_109612.json:
```json
{
    "body": "<a id='comment:753'></a>\nReplying to [tscrim](#comment%3A752):\n> Currently for elements to work with matrices (and free modules I believe), elements need to inherit from `RingElement`. See #15947 for some discussion and #14848 for a use case.\n\n#804 (needs review by the way, not as daunting as the elitist ticket number suggests!) fixes `Matrix` so that it only inherits from `ModuleElement`.",
    "created_at": "2014-05-05T00:30:16Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109612",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:753'></a>
Replying to [tscrim](#comment%3A752):
> Currently for elements to work with matrices (and free modules I believe), elements need to inherit from `RingElement`. See #15947 for some discussion and #14848 for a use case.

#804 (needs review by the way, not as daunting as the elitist ticket number suggests!) fixes `Matrix` so that it only inherits from `ModuleElement`.



---

archive/issue_comments_109613.json:
```json
{
    "body": "<a id='comment:754'></a>\nReplying to [git](#comment%3A750):\n> Branch pushed to git repo; I updated commit sha1. Last 10 new commits:\n\nIs it really a good idea to add 10 long commits at this stage, that actually don't seem to be vital for the topic of this ticket?",
    "created_at": "2014-05-05T08:51:57Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109613",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:754'></a>
Replying to [git](#comment%3A750):
> Branch pushed to git repo; I updated commit sha1. Last 10 new commits:

Is it really a good idea to add 10 long commits at this stage, that actually don't seem to be vital for the topic of this ticket?



---

archive/issue_comments_109614.json:
```json
{
    "body": "<a id='comment:755'></a>\nReplying to [SimonKing](#comment%3A754):\n> Replying to [git](#comment%3A750):\n> > Branch pushed to git repo; I updated commit sha1. Last 10 new commits:\n\n> \n> Is it really a good idea to add 10 long commits at this stage, that actually don't seem to be vital for the topic of this ticket?\n\nYeah, if it was just for me, #14269 would have been implemented as a\nfollow up to this ticket.\n\nBut #14269 is positive review and almost certainly will be merged\nbefore this ticket. Since the two tickets are conflicting\n(syntactically and semantically), I had not choice than to merge\n#14269 here and do the resolution. Only the merge commit needs to be\ndouble checked; the others have been reviewed as part of #14269.\n\nCheers,\n                                   Nicolas",
    "created_at": "2014-05-05T09:34:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109614",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:755'></a>
Replying to [SimonKing](#comment%3A754):
> Replying to [git](#comment%3A750):
> > Branch pushed to git repo; I updated commit sha1. Last 10 new commits:

> 
> Is it really a good idea to add 10 long commits at this stage, that actually don't seem to be vital for the topic of this ticket?

Yeah, if it was just for me, #14269 would have been implemented as a
follow up to this ticket.

But #14269 is positive review and almost certainly will be merged
before this ticket. Since the two tickets are conflicting
(syntactically and semantically), I had not choice than to merge
#14269 here and do the resolution. Only the merge commit needs to be
double checked; the others have been reviewed as part of #14269.

Cheers,
                                   Nicolas



---

archive/issue_comments_109615.json:
```json
{
    "body": "<a id='comment:756'></a>\nReplying to [nthiery](#comment%3A755):\n> But #14269 is positive review and almost certainly will be merged\n> before this ticket. Since the two tickets are conflicting\n> (syntactically and semantically), I had not choice than to merge\n> #14269 here and do the resolution. Only the merge commit needs to be\n> double checked; the others have been reviewed as part of #14269.\n\nI see. OK, I'll return to having a final look at the intestines of your code (i.e., the \"black magic\"). When this is done and if the tests all pass, then I think we can finally end up with a positive review, given that the documentation has improved a lot recently.",
    "created_at": "2014-05-05T09:41:52Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109615",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:756'></a>
Replying to [nthiery](#comment%3A755):
> But #14269 is positive review and almost certainly will be merged
> before this ticket. Since the two tickets are conflicting
> (syntactically and semantically), I had not choice than to merge
> #14269 here and do the resolution. Only the merge commit needs to be
> double checked; the others have been reviewed as part of #14269.

I see. OK, I'll return to having a final look at the intestines of your code (i.e., the "black magic"). When this is done and if the tests all pass, then I think we can finally end up with a positive review, given that the documentation has improved a lot recently.



---

archive/issue_comments_109616.json:
```json
{
    "body": "<a id='comment:757'></a>\nReplying to [darij](#comment%3A735):\n> WTF we still have the fucking double inheritance landmine and we haven't even figured out how to make it fail in obvious ways? How do we ever want Sage to scale?\n\nFor reference: There are threads on [cython-users](https://groups.google.com/forum/#!searchin/cython-users/Problem$20with$20inheritance$20from$20two$20extension$20classes/cython-users/-GvwK6sEF0E/vAaliNBQ9XMJ) (or [here](https://groups.google.com/forum/#!searchin/cython-users/sage$20map$20element/cython-users/WpOZ0YBDJuc/zA7K-SEoJKoJ)) and on [sage-devel](https://groups.google.com/forum/#!searchin/sage-devel/Problem$20with$20inheritance$20from$20two$20extension$20classes/sage-devel/qF4yU6Vdmao/wQlNrneSmWAJ).\n\nAnd here is a short example, showing that the problem persists:\n\n```\nsage: cython(\"\"\"\n....: from sage.structure.element cimport ModuleElement\n....: from sage.categories.map cimport Map\n....: def test1(a):\n....:     return <size_t>((<Map>a)._update_slots)\n....: def test2(a):\n....:     return <size_t>((<ModuleElement>a)._add_)\n....: \"\"\")\nsage: from sage.categories.map import Map\nsage: class C(Map, ModuleElement): pass\n....:\nsage: a = C(Hom(ZZ,ZZ))\nsage: test1(a) == test2(a)\nTrue\n```\nIn other words, `_add_` (of `ModuleElement`)  and `_update_slots` (of `Map`) have the same address in memory, which is not what we want.",
    "created_at": "2014-05-05T13:25:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109616",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:757'></a>
Replying to [darij](#comment%3A735):
> WTF we still have the fucking double inheritance landmine and we haven't even figured out how to make it fail in obvious ways? How do we ever want Sage to scale?

For reference: There are threads on [cython-users](https://groups.google.com/forum/#!searchin/cython-users/Problem$20with$20inheritance$20from$20two$20extension$20classes/cython-users/-GvwK6sEF0E/vAaliNBQ9XMJ) (or [here](https://groups.google.com/forum/#!searchin/cython-users/sage$20map$20element/cython-users/WpOZ0YBDJuc/zA7K-SEoJKoJ)) and on [sage-devel](https://groups.google.com/forum/#!searchin/sage-devel/Problem$20with$20inheritance$20from$20two$20extension$20classes/sage-devel/qF4yU6Vdmao/wQlNrneSmWAJ).

And here is a short example, showing that the problem persists:

```
sage: cython("""
....: from sage.structure.element cimport ModuleElement
....: from sage.categories.map cimport Map
....: def test1(a):
....:     return <size_t>((<Map>a)._update_slots)
....: def test2(a):
....:     return <size_t>((<ModuleElement>a)._add_)
....: """)
sage: from sage.categories.map import Map
sage: class C(Map, ModuleElement): pass
....:
sage: a = C(Hom(ZZ,ZZ))
sage: test1(a) == test2(a)
True
```
In other words, `_add_` (of `ModuleElement`)  and `_update_slots` (of `Map`) have the same address in memory, which is not what we want.



---

archive/issue_comments_109617.json:
```json
{
    "body": "<a id='comment:8'></a>\nFTR, I believe Nicolas means #16269 instead of #14269.",
    "created_at": "2014-05-05T15:01:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109617",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>
FTR, I believe Nicolas means #16269 instead of #14269.



---

archive/issue_comments_109618.json:
```json
{
    "body": "**Changing dependencies** from \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #16244\" to \"#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #16244, #16269\".",
    "created_at": "2014-05-05T15:01:45Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109618",
    "user": "https://github.com/tscrim"
}
```

**Changing dependencies** from "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #16244" to "#11224, #8327, #10193, #12895, #14516, #14722, #13589, #14471, #15069, #15094, #11688, #13394, #15150, #15506, #15757, #15759, #16244, #16269".



---

archive/issue_comments_109619.json:
```json
{
    "body": "<a id='comment:9'></a>\nJust a remark: We should perhaps better replace the `axioms_rank` cached function by a faster idiom:\n\n```\nsage: D = dict((k,v) for v,k in enumerate(all_axioms))\nsage: %timeit D['Distributive']\n10000000 loops, best of 3: 84 ns per loop\nsage: %timeit axioms_rank('Distributive')\n1000000 loops, best of 3: 576 ns per loop\n```\nThe above is with a warm cache.\n\nBut I suppose that's for a follow-up ticket.",
    "created_at": "2014-05-06T08:17:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109619",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Just a remark: We should perhaps better replace the `axioms_rank` cached function by a faster idiom:

```
sage: D = dict((k,v) for v,k in enumerate(all_axioms))
sage: %timeit D['Distributive']
10000000 loops, best of 3: 84 ns per loop
sage: %timeit axioms_rank('Distributive')
1000000 loops, best of 3: 576 ns per loop
```
The above is with a warm cache.

But I suppose that's for a follow-up ticket.



---

archive/issue_comments_109620.json:
```json
{
    "body": "<a id='comment:760'></a>\nReplying to [SimonKing](#comment%3A759):\n> Just a remark: We should perhaps better replace the `axioms_rank` cached function by a faster idiom:\n> \n> ```\n> sage: D = dict((k,v) for v,k in enumerate(all_axioms))\n> sage: %timeit D['Distributive']\n> 10000000 loops, best of 3: 84 ns per loop\n> sage: %timeit axioms_rank('Distributive')\n> 1000000 loops, best of 3: 576 ns per loop\n> ```\n> The above is with a warm cache.\n> But I suppose that's for a follow-up ticket.\n\nOk. This will be a natural thing to do when we will have decided on a\nproper protocol for registering new axiom names. Feel free to leave a\ntodo in the code about this.",
    "created_at": "2014-05-06T08:57:20Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109620",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:760'></a>
Replying to [SimonKing](#comment%3A759):
> Just a remark: We should perhaps better replace the `axioms_rank` cached function by a faster idiom:
> 
> ```
> sage: D = dict((k,v) for v,k in enumerate(all_axioms))
> sage: %timeit D['Distributive']
> 10000000 loops, best of 3: 84 ns per loop
> sage: %timeit axioms_rank('Distributive')
> 1000000 loops, best of 3: 576 ns per loop
> ```
> The above is with a warm cache.
> But I suppose that's for a follow-up ticket.

Ok. This will be a natural thing to do when we will have decided on a
proper protocol for registering new axiom names. Feel free to leave a
todo in the code about this.



---

archive/issue_comments_109621.json:
```json
{
    "body": "<a id='comment:761'></a>\nReplying to [nthiery](#comment%3A760):\n> Ok. This will be a natural thing to do when we will have decided on a\n> proper protocol for registering new axiom names.\n\nWell, if I see that correctly, some tests append (temporarily) to `all_axioms`, but otherwise it is left untouched. This could mimicked along the following lines:\n\n```\nsage: cython(\"\"\"\n....: cdef class AxiomsDict(dict):\n....:     def append(self, axiom):\n....:         self[axiom] = len(self)\n....: \"\"\")\nsage: D = AxiomsDict()\nsage: from sage.categories.category_with_axiom import all_axioms\nsage: for axiom in all_axioms: D.append(axiom)\nsage: D\n{'AdditiveAssociative': 16,\n 'AdditiveCommutative': 15,\n 'AdditiveInverse': 17,\n 'AdditiveUnital': 18,\n 'Associative': 10,\n 'Blue': 1,\n 'Commutative': 9,\n 'Connected': 6,\n 'Distributive': 19,\n 'Division': 13,\n 'Facade': 2,\n 'Finite': 3,\n 'FiniteDimensional': 5,\n 'Flying': 0,\n 'Infinite': 4,\n 'Inverse': 11,\n 'Irreducible': 8,\n 'NoZeroDivisors': 14,\n 'Unital': 12,\n 'WithBasis': 7}\nsage: %timeit D['Distributive']\n10000000 loops, best of 3: 86.5 ns per loop\nsage: %timeit 'Division' in all_axioms\n1000000 loops, best of 3: 470 ns per loop\nsage: %timeit 'Division' in D\n10000000 loops, best of 3: 90.3 ns per loop\nsage: D.append('Super')\nsage: D['Super']\n20\nsage: del D['Super']\n```\n\nHence, it would be possible to use this as a temporary improvement (speed-up) in the evolution towards a good solution for registering new axioms. But, as I said, this is for a later ticket, perhaps together with using Cython for category(_with_axiom).",
    "created_at": "2014-05-06T09:55:02Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109621",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:761'></a>
Replying to [nthiery](#comment%3A760):
> Ok. This will be a natural thing to do when we will have decided on a
> proper protocol for registering new axiom names.

Well, if I see that correctly, some tests append (temporarily) to `all_axioms`, but otherwise it is left untouched. This could mimicked along the following lines:

```
sage: cython("""
....: cdef class AxiomsDict(dict):
....:     def append(self, axiom):
....:         self[axiom] = len(self)
....: """)
sage: D = AxiomsDict()
sage: from sage.categories.category_with_axiom import all_axioms
sage: for axiom in all_axioms: D.append(axiom)
sage: D
{'AdditiveAssociative': 16,
 'AdditiveCommutative': 15,
 'AdditiveInverse': 17,
 'AdditiveUnital': 18,
 'Associative': 10,
 'Blue': 1,
 'Commutative': 9,
 'Connected': 6,
 'Distributive': 19,
 'Division': 13,
 'Facade': 2,
 'Finite': 3,
 'FiniteDimensional': 5,
 'Flying': 0,
 'Infinite': 4,
 'Inverse': 11,
 'Irreducible': 8,
 'NoZeroDivisors': 14,
 'Unital': 12,
 'WithBasis': 7}
sage: %timeit D['Distributive']
10000000 loops, best of 3: 86.5 ns per loop
sage: %timeit 'Division' in all_axioms
1000000 loops, best of 3: 470 ns per loop
sage: %timeit 'Division' in D
10000000 loops, best of 3: 90.3 ns per loop
sage: D.append('Super')
sage: D['Super']
20
sage: del D['Super']
```

Hence, it would be possible to use this as a temporary improvement (speed-up) in the evolution towards a good solution for registering new axioms. But, as I said, this is for a later ticket, perhaps together with using Cython for category(_with_axiom).



---

archive/issue_comments_109622.json:
```json
{
    "body": "<a id='comment:2'></a>\nI went through the critical parts of the code (sage.categories.category_with_axioms and sage.categories.category) again, and found it good. Sure, it will not be the end of the story, but I think speedups (cythonization) and conceptual changes (e.g., my beloved database using Gr\u00f6bner bases in boolean polynomial rings under the hood) will be for follow-up tickets.\n\nMoreover I have done some edits in docs and comments. I think I didn't do anything in the code, but please verify. if the tests all pass, then I'll push my changes and turn it into positive review.\n\nQUESTION:\n\nWhat follow-up tickets have already been created?",
    "created_at": "2014-05-06T10:30:19Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109622",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
I went through the critical parts of the code (sage.categories.category_with_axioms and sage.categories.category) again, and found it good. Sure, it will not be the end of the story, but I think speedups (cythonization) and conceptual changes (e.g., my beloved database using Gröbner bases in boolean polynomial rings under the hood) will be for follow-up tickets.

Moreover I have done some edits in docs and comments. I think I didn't do anything in the code, but please verify. if the tests all pass, then I'll push my changes and turn it into positive review.

QUESTION:

What follow-up tickets have already been created?



---

archive/issue_comments_109623.json:
```json
{
    "body": "**Changing commit** from \"[d2bc8b2d3523e3d5e295cd727286053ecc334534](https://github.com/sagemath/sagetrac-mirror/commit/d2bc8b2d3523e3d5e295cd727286053ecc334534)\" to \"[e9c3586de03c38397641e6d3347deddeef7c08a4](https://github.com/sagemath/sagetrac-mirror/commit/e9c3586de03c38397641e6d3347deddeef7c08a4)\".",
    "created_at": "2014-05-06T11:38:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109623",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[d2bc8b2d3523e3d5e295cd727286053ecc334534](https://github.com/sagemath/sagetrac-mirror/commit/d2bc8b2d3523e3d5e295cd727286053ecc334534)" to "[e9c3586de03c38397641e6d3347deddeef7c08a4](https://github.com/sagemath/sagetrac-mirror/commit/e9c3586de03c38397641e6d3347deddeef7c08a4)".



---

archive/issue_comments_109624.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e9c3586de03c38397641e6d3347deddeef7c08a4\">e9c3586</a></td><td><code>Some fixes to the docs and to comments in the code (review patch)</code></td></tr></table>\n",
    "created_at": "2014-05-06T11:38:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109624",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e9c3586de03c38397641e6d3347deddeef7c08a4">e9c3586</a></td><td><code>Some fixes to the docs and to comments in the code (review patch)</code></td></tr></table>




---

archive/issue_comments_109625.json:
```json
{
    "body": "<a id='comment:4'></a>\nWith the review patch, all tests pass, and I am sufficiently happy with the code. I hope you are happy with the review patch...\n\nIs there a follow-up ticket for speeding stuff up? If not, I'll create one.\n\nWhat other follow-up tickets have been created yet?",
    "created_at": "2014-05-06T11:42:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109625",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
With the review patch, all tests pass, and I am sufficiently happy with the code. I hope you are happy with the review patch...

Is there a follow-up ticket for speeding stuff up? If not, I'll create one.

What other follow-up tickets have been created yet?



---

archive/issue_events_085491.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-06T11:42:59Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85491"
}
```



---

archive/issue_events_085492.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-06T11:42:59Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85492"
}
```



---

archive/issue_comments_109626.json:
```json
{
    "body": "<a id='comment:766'></a>\nReplying to [SimonKing](#comment%3A764):\n> With the review patch, all tests pass, and I am sufficiently happy with the code.\n\nYippee!\n\n> I hope you are happy with the review patch...\n\nLooking at it right now!\n\n> Is there a follow-up ticket for speeding stuff up? If not, I'll create one.\n> What other follow-up tickets have been created yet?\n\nSpecifically about the axiom infrastructure, none as far as I can remember (I should have created such!)",
    "created_at": "2014-05-06T12:33:56Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109626",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:766'></a>
Replying to [SimonKing](#comment%3A764):
> With the review patch, all tests pass, and I am sufficiently happy with the code.

Yippee!

> I hope you are happy with the review patch...

Looking at it right now!

> Is there a follow-up ticket for speeding stuff up? If not, I'll create one.
> What other follow-up tickets have been created yet?

Specifically about the axiom infrastructure, none as far as I can remember (I should have created such!)



---

archive/issue_comments_109627.json:
```json
{
    "body": "<a id='comment:767'></a>\nReplying to [nthiery](#comment%3A766):\n> Specifically about the axiom infrastructure, none as far as I can remember (I should have created such!)\n\nI have created #16296 for performance. I think this should be done first, as (some of) the to-be-optimized algorithms will be relevant even when switching to a new model for axioms.",
    "created_at": "2014-05-06T14:00:51Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109627",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:767'></a>
Replying to [nthiery](#comment%3A766):
> Specifically about the axiom infrastructure, none as far as I can remember (I should have created such!)

I have created #16296 for performance. I think this should be done first, as (some of) the to-be-optimized algorithms will be relevant even when switching to a new model for axioms.



---

archive/issue_comments_109628.json:
```json
{
    "body": "<a id='comment:8'></a>\nCONGRATULATIONS!\n\nWhat is the current state of performance, without any planned further patches?\n\nA probably incomplete list of open stuff related to this ticket:\n\n#804 Matrix should not inherit from AlgebraElement\n\n#3685 make damned sure that \"import sage.all\" doesn't import ipython\n\n#9107 Nested class name mangling can be wrong in case of double nesting\n\n#10668 Refactor category support for morphisms (Hom is not a functorial construction!)\n\n#12453 Refactor integer vectors using ClonableIntArray Cython data structure\n\n#13901 Fix cython's deep C-stacks upon deallocation\n\n#15043 Rename MagmaticAlgebras to Algebras and Algebras to AssociativeUnitalAlgebras\n\n#15303 Coercion discovery fails to be transitive\n\n#15381 gens() can mean both module and algebra generators, confusing morphism.pyx\n\n#15475 Reenable broken doctests in #15473 and #15476 when #10963 is merged\n\n#15643 Document the implementation of axioms.\n\n#15647 Make a proper distinction in the categories between dual and graded dual\n\n#15648 lazy import attributes of a class are not substituted back after the import\n\n#15696 Implement an_instance for more categories, and extend category_sample\n\n#15701 Alternative for Axioms and Categories\n\n#15718 Implement the `__init_extra__` protocol of categories for Cython classes.\n\n#15947 Weaken types for `_rmul_` and `_lmul_`\n\n#16247 Meaning of Modules(R) currently not very clear\n\n#16183 Improve the terminology for the hierarchy relation between categories\n\n#16296 Speed improvements for categories with axioms",
    "created_at": "2014-05-06T14:45:40Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109628",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:8'></a>
CONGRATULATIONS!

What is the current state of performance, without any planned further patches?

A probably incomplete list of open stuff related to this ticket:

#804 Matrix should not inherit from AlgebraElement

#3685 make damned sure that "import sage.all" doesn't import ipython

#9107 Nested class name mangling can be wrong in case of double nesting

#10668 Refactor category support for morphisms (Hom is not a functorial construction!)

#12453 Refactor integer vectors using ClonableIntArray Cython data structure

#13901 Fix cython's deep C-stacks upon deallocation

#15043 Rename MagmaticAlgebras to Algebras and Algebras to AssociativeUnitalAlgebras

#15303 Coercion discovery fails to be transitive

#15381 gens() can mean both module and algebra generators, confusing morphism.pyx

#15475 Reenable broken doctests in #15473 and #15476 when #10963 is merged

#15643 Document the implementation of axioms.

#15647 Make a proper distinction in the categories between dual and graded dual

#15648 lazy import attributes of a class are not substituted back after the import

#15696 Implement an_instance for more categories, and extend category_sample

#15701 Alternative for Axioms and Categories

#15718 Implement the `__init_extra__` protocol of categories for Cython classes.

#15947 Weaken types for `_rmul_` and `_lmul_`

#16247 Meaning of Modules(R) currently not very clear

#16183 Improve the terminology for the hierarchy relation between categories

#16296 Speed improvements for categories with axioms



---

archive/issue_comments_109629.json:
```json
{
    "body": "<a id='comment:9'></a>\nCongratulations Nicolas!",
    "created_at": "2014-05-06T15:04:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109629",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:9'></a>
Congratulations Nicolas!



---

archive/issue_comments_109630.json:
```json
{
    "body": "**Changing reviewer** from \"Simon King, Fr\u00e9d\u00e9ric Chapoton\" to \"Simon King, Fr\u00e9d\u00e9ric Chapoton, Darij Grinberg, Travis Scrimshaw\".",
    "created_at": "2014-05-06T15:04:23Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109630",
    "user": "https://github.com/tscrim"
}
```

**Changing reviewer** from "Simon King, Frédéric Chapoton" to "Simon King, Frédéric Chapoton, Darij Grinberg, Travis Scrimshaw".



---

archive/issue_events_085493.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85493"
}
```



---

archive/issue_events_085494.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85494"
}
```



---

archive/issue_comments_109631.json:
```json
{
    "body": "<a id='comment:1'></a>\nWhile checking Simon's changes, I stumbled on a couple broken links\nwhich I am in the process of fixing now (with some little sphinx\nissues). Very final commit probably tonight!",
    "created_at": "2014-05-06T16:21:05Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109631",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:1'></a>
While checking Simon's changes, I stumbled on a couple broken links
which I am in the process of fixing now (with some little sphinx
issues). Very final commit probably tonight!



---

archive/issue_events_085495.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2014-05-06T16:21:05Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85495"
}
```



---

archive/issue_events_085496.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2014-05-06T16:21:05Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85496"
}
```



---

archive/issue_comments_109632.json:
```json
{
    "body": "**Changing commit** from \"[e9c3586de03c38397641e6d3347deddeef7c08a4](https://github.com/sagemath/sagetrac-mirror/commit/e9c3586de03c38397641e6d3347deddeef7c08a4)\" to \"[16b8e0ff1a2f8f7849103e63809f510b34da3382](https://github.com/sagemath/sagetrac-mirror/commit/16b8e0ff1a2f8f7849103e63809f510b34da3382)\".",
    "created_at": "2014-05-06T23:24:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109632",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[e9c3586de03c38397641e6d3347deddeef7c08a4](https://github.com/sagemath/sagetrac-mirror/commit/e9c3586de03c38397641e6d3347deddeef7c08a4)" to "[16b8e0ff1a2f8f7849103e63809f510b34da3382](https://github.com/sagemath/sagetrac-mirror/commit/16b8e0ff1a2f8f7849103e63809f510b34da3382)".



---

archive/issue_comments_109633.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/250c8fa6c69ad77d3d6e30dd893577ee8c48a277\">250c8fa</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of git://trac.sagemath.org/sage into 10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/16b8e0ff1a2f8f7849103e63809f510b34da3382\">16b8e0f</a></td><td><code>documentation edits to clarify that super_categories should not contain anything twice</code></td></tr></table>\n",
    "created_at": "2014-05-06T23:24:49Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109633",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/250c8fa6c69ad77d3d6e30dd893577ee8c48a277">250c8fa</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of git://trac.sagemath.org/sage into 10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/16b8e0ff1a2f8f7849103e63809f510b34da3382">16b8e0f</a></td><td><code>documentation edits to clarify that super_categories should not contain anything twice</code></td></tr></table>




---

archive/issue_comments_109634.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7e07dedb4560143235dfef7f8222be148c48c4fb\">7e07ded</a></td><td><code>Trac 10963: Fixed crosslinks</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bbfcbb83f1e3a721658e6536c4a4094c9d376ed9\">bbfcbb8</a></td><td><code>Merge Darij's commit in 'public/ticket/10963-doc-distributive' into categories/axioms-10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436\">f22508b</a></td><td><code>Trac 10963: proofread Darij's edits</code></td></tr></table>\n",
    "created_at": "2014-05-07T00:01:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109634",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7e07dedb4560143235dfef7f8222be148c48c4fb">7e07ded</a></td><td><code>Trac 10963: Fixed crosslinks</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bbfcbb83f1e3a721658e6536c4a4094c9d376ed9">bbfcbb8</a></td><td><code>Merge Darij's commit in 'public/ticket/10963-doc-distributive' into categories/axioms-10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436">f22508b</a></td><td><code>Trac 10963: proofread Darij's edits</code></td></tr></table>




---

archive/issue_comments_109635.json:
```json
{
    "body": "**Changing commit** from \"[16b8e0ff1a2f8f7849103e63809f510b34da3382](https://github.com/sagemath/sagetrac-mirror/commit/16b8e0ff1a2f8f7849103e63809f510b34da3382)\" to \"[f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436](https://github.com/sagemath/sagetrac-mirror/commit/f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436)\".",
    "created_at": "2014-05-07T00:01:32Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109635",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[16b8e0ff1a2f8f7849103e63809f510b34da3382](https://github.com/sagemath/sagetrac-mirror/commit/16b8e0ff1a2f8f7849103e63809f510b34da3382)" to "[f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436](https://github.com/sagemath/sagetrac-mirror/commit/f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436)".



---

archive/issue_comments_109636.json:
```json
{
    "body": "<a id='comment:4'></a>\nThank you!\n\nSo `super_categories` should always return a list, not an iterable? And the order is really irrelevant?",
    "created_at": "2014-05-07T00:05:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109636",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:4'></a>
Thank you!

So `super_categories` should always return a list, not an iterable? And the order is really irrelevant?



---

archive/issue_comments_109637.json:
```json
{
    "body": "<a id='comment:5'></a>\nOk, I am done fixing a bunch of crosslinks. I haven't tried to be\nexhaustive, but in the main files touched by this patch, most links\nare functional. Those that remain are broken due to Sphinx issues\nwhich can be dealt with later:\n\n- Deeply nested classes are not properly supported by Sphinx (waiting\n  for #9107 which is basically done)\n\n- At some point Sphinx was configured so that it was possible to\n  reference a class/function/... as soon as it was imported in the\n  module, without having to specify a full path. Apparently this is\n  broken. I have started looking at this with Florent (see #16298).\n  This concerns mostly Category_singleton and Category_over_base_ring.\n\nThanks Simon and Darij for your latest change. I have proofread\nthem. Please someone proofread my proofreading.\n\nThere is just one little change I would prefer to revert:\n\n```\n-        # This really should be in Category_over_base_ring.example,\n-        # but that would mean duplicating the documentation above.\n-        from category_types import Category_over_base_ring\n-        if isinstance(self, Category_over_base_ring): # Huh, smelly Run Time Type Checking, isn't it?\n-            if \"base_ring\" not in keywords:\n-                keywords[\"base_ring\"]=self.base_ring()\n+        if \"base_ring\" not in keywords:\n+            try:\n+                keywords[\"base_ring\"] = self.base_ring()\n+            except AttributeError:\n+                pass\n```\n\nIndeed, I find that the duck typing here smells as much as before (in\nboth cases, it points out that, in proper OO, this ought to be handled\nby Category_over_base_ring). And at least the RTTC and the comment are\nexplicit about this smell.\n\nSimon, are you ok with that? No big deal anyway.\n\nOnce my changes have been proofread and this little thing taken care\nof, I guess we can come back to a final positive review! And rejoice!\n(Well, just in case, I'll wait until the ticket is merged to rejoice).",
    "created_at": "2014-05-07T00:20:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109637",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>
Ok, I am done fixing a bunch of crosslinks. I haven't tried to be
exhaustive, but in the main files touched by this patch, most links
are functional. Those that remain are broken due to Sphinx issues
which can be dealt with later:

- Deeply nested classes are not properly supported by Sphinx (waiting
  for #9107 which is basically done)

- At some point Sphinx was configured so that it was possible to
  reference a class/function/... as soon as it was imported in the
  module, without having to specify a full path. Apparently this is
  broken. I have started looking at this with Florent (see #16298).
  This concerns mostly Category_singleton and Category_over_base_ring.

Thanks Simon and Darij for your latest change. I have proofread
them. Please someone proofread my proofreading.

There is just one little change I would prefer to revert:

```
-        # This really should be in Category_over_base_ring.example,
-        # but that would mean duplicating the documentation above.
-        from category_types import Category_over_base_ring
-        if isinstance(self, Category_over_base_ring): # Huh, smelly Run Time Type Checking, isn't it?
-            if "base_ring" not in keywords:
-                keywords["base_ring"]=self.base_ring()
+        if "base_ring" not in keywords:
+            try:
+                keywords["base_ring"] = self.base_ring()
+            except AttributeError:
+                pass
```

Indeed, I find that the duck typing here smells as much as before (in
both cases, it points out that, in proper OO, this ought to be handled
by Category_over_base_ring). And at least the RTTC and the comment are
explicit about this smell.

Simon, are you ok with that? No big deal anyway.

Once my changes have been proofread and this little thing taken care
of, I guess we can come back to a final positive review! And rejoice!
(Well, just in case, I'll wait until the ticket is merged to rejoice).



---

archive/issue_comments_109638.json:
```json
{
    "body": "<a id='comment:776'></a>\nReplying to [darij](#comment%3A774):\n> So `super_categories` should always return a list, not an iterable? \n\nAn iterable would probably work with the current code. But I prefer to\nkeep the specifications strict for now since I never had a use\ncase for an iterable.\n\n> And the order is really irrelevant?\n\nYes. All the code actually uses the lazy attribute\n`self._super_categories`, and this attribute is computed from\n`self.super_categories()` by sorting (and could include removing\nduplicates/redundant categories at some point in the future).",
    "created_at": "2014-05-07T00:25:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109638",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:776'></a>
Replying to [darij](#comment%3A774):
> So `super_categories` should always return a list, not an iterable? 

An iterable would probably work with the current code. But I prefer to
keep the specifications strict for now since I never had a use
case for an iterable.

> And the order is really irrelevant?

Yes. All the code actually uses the lazy attribute
`self._super_categories`, and this attribute is computed from
`self.super_categories()` by sorting (and could include removing
duplicates/redundant categories at some point in the future).



---

archive/issue_comments_109639.json:
```json
{
    "body": "<a id='comment:777'></a>\nReplying to [darij](#comment%3A768):\n> CONGRATULATIONS!\n\n:-)\n\n> What is the current state of performance, without any planned further patches?\n\nFor all that I checked, with #10963+#15801, performance is as good, if\nnot better, than before #10963. I just haven't done a Sage startup\ntime benchmark recently, but it used to be reasonable, and I see no\ncompelling reason to think that it could have changed recently.\n\n> A probably incomplete list of open stuff related to this ticket:\n> ...\n\nGosh, it's never ending :-)\n\nKidding apart, thanks for compiling this list! Would you mind adding\nit to http://trac.sagemath.org/wiki/CategoriesRoadMap?  (Yeah, this\npage needs a serious update ...)\n\nCheers,\n                           Nicolas",
    "created_at": "2014-05-07T00:33:28Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109639",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:777'></a>
Replying to [darij](#comment%3A768):
> CONGRATULATIONS!

:-)

> What is the current state of performance, without any planned further patches?

For all that I checked, with #10963+#15801, performance is as good, if
not better, than before #10963. I just haven't done a Sage startup
time benchmark recently, but it used to be reasonable, and I see no
compelling reason to think that it could have changed recently.

> A probably incomplete list of open stuff related to this ticket:
> ...

Gosh, it's never ending :-)

Kidding apart, thanks for compiling this list! Would you mind adding
it to http://trac.sagemath.org/wiki/CategoriesRoadMap?  (Yeah, this
page needs a serious update ...)

Cheers,
                           Nicolas



---

archive/issue_comments_109640.json:
```json
{
    "body": "<a id='comment:8'></a>\nThanks for the clarifications! (I also forgot #15927 in the list, and probably some more...)\n\nI would hesitate editing these into the roadmap because I have no idea how relevant most of them are to this. (And #15475 will be very easy to do once this is in, so it is probably not worth adding.)",
    "created_at": "2014-05-07T00:42:18Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109640",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:8'></a>
Thanks for the clarifications! (I also forgot #15927 in the list, and probably some more...)

I would hesitate editing these into the roadmap because I have no idea how relevant most of them are to this. (And #15475 will be very easy to do once this is in, so it is probably not worth adding.)



---

archive/issue_comments_109641.json:
```json
{
    "body": "**Changing commit** from \"[f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436](https://github.com/sagemath/sagetrac-mirror/commit/f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436)\" to \"[8da7522b983fd9a5bdc3680615e6a4b2094bab10](https://github.com/sagemath/sagetrac-mirror/commit/8da7522b983fd9a5bdc3680615e6a4b2094bab10)\".",
    "created_at": "2014-05-07T00:57:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109641",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436](https://github.com/sagemath/sagetrac-mirror/commit/f22508b30ce61aa97537b2bc0a2f5cf0b9ce3436)" to "[8da7522b983fd9a5bdc3680615e6a4b2094bab10](https://github.com/sagemath/sagetrac-mirror/commit/8da7522b983fd9a5bdc3680615e6a4b2094bab10)".



---

archive/issue_comments_109642.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8da7522b983fd9a5bdc3680615e6a4b2094bab10\">8da7522</a></td><td><code>Trac 10963: degraded a bit a newly added cross-link to work around 'make doc-clean; make clean' failure</code></td></tr></table>\n",
    "created_at": "2014-05-07T00:57:59Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109642",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8da7522b983fd9a5bdc3680615e6a4b2094bab10">8da7522</a></td><td><code>Trac 10963: degraded a bit a newly added cross-link to work around 'make doc-clean; make clean' failure</code></td></tr></table>




---

archive/issue_comments_109643.json:
```json
{
    "body": "<a id='comment:0'></a>\nGasp: after `make doc-clean`, `make doc` fails with\n\n```\n[misc     ] docstring of sage.misc.c3_controlled:103: WARNING: undefined label: category-primer-category-order (if the link has no caption the label must precede a section header)\n[misc     ] docstring of sage.misc.c3_controlled:103: WARNING: undefined label: sage.categories.primer (if the link has no caption the label must precede a section header)\n```\nwhereas this worked before the `make doc-clean`. Oh well, the degraded link I just pushed will do the job for now.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8da7522b983fd9a5bdc3680615e6a4b2094bab10\">8da7522</a></td><td><code>Trac 10963: degraded a bit a newly added cross-link to work around 'make doc-clean; make clean' failure</code></td></tr></table>\n",
    "created_at": "2014-05-07T00:59:15Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109643",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:0'></a>
Gasp: after `make doc-clean`, `make doc` fails with

```
[misc     ] docstring of sage.misc.c3_controlled:103: WARNING: undefined label: category-primer-category-order (if the link has no caption the label must precede a section header)
[misc     ] docstring of sage.misc.c3_controlled:103: WARNING: undefined label: sage.categories.primer (if the link has no caption the label must precede a section header)
```
whereas this worked before the `make doc-clean`. Oh well, the degraded link I just pushed will do the job for now.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8da7522b983fd9a5bdc3680615e6a4b2094bab10">8da7522</a></td><td><code>Trac 10963: degraded a bit a newly added cross-link to work around 'make doc-clean; make clean' failure</code></td></tr></table>




---

archive/issue_comments_109644.json:
```json
{
    "body": "<a id='comment:1'></a>\nFor the record: all long test passed.",
    "created_at": "2014-05-07T01:15:10Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109644",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:1'></a>
For the record: all long test passed.



---

archive/issue_comments_109645.json:
```json
{
    "body": "<a id='comment:782'></a>\nReplying to [darij](#comment%3A778):\n> I would hesitate editing these into the roadmap because I have no idea how relevant most of them are to this. (And #15475 will be very easy to do once this is in, so it is probably not worth adding.)\n\nOk. I used the occasion to completely refactor the roadmap:\n\nhttp://trac.sagemath.org/wiki/CategoriesRoadMap\n\nfeel free to add stuff I may have missed!",
    "created_at": "2014-05-07T09:46:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109645",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:782'></a>
Replying to [darij](#comment%3A778):
> I would hesitate editing these into the roadmap because I have no idea how relevant most of them are to this. (And #15475 will be very easy to do once this is in, so it is probably not worth adding.)

Ok. I used the occasion to completely refactor the roadmap:

http://trac.sagemath.org/wiki/CategoriesRoadMap

feel free to add stuff I may have missed!



---

archive/issue_comments_109646.json:
```json
{
    "body": "<a id='comment:783'></a>\nReplying to [nthiery](#comment%3A775):\n> - Deeply nested classes are not properly supported by Sphinx (waiting\n>   for #9107 which is basically done)\n\nI thought #9107 is *causing* a problem with the (pdf) docs?\n \n> There is just one little change I would prefer to revert:\n> \n> ```\n> -        # This really should be in Category_over_base_ring.example,\n> -        # but that would mean duplicating the documentation above.\n> -        from category_types import Category_over_base_ring\n> -        if isinstance(self, Category_over_base_ring): # Huh, smelly Run Time Type Checking, isn't it?\n> -            if \"base_ring\" not in keywords:\n> -                keywords[\"base_ring\"]=self.base_ring()\n> +        if \"base_ring\" not in keywords:\n> +            try:\n> +                keywords[\"base_ring\"] = self.base_ring()\n> +            except AttributeError:\n> +                pass\n> ```\n> \n> Indeed, I find that the duck typing here smells as much as before (in\n> both cases, it points out that, in proper OO, this ought to be handled\n> by Category_over_base_ring). And at least the RTTC and the comment are\n> explicit about this smell.\n> \n> Simon, are you ok with that? No big deal anyway.\n\nOK. Probably I will re-revert it (or do it properly) in #16296, though `:-P`",
    "created_at": "2014-05-07T10:19:43Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109646",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:783'></a>
Replying to [nthiery](#comment%3A775):
> - Deeply nested classes are not properly supported by Sphinx (waiting
>   for #9107 which is basically done)

I thought #9107 is *causing* a problem with the (pdf) docs?
 
> There is just one little change I would prefer to revert:
> 
> ```
> -        # This really should be in Category_over_base_ring.example,
> -        # but that would mean duplicating the documentation above.
> -        from category_types import Category_over_base_ring
> -        if isinstance(self, Category_over_base_ring): # Huh, smelly Run Time Type Checking, isn't it?
> -            if "base_ring" not in keywords:
> -                keywords["base_ring"]=self.base_ring()
> +        if "base_ring" not in keywords:
> +            try:
> +                keywords["base_ring"] = self.base_ring()
> +            except AttributeError:
> +                pass
> ```
> 
> Indeed, I find that the duck typing here smells as much as before (in
> both cases, it points out that, in proper OO, this ought to be handled
> by Category_over_base_ring). And at least the RTTC and the comment are
> explicit about this smell.
> 
> Simon, are you ok with that? No big deal anyway.

OK. Probably I will re-revert it (or do it properly) in #16296, though `:-P`



---

archive/issue_comments_109647.json:
```json
{
    "body": "<a id='comment:4'></a>\nFor the record: I have no problems with the recent changes. The docs build (after `make doc-clean` and `make doc`), look fine (at least when having a quick glance upon it), and I trust your statement that the tests pass. So, it may be positive review again.\n\nQuestion: You inserted many underscore methods into the reference manual. Do people agree that this is tgood to do? I thought the point of underscore methods is to hide them.",
    "created_at": "2014-05-07T10:47:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109647",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
For the record: I have no problems with the recent changes. The docs build (after `make doc-clean` and `make doc`), look fine (at least when having a quick glance upon it), and I trust your statement that the tests pass. So, it may be positive review again.

Question: You inserted many underscore methods into the reference manual. Do people agree that this is tgood to do? I thought the point of underscore methods is to hide them.



---

archive/issue_events_085497.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-07T10:47:41Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85497"
}
```



---

archive/issue_events_085498.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-07T10:47:41Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85498"
}
```



---

archive/issue_comments_109648.json:
```json
{
    "body": "<a id='comment:785'></a>\nReplying to [SimonKing](#comment%3A783):\n> Replying to [nthiery](#comment%3A775):\n> > - Deeply nested classes are not properly supported by Sphinx (waiting\n> >   for #9107 which is basically done)\n\n> \n> I thought #9107 is *causing* a problem with the (pdf) docs?\n\nYup: #9107 makes it so that deeply nested classes are finally\nincluded in the documentation (which is good), but as a side effect the produced latex does not compile yet because deep list nesting is not supported by default by latex. I\nsaid \"basically done\" because the little plan I sketched on sage-devel\nshould be good enough to fix this, and I will take care of it soon\nonce this is merged.\n\nOn a related matter, it would be cool to have folding in the html\ndocumentation; but that's another story.\n\n> OK. Probably I will re-revert it (or do it properly) in #16296, though `:-P`\n\nThinking twice about it, you are right: we should just do it properly in a followup to #15801. Indeed we anyway want to add support for:\n\n```\n    sage: Modules(Rings()).example()\n```\nSo I am just leaving things as they are now.",
    "created_at": "2014-05-07T11:00:37Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109648",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:785'></a>
Replying to [SimonKing](#comment%3A783):
> Replying to [nthiery](#comment%3A775):
> > - Deeply nested classes are not properly supported by Sphinx (waiting
> >   for #9107 which is basically done)

> 
> I thought #9107 is *causing* a problem with the (pdf) docs?

Yup: #9107 makes it so that deeply nested classes are finally
included in the documentation (which is good), but as a side effect the produced latex does not compile yet because deep list nesting is not supported by default by latex. I
said "basically done" because the little plan I sketched on sage-devel
should be good enough to fix this, and I will take care of it soon
once this is merged.

On a related matter, it would be cool to have folding in the html
documentation; but that's another story.

> OK. Probably I will re-revert it (or do it properly) in #16296, though `:-P`

Thinking twice about it, you are right: we should just do it properly in a followup to #15801. Indeed we anyway want to add support for:

```
    sage: Modules(Rings()).example()
```
So I am just leaving things as they are now.



---

archive/issue_comments_109649.json:
```json
{
    "body": "<a id='comment:6'></a>\nI just updated the reviewer's list. Feel free to edit if I forgot someone!",
    "created_at": "2014-05-07T11:55:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109649",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>
I just updated the reviewer's list. Feel free to edit if I forgot someone!



---

archive/issue_comments_109650.json:
```json
{
    "body": "**Changing reviewer** from \"Simon King, Fr\u00e9d\u00e9ric Chapoton, Darij Grinberg, Travis Scrimshaw\" to \"Volker Braun, Nils Bruin, Peter Bruin, Fr\u00e9d\u00e9ric Chapoton, Darij Grinberg, Florent Hivert, Simon King, Travis Scrimshaw\".",
    "created_at": "2014-05-07T11:55:34Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109650",
    "user": "https://github.com/nthiery"
}
```

**Changing reviewer** from "Simon King, Frédéric Chapoton, Darij Grinberg, Travis Scrimshaw" to "Volker Braun, Nils Bruin, Peter Bruin, Frédéric Chapoton, Darij Grinberg, Florent Hivert, Simon King, Travis Scrimshaw".



---

archive/issue_comments_109651.json:
```json
{
    "body": "<a id='comment:787'></a>\nReplying to [SimonKing](#comment%3A784):\n> Question: You inserted many underscore methods into the reference manual. Do people agree that this is tgood to do? I thought the point of underscore methods is to hide them.\n\nYeah, I pondered about this for a while. That's definitely a compromise. At the end, I\nfollowed the rule of thumb of inserting in the reference manual all the underscore\nmethods that were referenced somewhere. The rationale is as follow:\n\n- Keeping them as underscore methods marks the intention that they are\n  private methods: i.e. casual code should not use them directly, as\n  they may expose implementation details or be subject to changes\n  without notice.\n\n- If they are referenced somewhere, they probably are important\n  enough. So we want to be kind to the developers and help them get an\n  overview of the general structure through browsing the reference\n  manual and following links.\n\nSide notes:\n\n- I believe that all _..._ and __...__ methods are *special methods*\n  not *private methods* and thus should systematically be included in\n  the documentation. I mentioned this in a discussions; maybe it's\n  time to take action, creating a ticket and getting this moving.\n\n- I also believe that, in an ideal worled, all methods would be in the\n  reference manual, just with some mechanism (hiding/folding/separate\n  section) so that they would not pollute the view for casual users.",
    "created_at": "2014-05-07T14:12:30Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109651",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:787'></a>
Replying to [SimonKing](#comment%3A784):
> Question: You inserted many underscore methods into the reference manual. Do people agree that this is tgood to do? I thought the point of underscore methods is to hide them.

Yeah, I pondered about this for a while. That's definitely a compromise. At the end, I
followed the rule of thumb of inserting in the reference manual all the underscore
methods that were referenced somewhere. The rationale is as follow:

- Keeping them as underscore methods marks the intention that they are
  private methods: i.e. casual code should not use them directly, as
  they may expose implementation details or be subject to changes
  without notice.

- If they are referenced somewhere, they probably are important
  enough. So we want to be kind to the developers and help them get an
  overview of the general structure through browsing the reference
  manual and following links.

Side notes:

- I believe that all _..._ and __...__ methods are *special methods*
  not *private methods* and thus should systematically be included in
  the documentation. I mentioned this in a discussions; maybe it's
  time to take action, creating a ticket and getting this moving.

- I also believe that, in an ideal worled, all methods would be in the
  reference manual, just with some mechanism (hiding/folding/separate
  section) so that they would not pollute the view for casual users.



---

archive/issue_comments_109652.json:
```json
{
    "body": "<a id='comment:8'></a>\nConflicts with #16275, please fix",
    "created_at": "2014-05-10T20:24:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109652",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:8'></a>
Conflicts with #16275, please fix



---

archive/issue_comments_109653.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4ef8b279deb68585c57ba17db248e775f7a71fd8\">4ef8b27</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of git://trac.sagemath.org/sage into 10963new</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/afb911cebaf9314a04292fb231a258704bbd3c70\">afb911c</a></td><td><code>corrected conflict resolution</code></td></tr></table>\n",
    "created_at": "2014-05-10T21:11:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109653",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4ef8b279deb68585c57ba17db248e775f7a71fd8">4ef8b27</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of git://trac.sagemath.org/sage into 10963new</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/afb911cebaf9314a04292fb231a258704bbd3c70">afb911c</a></td><td><code>corrected conflict resolution</code></td></tr></table>




---

archive/issue_events_085499.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/git",
    "created_at": "2014-05-10T21:11:39Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85499"
}
```



---

archive/issue_events_085500.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/git",
    "created_at": "2014-05-10T21:11:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85500"
}
```



---

archive/issue_comments_109654.json:
```json
{
    "body": "**Changing commit** from \"[8da7522b983fd9a5bdc3680615e6a4b2094bab10](https://github.com/sagemath/sagetrac-mirror/commit/8da7522b983fd9a5bdc3680615e6a4b2094bab10)\" to \"[afb911cebaf9314a04292fb231a258704bbd3c70](https://github.com/sagemath/sagetrac-mirror/commit/afb911cebaf9314a04292fb231a258704bbd3c70)\".",
    "created_at": "2014-05-10T21:11:39Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109654",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[8da7522b983fd9a5bdc3680615e6a4b2094bab10](https://github.com/sagemath/sagetrac-mirror/commit/8da7522b983fd9a5bdc3680615e6a4b2094bab10)" to "[afb911cebaf9314a04292fb231a258704bbd3c70](https://github.com/sagemath/sagetrac-mirror/commit/afb911cebaf9314a04292fb231a258704bbd3c70)".



---

archive/issue_events_085501.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-05-10T21:12:44Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85501"
}
```



---

archive/issue_events_085502.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-05-10T21:12:44Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85502"
}
```



---

archive/issue_comments_109655.json:
```json
{
    "body": "<a id='comment:0'></a>\nFixed. It was a change in an exception output (change of capitalization ftw), so I don't think it needs review.",
    "created_at": "2014-05-10T21:12:44Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109655",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:0'></a>
Fixed. It was a change in an exception output (change of capitalization ftw), so I don't think it needs review.



---

archive/issue_comments_109656.json:
```json
{
    "body": "<a id='comment:791'></a>\nReplying to [darij](#comment%3A790):\n> Fixed. It was a change in an exception output (change of capitalization ftw), so I don't think it needs review.\n\nAgreed! Thanks for the merge!",
    "created_at": "2014-05-10T21:53:41Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109656",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:791'></a>
Replying to [darij](#comment%3A790):
> Fixed. It was a change in an exception output (change of capitalization ftw), so I don't think it needs review.

Agreed! Thanks for the merge!



---

archive/issue_comments_109657.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/96c631f536a20733a80e74fba45fecd5d98f6fd5\">96c631f</a></td><td><code>Merge branch 'develop' into categories/axioms-10963</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b1a2aede666273d01405811aad2c6338a06c0330\">b1a2aed</a></td><td><code>Trac 10963: two typo fixes to let the pdf documentation compile</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c\">c16f18b</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into categories/axioms-10963</code></td></tr></table>\n",
    "created_at": "2014-05-12T14:32:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109657",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/96c631f536a20733a80e74fba45fecd5d98f6fd5">96c631f</a></td><td><code>Merge branch 'develop' into categories/axioms-10963</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b1a2aede666273d01405811aad2c6338a06c0330">b1a2aed</a></td><td><code>Trac 10963: two typo fixes to let the pdf documentation compile</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c">c16f18b</a></td><td><code>Merge branch 'public/ticket/10963-doc-distributive' of trac.sagemath.org:sage into categories/axioms-10963</code></td></tr></table>




---

archive/issue_comments_109658.json:
```json
{
    "body": "**Changing commit** from \"[afb911cebaf9314a04292fb231a258704bbd3c70](https://github.com/sagemath/sagetrac-mirror/commit/afb911cebaf9314a04292fb231a258704bbd3c70)\" to \"[c16f18b56c2b5470088bbcf110ddbb15be6caf0c](https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c)\".",
    "created_at": "2014-05-12T14:32:14Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109658",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[afb911cebaf9314a04292fb231a258704bbd3c70](https://github.com/sagemath/sagetrac-mirror/commit/afb911cebaf9314a04292fb231a258704bbd3c70)" to "[c16f18b56c2b5470088bbcf110ddbb15be6caf0c](https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c)".



---

archive/issue_events_085503.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/git",
    "created_at": "2014-05-12T14:32:14Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85503"
}
```



---

archive/issue_events_085504.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/git",
    "created_at": "2014-05-12T14:32:14Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85504"
}
```



---

archive/issue_comments_109659.json:
```json
{
    "body": "<a id='comment:3'></a>\nAre the merge commits really just merge commits? If so, this should be pos_rev.",
    "created_at": "2014-05-13T18:34:26Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109659",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:3'></a>
Are the merge commits really just merge commits? If so, this should be pos_rev.



---

archive/issue_comments_109660.json:
```json
{
    "body": "<a id='comment:794'></a>\nReplying to [darij](#comment%3A793):\n> Are the merge commits really just merge commits? If so, this should be pos_rev.\n\nThe tiny tex fix in b1a2aed still needs review!",
    "created_at": "2014-05-13T19:12:17Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109660",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:794'></a>
Replying to [darij](#comment%3A793):
> Are the merge commits really just merge commits? If so, this should be pos_rev.

The tiny tex fix in b1a2aed still needs review!



---

archive/issue_events_085505.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-05-13T19:15:04Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85505"
}
```



---

archive/issue_events_085506.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-05-13T19:15:04Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85506"
}
```



---

archive/issue_comments_109661.json:
```json
{
    "body": "<a id='comment:5'></a>\nOK, so positive_review. (I am wondering if the \\text error was mine...)",
    "created_at": "2014-05-13T19:15:04Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109661",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:5'></a>
OK, so positive_review. (I am wondering if the \text error was mine...)



---

archive/issue_comments_109662.json:
```json
{
    "body": "**Changing branch** from \"[public/ticket/10963-doc-distributive](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963-doc-distributive)\" to \"[c16f18b56c2b5470088bbcf110ddbb15be6caf0c](https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c)\".",
    "created_at": "2014-05-19T10:24:46Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109662",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[public/ticket/10963-doc-distributive](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/10963-doc-distributive)" to "[c16f18b56c2b5470088bbcf110ddbb15be6caf0c](https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c)".



---

archive/issue_events_085507.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-05-19T10:24:46Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85507"
}
```



---

archive/issue_events_085508.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "16cdb7979ba83a71563175467f21a58b47023886",
    "created_at": "2014-05-19T10:24:46Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10963#event-85508"
}
```



---

archive/issue_comments_109663.json:
```json
{
    "body": "**Changing commit** from \"[c16f18b56c2b5470088bbcf110ddbb15be6caf0c](https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c)\" to \"\".",
    "created_at": "2014-05-19T11:57:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109663",
    "user": "https://github.com/nathanncohen"
}
```

**Changing commit** from "[c16f18b56c2b5470088bbcf110ddbb15be6caf0c](https://github.com/sagemath/sagetrac-mirror/commit/c16f18b56c2b5470088bbcf110ddbb15be6caf0c)" to "".



---

archive/issue_comments_109664.json:
```json
{
    "body": "<a id='comment:7'></a>\nWow.\n\n#10963 ?\n\nClosed ?\n\nWow `:-P`\n\nNathann",
    "created_at": "2014-05-19T11:57:21Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109664",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:7'></a>
Wow.

#10963 ?

Closed ?

Wow `:-P`

Nathann



---

archive/issue_comments_109665.json:
```json
{
    "body": "<a id='comment:8'></a>\nYippee!\n\nWell guys, that's a good chunk of work finally done. What a relief. I really\nappreciate all the energy that has been put in the review. Thank you\nso much everybody! Beers and/or chocolate is on me at the next\noccasion :-)\n\nAnd now let's move on!\n\nCheers,\n                               Nicolas",
    "created_at": "2014-05-19T13:24:25Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109665",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:8'></a>
Yippee!

Well guys, that's a good chunk of work finally done. What a relief. I really
appreciate all the energy that has been put in the review. Thank you
so much everybody! Beers and/or chocolate is on me at the next
occasion :-)

And now let's move on!

Cheers,
                               Nicolas



---

archive/issue_comments_109666.json:
```json
{
    "body": "<a id='comment:799'></a>\nReplying to [nthiery](#comment%3A798):\n> Yippee!\n\nCongratulations!\n\nNow in the branch field it says \"c16f18b56c2b5470088bbcf110ddbb15be6caf0c\" instead of \"public/.../\". Mark Shimozono needs to be able to get this branch for his work. How is he supposed to do it?\n\nThanks!\n\nAnne",
    "created_at": "2014-05-22T13:31:55Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109666",
    "user": "https://github.com/anneschilling"
}
```

<a id='comment:799'></a>
Replying to [nthiery](#comment%3A798):
> Yippee!

Congratulations!

Now in the branch field it says "c16f18b56c2b5470088bbcf110ddbb15be6caf0c" instead of "public/.../". Mark Shimozono needs to be able to get this branch for his work. How is he supposed to do it?

Thanks!

Anne



---

archive/issue_comments_109667.json:
```json
{
    "body": "<a id='comment:0'></a>\nCongrats too! (I guess that includes me, to some extent -- at the very least I'm happy to never again have to wait for this page to load...)\n\nTo get a pointer to the branch, you can click on the \"commits\" link. It ucrrently shows public/ticket/10963-doc-distributive as the branch name.",
    "created_at": "2014-05-22T13:36:36Z",
    "issue": "https://github.com/sagemath/sage/issues/10963",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10963#issuecomment-109667",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:0'></a>
Congrats too! (I guess that includes me, to some extent -- at the very least I'm happy to never again have to wait for this page to load...)

To get a pointer to the branch, you can click on the "commits" link. It ucrrently shows public/ticket/10963-doc-distributive as the branch name.
