# Issue 31432: Category of chain complexes: (co)homology functor

Issue created by migration from https://trac.sagemath.org/ticket/31669

Original creator: @mjungmath

Original creation time: 2021-04-14 14:22:05

CC:  mkoeppe tscrim egourgoulhon jhpalmieri

Keywords: homology, cohomology

In this ticket, we equip the category of chain complexes with a method `homology` yielding the associated homology. The corresponding homology functor will use this method. We furthermore establish a new category of cochain complexes.

This happens in view of Čech cohomology, Morse homology and de Rham cohomology on manifolds.

Comments and opinions are as always welcome.


---

Comment by @mjungmath created at 2021-04-17 23:05:29

First draft. Comments are welcome.
----
New commits:


---

Comment by git created at 2021-04-17 23:20:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-04-18 10:03:18

Changing keywords from "homology, cohomology" to "homology".


---

Comment by @mjungmath created at 2021-04-18 10:03:18

`chain_complex` doesn't make a distinction between chain and cochain complexes. Probably because it also allows multigrading.

Should we remove the category of cochain complexes then? I mean, in a broad sense, cochain complexes can be seen as generalized chain complexes, no?

Btw, is it customary to add a mathematical description in the category section?


---

Comment by git created at 2021-04-18 10:16:19

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @mjungmath created at 2021-04-18 10:16:38

Here is a proposal without cochain complexes.

----
New commits:


---

Comment by tscrim created at 2021-04-19 00:47:29

There is no difference as the degree of the chain map is part of the data of a chain complex. I agree that it is good to *not* have a category of cochain complexes.

You can add a very brief description to the category, but nobody really reads that part IMO.


---

Comment by @mjungmath created at 2021-04-19 08:51:08

I have added a `differential` method to the category since this is a crucial ingredient for chain complexes. For consistency it might also be a good idea to turn differentials of `chain_complex` into morphisms in the category of modules like it is done in `commutative_dga`.


---

Comment by git created at 2021-04-19 08:54:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-04-19 08:55:50

If there is nothing you'd like to add, that should be it. I added the above task as a `TODO` comment. Perhaps I even open a ticket.


---

Comment by @mjungmath created at 2021-04-19 08:56:03

Changing status from new to needs_review.


---

Comment by tscrim created at 2021-04-21 06:36:48

Rather than raise a `NotImplementedError`, it is better if you mark them as ``@`abstract_method`.

`_apply_functor_to_morphism` is missing doctests.

I would not change the title doc of `chain_complex.py`. It is possible that non-bounded chain complexes are added to that file eventually.

Should we allow `HomologyFunctor` to have a default of `n=None` so it returns the entire homology?

This is a more of a question for John. When I think of cohomology, I think there should be some extra ring structure. If the degree of the differential is negative, can we generally assume there is a ring structure on the homology or is this something special based on the construction?


---

Comment by @mjungmath created at 2021-04-21 10:58:44

Replying to [comment:14 tscrim]:
> Rather than raise a `NotImplementedError`, it is better if you mark them as ``@`abstract_method`.
> 
> `_apply_functor_to_morphism` is missing doctests.

That is because we don't have any examples to apply here, or do we?

> I would not change the title doc of `chain_complex.py`. It is possible that non-bounded chain complexes are added to that file eventually.

Well, that can be done if that finally happens, no?

> Should we allow `HomologyFunctor` to have a default of `n=None` so it returns the entire homology?
> 
> This is a more of a question for John. When I think of cohomology, I think there should be some extra ring structure. If the degree of the differential is negative, can we generally assume there is a ring structure on the homology or is this something special based on the construction?

I agree, it should, and I will add it accordingly. For the moment however, neither `chain_complex` nor `commutative_dga` provide (co)homology in terms of a graded ring.


---

Comment by @mjungmath created at 2021-04-21 11:08:31

Replying to [comment:15 gh-mjungmath]:
> Replying to [comment:14 tscrim]:
> > Rather than raise a `NotImplementedError`, it is better if you mark them as ``@`abstract_method`.
> > 
> > `_apply_functor_to_morphism` is missing doctests.
> 
> That is because we don't have any examples to apply here, or do we?

Perhaps I can add an example together with #31693.


---

Comment by @mjungmath created at 2021-04-21 15:49:10

As for `_apply_functor_to_morphism` we could enforce a method `homology_raw` (cf. `commutative_dga`) which returns the homology as an actual quotient whose elements admit a `lift` method. Then the `_apply_functor_to_morphism` is rather generic:

Lift the homology element, apply the original morphism to it, reduce to the quotient.

At that end one could implement isomorphisms from the already lifted homology groups to the homology groups emerged as quotient.

Not sure whether this is a feasible approach. Travis, what do you think?

I would have wished that the homology already occurs as a quotient in the first place. Is there a reason why this hasn't been done so?


---

Comment by @mjungmath created at 2021-04-21 16:04:30

Changing status from needs_review to needs_work.


---

Comment by jhpalmieri created at 2021-04-21 19:55:21

Replying to [comment:17 gh-mjungmath]:
> I would have wished that the homology already occurs as a quotient in the first place. Is there a reason why this hasn't been done so?

It is _much_ faster to compute the homology as an abstract group (by computing the Smith normal form of the boundary matrices) than to compute the cycles as a subgroup of the chains and then the homology as a quotient of the cycles.


---

Comment by git created at 2021-04-22 08:50:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-04-22 08:51:43

Check out my new commit. This approach is a bit more generic. What do you think?


---

Comment by git created at 2021-04-22 08:55:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-04-22 08:58:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-04-23 00:46:46

Even if we have no examples, it still needs a doctest (even if it just showing that it has not been defined).

Yes, we can change the title if that indeed happens, but right now, let's leave it alone.

I don't like the idea of enforcing a `homology_raw`. Implementors should be free to implement what works best for them and their problem at hand as per John's comment. Things at the category level should be kept as generic as possible.

It would be better to have this as a generic implementation in the category by using some assumption on the chain complex and the corresponding morphisms. Of course, it would need a better name and could be the generic implementation, but I am not sure we want to force an option that homology needs to be realized as a quotient.


---

Comment by @mjungmath created at 2021-04-23 07:07:15

Replying to [comment:24 tscrim]:
> Even if we have no examples, it still needs a doctest (even if it just showing that it has not been defined).
> 
> Yes, we can change the title if that indeed happens, but right now, let's leave it alone.
> 
> I don't like the idea of enforcing a `homology_raw`. Implementors should be free to implement what works best for them and their problem at hand as per John's comment. Things at the category level should be kept as generic as possible.
> 
> It would be better to have this as a generic implementation in the category by using some assumption on the chain complex and the corresponding morphisms. Of course, it would need a better name and could be the generic implementation, but I am not sure we want to force an option that homology needs to be realized as a quotient.

Have you checked my last commits? I already dropped most things you are referring to.

Instead of `homology_raw`, I have introduced two methods: `lift_from_homology` and `reduce_to_homology` which lifts an homology class to a representative and reduces a cycle to its homology class respectively. These can be overwritten depending on the implementation.

As for renaming: I really don't care. I just think that it is way smoother if the title fits the content. What I meant: you can change it back as soon as the implementation has been generalized, at which point the documentation needs to be refactored anyway.


---

Comment by tscrim created at 2021-04-23 08:50:14

Replying to [comment:25 gh-mjungmath]:
> Replying to [comment:24 tscrim]:
> > Even if we have no examples, it still needs a doctest (even if it just showing that it has not been defined).
> > 
> > Yes, we can change the title if that indeed happens, but right now, let's leave it alone.
> > 
> > I don't like the idea of enforcing a `homology_raw`. Implementors should be free to implement what works best for them and their problem at hand as per John's comment. Things at the category level should be kept as generic as possible.
> > 
> > It would be better to have this as a generic implementation in the category by using some assumption on the chain complex and the corresponding morphisms. Of course, it would need a better name and could be the generic implementation, but I am not sure we want to force an option that homology needs to be realized as a quotient.
> 
> Have you checked my last commits? I already dropped most things you are referring to.
> 
> Instead of `homology_raw`, I have introduced two methods: `lift_from_homology` and `reduce_to_homology` which lifts an homology class to a representative and reduces a cycle to its homology class respectively. These can be overwritten depending on the implementation.

Okay, I understand what you are trying to do. I didn't realize you were changing your approach with your last commit. It might be a slight abuse to have a functor for all `n`, but I think it should be fine.

> As for renaming: I really don't care. I just think that it is way smoother if the title fits the content. What I meant: you can change it back as soon as the implementation has been generalized, at which point the documentation needs to be refactored anyway.

I am still a -1 on changing the title docstring of `chain_complex.py`. That file is for chain complexes. Just because we happen to have only bounded ones implemented doesn't mean we need to limit it right now.


---

Comment by git created at 2021-04-23 20:44:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-04-23 20:46:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-04-26 14:30:11

When #31691 has a positive review, I will add some examples for de Rham cohomology here.


---

Comment by jhpalmieri created at 2021-04-29 20:37:59

Replying to [comment:26 tscrim]:
> Replying to [comment:25 gh-mjungmath]:
> > As for renaming: I really don't care. I just think that it is way smoother if the title fits the content. What I meant: you can change it back as soon as the implementation has been generalized, at which point the documentation needs to be refactored anyway.
> 
> I am still a -1 on changing the title docstring of `chain_complex.py`. That file is for chain complexes. Just because we happen to have only bounded ones implemented doesn't mean we need to limit it right now.

Regarding this, I don't know much about [kenzo](https://github.com/gheber/kenzo), but it is conceivable that it handles unbounded chain complexes, and I think we should leave the title of Sage's chain complex module as is, in case the Sage-kenzo interface develops further and we can directly access its chain complexes. (Kenzo certainly handles topological spaces which have nonzero homology in infinitely many dimensions, but I don't know the details of how it handles the associated chain complexes.)


---

Comment by git created at 2021-05-06 18:27:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-05-06 18:28:00

Changing status from needs_work to needs_review.


---

Comment by @mjungmath created at 2021-05-06 18:28:27

Ready for review.


---

Comment by git created at 2021-05-06 18:31:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2021-05-06 22:32:33

Is #31691 a dependency of this ticket?


---

Comment by tscrim created at 2021-05-07 06:00:08

Yes, I think it is.

Some comments:

Doctest failure:

```
sage -t --long --random-seed=0 src/sage/homology/hochschild_complex.py  # 1 doctest failed
```


I would use `_n` instead of `__n` as we don't need the name mangling.

A useful construction is `Cat.or_subcategory(input_cat)`, which automatically returns `Cat` when `input_cat=None`.


---

Comment by @mjungmath created at 2021-05-07 08:09:53

Replying to [comment:36 tscrim]:
> Yes, I think it is.

Indeed. My mistake.

> 
> Some comments:
> 
> Doctest failure:
> {{{
> sage -t --long --random-seed=0 src/sage/homology/hochschild_complex.py  # 1 doctest failed
> }}}

Saw it. I hope the Hochschild complex implementation provides a boundary map...

> 
> I would use `_n` instead of `__n` as we don't need the name mangling.
> 
Check.

> A useful construction is `Cat.or_subcategory(input_cat)`, which automatically returns `Cat` when `input_cat=None`.

What do you propose?


---

Comment by @mjungmath created at 2021-05-08 10:08:42

Replying to [comment:36 tscrim]:
> A useful construction is `Cat.or_subcategory(input_cat)`, which automatically returns `Cat` when `input_cat=None`.

Ah, you are probably referring to `GCAlgebra`. This `or_subcategory` seems also useful to improve the code for manifolds since this is similarly implemented as I did here.


---

Comment by @mjungmath created at 2021-05-08 10:16:30

But it seems like this is done all over Sage:


```python
def __init__(..., category=None):
    ...
    if category is None:
        category = SomeCategory()
```



---

Comment by git created at 2021-05-08 10:23:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-05-08 13:19:26

Looks to me like morally green...?


---

Comment by git created at 2021-05-08 13:37:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-05-10 11:01:57

Ready for review. Patchbot is 'green'.


---

Comment by tscrim created at 2021-05-12 07:08:41

Replying to [comment:39 gh-mjungmath]:
> But it seems like this is done all over Sage:
> 
> {{{#!python
> def __init__(..., category=None):
>     ...
>     if category is None:
>         category = SomeCategory()
> }}}

Yes, that is what I was referring too. However, just because it is used many places elsewhere doesn't mean you shouldn't use it. That is typically older code and is a weaker test. Someone could pass a weaker category than the code actually needs, which would be a problem.


---

Comment by @mjungmath created at 2021-05-12 07:47:38

I don't know whether `is_subcategory` is the state of the art here. Sometimes, categories are not compatible with each other. Or a subcategory (in the mathematical sense) is not recognized as such. I have a bad feeling that this can lead to undesired results.


---

Comment by tscrim created at 2021-05-12 08:01:00

This is what we want to use. Please make the change to use it. If categories are incompatible, then there is a bigger issue that this will alert you to.


---

Comment by @mjungmath created at 2021-05-12 08:32:46

I still don't think this is what we should use. For example, assume that the class represents an object in the category of groups. Now I want to inherit from this class and turn it into a ring. Passing `Rings()` to the initialization would then cause an error:


```
sage: Groups().or_subcategory(Rings())
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-2-38547a21b34f> in <module>
----> 1 Groups().or_subcategory(Rings())

/ext/sage/sage-9.2/local/lib/python3.8/site-packages/sage/categories/category.py in or_subcategory(self, category, join)
   1876         else:
   1877             if not category.is_subcategory(self):
-> 1878                 raise ValueError("Subcategory of `{}` required; got `{}`".format(self, category))
   1879             return category
   1880 
ValueError: Subcategory of `Category of groups` required; got `Category of rings
```


Even with `join=True` we get an undesired result:


```
sage: Groups().or_subcategory(Rings(), join=True)
Category of inverse rings
```


What we really want to do is overwrite the category in that case.


---

Comment by tscrim created at 2021-05-12 22:24:05

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2021-05-12 22:24:05

That error is telling you that you are doing something mathematically nonsensical. A ring is not a (multiplicative) group because it doesn't have inverses. Thus, your example gives even more reason you want to use it.


---

Comment by @mjungmath created at 2021-05-13 00:49:54

Right, Sage distinguishes between multiplicative and additive groups. Probably a bad example. The same error would occur for additive groups though, except that `join=True` gives what we want. But I am not sure whether we always want to join categories and never make it possible to overwrite them for inheritance purposes.

I am sure you can somehow construct another example that leads to something undesirable. Besides, there must be a reason why `or_subcategory` is literally never used for that purpose.

I'd appreciate an additional opinion here. Matthias?


---

Comment by jhpalmieri created at 2021-05-13 01:17:32

I don't have an opinion about this particular situation, but in my experience, Travis knows the category code well, and I try to follow his advice.


---

Comment by tscrim created at 2021-05-13 02:27:14

Replying to [comment:49 gh-mjungmath]:
> Right, Sage distinguishes between multiplicative and additive groups. Probably a bad example. The same error would occur for additive groups though, except that `join=True` gives what we want.

It does not result in an error:

```
sage: from sage.categories.additive_groups import AdditiveGroups
sage: AdditiveGroups().or_subcategory(Rings())
Category of rings
```


> But I am not sure whether we always want to join categories and never make it possible to overwrite them for inheritance purposes.

I don't understand. Join categories are used all over the place in Sage. When creating a new category, we often (maybe even typically) build it as a join or a subcategory thereof.

> I am sure you can somehow construct another example that leads to something undesirable.

If you do, then you are exposing a bug in the category hierarchy.

> Besides, there must be a reason why `or_subcategory` is literally never used for that purpose.

This is used in many places in Sage:

```
uqtscrim@SMP-36PQ8T2:~/sage/src/sage$ grep -R -l "or_subcategory" *
algebras/lie_algebras/quotient.py
algebras/lie_algebras/nilpotent_lie_algebra.py
algebras/lie_algebras/structure_coefficients.py
algebras/lie_algebras/lie_algebra.py
algebras/lie_algebras/subalgebra.py
algebras/lie_algebras/abelian.py
algebras/tensor_algebra.py
algebras/lie_conformal_algebras/lie_conformal_algebra_with_basis.py
algebras/lie_conformal_algebras/graded_lie_conformal_algebra.py
algebras/lie_conformal_algebras/finitely_freely_generated_lca.py
algebras/lie_conformal_algebras/lie_conformal_algebra_with_structure_coefs.py
algebras/clifford_algebra.py
algebras/associated_graded.py
algebras/finite_dimensional_algebras/finite_dimensional_algebra.py
categories/examples/semigroups.py
categories/coxeter_groups.py
categories/category.py
combinat/free_module.py
combinat/diagram_algebras.py
combinat/posets/posets.py
combinat/crystals/subcrystal.py
combinat/crystals/virtual_crystal.py
combinat/combinat.py
groups/lie_gps/nilpotent_lie_group.py
groups/perm_gps/permgroup.py
groups/indexed_free_group.py
homology/simplicial_complex.py
homology/homology_vector_space_with_basis.py
manifolds/manifold.py
modules/with_basis/subquotient.py
modules/with_basis/morphism.py
monoids/indexed_free_monoid.py
rings/function_field/order.py
rings/function_field/valuation_ring.py
rings/function_field/differential.py
rings/function_field/function_field.py
rings/lazy_laurent_series_ring.py
rings/polynomial/ore_polynomial_ring.py
rings/polynomial/ore_function_field.py
rings/polynomial/polynomial_quotient_ring.py
rings/asymptotic/asymptotics_multivariate_generating_functions.py
sets/finite_set_maps.py
sets/recursively_enumerated_set.pyx
sets/non_negative_integers.py
tensor/modules/finite_rank_free_module.py
```

One of the most notable is in `combinat/free_module.py`, which is the base class of many algebras in Sage.


---

Comment by @mjungmath created at 2021-05-13 09:27:19

Replying to [comment:51 tscrim]:
> Replying to [comment:49 gh-mjungmath]:
> > Right, Sage distinguishes between multiplicative and additive groups. Probably a bad example. The same error would occur for additive groups though, except that `join=True` gives what we want.
> 
> It does not result in an error:
> {{{
> sage: from sage.categories.additive_groups import AdditiveGroups
> sage: AdditiveGroups().or_subcategory(Rings())
> Category of rings
> }}}

Mh, you are right, it works. But according to the documentation this input should be invalid, too:


```
or_subcategory(category=None, join=False)
Return category or self if category is None.

INPUT:

    category – a sub category of self, tuple/list thereof, or None

    join – a boolean (default: False)
```


In that case, the documentation should be revised.


---

Comment by @mjungmath created at 2021-05-13 10:07:59

I think the documentation of `or_subcategory` should be modified accordingly, at least the `INPUT` part.


---

Comment by @mjungmath created at 2021-05-13 10:08:26

I apologize for my stubbornness. :D


---

Comment by git created at 2021-05-13 12:07:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-05-13 12:08:21

Here we go, and thank you for your patience, Travis!


---

Comment by @mjungmath created at 2021-05-15 11:04:43

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2021-05-23 05:30:27

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2021-05-23 05:30:27

LGTM. Thank you.


---

Comment by @mjungmath created at 2021-05-23 09:44:02

Thank you for the review! :)


---

Comment by vbraun created at 2021-06-19 20:58:25

Resolution: fixed
