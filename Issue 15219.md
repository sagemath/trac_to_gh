# Issue 15219: fix bug in has_right/left_descents in Weyl group code

Issue created by migration from Trac.

Original creator: zabrocki

Original creation time: 2013-11-26 22:10:38

CC:  sdenton aschilling nthiery sage-combinat

The `has_right_descents` method in `WeylGroup` element methods calls `has_left_descents` and vice versa.  This causes an error in the following example.


```
sage: W = WeylGroup(['A',4])
sage: w = W.from_reduced_word([3,4,2])
sage: w.has_right_descent(3)
Traceback (click to the left of this block for traceback)
...
RuntimeError: maximum recursion depth exceeded
```


The doc tests for this method make calls to `CoxeterGroup` code to test it and so all tests pass.


---

Comment by nthiery created at 2013-11-26 22:20:06

Hi Mike!

This is not a bug but a feature :-)

When implementing a Coxeter group one can choose to either implement has_right_descent or has_left_descent (or both), and the Coxeter group category provides a default implementation for the other, if needed.

Granted, it would be nice if there was a nicer error message mentionning that at least one of has_left_descent or has_right_descent should be implemented. However, at this point, we have not generic infrastructure for this kind of situation, and it would be a bit tedious to do it by hand (but ideas on how to handle this are welcome!).

Cheers,


---

Comment by zabrocki created at 2013-11-26 22:25:38

Hi Nicolas,

This can't be a feature.  In `WeylGroup` this is a bug.  In `CoxeterGroup` it is correct.

In `WeylGroups` the method `has_right_descent` and `has_left_descent` don't do anything except call each other.


---

Comment by zabrocki created at 2013-11-26 22:27:45

BTW, in `WeylGroup` the method `has_descent` doesn't call either `has_right_descent` or `has_left_descent` and decides if there is a right/left descent by another method.


---

Comment by nthiery created at 2013-11-26 22:52:05

Right. The proper specification is:

- at least one of has_descent / has_right_descent / has_left_descent should be implemented
- in generic code, always use has_descent, not has_*_descent.

This definitely should be put in the doc if not yet there.


---

Comment by zabrocki created at 2013-11-26 22:52:30

I take the part about it being correct in `CoxeterGroup` back.  It seems to only be correct for the `CoxeterGroups().example()`.

I assume that you are right in that "Coxeter group category provides a default implementation for the other" but no one has implemented `has_right_descent` or `has_left_descent` for any of the finite or affine `WeylGroups` or `CoxeterGroups` (to an end user of these groups, this is a bug because it should just raise a `Not Implemented` error).

Is the correct solution then that 

(1) someone needs to implement them for each of the types 

(2) that the default implementation should be `has_left_descent` should call `has_descent(self, side="left")`

(3) the default implementation of `has_right_descent` should raise a `Not Implemented` error

(4) something else?


---

Comment by chapoton created at 2014-03-05 16:25:54

Here is a possible solution. Please review.
----
New commits:


---

Comment by chapoton created at 2014-03-05 16:25:54

Changing status from new to needs_review.


---

Comment by tscrim created at 2014-03-05 16:36:01

I think what we should do is have `has_left_descent` call `has_descent(self, side="right")` and `has_right_descent` call `has_descent(self, side="left")`.


---

Comment by chapoton created at 2014-03-05 16:39:48

8)

Indeed ? well, please do that if you think this is the thing to do.


---

Comment by sdenton created at 2014-03-05 16:49:19

tscrim: That's what WAS happening, but if you instantiate an abstract Weyl Group or Coxeter Group it leads to an infinite loop, which is a bug.  What we need is a NotImplemented error if neither side is implemented, and the appropriate call to the implemented 'side' if one side or the other is concretely implemented but not the other.

I see two possible ways forward:
1) The default Coxeter/Weyl Group 'has_x_descent' methods just give a NotImplemented error, pushing it to the person creating a concrete realization to actually implement them correctly and not give an infinite loop, or
2) Introduce some kind of '_is_implemented' flags for checking left and right descent, which are false by default, and set to true if there's a concrete implementation on one side that the other can use.  Then if it's true, we call the other side, and otherwise raise a NotImplemented error.

Option 2 seems doable but introduces an Obscure Thing for the implementers of Coxeter groups to keep track of.  As such, I would advocate for Option 1.


---

Comment by sdenton created at 2014-03-05 16:52:45

It's also worth noting that sometimes one 'side' or the other is simply faster for computing descents.  This is clearly true for simple permutations: one can check in constant time if there's a right descent, but it takes O(n) to check for a left descent.  So then it would be bad news bears to have a default implementation of the right descent that calls the left decent.

But in other cases, it's maybe the left descent that's faster to compute, so you wouldn't want the reverse situation, either...  

So I think I would advocate against breaking symmetry at the Category level, and just raise NotImplemented errors for both sides.


---

Comment by chapoton created at 2014-03-05 17:13:09

I do not understand why my solution is not good enough. From my point of view, the function `has_descent` in `weyl_group.py` should rather be named `has_right_descent`, because it is necessary to have at least one of the two (left or right) descent methods to avoid the infinite loop. I think that `has_descent` should only be defined for abstract Coxeter groups.


---

Comment by tscrim created at 2014-03-05 17:20:28

Hey Tom,

If we made both left/right ``@`abstract_method`'s, then we would have to implement all methods. If we made them optional, I feel that we'd get bug reports about these not being implemented. The problem is that `has_descent()` wasn't being brought into the loop, so if that was the only thing implemented, then one couldn't use `has_left_descent()` as expects. Thus [comment:4 the spec]:

>* at least one of has_descent / has_right_descent / has_left_descent should be implemented

would be satisfied in my proposal.

Although I think we could do a modified version of your proposal 1) by implementing some kind of modification to ``@`abstract_method`. Something like

```
`@`abstract_method(circular=['foo', 'bar'])
```

where if `foo` and `bar` were also called, then error out.


---

Comment by tscrim created at 2014-03-05 17:25:48

Replying to [comment:12 chapoton]:
> I do not understand why my solution is not good enough. From my point of view, the function `has_descent` in `weyl_group.py` should rather be named `has_right_descent`, because it is necessary to have at least one of the two (left or right) descent methods to avoid the infinite loop. I think that `has_descent` should only be defined for abstract Coxeter groups.

The `has_descent()` in `weyl_group.py` works for both sides, and by simply doing an alias, you're exposing invalid (at least 'should not be used') arguments in `has_right_descent()`. In essence what you're doing is saying `has_right_descent()` should call `has_descent()` with the appropriate arguments. I'm saying let's do this in a generic fashion to follow the spec (I think comment:4 point 1 is in the doc already, but I haven't checked).


---

Comment by zabrocki created at 2014-03-05 17:40:24

I couldn't find an indication that the documentation specifies that at least one of has_descent / has_right_descent / has_left_descent should be implemented.

Instead it seems to be that the default implementation of `has_descent` calls `has_left`or`right_descent`

Maybe we should throw checks in `_test_has_descent` to ensure that all of the functions work.


---

Comment by git created at 2014-03-05 20:25:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2014-03-05 20:30:16

Here is new (better) proposal:

The main idea is "please never override has_descent" and "please implement either has_left_descent or has_right_descent" in every instance (if only as a place holder raising `NotImplementedError`).

In `categories/coxeter_group`, there is only the mechanism:

* has_descent calls either has_left_descent or has right_descent
* they call each other

In instances of Coxeter group, one implements either has_left_descent or has_right_descent or both. Even in a minimalistic way, raising a `NotImplementedError`.

What do you think ?


---

Comment by git created at 2014-03-05 20:34:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2014-03-06 12:11:32

I think this is a good solution and probably what was intended to happen when the `CoxeterGroup` code was originally written.  Do others agree?


---

Comment by tscrim created at 2014-03-06 18:32:54

I don't like having the warning saying "don't override this", especially since I don't see  a good reason for doing this (and there's no "final" semantic in python). I am in favor of saying we must implement either `has_left_descent()` or `has_right_descent()`. Also possibly implementing has_left/right_descent()` for `weyl_group.py` to call `has_descent()`.

Anyways, I've put my working version on trac at `u/tscrim/15456`. I also gave default implementations of `has_left/right_descent()` to `weyl_group.py` for speed. Although now that I've done the implementation, I'm less convinced of my suggestion. Perhaps what would be best is some category magic. We test upon creation of a Coxeter group to see if any of the methods have been implemented. Thus we do the following:

- If `has_descent()` has been implemented, give default `has_*_descent()` call `has_descent()` with the appropriate args for those not implemented.
- If none were implemented, error out on construction.
- Otherwise set it up as we have it now.

Maybe this is heavy-handed?

Nevertheless, here are some timings. I'm using the example from the ticket description. Baseline:

```
sage: %timeit w.has_descent(3, side="left")
1000 loops, best of 3: 860 us per loop
sage: %timeit w.has_descent(3, side="left")
1000 loops, best of 3: 820 us per loop
sage: %timeit w.has_descent(3, side="right")
1000 loops, best of 3: 200 us per loop
sage: %timeit w.has_descent(3, side="right")
1000 loops, best of 3: 209 us per loop
```

With Frederic's branch:

```
sage: %timeit w.has_descent(3, side="left")
1000 loops, best of 3: 987 us per loop
sage: %timeit w.has_left_descent(3)
1000 loops, best of 3: 929 us per loop
sage: %timeit w.has_descent(3, side="right")
1000 loops, best of 3: 204 us per loop
sage: %timeit w.has_right_descent(3)
1000 loops, best of 3: 215 us per loop
```

With my branch:

```
sage: %timeit w.has_descent(3, side="left")
1000 loops, best of 3: 867 us per loop
sage: %timeit w.has_left_descent(3)
1000 loops, best of 3: 902 us per loop
sage: %timeit w.has_descent(3, side="right")
1000 loops, best of 3: 200 us per loop
sage: %timeit w.has_right_descent(3)
1000 loops, best of 3: 191 us per loop
```



---

Comment by chapoton created at 2014-03-07 21:09:05

So, what shall we do here ?

If I understand your proposal, when no `has_something` is implemented in an instance of Coxeter group, one has two different possibilities of infinite loop instead of one.

Supose now that I only implement `has_left` and that I call `has_right`. This will result in an infinite loop in your proposal, no ?


---

Comment by tscrim created at 2014-03-07 22:59:49

Ah, I made a correction in my implementation `has_right(i)` called `(~self).has_descent(i, side='left')`.

I'm not so sure now what the best course of action is. From the above, having to create the inverse is slow (at least generically). I'm partially inclined to just implement `has_left` and `has_right` for Weyl groups which calls `has_descent(i, side=*)` to fix the problem at present. In any of the solutions except my initial one, I would think the speed should roughly be the same...


---

Comment by chapoton created at 2014-03-14 16:30:17

Changing keywords from "" to "coxeter".


---

Comment by git created at 2014-04-08 19:11:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2014-04-10 19:10:46

I am comfortable with accepting Frédéric's changes.  From Nicolas' comments I think that the original implementation meant to have `has_descent` should call either `has_left` or `has_right` and at least one of those needs to be implemented.

I checked that at least the `_test_has_descent` will fail when one of these is not implemented by going into a Coxeter group implementation, deleting the `has_right_descent` method, and then checking that `G._test_has_descent()` raises an error.  The problem is that all tests will pass in the implementation of a Coxeter group unless the `_test_has_descent` method is called (which was probably always the case and the source of the original problem).  Is there a way of ensuring that a test of the left and right functions will be made for future implementations?  We can just leave it up to the warning which is already in the documentation.


---

Comment by git created at 2014-04-18 19:22:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by aschilling created at 2015-06-08 16:02:39

New commits:


---

Comment by aschilling created at 2015-06-08 16:55:23

Replying to [comment:25 zabrocki]:
> I am comfortable with accepting Frédéric's changes.  From Nicolas' comments I think that the original implementation meant to have `has_descent` should call either `has_left` or `has_right` and at least one of those needs to be implemented.
> 
> I checked that at least the `_test_has_descent` will fail when one of these is not implemented by going into a Coxeter group implementation, deleting the `has_right_descent` method, and then checking that `G._test_has_descent()` raises an error.  The problem is that all tests will pass in the implementation of a Coxeter group unless the `_test_has_descent` method is called (which was probably always the case and the source of the original problem).  Is there a way of ensuring that a test of the left and right functions will be made for future implementations?  We can just leave it up to the warning which is already in the documentation.

I am ok with Federic's solution. All tests pass, so I think this should go in.


---

Comment by zabrocki created at 2015-06-08 16:56:01

Anne looked at the code as well.  We both approve and I am setting to positive review.


---

Comment by zabrocki created at 2015-06-08 16:56:01

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2015-06-08 17:28:43

This will conflict will #18610 and is probably a duplicate. The review is coming too late.

This need to be checked, nevertheless.


---

Comment by aschilling created at 2015-06-08 19:46:44

Changing status from positive_review to needs_info.


---

Comment by zabrocki created at 2015-06-09 11:58:14

Changing keywords from "coxeter" to "coxeter, sd65".


---

Comment by chapoton created at 2015-06-24 19:30:46

ok, let us consider that this has been solved by #18610


---

Comment by chapoton created at 2015-06-24 19:30:46

Changing status from needs_info to positive_review.


---

Comment by aschilling created at 2015-06-24 19:35:36

Replying to [comment:39 chapoton]:
> ok, let us consider that this has been solved by #18610

Why are you setting it to positive review then and not leave it at sage-duplicate?


---

Comment by chapoton created at 2015-06-24 19:44:21

This is 'positive review as a duplicate', the usual standard procedure, so that it can be closed!


---

Comment by vbraun created at 2015-07-17 20:07:16

Resolution: duplicate
