# Issue 19168: Add lyapunov_rank() method for polyhedral cones

Issue created by migration from https://trac.sagemath.org/ticket/19405

Original creator: mjo

Original creation time: 2015-10-13 17:08:42

CC:  novoselt

The Lyapunov rank measures the length of a `lyapunov_like_basis()` and quantifies how many equations you can get out of the complementarity condition `<x,s> = 0`. Counting a basis is easy but unnecessarily slow when, for example, you have a single ray in a 100-dimensional space.

The new `lyapunov_rank()` method computes the rank using a shortcut based on considering that single ray as living in its own span. Then the remaining 99-dimensions worth of zeros are easily dealt with.

The operation of "considering the ray as living in its own span" is a bit tricky, and can only be done up to linear isomorphism. A private helper method `_restrict_to_space()` handles that.

This is new stuff, but I've presented it to the department (http://michael.orlitzky.com/presentations/the_lyapunov_rank_of_an_improper_cone_-_part_i_-_algorithms.pdf) and a few people have even read the preprint. Perhaps more importantly, there's a doctest that checks the answer against the naive algorithm: `len(K.lyapunov_like_basis())`. So I'm Pretty Sure it works.


---

Comment by mjo created at 2015-10-13 17:11:46

New commits:


---

Comment by mjo created at 2015-10-13 17:11:46

Changing status from new to needs_review.


---

Comment by novoselt created at 2015-10-13 22:57:23

`_restrict_to_subspace` sounds more appropriate and in principle can be of interest on its own, but after reading a bit of your presentation I see that you think of dual cones as living in the same space. This is not at all the case in Sage and quite a bit of effort went into ensuring that dual cones live in dual lattices which have no canonical isomorphism/coercion between them. In particular, there are sublattices of toric lattices and duals of cones living there will live in duals of sublattices, which are quotient of toric lattices for saturated sublattices. There were some issues with this setup that was not used much and was slowly improving, not sure where we are at now...

I will look closer in a few day (remind me if I don't ;-)), but it is something worth thinking about: each cone `K` is coming with its associated space in Sage `K.lattice()` which is not an innter-product space, and `K.dual()` lives in a different space. It would be best if all methods and implementations were in agreement on this point.


---

Comment by git created at 2015-10-14 16:07:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2015-10-14 16:41:33

Replying to [comment:2 novoselt]:
> `_restrict_to_subspace` sounds more appropriate and in principle can be of interest on its own, but after reading a bit of your presentation I see that you think of dual cones as living in the same space.

It's safe to say that everything I know about toric geometry is from your docstrings. I read enough to make sure that we're actually talking about the same thing when we say "dual cone." I think the difference is that you construct the dual cone from the dual vector space whose elements then act on primal vectors via multiplication (function application). Then a rational cone is one that can be represented on an integer lattice?

In optimization, I've only ever seen the dual cone defined in the primal space, but our definition starts in essentially the same way. Rather than a cone of row vectors in a dual space, we just think of the associated column vectors in the original space. That is, the cone of `v`s such that `f_v(w) >= 0` for all `w` in the cone (where the `f_v` live in the dual vector space).

The out-of-place subspace argument is part of the reason why I made `_restrict_to_subspace` private. The other is that it's probably less useful than you think, since it only does what it's supposed to up to linear isomorphism. Unless you're studying something (like Lyapunov rank) that's invariant under linear isomorphism, the restriction just doesn't work.


> I will look closer in a few day (remind me if I don't ;-)), but it is something worth thinking about: each cone `K` is coming with its associated space in Sage `K.lattice()` which is not an innter-product space, and `K.dual()` lives in a different space. It would be best if all methods and implementations were in agreement on this point.

My use of the fact that `K.lattice().vector_space()` and `K.dual().lattice().vector_space()` both have column-vector bases is a bit unsanitary maybe. I guess the latter should be row vectors, and I'd have to convert them before taking their span in the primal space. Acknowledging that the primal/dual rays live in dual spaces isn't a problem as long as I can convert between the two.

Anyway thanks for looking and I'll do what I can to clean it up.


---

Comment by mjo created at 2015-11-09 04:05:55

Ping =)

I'm only being annoying because I'm waiting to submit this paper and I'd like to be able to say "these algorithms are all implemented in sage-6.10..."

You are of course under no obligation to review this -- much less positively -- so if you think it might take a while, I can just submit the paper as-is and try to add that blurb later.


---

Comment by novoselt created at 2015-11-12 23:23:34

Well, I do intend to review this positively, I just usually try to really understand the code and read documentation ;-) Life got a bit busier, but I still hope to manage in time for 6.10.

1. Can we please remove "yet we have no way to perform operations like :meth:`dual` in the subspace" or augment it to the effect of "it is not implemented at the moment" since mathematically there is nothing wrong with taking a cone in a saturated sublattice and considering its dual, which will live in the torsion-free quotient of the dual of the original lattice. I actually had a hope that it will work already, but apparently it does not.
1. The last test in the helper method goes very much against the philosophy of toric dualities with dual lattices being distinct:

```
+        Through a series of restrictions, any closed convex cone can be
+        reduced to a cartesian product with a proper factor [Orlitzky]_::
+
+            sage: set_random_seed()
+            sage: K = random_cone(max_ambient_dim = 8)
+            sage: K_S = K._restrict_to_subspace(K.span())
+            sage: P = K_S.dual().span()
+            sage: K_SP = K_S._restrict_to_subspace(P)
+            sage: K_SP.is_proper()
+            True
```

 Given that this method is there only for the sake of `lyapunov_rank`, I would suggest making it an internal function of `lyapunov_rank`. In this case you can do whatever you want and in fact there is no need at all for documentation and tests - you are of course welcome to still explain what it does, but I am not even sure if test will run on internal functions.
1. Note that there is already `strict_quotient` doing one of the restrictions you need:

```
sage: K = Cone([(1,1,1), (1,0,0), (-1,0,0)])
sage: K
2-d cone in 3-d lattice N
sage: K.rays()
N( 0, 1, 1),
N( 1, 0, 0),
N(-1, 0, 0)
in 3-d lattice N
sage: K.strict_quotient()
1-d cone in 2-d lattice N
sage: K.strict_quotient().rays()
N(1, 1)
in 2-d lattice N
```

1. The recommended spacing for keywords is `random_cone(max_ambient_dim=8)` rather than `random_cone(max_ambient_dim = 8)`


---

Comment by git created at 2015-11-15 01:29:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2015-11-15 01:41:11

I think I can address most of those points at once by implementing the other quotient method. Is there a better name for it than `solid_quotient`?

I thought it was weird that the result of `strict_quotient` was being cached. Do you forsee it being called more than once without being bound to a variable? In any case, I copied that behavior to the new method.


---

Comment by novoselt created at 2015-11-15 22:20:41

Well, to start with, we should realize that it is NOT a quotient! And that's one of those cases when all the fuss about distinct lattices M and N is handy. If our cone lives in N, then `orthogonal_sublattice` is in M and there is no way to quotient N by it. What you want instead is to take the sublattice of N spanned by the cone and think of the cone as living in this sublattice where it will become solid. Since you have discovered that constructing cone in sublattices breaks some methods, you actually want to pick some basis for this sublattice (non-canonical choice) and then send your cone to a "standalone lattice". If you want to expose this functionality to users, perhaps `solid_restriction` or `solid_inclusion` would make sense. Another option is to have it as an internal function with whatever name you like ;-)

For exposure to the user, it may be preferable to have two methods: one to restrict to sublattice as indeed a sublattice (this is canonical), and another taking a cone living in sublattice/quotient lattice/whatever and representing it in the basis of this whatever. The latter is not canonical and has not much mathematical sense, but it makes life easier in the code since nothing should break on regular lattices. (Fixing everything so that nothing breaks on sublattices is an even better noble goal, but will take longer to reach.)

As for caching, I guess I just had overall approach to cache everything that it relatively expensive to compute or is complicated. "Factor cones" are complicated because they are cones - if you start working with their face lattices etc. it is nice to cache things. So far I didn't encounter a situation where it was hurtful. On the other hand, this is not how caching should be implemented in most cases: just return whatever is necessary and add ``@`cached_method` decorator.


---

Comment by novoselt created at 2015-11-15 22:22:58

Oh, and there are things missing:

```
+        If the ambient space is trivial, the Lyapunov rank will be zero.
+        Otherwise, if the dimension of the ambient vector space is `n`,
+        then the resulting Lyapunov rank will be between `1` and `n`
+        inclusive. A Lyapunov rank of `n-1` is not possible [Orlitzky]_.
```

This is only for proper cones, right? There is an example of `n^2` for the vector space below. May be nice to quote the exact theorem number as well.


---

Comment by git created at 2015-11-16 02:36:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2015-11-16 02:56:26

Replying to [comment:10 novoselt]:
> This is only for proper cones, right? There is an example of `n^2` for the vector space below. May be nice to quote the exact theorem number as well.

Right, thanks, that should have been for proper cones. I've updated it but I forgot to quote the theorem number -- I can do that tomorrow.


---

Comment by mjo created at 2015-11-16 03:26:18

Replying to [comment:9 novoselt]:
> Well, to start with, we should realize that it is NOT a quotient! And that's one of those cases when all the fuss about distinct lattices M and N is handy. If our cone lives in N, then `orthogonal_sublattice` is in M and there is no way to quotient N by it.

So that I don't make the same mistake again, I have a few disorganized questions:

1. What exactly is the problem with the quotient? Is it that `M` and `N` are different, so we don't think of the thing in `M` as being a subthing of the thing in `N`? (This makes sense to me, I just didn't expect a "sublattice" method to give me something in another lattice.)

2. I borrowed the quotient terminology from `strict_quotient` where we go through the back door of `linear_subspace()` -- why isn't that cheating too, since it drops down to vector spaces?

3. Sage will let me take the lattice quotient of `N` and a sublattice `M`. Isn't it supposed to stop me? The docstring says it checks for a valid sublattice. Here's an example:


```
sage: K = Cone([(1,0,0),(0,1,0)])
sage: K.lattice()
3-d lattice N
sage: K.orthogonal_sublattice()
Sublattice <M(0, 0, 1)>
sage: K.lattice().quotient(K.orthogonal_sublattice())
2-d lattice, quotient of 3-d lattice N by Free module of degree 3 and rank 1 over Integer Ring
Echelon basis matrix:
[0 0 1]
```


4. If the only problem is the `M`/`N` distinction, can I use `sublattice_complement()` instead of `orthogonal_complement()`? I think this gives me the correct subthing:


```
sage: K.sublattice_complement()
Sublattice <N(0, 0, 1)>
```


Could I now consider `K.lattice().quotient(K.sublattice_complement())` a true quotient?

I'd like to stick to things that make sense in your framework but I may need some hints. I'd hate to use an internal function because then we'd lose the doctests.


---

Comment by novoselt created at 2015-11-16 06:04:50

Replying to [comment:13 mjo]:
> 1. What exactly is the problem with the quotient? Is it that `M` and `N` are different, so we don't think of the thing in `M` as being a subthing of the thing in `N`? (This makes sense to me, I just didn't expect a "sublattice" method to give me something in another lattice.)

Correct, elements of `M` can not be thought of as elements of `N` because while these lattices are isomorphic there is no canonical isomorphism. The reason for the (standard) name "sublattice" here is that a cone has two canonical lattices associated to it - characters/one-dimensional representations and one-parameter subgroups. Neither comes with a choice of basis.

> 2. I borrowed the quotient terminology from `strict_quotient` where we go through the back door of `linear_subspace()` -- why isn't that cheating too, since it drops down to vector spaces?

It is a bit of a cheating in the sense that the result should live in a quotient lattice of N. But since they (quotient lattices) were not implemented before and still lack some features the result is returned in a generic lattice. However, this is "code cheating" - I am performing a mathematically allowed operation in a way possible with current code. Taking quotient of N by sublattice of M is doing a mathematically illegal operation in a way that your (or perhaps rather mine ;-)) code tolerates.

> 3. Sage will let me take the lattice quotient of `N` and a sublattice `M`. Isn't it supposed to stop me? The docstring says it checks for a valid sublattice. Here's an example:
> 
> {{{
> sage: K = Cone([(1,0,0),(0,1,0)])
> sage: K.lattice()
> 3-d lattice N
> sage: K.orthogonal_sublattice()
> Sublattice <M(0, 0, 1)>
> sage: K.lattice().quotient(K.orthogonal_sublattice())
> 2-d lattice, quotient of 3-d lattice N by Free module of degree 3 and rank 1 over Integer Ring
> Echelon basis matrix:
> [0 0 1]
> }}}

It is supposed to stop you, especially since documentation claims it. You have discovered another bug!

> 4. If the only problem is the `M`/`N` distinction, can I use `sublattice_complement()` instead of `orthogonal_complement()`? I think this gives me the correct subthing:
> 
> {{{
> sage: K.sublattice_complement()
> Sublattice <N(0, 0, 1)>
> }}}
> 
> Could I now consider `K.lattice().quotient(K.sublattice_complement())` a true quotient?

It is a true quotient in the sense that it is a mathematically legal operation, however this is not what you want. What you want is just `K.sublattice()` - get coordinates of rays of `K` in the basis of this sublattice and return a new cone in the generic lattice of this dimension generated by those coordinates. Something like

```
N_K = K.sublattice()
L = ToricLattice(N_K.dimension(), <name tweaks>)
Cone([L(N_K.coordinates(r)) for r in K], check=False)
```



---

Comment by git created at 2015-11-17 01:07:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2015-11-17 01:18:58

Thanks for taking the time to explain all that, it really helps by eliminating the inconsistencies in my mental model.

I rewrote `solid_quotient()` as `solid_restriction()` which does the "convenient" restriction to another generic lattice. I wasn't sure what to pick for the new lattice names. Since we're only creating a new lattice for programming convenience, I gave it the same name as the lattice of the original cone.


---

Comment by novoselt created at 2015-11-18 00:25:11

I think it would be better to have `solid_restriction` return the original cone if it is already solid. The amount of time required for the check is not much compared to constructing a new cone and the advantages are common sense and being able to reuse all cached data. My version of changes are posted.

I've also switched to using `cached_method` and changed `==` to `is` in some tests.

`REFERENCES:` block in `lyapunov_rank` should be reformatted perhaps? Or is there a reason why some entries are in Spinx notation and others are not?

Not for this ticket - couldn't you use this more efficient algorithm for computing the Lyapunov basis as well? I.e. compute it for the restriction and then modify appropriately to account for the space and trivial factors?


---

Comment by mjo created at 2015-11-18 02:04:51

Replying to [comment:18 novoselt]:
> `REFERENCES:` block in `lyapunov_rank` should be reformatted perhaps? Or is there a reason why some entries are in Spinx notation and others are not?

The docbuild process throws a fit about duplicate references -- those two appear as references to `discrete_complementarity_set()` and `lyapunov_like_basis()`. That leaves two bad choices: decide it's okay for your build system to spit out big red errors, or mess up the formatting of the references block. I flipped a coin.


> Not for this ticket - couldn't you use this more efficient algorithm for computing the Lyapunov basis as well? I.e. compute it for the restriction and then modify appropriately to account for the space and trivial factors?

Probably =)

Any closed convex cone `K` is isomorphic to a cartesian product of three factors:

1. `K.solid_restriction().strict_quotient()`
2. `K.linear_subspace()`
3. The trivial cone in `K.span().complement()`

Suppose some matrix `A` sends the cone `K` to this nice representation as a product. If we let `L` be a 3x3 block matrix, then you can figure out what the entries should be if `L` is to be Lyapunov-like on `A(K)`. That's basically what I did in Lemma 1 in the paper, but then I threw away some information and just counted dimensions.

The block entries of `L` will be one of three things:

1. Lyapunov-like transformations on `K.solid_restriction().strict_quotient()`
2. Zero
3. Arbitrary

You can fill them in with some coordinate juggling. Afterwards, Proposition 5 shows you how to get back in terms of `K`: simply conjugate by the matrix `A` that put `K` into the nice cartesian product. The only complications I see are aesthetic.

And I told you this boring story... so that I would have a good example below!


> I think it would be better to have `solid_restriction` return the original cone if it is already solid. The amount of time required for the check is not much compared to constructing a new cone and the advantages are common sense and being able to reuse all cached data. My version of changes are posted.

The problem I foresee with this is that it gives you different behavior for solid/nonsolid cones. If `K` is solid, you'll get its representation in one basis, but if it's not, you'll get it in another basis.

Suppose I actually wanted to implement the fast `lyapunov_like_basis` algorithm above. I would need to know which change-of-basis occurs when I call `K.solid_restriction()`, because I would eventually need to do a conjugation involving it. But the change-of-basis depends on whether or not `K` was solid to begin with.

In similar cases where you need to know what happened in `solid_restriction()`, you'll need to prefix that call with `if K.solid()...`, duplicating the check inside the method. Two possible behaviors inside the function forces two possible responses outside it.


Everything else looks fine, tests pass, etc.

----
New commits:


---

Comment by novoselt created at 2015-11-18 04:07:19

I can tell you exactly what matrix to use for the change of coordinates when the cone itself is returned, but I suspect you know it yourself ;-)

The method does not claim anything about which basis is used (although we can mention it, of course) and mathematically there is no good (=canonical) choice of basis for the sublattice of the cone. In this case I think the best option would be to return with the cone also the matrix of the transformation, perhaps only when requested explicitly, `K.solid_restriction(transformation=True)`, and this matrix will be identity in the solid case.


---

Comment by mjo created at 2015-11-18 05:07:26

I don't care that much, but let's delete a few lines from `lyapunov_rank()`.
----
Last 10 new commits:


---

Comment by novoselt created at 2015-11-19 21:48:08

Changing status from needs_review to positive_review.


---

Comment by mjo created at 2015-11-19 22:12:58

Thanks again! I'll go open another ticket for that N/M quotient thing.


---

Comment by novoselt created at 2015-11-19 22:16:35

Great! Also, regarding that possible change when rays of a solid cone are written in the basis of its sublattice - perhaps the sublattice itself should have the standard basis as its basis when it coincides with the whole space. On the other hand I never had problems with the current behaviour in practice, so maybe there is no point to worry about it.


---

Comment by vbraun created at 2015-11-23 06:34:21

Resolution: fixed
