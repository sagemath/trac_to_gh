# Issue 22878: Spanning tree method for DiGraph

Issue created by migration from https://trac.sagemath.org/ticket/23115

Original creator: tpetiteau

Original creation time: 2017-05-31 13:14:58

CC:  tmonteil cchretien dcoudert

Keywords: spanning tree digraph

Add the method spanning_trees to the digraph class.

The method iterates through every spanning trees.
Each tree is rooted in a given vertex v and directed from v to leaves


---

Comment by tpetiteau created at 2017-06-01 07:55:18

Changing status from new to needs_review.


---

Comment by tpetiteau created at 2017-06-01 07:55:18

New commits:


---

Comment by dcoudert created at 2017-06-01 10:09:35

Hello,

I'm not sure that the term `spanning tree` is the best choice. A rooted directed spanning tree is usually called an `out-branching` in digraph theory.

I have several comments, but not enough time today. Only a few below.

To test if we can reach every other vertex from the source, you can simply do:

```
if len(list(self.depth_first_search(source))) < self.order():
    return
```



For initialization of `list_of_edges_to_keep` (and same idea in other places)

```
for i,(u,v) in enumerate(list_of_edges):
    if v != source and u != v:
        list_of_edges_to_keep.append((u, v, [i]))
```


Don't use `xrange` but `range`.

etc.


---

Comment by dcoudert created at 2017-06-01 10:09:35

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2017-06-01 10:10:09

Changing component from PLEASE CHANGE to graph theory.


---

Comment by dcoudert created at 2017-06-04 18:58:14

I think that the following solution is much better.

```
def arborescence_iterator(self, source):
    r"""
    Return an iterator over the rooted arborescences of the current ``DiGraph``.
    """
    from copy import deepcopy
    from itertools import product
    from sage.graphs.digraph import DiGraph
    
    def _arborescence_rec(D, arborescence):
        """
        """
        if arborescence.size() == self.order() - 1:
            # We have the shape of the arborescence. We iterate over the
            # combinations of labels of the multiple edges (if any).
            if multiple_edges:
                L = [[(u, v, l) for l in labels] for u,v,labels in arborescence.edges()]
                for edges in product(*L):
                    yield DiGraph(deepcopy(edges), format='list_of_edges')
            else:
                yield DiGraph(deepcopy(arborescence.edges()), format='list_of_edges')

        else:
            # 1) Pick an edge e in the out boundary of the current arborescence
            e = D.edge_boundary(arborescence.vertices())[0]

            # 2) Find all arborescences that do not contain e
            D.delete_edge(e)
            if len(list(D.depth_first_search(arborescence.vertices()))) == D.order():
                for tree in _arborescence_rec(D, arborescence): 
                    yield tree
            D.add_edge(e)
        
            # 3) Find all arborescences that do contain e
            arborescence.add_edge(e)
            for tree in _arborescence_rec(D, arborescence): 
                yield tree
            # We remove edge e and its target
            arborescence.delete_vertex(e[1])


    if not self.has_vertex(source):
        return

    # Test if the source can access to every other vertex
    if len(list(self.depth_first_search(source))) < self.order():
        return

    # We build a digraph without loops nor multiple edges, and we store the
    # labels of multiple edges.
    D = self.to_simple(to_undirected=False)
    D.delete_edges(D.incoming_edges(source))

    multiple_edges = self.has_multiple_edges()
    if multiple_edges:
        for u,v in D.edge_iterator(labels=0):
            D.set_edge_label(u, v, self.edge_label(u,v))
    
    arborescence = DiGraph()
    arborescence.add_vertex(source)
    
    return _arborescence_rec(D, arborescence)
```



---

Comment by dcoudert created at 2017-06-05 11:26:43

I pushed a proposal for this method in `public/23115`. It allows to iterate over both in and out arborescences (or branchings or directed rooted trees) [1]. If you like it you can change the branch name in this ticket.
Since the branch is in public, you are allowed to modify it if needed.
----
[1] https://en.wikipedia.org/wiki/Arborescence_(graph_theory)


---

Comment by dcoudert created at 2017-06-06 09:57:06

Let's go back to what you have proposed.

In your code, you have a complex use of indexes to cope with multi edges.

Actually, what you are doing, and this is the correct approach, is:
1. find an out-branching T in the digraph without labels
2. enumerate all possible out-branching that you can obtain from T using combinations of labels
3. goto step 1

To ease the readability of your code, I propose to proceed as follows:
1. build a data structure (a dictionary) keyed by pairs (u,v), so without labels, containing the list of labeled edges. That is, `dico[u,v] = [(u, v, label1), (u, v, label2)]`
2. find out-branchings T without labels. 
3. When you have an out-branching, enumerate all labeled out-branchings using the `product` operator and the dictionary `edge without label -> list of labeled edges`


Note that the out-branching without labels is exactly the list of the edges you have contracted.


In your code, you have chosen to contract edges. Clearly it eases the selection of the next edge to consider (you can use `graph.outgoing_edge_iterator(source)`). The drawback is that you may create loops or multiple edges, and that you have to perform many operations to deal with those edges and also undo the contractions.
You could instead maintain 2 graphs:
* The first one, G, is a copy of ``self`` without loops/multiedges/labels. On this graph you can only remove and put back the current edge
* The second one, T, is the current out-branching. So you add in it the current edge and later remove that edge.
So doing, the maintenance is much easier. You can use `G.edge_boundary(T.vertices())` to find the next edge.

Let me know if you have questions.


---

Comment by git created at 2017-06-15 16:08:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tpetiteau created at 2017-06-15 16:31:14

First of all thank you for the feedback !
\\
\\
We implemented the recommendations you made on comment 4 and stole some ideas from your solution that improved our algorithm a lot.
\\
\\
We took some time before answering because we wanted to compare both algorithms.
 
We then made some tests with different graphs (based on the following code)



```
from contextlib import contextmanager
from timeit import default_timer

@contextmanager
def elapsed_timer():
    start = default_timer()
    elapser = lambda: default_timer() - start
    yield lambda: elapser()
    end = default_timer()
    elapser = lambda: end-start

D = digraphs.RandomDirectedGNP(50, .08)

x = D.arborescence_iterator(0)
with elapsed_timer() as e:
    for eee in range(100000):
        x.next().size(),
print e()

x = D.spanning_trees(0)
with elapsed_timer() as e:
    for eee in range(100000):
        x.next().size(),
print e()
```


This test gives us 185 seconds for your solution and 107 seconds for ours.

So we think that the last committed version might be more suitable than your solution or the previous one.

Concerning the name of our algorithm we found a lot of article using the term "spanning tree" while other use "arborescence"; therefore we do not think it is necessary to change it.

Anyway, thanks again for your feedback it helped us a lot.


---

Comment by tpetiteau created at 2017-06-15 16:31:31

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2017-06-16 09:46:39

A first round of unordered comments:
* do not use `D.outgoing_edge_iterator(source).next()` but `next(D.outgoing_edge_iterator(source))`
* Add some details to clarify how you play with labels. It is not obvious at all
* ensure that comments are formtted in 80 columns mode. This is easy to do with some editors like emacs
* instead of using 3 lists to store edges (`out_source`, etc.), you could use a single `saved_edges` list
* to ease termination test, you could pass an argument (depth) to the `_rec_spanning_trees` method so that the final test becomes `if depth == 0:`


---

Comment by tpetiteau created at 2017-06-16 09:52:45

Changing status from needs_review to needs_work.


---

Comment by tpetiteau created at 2017-06-16 09:57:04

We will make sure to apply the modifications you suggest.

But we are not sure that we fully understand what you mean by :

 - to ease termination test, you could pass an argument (depth) to the `_rec_spanning_trees` method so that the final test becomes `if depth == 0`:

Do you want to replace `if(len(list_merged_edges)) == self.order()-1` by a test on a parameter `depth` gave to `_rec_spanning_trees` method ?


---

Comment by dcoudert created at 2017-06-16 10:00:53

Replying to [comment:14 tpetiteau]:
> We will make sure to apply the modifications you suggest.
> 
> But we are not sure that we fully understand what you mean by :
> 
>  - to ease termination test, you could pass an argument (depth) to the `_rec_spanning_trees` method so that the final test becomes `if depth == 0`:
> 
> Do you want to replace `if(len(list_merged_edges)) == self.order()-1` by a test on a parameter `depth` gave to `_rec_spanning_trees` method ?
Exactly. The first call is with `self.order()-1` and then each recursive call is with `depth-1` (or a more suitable name).


---

Comment by dcoudert created at 2017-10-21 08:55:51

any update ?


---

Comment by tpetiteau created at 2017-10-26 16:57:07

Update is coming, I got caught in personal problem and crashed my computer.

I should get time this week end to upload the last modification.


---

Comment by tmonteil created at 2018-02-04 16:13:42

ping :)


---

Comment by git created at 2020-02-13 13:56:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-02-13 13:59:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-02-13 14:05:43

Changing status from needs_work to needs_review.


---

Comment by @vipul79321 created at 2020-02-13 14:10:47

Set assignee to @vipul79321.


---

Comment by dcoudert created at 2020-02-14 12:41:03

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2020-02-14 12:41:03

**General comments:**

- All comments must be formatted in 80 columns mode. You can certainly configure your editor for that
- `The spanning trees are rooted in the vertex source and directed from source to leaves.` -> `The spanning trees are rooted at  vertex ``source`` and edges are directed from source to leaves.`


```diff
-            - :meth:`~sage.graphs.generic_graph.GenericGraph.spanning_trees_count`$
+            - :meth:`~sage.graphs.generic_graph.GenericGraph.spanning_trees_count`
```



```diff
-        A simple Graph: a square with edges in both directions
-
-        ::
+        A bidirectional 4-cycle::
```



```diff
-        With the Petersen graph turned into a directed graph
-
-        ::
+        With the Petersen graph turned into a symmetric directed graph::
```


- In tests and examples, avoid empty lines before `::`. Can be placed directly at the end of the line

- we can avoid calling twice method `outgoing_edge_iterator` as follows

```diff
-            # 2) Pick an edge e outgoing from the source
-            if(len(D.outgoing_edges(source))==0):
-                return
-            s, x, l = next(D.outgoing_edge_iterator(source))
+            # 2) Pick an edge e outgoing from the source
+            try:
+                s, x, l = next(D.outgoing_edge_iterator(source))
+            except:
+                return
```


- Prefer `(u, v, l)` to `(u,v,l)`, `self.order() - 1` to `self.order()-1`,  `D.add_edge(u, v, (i,))` to `D.add_edge(u,v,(i,))`, 


**Terminology:**

I understand the use of spanning trees in this context and it is a counter part of the method for undirected graphes. However, I don't think it is the correct terminology in directed graphs. More precisely, [1] defines out-branchings as trees rooted at a vertex u with all vertices of in-degree 1 (so all edges directed from source to leaves) and similarly in-branchings. Such a branching is not necessarily spanning, and so we can use the term `spanning out branching`.

[1] Jørgen Bang-Jensen, Gregory Z. Gutin: Digraphs - Theory, Algorithms and Applications, Second Edition. Springer Monographs in Mathematics, Springer 2009, ISBN 978-1-84800-997-4, pp. I-XXII, 1-795  
[2] https://en.wikipedia.org/wiki/Arborescence_(graph_theory)


**Todo:**
- The current code iterates over spanning out branchings. Why not also iterating over spanning in branchings ?
- add iterator over in and out branchings


---

Comment by @vipul79321 created at 2020-02-14 13:10:52

Replying to [comment:25 dcoudert]:
> 
> **General comments:**
> 
> - All comments must be formatted in 80 columns mode. You can certainly configure your editor for that
> - `The spanning trees are rooted in the vertex source and directed from source to leaves.` -> `The spanning trees are rooted at  vertex ``source`` and edges are directed from source to leaves.`
> 


> {{{#!diff
> -            - :meth:`~sage.graphs.generic_graph.GenericGraph.spanning_trees_count`$
> +            - :meth:`~sage.graphs.generic_graph.GenericGraph.spanning_trees_count`
> }}}
> 
> {{{#!diff
> -        A simple Graph: a square with edges in both directions
> -
> -        ::
> +        A bidirectional 4-cycle::
> }}}
> 
> {{{#!diff
> -        With the Petersen graph turned into a directed graph
> -
> -        ::
> +        With the Petersen graph turned into a symmetric directed graph::
> }}}
> 
> - In tests and examples, avoid empty lines before `::`. Can be placed directly at the end of the line
> 
> - we can avoid calling twice method `outgoing_edge_iterator` as follows
> {{{#!diff
> -            # 2) Pick an edge e outgoing from the source
> -            if(len(D.outgoing_edges(source))==0):
> -                return
> -            s, x, l = next(D.outgoing_edge_iterator(source))
> +            # 2) Pick an edge e outgoing from the source
> +            try:
> +                s, x, l = next(D.outgoing_edge_iterator(source))
> +            except:
> +                return
> }}}
> 
> - Prefer `(u, v, l)` to `(u,v,l)`, `self.order() - 1` to `self.order()-1`,  `D.add_edge(u, v, (i,))` to `D.add_edge(u,v,(i,))`, 
> 
> 
Ok
I will apply all the modifications you suggested.
> **Terminology:**
> 
> I understand the use of spanning trees in this context and it is a counter part of the method for undirected graphes. However, I don't think it is the correct terminology in directed graphs. More precisely, [1] defines out-branchings as trees rooted at a vertex u with all vertices of in-degree 1 (so all edges directed from source to leaves) and similarly in-branchings. Such a branching is not necessarily spanning, and so we can use the term `spanning out branching`.
> 
> [1] Jørgen Bang-Jensen, Gregory Z. Gutin: Digraphs - Theory, Algorithms and Applications, Second Edition. Springer Monographs in Mathematics, Springer 2009, ISBN 978-1-84800-997-4, pp. I-XXII, 1-795  
> [2] https://en.wikipedia.org/wiki/Arborescence_(graph_theory)
> 
> 
Yes, We can use the term `spanning_out_branching` instead of `spanning_trees`.
> **Todo:**
> - The current code iterates over spanning out branchings. Why not also iterating over spanning in branchings ?
> - add iterator over in and out branchings
> 
This part is quite unclear to me.
Are you suggesting that we should write another method `spanning_in_branching`, which will return a directed tree in which there is path from each vertex to source?
> 
>


---

Comment by dcoudert created at 2020-02-14 13:15:20

> Yes, We can use the term `spanning_out_branching` instead of `spanning_trees`.
> > **Todo:**
> > - The current code iterates over spanning out branchings. Why not also iterating over spanning in branchings ?
> > - add iterator over in and out branchings
> > 
> This part is quite unclear to me.
> Are you suggesting that we should write another method `spanning_in_branching`, which will return a directed tree in which there is path from each vertex to source?

Exactly. Observe that in such branching, each vertex except the source (in fact a target) has out degree 1.


---

Comment by @vipul79321 created at 2020-02-14 14:09:17

Replying to [comment:27 dcoudert]:
> > Yes, We can use the term `spanning_out_branching` instead of `spanning_trees`.
> > > **Todo:**
> > > - The current code iterates over spanning out branchings. Why not also iterating over spanning in branchings ?
> > > - add iterator over in and out branchings
> > > 
> > This part is quite unclear to me.
> > Are you suggesting that we should write another method `spanning_in_branching`, which will return a directed tree in which there is path from each vertex to source?
> 
> Exactly. Observe that in such branching, each vertex except the source (in fact a target) has out degree 1.
Ok, I got it now.
But how do you propose to check whether source is accesible from each vertex?
Either we can check the following condition `len(list(self.reverse().depth_first_search(source))==self.order())`
or 
we can implement modified version of DFS in our method specifically for this purpose.


---

Comment by dcoudert created at 2020-02-14 14:51:08

Generally, ready the documentation of methods helps a lot:

```
sage: G = digraphs.Path(5)
sage: G.depth_first_search??
sage: list(G.depth_first_search(2, neighbors=G.neighbor_in_iterator))
[2, 1, 0]
sage: list(G.depth_first_search(2, neighbors=G.neighbor_out_iterator))
[2, 3, 4]
```



---

Comment by git created at 2020-02-14 16:45:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-02-14 16:54:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-02-14 16:57:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-02-14 17:00:13

Replying to [comment:30 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[15267ea](https://git.sagemath.org/sage.git/commit/?id=15267eabe3a6e9487f334b2fbaf1f96502c2c4c7)||`method spanning_in_branching added`||
I mistakenly made some changes in graph.py file. Those changes are removed in the next two commits.
I have made all the modifications suggested in comment 25 and added method `spanning_in_branching` in digraph.py


---

Comment by @vipul79321 created at 2020-02-14 17:00:29

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2020-02-15 12:00:39

- the patchbot reports a pyflakes error as itertools.chain is not used

```diff
-from itertools import product, chain
+from itertools import product
```


- Format all documentation and comments of your methods in 80 columns mode

- We can improve the definition

```diff
-        The spanning out branching are rooted in the vertex ``source`` and directed from source to leaves.
+        An out-branching is a directed tree rooted at ``source`` whose arcs are directed from source to
+        leaves. An out-branching is spanning if it contains all vertices of the digraph. 
}}} 

- and also
{{{#!diff
-        If no spanning out branching exist, return nothing.
+        If no spanning out branching rooted at ``source`` exist, return nothing.
}}}

- `spanning out branches` -> `spanning out branchings`

- We try to comply with the PEP8 style guide for Python code [https://www.python.org/dev/peps/pep-0008/ ]. So,
 - `D.delete_edge(u,v,l)` -> `D.delete_edge(u, v, l)`
 - `(u,v)` -> `(u, v)`

- instead of `depth -= 1` and later `depth += 1`, you can change the call to `_rec_spanning_out_branchings(depth - 1)`

- Instead of returning nothing if the source is not a vertex of the digraph, we should raise an error and adapt doctests accordingly. 
{{{
    if not self.has_vertex(source):
        raise ValueError("vertex ({0}) is not a vertex of the digraph".format(source))
}}}


- I propose the following simpler code
{{{#!diff
-        # We build a copy of the current Digraph removing loops and edges 
-        # coming in sources
-        # We give to every edge a label corresponding to its index in the list 
-        # of edges of the current digraph
-        D = DiGraph(multiedges=True, loops=True)
-        list_edges = self.edges()
-        depth = self.order() - 1
-        # Adding edges in D with label corresponding to index of that edge in
-        # self.edges()
-        for i,(u, v, _) in enumerate(list_edges):
-            if u != v and v != source:
-                D.add_edge(u, v, (i,))
-        list_merged_edges = set()
-        return _rec_spanning_out_branchings(depth)
+       # We build a copy of self in which each edge has a distinct label.
+       # On the way, we remove loops and edges incoming to source.
+        D = DiGraph(multiedges=True, loops=True)
+        for i, (u, v) in enumerate(self.edges(labels=False, sort=False)):
+            if u != v and v != source:
+                D.add_edge(u, v, (i,))
+        list_merged_edges = set()
+        return _rec_spanning_out_branchings(self.order() - 1)
}}}


- similar changes have to be done for `spanning_in_branching`.

- don't forget to add the methods to the top tables of the file.
- Also, check that the documentation builds well and displays properly.


---

Comment by git created at 2020-02-16 05:12:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-02-16 10:17:27

- alignment

```diff
-        - ``source`` -- vertex used as the source for all spanning out 
-        branchings.
+        - ``source`` -- vertex used as the source for all spanning out 
+          branchings.
```


- I did a mistake in last review when I proposed to remove `list_edges` It is effectively needed and more efficient. Indeed, now `.edges` returns a `EdgesView` and asking for the `i`-th edge takes time `O(i)` instead of constant time with a list. So, you have to do:

```diff
-                    yield DiGraph([self.edges(sort=False)
-                                     [index] for index in indexes],
-                                      format='list_of_edges',
-                                      pos=self.get_pos())
+                    yield DiGraph([list_edges[index] for index in indexes],
+                                     format='list_of_edges',
+                                     pos=self.get_pos())
```

  and

```diff
-        for i, (u, v) in enumerate(self.edges(labels=False, sort=False)):
+        list_edges = list(self.edges(labels=False, sort=False))
+        for i, (u, v) in enumerate(list_edges):
```


- FYI: you can write `merged_multiple_edges[(u, v)]` or `merged_multiple_edges[u, v]`

- The 80 columns mode is mandatory for documentation, not for the code. 

```diff
-                D.add_edges([(u, v, l)
-                                for (u, v),l in merged_multiple_edges.items()])
+                D.add_edges([(u, v, l) for (u, v),l in merged_multiple_edges.items()])
```


```diff
-            raise ValueError("vertex ({0}) is not a vertex of the digraph"\
-                .format(source))
+            raise ValueError("vertex ({0}) is not a vertex of the digraph".format(source))
```



- Same comments for the second method.

Note also that I'm currently unable to build the documentation, at least due to the first bullet above.


---

Comment by git created at 2020-02-16 13:46:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-02-16 14:22:37

the doc builds but does not display well. After some trials and a look at relevant documentation [http://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html](http://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html), I got good result with

```diff
-        At each step:
-            #.0) clean the graph (see below) 
-            #.1) pick an edge e out of source
-            #.2) find all spanning out branchings that do not contain e by first 
-            removing it
-            #.3) find all spanning out branchings that do contain e by first 
-            merging the end vertices of e
+        At each step:
+
+        0. clean the graph (see below)
+        1. pick an edge e out of source
+        2. find all spanning out branchings that do not contain e by first
+           removing it
+        3. find all spanning out branchings that do contain e by first merging
+           the end vertices of e
```


Beware to not introduce trailing whitespaces (useless spaces at the end of lines).


---

Comment by git created at 2020-02-17 05:13:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-02-17 07:26:30

You forgot the blank line between the numbering an the previous line. `;)`

Also, are we sure the multiedge code works correctly? I am a little dubious of this:

```
merged_multiple_edges[(u, v)] += l
```

as I feel it actually adds the labels rather than concatenates them. I think you should wrap the labels in a `str(l)` (including for the first one). In particular, try a mutliedge digraph with a string and an integer label.


---

Comment by @vipul79321 created at 2020-02-17 07:51:11

Replying to [comment:41 tscrim]:
> You forgot the blank line between the numbering an the previous line. `;)`
> 
I am not sure what are you saying. Can you please clarify?
> Also, are we sure the multiedge code works correctly? I am a little dubious of this:
> {{{
> merged_multiple_edges[(u, v)] += l
> }}}
> as I feel it actually adds the labels rather than concatenates them. I think you should wrap the labels in a `str(l)` (including for the first one). In particular, try a mutliedge digraph with a string and an integer label.

Yeah, Code works fine with digraph of multiple edges. Because in code, while making a copy of `self` in digraph D we are adding edges with label `(i,)` where i is index of that edge in `self.edges()` and since `(i,)` is a tuple object so multiple labels will concatenate.


---

Comment by tscrim created at 2020-02-17 08:05:08

Replying to [comment:42 gh-vipul79321]:
> Replying to [comment:41 tscrim]:
> > You forgot the blank line between the numbering an the previous line. `;)`
> > 
> I am not sure what are you saying. Can you please clarify?


```diff
         At each step:
+
         0. clean the graph (see below)
```


> > Also, are we sure the multiedge code works correctly? I am a little dubious of this:
> > {{{
> > merged_multiple_edges[(u, v)] += l
> > }}}
> > as I feel it actually adds the labels rather than concatenates them. I think you should wrap the labels in a `str(l)` (including for the first one). In particular, try a mutliedge digraph with a string and an integer label.
> 
> Yeah, Code works fine with digraph of multiple edges. Because in code, while making a copy of `self` in digraph D we are adding edges with label `(i,)` where i is index of that edge in `self.edges()` and since `(i,)` is a tuple object so multiple labels will concatenate.

Ah, I see. I didn't look closely enough at what the code was doing. Could you add such a test though to make sure it stays working?

Also, I feel it would be faster to make a full (mutable) copy of the digraph and then just modify its labels. It wouldn't require two copies of the edges. Although maybe iterating over the edges in a multiedge diagraph and changing the labels is not so good? Actually, are there any problems if the digraph has a singleton vertex?


---

Comment by git created at 2020-02-17 13:32:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-02-17 13:40:27

Replying to [comment:43 tscrim]:
> Replying to [comment:42 gh-vipul79321]:
> > Replying to [comment:41 tscrim]:
> > > You forgot the blank line between the numbering an the previous line. `;)`
> > > 
> > I am not sure what are you saying. Can you please clarify?
> 
> {{{#!diff
>          At each step:
> +
>          0. clean the graph (see below)
> }}}
> 
> > > Also, are we sure the multiedge code works correctly? I am a little dubious of this:
> > > {{{
> > > merged_multiple_edges[(u, v)] += l
> > > }}}
> > > as I feel it actually adds the labels rather than concatenates them. I think you should wrap the labels in a `str(l)` (including for the first one). In particular, try a mutliedge digraph with a string and an integer label.
> > 
> > Yeah, Code works fine with digraph of multiple edges. Because in code, while making a copy of `self` in digraph D we are adding edges with label `(i,)` where i is index of that edge in `self.edges()` and since `(i,)` is a tuple object so multiple labels will concatenate.
> 
> Ah, I see. I didn't look closely enough at what the code was doing. Could you add such a test though to make sure it stays working?
> 
> Also, I feel it would be faster to make a full (mutable) copy of the digraph and then just modify its labels. It wouldn't require two copies of the edges. Although maybe iterating over the edges in a multiedge diagraph and changing the labels is not so good? Actually, are there any problems if the digraph has a singleton vertex?

Thanks for pointing that out. It was returning an empty digraph for Digraph with singleton vertex.
I have fixed that. But, now it is returning a Digraph containing that vertex and not a generator object.
Can you suggest me something for that purpose?


---

Comment by dcoudert created at 2020-02-17 17:09:21

This will do the job

```diff
-            return D
+            yield D
+            return
```



---

Comment by @vipul79321 created at 2020-02-17 17:46:53

Replying to [comment:46 dcoudert]:
> This will do the job
> {{{#!diff
> -            return D
> +            yield D
> +            return
> }}}
On doing this, test of empty Digraph fails.

```
sage: G = DiGraph()
sage: G.order()
0
sage: G.spanning_out_branching(0)
<generator object DiGraph.spanning_out_branching at 0x7f9a4892c4f8>
```

It should have thrown error here instead.

```
sage: list(G.spanning_out_branching(0))
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-14-3a617b5469bd> in <module>()
----> 1 list(G.spanning_out_branching(Integer(0)))

/home/vipul/sage/local/lib/python3.7/site-packages/sage/graphs/digraph.py in spanning_out_branching(self, source)
   3395 
   3396         if not self.has_vertex(source):
-> 3397             raise ValueError("vertex ({0}) is not a vertex of the digraph".format(source))
   3398 
   3399         # check if the source can access to every other vertex

ValueError: vertex (0) is not a vertex of the digraph

```

And this throws error. 
I am unable to understand this behavior. Any suggestions will be helpful.


---

Comment by tscrim created at 2020-02-17 23:02:48

How about passing the vertices to the `DiGraph` on its construction? I would still advocate for just using the internal `DiGraph.copy()` and then relabeling/mutating. You may need to special case the empty digraph too.


---

Comment by git created at 2020-02-18 04:00:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-02-18 04:03:59

Replying to [comment:49 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[7afd10c](https://git.sagemath.org/sage.git/commit/?id=7afd10cf7a6d38f6079400af7c27757450e77023)||`Fixed for singleton digraph, added tests for multiple edges`||
I have added a small function which will be called only for digraph with a singleton vertex.
Now the code works fine.


---

Comment by @vipul79321 created at 2020-02-18 04:10:12

Replying to [comment:48 tscrim]:
> How about passing the vertices to the `DiGraph` on its construction? I would still advocate for just using the internal `DiGraph.copy()` and then relabeling/mutating. You may need to special case the empty digraph too.
I think it will consume more time, firstly making copy of `self` then relabelling that copy.
Also, I have fixed the current method. You can have a look at it and tell me if there are any suggestions.


---

Comment by tscrim created at 2020-02-18 05:11:16

Replying to [comment:51 gh-vipul79321]:
> Replying to [comment:48 tscrim]:
> > How about passing the vertices to the `DiGraph` on its construction? I would still advocate for just using the internal `DiGraph.copy()` and then relabeling/mutating. You may need to special case the empty digraph too.
> I think it will consume more time, firstly making copy of `self` then relabelling that copy.

I would be a bit surprised by this because it is just copying memory, not rebuilding itself (at least, if it is a good copy method). Whereas rebuilding the digraph with the modified edges would require the internal structure to be manipulated, especially since this is done in Python. It might be worthwhile to try both methods and compare the timings.

> Also, I have fixed the current method. You can have a look at it and tell me if there are any suggestions.  

I don't see why `_singleton_spanning` needs to be a separate function. It is equivalent to the change resulting in

```
yield D
return
```

as David indicated in comment:46.


---

Comment by @vipul79321 created at 2020-02-18 05:20:50

Replying to [comment:52 tscrim]:
> Replying to [comment:51 gh-vipul79321]:
> > Replying to [comment:48 tscrim]:
> > > How about passing the vertices to the `DiGraph` on its construction? I would still advocate for just using the internal `DiGraph.copy()` and then relabeling/mutating. You may need to special case the empty digraph too.
> > I think it will consume more time, firstly making copy of `self` then relabelling that copy.
> 
> I would be a bit surprised by this because it is just copying memory, not rebuilding itself (at least, if it is a good copy method). Whereas rebuilding the digraph with the modified edges would require the internal structure to be manipulated, especially since this is done in Python. It might be worthwhile to try both methods and compare the timings.
>
Ok, I will give it a try.
> > Also, I have fixed the current method. You can have a look at it and tell me if there are any suggestions.  
> 
> I don't see why `_singleton_spanning` needs to be a separate function. It is equivalent to the change resulting in
> {{{
> yield D
> return
> }}}
> as David indicated in comment:46.
Yeah, that bugs me too.


---

Comment by @vipul79321 created at 2020-02-18 06:15:49

Replying to [comment:48 tscrim]:
> How about passing the vertices to the `DiGraph` on its construction? I would still advocate for just using the internal `DiGraph.copy()` and then relabeling/mutating. You may need to special case the empty digraph too.
I am having trouble in relabeling multiedges since our code needs edge label to be of tuple (or any other type allowing concatenation).
Here is a link regarding same problem [https://ask.sagemath.org/question/25659/how-do-i-set-label-of-multiedges-graph/](https://ask.sagemath.org/question/25659/how-do-i-set-label-of-multiedges-graph/)
Can you help me out here?


---

Comment by tscrim created at 2020-02-18 06:39:25

Replying to [comment:54 gh-vipul79321]:
> Replying to [comment:48 tscrim]:
> > How about passing the vertices to the `DiGraph` on its construction? I would still advocate for just using the internal `DiGraph.copy()` and then relabeling/mutating. You may need to special case the empty digraph too.
> I am having trouble in relabeling multiedges since our code needs edge label to be of tuple (or any other type allowing concatenation).
> Here is a link regarding same problem [https://ask.sagemath.org/question/25659/how-do-i-set-label-of-multiedges-graph/](https://ask.sagemath.org/question/25659/how-do-i-set-label-of-multiedges-graph/)
> Can you help me out here?

Hmm...that is a problem. Perhaps then the thing to do would be to separate out the multiedge case during the initial construction rather than in the helper functions `_rec_*`? In that case you just have to build the new (merged) digraph. This also has the benefit of when you start the recursion, you know you have a non-multiedge-diagraph.


---

Comment by @vipul79321 created at 2020-02-18 08:19:31

Replying to [comment:55 tscrim]:
> Replying to [comment:54 gh-vipul79321]:
> > Replying to [comment:48 tscrim]:
> > > How about passing the vertices to the `DiGraph` on its construction? I would still advocate for just using the internal `DiGraph.copy()` and then relabeling/mutating. You may need to special case the empty digraph too.
> > I am having trouble in relabeling multiedges since our code needs edge label to be of tuple (or any other type allowing concatenation).
> > Here is a link regarding same problem [https://ask.sagemath.org/question/25659/how-do-i-set-label-of-multiedges-graph/](https://ask.sagemath.org/question/25659/how-do-i-set-label-of-multiedges-graph/)
> > Can you help me out here?
> 
> Hmm...that is a problem. Perhaps then the thing to do would be to separate out the multiedge case during the initial construction rather than in the helper functions `_rec_*`? In that case you just have to build the new (merged) digraph. This also has the benefit of when you start the recursion, you know you have a non-multiedge-diagraph.

Separating out multiedge during initial construction won't work because during recursion it might be possible that graph formed by merging vertices have multiedges.


---

Comment by dcoudert created at 2020-02-18 09:48:52

First of all, the flow of operations should be something like:
1. deal with empty graph -> return nothing
2. check that the source is in the graph. If not, raise error
3. Deal with graphs of order 1 (singleton)
4. check that all vertices can be reached. If not, raise error
5. call recursive method

Concerning the idea of making a copy of the graph.
- It can hardly be done inside the recursive method due to the creation of new multi-edges when merging vertices
- However, if the input graph has multiple edges, we could make a simple copy of it (without loops / multi edges), then call the recursive method, and on the way back yield all possible labelings of edges that are based on the same graph.

Another idea, to make the method more general is to add it an optional parameter `spanning` default to `True`, so that the method can also yield non spanning out branchings. Then, when this parameter is true, we check that all vertices can be reached. Otherwise, we initialize the `depth` parameter with the number of vertices that can be reached and possibly work only on the subgraph containing only these vertices.


---

Comment by git created at 2020-02-18 13:12:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-02-18 13:45:27

When you check if the order is 1, there is no need to check if the graph has the vertex. Already done before.
And there is no need for a specific method. It can be done in the else part.

You don't check if the graph is empty and actually there is no need for it as the empty graph cannot have the source vertex.


---

Comment by git created at 2020-02-18 14:33:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-02-18 14:34:39

Replying to [comment:59 dcoudert]:
> When you check if the order is 1, there is no need to check if the graph has the vertex. Already done before.
> And there is no need for a specific method. It can be done in the else part.
> 
I tried this but the same problem arises again.


---

Comment by dcoudert created at 2020-02-19 09:00:00

One solution is to decide if an out-branching can be a single vertex.

`@`tscrim: what do you think ?


Since we now have parameter `spanning`,  we can remove `spanning_` from method names.


---

Comment by tscrim created at 2020-02-19 09:51:05

Replying to [comment:62 dcoudert]:
> One solution is to decide if an out-branching can be a single vertex.
> 
> `@`tscrim: what do you think ?

I don't have a strong opinion on the matter, but I would naïvely expect it to be one.


---

Comment by git created at 2020-02-19 10:49:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-02-19 11:07:46

Replying to [comment:64 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[27c06b2](https://git.sagemath.org/sage.git/commit/?id=27c06b24d60f63adc40d0137a01e1826e7a96e16)||`names of method updated and non spanning branching for isolated vertex added`||
For isolated source and `spanning=False` it was returning an empty generator object. I have corrected that


---

Comment by dcoudert created at 2020-02-19 15:42:31

Can you update the first line of documentation (also in top table) to clarify that the method returns an out-branchin. That is remove the term spanning. Same for in-branching.

You also have to add adjust the examples (distinguish calls with `spanning=True` and `False`), and may be add other examples if needed.

Almost done.


---

Comment by git created at 2020-02-19 16:05:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-02-19 16:07:35

Replying to [comment:66 dcoudert]:
> Can you update the first line of documentation (also in top table) to clarify that the method returns an out-branchin. That is remove the term spanning. Same for in-branching.
> 
> You also have to add adjust the examples (distinguish calls with `spanning=True` and `False`), and may be add other examples if needed.
> 
> Almost done.
I have ordered the examples for `spanning=True` and `False`. 
And removed the term `spanning` wherever it was unnecessary.


---

Comment by tscrim created at 2020-02-21 02:03:07

I have no additional comments.


---

Comment by dcoudert created at 2020-02-21 12:36:55

just a minor remark: a branching is by definition directed, so we can simply

```diff
-        Return an iterator over directed out branching of the current
-        ``DiGraph``.
+        Return an iterator over the out branchings of this digraph.
```


I will do more tests asap.


---

Comment by git created at 2020-02-21 12:53:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-02-22 18:32:08

I pushed a new branch with few review edits. The branch is in `public/` so you can modify it if needed. 

I have renamed the methods `out_branchings` and `in_branchings`.

If you agree with the current branch, I will then set it to positive review. Let me know.
----
New commits:


---

Comment by @vipul79321 created at 2020-02-22 19:17:13

Replying to [comment:73 dcoudert]:
> I pushed a new branch with few review edits. The branch is in `public/` so you can modify it if needed. 
> 
> I have renamed the methods `out_branchings` and `in_branchings`.
> 
> If you agree with the current branch, I will then set it to positive review. Let me know.
Yeah, It looks fine to me. 
> ----
> New commits:
> ||[d09ee74](https://git.sagemath.org/sage.git/commit?id=d09ee74d16da2f3ce15b16394ff14e98ccefe82d)||`trac #23115: Merged with 9.1.beta5`||
> ||[e2f9d69](https://git.sagemath.org/sage.git/commit?id=e2f9d69c761493ab93e353c6c451d1072467a7b9)||`trac #23115: review edit`||


---

Comment by dcoudert created at 2020-02-22 23:26:02

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2020-02-22 23:26:02

Good.


---

Comment by vbraun created at 2020-02-23 16:51:32

Resolution: fixed
