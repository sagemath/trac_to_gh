# Issue 22878: Spanning tree method for DiGraph

Issue created by migration from Trac.

Original creator: tpetiteau

Original creation time: 2017-05-31 13:14:58

CC:  tmonteil cchretien dcoudert

Keywords: spanning tree digraph

Add the method spanning_trees to the digraph class.

The method iterates through every spanning trees.
Each tree is rooted in a given vertex v and directed from v to leaves


---

Comment by tpetiteau created at 2017-06-01 07:55:18

Changing status from new to needs_review.


---

Comment by tpetiteau created at 2017-06-01 07:55:18

New commits:


---

Comment by dcoudert created at 2017-06-01 10:09:35

Hello,

I'm not sure that the term `spanning tree` is the best choice. A rooted directed spanning tree is usually called an `out-branching` in digraph theory.

I have several comments, but not enough time today. Only a few below.

To test if we can reach every other vertex from the source, you can simply do:

```
if len(list(self.depth_first_search(source))) < self.order():
    return
```



For initialization of `list_of_edges_to_keep` (and same idea in other places)

```
for i,(u,v) in enumerate(list_of_edges):
    if v != source and u != v:
        list_of_edges_to_keep.append((u, v, [i]))
```


Don't use `xrange` but `range`.

etc.


---

Comment by dcoudert created at 2017-06-01 10:09:35

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2017-06-01 10:10:09

Changing component from PLEASE CHANGE to graph theory.


---

Comment by dcoudert created at 2017-06-04 18:58:14

I think that the following solution is much better.

```
def arborescence_iterator(self, source):
    r"""
    Return an iterator over the rooted arborescences of the current ``DiGraph``.
    """
    from copy import deepcopy
    from itertools import product
    from sage.graphs.digraph import DiGraph
    
    def _arborescence_rec(D, arborescence):
        """
        """
        if arborescence.size() == self.order() - 1:
            # We have the shape of the arborescence. We iterate over the
            # combinations of labels of the multiple edges (if any).
            if multiple_edges:
                L = [[(u, v, l) for l in labels] for u,v,labels in arborescence.edges()]
                for edges in product(*L):
                    yield DiGraph(deepcopy(edges), format='list_of_edges')
            else:
                yield DiGraph(deepcopy(arborescence.edges()), format='list_of_edges')

        else:
            # 1) Pick an edge e in the out boundary of the current arborescence
            e = D.edge_boundary(arborescence.vertices())[0]

            # 2) Find all arborescences that do not contain e
            D.delete_edge(e)
            if len(list(D.depth_first_search(arborescence.vertices()))) == D.order():
                for tree in _arborescence_rec(D, arborescence): 
                    yield tree
            D.add_edge(e)
        
            # 3) Find all arborescences that do contain e
            arborescence.add_edge(e)
            for tree in _arborescence_rec(D, arborescence): 
                yield tree
            # We remove edge e and its target
            arborescence.delete_vertex(e[1])


    if not self.has_vertex(source):
        return

    # Test if the source can access to every other vertex
    if len(list(self.depth_first_search(source))) < self.order():
        return

    # We build a digraph without loops nor multiple edges, and we store the
    # labels of multiple edges.
    D = self.to_simple(to_undirected=False)
    D.delete_edges(D.incoming_edges(source))

    multiple_edges = self.has_multiple_edges()
    if multiple_edges:
        for u,v in D.edge_iterator(labels=0):
            D.set_edge_label(u, v, self.edge_label(u,v))
    
    arborescence = DiGraph()
    arborescence.add_vertex(source)
    
    return _arborescence_rec(D, arborescence)
```



---

Comment by dcoudert created at 2017-06-05 11:26:43

I pushed a proposal for this method in `public/23115`. It allows to iterate over both in and out arborescences (or branchings or directed rooted trees) [1]. If you like it you can change the branch name in this ticket.
Since the branch is in public, you are allowed to modify it if needed.
----
[1] https://en.wikipedia.org/wiki/Arborescence_(graph_theory)


---

Comment by dcoudert created at 2017-06-06 09:57:06

Let's go back to what you have proposed.

In your code, you have a complex use of indexes to cope with multi edges.

Actually, what you are doing, and this is the correct approach, is:
1. find an out-branching T in the digraph without labels
2. enumerate all possible out-branching that you can obtain from T using combinations of labels
3. goto step 1

To ease the readability of your code, I propose to proceed as follows:
1. build a data structure (a dictionary) keyed by pairs (u,v), so without labels, containing the list of labeled edges. That is, `dico[u,v] = [(u, v, label1), (u, v, label2)]`
2. find out-branchings T without labels. 
3. When you have an out-branching, enumerate all labeled out-branchings using the `product` operator and the dictionary `edge without label -> list of labeled edges`


Note that the out-branching without labels is exactly the list of the edges you have contracted.


In your code, you have chosen to contract edges. Clearly it eases the selection of the next edge to consider (you can use `graph.outgoing_edge_iterator(source)`). The drawback is that you may create loops or multiple edges, and that you have to perform many operations to deal with those edges and also undo the contractions.
You could instead maintain 2 graphs:
* The first one, G, is a copy of ``self`` without loops/multiedges/labels. On this graph you can only remove and put back the current edge
* The second one, T, is the current out-branching. So you add in it the current edge and later remove that edge.
So doing, the maintenance is much easier. You can use `G.edge_boundary(T.vertices())` to find the next edge.

Let me know if you have questions.


---

Comment by git created at 2017-06-15 16:08:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tpetiteau created at 2017-06-15 16:31:14

First of all thank you for the feedback !
\\
\\
We implemented the recommendations you made on comment 4 and stole some ideas from your solution that improved our algorithm a lot.
\\
\\
We took some time before answering because we wanted to compare both algorithms.
 
We then made some tests with different graphs (based on the following code)



```
from contextlib import contextmanager
from timeit import default_timer

`@`contextmanager
def elapsed_timer():
    start = default_timer()
    elapser = lambda: default_timer() - start
    yield lambda: elapser()
    end = default_timer()
    elapser = lambda: end-start

D = digraphs.RandomDirectedGNP(50, .08)

x = D.arborescence_iterator(0)
with elapsed_timer() as e:
    for eee in range(100000):
        x.next().size(),
print e()

x = D.spanning_trees(0)
with elapsed_timer() as e:
    for eee in range(100000):
        x.next().size(),
print e()
```


This test gives us 185 seconds for your solution and 107 seconds for ours.

So we think that the last committed version might be more suitable than your solution or the previous one.

Concerning the name of our algorithm we found a lot of article using the term "spanning tree" while other use "arborescence"; therefore we do not think it is necessary to change it.

Anyway, thanks again for your feedback it helped us a lot.


---

Comment by tpetiteau created at 2017-06-15 16:31:31

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2017-06-16 09:46:39

A first round of unordered comments:
* do not use `D.outgoing_edge_iterator(source).next()` but `next(D.outgoing_edge_iterator(source))`
* Add some details to clarify how you play with labels. It is not obvious at all
* ensure that comments are formtted in 80 columns mode. This is easy to do with some editors like emacs
* instead of using 3 lists to store edges (`out_source`, etc.), you could use a single `saved_edges` list
* to ease termination test, you could pass an argument (depth) to the `_rec_spanning_trees` method so that the final test becomes `if depth == 0:`


---

Comment by tpetiteau created at 2017-06-16 09:52:45

Changing status from needs_review to needs_work.


---

Comment by tpetiteau created at 2017-06-16 09:57:04

We will make sure to apply the modifications you suggest.

But we are not sure that we fully understand what you mean by :

 - to ease termination test, you could pass an argument (depth) to the `_rec_spanning_trees` method so that the final test becomes `if depth == 0`:

Do you want to replace `if(len(list_merged_edges)) == self.order()-1` by a test on a parameter `depth` gave to `_rec_spanning_trees` method ?


---

Comment by dcoudert created at 2017-06-16 10:00:53

Replying to [comment:14 tpetiteau]:
> We will make sure to apply the modifications you suggest.
> 
> But we are not sure that we fully understand what you mean by :
> 
>  - to ease termination test, you could pass an argument (depth) to the `_rec_spanning_trees` method so that the final test becomes `if depth == 0`:
> 
> Do you want to replace `if(len(list_merged_edges)) == self.order()-1` by a test on a parameter `depth` gave to `_rec_spanning_trees` method ?
Exactly. The first call is with `self.order()-1` and then each recursive call is with `depth-1` (or a more suitable name).


---

Comment by dcoudert created at 2017-10-21 08:55:51

any update ?


---

Comment by tpetiteau created at 2017-10-26 16:57:07

Update is coming, I got caught in personal problem and crashed my computer.

I should get time this week end to upload the last modification.


---

Comment by tmonteil created at 2018-02-04 16:13:42

ping :)


---

Comment by git created at 2020-02-13 13:56:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-02-13 13:59:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @vipul79321 created at 2020-02-13 14:05:43

Changing status from needs_work to needs_review.


---

Comment by @vipul79321 created at 2020-02-13 14:10:47

Set assignee to @vipul79321.
