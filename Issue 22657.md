# Issue 22657: Symbolic expression.is_exact()

Issue created by migration from https://trac.sagemath.org/ticket/22894

Original creator: rws

Original creation time: 2017-04-28 08:07:33

CC:  tmonteil

Expressions can contain inexact elements which makes themselves inexact. This status could be made queriable e.g. to prevent integration attempts.


---

Comment by mforets created at 2017-05-07 12:08:47

how do you approach this problem? since numeric coefficients are cast into SR which is inexact, one has: 


```
sage: f1 = x - 1
sage: [op.base_ring().is_exact() for op in f1.operands()]
[False, False]

sage: f2 = x - 1.0
sage: [op.base_ring().is_exact() for op in f2.operands()]
[False, False]
```



---

Comment by rws created at 2017-05-08 05:48:42

Apparently ring exactness can be tainted if it can possibly contain inexact elements. So we would not check the exactness of symbols/functions etc. which leaves those Python objects that are wrapped by SR (into `Expression`) and called "numeric". We can get the pure object via `Expression.pyobject()`, e.g.

```
sage: f1 = x - 1
sage: [op.is_numeric() and not op.pyobject().base_ring().is_exact() for op in f1
....: .operands()]
[False, False]
sage: f2 = x - 1.0
sage: [op.is_numeric() and not op.pyobject().base_ring().is_exact() for op in f2
....: .operands()]
[False, True]
```

But maybe not every of these rings has an `is_exact` member?


---

Comment by mforets created at 2017-05-08 17:37:25

`@`rws : nice. and one can consider more complicated expressions (fractions, etc) by recursively applying the `operands()` method to each piece (until you get []).

> But maybe not every of these rings has an is_exact member? 

I know the basic ones: (QQ, QQbar, ZZ) have `is_exact=True` while (RDF, RR, CC) give `is_exact=False`.. But Thierry has a comprehensive list so I'm CC'ing him!


---

Comment by tmonteil created at 2017-05-08 18:36:52

Regarding real and complex numbers only, basically, numerical representations are inexact:


```
RealDoubleField()
RealField(prec)
RealIntervalField(prec)
RealBallField(prec)
ComplexDoubleField()
ComplexField(prec)
ComplexIntervalField(prec)
ComplexBallField(prec)
```


Algebraic representations are exact:


```
AlgebraicRealField()
NumberField(poly)
QuadraticField(n)
RationalField()
AlgebraicField()
UniversalCyclotomicField()
CyclotomicField(n)
```


Symbolic ring is a mixture, so it is inexact.

The main problem are `RealLazyField()` and `ComplexLazyField()` which claim to be exact, but they are not:


```
sage: a = RLF(0.1)
sage: a
0.10000000000000001?
sage: a._value
0.100000000000000
sage: a._value.parent()
Real Field with 53 bits of precision
sage: RLF.is_exact()
True
```


Perhaps should we fix this.


---

Comment by tmonteil created at 2017-05-08 18:51:59

See #22960.


---

Comment by mforets created at 2017-05-25 19:57:11

`@`Thierry: that is indeed a _comprehensive_ list :0


---

Comment by mforets created at 2017-05-25 19:57:11

Changing status from new to needs_review.


---

Comment by git created at 2017-05-25 20:01:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2017-06-05 05:53:14

Changing status from needs_review to positive_review.


---

Comment by rws created at 2017-06-05 05:53:14

LGTM.


---

Comment by vbraun created at 2017-06-07 20:13:24

Resolution: fixed
