# Issue 18668: fix more leaks found in #18897

archive/issues_018668.json:
```json
{
    "body": "CC:  jmantysalo\n\nIn #18897 one leak is fixed, but there are more left, see comments 27 and later.\n\nIssue created by migration from https://trac.sagemath.org/ticket/18905\n\n",
    "created_at": "2015-07-15T10:48:57Z",
    "labels": [
        "memleak",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "fix more leaks found in #18897",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18668",
    "user": "dimpase"
}
```
CC:  jmantysalo

In #18897 one leak is fixed, but there are more left, see comments 27 and later.

Issue created by migration from https://trac.sagemath.org/ticket/18905





---

archive/issue_comments_254233.json:
```json
{
    "body": "This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.  The following simpler code exhibits a similar memory leak:\n\n```python\nimport gc                                                                                   \nfrom collections import Counter\ngc.collect()\npre = {id(c) for c in gc.get_objects()}\nfor p in prime_range(100):\n    GF(p).algebraic_closure()\ngc.collect()\npost = Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\nprint([(k,v) for (k,v) in post.iteritems() if v>10])\n```\n",
    "created_at": "2015-07-15T11:35:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254233",
    "user": "pbruin"
}
```

This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.  The following simpler code exhibits a similar memory leak:

```python
import gc                                                                                   
from collections import Counter
gc.collect()
pre = {id(c) for c in gc.get_objects()}
for p in prime_range(100):
    GF(p).algebraic_closure()
gc.collect()
post = Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
print([(k,v) for (k,v) in post.iteritems() if v>10])
```




---

archive/issue_comments_254234.json:
```json
{
    "body": "Replying to [comment:2 pbruin]:\n> This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.\n\nCircular references shouldn't be problematic, unless one of the objects involved has a `__del__` method. However:\n\n```\nsage: K = GF(5)\nsage: hasattr(K, '__del__')\nFalse\nsage: hasattr(K.algebraic_closure(), '__del__')\nFalse\n```\n\n\nAnd indeed:\n\n```\nsage: while 1:\n....:     print get_memory_usage()\n....:     for p in range(2, 102):\n....:         A = GF(nth_prime(p)).algebraic_closure()\n....:         \n<constant amount of memory>\n```\n",
    "created_at": "2015-07-15T12:14:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254234",
    "user": "SimonKing"
}
```

Replying to [comment:2 pbruin]:
> This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.

Circular references shouldn't be problematic, unless one of the objects involved has a `__del__` method. However:

```
sage: K = GF(5)
sage: hasattr(K, '__del__')
False
sage: hasattr(K.algebraic_closure(), '__del__')
False
```


And indeed:

```
sage: while 1:
....:     print get_memory_usage()
....:     for p in range(2, 102):
....:         A = GF(nth_prime(p)).algebraic_closure()
....:         
<constant amount of memory>
```




---

archive/issue_comments_254235.json:
```json
{
    "body": "Oops, that's a bad test. Of course it had a constant memory consumption even if memory could not be freed. Sorry.\n\n\n```\nsage: import gc\nsage: _ = gc.collect()\nsage: while 1:                                  \n....:     print gc.collect()\n....:     for p in range(2, 102):\n....:         A = GF(nth_prime(p)).algebraic_closure()\n....:         \n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n```\n\nThat's a leak.",
    "created_at": "2015-07-15T12:17:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254235",
    "user": "SimonKing"
}
```

Oops, that's a bad test. Of course it had a constant memory consumption even if memory could not be freed. Sorry.


```
sage: import gc
sage: _ = gc.collect()
sage: while 1:                                  
....:     print gc.collect()
....:     for p in range(2, 102):
....:         A = GF(nth_prime(p)).algebraic_closure()
....:         
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
```

That's a leak.



---

archive/issue_comments_254236.json:
```json
{
    "body": "Replying to [comment:2 pbruin]:\n> This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.  The following simpler code exhibits a similar memory leak:\n> {{{\n> #!python\n> import gc                                                                                   \n> from collections import Counter\n> gc.collect()\n> pre = {id(c) for c in gc.get_objects()}\n> for p in prime_range(100):\n>     GF(p).algebraic_closure()\n> gc.collect()\n> post = Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n> print([(k,v) for (k,v) in post.iteritems() if v>10])\n> }}}\n\nLike noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.",
    "created_at": "2015-07-15T12:19:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254236",
    "user": "slabbe"
}
```

Replying to [comment:2 pbruin]:
> This is probably because the `algebraic_closure()` method of finite fields is cached (see #14990), creating circular references between finite fields and their algebraic closures.  The following simpler code exhibits a similar memory leak:
> {{{
> #!python
> import gc                                                                                   
> from collections import Counter
> gc.collect()
> pre = {id(c) for c in gc.get_objects()}
> for p in prime_range(100):
>     GF(p).algebraic_closure()
> gc.collect()
> post = Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
> print([(k,v) for (k,v) in post.iteritems() if v>10])
> }}}

Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.



---

archive/issue_comments_254237.json:
```json
{
    "body": "And the leak indeed only occurs if we store the algebraic closure. In a freshly started session (the previous result has also been in a freshly started session):\n\n```\nsage: _ = gc.collect()\nsage: while 1:                                  \n....:     print gc.collect()\n....:     for p in range(2, 102):\n....:         A = GF(nth_prime(p))\n....:         \n0\n8396\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n7969\n```\n",
    "created_at": "2015-07-15T12:19:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254237",
    "user": "SimonKing"
}
```

And the leak indeed only occurs if we store the algebraic closure. In a freshly started session (the previous result has also been in a freshly started session):

```
sage: _ = gc.collect()
sage: while 1:                                  
....:     print gc.collect()
....:     for p in range(2, 102):
....:         A = GF(nth_prime(p))
....:         
0
8396
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
7969
```




---

archive/issue_comments_254238.json:
```json
{
    "body": "> Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.\n\n...ok, but that's the same thing for the bug presented in the description of the ticket. Sorry.",
    "created_at": "2015-07-15T12:21:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254238",
    "user": "slabbe"
}
```

> Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.

...ok, but that's the same thing for the bug presented in the description of the ticket. Sorry.



---

archive/issue_comments_254239.json:
```json
{
    "body": "Replying to [comment:5 slabbe]:\n> Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.\n\nThat's just because there is only one base ring. Do the same while iterating over `GF(p)`, and you'll see how things accumulate.\n\nAt #18897, a binary tree was duely deallocated, however it was forgotten to dereference the root node. But here, we have objects that could be deallocated, but aren't. It is a totally different kind of leak.",
    "created_at": "2015-07-15T12:23:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254239",
    "user": "SimonKing"
}
```

Replying to [comment:5 slabbe]:
> Like noticed in #18897, when this code is runned the first time, there are many stuff left. But the second time, the list is empty.

That's just because there is only one base ring. Do the same while iterating over `GF(p)`, and you'll see how things accumulate.

At #18897, a binary tree was duely deallocated, however it was forgotten to dereference the root node. But here, we have objects that could be deallocated, but aren't. It is a totally different kind of leak.



---

archive/issue_comments_254240.json:
```json
{
    "body": "Reference chain to finite field after creating its algebraic closure",
    "created_at": "2015-07-15T12:39:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254240",
    "user": "SimonKing"
}
```

Reference chain to finite field after creating its algebraic closure



---

archive/issue_comments_254241.json:
```json
{
    "body": "Attachment [test.png](tarball://root/attachments/some-uuid/ticket18905/test.png) by SimonKing created at 2015-07-15 12:42:26\n\nattachment:test.png results from the following code:\n\n```\nsage: import objgraph, gc\nsage: K = GF(31)\nsage: n = id(K)\nsage: A = K.algebraic_closure()\nsage: del A,K\nsage: gc.collect()\n0\nsage: L = [c for c in gc.get_objects() if id(c)==n]\nsage: objgraph.show_backrefs(L[0],filename=\"/home/king/Sage/work/memleak/test.png\")\nGraph written to /tmp/objgraph-r5RhSM.dot (21 nodes)\nImage generated as /home/king/Sage/work/memleak/test.png\n```\n\n\nApparently (since all other references are weak or circular), the references that prevent deallocation come from `sage.rings.finite_rings.integer_mod.NativeIntStruct`.",
    "created_at": "2015-07-15T12:42:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254241",
    "user": "SimonKing"
}
```

Attachment [test.png](tarball://root/attachments/some-uuid/ticket18905/test.png) by SimonKing created at 2015-07-15 12:42:26

attachment:test.png results from the following code:

```
sage: import objgraph, gc
sage: K = GF(31)
sage: n = id(K)
sage: A = K.algebraic_closure()
sage: del A,K
sage: gc.collect()
0
sage: L = [c for c in gc.get_objects() if id(c)==n]
sage: objgraph.show_backrefs(L[0],filename="/home/king/Sage/work/memleak/test.png")
Graph written to /tmp/objgraph-r5RhSM.dot (21 nodes)
Image generated as /home/king/Sage/work/memleak/test.png
```


Apparently (since all other references are weak or circular), the references that prevent deallocation come from `sage.rings.finite_rings.integer_mod.NativeIntStruct`.



---

archive/issue_comments_254242.json:
```json
{
    "body": "It seems that there is a NativeIntStruct created for each finite field. If the NativeIntStruct is small enough, then it has a (multiplication?) table, which holds references to all elements of the finite field. And they have, of course, references to their parent. But what is referencing the NativeIntStruct?",
    "created_at": "2015-07-15T12:51:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254242",
    "user": "SimonKing"
}
```

It seems that there is a NativeIntStruct created for each finite field. If the NativeIntStruct is small enough, then it has a (multiplication?) table, which holds references to all elements of the finite field. And they have, of course, references to their parent. But what is referencing the NativeIntStruct?



---

archive/issue_comments_254243.json:
```json
{
    "body": "It seems that the reference somehow comes from constructing the algebraic closure, as we have\n\n```\nsage: K = GF(31)\nsage: del K\nsage: L = [c for c in gc.get_objects() if isinstance(c, sage.rings.finite_rings.integer_mod.NativeIntStruct) and len(c._get_table())==31]\nsage: len(L)\n0\n```\n\nSo, the NativeIntStruct can be garbage collected when we do not construct the algebraic closure.\n\nHow can one find a reference chain from the algebraic closure to the NativeIntStruct?",
    "created_at": "2015-07-15T13:03:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254243",
    "user": "SimonKing"
}
```

It seems that the reference somehow comes from constructing the algebraic closure, as we have

```
sage: K = GF(31)
sage: del K
sage: L = [c for c in gc.get_objects() if isinstance(c, sage.rings.finite_rings.integer_mod.NativeIntStruct) and len(c._get_table())==31]
sage: len(L)
0
```

So, the NativeIntStruct can be garbage collected when we do not construct the algebraic closure.

How can one find a reference chain from the algebraic closure to the NativeIntStruct?



---

archive/issue_comments_254244.json:
```json
{
    "body": "Another reference chain, towards NativeIntStruct",
    "created_at": "2015-07-15T13:04:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254244",
    "user": "SimonKing"
}
```

Another reference chain, towards NativeIntStruct



---

archive/issue_comments_254245.json:
```json
{
    "body": "Attachment [test2.png](tarball://root/attachments/some-uuid/ticket18905/test2.png) by SimonKing created at 2015-07-15 13:10:00\n\nattachment:test2.png shows the result of\n\n```\nsage: K = GF(31)\nsage: A = K.algebraic_closure()\nsage: del A,K\nsage: L = [c for c in gc.get_objects() if isinstance(c, sage.rings.finite_rings.integer_mod.NativeIntStruct) and len(c._get_table())==31]\nsage: filter = lambda x: (x is not L) and (not isinstance(x, sage.rings.finite_rings.integer_mod.IntegerMod_int))\nsage: objgraph.show_backrefs(L[0],filter=filter,filename=\"/home/king/Sage/work/memleak/test2.png\")\nGraph written to /tmp/objgraph-4qP1R3.dot (16 nodes)\nImage generated as /home/king/Sage/work/memleak/test2.png\n```\n\n\nThe picture somehow looks familiar: There is a coerce map involved, namely !Int_to_IntegerMod. Coerce maps are supposed to have a weak reference to the domain and a strong reference to the codomain. Since the domain of !Int_to_IntegerMod presumably is the ring of integers and can't be deallocated anyway, a strong reference to the codomain means trouble...",
    "created_at": "2015-07-15T13:10:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254245",
    "user": "SimonKing"
}
```

Attachment [test2.png](tarball://root/attachments/some-uuid/ticket18905/test2.png) by SimonKing created at 2015-07-15 13:10:00

attachment:test2.png shows the result of

```
sage: K = GF(31)
sage: A = K.algebraic_closure()
sage: del A,K
sage: L = [c for c in gc.get_objects() if isinstance(c, sage.rings.finite_rings.integer_mod.NativeIntStruct) and len(c._get_table())==31]
sage: filter = lambda x: (x is not L) and (not isinstance(x, sage.rings.finite_rings.integer_mod.IntegerMod_int))
sage: objgraph.show_backrefs(L[0],filter=filter,filename="/home/king/Sage/work/memleak/test2.png")
Graph written to /tmp/objgraph-4qP1R3.dot (16 nodes)
Image generated as /home/king/Sage/work/memleak/test2.png
```


The picture somehow looks familiar: There is a coerce map involved, namely !Int_to_IntegerMod. Coerce maps are supposed to have a weak reference to the domain and a strong reference to the codomain. Since the domain of !Int_to_IntegerMod presumably is the ring of integers and can't be deallocated anyway, a strong reference to the codomain means trouble...



---

archive/issue_comments_254246.json:
```json
{
    "body": "I was also playing with objgraph...\n\n```python\ndef test(L, dim):\n    import objgraph\n    import gc\n    from collections import Counter\n    gc.collect()\n    pre={id(c) for c in gc.get_objects()}\n    m = matrix(dim, L)\n    for p in range(2,102):\n        m.change_ring(GF(nth_prime(p))).eigenvalues()\n    gc.collect()\n    O = gc.get_objects()\n    post=Counter(type(o) for o in O if id(o) not in pre)\n    T = [k for (k,v) in post.iteritems() if v==100]\n    D = dict((type(o),o) for o in O if type(o) in T)\n    for i,v in enumerate(sorted(D.values())):\n        print v\n        objgraph.show_backrefs(v,filename=\"test_{}.png\".format(i))\n        print \"--\"\n```\n\nI get :\n\n```\nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: test(L, 5)\nPrincipal ideal (547) of Integer Ring\nGraph written to /tmp/objgraph-e803N8.dot (20 nodes)\nImage generated as test_0.png\n--\nSet of Homomorphisms from Integer Ring to Finite Field of size 181\nGraph written to /tmp/objgraph-I_uL5V.dot (12 nodes)\nImage generated as test_1.png\n--\n<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>\nGraph written to /tmp/objgraph-oMuwMY.dot (13 nodes)\nImage generated as test_2.png\n--\nAlgebraic closure of Finite Field of size 181\nGraph written to /tmp/objgraph-M_9gmt.dot (14 nodes)\nImage generated as test_3.png\n--\nFinite Field of size 547\nGraph written to /tmp/objgraph-ZostIO.dot (25 nodes)\nImage generated as test_4.png\n--\nSet of Homomorphisms from Finite Field of size 181 to Univariate Polynomial Ring in x over Finite Field of size 181\nGraph written to /tmp/objgraph-diDGKn.dot (12 nodes)\nImage generated as test_5.png\n--\n<sage.rings.finite_rings.integer_mod.NativeIntStruct object at 0x7f366d1e3590>\nGraph written to /tmp/objgraph-JxmEbJ.dot (30 nodes)\nImage generated as test_6.png\n--\n```\n\nI will attach test_3.png for the algebraic closure right now.",
    "created_at": "2015-07-15T13:58:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254246",
    "user": "slabbe"
}
```

I was also playing with objgraph...

```python
def test(L, dim):
    import objgraph
    import gc
    from collections import Counter
    gc.collect()
    pre={id(c) for c in gc.get_objects()}
    m = matrix(dim, L)
    for p in range(2,102):
        m.change_ring(GF(nth_prime(p))).eigenvalues()
    gc.collect()
    O = gc.get_objects()
    post=Counter(type(o) for o in O if id(o) not in pre)
    T = [k for (k,v) in post.iteritems() if v==100]
    D = dict((type(o),o) for o in O if type(o) in T)
    for i,v in enumerate(sorted(D.values())):
        print v
        objgraph.show_backrefs(v,filename="test_{}.png".format(i))
        print "--"
```

I get :

```
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: test(L, 5)
Principal ideal (547) of Integer Ring
Graph written to /tmp/objgraph-e803N8.dot (20 nodes)
Image generated as test_0.png
--
Set of Homomorphisms from Integer Ring to Finite Field of size 181
Graph written to /tmp/objgraph-I_uL5V.dot (12 nodes)
Image generated as test_1.png
--
<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>
Graph written to /tmp/objgraph-oMuwMY.dot (13 nodes)
Image generated as test_2.png
--
Algebraic closure of Finite Field of size 181
Graph written to /tmp/objgraph-M_9gmt.dot (14 nodes)
Image generated as test_3.png
--
Finite Field of size 547
Graph written to /tmp/objgraph-ZostIO.dot (25 nodes)
Image generated as test_4.png
--
Set of Homomorphisms from Finite Field of size 181 to Univariate Polynomial Ring in x over Finite Field of size 181
Graph written to /tmp/objgraph-diDGKn.dot (12 nodes)
Image generated as test_5.png
--
<sage.rings.finite_rings.integer_mod.NativeIntStruct object at 0x7f366d1e3590>
Graph written to /tmp/objgraph-JxmEbJ.dot (30 nodes)
Image generated as test_6.png
--
```

I will attach test_3.png for the algebraic closure right now.



---

archive/issue_comments_254247.json:
```json
{
    "body": "Ref graph for Algebraic closure of Finite Field of size 181",
    "created_at": "2015-07-15T14:00:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254247",
    "user": "slabbe"
}
```

Ref graph for Algebraic closure of Finite Field of size 181



---

archive/issue_comments_254248.json:
```json
{
    "body": "Attachment [test_3.png](tarball://root/attachments/some-uuid/ticket18905/test_3.png) by SimonKing created at 2015-07-15 20:52:13\n\nLet me try to recall why the current \"weak-referencing coerce maps\" are made as they are, to understand why we have a strong reference chain to `Int_to_IntegerMod`.\n\n- We have a backtracking algorithm to find coerce maps by transitivity of \"registered\" coerce maps. Hence, registered coerce maps need to be stored in the codomain.\n- Since the maps are stored in a container that is stored as an attribute of the codomain, there is a strong reference chain from the codomain to the coerce map.\n- A strong reference to the codomain should not prevent the domain from garbage collection. Hence, IN COERCION, we use a weak reference from the map to the domain, and we cut the reference from the map to its parent.\n- A strong reference to the domain should not prevent the codomain from garbage collection. That's what seems to fail in the current example.\n\nWhat I do not understand: Why is that more than a strong reference CYCLE (which would not prevent garbage collection) from the codomain to the map and back?",
    "created_at": "2015-07-15T20:52:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254248",
    "user": "SimonKing"
}
```

Attachment [test_3.png](tarball://root/attachments/some-uuid/ticket18905/test_3.png) by SimonKing created at 2015-07-15 20:52:13

Let me try to recall why the current "weak-referencing coerce maps" are made as they are, to understand why we have a strong reference chain to `Int_to_IntegerMod`.

- We have a backtracking algorithm to find coerce maps by transitivity of "registered" coerce maps. Hence, registered coerce maps need to be stored in the codomain.
- Since the maps are stored in a container that is stored as an attribute of the codomain, there is a strong reference chain from the codomain to the coerce map.
- A strong reference to the codomain should not prevent the domain from garbage collection. Hence, IN COERCION, we use a weak reference from the map to the domain, and we cut the reference from the map to its parent.
- A strong reference to the domain should not prevent the codomain from garbage collection. That's what seems to fail in the current example.

What I do not understand: Why is that more than a strong reference CYCLE (which would not prevent garbage collection) from the codomain to the map and back?



---

archive/issue_comments_254249.json:
```json
{
    "body": "Aha. The coercion model caches the coerce maps, too. So, it isn't the codomain only that holds a cache.\n\nThe coercion model is of course a permanent object. It references a `TripleDict` to store the coercion maps. The coercion map references the codomain. Hence, if the domain is strongly referenced from somewhere, then the coerce map and thus the codomain can not be garbage collected.\n\nCan we perhaps make it so that the cache in the coercion model only keeps a WEAK reference to the coerce map? I worry about performance, though, since getting the referenced object from a weak reference is a bit costly.\n\nDo we need to worry about premature collection of coerce map? If I understand correctly, the cache in the coercion model is mainly for performance, as the map is cached as an attribute of the codomain anyway. And the codomain of any map is a parent. Hence, the cache of the coercion model actually is redundant.\n\nSo, perhaps a better idea is to completely get rid of the coercion model cache, as the coercion model can use the codomain's cache. I'll try that.",
    "created_at": "2015-07-15T21:14:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254249",
    "user": "SimonKing"
}
```

Aha. The coercion model caches the coerce maps, too. So, it isn't the codomain only that holds a cache.

The coercion model is of course a permanent object. It references a `TripleDict` to store the coercion maps. The coercion map references the codomain. Hence, if the domain is strongly referenced from somewhere, then the coerce map and thus the codomain can not be garbage collected.

Can we perhaps make it so that the cache in the coercion model only keeps a WEAK reference to the coerce map? I worry about performance, though, since getting the referenced object from a weak reference is a bit costly.

Do we need to worry about premature collection of coerce map? If I understand correctly, the cache in the coercion model is mainly for performance, as the map is cached as an attribute of the codomain anyway. And the codomain of any map is a parent. Hence, the cache of the coercion model actually is redundant.

So, perhaps a better idea is to completely get rid of the coercion model cache, as the coercion model can use the codomain's cache. I'll try that.



---

archive/issue_comments_254250.json:
```json
{
    "body": "No, the coercion model's cache is needed. It is relevant for pushouts. There, we have no codomain, as it first needs to be constructed.",
    "created_at": "2015-07-15T21:17:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254250",
    "user": "SimonKing"
}
```

No, the coercion model's cache is needed. It is relevant for pushouts. There, we have no codomain, as it first needs to be constructed.



---

archive/issue_comments_254251.json:
```json
{
    "body": "Perhaps my diagnosis was wrong: It is not relevant for pushouts, but we want to cache the ABSENCE of a coercion from a parent to, say, `int`. So, if the codomain happens to be a parent then we can use its cache; otherwise there is no problem to use the coercion model's cache since `int` and friends will never be garbage collected anyway.\n\nSo, better not use weak references to coercion maps...",
    "created_at": "2015-07-15T21:54:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254251",
    "user": "SimonKing"
}
```

Perhaps my diagnosis was wrong: It is not relevant for pushouts, but we want to cache the ABSENCE of a coercion from a parent to, say, `int`. So, if the codomain happens to be a parent then we can use its cache; otherwise there is no problem to use the coercion model's cache since `int` and friends will never be garbage collected anyway.

So, better not use weak references to coercion maps...



---

archive/issue_comments_254252.json:
```json
{
    "body": "It seems that #14058 is relevant -- and perhaps it fixes our problem (except that it has no branch).",
    "created_at": "2015-07-16T19:44:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254252",
    "user": "SimonKing"
}
```

It seems that #14058 is relevant -- and perhaps it fixes our problem (except that it has no branch).



---

archive/issue_comments_254253.json:
```json
{
    "body": "I am afraid that #14058 (which now has a branch) does not suffice to fix the problem: GF(31) still can't be collected after creating its algebraic closure. However, the coercion model is not mentioned any longer. Instead, the reference goes via a weak value dictionary, which seems to be the polynomial ring cache.\n\nMy guess:\n- There is some polynomial ring P over the base ring GF(31) that was constructed when creating the algebraic closure of GF(31).\n- There is only a weak reference to P from the polynomial ring cache (it is weak value dictionary). However, for a different reason there is a strong reference to P.\n- Hence, the entry for P in the weak value dictionary can not be freed. By consequence, the reference to the KEY of this entry, which is a STRONG reference to GF(31), can not be freed.\n- Thus, GF(31) can not be deallocated.\n\nThe question is: How is there a strong reference to P? Perhaps there is a strong reference from GF(31) to P? Maybe via caching the algebraic closure, which references an element of P? This would be enough to keep P alive.",
    "created_at": "2015-07-16T23:05:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254253",
    "user": "SimonKing"
}
```

I am afraid that #14058 (which now has a branch) does not suffice to fix the problem: GF(31) still can't be collected after creating its algebraic closure. However, the coercion model is not mentioned any longer. Instead, the reference goes via a weak value dictionary, which seems to be the polynomial ring cache.

My guess:
- There is some polynomial ring P over the base ring GF(31) that was constructed when creating the algebraic closure of GF(31).
- There is only a weak reference to P from the polynomial ring cache (it is weak value dictionary). However, for a different reason there is a strong reference to P.
- Hence, the entry for P in the weak value dictionary can not be freed. By consequence, the reference to the KEY of this entry, which is a STRONG reference to GF(31), can not be freed.
- Thus, GF(31) can not be deallocated.

The question is: How is there a strong reference to P? Perhaps there is a strong reference from GF(31) to P? Maybe via caching the algebraic closure, which references an element of P? This would be enough to keep P alive.



---

archive/issue_comments_254254.json:
```json
{
    "body": "I tried to find a backref chain as follows:\n\n```\nsage: import objgraph, gc, __main__\nsage: K = GF(31)\nsage: A = K.algebraic_closure()\nsage: nK = id(K)\nsage: del A,K\nsage: L = [c for c in gc.get_objects() if id(c) == nK]\nsage: objgraph.find_backref_chain(L[0], lambda x: x in __main__.__dict__.values(), extra_ignore=(id(L),))\n```\n\nbut it crashes with a segfault. Any idea why it fails?",
    "created_at": "2015-07-18T20:28:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254254",
    "user": "SimonKing"
}
```

I tried to find a backref chain as follows:

```
sage: import objgraph, gc, __main__
sage: K = GF(31)
sage: A = K.algebraic_closure()
sage: nK = id(K)
sage: del A,K
sage: L = [c for c in gc.get_objects() if id(c) == nK]
sage: objgraph.find_backref_chain(L[0], lambda x: x in __main__.__dict__.values(), extra_ignore=(id(L),))
```

but it crashes with a segfault. Any idea why it fails?



---

archive/issue_comments_254255.json:
```json
{
    "body": "And this one\n\n```\nsage: import objgraph, gc\nsage: cm = sage.structure.element.get_coercion_model()\nsage: K = GF(31)\nsage: A = K.algebraic_closure()\nsage: nK = id(K)\nsage: del A,K\nsage: gc.collect()\n0\nsage: L = [c for c in gc.get_objects() if id(c) == nK]\nsage: objgraph.find_backref_chain(L[0], lambda x: x is cm, extra_ignore=(id(L),))\n```\n\ndoesn't finish after several minutes.",
    "created_at": "2015-07-18T20:35:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254255",
    "user": "SimonKing"
}
```

And this one

```
sage: import objgraph, gc
sage: cm = sage.structure.element.get_coercion_model()
sage: K = GF(31)
sage: A = K.algebraic_closure()
sage: nK = id(K)
sage: del A,K
sage: gc.collect()
0
sage: L = [c for c in gc.get_objects() if id(c) == nK]
sage: objgraph.find_backref_chain(L[0], lambda x: x is cm, extra_ignore=(id(L),))
```

doesn't finish after several minutes.



---

archive/issue_comments_254256.json:
```json
{
    "body": "I get pretty good plots from\n\n```\nobjgraph.show_backrefs(L,filename='plot.png',max_depth=5)\n```\n\nIt seems a global link exists here:\n\n```\nsage: [a for a in sage.rings.polynomial.polynomial_ring_constructor.__dict__['_cache'].keys() if id(a[0]) == id(L[0])]\n[(Finite Field of size 31, ('x',), False, None),\n (Finite Field of size 31, ('x',), False, 'FLINT')]\n```\n",
    "created_at": "2015-07-18T21:00:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254256",
    "user": "nbruin"
}
```

I get pretty good plots from

```
objgraph.show_backrefs(L,filename='plot.png',max_depth=5)
```

It seems a global link exists here:

```
sage: [a for a in sage.rings.polynomial.polynomial_ring_constructor.__dict__['_cache'].keys() if id(a[0]) == id(L[0])]
[(Finite Field of size 31, ('x',), False, None),
 (Finite Field of size 31, ('x',), False, 'FLINT')]
```




---

archive/issue_comments_254257.json:
```json
{
    "body": "Replying to [comment:23 nbruin]:\n> I get pretty good plots from\n> {{{\n> objgraph.show_backrefs(L,filename='plot.png',max_depth=5)\n> }}}\n\nAhm, L?? That's a list.\n\n> It seems a global link exists here:\n> {{{\n> sage: [a for a in sage.rings.polynomial.polynomial_ring_constructor.__dict__['_cache'].keys() if id(a[0]) == id(L[0])]\n> [(Finite Field of size 31, ('x',), False, None),\n>  (Finite Field of size 31, ('x',), False, 'FLINT')]\n> }}}\n\nOf course. As long as `P=GF(31)['x']` lives, its base ring will live, too. The question is why the polynomial ring can't be collected. So, perhaps it would be better to try and find a chain for the polynomial ring instead.",
    "created_at": "2015-07-18T21:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254257",
    "user": "SimonKing"
}
```

Replying to [comment:23 nbruin]:
> I get pretty good plots from
> {{{
> objgraph.show_backrefs(L,filename='plot.png',max_depth=5)
> }}}

Ahm, L?? That's a list.

> It seems a global link exists here:
> {{{
> sage: [a for a in sage.rings.polynomial.polynomial_ring_constructor.__dict__['_cache'].keys() if id(a[0]) == id(L[0])]
> [(Finite Field of size 31, ('x',), False, None),
>  (Finite Field of size 31, ('x',), False, 'FLINT')]
> }}}

Of course. As long as `P=GF(31)['x']` lives, its base ring will live, too. The question is why the polynomial ring can't be collected. So, perhaps it would be better to try and find a chain for the polynomial ring instead.



---

archive/issue_comments_254258.json:
```json
{
    "body": "Backref graph for a polynomial ring over finite field",
    "created_at": "2015-07-18T21:37:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254258",
    "user": "SimonKing"
}
```

Backref graph for a polynomial ring over finite field



---

archive/issue_comments_254259.json:
```json
{
    "body": "Attachment [test_P_14058.png](tarball://root/attachments/some-uuid/ticket18905/test_P_14058.png) by SimonKing created at 2015-07-18 21:38:21\n\nattachment:test_P_14058.png is interesting. It seems that the reference chain to the polynomial ring is via TRACEBACKS! The question then arises: Why are the tracebacks not garbage collected?",
    "created_at": "2015-07-18T21:38:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254259",
    "user": "SimonKing"
}
```

Attachment [test_P_14058.png](tarball://root/attachments/some-uuid/ticket18905/test_P_14058.png) by SimonKing created at 2015-07-18 21:38:21

attachment:test_P_14058.png is interesting. It seems that the reference chain to the polynomial ring is via TRACEBACKS! The question then arises: Why are the tracebacks not garbage collected?



---

archive/issue_comments_254260.json:
```json
{
    "body": "Replying to [comment:24 SimonKing]:\n> Of course. As long as `P=GF(31)['x']` lives, its base ring will live, too. The question is why the polynomial ring can't be collected. So, perhaps it would be better to try and find a chain for the polynomial ring instead.\n\nOK, the finite field caches under `algebraic_closure` in its dict a `CachedMethodCaller` that references a `PseudoConwayLattice` object that in its `__dict__` has a ring that is the polynomial ring. That's a reference chain from the finite field to the polynomial ring, preventing the polynomial ring from being deallocated.",
    "created_at": "2015-07-18T21:38:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254260",
    "user": "nbruin"
}
```

Replying to [comment:24 SimonKing]:
> Of course. As long as `P=GF(31)['x']` lives, its base ring will live, too. The question is why the polynomial ring can't be collected. So, perhaps it would be better to try and find a chain for the polynomial ring instead.

OK, the finite field caches under `algebraic_closure` in its dict a `CachedMethodCaller` that references a `PseudoConwayLattice` object that in its `__dict__` has a ring that is the polynomial ring. That's a reference chain from the finite field to the polynomial ring, preventing the polynomial ring from being deallocated.



---

archive/issue_comments_254261.json:
```json
{
    "body": "Oops. I see that the chain goes via objgraph. So, I guess the new attachment is worthless.",
    "created_at": "2015-07-18T21:39:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254261",
    "user": "SimonKing"
}
```

Oops. I see that the chain goes via objgraph. So, I guess the new attachment is worthless.



---

archive/issue_comments_254262.json:
```json
{
    "body": "Replying to [comment:26 nbruin]:\n> OK, the finite field caches under `algebraic_closure` in its dict a `CachedMethodCaller` that references a `PseudoConwayLattice` object that in its `__dict__` has a ring that is the polynomial ring. That's a reference chain from the finite field to the polynomial ring, preventing the polynomial ring from being deallocated. \n\nAnd, by comment:19, it prevents the base ring from collection, because it is not simply a cyclic reference, but a strong reference from a weak value dictionary to one of its keys.",
    "created_at": "2015-07-18T21:44:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254262",
    "user": "SimonKing"
}
```

Replying to [comment:26 nbruin]:
> OK, the finite field caches under `algebraic_closure` in its dict a `CachedMethodCaller` that references a `PseudoConwayLattice` object that in its `__dict__` has a ring that is the polynomial ring. That's a reference chain from the finite field to the polynomial ring, preventing the polynomial ring from being deallocated. 

And, by comment:19, it prevents the base ring from collection, because it is not simply a cyclic reference, but a strong reference from a weak value dictionary to one of its keys.



---

archive/issue_comments_254263.json:
```json
{
    "body": "Why does the CachedMethodCaller reference a PseudoConwayLattice? Shouldn't it \"only\" reference the return value?",
    "created_at": "2015-07-18T21:52:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254263",
    "user": "SimonKing"
}
```

Why does the CachedMethodCaller reference a PseudoConwayLattice? Shouldn't it "only" reference the return value?



---

archive/issue_comments_254264.json:
```json
{
    "body": "Replying to [comment:29 SimonKing]:\n> Why does the CachedMethodCaller reference a PseudoConwayLattice? Shouldn't it \"only\" reference the return value?\n\nI see. The algebraic closure itself references the PseudoConwayLattice.\n\nHm. At some point we should use a weak reference. Maybe right here.",
    "created_at": "2015-07-18T21:55:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254264",
    "user": "SimonKing"
}
```

Replying to [comment:29 SimonKing]:
> Why does the CachedMethodCaller reference a PseudoConwayLattice? Shouldn't it "only" reference the return value?

I see. The algebraic closure itself references the PseudoConwayLattice.

Hm. At some point we should use a weak reference. Maybe right here.



---

archive/issue_comments_254265.json:
```json
{
    "body": "The lattice that is stored in the algebraic closure is either passed as an argument to the init method, or is constructed during init:\n\n```python\n    def __init__(self, base_ring, name, category=None, lattice=None, use_database=True):\n        if not (is_FiniteField(base_ring) and base_ring.is_prime_field()):\n            raise NotImplementedError('algebraic closures of finite fields are only implemented for prime fields')\n        from sage.rings.finite_rings.conway_polynomials import PseudoConwayLattice\n        p = base_ring.characteristic()\n        if lattice is None:\n            lattice = PseudoConwayLattice(p, use_database)\n        elif not isinstance(lattice, PseudoConwayLattice) or lattice.p != p:\n            raise TypeError('lattice must be a pseudo-Conway lattice with characteristic %s' % p)\n        self._pseudo_conway_lattice = lattice\n        AlgebraicClosureFiniteField_generic.__init__(self, base_ring, name, category)\n```\n\n\nThat's a dilemma. If \"lattice\" is not passed as an argument, it is no problem to weakly reference it, as it can be reconstructed, should it be garbage collected. But otherwise? Hm.",
    "created_at": "2015-07-18T22:05:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254265",
    "user": "SimonKing"
}
```

The lattice that is stored in the algebraic closure is either passed as an argument to the init method, or is constructed during init:

```python
    def __init__(self, base_ring, name, category=None, lattice=None, use_database=True):
        if not (is_FiniteField(base_ring) and base_ring.is_prime_field()):
            raise NotImplementedError('algebraic closures of finite fields are only implemented for prime fields')
        from sage.rings.finite_rings.conway_polynomials import PseudoConwayLattice
        p = base_ring.characteristic()
        if lattice is None:
            lattice = PseudoConwayLattice(p, use_database)
        elif not isinstance(lattice, PseudoConwayLattice) or lattice.p != p:
            raise TypeError('lattice must be a pseudo-Conway lattice with characteristic %s' % p)
        self._pseudo_conway_lattice = lattice
        AlgebraicClosureFiniteField_generic.__init__(self, base_ring, name, category)
```


That's a dilemma. If "lattice" is not passed as an argument, it is no problem to weakly reference it, as it can be reconstructed, should it be garbage collected. But otherwise? Hm.



---

archive/issue_comments_254266.json:
```json
{
    "body": "I think I know a potential solution.\n\nThe problem, by the above analysis: The polynomial ring cache is a weak value dictionary. Generally, a strong reference chain from key to value will prevent garbage collection of the key-value pair.\n\nI suggest to remove the \"global\" polynomial ring cache. Instead, I suggest that the polynomial ring constructor uses a weak value dictionary that is stored as an attribute of the base ring (e.g., in `self.__cached_methods`, which is available for all parents).\n\nThe weakly referenced values are polynomial rings. The keys are the list of variable names and information on term order and implementation---so, strong references to them shouldn't be problematic.\n\nIn that model, a strong reference chain from the base ring to the polynomial ring would NOT prevent garbage collection, since in the worst case it is a reference cycle (base ring <-> polynomial ring).",
    "created_at": "2015-07-18T22:43:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254266",
    "user": "SimonKing"
}
```

I think I know a potential solution.

The problem, by the above analysis: The polynomial ring cache is a weak value dictionary. Generally, a strong reference chain from key to value will prevent garbage collection of the key-value pair.

I suggest to remove the "global" polynomial ring cache. Instead, I suggest that the polynomial ring constructor uses a weak value dictionary that is stored as an attribute of the base ring (e.g., in `self.__cached_methods`, which is available for all parents).

The weakly referenced values are polynomial rings. The keys are the list of variable names and information on term order and implementation---so, strong references to them shouldn't be problematic.

In that model, a strong reference chain from the base ring to the polynomial ring would NOT prevent garbage collection, since in the worst case it is a reference cycle (base ring <-> polynomial ring).



---

archive/issue_comments_254267.json:
```json
{
    "body": "Hooray! With that change, I get\n\n```\nsage: import objgraph, gc\nsage: K = GF(31)\nsage: A = K.algebraic_closure()\nsage: n = id(K)\nsage: del A,K\nsage: gc.collect()\n186\nsage: L = [c for c in gc.get_objects() if id(c) == n]\nsage: L\n[]\n```\n",
    "created_at": "2015-07-18T22:58:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254267",
    "user": "SimonKing"
}
```

Hooray! With that change, I get

```
sage: import objgraph, gc
sage: K = GF(31)
sage: A = K.algebraic_closure()
sage: n = id(K)
sage: del A,K
sage: gc.collect()
186
sage: L = [c for c in gc.get_objects() if id(c) == n]
sage: L
[]
```




---

archive/issue_comments_254268.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-07-19T06:31:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254268",
    "user": "SimonKing"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_254269.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2015-07-19T06:31:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254269",
    "user": "SimonKing"
}
```

Last 10 new commits:



---

archive/issue_comments_254270.json:
```json
{
    "body": "To my slight surprise, replacing the global polynomial ring cache by a local cache did not only solve the issue tracked here, but it did not introduce a new problem: With the attached branch, all tests should pass.\n\nI have reviewed most part of #14058, but I think someone should have a look at my additions (review patch) there and finish the review.",
    "created_at": "2015-07-19T06:35:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254270",
    "user": "SimonKing"
}
```

To my slight surprise, replacing the global polynomial ring cache by a local cache did not only solve the issue tracked here, but it did not introduce a new problem: With the attached branch, all tests should pass.

I have reviewed most part of #14058, but I think someone should have a look at my additions (review patch) there and finish the review.



---

archive/issue_comments_254271.json:
```json
{
    "body": "From the patchbot\n\n```\nsage -t --long src/sage/structure/coerce.pyx\n**********************************************************************\nFile \"src/sage/structure/coerce.pyx\", line 1307, in sage.structure.coerce.CoercionModel_cache_maps.coercion_maps\nFailed example:\n    print N2-N0\nExpected:\n    0\nGot:\n    -1\n```\n\nIs it what we should get?",
    "created_at": "2015-08-10T09:58:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254271",
    "user": "vdelecroix"
}
```

From the patchbot

```
sage -t --long src/sage/structure/coerce.pyx
**********************************************************************
File "src/sage/structure/coerce.pyx", line 1307, in sage.structure.coerce.CoercionModel_cache_maps.coercion_maps
Failed example:
    print N2-N0
Expected:
    0
Got:
    -1
```

Is it what we should get?



---

archive/issue_comments_254272.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-10T09:58:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254272",
    "user": "vdelecroix"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_254273.json:
```json
{
    "body": "Replying to [comment:37 vdelecroix]:\n> From the patchbot\n> ...\n> Is it what we should get?\n\nNote that the same error appears at #14058, even though the commits from here are not part of #14058, if I see that correctly.\n\nCould someone verify if it is really the case that tests pass with \"develop\", but fail with the branch from here (merged in \"develop\" of course)? I currently do not have the bandwidth.",
    "created_at": "2015-08-10T11:56:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254273",
    "user": "SimonKing"
}
```

Replying to [comment:37 vdelecroix]:
> From the patchbot
> ...
> Is it what we should get?

Note that the same error appears at #14058, even though the commits from here are not part of #14058, if I see that correctly.

Could someone verify if it is really the case that tests pass with "develop", but fail with the branch from here (merged in "develop" of course)? I currently do not have the bandwidth.



---

archive/issue_comments_254274.json:
```json
{
    "body": "Replying to [comment:38 SimonKing]:\n> Replying to [comment:37 vdelecroix]:\n> Could someone verify if it is really the case that tests pass with \"develop\", but fail with the branch from here (merged in \"develop\" of course)? I currently do not have the bandwidth.\n\nIt does fail, see [#14058 comment 62](http://trac.sagemath.org/ticket/14058#comment:62).",
    "created_at": "2015-08-10T12:09:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254274",
    "user": "vdelecroix"
}
```

Replying to [comment:38 SimonKing]:
> Replying to [comment:37 vdelecroix]:
> Could someone verify if it is really the case that tests pass with "develop", but fail with the branch from here (merged in "develop" of course)? I currently do not have the bandwidth.

It does fail, see [#14058 comment 62](http://trac.sagemath.org/ticket/14058#comment:62).



---

archive/issue_comments_254275.json:
```json
{
    "body": "Replying to [comment:39 vdelecroix]:\n> Replying to [comment:38 SimonKing]:\n> > Replying to [comment:37 vdelecroix]:\n> > Could someone verify if it is really the case that tests pass with \"develop\", but fail with the branch from here (merged in \"develop\" of course)? I currently do not have the bandwidth.\n> \n> It does fail, see [#14058 comment 62](http://trac.sagemath.org/ticket/14058#comment:62).\n\nPlease be clearer. It fails in what setting? Does it only fail with #14058? Does it also fail with develop? Does it also fail with the branch from here?\n\nIf it fails both here and at #14058, but not with develop, then I reckon both branches trigger a memory leak that was introduced elsewhere.",
    "created_at": "2015-08-10T12:25:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254275",
    "user": "SimonKing"
}
```

Replying to [comment:39 vdelecroix]:
> Replying to [comment:38 SimonKing]:
> > Replying to [comment:37 vdelecroix]:
> > Could someone verify if it is really the case that tests pass with "develop", but fail with the branch from here (merged in "develop" of course)? I currently do not have the bandwidth.
> 
> It does fail, see [#14058 comment 62](http://trac.sagemath.org/ticket/14058#comment:62).

Please be clearer. It fails in what setting? Does it only fail with #14058? Does it also fail with develop? Does it also fail with the branch from here?

If it fails both here and at #14058, but not with develop, then I reckon both branches trigger a memory leak that was introduced elsewhere.



---

archive/issue_comments_254276.json:
```json
{
    "body": "Replying to [comment:40 SimonKing]:\n> Please be clearer. It fails in what setting? Does it only fail with #14058? Does it also fail with develop? Does it also fail with the branch from here?\n\nSorry for the noise. I just notice that #14058 is a dependency for the ticket here. So, we should focus on #14058.",
    "created_at": "2015-08-10T12:25:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254276",
    "user": "SimonKing"
}
```

Replying to [comment:40 SimonKing]:
> Please be clearer. It fails in what setting? Does it only fail with #14058? Does it also fail with develop? Does it also fail with the branch from here?

Sorry for the noise. I just notice that #14058 is a dependency for the ticket here. So, we should focus on #14058.



---

archive/issue_comments_254277.json:
```json
{
    "body": "bump...",
    "created_at": "2015-09-23T15:41:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254277",
    "user": "SimonKing"
}
```

bump...



---

archive/issue_comments_254278.json:
```json
{
    "body": "I think the description of the ticket should be updated because I don't see those instances with multiple of one hundred anymore on sage-6.9.rc0. (Exactly what leaks are fixed in this ticket?)\n\nIs the following line needed?\n\n```\n+from sage.structure.parent import Parent\n```\n\n\nOther than that, I verified that the branches indeed fixes the problem mentioned at comment 33. When the two thing above are fixed, to me, it will be a positive review.",
    "created_at": "2015-09-28T14:55:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254278",
    "user": "slabbe"
}
```

I think the description of the ticket should be updated because I don't see those instances with multiple of one hundred anymore on sage-6.9.rc0. (Exactly what leaks are fixed in this ticket?)

Is the following line needed?

```
+from sage.structure.parent import Parent
```


Other than that, I verified that the branches indeed fixes the problem mentioned at comment 33. When the two thing above are fixed, to me, it will be a positive review.



---

archive/issue_comments_254279.json:
```json
{
    "body": "Replying to [comment:43 slabbe]:\n>  because I don't see those instances with multiple of one hundred anymore on sage-6.9.rc0.\n\nSorry, I am retracting here as I do see them on sage-6.9.rc0:\n\n\n```python\nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: %cpaste\nPasting code; enter '--' alone on the line to stop or use Ctrl-D.\n:sage: def test_mod_100(L, dim):\n:....:     import gc\n:....:     from collections import Counter\n:....:     gc.collect()\n:....:     pre={id(c) for c in gc.get_objects()}\n:....:     m = matrix(dim, L)\n:....:     for p in range(2,102):\n:....:         m.change_ring(GF(nth_prime(p))).eigenvalues()\n:....:     gc.collect()\n:....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n:....:     return [(k,v) for (k,v) in post.iteritems() if v%100==0]\n:--\nsage: test_mod_100(L, 5)\n[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>, 100),\n (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),\n (<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>, 100),\n (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),\n (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),\n (<class 'sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category'>, 100),\n (<type 'sage.categories.map.FormalCompositeMap'>, 200),\n (<type 'sage.rings.polynomial.polynomial_element.PolynomialBaseringInjection'>, 200),\n (<class 'sage.rings.ideal.Ideal_pid'>, 100),\n (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100)]\n```\n\n\nand they do disappear with this ticket on top on sage-6.9.rc0:\n\n\n```python\nsage: test_mod_100(L, 5)\n[]\n```\n\n\nThat being said, I do see some stuff on the second, third, fourth execution of `test(L, 5)`:\n\n\n```python\nsage: test(L, 5)\n[(<type 'tuple'>, 5198),\n (<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category.element_class'>,  101),\n (<type 'sage.rings.finite_rings.element_givaro.FiniteField_givaroElement'>,  194),\n (<type 'sage.rings.finite_rings.element_pari_ffelt.FiniteFieldElement_pari_ffelt'>,  1104),\n (<type 'dict'>, 102)]\n```\n\n\nIs this problematic?",
    "created_at": "2015-09-30T08:51:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254279",
    "user": "slabbe"
}
```

Replying to [comment:43 slabbe]:
>  because I don't see those instances with multiple of one hundred anymore on sage-6.9.rc0.

Sorry, I am retracting here as I do see them on sage-6.9.rc0:


```python
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: %cpaste
Pasting code; enter '--' alone on the line to stop or use Ctrl-D.
:sage: def test_mod_100(L, dim):
:....:     import gc
:....:     from collections import Counter
:....:     gc.collect()
:....:     pre={id(c) for c in gc.get_objects()}
:....:     m = matrix(dim, L)
:....:     for p in range(2,102):
:....:         m.change_ring(GF(nth_prime(p))).eigenvalues()
:....:     gc.collect()
:....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
:....:     return [(k,v) for (k,v) in post.iteritems() if v%100==0]
:--
sage: test_mod_100(L, 5)
[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>, 100),
 (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),
 (<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>, 100),
 (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),
 (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),
 (<class 'sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category'>, 100),
 (<type 'sage.categories.map.FormalCompositeMap'>, 200),
 (<type 'sage.rings.polynomial.polynomial_element.PolynomialBaseringInjection'>, 200),
 (<class 'sage.rings.ideal.Ideal_pid'>, 100),
 (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100)]
```


and they do disappear with this ticket on top on sage-6.9.rc0:


```python
sage: test_mod_100(L, 5)
[]
```


That being said, I do see some stuff on the second, third, fourth execution of `test(L, 5)`:


```python
sage: test(L, 5)
[(<type 'tuple'>, 5198),
 (<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category.element_class'>,  101),
 (<type 'sage.rings.finite_rings.element_givaro.FiniteField_givaroElement'>,  194),
 (<type 'sage.rings.finite_rings.element_pari_ffelt.FiniteFieldElement_pari_ffelt'>,  1104),
 (<type 'dict'>, 102)]
```


Is this problematic?



---

archive/issue_comments_254280.json:
```json
{
    "body": "New commits:",
    "created_at": "2017-05-27T20:03:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18668",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18668#issuecomment-254280",
    "user": "chapoton"
}
```

New commits:
