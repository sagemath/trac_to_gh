# Issue 21920: Add SPQR-tree decomposition for 2-vertex-connected graphs

Issue created by migration from https://trac.sagemath.org/ticket/22157

Original creator: jfallon

Original creation time: 2017-01-09 05:46:19

CC:  dcoudert meghanamreddy saiharsh

Keywords: connectivity, decomposition

Addition of a method spqr_tree() to generic_graph.py to decompose a 2-vertex-connected graph into cycles, cocycles, and 3-vertex-connected blocks.


---

Comment by dcoudert created at 2017-01-09 14:58:07

I'll be happy to help reviewing this method.


---

Comment by git created at 2017-01-09 18:43:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2017-01-10 12:10:32

When I look at the code, I see many many modifications in various functions. I hope it is only a side effect of the tool to see the commits and that you have only touch methods `twosplit` and `spqr_tree`.

The proposed method is far from being a linear time algorithm. Although I was not expecting the implementation to perfectly follow the time complexity, and we are for sure more interested by the functionality than by it's running time, I'm surprised that you use methods such as `vertex_connectivity` or `is_isomorphic`. You have also lots of graph copies and such operations are also time consuming. I fear that this code will be usable only for small graphs, while it would be very useful for graphs with thousands of nodes.

Could you add more comments in the code. So far it is really hard to follow what you are doing and why. Thanks.


---

Comment by jfallon created at 2017-01-10 16:11:42

Regarding the other functions, all I have done to the generic_graph.py file is to paste in the two functions; I have not touched anything else. Given the complexity cost of calling other functions, it seems best to accomplish the transition from crude to code by overhaul; adding comments to the current content will be time best spent making large improvements. The function did what I needed as a helper for a larger function; for contribution to Sage it needs better treatment.


---

Comment by dcoudert created at 2017-01-11 16:50:32

If I understand well, your first objective is to have a method returning a `SPQR-tree`, but you don't need this method to be fast and you are not planning yet to implement best possible method. This is perfectly understandable and in such case we need to add a warning or todo flag explaining that a faster algorithm could be implemented.

some remarks:

In method `twosplit` you can avoid calling twice `vertex_connectivity`. First call `cut_size,cut_vertices = self.vertex_connectivity(value_only=False)` and then check if `cut_size != 2`.

In method `spqr_tree`, you can avoid a call to `vertex_connectivity` doing `if not self.is_connected() and len(self.blocks_and_cut_vertices()[1]) > 0: ...`.

We can certainly make a small method to check that `A` is a cycle. For instance `if A.order()==A.size() and min(A.degree())==max(A.degree() and A.is_connected()` ? Unfortunately, no such method has been added to `graph_classes` yet.

You don't need to call `GraphGenerators.EmptyGraph()`. You can call directly `Graph(multiedges=True)` if you want to allow multi edges.

Instead of `e in SPR[i].edges(labels = False)` you could test `SPR[i].has_edge(e)`. Many times.


---

Comment by git created at 2017-01-13 05:12:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2017-01-14 17:43:55

Some proposals to improve method `twosplit`.
* the name of the method is not appropriate. It should be at least `two_split` or something more clear
* You can use method `self._scream_if_not_simple()` to avoid adding your own tests.
* `virtual_edge = (cut_vertices[0],cut_vertices[1])` -> `virtual_edge = tuple(cut_vertices)`
* Instead of `H = self.subgraph(vertices = [v for v in self.vertices() if v not in cut_vertices])` you can do the following which should be slightly faster: 

```
H = Graph(self.edges(labels=False))
H.delete_vertices(cut_vertices)
```

* In loop `for K in CC:...` you can do that, thus saving a useless creation of a subgraph (graph copies and taking subgraph can be a long operation):

```
    cut_sides = []
    for K in CC:
        for u in cut_vertices:
            K.add_edges([(u,v) for v in self.neighbor_iterator(u) if v in K])
        K.allow_multiple_edges(True) ## why do we need that ???
        if not K.has_edge(virtual_edge):
            K.add_edge(virtual_edge)
        cut_sides.append(K)
```

* The loop `for i in range(Comps + 1): cocycles.add_edge(virtual_edge)` could be replaced with `cocycles.add_edges([virtual_edge]*(Comps+1))`. Very similar in fact.
* Also, do not hesitate to add an empty line between important blocs of code/comments to ease the readability.


Overall, the method should be something like that:

```
    from sage.graphs.graph import Graph
    self._scream_if_not_simple()

    cut_size,cut_vertices = self.vertex_connectivity(value_only = False)
    if cut_size != 2:
        raise NotImplementedError("twosplit is only implemented on graphs with vertex connectivity 2")

    H = Graph(self.edges(labels=False))
    H.delete_vertices(cut_vertices)

    virtual_edge = tuple(cut_vertices)    
    CC = H.connected_components_subgraphs()
    Comps = len(CC)

    # deletion of separating pair leaves connected components;
    # we add to each of those components a virtual edge
    # between the separating pair and restore edges incident to them
    cut_sides = []
    for K in CC:
        for u in cut_vertices:
            K.add_edges([(u,v) for v in self.neighbor_iterator(u) if v in K])
        K.allow_multiple_edges(True) ## why ???
        if not K.has_edge(virtual_edge):
            K.add_edge(virtual_edge)
        cut_sides.append(K)

    # if the original graph has an edge between the separating pair
    # of vertices, a bond with one edge more than the number of 
    # auxiliary graphs is needed for re-assembly
    cocycles = Graph(multiedges=True)
    if self.has_edge(virtual_edge):
        cocycles.add_edges([virtual_edge]*(Comps+1))

    # if the original graph has no edge between the separating pair
    # of vertices but deletion of the separating pair leaves
    # more than two components, a bond with one edge per component
    # is needed for re-assembly
    elif Comps > 2:
        cocycles.add_edges([virtual_edge]*Comps)

    return cut_sides,cocycles,virtual_edge
```


Of course, the modifications I proposed are not helpful to speed up the code. We need a palm-tree and the appropriate algorithm for that...


---

Comment by dcoudert created at 2017-10-21 09:27:33

Any news on this ticket? It would be very useful to have this method.


---

Comment by git created at 2017-10-30 18:11:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-03-22 21:11:13

Could anyone explain me the current status of this ticket, how far it's completed? and what are the gaps?


---

Comment by dcoudert created at 2018-03-24 08:58:26

The proposed patch implements a slow version of the decomposition of a graph into 3 connected components. It must be rebased on last beta, and the proposed methods must be moved to `graph.py` since it is for undirected graphs only.


---

Comment by saiharsh created at 2018-05-25 10:16:42

New commits:


---

Comment by git created at 2018-05-25 10:40:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-05-26 12:03:22

Your patch does not pass tests.
In the multigraph example, you must add `multiedges=True`, so

```
sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)
```


Furthermore, have you checked that the returned solutions are correct ?
In the subgraphs, some multiple edges are presents but some are missing.

```
sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)
sage: S,C,f = G.cleave()
sage: for g in S:
....:     print(g.edges(labels=0))
....: 
[(0, 1), (0, 1), (0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)]
[(2, 4), (2, 6), (4, 6)]
[(2, 4), (2, 7), (4, 7)]
```


I do prefer the following example, easier to check:

```
sage: G = graphs.CompleteBipartiteGraph(2,3)
sage: G.add_edge(2, 3)
sage: G.allow_multiple_edges(True)
sage: G.add_edges(G.edges())
sage: S,C,f = G.cleave()
sage: for g in S:
....:     print(g.edges(labels=0))
....:     
[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (2, 3)]
[(0, 1), (0, 4), (1, 4)]
```

It seems the problem is with multiple edges incident to a cut vertex.


---

Comment by saiharsh created at 2018-05-27 09:25:03

Replying to [comment:18 dcoudert]:
> Your patch does not pass tests.
> In the multigraph example, you must add `multiedges=True`, so
> {{{
> sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)
> }}}
> 
> Furthermore, have you checked that the returned solutions are correct ?
> In the subgraphs, some multiple edges are presents but some are missing.
> {{{
> sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)
> sage: S,C,f = G.cleave()
> sage: for g in S:
> ....:     print(g.edges(labels=0))
> ....: 
> [(0, 1), (0, 1), (0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)]
> [(2, 4), (2, 6), (4, 6)]
> [(2, 4), (2, 7), (4, 7)]
> }}}
> 
> I do prefer the following example, easier to check:
> {{{
> sage: G = graphs.CompleteBipartiteGraph(2,3)
> sage: G.add_edge(2, 3)
> sage: G.allow_multiple_edges(True)
> sage: G.add_edges(G.edges())
> sage: S,C,f = G.cleave()
> sage: for g in S:
> ....:     print(g.edges(labels=0))
> ....:     
> [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (2, 3)]
> [(0, 1), (0, 4), (1, 4)]
> }}}
> It seems the problem is with multiple edges incident to a cut vertex.
Yes, there are few edges missing in `S` because we are adding only one edge in a component between `u` and cut vertex even if there are multiple edges between them. Please see below.

```
for u in cut_vertices:
    component.add_edges([(u,v) for v in G.neighbor_iterator(u) if v in componentVertices])
```

\\
Shall I iterate over cut vertices edges using `G.edge_iterator` and add edges like below.

```
for u in cut_vertices:
    component.add_edges([(u,e[1]) for e in G.edge_iterator(u) if e[1] in componentVertices])
```

Or is there any better way to find number of multiple edges between `u` and `v`. \\
\\
I feel the `cocycles` if there is an edge between the separating pair then it should be like

```
cocycles.add_edges([virtual_edge]*(Comps+(number of multiple edges between cutvertices)))
```

Please let me know if I am wrong.


---

Comment by dcoudert created at 2018-05-28 08:17:59

> Shall I iterate over cut vertices edges using `G.edge_iterator` and add edges like below.
> {{{
> for u in cut_vertices:
>     component.add_edges([(u,e[1]) for e in G.edge_iterator(u) if e[1] in componentVertices])
> }}}

You can do directly:

```
component.add_edges([e for e in G.edge_iterator(vertex=cut_vertices) if e[0] in componentVertices or e[1] in componentVertices])
```

\\

> I feel the `cocycles` if there is an edge between the separating pair then it should be like
> {{{
> cocycles.add_edges([virtual_edge]*(Comps+(number of multiple edges between cutvertices)))
> }}}
> Please let me know if I am wrong. 

Good question. In fact, it might be even more. Indeed, you create a list of subgraphs, each corresponding to the vertices of a connected component in the graph minus the cut vertices, plus the cut vertices and edges between them.
Hence, if we have 2 edges between the cut vertices, we must also have 2 edges between these vertices in each subgraph.

Consequently, the cocycle contains `(#comps + 1) * (number of multiple edges between cutvertices)` edges when we have edges between the cut vertices and `#comps` otherwise. 


Do not forget to correct all minor issues in the method like `if `G` is a biconnected..` -> `If `G` is a biconnected..`, in the description of the output you must say that `C` is `cocylcles`, etc.


---

Comment by saiharsh created at 2018-05-28 09:24:10

Replying to [comment:20 dcoudert]:
> Good question. In fact, it might be even more. Indeed, you create a list of subgraphs, each corresponding to the vertices of a connected component in the graph minus the cut vertices, plus the cut vertices and edges between them.
> Hence, if we have 2 edges between the cut vertices, we must also have 2 edges between these vertices in each subgraph.
Sorry, I am unable to understand, does it means if `G` has 3 edges between cut vertices then each connected component of H(after removing cut vertices in G) should have 3 virtual edges between cut vertices?

If no edge between cut vertices in G, it's clear, (#comps).
 
> Do not forget to correct all minor issues in the method like `if `G` is a biconnected..` -> `If `G` is a biconnected..`, in the description of the output you must say that `C` is `cocylcles`, etc.
Yes I will and update it in next commit.


---

Comment by dcoudert created at 2018-05-28 09:33:38

> Sorry, I am unable to understand, does it means if `G` has 3 edges between cut vertices then each connected component of H(after removing cut vertices in G) should have 3 virtual edges between cut vertices?

It's what I think.


---

Comment by saiharsh created at 2018-05-28 18:56:14

New commits:


---

Comment by saiharsh created at 2018-05-29 06:14:30

It took sometime for updating it to latest beta version.\\
\\
I am using a variable `multiedges_bw_cutvertices` which stores the number of multiple edges between cut vertices in `G` and it's used to add number of virtual edges to each component.\\
The previous version add only one virtual edge.

```
if not component.has_edge(virtual_edge):
    component.add_edges([virtual_edge]*multiedges_bw_cutvertices)
```


I am unable to understand why `cocycles` a dipole graph is not define when the connected components are 2? (Unable to find the supporting point)

```
elif Comps > 2:
    cocycles.add_edges([virtual_edge]*Comps)
```


Do these examples are enough or we need to add more examples for cleave function?

In the next commit I will be updating spqr_tree function.


---

Comment by dcoudert created at 2018-05-29 15:39:21

> I am unable to understand why `cocycles` a dipole graph is not define when the connected components are 2? (Unable to find the supporting point)

I don't understand the question. Please give a clear example

> In the next commit I will be updating spqr_tree function. 
OK
\\

You can get the number of edges between cut vertices as 

```
if self.has_edge(virtual_edge):
   if self.has_multiple_edges():
      multiedges_bw_cutvertices = len(self.edge_label(cut_vertices[0],cut_vertices[1]))
   else:
      multiedges_bw_cutvertices = 1
else:
   multiedges_bw_cutvertices = 0
```


Do `component.allow_multiple_edges(True)` before adding edges to the component. Otherwise, multiedges will not be added


---

Comment by saiharsh created at 2018-05-29 15:58:59

Replying to [comment:25 dcoudert]:


\\
Please see below lines.


```
        if self.has_edge(virtual_edge):
            cocycles.add_edges([virtual_edge]*(Comps+1)*multiedges_bw_cutvertices)

        elif Comps > 2:
            cocycles.add_edges([virtual_edge]*Comps)
```


When we have connected components = 2 and `G` has no virtual edge then it neither enters in if condition nor in else condition. End up by returning an empty list for `cocycle`. is it correct? \\

If the number of connected components is 2 and there is not virtual edge present in `G`
then why we are not adding virtual edges to `cocycles`?


---

Comment by dcoudert created at 2018-05-30 10:19:25

But you must add edges to the cocycle when `Comps >= 2` ! So please change.


---

Comment by saiharsh created at 2018-06-03 17:27:35

1. Cleave function is defined initially, knowing that input is always simple biconnected graph.
2. As `A` is always simple according to `split_multiple_edges` algorithm in the reference paper, I feel there is no need to add `B.allow_multiple_edges(False)`.
3. Currently, all the cycles are pushed to polygons(S-Block) but what if a cycle is tri connected i.e a triangle. I feel it need to be in `R-Block` instead of `S-Block`. Correct me, If I am wrong.

4. According to `Theorem 1` in reference paper, the number of nodes in Tree need to be equal to the number of tri-connected components and the edges between nodes u,v exit only if the components u and v share the common edge. The current implementation is adding all the required edges and the generated tree seems to be correct, yet not found a counter case yet.
Is there any simple way to verify the output tree?
\\ 
\\
5. I tried with few examples.

```
G = Graph({1:[2,3], 3:[2, 5], 2:[4], 6:[4,5]})
G = Graph({0:[1,2,3],1:[4,5],2:[3],3:[5],4:[5],6:[2,4]})
# Refernce Paper graph
G = Graph({1:[2, 4, 8, 12, 13], 2:[1, 3, 13], 3:[2, 4, 13], 4:[1, 3, 7, 5], 5:[4, 6, 7, 8], 6:[5, 7], 7:[4, 5, 6], 8:[1, 5, 9, 11, 12], 9:[8, 10, 11, 12], 10:[9, 11, 12], 11:[8, 9, 10], 12:[1, 8, 9, 10]})
```

AFAIK, the output seems to be correct.
Please let me know the case in which it's giving an incorrect answer.
6. There is a minor change in the `cleave function`, multiedges_bw_cutvertices -> num_virtual_edge_add, my bad I gave initially the incorrect name. 
`num_virtual_edge_add` says the number of virtual edges needs to be added to a component.


---

Comment by git created at 2018-06-04 10:26:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-06-04 10:33:18

Replying to [comment:29 git]:

Please test on this spqr-tree function and there is a minor change in the output definition.
Previous it return `(R,S,P,SPR,SPQR-tree)` \\
Now it return      `(R,S,P,SPR,tricomp,SPQR-tree)` \\
Tri-Component is a list of tri-components from R and S block. As S-Block contains the only polygon so there is only one case in which a component is a cycle and tri-connected is Triangle.

> ||[ad946da](https://git.sagemath.org/sage.git/commit/?id=ad946dabc60578979c80087a54aadf87fecbca30)||`First commit on SPQR-Tree`||


---

Comment by dcoudert created at 2018-06-04 15:08:27

I cannot test yet. I had to do a `make dist-clean && make` after a system update. long time...

- In `cleave`, the error message `"G must be a biconnected graph."` is not appropriate. It can be used only if you test `if cut_size < 2`. But when `cut_size > 2`, it is better to say `"G has no 2-vertex cut"`  (without dot at the end of the sentence)

- `R & S block` -> ``R` and `S` blocks`

- do you think that the example `sage: G.spqr_tree()[1]` is useful ? I don't understand what we get. May be should should add explanation before that a graph build from a complete bipartite graph `2x5` with an edge joining the vertices of the side of order 2 is decomposed into 5 rigid blocks. However, the blocks are triangles...\\
  This graph could be more informative. It is made of 3 `K_4` with edge `(0, 1)` in common.

```
sage: G = Graph(2)
sage: for i in range(3):
....:     G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
```

  It will be split into 3 3-connected blocks, each isomorphic to a `K_4`.


---

Comment by saiharsh created at 2018-06-04 16:38:13

> - do you think that the example `sage: G.spqr_tree()[1]` is useful ? I don't understand what we get. May be should should add explanation before that a graph build from a complete bipartite graph `2x5` with an edge joining the vertices of the side of order 2 is decomposed into 5 rigid blocks. However, the blocks are triangles...\\
>   This graph could be more informative. It is made of 3 `K_4` with edge `(0, 1)` in common.
> {{{
> sage: G = Graph(2)
> sage: for i in range(3):
> ....:     G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
> }}}
>   It will be split into 3 3-connected blocks, each isomorphic to a `K_4`.
> 
Yes, followed by G.spqr_tree()[0],  G.spqr_tree()[1] will give us a empty set as other components are tri-connected and covered in R-Block. \\

G = Graph({0:[1,2],3:[1,2],4:[1,2],5:[1,2],6:[1,2]}) will give similar results if triangles are added to R-Block instead of S-block i.e polygon blocks.
Currently, it's giving an empty list to R-block(G.spqr_tree()[0]) and all triangles to S-Block(G.spqr_tree()[1]).


---

Comment by dcoudert created at 2018-06-04 16:56:46

my main complain is that this output is ugly

```
+            sage: G.spqr_tree()[1]
+            [Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices]
```



---

Comment by saiharsh created at 2018-06-04 20:19:23

Replying to [comment:33 dcoudert]:
> my main complain is that this output is ugly
> {{{
> +            sage: G.spqr_tree()[1]
> +            [Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices]
> }}}
Yes it doesn't look good and convey less information. \\
Any suggestion where I can find the document related to it or we can reduce this message in the code? \\
Tried searching in developer's  Guide  couldn't find a related doc.


---

Comment by dcoudert created at 2018-06-05 07:06:32

You want to show that the set `S` contains 5 3-cycles. So you can do:

```
sage: G = Graph({0:[1,2],3:[1,2],4:[1,2],5:[1,2],6:[1,2]})
sage: R,S,P,SPR,tricomp,SPQR-tree = G.spqr_tree()
sage: R
[]
sage: C3 = graphs.CycleGraph(3)
sage: all(h.is_isomorphic(C3) for h in S]
True
```



---

Comment by saiharsh created at 2018-06-05 15:41:14

Replying to [comment:35 dcoudert]:
> You want to show that the set `S` contains 5 3-cycles. So you can do:
> {{{
> sage: G = Graph({0:[1,2],3:[1,2],4:[1,2],5:[1,2],6:[1,2]})
> sage: R,S,P,SPR,tricomp,SPQR-tree = G.spqr_tree()
> sage: R
> []
> sage: C3 = graphs.CycleGraph(3)
> sage: all(h.is_isomorphic(C3) for h in S]
> True
> }}}
With the help of 3 K_4 example and this, 2 good examples are covered.

```
sage: G = Graph(2)
sage: for i in range(3):
....:     G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
sage: R,S,P,SPR,tricomp,SPQR_tree = G.spqr_tree()
sage: CG4 = graphs.CompleteGraph(4)
sage: all(h.is_isomorphic(CG4) for h in R)
True
```

I will update it in next commit.

One example for multiple edges, 

```
sage: G = graphs.CompleteBipartiteGraph(2,3)
sage: G.add_edge(2, 3)            
sage: G.allow_multiple_edges(True)
sage: G.add_edges(G.edges())
sage: G.add_edges([[0,1],[0,1],[0,1]])
sage: R,S,P,SPR,tricomp,SPQR-tree = G.spqr_tree()
sage: tricomp
[Subgraph of (): Multi-graph on 3 vertices,
 Subgraph of (): Multi-graph on 4 vertices]
```

With different order of tri-connected components.


---

Comment by git created at 2018-06-06 17:08:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-06-07 15:05:37

I have updated examples.
Currently, I am doing some performance analysis, how it's behaving on huge graphs. \\
Individually which operation is taking time.
\\
Replying to [comment:37 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[2457a52](https://git.sagemath.org/sage.git/commit/?id=2457a526eef1474a230fec134f4a5c6ae824b61f)||`Examples updated.`||


---

Comment by dcoudert created at 2018-06-07 16:18:44

Changing keywords from "connectivity, decomposition" to "connectivity, decomposition, gsoc2018".


---

Comment by dcoudert created at 2018-06-07 16:18:44

I bet that `self.vertex_connectivity(value_only=False)` is one of the most time consuming operation. That's why we need the implementation of the linear time algorithm.

The most import in this patch is to get a working method. It will be very useful for testing the linear time code.


---

Comment by saiharsh created at 2018-06-07 17:50:22

Replying to [comment:39 dcoudert]:
> I bet that `self.vertex_connectivity(value_only=False)` is one of the most time consuming operation. That's why we need the implementation of the linear time algorithm.
I will keep this as a separate parameter. \\
Thanks for suggesting me. \\
I will try to update you will the report ASAP.
> The most import in this patch is to get a working method. It will be very useful for testing the linear time code.
Yes, If found any incorrect answer please let me know.\\


---

Comment by saiharsh created at 2018-06-11 20:14:32

Yes, it's taking much time for graphs which has order > 2000 and size > 40000.
Mostly the time is taken by vertex_connectivity function and some other component depending on graph.(cases are less)
\\
To reduce memory usage, I am deleting few variables after usage. 

After doing few runs with different graphs, I kept flags to find running time for below 5 parts.
1. Vertex_connectivity
2. Split_multiple_edge(4711 to 4730)
3. cleave and appending cuts (4734 to 4761)
4. appending blocks (4769 to 4806)
5. Construction of Tree (4812 to 4843)

vertex_connectiviy is taking more time when there are multiple edges in input graph. So I am pushing, Split_multiple_edges as the first step(if graph has multiple edges) as split_mutiple_edge will give output as a simple version of G. if there are x cut points in multigraph then they should be x cut points in a simple graph too. correct me if I am wrong.

There is a significant difference in running time of vertex_connectivity function if we do above change, atleast code running time is down with 1/2 when there are multiple edges in input graph.

I will upload the result file mostly by tomorrow night. Some test cases are pending.


---

Comment by dcoudert created at 2018-06-12 15:53:39

> vertex_connectiviy is taking more time when there are multiple edges in input graph. 

This is surprizing. In the ILP formulation, multiple edges only lead to adding multiple times the same constraint, but then solver quickly remove redundant constraints.

> So I am pushing, Split_multiple_edges as the first step(if graph has multiple edges) as split_mutiple_edge will give output as a simple version of G. if there are x cut points in multigraph then they should be x cut points in a simple graph too. correct me if I am wrong.
> 
Don't do that ! ;)

What is `split_multiple_edges` doing ? If it split an edge into a path, it introduce a new vertex of degree 2, and so a new cut with 2 vertices.



> There is a significant difference in running time of vertex_connectivity function if we do above change, atleast code running time is down with 1/2 when there are multiple edges in input graph.

Really weird. Isn't it due to extra computation like a copy of the graph ?


---

Attachment


---

Attachment


---

Comment by saiharsh created at 2018-06-12 21:52:52

Replying to [comment:42 dcoudert]:
> This is surprizing. In the ILP formulation, multiple edges only lead to adding multiple times the same constraint, but then solver quickly remove redundant constraints.
> Except that all other components are taking time but it sounds reasonable.
Please have a look at the second table in the attached file. 

In which I used two graph G1 with order = 3502 and size = 8751 and G2 with order = 5002 and size = 12501. later I am adding multiple edges to G1 and G2.
There is an increase in running time of Vertex Connectivity
but the difference is significant, please let me know if this kind of nature is expected.

\\
> > So I am pushing, Split_multiple_edges as the first step(if graph has multiple edges) as split_mutiple_edge will give output as a simple version of G. if there are x cut points in multigraph then they should be x cut points in a simple graph too. correct me if I am wrong.
> > 
> Don't do that ! ;)
> 
> What is `split_multiple_edges` doing ? If it split an edge into a path, it introduce a new vertex of degree 2, and so a new cut with 2 vertices.
> 
`split_multiple_edges` in this part bundle of multiple edges are replaced by a new virtual edge. This step is done only to make graph simple from multi.
It's reference is present in section 4.1 of the reference paper.

It's not going add any new vertex. 
\\
> 
> 
> > There is a significant difference in running time of vertex_connectivity function if we do above change, atleast code running time is down with 1/2 when there are multiple edges in input graph.
> 
> Really weird. Isn't it due to extra computation like a copy of the graph ?
I am finding how much time it's taking to execute `self.vertex_connectivity(value_only = False)` this step.
Let me know if I missed something.

Results.2.csv is same as Results.csv
\\
Table 1 has all multigraphs, it's intended to show which component is taking time if multiple edges are more.
\\
I wanted to generate a graph which shows running time vs memory consumption couldn't complete it.
\\
I used Intel(R) Xeon(R) CPU E5-2640 v4 processor, which has 2.40GHz frequency. To generate the running time.


---

Comment by git created at 2018-06-13 10:40:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-06-13 10:45:33

Replying to [comment:44 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[22e164b](https://git.sagemath.org/sage.git/commit/?id=22e164b11e46d477e90bb8e8b238a62a4c9f6521)||`Deleting few variables after there usage, added few flags for running time analysis which will be removed later.`||

Please use this code for testing.

Below is the sample output of the code.

```
sage: G = Graph(2)
....: for i in range(20):G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
....: R,S,P,SPR,tricomp,SPQR_tree = G.spqr_tree()
Nodes: 42
Edges: 101
cut_size =  2 cut_vertices =  [0, 1]
Time Taken for Vertex Connectivity: 0.0595650672913
Time Taken for Split_multiple_edge algorithm: 0.000383853912354
Time Taken for cleave and appending cuts  0.00986504554749
Time Taken for appending blocks, 6.48498535156e-05
Time Taken for Construction of Tree 0.00036883354187
Total time: 0.0704739093781
```



---

Comment by dcoudert created at 2018-06-13 11:34:18

I did some tests

```
sage: G = Graph(2)
sage: for i in range(1000):G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
sage: H = Graph(G.edges()+G.edges(), multiedges=True)
sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='Cplex')
1 loop, best of 3: 458 ms per loop
sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='Cplex')
1 loop, best of 3: 639 ms per loop
sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='GLPK')
1 loop, best of 3: 8.71 s per loop
sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='GLPK')
1 loop, best of 3: 15.3 s per loop
```

I also checked more closely adding parameter `verbose=3`.

With `Cplex`, the difference in running time is mostly in the time needed to write the ILP, and then in the elimination of rows/columns. So the difference is small.
With `GLPK`, I have the feeling that it does not eliminate rows/columns, and so is very long.

Anyway, we knew that `vertex_connectivity` is slow and that it takes most of the computing time of the method. So don't waste more time trying to optimize the running time of this method. It will be slow. The most important is that it is safe = it gives the correct result.


---

Comment by saiharsh created at 2018-06-13 16:53:50

Replying to [comment:46 dcoudert]:
> I did some tests
> {{{
> sage: G = Graph(2)
> sage: for i in range(1000):G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
> sage: H = Graph(G.edges()+G.edges(), multiedges=True)
> sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='Cplex')
> 1 loop, best of 3: 458 ms per loop
> sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='Cplex')
> 1 loop, best of 3: 639 ms per loop
> sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='GLPK')
> 1 loop, best of 3: 8.71 s per loop
> sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='GLPK')
> 1 loop, best of 3: 15.3 s per loop
> }}}
> I also checked more closely adding parameter `verbose=3`.
> 
> With `Cplex`, the difference in running time is mostly in the time needed to write the ILP, and then in the elimination of rows/columns. So the difference is small.
> With `GLPK`, I have the feeling that it does not eliminate rows/columns, and so is very long.
> 
I feel for 1000 nodes if it's taking ms is reasonable time. Ultimately it need to preform good when graph is simple but it's taking time for it too.

> Anyway, we knew that `vertex_connectivity` is slow and that it takes most of the computing time of the method. So don't waste more time trying to optimize the running time of this method. It will be slow. The most important is that it is safe = it gives the correct result.
The overall contribution of vertex_connectivity is to check whether the graph is bi-connected or not. if we mention the input need to be biconnected then we can remove the `vertex_connectivity`  or we can use `is_biconnected()`. \\
Again `vertex_connectivity` is used in `Cleave` a helper function of spqr_tree, the input to Cleave function is a simple subgraph. Its time is comparatively less if we see in Results.csv


---

Comment by dcoudert created at 2018-06-14 14:48:06

> > Anyway, we knew that `vertex_connectivity` is slow and that it takes most of the computing time of the method. So don't waste more time trying to optimize the running time of this method. It will be slow. The most important is that it is safe = it gives the correct result.
> The overall contribution of vertex_connectivity is to check whether the graph is bi-connected or not. 

Not only. We want to check if the graph has a 2-vertex-cut or not.

In particular, the `cleave` method is used to split a biconnected graph along a 2-vertex cut, if it has one.

> if we mention the input need to be biconnected then we can remove the `vertex_connectivity`  or we can use `is_biconnected()`. \\

Where ? in `cleave`, we need to find the 2-vertex-cuts.


---

Comment by saiharsh created at 2018-06-14 19:45:08

Replying to [comment:48 dcoudert]:
> Not only. We want to check if the graph has a 2-vertex-cut or not.
Yes, we need to check a graph has 2 cut vertices. If it's biconnected we would have used is_biconected.
> 
> Where ? in `cleave`, we need to find the 2-vertex-cuts.
Yes in `cleave` function but again the same problem. \\
I will remove the flags and update it.


---

Comment by git created at 2018-06-15 10:40:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-06-16 18:11:27

New commits:


---

Comment by dcoudert created at 2018-06-16 18:14:43

I moved the methods to `connectivity.pyx` and fixed the doctests. I will do more tests/corrections tomorrow.


---

Comment by saiharsh created at 2018-06-16 21:40:46

Replying to [comment:52 dcoudert]:
> I moved the methods to `connectivity.pyx` and fixed the doctests. I will do more tests/corrections tomorrow.
Thanks for updating it to beta5, could you please say what are the remaining gaps are available in this ticket.


---

Comment by git created at 2018-06-17 17:13:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-06-17 17:21:59

I have changed the `cleave` method to a more general form. It's now working for any size of vertex cut. More importantly, you can give it a vertex cut. This way, we save some calls to `vertex_connectivity`. I have updated `spqr_tree` accordingly.

In `spqr_tree`,  I have remove all `del` statements. In particular, you where deleting `SG` before the while loop over `twoblocks`... not good :P

Please check the new `cleave`.

I have not checked `spqr_tree` carefully yet.


---

Comment by saiharsh created at 2018-06-17 19:49:37

Replying to [comment:55 dcoudert]:
> I have changed the `cleave` method to a more general form. It's now working for any size of vertex cut. More importantly, you can give it a vertex cut. This way, we save some calls to `vertex_connectivity`. I have updated `spqr_tree` accordingly.
> 
Yes, now it could be used in general not only specific to `spqr_tree`. \\

> In `spqr_tree`,  I have remove all `del` statements. In particular, you where deleting `SG` before the while loop over `twoblocks`... not good :P
I kept `SG` before the while loop of `twoblocks` because there was no use of `SG` in future, as it was appended in `twoblocks` it's safe to delete it and deleting of `SG` won't reflect in `twoblocks`. \\
The moto of deleting variables is to reduce the memory usage. correct me if I am wrong.

> Please check the new `cleave`.
The code is well structured and easy to read. \\
Can we add an example in which cut vertices which are generated differ from ones which are given as input.\\


```
sage: G = Graph()
sage: G.add_cycle(vertices=[0,1,2,3,4])
sage: cut_size,cut_vertices = G.vertex_connectivity(value_only=False)
sage: cut_vertices
[2, 4]
sage: S,C,f = G.cleave(cut_vertices=[1, 3])
sage: [g.order() for g in S]
[4, 3]
sage: C.order(), C.size()
(2, 2)
sage: f.vertices()
[1, 3]

```



---

Comment by dcoudert created at 2018-06-17 20:10:11

> > In `spqr_tree`,  I have remove all `del` statements. In particular, you where deleting `SG` before the while loop over `twoblocks`... not good :P
> I kept `SG` before the while loop of `twoblocks` because there was no use of `SG` in future, as it was appended in `twoblocks` it's safe to delete it and deleting of `SG` won't reflect in `twoblocks`. \\
> The moto of deleting variables is to reduce the memory usage. correct me if I am wrong.

Deleting SG might lead to an error. Understand that when you append SG to `twoblocks`, you don't copy the full object, you just append a pointer to SG. Hopeful, when you do `del SG` it apparently only deletes the pointer, not the full object. So please don't do that !

To give you an example:

```
sage: G = Graph()
sage: L = []
sage: L.append(G)
sage: G.add_edge(0, 1)
sage: L[0].edges()
[(0, 1, None)]
```

 

Concerning `del twoblocks`, since the list is empty at that time, the memory occupancy is negligeable, so there is no need to do that.


> Can we add an example in which cut vertices which are generated differ from ones which are given as input.\\
> 
> {{{
> sage: G = Graph()
> sage: G.add_cycle(vertices=[0,1,2,3,4])
> sage: cut_size,cut_vertices = G.vertex_connectivity(value_only=False)
> sage: cut_vertices
> [2, 4]
> sage: S,C,f = G.cleave(cut_vertices=[1, 3])
> sage: [g.order() for g in S]
> [4, 3]
> sage: C.order(), C.size()
> (2, 2)
> sage: f.vertices()
> [1, 3]
> 
> }}}
I don't understand what you want to show. What is important is to give a valid vertex cut of the graph. You may add an example with more vertices than needed if you want, but I'm not sure it's so interesting here.


---

Comment by saiharsh created at 2018-06-17 21:58:25

Replying to [comment:57 dcoudert]:
> Deleting SG might lead to an error. Understand that when you append SG to `twoblocks`, you don't copy the full object, you just append a pointer to SG. Hopeful, when you do `del SG` it apparently only deletes the pointer, not the full object. So please don't do that !
> 
> To give you an example:
> {{{
> sage: G = Graph()
> sage: L = []
> sage: L.append(G)
> sage: G.add_edge(0, 1)
> sage: L[0].edges()
> [(0, 1, None)]
> }}}
>  
> 
> Concerning `del twoblocks`, since the list is empty at that time, the memory occupancy is negligeable, so there is no need to do that.
> 
Thanks for clearing it, I thought the change in `SG` should not effect in `twoblocks`.
so we can delete it. 
Before keeping `del SG`, I did below test.

```
sage: G = Graph([[0,1]])
sage: l = []
sage: l.append(G)
sage: G
Graph on 2 vertices
sage: l
[Graph on 2 vertices]
sage: del G
sage: G
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-7-96e89ba817df> in <module>()
----> 1 G

NameError: name 'G' is not defined
sage: l
[Graph on 2 vertices]
sage: l[0].add_edge(2,3)
sage: l
[Graph on 4 vertices]

```

This gives me thought that `G` and `l` doesn't have any link between them and both have independent memory location, so why to keep `G` when we have its instance in `l` but actually, it's appending links and deleting link i.e `SG` doesn't make sense and doesn't affect memory usage.

> > Can we add an example in which cut vertices which are generated differ from ones which are given as input.\\
> > 
> > {{{
> > sage: G = Graph()
> > sage: G.add_cycle(vertices=[0,1,2,3,4])
> > sage: cut_size,cut_vertices = G.vertex_connectivity(value_only=False)
> > sage: cut_vertices
> > [2, 4]
> > sage: S,C,f = G.cleave(cut_vertices=[1, 3])
> > sage: [g.order() for g in S]
> > [4, 3]
> > sage: C.order(), C.size()
> > (2, 2)
> > sage: f.vertices()
> > [1, 3]
> > 
> > }}}

> I don't understand what you want to show. What is important is to give a valid vertex cut of the graph. You may add an example with more vertices than needed if you want, but I'm not sure it's so interesting here.
I want to show that the cut vertices(passing values when calling the function) could differ(in size too) from the generated output of `vertex_connectivity`, as we have enough examples may this is not a good example.


---

Comment by saiharsh created at 2018-06-23 17:06:13

New commits:


---

Comment by saiharsh created at 2018-06-23 17:12:04

A minor change in the examples, `G.spqr_tree()` to `spqr_tree(G)` and `G.cleave(cut_vertices)` to `cleave(G, cut_vertices)`as the code is shifted to connectivity.pyx file.


---

Comment by git created at 2018-06-24 09:13:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-06-24 09:22:26

I did some more corrections, but I need some clarifications to go beyond.
- Could you try to improve the comments. So far, some of them a really not clear ;)

- if `SG` is simplified to a cycle, can't we directly return the solution ?

- In the part where you merge cycles to form `cycle_graph`, I'm not sure of what we want at the end. I suspect that we can do something smarter, but it depends on what we must get.

- Why are we returning so many different values ? Can't we just return a tree in which nodes a tuples (type, graph) ? Observe that using `immutable` graphs, we can do:

```
sage: P = Graph(1, immutable=True)
sage: Q = Graph(2, immutable=True)
sage: H = Graph([[P, Q], [(P, Q)]])
```


- The case of `Q` block could also be handled at the beginning, right ?


---

Comment by git created at 2018-06-25 14:14:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-06-25 14:19:50

Replying to [comment:63 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[150e868](https://git.sagemath.org/sage.git/commit/?id=150e8689ee4481c2df8e9474287936e0430668be)||`Updated for case when `SG` is a cycle.`||
I have added `P_block_new` for test.
Example: 

```
sage: from sage.graphs.connectivity import spqr_tree
....: G = Graph()
....: G.add_cycle(vertices=[0,1,2,3,4])
....: G.allow_multiple_edges(True)
....: G.add_edges(G.edges())
....: G.add_edge(2,3)
....: G.add_edge(3,4)
....: 
sage: R,S,P,SPR,tricomp,SPQR_tree,P_new = spqr_tree(G)
sage: P==P_new
True

```

In the next commit, I will update the comments and add a return statement `if SG.is_cycle():`.


---

Comment by saiharsh created at 2018-06-25 14:32:27

Replying to [comment:62 dcoudert]:

> - Could you try to improve the comments. So far, some of them a really not clear ;)
I will try to add in the next commit. I am not yet good at writing formally.
> 
> - if `SG` is simplified to a cycle, can't we directly return the solution ?
Yes we can do this, 
R will be `[]` \\
S will be `SG` \\
P_block will be the components formed by combining multiple edges in `cocycle`. there are two ways to do it. \\
1. Make components by adding multiple edges. \\
2. Make multigraph using `cocycle` edges then extract subgraphs using `cuts`. \\
I feel option 1 is slightly better than option 2, let me know which option is better.
> 
> - In the part where you merge cycles to form `cycle_graph`, I'm not sure of what we want at the end. I suspect that we can do something smarter, but it depends on what we must get.
> 
It's a verification step used to check whether all the cycles are formed using `cocycle` edges. \\
Initially, I thought we can skip this step as there is no case in which cycle will be formed without using `cocycle` edge but I am not 100% sure.
> - Why are we returning so many different values ? Can't we just return a tree in which nodes a tuples (type, graph) ? Observe that using `immutable` graphs, we can do:
> {{{
> sage: P = Graph(1, immutable=True)
> sage: Q = Graph(2, immutable=True)
> sage: H = Graph([[P, Q], [(P, Q)]])
> }}}
> 
> - The case of `Q` block could also be handled at the beginning, right ?
We can remove `SPR` block as it's addition of previous 3 variables, `R_blocks + polygons + P_blocks`. \\


---

Comment by dcoudert created at 2018-06-27 07:00:36

> P_block will be the components formed by combining multiple edges in `cocycle`. there are two ways to do it. \\
> 1. Make components by adding multiple edges. \\
> 2. Make multigraph using `cocycle` edges then extract subgraphs using `cuts`. \\
> I feel option 1 is slightly better than option 2, let me know which option is better.

It's also my impression.

> > - In the part where you merge cycles to form `cycle_graph`, I'm not sure of what we want at the end. I suspect that we can do something smarter, but it depends on what we must get.
> > 
> It's a verification step used to check whether all the cycles are formed using `cocycle` edges. \\
> Initially, I thought we can skip this step as there is no case in which cycle will be formed without using `cocycle` edge but I am not 100% sure.

Me neither. 

> > - Why are we returning so many different values ? Can't we just return a tree in which nodes a tuples (type, graph) ? Observe that using `immutable` graphs, we can do:
> > {{{
> > sage: P = Graph(1, immutable=True)
> > sage: Q = Graph(2, immutable=True)
> > sage: H = Graph([[P, Q], [(P, Q)]])
> > }}}
> > 
> > - The case of `Q` block could also be handled at the beginning, right ?
> We can remove `SPR` block as it's addition of previous 3 variables, `R_blocks + polygons + P_blocks`. \\

Assume that the nodes of the SPQR-tree are (immutable) multi-graphs and not subsets of vertices. If I give you only the SPQR-tree, we should be able to reconstruct the original graph, right ? So are other outputs necessary ?


---

Comment by git created at 2018-06-27 11:30:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-06-27 11:45:37


```
sage: from sage.graphs.connectivity import spqr_tree
....: G = Graph()
....: G.add_cycle(vertices=[0,1,2,3,4])
....: G.allow_multiple_edges(True)
....: G.add_edges(G.edges())
....: G.add_edge(2,3)
....: G.add_edge(3,4)
....: R,S,P,SPR,tricomp,SPQR_tree, tree_new = spqr_tree(G)
sage: tree_new == SPQR_tree
True
sage: SPQR_tree.vertices()
[('P', (0, 1), Subgraph of (): Multi-graph on 2 vertices),
 ('P', (0, 4), Subgraph of (): Multi-graph on 2 vertices),
 ('P', (1, 2), Subgraph of (): Multi-graph on 2 vertices),
 ('P', (2, 3), Subgraph of (): Multi-graph on 2 vertices),
 ('P', (3, 4), Subgraph of (): Multi-graph on 2 vertices),
 ('S', (0, 1, 2, 3, 4), Subgraph of (): Multi-graph on 5 vertices)]
```


Updated SPQR_Tree vertices with subgraphs and added tree construction along with P_Block part for `SG` cycle case. \\
Let me know this is the right way to do. \\
From this, we need to return only `Tree` and not need to return other blocks.\\
Still, subgraph vertices are there in SPQR_Tree it's for testing which will be removed.


---

Comment by dcoudert created at 2018-06-27 15:48:37

Do you agree that, if after the `Split_multiple_edge Algorithm`, `SG` is reduced to a cycle,  it means that the graph `G` is a cycle with possibly multiple edges, and so that the SPQR-tree contains a single vertex `('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges()))` ? 

If so, you do directly:

```
if SG.is_cycle():
    return Graph({('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges())): []})
```



---

Comment by saiharsh created at 2018-06-27 17:02:39

Replying to [comment:69 dcoudert]:
> Do you agree that, if after the `Split_multiple_edge Algorithm`, `SG` is reduced to a cycle,  it means that the graph `G` is a cycle with possibly multiple edges, and so that the SPQR-tree contains a single vertex `('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges()))` ? 
> 
> If so, you do directly:
> {{{
> if SG.is_cycle():
>     return Graph({('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges())): []})
> }}}
Yes, `SG` will be a cycle if `G` is a cycle with few multi edges but in SPQR-Tree I feel we will have morethan one vertex because `G` is multi-graph so some edges will be added to `cocycle` which will lead to creation of `P_Block`(P vertices). \\

`return Graph({('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges())`. \\
This is true when `G` is cycle with `n - 1` edges. So no edges will contribute in creation of `P_Block`. \\

correct me if I am wrong.


---

Comment by dcoudert created at 2018-06-28 08:15:16

I'm not completely sure of that, but may be I missed something in the definitions (not clear for multigraphs). Somehow, the question we have to answer is: can a P node be a leaf of the SPQR tree ?\\
If so, a P node is a separator only if it is also an internal vertex of the tree.

`@`Meghana: what's your understanding of this case ?


---

Comment by saiharsh created at 2018-06-28 10:19:26

Replying to [comment:71 dcoudert]:
> I'm not completely sure of that, but may be I missed something in the definitions (not clear for multigraphs). Somehow, the question we have to answer is: can a P node be a leaf of the SPQR tree ?\\
Yes, it can be a leaf node.
> If so, a P node is a separator only if it is also an internal vertex of the tree.
Yes, it will be a separator if it's an internal vertex.

```
        sage: G = graphs.CompleteBipartiteGraph(2,3)
        sage: G.add_edge(2, 3)
        sage: G.allow_multiple_edges(True)
        sage: G.add_edges(G.edges())
        sage: G.add_edges([[0,1],[0,1],[0,1]])
        sage: R,S,P,SPR,tricomp,SPQR_tree,tree_new = spqr_tree(G)
```

In the above example some `P` elements are acting as leaf and some as internal vertex(a seperator).


---

Comment by git created at 2018-06-28 10:22:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-28 18:00:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-06-28 18:05:42

With what I did, you can do (don't add a third edge between 0 and 1 in this example. There is an error in `is_clique`: #25696):

```
sage: G = Graph([(0, 1), (0, 1), (0, 3), (1, 2), (2, 3)], multiedges=True)
sage: spqr_tree(G)
SPQR-tree of : Graph on 2 vertices
sage: spqr_tree(G).edges()
[(('P', Multi-graph on 2 vertices), ('S', Multi-graph on 4 vertices), None)]
```

I think the code is simpler and we return only what we need = the SPQR tree. Do you agree or you think something is missing ?



At some point, we will need a function that reconstruct a graph from a SPQR tree.


---

Comment by saiharsh created at 2018-06-28 18:28:17

Replying to [comment:75 dcoudert]:
> With what I did, you can do (don't add a third edge between 0 and 1 in this example. There is an error in `is_clique`: #25696):
> {{{
> sage: G = Graph([(0, 1), (0, 1), (0, 3), (1, 2), (2, 3)], multiedges=True)
> sage: spqr_tree(G)
> SPQR-tree of : Graph on 2 vertices
> sage: spqr_tree(G).edges()
> [(('P', Multi-graph on 2 vertices), ('S', Multi-graph on 4 vertices), None)]
> }}}
> I think the code is simpler and we return only what we need = the SPQR tree. Do you agree or you think something is missing ?
Yes, SPQR-Tree is sufficient as all blocks with edges are covered in it.
> 
> At some point, we will need a function that reconstruct a graph from a SPQR tree.
Is it for verification?


---

Comment by dcoudert created at 2018-06-28 18:33:36

> > I think the code is simpler and we return only what we need = the SPQR tree. Do you agree or you think something is missing ?
> Yes, SPQR-Tree is sufficient as all blocks with edges are covered in it.

So you can improve the last parts of the method in this way and update the examples and tests ?

> > At some point, we will need a function that reconstruct a graph from a SPQR tree.
> Is it for verification?
Yes. It can be an internal method of `connectivity.pyx`. Then we can reconstruct and check that the resulting graph is isomorphic to the original one.


---

Comment by git created at 2018-06-28 20:03:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-06-28 20:22:14

Replying to [comment:78 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[fdae153](https://git.sagemath.org/sage.git/commit/?id=fdae15359d6813b2a1fa4e7f1947ce0fa99c80d7)||`Updated examples and output definition`||
Is there is a way we can future improve the tree creation? \\
Updated the examples and removed few unused statements.


---

Comment by dcoudert created at 2018-06-29 06:45:03

The merging of cycles is not working well :(

```
sage: G = Graph(2)
sage: for _ in range(3):
....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])
....:     
sage: H = spqr_tree(G)
sage: H.order()
8
sage: for u in H:
....:     print u[0],u[1].vertices()
....:     
P [1, 4]
S [0, 1, 2]
P [1, 2]
S [0, 1, 6, 7]
S [1, 2, 3]
P [0, 1]
S [0, 1, 4]
S [1, 4, 5]
```



---

Comment by saiharsh created at 2018-06-29 18:15:19

Replying to [comment:80 dcoudert]:
> The merging of cycles is not working well :(
> {{{
> sage: G = Graph(2)
> sage: for _ in range(3):
> ....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])
> ....:     
> sage: H = spqr_tree(G)
> sage: H.order()
> 8
> sage: for u in H:
> ....:     print u[0],u[1].vertices()
> ....:     
> P [1, 4]
> S [0, 1, 2]
> P [1, 2]
> S [0, 1, 6, 7]
> S [1, 2, 3]
> P [0, 1]
> S [0, 1, 4]
> S [1, 4, 5]
> }}}
Is the problem is there are not sorted? \\
any problem in accessing vertices like this

```
sage: G = Graph(2)
sage: for _ in range(3):
....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])
....:     
sage: H = spqr_tree(G)
sage: H.order() 
10
sage: for u in H.vertices():
....:     print u[0], u[1].vertices()
....:     
P [0, 7]
P [1, 2]
P [0, 5]
P [0, 1]
S [0, 6, 7]
S [0, 1, 7]
S [0, 4, 5]
S [0, 1, 5]
S [1, 2, 3]
S [0, 1, 2]
```



---

Comment by dcoudert created at 2018-06-29 21:45:45

No. I expect the SPQR tree to have 1 P block and 3 S blocks. We have more, meaning that the merging of cycles is not well done.


---

Comment by git created at 2018-06-30 13:18:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-06-30 13:29:49

I did multiple changes in the code. Some parts were not clear to me. The main change is to separate the manipulation of the multiedges of the original graph from the cocycle edges. I have also changed some data structure to have easier stuff to manipulate. I think that the merging of cycles is now correct. Also, the construction of the graph is easier the way I did it (*).

TODO:
- check the code carefully. Some additional comments might be needed, and I may have missed some cases.
- check that the number of edges in the P blocks is what we expect. 
- do many tests to check if it's working. We could add extra examples / tests. For instance, we could add a test with `G = graphs.Grid2dGraph(2, 5)`, or the graph of the wikipedia page, etc.

(*) I raised an issue in the immutable graph backend. I don't know if we should open a ticket to change this behavior, possibly with a deprecation warning. We can't do it in this ticket.


---

Comment by saiharsh created at 2018-07-01 22:22:46

Replying to [comment:84 dcoudert]:
> I did multiple changes in the code. Some parts were not clear to me. The main change is to separate the manipulation of the multiedges of the original graph from the cocycle edges. I have also changed some data structure to have easier stuff to manipulate. I think that the merging of cycles is now correct. Also, the construction of the graph is easier the way I did it (*).
Yes, the changes preform better. \\
I was trying to get a verification way to cross-check the results but couldn't find a good way to reconstruct the graph from the `Tree` as we are adding few edges.
could you say is there a good way to reconstruct `G` from `Tree`?\\
I am trying `OGDF` for `SPQR-Tree` but getting few issues.\\
> 
> TODO:
> - check the code carefully. Some additional comments might be needed, and I may have missed some cases.
Yes, I will try.
> - check that the number of edges in the P blocks is what we expect. 
> - do many tests to check if it's working. We could add extra examples / tests. For instance, we could add a test with `G = graphs.Grid2dGraph(2, 5)`, or the graph of the wikipedia page, etc.
> 
Yes, I will test on some standard examples(in reference papers), update you on this.

> (*) I raised an issue in the immutable graph backend. I don't know if we should open a ticket to change this behavior, possibly with a deprecation warning. We can't do it in this ticket.
in my view, If it helps others by adding deprecation warning then we can open a ticket for it.


---

Comment by git created at 2018-07-04 11:14:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-07-04 11:20:59

I added method `spqr_tree_to_graph`. It is useful to check that the construction is correct.
On the way I solved an issue with the number of edges in the P blocks. It should now be OK.

=> Please check again the code and test these methods with various examples. If you find errors / typos / etc. correct them.


---

Comment by dcoudert created at 2018-07-04 11:20:59

Changing status from new to needs_review.


---

Comment by saiharsh created at 2018-07-04 20:59:07

Replying to [comment:87 dcoudert]:
> I added method `spqr_tree_to_graph`. It is useful to check that the construction is correct.
> On the way I solved an issue with the number of edges in the P blocks. It should now be OK.
Yes, it's okay now, on the last version, I found only two counter case, in which the number of `S` and `P` block is (4, 2) which is expected to be (9, 8), verified by OGDF code. this occurred on the example graph provided by Hopcroft paper, that 4 S components are found by breaking 2 squares into 4 triangles by using 2 cut edges. But the current version is giving the correct answer now. \\
The second example was on a graph which is formed by combining 4 cycles of length 4, in which the previous version was giving 0 `S components` and the current version is giving the correct answer.

> 
> => Please check again the code and test these methods with various examples. If you find errors / typos / etc. correct them.

Added the reference paper example to `spqr_tree_to_graph` function, it's the same graph on which the last version failed. \\
And a very minor change in `spqr_tree` examples.

For the below graph there is a miss match in OGDF output and current version.
for Graph,

```
sage: G = graphs.CycleGraph(4)
sage: G.allow_multiple_edges(True)
sage: G.add_edges([(0, 2), (0, 2)])
sage: T = spqr_tree(G)
sage: T.vertices()
[('R', Cycle graph: Multi-graph on 4 vertices)]
```

OGDF says it should have 2 `S components` and 2 `P components`. but both seems to be correct. 
Except for this example, I feel everything is fine.


---

Comment by git created at 2018-07-04 21:02:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-07-04 21:45:41

> Added the reference paper example to `spqr_tree_to_graph` function, it's the same graph on which the last version failed. \\

You should add the link using `:wikipedia:`SPQR_tree``

> And a very minor change in `spqr_tree` examples.

Why did you change this way ?

```
-        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'R')
+        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'S')
```

 a K4 is 3 connected, so it is a 'R' block, not a 'S' block.

 
> For the below graph there is a miss match in OGDF output and current version.
> for Graph,
> {{{
> sage: G = graphs.CycleGraph(4)
> sage: G.allow_multiple_edges(True)
> sage: G.add_edges([(0, 2), (0, 2)])
> sage: T = spqr_tree(G)
> sage: T.vertices()
> [('R', Cycle graph: Multi-graph on 4 vertices)]
> }}}
> OGDF says it should have 2 `S components` and 2 `P components`. but both seems to be correct. 
> Except for this example, I feel everything is fine.

It's due to `is_clique`, as reported in #25696. The graph has 4 vertices and 6 edges...

You can rebase this ticket on top of #25696 and add the dependency. Then the example should work properly.

One case has not been treated yet: `Q` blocks when `G` is a single edge.


---

Comment by saiharsh created at 2018-07-04 22:09:17

Replying to [comment:90 dcoudert]:
> > Added the reference paper example to `spqr_tree_to_graph` function, it's the same graph on which the last version failed. \\
> 
> You should add the link using `:wikipedia:`SPQR_tree``
Yes added.

> > And a very minor change in `spqr_tree` examples.
> 
> Why did you change this way ?
> {{{
> -        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'R')
> +        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'S')
> }}}
>  a K4 is 3 connected, so it is a 'R' block, not a 'S' block.
Yes, it should be `R` not `S`, as S contains cycles. my mistake.
>  

> 
> It's due to `is_clique`, as reported in #25696. The graph has 4 vertices and 6 edges...
> 
> You can rebase this ticket on top of #25696 and add the dependency. Then the example should work properly.
> 
I will rebase and try it.
> One case has not been treated yet: `Q` blocks when `G` is a single edge.
Yes, all the examples are taken such that no `Q` block exists.


---

Comment by git created at 2018-07-04 22:09:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-07 15:20:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-07-07 15:23:19

`@`Meghana: can you do some tests ? This patch is almost ready, but we may have missed some cases.


---

Comment by meghanamreddy created at 2018-07-11 10:23:40

Replying to [comment:94 dcoudert]:
> `@`Meghana: can you do some tests ? This patch is almost ready, but we may have missed some cases.

Yes, I have been doing some tests. It seems correct with all the various test cases I checked till now. I am going through the code now. I will update if I find any errors.


---

Comment by meghanamreddy created at 2018-07-11 12:45:10

Can we add an example in the `cleave` function to show the usage of the parameter `virtual_edges`? Also, in which use case would we set the parameter to False? I was not sure about the use case since the definition of `virtual_edges` used in the `cleave` function is different from what we use in the linear time algorithm.


---

Comment by dcoudert created at 2018-07-11 12:58:31

Replying to [comment:96 meghanamreddy]:
> Can we add an example in the `cleave` function to show the usage of the parameter `virtual_edges`? 

Sure. 

`@`Say Harsh: can you do that ?

> Also, in which use case would we set the parameter to False? I was not sure about the use case since the definition of `virtual_edges` used in the `cleave` function is different from what we use in the linear time algorithm.

The way we implemented the `cleave` method is more general than for our needs only. It can be useful to set `virtual_edges=False` when you want the subgraphs induced by the cut. If `S` is the set of vertices of the cut, and `A` and `B` are the sets of vertices of connected components in `G-S`, then we get `G[A+S]` and `G[B+S]` with only edges from `G`.


---

Comment by saiharsh created at 2018-07-11 13:12:30

Replying to [comment:97 dcoudert]:

> `@`Say Harsh: can you do that ?
Yes, I will do that.


---

Comment by meghanamreddy created at 2018-07-11 14:06:06

> The way we implemented the `cleave` method is more general than for our needs only. It can be useful to set `virtual_edges=False` when you want the subgraphs induced by the cut. If `S` is the set of vertices of the cut, and `A` and `B` are the sets of vertices of connected components in `G-S`, then we get `G[A+S]` and `G[B+S]` with only edges from `G`.

Ok, I understood now.

I was using the following example of a cycle on `5` vertices to test the parameter `virtual_edges`:

```
G = Graph()
G.add_edges([(1,2),(1,5),(2,4),(3,4),(3,5)])
S,C,f = cleave(G, cut_vertices=[1,2,3], virtual_edges=True)
```

In the case where `virtual_edges` is set to True, `f` is a path graph on `3` vertices. In the case where it is set to False, it is a graph with `3` isolated vertices. However, according to the definition of `f`, 
    `f` is the complement of the subgraph of `G` induced by the vertex cut. Hence, its vertex set is the vertex cut, and its edge set is the set of virtual edges.

Hence, when `virtual_edges` is set to False, `f` in the above example should be a graph on vertices `1,2 and 3` with one edge between `2` and `3` (which is the complement of the subgraph). I am not sure what the output should be when `virtual_edges` is set to true.


---

Comment by git created at 2018-07-11 15:33:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-07-11 15:56:55

> I was using the following example of a cycle on `5` vertices to test the parameter `virtual_edges`:
...
> Hence, when `virtual_edges` is set to False, `f` in the above example should be a graph on vertices `1,2 and 3` with one edge between `2` and `3` (which is the complement of the subgraph). I am not sure what the output should be when `virtual_edges` is set to true.

When `virtual_edges==False`, we don't add virtual edges to the sides of the cut. `f` is the graph containing only the virtual edges, so when we don't add virtual edges, `f` has no edges. When `virtual_edges==True`, then `f` is the complement of the subgraph induced by the cut. We should update the documentation accordingly.

Concerning last commit: 
The convention in Sagemath is to write `Return the connected components...` and not `Returns the connected components...`.
It has not yet been unified. We change it step by step.


---

Comment by git created at 2018-07-11 17:16:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saiharsh created at 2018-07-11 17:22:41

Replying to [comment:102 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[a6f2a5a](https://git.sagemath.org/sage.git/commit/?id=a6f2a5ab5fe881193b4f081f9b0abf599ff872a9)||`Virtual edge case added`||
We will have the same output for virtual_edge == True and False if the complement subgraph of cut vertices has no edges, which means subgraph of cut vertices is a complete graph. \\

And yes, `f` has no virtual edge when `virtual_edge == False` we can see it at virtual edges set to the false case in example.


---

Comment by meghanamreddy created at 2018-07-11 19:01:19

> When `virtual_edges==False`, we don't add virtual edges to the sides of the cut. `f` is the graph containing only the virtual edges, so when we don't add virtual edges, `f` has no edges. When `virtual_edges==True`, then `f` is the complement of the subgraph induced by the cut. We should update the documentation accordingly.

In the example I considered, when `virtual_edges==True`, the virtual edges that are added are `(1,3)` and `(2,3)`. So when `virtual_edges==True`, `f` is the complement of the subgraph induced by the cut? Or `f` is the graph containing only the virtual edges? If it is the former, `f` would be a graph on `3` vertices with one edge between `(2,3)`. If it is the latter, `f` would be a path graph on three vertices. Currently, the output `f` is a path graph on `3` vertices. 

I know I am asking too many times, but I would like to update the documentation to make it more clear.

> 
> Concerning last commit: 
> The convention in Sagemath is to write `Return the connected components...` and not `Returns the connected components...`.
> It has not yet been unified. We change it step by step.
My mistake, I saw in `generic_graph.py` and followed the same. I will change it.


---

Comment by git created at 2018-07-12 05:32:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-07-12 07:20:52

As said Sai Harsh, when 
* `virtual_edges == True`, `f` contains all the virtual edges which are the edges of the complement of the subgraph of `G` induced by the cut. In your example, it is a path graph with edges `(1,3)` and `(2, 3)`.
* `virtual_edges == False`, `f` is an independent set, so a graph containing only the vertices of the cut and no edge.


---

Comment by meghanamreddy created at 2018-07-12 07:42:06

Okay, I understood now. I had done a silly mistake in my previous question, my bad, sorry for the repeated questions.

I ran many test cases on the `sqpr_tree` and `spqr_tree_to_graph` functions, and there seemed to be no errors.


---

Comment by git created at 2018-07-13 11:22:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-07-13 11:26:22

Minor edits so that the doc build properly.


---

Comment by dcoudert created at 2018-07-13 17:36:22

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2018-07-13 17:36:22

For me this patch is now good to go !


---

Comment by vbraun created at 2018-08-11 16:55:08

Resolution: fixed
