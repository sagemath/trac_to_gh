# Issue 21920: Add SPQR-tree decomposition for 2-vertex-connected graphs

archive/issues_021920.json:
```json
{
    "body": "CC:  @dcoudert @meghanamreddy saiharsh\n\nKeywords: connectivity, decomposition\n\nAddition of a method spqr_tree() to generic_graph.py to decompose a 2-vertex-connected graph into cycles, cocycles, and 3-vertex-connected blocks.\n\nIssue created by migration from https://trac.sagemath.org/ticket/22157\n\n",
    "created_at": "2017-01-09T05:46:19Z",
    "labels": [
        "graph theory",
        "minor",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.4",
    "title": "Add SPQR-tree decomposition for 2-vertex-connected graphs",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21920",
    "user": "jfallon"
}
```
CC:  @dcoudert @meghanamreddy saiharsh

Keywords: connectivity, decomposition

Addition of a method spqr_tree() to generic_graph.py to decompose a 2-vertex-connected graph into cycles, cocycles, and 3-vertex-connected blocks.

Issue created by migration from https://trac.sagemath.org/ticket/22157





---

archive/issue_comments_304281.json:
```json
{
    "body": "I'll be happy to help reviewing this method.",
    "created_at": "2017-01-09T14:58:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304281",
    "user": "@dcoudert"
}
```

I'll be happy to help reviewing this method.



---

archive/issue_comments_304282.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-01-09T18:43:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304282",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304283.json:
```json
{
    "body": "When I look at the code, I see many many modifications in various functions. I hope it is only a side effect of the tool to see the commits and that you have only touch methods `twosplit` and `spqr_tree`.\n\nThe proposed method is far from being a linear time algorithm. Although I was not expecting the implementation to perfectly follow the time complexity, and we are for sure more interested by the functionality than by it's running time, I'm surprised that you use methods such as `vertex_connectivity` or `is_isomorphic`. You have also lots of graph copies and such operations are also time consuming. I fear that this code will be usable only for small graphs, while it would be very useful for graphs with thousands of nodes.\n\nCould you add more comments in the code. So far it is really hard to follow what you are doing and why. Thanks.",
    "created_at": "2017-01-10T12:10:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304283",
    "user": "@dcoudert"
}
```

When I look at the code, I see many many modifications in various functions. I hope it is only a side effect of the tool to see the commits and that you have only touch methods `twosplit` and `spqr_tree`.

The proposed method is far from being a linear time algorithm. Although I was not expecting the implementation to perfectly follow the time complexity, and we are for sure more interested by the functionality than by it's running time, I'm surprised that you use methods such as `vertex_connectivity` or `is_isomorphic`. You have also lots of graph copies and such operations are also time consuming. I fear that this code will be usable only for small graphs, while it would be very useful for graphs with thousands of nodes.

Could you add more comments in the code. So far it is really hard to follow what you are doing and why. Thanks.



---

archive/issue_comments_304284.json:
```json
{
    "body": "Regarding the other functions, all I have done to the generic_graph.py file is to paste in the two functions; I have not touched anything else. Given the complexity cost of calling other functions, it seems best to accomplish the transition from crude to code by overhaul; adding comments to the current content will be time best spent making large improvements. The function did what I needed as a helper for a larger function; for contribution to Sage it needs better treatment.",
    "created_at": "2017-01-10T16:11:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304284",
    "user": "jfallon"
}
```

Regarding the other functions, all I have done to the generic_graph.py file is to paste in the two functions; I have not touched anything else. Given the complexity cost of calling other functions, it seems best to accomplish the transition from crude to code by overhaul; adding comments to the current content will be time best spent making large improvements. The function did what I needed as a helper for a larger function; for contribution to Sage it needs better treatment.



---

archive/issue_comments_304285.json:
```json
{
    "body": "If I understand well, your first objective is to have a method returning a `SPQR-tree`, but you don't need this method to be fast and you are not planning yet to implement best possible method. This is perfectly understandable and in such case we need to add a warning or todo flag explaining that a faster algorithm could be implemented.\n\nsome remarks:\n\nIn method `twosplit` you can avoid calling twice `vertex_connectivity`. First call `cut_size,cut_vertices = self.vertex_connectivity(value_only=False)` and then check if `cut_size != 2`.\n\nIn method `spqr_tree`, you can avoid a call to `vertex_connectivity` doing `if not self.is_connected() and len(self.blocks_and_cut_vertices()[1]) > 0: ...`.\n\nWe can certainly make a small method to check that `A` is a cycle. For instance `if A.order()==A.size() and min(A.degree())==max(A.degree() and A.is_connected()` ? Unfortunately, no such method has been added to `graph_classes` yet.\n\nYou don't need to call `GraphGenerators.EmptyGraph()`. You can call directly `Graph(multiedges=True)` if you want to allow multi edges.\n\nInstead of `e in SPR[i].edges(labels = False)` you could test `SPR[i].has_edge(e)`. Many times.",
    "created_at": "2017-01-11T16:50:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304285",
    "user": "@dcoudert"
}
```

If I understand well, your first objective is to have a method returning a `SPQR-tree`, but you don't need this method to be fast and you are not planning yet to implement best possible method. This is perfectly understandable and in such case we need to add a warning or todo flag explaining that a faster algorithm could be implemented.

some remarks:

In method `twosplit` you can avoid calling twice `vertex_connectivity`. First call `cut_size,cut_vertices = self.vertex_connectivity(value_only=False)` and then check if `cut_size != 2`.

In method `spqr_tree`, you can avoid a call to `vertex_connectivity` doing `if not self.is_connected() and len(self.blocks_and_cut_vertices()[1]) > 0: ...`.

We can certainly make a small method to check that `A` is a cycle. For instance `if A.order()==A.size() and min(A.degree())==max(A.degree() and A.is_connected()` ? Unfortunately, no such method has been added to `graph_classes` yet.

You don't need to call `GraphGenerators.EmptyGraph()`. You can call directly `Graph(multiedges=True)` if you want to allow multi edges.

Instead of `e in SPR[i].edges(labels = False)` you could test `SPR[i].has_edge(e)`. Many times.



---

archive/issue_comments_304286.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-01-13T05:12:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304286",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304287.json:
```json
{
    "body": "Some proposals to improve method `twosplit`.\n* the name of the method is not appropriate. It should be at least `two_split` or something more clear\n* You can use method `self._scream_if_not_simple()` to avoid adding your own tests.\n* `virtual_edge = (cut_vertices[0],cut_vertices[1])` -> `virtual_edge = tuple(cut_vertices)`\n* Instead of `H = self.subgraph(vertices = [v for v in self.vertices() if v not in cut_vertices])` you can do the following which should be slightly faster: \n\n```\nH = Graph(self.edges(labels=False))\nH.delete_vertices(cut_vertices)\n```\n\n* In loop `for K in CC:...` you can do that, thus saving a useless creation of a subgraph (graph copies and taking subgraph can be a long operation):\n\n```\n    cut_sides = []\n    for K in CC:\n        for u in cut_vertices:\n            K.add_edges([(u,v) for v in self.neighbor_iterator(u) if v in K])\n        K.allow_multiple_edges(True) ## why do we need that ???\n        if not K.has_edge(virtual_edge):\n            K.add_edge(virtual_edge)\n        cut_sides.append(K)\n```\n\n* The loop `for i in range(Comps + 1): cocycles.add_edge(virtual_edge)` could be replaced with `cocycles.add_edges([virtual_edge]*(Comps+1))`. Very similar in fact.\n* Also, do not hesitate to add an empty line between important blocs of code/comments to ease the readability.\n\n\nOverall, the method should be something like that:\n\n```\n    from sage.graphs.graph import Graph\n    self._scream_if_not_simple()\n\n    cut_size,cut_vertices = self.vertex_connectivity(value_only = False)\n    if cut_size != 2:\n        raise NotImplementedError(\"twosplit is only implemented on graphs with vertex connectivity 2\")\n\n    H = Graph(self.edges(labels=False))\n    H.delete_vertices(cut_vertices)\n\n    virtual_edge = tuple(cut_vertices)    \n    CC = H.connected_components_subgraphs()\n    Comps = len(CC)\n\n    # deletion of separating pair leaves connected components;\n    # we add to each of those components a virtual edge\n    # between the separating pair and restore edges incident to them\n    cut_sides = []\n    for K in CC:\n        for u in cut_vertices:\n            K.add_edges([(u,v) for v in self.neighbor_iterator(u) if v in K])\n        K.allow_multiple_edges(True) ## why ???\n        if not K.has_edge(virtual_edge):\n            K.add_edge(virtual_edge)\n        cut_sides.append(K)\n\n    # if the original graph has an edge between the separating pair\n    # of vertices, a bond with one edge more than the number of \n    # auxiliary graphs is needed for re-assembly\n    cocycles = Graph(multiedges=True)\n    if self.has_edge(virtual_edge):\n        cocycles.add_edges([virtual_edge]*(Comps+1))\n\n    # if the original graph has no edge between the separating pair\n    # of vertices but deletion of the separating pair leaves\n    # more than two components, a bond with one edge per component\n    # is needed for re-assembly\n    elif Comps > 2:\n        cocycles.add_edges([virtual_edge]*Comps)\n\n    return cut_sides,cocycles,virtual_edge\n```\n\n\nOf course, the modifications I proposed are not helpful to speed up the code. We need a palm-tree and the appropriate algorithm for that...",
    "created_at": "2017-01-14T17:43:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304287",
    "user": "@dcoudert"
}
```

Some proposals to improve method `twosplit`.
* the name of the method is not appropriate. It should be at least `two_split` or something more clear
* You can use method `self._scream_if_not_simple()` to avoid adding your own tests.
* `virtual_edge = (cut_vertices[0],cut_vertices[1])` -> `virtual_edge = tuple(cut_vertices)`
* Instead of `H = self.subgraph(vertices = [v for v in self.vertices() if v not in cut_vertices])` you can do the following which should be slightly faster: 

```
H = Graph(self.edges(labels=False))
H.delete_vertices(cut_vertices)
```

* In loop `for K in CC:...` you can do that, thus saving a useless creation of a subgraph (graph copies and taking subgraph can be a long operation):

```
    cut_sides = []
    for K in CC:
        for u in cut_vertices:
            K.add_edges([(u,v) for v in self.neighbor_iterator(u) if v in K])
        K.allow_multiple_edges(True) ## why do we need that ???
        if not K.has_edge(virtual_edge):
            K.add_edge(virtual_edge)
        cut_sides.append(K)
```

* The loop `for i in range(Comps + 1): cocycles.add_edge(virtual_edge)` could be replaced with `cocycles.add_edges([virtual_edge]*(Comps+1))`. Very similar in fact.
* Also, do not hesitate to add an empty line between important blocs of code/comments to ease the readability.


Overall, the method should be something like that:

```
    from sage.graphs.graph import Graph
    self._scream_if_not_simple()

    cut_size,cut_vertices = self.vertex_connectivity(value_only = False)
    if cut_size != 2:
        raise NotImplementedError("twosplit is only implemented on graphs with vertex connectivity 2")

    H = Graph(self.edges(labels=False))
    H.delete_vertices(cut_vertices)

    virtual_edge = tuple(cut_vertices)    
    CC = H.connected_components_subgraphs()
    Comps = len(CC)

    # deletion of separating pair leaves connected components;
    # we add to each of those components a virtual edge
    # between the separating pair and restore edges incident to them
    cut_sides = []
    for K in CC:
        for u in cut_vertices:
            K.add_edges([(u,v) for v in self.neighbor_iterator(u) if v in K])
        K.allow_multiple_edges(True) ## why ???
        if not K.has_edge(virtual_edge):
            K.add_edge(virtual_edge)
        cut_sides.append(K)

    # if the original graph has an edge between the separating pair
    # of vertices, a bond with one edge more than the number of 
    # auxiliary graphs is needed for re-assembly
    cocycles = Graph(multiedges=True)
    if self.has_edge(virtual_edge):
        cocycles.add_edges([virtual_edge]*(Comps+1))

    # if the original graph has no edge between the separating pair
    # of vertices but deletion of the separating pair leaves
    # more than two components, a bond with one edge per component
    # is needed for re-assembly
    elif Comps > 2:
        cocycles.add_edges([virtual_edge]*Comps)

    return cut_sides,cocycles,virtual_edge
```


Of course, the modifications I proposed are not helpful to speed up the code. We need a palm-tree and the appropriate algorithm for that...



---

archive/issue_comments_304288.json:
```json
{
    "body": "Any news on this ticket? It would be very useful to have this method.",
    "created_at": "2017-10-21T09:27:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304288",
    "user": "@dcoudert"
}
```

Any news on this ticket? It would be very useful to have this method.



---

archive/issue_comments_304289.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-30T18:11:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304289",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304290.json:
```json
{
    "body": "Could anyone explain me the current status of this ticket, how far it's completed? and what are the gaps?",
    "created_at": "2018-03-22T21:11:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304290",
    "user": "saiharsh"
}
```

Could anyone explain me the current status of this ticket, how far it's completed? and what are the gaps?



---

archive/issue_comments_304291.json:
```json
{
    "body": "The proposed patch implements a slow version of the decomposition of a graph into 3 connected components. It must be rebased on last beta, and the proposed methods must be moved to `graph.py` since it is for undirected graphs only.",
    "created_at": "2018-03-24T08:58:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304291",
    "user": "@dcoudert"
}
```

The proposed patch implements a slow version of the decomposition of a graph into 3 connected components. It must be rebased on last beta, and the proposed methods must be moved to `graph.py` since it is for undirected graphs only.



---

archive/issue_comments_304292.json:
```json
{
    "body": "New commits:",
    "created_at": "2018-05-25T10:16:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304292",
    "user": "saiharsh"
}
```

New commits:



---

archive/issue_comments_304293.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-25T10:40:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304293",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304294.json:
```json
{
    "body": "Your patch does not pass tests.\nIn the multigraph example, you must add `multiedges=True`, so\n\n```\nsage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)\n```\n\n\nFurthermore, have you checked that the returned solutions are correct ?\nIn the subgraphs, some multiple edges are presents but some are missing.\n\n```\nsage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)\nsage: S,C,f = G.cleave()\nsage: for g in S:\n....:     print(g.edges(labels=0))\n....: \n[(0, 1), (0, 1), (0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)]\n[(2, 4), (2, 6), (4, 6)]\n[(2, 4), (2, 7), (4, 7)]\n```\n\n\nI do prefer the following example, easier to check:\n\n```\nsage: G = graphs.CompleteBipartiteGraph(2,3)\nsage: G.add_edge(2, 3)\nsage: G.allow_multiple_edges(True)\nsage: G.add_edges(G.edges())\nsage: S,C,f = G.cleave()\nsage: for g in S:\n....:     print(g.edges(labels=0))\n....:     \n[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (2, 3)]\n[(0, 1), (0, 4), (1, 4)]\n```\n\nIt seems the problem is with multiple edges incident to a cut vertex.",
    "created_at": "2018-05-26T12:03:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304294",
    "user": "@dcoudert"
}
```

Your patch does not pass tests.
In the multigraph example, you must add `multiedges=True`, so

```
sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)
```


Furthermore, have you checked that the returned solutions are correct ?
In the subgraphs, some multiple edges are presents but some are missing.

```
sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)
sage: S,C,f = G.cleave()
sage: for g in S:
....:     print(g.edges(labels=0))
....: 
[(0, 1), (0, 1), (0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)]
[(2, 4), (2, 6), (4, 6)]
[(2, 4), (2, 7), (4, 7)]
```


I do prefer the following example, easier to check:

```
sage: G = graphs.CompleteBipartiteGraph(2,3)
sage: G.add_edge(2, 3)
sage: G.allow_multiple_edges(True)
sage: G.add_edges(G.edges())
sage: S,C,f = G.cleave()
sage: for g in S:
....:     print(g.edges(labels=0))
....:     
[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (2, 3)]
[(0, 1), (0, 4), (1, 4)]
```

It seems the problem is with multiple edges incident to a cut vertex.



---

archive/issue_comments_304295.json:
```json
{
    "body": "Replying to [comment:18 dcoudert]:\n> Your patch does not pass tests.\n> In the multigraph example, you must add `multiedges=True`, so\n> {{{\n> sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)\n> }}}\n> \n> Furthermore, have you checked that the returned solutions are correct ?\n> In the subgraphs, some multiple edges are presents but some are missing.\n> {{{\n> sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)\n> sage: S,C,f = G.cleave()\n> sage: for g in S:\n> ....:     print(g.edges(labels=0))\n> ....: \n> [(0, 1), (0, 1), (0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)]\n> [(2, 4), (2, 6), (4, 6)]\n> [(2, 4), (2, 7), (4, 7)]\n> }}}\n> \n> I do prefer the following example, easier to check:\n> {{{\n> sage: G = graphs.CompleteBipartiteGraph(2,3)\n> sage: G.add_edge(2, 3)\n> sage: G.allow_multiple_edges(True)\n> sage: G.add_edges(G.edges())\n> sage: S,C,f = G.cleave()\n> sage: for g in S:\n> ....:     print(g.edges(labels=0))\n> ....:     \n> [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (2, 3)]\n> [(0, 1), (0, 4), (1, 4)]\n> }}}\n> It seems the problem is with multiple edges incident to a cut vertex.\nYes, there are few edges missing in `S` because we are adding only one edge in a component between `u` and cut vertex even if there are multiple edges between them. Please see below.\n\n```\nfor u in cut_vertices:\n    component.add_edges([(u,v) for v in G.neighbor_iterator(u) if v in componentVertices])\n```\n\n\\\\\nShall I iterate over cut vertices edges using `G.edge_iterator` and add edges like below.\n\n```\nfor u in cut_vertices:\n    component.add_edges([(u,e[1]) for e in G.edge_iterator(u) if e[1] in componentVertices])\n```\n\nOr is there any better way to find number of multiple edges between `u` and `v`. \\\\\n\\\\\nI feel the `cocycles` if there is an edge between the separating pair then it should be like\n\n```\ncocycles.add_edges([virtual_edge]*(Comps+(number of multiple edges between cutvertices)))\n```\n\nPlease let me know if I am wrong.",
    "created_at": "2018-05-27T09:25:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304295",
    "user": "saiharsh"
}
```

Replying to [comment:18 dcoudert]:
> Your patch does not pass tests.
> In the multigraph example, you must add `multiedges=True`, so
> {{{
> sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)
> }}}
> 
> Furthermore, have you checked that the returned solutions are correct ?
> In the subgraphs, some multiple edges are presents but some are missing.
> {{{
> sage: G = Graph({0:[1,1,1,2,3],1:[4,5],2:[3,3],3:[5],4:[5],6:[2,4],7:[2,2,4,4]}, multiedges=True)
> sage: S,C,f = G.cleave()
> sage: for g in S:
> ....:     print(g.edges(labels=0))
> ....: 
> [(0, 1), (0, 1), (0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)]
> [(2, 4), (2, 6), (4, 6)]
> [(2, 4), (2, 7), (4, 7)]
> }}}
> 
> I do prefer the following example, easier to check:
> {{{
> sage: G = graphs.CompleteBipartiteGraph(2,3)
> sage: G.add_edge(2, 3)
> sage: G.allow_multiple_edges(True)
> sage: G.add_edges(G.edges())
> sage: S,C,f = G.cleave()
> sage: for g in S:
> ....:     print(g.edges(labels=0))
> ....:     
> [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (2, 3)]
> [(0, 1), (0, 4), (1, 4)]
> }}}
> It seems the problem is with multiple edges incident to a cut vertex.
Yes, there are few edges missing in `S` because we are adding only one edge in a component between `u` and cut vertex even if there are multiple edges between them. Please see below.

```
for u in cut_vertices:
    component.add_edges([(u,v) for v in G.neighbor_iterator(u) if v in componentVertices])
```

\\
Shall I iterate over cut vertices edges using `G.edge_iterator` and add edges like below.

```
for u in cut_vertices:
    component.add_edges([(u,e[1]) for e in G.edge_iterator(u) if e[1] in componentVertices])
```

Or is there any better way to find number of multiple edges between `u` and `v`. \\
\\
I feel the `cocycles` if there is an edge between the separating pair then it should be like

```
cocycles.add_edges([virtual_edge]*(Comps+(number of multiple edges between cutvertices)))
```

Please let me know if I am wrong.



---

archive/issue_comments_304296.json:
```json
{
    "body": "> Shall I iterate over cut vertices edges using `G.edge_iterator` and add edges like below.\n> {{{\n> for u in cut_vertices:\n>     component.add_edges([(u,e[1]) for e in G.edge_iterator(u) if e[1] in componentVertices])\n> }}}\n\nYou can do directly:\n\n```\ncomponent.add_edges([e for e in G.edge_iterator(vertex=cut_vertices) if e[0] in componentVertices or e[1] in componentVertices])\n```\n\n\\\\\n\n> I feel the `cocycles` if there is an edge between the separating pair then it should be like\n> {{{\n> cocycles.add_edges([virtual_edge]*(Comps+(number of multiple edges between cutvertices)))\n> }}}\n> Please let me know if I am wrong. \n\nGood question. In fact, it might be even more. Indeed, you create a list of subgraphs, each corresponding to the vertices of a connected component in the graph minus the cut vertices, plus the cut vertices and edges between them.\nHence, if we have 2 edges between the cut vertices, we must also have 2 edges between these vertices in each subgraph.\n\nConsequently, the cocycle contains `(#comps + 1) * (number of multiple edges between cutvertices)` edges when we have edges between the cut vertices and `#comps` otherwise. \n\n\nDo not forget to correct all minor issues in the method like `if `G` is a biconnected..` -> `If `G` is a biconnected..`, in the description of the output you must say that `C` is `cocylcles`, etc.",
    "created_at": "2018-05-28T08:17:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304296",
    "user": "@dcoudert"
}
```

> Shall I iterate over cut vertices edges using `G.edge_iterator` and add edges like below.
> {{{
> for u in cut_vertices:
>     component.add_edges([(u,e[1]) for e in G.edge_iterator(u) if e[1] in componentVertices])
> }}}

You can do directly:

```
component.add_edges([e for e in G.edge_iterator(vertex=cut_vertices) if e[0] in componentVertices or e[1] in componentVertices])
```

\\

> I feel the `cocycles` if there is an edge between the separating pair then it should be like
> {{{
> cocycles.add_edges([virtual_edge]*(Comps+(number of multiple edges between cutvertices)))
> }}}
> Please let me know if I am wrong. 

Good question. In fact, it might be even more. Indeed, you create a list of subgraphs, each corresponding to the vertices of a connected component in the graph minus the cut vertices, plus the cut vertices and edges between them.
Hence, if we have 2 edges between the cut vertices, we must also have 2 edges between these vertices in each subgraph.

Consequently, the cocycle contains `(#comps + 1) * (number of multiple edges between cutvertices)` edges when we have edges between the cut vertices and `#comps` otherwise. 


Do not forget to correct all minor issues in the method like `if `G` is a biconnected..` -> `If `G` is a biconnected..`, in the description of the output you must say that `C` is `cocylcles`, etc.



---

archive/issue_comments_304297.json:
```json
{
    "body": "Replying to [comment:20 dcoudert]:\n> Good question. In fact, it might be even more. Indeed, you create a list of subgraphs, each corresponding to the vertices of a connected component in the graph minus the cut vertices, plus the cut vertices and edges between them.\n> Hence, if we have 2 edges between the cut vertices, we must also have 2 edges between these vertices in each subgraph.\nSorry, I am unable to understand, does it means if `G` has 3 edges between cut vertices then each connected component of H(after removing cut vertices in G) should have 3 virtual edges between cut vertices?\n\nIf no edge between cut vertices in G, it's clear, (#comps).\n \n> Do not forget to correct all minor issues in the method like `if `G` is a biconnected..` -> `If `G` is a biconnected..`, in the description of the output you must say that `C` is `cocylcles`, etc.\nYes I will and update it in next commit.",
    "created_at": "2018-05-28T09:24:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304297",
    "user": "saiharsh"
}
```

Replying to [comment:20 dcoudert]:
> Good question. In fact, it might be even more. Indeed, you create a list of subgraphs, each corresponding to the vertices of a connected component in the graph minus the cut vertices, plus the cut vertices and edges between them.
> Hence, if we have 2 edges between the cut vertices, we must also have 2 edges between these vertices in each subgraph.
Sorry, I am unable to understand, does it means if `G` has 3 edges between cut vertices then each connected component of H(after removing cut vertices in G) should have 3 virtual edges between cut vertices?

If no edge between cut vertices in G, it's clear, (#comps).
 
> Do not forget to correct all minor issues in the method like `if `G` is a biconnected..` -> `If `G` is a biconnected..`, in the description of the output you must say that `C` is `cocylcles`, etc.
Yes I will and update it in next commit.



---

archive/issue_comments_304298.json:
```json
{
    "body": "> Sorry, I am unable to understand, does it means if `G` has 3 edges between cut vertices then each connected component of H(after removing cut vertices in G) should have 3 virtual edges between cut vertices?\n\nIt's what I think.",
    "created_at": "2018-05-28T09:33:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304298",
    "user": "@dcoudert"
}
```

> Sorry, I am unable to understand, does it means if `G` has 3 edges between cut vertices then each connected component of H(after removing cut vertices in G) should have 3 virtual edges between cut vertices?

It's what I think.



---

archive/issue_comments_304299.json:
```json
{
    "body": "New commits:",
    "created_at": "2018-05-28T18:56:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304299",
    "user": "saiharsh"
}
```

New commits:



---

archive/issue_comments_304300.json:
```json
{
    "body": "It took sometime for updating it to latest beta version.\\\\\n\\\\\nI am using a variable `multiedges_bw_cutvertices` which stores the number of multiple edges between cut vertices in `G` and it's used to add number of virtual edges to each component.\\\\\nThe previous version add only one virtual edge.\n\n```\nif not component.has_edge(virtual_edge):\n    component.add_edges([virtual_edge]*multiedges_bw_cutvertices)\n```\n\n\nI am unable to understand why `cocycles` a dipole graph is not define when the connected components are 2? (Unable to find the supporting point)\n\n```\nelif Comps > 2:\n    cocycles.add_edges([virtual_edge]*Comps)\n```\n\n\nDo these examples are enough or we need to add more examples for cleave function?\n\nIn the next commit I will be updating spqr_tree function.",
    "created_at": "2018-05-29T06:14:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304300",
    "user": "saiharsh"
}
```

It took sometime for updating it to latest beta version.\\
\\
I am using a variable `multiedges_bw_cutvertices` which stores the number of multiple edges between cut vertices in `G` and it's used to add number of virtual edges to each component.\\
The previous version add only one virtual edge.

```
if not component.has_edge(virtual_edge):
    component.add_edges([virtual_edge]*multiedges_bw_cutvertices)
```


I am unable to understand why `cocycles` a dipole graph is not define when the connected components are 2? (Unable to find the supporting point)

```
elif Comps > 2:
    cocycles.add_edges([virtual_edge]*Comps)
```


Do these examples are enough or we need to add more examples for cleave function?

In the next commit I will be updating spqr_tree function.



---

archive/issue_comments_304301.json:
```json
{
    "body": "> I am unable to understand why `cocycles` a dipole graph is not define when the connected components are 2? (Unable to find the supporting point)\n\nI don't understand the question. Please give a clear example\n\n> In the next commit I will be updating spqr_tree function. \nOK\n\\\\\n\nYou can get the number of edges between cut vertices as \n\n```\nif self.has_edge(virtual_edge):\n   if self.has_multiple_edges():\n      multiedges_bw_cutvertices = len(self.edge_label(cut_vertices[0],cut_vertices[1]))\n   else:\n      multiedges_bw_cutvertices = 1\nelse:\n   multiedges_bw_cutvertices = 0\n```\n\n\nDo `component.allow_multiple_edges(True)` before adding edges to the component. Otherwise, multiedges will not be added",
    "created_at": "2018-05-29T15:39:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304301",
    "user": "@dcoudert"
}
```

> I am unable to understand why `cocycles` a dipole graph is not define when the connected components are 2? (Unable to find the supporting point)

I don't understand the question. Please give a clear example

> In the next commit I will be updating spqr_tree function. 
OK
\\

You can get the number of edges between cut vertices as 

```
if self.has_edge(virtual_edge):
   if self.has_multiple_edges():
      multiedges_bw_cutvertices = len(self.edge_label(cut_vertices[0],cut_vertices[1]))
   else:
      multiedges_bw_cutvertices = 1
else:
   multiedges_bw_cutvertices = 0
```


Do `component.allow_multiple_edges(True)` before adding edges to the component. Otherwise, multiedges will not be added



---

archive/issue_comments_304302.json:
```json
{
    "body": "Replying to [comment:25 dcoudert]:\n\n\n\\\\\nPlease see below lines.\n\n\n```\n        if self.has_edge(virtual_edge):\n            cocycles.add_edges([virtual_edge]*(Comps+1)*multiedges_bw_cutvertices)\n\n        elif Comps > 2:\n            cocycles.add_edges([virtual_edge]*Comps)\n```\n\n\nWhen we have connected components = 2 and `G` has no virtual edge then it neither enters in if condition nor in else condition. End up by returning an empty list for `cocycle`. is it correct? \\\\\n\nIf the number of connected components is 2 and there is not virtual edge present in `G`\nthen why we are not adding virtual edges to `cocycles`?",
    "created_at": "2018-05-29T15:58:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304302",
    "user": "saiharsh"
}
```

Replying to [comment:25 dcoudert]:


\\
Please see below lines.


```
        if self.has_edge(virtual_edge):
            cocycles.add_edges([virtual_edge]*(Comps+1)*multiedges_bw_cutvertices)

        elif Comps > 2:
            cocycles.add_edges([virtual_edge]*Comps)
```


When we have connected components = 2 and `G` has no virtual edge then it neither enters in if condition nor in else condition. End up by returning an empty list for `cocycle`. is it correct? \\

If the number of connected components is 2 and there is not virtual edge present in `G`
then why we are not adding virtual edges to `cocycles`?



---

archive/issue_comments_304303.json:
```json
{
    "body": "But you must add edges to the cocycle when `Comps >= 2` ! So please change.",
    "created_at": "2018-05-30T10:19:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304303",
    "user": "@dcoudert"
}
```

But you must add edges to the cocycle when `Comps >= 2` ! So please change.



---

archive/issue_comments_304304.json:
```json
{
    "body": "1. Cleave function is defined initially, knowing that input is always simple biconnected graph.\n2. As `A` is always simple according to `split_multiple_edges` algorithm in the reference paper, I feel there is no need to add `B.allow_multiple_edges(False)`.\n3. Currently, all the cycles are pushed to polygons(S-Block) but what if a cycle is tri connected i.e a triangle. I feel it need to be in `R-Block` instead of `S-Block`. Correct me, If I am wrong.\n\n4. According to `Theorem 1` in reference paper, the number of nodes in Tree need to be equal to the number of tri-connected components and the edges between nodes u,v exit only if the components u and v share the common edge. The current implementation is adding all the required edges and the generated tree seems to be correct, yet not found a counter case yet.\nIs there any simple way to verify the output tree?\n\\\\ \n\\\\\n5. I tried with few examples.\n\n```\nG = Graph({1:[2,3], 3:[2, 5], 2:[4], 6:[4,5]})\nG = Graph({0:[1,2,3],1:[4,5],2:[3],3:[5],4:[5],6:[2,4]})\n# Refernce Paper graph\nG = Graph({1:[2, 4, 8, 12, 13], 2:[1, 3, 13], 3:[2, 4, 13], 4:[1, 3, 7, 5], 5:[4, 6, 7, 8], 6:[5, 7], 7:[4, 5, 6], 8:[1, 5, 9, 11, 12], 9:[8, 10, 11, 12], 10:[9, 11, 12], 11:[8, 9, 10], 12:[1, 8, 9, 10]})\n```\n\nAFAIK, the output seems to be correct.\nPlease let me know the case in which it's giving an incorrect answer.\n6. There is a minor change in the `cleave function`, multiedges_bw_cutvertices -> num_virtual_edge_add, my bad I gave initially the incorrect name. \n`num_virtual_edge_add` says the number of virtual edges needs to be added to a component.",
    "created_at": "2018-06-03T17:27:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304304",
    "user": "saiharsh"
}
```

1. Cleave function is defined initially, knowing that input is always simple biconnected graph.
2. As `A` is always simple according to `split_multiple_edges` algorithm in the reference paper, I feel there is no need to add `B.allow_multiple_edges(False)`.
3. Currently, all the cycles are pushed to polygons(S-Block) but what if a cycle is tri connected i.e a triangle. I feel it need to be in `R-Block` instead of `S-Block`. Correct me, If I am wrong.

4. According to `Theorem 1` in reference paper, the number of nodes in Tree need to be equal to the number of tri-connected components and the edges between nodes u,v exit only if the components u and v share the common edge. The current implementation is adding all the required edges and the generated tree seems to be correct, yet not found a counter case yet.
Is there any simple way to verify the output tree?
\\ 
\\
5. I tried with few examples.

```
G = Graph({1:[2,3], 3:[2, 5], 2:[4], 6:[4,5]})
G = Graph({0:[1,2,3],1:[4,5],2:[3],3:[5],4:[5],6:[2,4]})
# Refernce Paper graph
G = Graph({1:[2, 4, 8, 12, 13], 2:[1, 3, 13], 3:[2, 4, 13], 4:[1, 3, 7, 5], 5:[4, 6, 7, 8], 6:[5, 7], 7:[4, 5, 6], 8:[1, 5, 9, 11, 12], 9:[8, 10, 11, 12], 10:[9, 11, 12], 11:[8, 9, 10], 12:[1, 8, 9, 10]})
```

AFAIK, the output seems to be correct.
Please let me know the case in which it's giving an incorrect answer.
6. There is a minor change in the `cleave function`, multiedges_bw_cutvertices -> num_virtual_edge_add, my bad I gave initially the incorrect name. 
`num_virtual_edge_add` says the number of virtual edges needs to be added to a component.



---

archive/issue_comments_304305.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-04T10:26:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304305",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304306.json:
```json
{
    "body": "Replying to [comment:29 git]:\n\nPlease test on this spqr-tree function and there is a minor change in the output definition.\nPrevious it return `(R,S,P,SPR,SPQR-tree)` \\\\\nNow it return      `(R,S,P,SPR,tricomp,SPQR-tree)` \\\\\nTri-Component is a list of tri-components from R and S block. As S-Block contains the only polygon so there is only one case in which a component is a cycle and tri-connected is Triangle.\n\n> ||[ad946da](https://git.sagemath.org/sage.git/commit/?id=ad946dabc60578979c80087a54aadf87fecbca30)||`First commit on SPQR-Tree`||",
    "created_at": "2018-06-04T10:33:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304306",
    "user": "saiharsh"
}
```

Replying to [comment:29 git]:

Please test on this spqr-tree function and there is a minor change in the output definition.
Previous it return `(R,S,P,SPR,SPQR-tree)` \\
Now it return      `(R,S,P,SPR,tricomp,SPQR-tree)` \\
Tri-Component is a list of tri-components from R and S block. As S-Block contains the only polygon so there is only one case in which a component is a cycle and tri-connected is Triangle.

> ||[ad946da](https://git.sagemath.org/sage.git/commit/?id=ad946dabc60578979c80087a54aadf87fecbca30)||`First commit on SPQR-Tree`||



---

archive/issue_comments_304307.json:
```json
{
    "body": "I cannot test yet. I had to do a `make dist-clean && make` after a system update. long time...\n\n- In `cleave`, the error message `\"G must be a biconnected graph.\"` is not appropriate. It can be used only if you test `if cut_size < 2`. But when `cut_size > 2`, it is better to say `\"G has no 2-vertex cut\"`  (without dot at the end of the sentence)\n\n- `R & S block` -> ``R` and `S` blocks`\n\n- do you think that the example `sage: G.spqr_tree()[1]` is useful ? I don't understand what we get. May be should should add explanation before that a graph build from a complete bipartite graph `2x5` with an edge joining the vertices of the side of order 2 is decomposed into 5 rigid blocks. However, the blocks are triangles...\\\\\n  This graph could be more informative. It is made of 3 `K_4` with edge `(0, 1)` in common.\n\n```\nsage: G = Graph(2)\nsage: for i in range(3):\n....:     G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])\n```\n\n  It will be split into 3 3-connected blocks, each isomorphic to a `K_4`.",
    "created_at": "2018-06-04T15:08:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304307",
    "user": "@dcoudert"
}
```

I cannot test yet. I had to do a `make dist-clean && make` after a system update. long time...

- In `cleave`, the error message `"G must be a biconnected graph."` is not appropriate. It can be used only if you test `if cut_size < 2`. But when `cut_size > 2`, it is better to say `"G has no 2-vertex cut"`  (without dot at the end of the sentence)

- `R & S block` -> ``R` and `S` blocks`

- do you think that the example `sage: G.spqr_tree()[1]` is useful ? I don't understand what we get. May be should should add explanation before that a graph build from a complete bipartite graph `2x5` with an edge joining the vertices of the side of order 2 is decomposed into 5 rigid blocks. However, the blocks are triangles...\\
  This graph could be more informative. It is made of 3 `K_4` with edge `(0, 1)` in common.

```
sage: G = Graph(2)
sage: for i in range(3):
....:     G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
```

  It will be split into 3 3-connected blocks, each isomorphic to a `K_4`.



---

archive/issue_comments_304308.json:
```json
{
    "body": "> - do you think that the example `sage: G.spqr_tree()[1]` is useful ? I don't understand what we get. May be should should add explanation before that a graph build from a complete bipartite graph `2x5` with an edge joining the vertices of the side of order 2 is decomposed into 5 rigid blocks. However, the blocks are triangles...\\\\\n>   This graph could be more informative. It is made of 3 `K_4` with edge `(0, 1)` in common.\n> {{{\n> sage: G = Graph(2)\n> sage: for i in range(3):\n> ....:     G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])\n> }}}\n>   It will be split into 3 3-connected blocks, each isomorphic to a `K_4`.\n> \nYes, followed by G.spqr_tree()[0],  G.spqr_tree()[1] will give us a empty set as other components are tri-connected and covered in R-Block. \\\\\n\nG = Graph({0:[1,2],3:[1,2],4:[1,2],5:[1,2],6:[1,2]}) will give similar results if triangles are added to R-Block instead of S-block i.e polygon blocks.\nCurrently, it's giving an empty list to R-block(G.spqr_tree()[0]) and all triangles to S-Block(G.spqr_tree()[1]).",
    "created_at": "2018-06-04T16:38:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304308",
    "user": "saiharsh"
}
```

> - do you think that the example `sage: G.spqr_tree()[1]` is useful ? I don't understand what we get. May be should should add explanation before that a graph build from a complete bipartite graph `2x5` with an edge joining the vertices of the side of order 2 is decomposed into 5 rigid blocks. However, the blocks are triangles...\\
>   This graph could be more informative. It is made of 3 `K_4` with edge `(0, 1)` in common.
> {{{
> sage: G = Graph(2)
> sage: for i in range(3):
> ....:     G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
> }}}
>   It will be split into 3 3-connected blocks, each isomorphic to a `K_4`.
> 
Yes, followed by G.spqr_tree()[0],  G.spqr_tree()[1] will give us a empty set as other components are tri-connected and covered in R-Block. \\

G = Graph({0:[1,2],3:[1,2],4:[1,2],5:[1,2],6:[1,2]}) will give similar results if triangles are added to R-Block instead of S-block i.e polygon blocks.
Currently, it's giving an empty list to R-block(G.spqr_tree()[0]) and all triangles to S-Block(G.spqr_tree()[1]).



---

archive/issue_comments_304309.json:
```json
{
    "body": "my main complain is that this output is ugly\n\n```\n+            sage: G.spqr_tree()[1]\n+            [Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,\n+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,\n+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,\n+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,\n+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices]\n```\n",
    "created_at": "2018-06-04T16:56:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304309",
    "user": "@dcoudert"
}
```

my main complain is that this output is ugly

```
+            sage: G.spqr_tree()[1]
+            [Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
+             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices]
```




---

archive/issue_comments_304310.json:
```json
{
    "body": "Replying to [comment:33 dcoudert]:\n> my main complain is that this output is ugly\n> {{{\n> +            sage: G.spqr_tree()[1]\n> +            [Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,\n> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,\n> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,\n> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,\n> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices]\n> }}}\nYes it doesn't look good and convey less information. \\\\\nAny suggestion where I can find the document related to it or we can reduce this message in the code? \\\\\nTried searching in developer's  Guide  couldn't find a related doc.",
    "created_at": "2018-06-04T20:19:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304310",
    "user": "saiharsh"
}
```

Replying to [comment:33 dcoudert]:
> my main complain is that this output is ugly
> {{{
> +            sage: G.spqr_tree()[1]
> +            [Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices,
> +             Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of (Subgraph of ()))))): Multi-graph on 3 vertices]
> }}}
Yes it doesn't look good and convey less information. \\
Any suggestion where I can find the document related to it or we can reduce this message in the code? \\
Tried searching in developer's  Guide  couldn't find a related doc.



---

archive/issue_comments_304311.json:
```json
{
    "body": "You want to show that the set `S` contains 5 3-cycles. So you can do:\n\n```\nsage: G = Graph({0:[1,2],3:[1,2],4:[1,2],5:[1,2],6:[1,2]})\nsage: R,S,P,SPR,tricomp,SPQR-tree = G.spqr_tree()\nsage: R\n[]\nsage: C3 = graphs.CycleGraph(3)\nsage: all(h.is_isomorphic(C3) for h in S]\nTrue\n```\n",
    "created_at": "2018-06-05T07:06:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304311",
    "user": "@dcoudert"
}
```

You want to show that the set `S` contains 5 3-cycles. So you can do:

```
sage: G = Graph({0:[1,2],3:[1,2],4:[1,2],5:[1,2],6:[1,2]})
sage: R,S,P,SPR,tricomp,SPQR-tree = G.spqr_tree()
sage: R
[]
sage: C3 = graphs.CycleGraph(3)
sage: all(h.is_isomorphic(C3) for h in S]
True
```




---

archive/issue_comments_304312.json:
```json
{
    "body": "Replying to [comment:35 dcoudert]:\n> You want to show that the set `S` contains 5 3-cycles. So you can do:\n> {{{\n> sage: G = Graph({0:[1,2],3:[1,2],4:[1,2],5:[1,2],6:[1,2]})\n> sage: R,S,P,SPR,tricomp,SPQR-tree = G.spqr_tree()\n> sage: R\n> []\n> sage: C3 = graphs.CycleGraph(3)\n> sage: all(h.is_isomorphic(C3) for h in S]\n> True\n> }}}\nWith the help of 3 K_4 example and this, 2 good examples are covered.\n\n```\nsage: G = Graph(2)\nsage: for i in range(3):\n....:     G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])\nsage: R,S,P,SPR,tricomp,SPQR_tree = G.spqr_tree()\nsage: CG4 = graphs.CompleteGraph(4)\nsage: all(h.is_isomorphic(CG4) for h in R)\nTrue\n```\n\nI will update it in next commit.\n\nOne example for multiple edges, \n\n```\nsage: G = graphs.CompleteBipartiteGraph(2,3)\nsage: G.add_edge(2, 3)            \nsage: G.allow_multiple_edges(True)\nsage: G.add_edges(G.edges())\nsage: G.add_edges([[0,1],[0,1],[0,1]])\nsage: R,S,P,SPR,tricomp,SPQR-tree = G.spqr_tree()\nsage: tricomp\n[Subgraph of (): Multi-graph on 3 vertices,\n Subgraph of (): Multi-graph on 4 vertices]\n```\n\nWith different order of tri-connected components.",
    "created_at": "2018-06-05T15:41:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304312",
    "user": "saiharsh"
}
```

Replying to [comment:35 dcoudert]:
> You want to show that the set `S` contains 5 3-cycles. So you can do:
> {{{
> sage: G = Graph({0:[1,2],3:[1,2],4:[1,2],5:[1,2],6:[1,2]})
> sage: R,S,P,SPR,tricomp,SPQR-tree = G.spqr_tree()
> sage: R
> []
> sage: C3 = graphs.CycleGraph(3)
> sage: all(h.is_isomorphic(C3) for h in S]
> True
> }}}
With the help of 3 K_4 example and this, 2 good examples are covered.

```
sage: G = Graph(2)
sage: for i in range(3):
....:     G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
sage: R,S,P,SPR,tricomp,SPQR_tree = G.spqr_tree()
sage: CG4 = graphs.CompleteGraph(4)
sage: all(h.is_isomorphic(CG4) for h in R)
True
```

I will update it in next commit.

One example for multiple edges, 

```
sage: G = graphs.CompleteBipartiteGraph(2,3)
sage: G.add_edge(2, 3)            
sage: G.allow_multiple_edges(True)
sage: G.add_edges(G.edges())
sage: G.add_edges([[0,1],[0,1],[0,1]])
sage: R,S,P,SPR,tricomp,SPQR-tree = G.spqr_tree()
sage: tricomp
[Subgraph of (): Multi-graph on 3 vertices,
 Subgraph of (): Multi-graph on 4 vertices]
```

With different order of tri-connected components.



---

archive/issue_comments_304313.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-06T17:08:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304313",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304314.json:
```json
{
    "body": "I have updated examples.\nCurrently, I am doing some performance analysis, how it's behaving on huge graphs. \\\\\nIndividually which operation is taking time.\n\\\\\nReplying to [comment:37 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> ||[2457a52](https://git.sagemath.org/sage.git/commit/?id=2457a526eef1474a230fec134f4a5c6ae824b61f)||`Examples updated.`||",
    "created_at": "2018-06-07T15:05:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304314",
    "user": "saiharsh"
}
```

I have updated examples.
Currently, I am doing some performance analysis, how it's behaving on huge graphs. \\
Individually which operation is taking time.
\\
Replying to [comment:37 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[2457a52](https://git.sagemath.org/sage.git/commit/?id=2457a526eef1474a230fec134f4a5c6ae824b61f)||`Examples updated.`||



---

archive/issue_comments_304315.json:
```json
{
    "body": "Changing keywords from \"connectivity, decomposition\" to \"connectivity, decomposition, gsoc2018\".",
    "created_at": "2018-06-07T16:18:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304315",
    "user": "@dcoudert"
}
```

Changing keywords from "connectivity, decomposition" to "connectivity, decomposition, gsoc2018".



---

archive/issue_comments_304316.json:
```json
{
    "body": "I bet that `self.vertex_connectivity(value_only=False)` is one of the most time consuming operation. That's why we need the implementation of the linear time algorithm.\n\nThe most import in this patch is to get a working method. It will be very useful for testing the linear time code.",
    "created_at": "2018-06-07T16:18:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304316",
    "user": "@dcoudert"
}
```

I bet that `self.vertex_connectivity(value_only=False)` is one of the most time consuming operation. That's why we need the implementation of the linear time algorithm.

The most import in this patch is to get a working method. It will be very useful for testing the linear time code.



---

archive/issue_comments_304317.json:
```json
{
    "body": "Replying to [comment:39 dcoudert]:\n> I bet that `self.vertex_connectivity(value_only=False)` is one of the most time consuming operation. That's why we need the implementation of the linear time algorithm.\nI will keep this as a separate parameter. \\\\\nThanks for suggesting me. \\\\\nI will try to update you will the report ASAP.\n> The most import in this patch is to get a working method. It will be very useful for testing the linear time code.\nYes, If found any incorrect answer please let me know.\\\\",
    "created_at": "2018-06-07T17:50:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304317",
    "user": "saiharsh"
}
```

Replying to [comment:39 dcoudert]:
> I bet that `self.vertex_connectivity(value_only=False)` is one of the most time consuming operation. That's why we need the implementation of the linear time algorithm.
I will keep this as a separate parameter. \\
Thanks for suggesting me. \\
I will try to update you will the report ASAP.
> The most import in this patch is to get a working method. It will be very useful for testing the linear time code.
Yes, If found any incorrect answer please let me know.\\



---

archive/issue_comments_304318.json:
```json
{
    "body": "Yes, it's taking much time for graphs which has order > 2000 and size > 40000.\nMostly the time is taken by vertex_connectivity function and some other component depending on graph.(cases are less)\n\\\\\nTo reduce memory usage, I am deleting few variables after usage. \n\nAfter doing few runs with different graphs, I kept flags to find running time for below 5 parts.\n1. Vertex_connectivity\n2. Split_multiple_edge(4711 to 4730)\n3. cleave and appending cuts (4734 to 4761)\n4. appending blocks (4769 to 4806)\n5. Construction of Tree (4812 to 4843)\n\nvertex_connectiviy is taking more time when there are multiple edges in input graph. So I am pushing, Split_multiple_edges as the first step(if graph has multiple edges) as split_mutiple_edge will give output as a simple version of G. if there are x cut points in multigraph then they should be x cut points in a simple graph too. correct me if I am wrong.\n\nThere is a significant difference in running time of vertex_connectivity function if we do above change, atleast code running time is down with 1/2 when there are multiple edges in input graph.\n\nI will upload the result file mostly by tomorrow night. Some test cases are pending.",
    "created_at": "2018-06-11T20:14:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304318",
    "user": "saiharsh"
}
```

Yes, it's taking much time for graphs which has order > 2000 and size > 40000.
Mostly the time is taken by vertex_connectivity function and some other component depending on graph.(cases are less)
\\
To reduce memory usage, I am deleting few variables after usage. 

After doing few runs with different graphs, I kept flags to find running time for below 5 parts.
1. Vertex_connectivity
2. Split_multiple_edge(4711 to 4730)
3. cleave and appending cuts (4734 to 4761)
4. appending blocks (4769 to 4806)
5. Construction of Tree (4812 to 4843)

vertex_connectiviy is taking more time when there are multiple edges in input graph. So I am pushing, Split_multiple_edges as the first step(if graph has multiple edges) as split_mutiple_edge will give output as a simple version of G. if there are x cut points in multigraph then they should be x cut points in a simple graph too. correct me if I am wrong.

There is a significant difference in running time of vertex_connectivity function if we do above change, atleast code running time is down with 1/2 when there are multiple edges in input graph.

I will upload the result file mostly by tomorrow night. Some test cases are pending.



---

archive/issue_comments_304319.json:
```json
{
    "body": "> vertex_connectiviy is taking more time when there are multiple edges in input graph. \n\nThis is surprizing. In the ILP formulation, multiple edges only lead to adding multiple times the same constraint, but then solver quickly remove redundant constraints.\n\n> So I am pushing, Split_multiple_edges as the first step(if graph has multiple edges) as split_mutiple_edge will give output as a simple version of G. if there are x cut points in multigraph then they should be x cut points in a simple graph too. correct me if I am wrong.\n> \nDon't do that ! ;)\n\nWhat is `split_multiple_edges` doing ? If it split an edge into a path, it introduce a new vertex of degree 2, and so a new cut with 2 vertices.\n\n\n\n> There is a significant difference in running time of vertex_connectivity function if we do above change, atleast code running time is down with 1/2 when there are multiple edges in input graph.\n\nReally weird. Isn't it due to extra computation like a copy of the graph ?",
    "created_at": "2018-06-12T15:53:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304319",
    "user": "@dcoudert"
}
```

> vertex_connectiviy is taking more time when there are multiple edges in input graph. 

This is surprizing. In the ILP formulation, multiple edges only lead to adding multiple times the same constraint, but then solver quickly remove redundant constraints.

> So I am pushing, Split_multiple_edges as the first step(if graph has multiple edges) as split_mutiple_edge will give output as a simple version of G. if there are x cut points in multigraph then they should be x cut points in a simple graph too. correct me if I am wrong.
> 
Don't do that ! ;)

What is `split_multiple_edges` doing ? If it split an edge into a path, it introduce a new vertex of degree 2, and so a new cut with 2 vertices.



> There is a significant difference in running time of vertex_connectivity function if we do above change, atleast code running time is down with 1/2 when there are multiple edges in input graph.

Really weird. Isn't it due to extra computation like a copy of the graph ?



---

archive/issue_comments_304320.json:
```json
{
    "body": "Attachment [Results.csv](tarball://root/attachments/some-uuid/ticket22157/Results.csv) by saiharsh created at 2018-06-12 21:34:42",
    "created_at": "2018-06-12T21:34:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304320",
    "user": "saiharsh"
}
```

Attachment [Results.csv](tarball://root/attachments/some-uuid/ticket22157/Results.csv) by saiharsh created at 2018-06-12 21:34:42



---

archive/issue_comments_304321.json:
```json
{
    "body": "Attachment [Results.2.csv](tarball://root/attachments/some-uuid/ticket22157/Results.2.csv) by saiharsh created at 2018-06-12 21:35:21",
    "created_at": "2018-06-12T21:35:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304321",
    "user": "saiharsh"
}
```

Attachment [Results.2.csv](tarball://root/attachments/some-uuid/ticket22157/Results.2.csv) by saiharsh created at 2018-06-12 21:35:21



---

archive/issue_comments_304322.json:
```json
{
    "body": "Replying to [comment:42 dcoudert]:\n> This is surprizing. In the ILP formulation, multiple edges only lead to adding multiple times the same constraint, but then solver quickly remove redundant constraints.\n> Except that all other components are taking time but it sounds reasonable.\nPlease have a look at the second table in the attached file. \n\nIn which I used two graph G1 with order = 3502 and size = 8751 and G2 with order = 5002 and size = 12501. later I am adding multiple edges to G1 and G2.\nThere is an increase in running time of Vertex Connectivity\nbut the difference is significant, please let me know if this kind of nature is expected.\n\n\\\\\n> > So I am pushing, Split_multiple_edges as the first step(if graph has multiple edges) as split_mutiple_edge will give output as a simple version of G. if there are x cut points in multigraph then they should be x cut points in a simple graph too. correct me if I am wrong.\n> > \n> Don't do that ! ;)\n> \n> What is `split_multiple_edges` doing ? If it split an edge into a path, it introduce a new vertex of degree 2, and so a new cut with 2 vertices.\n> \n`split_multiple_edges` in this part bundle of multiple edges are replaced by a new virtual edge. This step is done only to make graph simple from multi.\nIt's reference is present in section 4.1 of the reference paper.\n\nIt's not going add any new vertex. \n\\\\\n> \n> \n> > There is a significant difference in running time of vertex_connectivity function if we do above change, atleast code running time is down with 1/2 when there are multiple edges in input graph.\n> \n> Really weird. Isn't it due to extra computation like a copy of the graph ?\nI am finding how much time it's taking to execute `self.vertex_connectivity(value_only = False)` this step.\nLet me know if I missed something.\n\nResults.2.csv is same as Results.csv\n\\\\\nTable 1 has all multigraphs, it's intended to show which component is taking time if multiple edges are more.\n\\\\\nI wanted to generate a graph which shows running time vs memory consumption couldn't complete it.\n\\\\\nI used Intel(R) Xeon(R) CPU E5-2640 v4 processor, which has 2.40GHz frequency. To generate the running time.",
    "created_at": "2018-06-12T21:52:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304322",
    "user": "saiharsh"
}
```

Replying to [comment:42 dcoudert]:
> This is surprizing. In the ILP formulation, multiple edges only lead to adding multiple times the same constraint, but then solver quickly remove redundant constraints.
> Except that all other components are taking time but it sounds reasonable.
Please have a look at the second table in the attached file. 

In which I used two graph G1 with order = 3502 and size = 8751 and G2 with order = 5002 and size = 12501. later I am adding multiple edges to G1 and G2.
There is an increase in running time of Vertex Connectivity
but the difference is significant, please let me know if this kind of nature is expected.

\\
> > So I am pushing, Split_multiple_edges as the first step(if graph has multiple edges) as split_mutiple_edge will give output as a simple version of G. if there are x cut points in multigraph then they should be x cut points in a simple graph too. correct me if I am wrong.
> > 
> Don't do that ! ;)
> 
> What is `split_multiple_edges` doing ? If it split an edge into a path, it introduce a new vertex of degree 2, and so a new cut with 2 vertices.
> 
`split_multiple_edges` in this part bundle of multiple edges are replaced by a new virtual edge. This step is done only to make graph simple from multi.
It's reference is present in section 4.1 of the reference paper.

It's not going add any new vertex. 
\\
> 
> 
> > There is a significant difference in running time of vertex_connectivity function if we do above change, atleast code running time is down with 1/2 when there are multiple edges in input graph.
> 
> Really weird. Isn't it due to extra computation like a copy of the graph ?
I am finding how much time it's taking to execute `self.vertex_connectivity(value_only = False)` this step.
Let me know if I missed something.

Results.2.csv is same as Results.csv
\\
Table 1 has all multigraphs, it's intended to show which component is taking time if multiple edges are more.
\\
I wanted to generate a graph which shows running time vs memory consumption couldn't complete it.
\\
I used Intel(R) Xeon(R) CPU E5-2640 v4 processor, which has 2.40GHz frequency. To generate the running time.



---

archive/issue_comments_304323.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-13T10:40:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304323",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304324.json:
```json
{
    "body": "Replying to [comment:44 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> ||[22e164b](https://git.sagemath.org/sage.git/commit/?id=22e164b11e46d477e90bb8e8b238a62a4c9f6521)||`Deleting few variables after there usage, added few flags for running time analysis which will be removed later.`||\n\nPlease use this code for testing.\n\nBelow is the sample output of the code.\n\n```\nsage: G = Graph(2)\n....: for i in range(20):G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])\n....: R,S,P,SPR,tricomp,SPQR_tree = G.spqr_tree()\nNodes: 42\nEdges: 101\ncut_size =  2 cut_vertices =  [0, 1]\nTime Taken for Vertex Connectivity: 0.0595650672913\nTime Taken for Split_multiple_edge algorithm: 0.000383853912354\nTime Taken for cleave and appending cuts  0.00986504554749\nTime Taken for appending blocks, 6.48498535156e-05\nTime Taken for Construction of Tree 0.00036883354187\nTotal time: 0.0704739093781\n```\n",
    "created_at": "2018-06-13T10:45:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304324",
    "user": "saiharsh"
}
```

Replying to [comment:44 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[22e164b](https://git.sagemath.org/sage.git/commit/?id=22e164b11e46d477e90bb8e8b238a62a4c9f6521)||`Deleting few variables after there usage, added few flags for running time analysis which will be removed later.`||

Please use this code for testing.

Below is the sample output of the code.

```
sage: G = Graph(2)
....: for i in range(20):G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
....: R,S,P,SPR,tricomp,SPQR_tree = G.spqr_tree()
Nodes: 42
Edges: 101
cut_size =  2 cut_vertices =  [0, 1]
Time Taken for Vertex Connectivity: 0.0595650672913
Time Taken for Split_multiple_edge algorithm: 0.000383853912354
Time Taken for cleave and appending cuts  0.00986504554749
Time Taken for appending blocks, 6.48498535156e-05
Time Taken for Construction of Tree 0.00036883354187
Total time: 0.0704739093781
```




---

archive/issue_comments_304325.json:
```json
{
    "body": "I did some tests\n\n```\nsage: G = Graph(2)\nsage: for i in range(1000):G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])\nsage: H = Graph(G.edges()+G.edges(), multiedges=True)\nsage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='Cplex')\n1 loop, best of 3: 458 ms per loop\nsage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='Cplex')\n1 loop, best of 3: 639 ms per loop\nsage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='GLPK')\n1 loop, best of 3: 8.71 s per loop\nsage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='GLPK')\n1 loop, best of 3: 15.3 s per loop\n```\n\nI also checked more closely adding parameter `verbose=3`.\n\nWith `Cplex`, the difference in running time is mostly in the time needed to write the ILP, and then in the elimination of rows/columns. So the difference is small.\nWith `GLPK`, I have the feeling that it does not eliminate rows/columns, and so is very long.\n\nAnyway, we knew that `vertex_connectivity` is slow and that it takes most of the computing time of the method. So don't waste more time trying to optimize the running time of this method. It will be slow. The most important is that it is safe = it gives the correct result.",
    "created_at": "2018-06-13T11:34:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304325",
    "user": "@dcoudert"
}
```

I did some tests

```
sage: G = Graph(2)
sage: for i in range(1000):G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
sage: H = Graph(G.edges()+G.edges(), multiedges=True)
sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='Cplex')
1 loop, best of 3: 458 ms per loop
sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='Cplex')
1 loop, best of 3: 639 ms per loop
sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='GLPK')
1 loop, best of 3: 8.71 s per loop
sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='GLPK')
1 loop, best of 3: 15.3 s per loop
```

I also checked more closely adding parameter `verbose=3`.

With `Cplex`, the difference in running time is mostly in the time needed to write the ILP, and then in the elimination of rows/columns. So the difference is small.
With `GLPK`, I have the feeling that it does not eliminate rows/columns, and so is very long.

Anyway, we knew that `vertex_connectivity` is slow and that it takes most of the computing time of the method. So don't waste more time trying to optimize the running time of this method. It will be slow. The most important is that it is safe = it gives the correct result.



---

archive/issue_comments_304326.json:
```json
{
    "body": "Replying to [comment:46 dcoudert]:\n> I did some tests\n> {{{\n> sage: G = Graph(2)\n> sage: for i in range(1000):G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])\n> sage: H = Graph(G.edges()+G.edges(), multiedges=True)\n> sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='Cplex')\n> 1 loop, best of 3: 458 ms per loop\n> sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='Cplex')\n> 1 loop, best of 3: 639 ms per loop\n> sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='GLPK')\n> 1 loop, best of 3: 8.71 s per loop\n> sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='GLPK')\n> 1 loop, best of 3: 15.3 s per loop\n> }}}\n> I also checked more closely adding parameter `verbose=3`.\n> \n> With `Cplex`, the difference in running time is mostly in the time needed to write the ILP, and then in the elimination of rows/columns. So the difference is small.\n> With `GLPK`, I have the feeling that it does not eliminate rows/columns, and so is very long.\n> \nI feel for 1000 nodes if it's taking ms is reasonable time. Ultimately it need to preform good when graph is simple but it's taking time for it too.\n\n> Anyway, we knew that `vertex_connectivity` is slow and that it takes most of the computing time of the method. So don't waste more time trying to optimize the running time of this method. It will be slow. The most important is that it is safe = it gives the correct result.\nThe overall contribution of vertex_connectivity is to check whether the graph is bi-connected or not. if we mention the input need to be biconnected then we can remove the `vertex_connectivity`  or we can use `is_biconnected()`. \\\\\nAgain `vertex_connectivity` is used in `Cleave` a helper function of spqr_tree, the input to Cleave function is a simple subgraph. Its time is comparatively less if we see in Results.csv",
    "created_at": "2018-06-13T16:53:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304326",
    "user": "saiharsh"
}
```

Replying to [comment:46 dcoudert]:
> I did some tests
> {{{
> sage: G = Graph(2)
> sage: for i in range(1000):G.add_clique([0, 1, G.add_vertex(), G.add_vertex()])
> sage: H = Graph(G.edges()+G.edges(), multiedges=True)
> sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='Cplex')
> 1 loop, best of 3: 458 ms per loop
> sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='Cplex')
> 1 loop, best of 3: 639 ms per loop
> sage: %timeit a,b = G.vertex_connectivity(value_only=False, solver='GLPK')
> 1 loop, best of 3: 8.71 s per loop
> sage: %timeit a,b = H.vertex_connectivity(value_only=False, solver='GLPK')
> 1 loop, best of 3: 15.3 s per loop
> }}}
> I also checked more closely adding parameter `verbose=3`.
> 
> With `Cplex`, the difference in running time is mostly in the time needed to write the ILP, and then in the elimination of rows/columns. So the difference is small.
> With `GLPK`, I have the feeling that it does not eliminate rows/columns, and so is very long.
> 
I feel for 1000 nodes if it's taking ms is reasonable time. Ultimately it need to preform good when graph is simple but it's taking time for it too.

> Anyway, we knew that `vertex_connectivity` is slow and that it takes most of the computing time of the method. So don't waste more time trying to optimize the running time of this method. It will be slow. The most important is that it is safe = it gives the correct result.
The overall contribution of vertex_connectivity is to check whether the graph is bi-connected or not. if we mention the input need to be biconnected then we can remove the `vertex_connectivity`  or we can use `is_biconnected()`. \\
Again `vertex_connectivity` is used in `Cleave` a helper function of spqr_tree, the input to Cleave function is a simple subgraph. Its time is comparatively less if we see in Results.csv



---

archive/issue_comments_304327.json:
```json
{
    "body": "> > Anyway, we knew that `vertex_connectivity` is slow and that it takes most of the computing time of the method. So don't waste more time trying to optimize the running time of this method. It will be slow. The most important is that it is safe = it gives the correct result.\n> The overall contribution of vertex_connectivity is to check whether the graph is bi-connected or not. \n\nNot only. We want to check if the graph has a 2-vertex-cut or not.\n\nIn particular, the `cleave` method is used to split a biconnected graph along a 2-vertex cut, if it has one.\n\n> if we mention the input need to be biconnected then we can remove the `vertex_connectivity`  or we can use `is_biconnected()`. \\\\\n\nWhere ? in `cleave`, we need to find the 2-vertex-cuts.",
    "created_at": "2018-06-14T14:48:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304327",
    "user": "@dcoudert"
}
```

> > Anyway, we knew that `vertex_connectivity` is slow and that it takes most of the computing time of the method. So don't waste more time trying to optimize the running time of this method. It will be slow. The most important is that it is safe = it gives the correct result.
> The overall contribution of vertex_connectivity is to check whether the graph is bi-connected or not. 

Not only. We want to check if the graph has a 2-vertex-cut or not.

In particular, the `cleave` method is used to split a biconnected graph along a 2-vertex cut, if it has one.

> if we mention the input need to be biconnected then we can remove the `vertex_connectivity`  or we can use `is_biconnected()`. \\

Where ? in `cleave`, we need to find the 2-vertex-cuts.



---

archive/issue_comments_304328.json:
```json
{
    "body": "Replying to [comment:48 dcoudert]:\n> Not only. We want to check if the graph has a 2-vertex-cut or not.\nYes, we need to check a graph has 2 cut vertices. If it's biconnected we would have used is_biconected.\n> \n> Where ? in `cleave`, we need to find the 2-vertex-cuts.\nYes in `cleave` function but again the same problem. \\\\\nI will remove the flags and update it.",
    "created_at": "2018-06-14T19:45:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304328",
    "user": "saiharsh"
}
```

Replying to [comment:48 dcoudert]:
> Not only. We want to check if the graph has a 2-vertex-cut or not.
Yes, we need to check a graph has 2 cut vertices. If it's biconnected we would have used is_biconected.
> 
> Where ? in `cleave`, we need to find the 2-vertex-cuts.
Yes in `cleave` function but again the same problem. \\
I will remove the flags and update it.



---

archive/issue_comments_304329.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-15T10:40:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304329",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304330.json:
```json
{
    "body": "New commits:",
    "created_at": "2018-06-16T18:11:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304330",
    "user": "@dcoudert"
}
```

New commits:



---

archive/issue_comments_304331.json:
```json
{
    "body": "I moved the methods to `connectivity.pyx` and fixed the doctests. I will do more tests/corrections tomorrow.",
    "created_at": "2018-06-16T18:14:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304331",
    "user": "@dcoudert"
}
```

I moved the methods to `connectivity.pyx` and fixed the doctests. I will do more tests/corrections tomorrow.



---

archive/issue_comments_304332.json:
```json
{
    "body": "Replying to [comment:52 dcoudert]:\n> I moved the methods to `connectivity.pyx` and fixed the doctests. I will do more tests/corrections tomorrow.\nThanks for updating it to beta5, could you please say what are the remaining gaps are available in this ticket.",
    "created_at": "2018-06-16T21:40:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304332",
    "user": "saiharsh"
}
```

Replying to [comment:52 dcoudert]:
> I moved the methods to `connectivity.pyx` and fixed the doctests. I will do more tests/corrections tomorrow.
Thanks for updating it to beta5, could you please say what are the remaining gaps are available in this ticket.



---

archive/issue_comments_304333.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-17T17:13:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304333",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304334.json:
```json
{
    "body": "I have changed the `cleave` method to a more general form. It's now working for any size of vertex cut. More importantly, you can give it a vertex cut. This way, we save some calls to `vertex_connectivity`. I have updated `spqr_tree` accordingly.\n\nIn `spqr_tree`,  I have remove all `del` statements. In particular, you where deleting `SG` before the while loop over `twoblocks`... not good :P\n\nPlease check the new `cleave`.\n\nI have not checked `spqr_tree` carefully yet.",
    "created_at": "2018-06-17T17:21:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304334",
    "user": "@dcoudert"
}
```

I have changed the `cleave` method to a more general form. It's now working for any size of vertex cut. More importantly, you can give it a vertex cut. This way, we save some calls to `vertex_connectivity`. I have updated `spqr_tree` accordingly.

In `spqr_tree`,  I have remove all `del` statements. In particular, you where deleting `SG` before the while loop over `twoblocks`... not good :P

Please check the new `cleave`.

I have not checked `spqr_tree` carefully yet.



---

archive/issue_comments_304335.json:
```json
{
    "body": "Replying to [comment:55 dcoudert]:\n> I have changed the `cleave` method to a more general form. It's now working for any size of vertex cut. More importantly, you can give it a vertex cut. This way, we save some calls to `vertex_connectivity`. I have updated `spqr_tree` accordingly.\n> \nYes, now it could be used in general not only specific to `spqr_tree`. \\\\\n\n> In `spqr_tree`,  I have remove all `del` statements. In particular, you where deleting `SG` before the while loop over `twoblocks`... not good :P\nI kept `SG` before the while loop of `twoblocks` because there was no use of `SG` in future, as it was appended in `twoblocks` it's safe to delete it and deleting of `SG` won't reflect in `twoblocks`. \\\\\nThe moto of deleting variables is to reduce the memory usage. correct me if I am wrong.\n\n> Please check the new `cleave`.\nThe code is well structured and easy to read. \\\\\nCan we add an example in which cut vertices which are generated differ from ones which are given as input.\\\\\n\n\n```\nsage: G = Graph()\nsage: G.add_cycle(vertices=[0,1,2,3,4])\nsage: cut_size,cut_vertices = G.vertex_connectivity(value_only=False)\nsage: cut_vertices\n[2, 4]\nsage: S,C,f = G.cleave(cut_vertices=[1, 3])\nsage: [g.order() for g in S]\n[4, 3]\nsage: C.order(), C.size()\n(2, 2)\nsage: f.vertices()\n[1, 3]\n\n```\n",
    "created_at": "2018-06-17T19:49:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304335",
    "user": "saiharsh"
}
```

Replying to [comment:55 dcoudert]:
> I have changed the `cleave` method to a more general form. It's now working for any size of vertex cut. More importantly, you can give it a vertex cut. This way, we save some calls to `vertex_connectivity`. I have updated `spqr_tree` accordingly.
> 
Yes, now it could be used in general not only specific to `spqr_tree`. \\

> In `spqr_tree`,  I have remove all `del` statements. In particular, you where deleting `SG` before the while loop over `twoblocks`... not good :P
I kept `SG` before the while loop of `twoblocks` because there was no use of `SG` in future, as it was appended in `twoblocks` it's safe to delete it and deleting of `SG` won't reflect in `twoblocks`. \\
The moto of deleting variables is to reduce the memory usage. correct me if I am wrong.

> Please check the new `cleave`.
The code is well structured and easy to read. \\
Can we add an example in which cut vertices which are generated differ from ones which are given as input.\\


```
sage: G = Graph()
sage: G.add_cycle(vertices=[0,1,2,3,4])
sage: cut_size,cut_vertices = G.vertex_connectivity(value_only=False)
sage: cut_vertices
[2, 4]
sage: S,C,f = G.cleave(cut_vertices=[1, 3])
sage: [g.order() for g in S]
[4, 3]
sage: C.order(), C.size()
(2, 2)
sage: f.vertices()
[1, 3]

```




---

archive/issue_comments_304336.json:
```json
{
    "body": "> > In `spqr_tree`,  I have remove all `del` statements. In particular, you where deleting `SG` before the while loop over `twoblocks`... not good :P\n> I kept `SG` before the while loop of `twoblocks` because there was no use of `SG` in future, as it was appended in `twoblocks` it's safe to delete it and deleting of `SG` won't reflect in `twoblocks`. \\\\\n> The moto of deleting variables is to reduce the memory usage. correct me if I am wrong.\n\nDeleting SG might lead to an error. Understand that when you append SG to `twoblocks`, you don't copy the full object, you just append a pointer to SG. Hopeful, when you do `del SG` it apparently only deletes the pointer, not the full object. So please don't do that !\n\nTo give you an example:\n\n```\nsage: G = Graph()\nsage: L = []\nsage: L.append(G)\nsage: G.add_edge(0, 1)\nsage: L[0].edges()\n[(0, 1, None)]\n```\n\n \n\nConcerning `del twoblocks`, since the list is empty at that time, the memory occupancy is negligeable, so there is no need to do that.\n\n\n> Can we add an example in which cut vertices which are generated differ from ones which are given as input.\\\\\n> \n> {{{\n> sage: G = Graph()\n> sage: G.add_cycle(vertices=[0,1,2,3,4])\n> sage: cut_size,cut_vertices = G.vertex_connectivity(value_only=False)\n> sage: cut_vertices\n> [2, 4]\n> sage: S,C,f = G.cleave(cut_vertices=[1, 3])\n> sage: [g.order() for g in S]\n> [4, 3]\n> sage: C.order(), C.size()\n> (2, 2)\n> sage: f.vertices()\n> [1, 3]\n> \n> }}}\nI don't understand what you want to show. What is important is to give a valid vertex cut of the graph. You may add an example with more vertices than needed if you want, but I'm not sure it's so interesting here.",
    "created_at": "2018-06-17T20:10:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304336",
    "user": "@dcoudert"
}
```

> > In `spqr_tree`,  I have remove all `del` statements. In particular, you where deleting `SG` before the while loop over `twoblocks`... not good :P
> I kept `SG` before the while loop of `twoblocks` because there was no use of `SG` in future, as it was appended in `twoblocks` it's safe to delete it and deleting of `SG` won't reflect in `twoblocks`. \\
> The moto of deleting variables is to reduce the memory usage. correct me if I am wrong.

Deleting SG might lead to an error. Understand that when you append SG to `twoblocks`, you don't copy the full object, you just append a pointer to SG. Hopeful, when you do `del SG` it apparently only deletes the pointer, not the full object. So please don't do that !

To give you an example:

```
sage: G = Graph()
sage: L = []
sage: L.append(G)
sage: G.add_edge(0, 1)
sage: L[0].edges()
[(0, 1, None)]
```

 

Concerning `del twoblocks`, since the list is empty at that time, the memory occupancy is negligeable, so there is no need to do that.


> Can we add an example in which cut vertices which are generated differ from ones which are given as input.\\
> 
> {{{
> sage: G = Graph()
> sage: G.add_cycle(vertices=[0,1,2,3,4])
> sage: cut_size,cut_vertices = G.vertex_connectivity(value_only=False)
> sage: cut_vertices
> [2, 4]
> sage: S,C,f = G.cleave(cut_vertices=[1, 3])
> sage: [g.order() for g in S]
> [4, 3]
> sage: C.order(), C.size()
> (2, 2)
> sage: f.vertices()
> [1, 3]
> 
> }}}
I don't understand what you want to show. What is important is to give a valid vertex cut of the graph. You may add an example with more vertices than needed if you want, but I'm not sure it's so interesting here.



---

archive/issue_comments_304337.json:
```json
{
    "body": "Replying to [comment:57 dcoudert]:\n> Deleting SG might lead to an error. Understand that when you append SG to `twoblocks`, you don't copy the full object, you just append a pointer to SG. Hopeful, when you do `del SG` it apparently only deletes the pointer, not the full object. So please don't do that !\n> \n> To give you an example:\n> {{{\n> sage: G = Graph()\n> sage: L = []\n> sage: L.append(G)\n> sage: G.add_edge(0, 1)\n> sage: L[0].edges()\n> [(0, 1, None)]\n> }}}\n>  \n> \n> Concerning `del twoblocks`, since the list is empty at that time, the memory occupancy is negligeable, so there is no need to do that.\n> \nThanks for clearing it, I thought the change in `SG` should not effect in `twoblocks`.\nso we can delete it. \nBefore keeping `del SG`, I did below test.\n\n```\nsage: G = Graph([[0,1]])\nsage: l = []\nsage: l.append(G)\nsage: G\nGraph on 2 vertices\nsage: l\n[Graph on 2 vertices]\nsage: del G\nsage: G\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-7-96e89ba817df> in <module>()\n----> 1 G\n\nNameError: name 'G' is not defined\nsage: l\n[Graph on 2 vertices]\nsage: l[0].add_edge(2,3)\nsage: l\n[Graph on 4 vertices]\n\n```\n\nThis gives me thought that `G` and `l` doesn't have any link between them and both have independent memory location, so why to keep `G` when we have its instance in `l` but actually, it's appending links and deleting link i.e `SG` doesn't make sense and doesn't affect memory usage.\n\n> > Can we add an example in which cut vertices which are generated differ from ones which are given as input.\\\\\n> > \n> > {{{\n> > sage: G = Graph()\n> > sage: G.add_cycle(vertices=[0,1,2,3,4])\n> > sage: cut_size,cut_vertices = G.vertex_connectivity(value_only=False)\n> > sage: cut_vertices\n> > [2, 4]\n> > sage: S,C,f = G.cleave(cut_vertices=[1, 3])\n> > sage: [g.order() for g in S]\n> > [4, 3]\n> > sage: C.order(), C.size()\n> > (2, 2)\n> > sage: f.vertices()\n> > [1, 3]\n> > \n> > }}}\n\n> I don't understand what you want to show. What is important is to give a valid vertex cut of the graph. You may add an example with more vertices than needed if you want, but I'm not sure it's so interesting here.\nI want to show that the cut vertices(passing values when calling the function) could differ(in size too) from the generated output of `vertex_connectivity`, as we have enough examples may this is not a good example.",
    "created_at": "2018-06-17T21:58:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304337",
    "user": "saiharsh"
}
```

Replying to [comment:57 dcoudert]:
> Deleting SG might lead to an error. Understand that when you append SG to `twoblocks`, you don't copy the full object, you just append a pointer to SG. Hopeful, when you do `del SG` it apparently only deletes the pointer, not the full object. So please don't do that !
> 
> To give you an example:
> {{{
> sage: G = Graph()
> sage: L = []
> sage: L.append(G)
> sage: G.add_edge(0, 1)
> sage: L[0].edges()
> [(0, 1, None)]
> }}}
>  
> 
> Concerning `del twoblocks`, since the list is empty at that time, the memory occupancy is negligeable, so there is no need to do that.
> 
Thanks for clearing it, I thought the change in `SG` should not effect in `twoblocks`.
so we can delete it. 
Before keeping `del SG`, I did below test.

```
sage: G = Graph([[0,1]])
sage: l = []
sage: l.append(G)
sage: G
Graph on 2 vertices
sage: l
[Graph on 2 vertices]
sage: del G
sage: G
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-7-96e89ba817df> in <module>()
----> 1 G

NameError: name 'G' is not defined
sage: l
[Graph on 2 vertices]
sage: l[0].add_edge(2,3)
sage: l
[Graph on 4 vertices]

```

This gives me thought that `G` and `l` doesn't have any link between them and both have independent memory location, so why to keep `G` when we have its instance in `l` but actually, it's appending links and deleting link i.e `SG` doesn't make sense and doesn't affect memory usage.

> > Can we add an example in which cut vertices which are generated differ from ones which are given as input.\\
> > 
> > {{{
> > sage: G = Graph()
> > sage: G.add_cycle(vertices=[0,1,2,3,4])
> > sage: cut_size,cut_vertices = G.vertex_connectivity(value_only=False)
> > sage: cut_vertices
> > [2, 4]
> > sage: S,C,f = G.cleave(cut_vertices=[1, 3])
> > sage: [g.order() for g in S]
> > [4, 3]
> > sage: C.order(), C.size()
> > (2, 2)
> > sage: f.vertices()
> > [1, 3]
> > 
> > }}}

> I don't understand what you want to show. What is important is to give a valid vertex cut of the graph. You may add an example with more vertices than needed if you want, but I'm not sure it's so interesting here.
I want to show that the cut vertices(passing values when calling the function) could differ(in size too) from the generated output of `vertex_connectivity`, as we have enough examples may this is not a good example.



---

archive/issue_comments_304338.json:
```json
{
    "body": "New commits:",
    "created_at": "2018-06-23T17:06:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304338",
    "user": "saiharsh"
}
```

New commits:



---

archive/issue_comments_304339.json:
```json
{
    "body": "A minor change in the examples, `G.spqr_tree()` to `spqr_tree(G)` and `G.cleave(cut_vertices)` to `cleave(G, cut_vertices)`as the code is shifted to connectivity.pyx file.",
    "created_at": "2018-06-23T17:12:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304339",
    "user": "saiharsh"
}
```

A minor change in the examples, `G.spqr_tree()` to `spqr_tree(G)` and `G.cleave(cut_vertices)` to `cleave(G, cut_vertices)`as the code is shifted to connectivity.pyx file.



---

archive/issue_comments_304340.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-24T09:13:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304340",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304341.json:
```json
{
    "body": "I did some more corrections, but I need some clarifications to go beyond.\n- Could you try to improve the comments. So far, some of them a really not clear ;)\n\n- if `SG` is simplified to a cycle, can't we directly return the solution ?\n\n- In the part where you merge cycles to form `cycle_graph`, I'm not sure of what we want at the end. I suspect that we can do something smarter, but it depends on what we must get.\n\n- Why are we returning so many different values ? Can't we just return a tree in which nodes a tuples (type, graph) ? Observe that using `immutable` graphs, we can do:\n\n```\nsage: P = Graph(1, immutable=True)\nsage: Q = Graph(2, immutable=True)\nsage: H = Graph([[P, Q], [(P, Q)]])\n```\n\n\n- The case of `Q` block could also be handled at the beginning, right ?",
    "created_at": "2018-06-24T09:22:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304341",
    "user": "@dcoudert"
}
```

I did some more corrections, but I need some clarifications to go beyond.
- Could you try to improve the comments. So far, some of them a really not clear ;)

- if `SG` is simplified to a cycle, can't we directly return the solution ?

- In the part where you merge cycles to form `cycle_graph`, I'm not sure of what we want at the end. I suspect that we can do something smarter, but it depends on what we must get.

- Why are we returning so many different values ? Can't we just return a tree in which nodes a tuples (type, graph) ? Observe that using `immutable` graphs, we can do:

```
sage: P = Graph(1, immutable=True)
sage: Q = Graph(2, immutable=True)
sage: H = Graph([[P, Q], [(P, Q)]])
```


- The case of `Q` block could also be handled at the beginning, right ?



---

archive/issue_comments_304342.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-25T14:14:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304342",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304343.json:
```json
{
    "body": "Replying to [comment:63 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> ||[150e868](https://git.sagemath.org/sage.git/commit/?id=150e8689ee4481c2df8e9474287936e0430668be)||`Updated for case when `SG` is a cycle.`||\nI have added `P_block_new` for test.\nExample: \n\n```\nsage: from sage.graphs.connectivity import spqr_tree\n....: G = Graph()\n....: G.add_cycle(vertices=[0,1,2,3,4])\n....: G.allow_multiple_edges(True)\n....: G.add_edges(G.edges())\n....: G.add_edge(2,3)\n....: G.add_edge(3,4)\n....: \nsage: R,S,P,SPR,tricomp,SPQR_tree,P_new = spqr_tree(G)\nsage: P==P_new\nTrue\n\n```\n\nIn the next commit, I will update the comments and add a return statement `if SG.is_cycle():`.",
    "created_at": "2018-06-25T14:19:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304343",
    "user": "saiharsh"
}
```

Replying to [comment:63 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[150e868](https://git.sagemath.org/sage.git/commit/?id=150e8689ee4481c2df8e9474287936e0430668be)||`Updated for case when `SG` is a cycle.`||
I have added `P_block_new` for test.
Example: 

```
sage: from sage.graphs.connectivity import spqr_tree
....: G = Graph()
....: G.add_cycle(vertices=[0,1,2,3,4])
....: G.allow_multiple_edges(True)
....: G.add_edges(G.edges())
....: G.add_edge(2,3)
....: G.add_edge(3,4)
....: 
sage: R,S,P,SPR,tricomp,SPQR_tree,P_new = spqr_tree(G)
sage: P==P_new
True

```

In the next commit, I will update the comments and add a return statement `if SG.is_cycle():`.



---

archive/issue_comments_304344.json:
```json
{
    "body": "Replying to [comment:62 dcoudert]:\n\n> - Could you try to improve the comments. So far, some of them a really not clear ;)\nI will try to add in the next commit. I am not yet good at writing formally.\n> \n> - if `SG` is simplified to a cycle, can't we directly return the solution ?\nYes we can do this, \nR will be `[]` \\\\\nS will be `SG` \\\\\nP_block will be the components formed by combining multiple edges in `cocycle`. there are two ways to do it. \\\\\n1. Make components by adding multiple edges. \\\\\n2. Make multigraph using `cocycle` edges then extract subgraphs using `cuts`. \\\\\nI feel option 1 is slightly better than option 2, let me know which option is better.\n> \n> - In the part where you merge cycles to form `cycle_graph`, I'm not sure of what we want at the end. I suspect that we can do something smarter, but it depends on what we must get.\n> \nIt's a verification step used to check whether all the cycles are formed using `cocycle` edges. \\\\\nInitially, I thought we can skip this step as there is no case in which cycle will be formed without using `cocycle` edge but I am not 100% sure.\n> - Why are we returning so many different values ? Can't we just return a tree in which nodes a tuples (type, graph) ? Observe that using `immutable` graphs, we can do:\n> {{{\n> sage: P = Graph(1, immutable=True)\n> sage: Q = Graph(2, immutable=True)\n> sage: H = Graph([[P, Q], [(P, Q)]])\n> }}}\n> \n> - The case of `Q` block could also be handled at the beginning, right ?\nWe can remove `SPR` block as it's addition of previous 3 variables, `R_blocks + polygons + P_blocks`. \\\\",
    "created_at": "2018-06-25T14:32:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304344",
    "user": "saiharsh"
}
```

Replying to [comment:62 dcoudert]:

> - Could you try to improve the comments. So far, some of them a really not clear ;)
I will try to add in the next commit. I am not yet good at writing formally.
> 
> - if `SG` is simplified to a cycle, can't we directly return the solution ?
Yes we can do this, 
R will be `[]` \\
S will be `SG` \\
P_block will be the components formed by combining multiple edges in `cocycle`. there are two ways to do it. \\
1. Make components by adding multiple edges. \\
2. Make multigraph using `cocycle` edges then extract subgraphs using `cuts`. \\
I feel option 1 is slightly better than option 2, let me know which option is better.
> 
> - In the part where you merge cycles to form `cycle_graph`, I'm not sure of what we want at the end. I suspect that we can do something smarter, but it depends on what we must get.
> 
It's a verification step used to check whether all the cycles are formed using `cocycle` edges. \\
Initially, I thought we can skip this step as there is no case in which cycle will be formed without using `cocycle` edge but I am not 100% sure.
> - Why are we returning so many different values ? Can't we just return a tree in which nodes a tuples (type, graph) ? Observe that using `immutable` graphs, we can do:
> {{{
> sage: P = Graph(1, immutable=True)
> sage: Q = Graph(2, immutable=True)
> sage: H = Graph([[P, Q], [(P, Q)]])
> }}}
> 
> - The case of `Q` block could also be handled at the beginning, right ?
We can remove `SPR` block as it's addition of previous 3 variables, `R_blocks + polygons + P_blocks`. \\



---

archive/issue_comments_304345.json:
```json
{
    "body": "> P_block will be the components formed by combining multiple edges in `cocycle`. there are two ways to do it. \\\\\n> 1. Make components by adding multiple edges. \\\\\n> 2. Make multigraph using `cocycle` edges then extract subgraphs using `cuts`. \\\\\n> I feel option 1 is slightly better than option 2, let me know which option is better.\n\nIt's also my impression.\n\n> > - In the part where you merge cycles to form `cycle_graph`, I'm not sure of what we want at the end. I suspect that we can do something smarter, but it depends on what we must get.\n> > \n> It's a verification step used to check whether all the cycles are formed using `cocycle` edges. \\\\\n> Initially, I thought we can skip this step as there is no case in which cycle will be formed without using `cocycle` edge but I am not 100% sure.\n\nMe neither. \n\n> > - Why are we returning so many different values ? Can't we just return a tree in which nodes a tuples (type, graph) ? Observe that using `immutable` graphs, we can do:\n> > {{{\n> > sage: P = Graph(1, immutable=True)\n> > sage: Q = Graph(2, immutable=True)\n> > sage: H = Graph([[P, Q], [(P, Q)]])\n> > }}}\n> > \n> > - The case of `Q` block could also be handled at the beginning, right ?\n> We can remove `SPR` block as it's addition of previous 3 variables, `R_blocks + polygons + P_blocks`. \\\\\n\nAssume that the nodes of the SPQR-tree are (immutable) multi-graphs and not subsets of vertices. If I give you only the SPQR-tree, we should be able to reconstruct the original graph, right ? So are other outputs necessary ?",
    "created_at": "2018-06-27T07:00:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304345",
    "user": "@dcoudert"
}
```

> P_block will be the components formed by combining multiple edges in `cocycle`. there are two ways to do it. \\
> 1. Make components by adding multiple edges. \\
> 2. Make multigraph using `cocycle` edges then extract subgraphs using `cuts`. \\
> I feel option 1 is slightly better than option 2, let me know which option is better.

It's also my impression.

> > - In the part where you merge cycles to form `cycle_graph`, I'm not sure of what we want at the end. I suspect that we can do something smarter, but it depends on what we must get.
> > 
> It's a verification step used to check whether all the cycles are formed using `cocycle` edges. \\
> Initially, I thought we can skip this step as there is no case in which cycle will be formed without using `cocycle` edge but I am not 100% sure.

Me neither. 

> > - Why are we returning so many different values ? Can't we just return a tree in which nodes a tuples (type, graph) ? Observe that using `immutable` graphs, we can do:
> > {{{
> > sage: P = Graph(1, immutable=True)
> > sage: Q = Graph(2, immutable=True)
> > sage: H = Graph([[P, Q], [(P, Q)]])
> > }}}
> > 
> > - The case of `Q` block could also be handled at the beginning, right ?
> We can remove `SPR` block as it's addition of previous 3 variables, `R_blocks + polygons + P_blocks`. \\

Assume that the nodes of the SPQR-tree are (immutable) multi-graphs and not subsets of vertices. If I give you only the SPQR-tree, we should be able to reconstruct the original graph, right ? So are other outputs necessary ?



---

archive/issue_comments_304346.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-27T11:30:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304346",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304347.json:
```json
{
    "body": "\n```\nsage: from sage.graphs.connectivity import spqr_tree\n....: G = Graph()\n....: G.add_cycle(vertices=[0,1,2,3,4])\n....: G.allow_multiple_edges(True)\n....: G.add_edges(G.edges())\n....: G.add_edge(2,3)\n....: G.add_edge(3,4)\n....: R,S,P,SPR,tricomp,SPQR_tree, tree_new = spqr_tree(G)\nsage: tree_new == SPQR_tree\nTrue\nsage: SPQR_tree.vertices()\n[('P', (0, 1), Subgraph of (): Multi-graph on 2 vertices),\n ('P', (0, 4), Subgraph of (): Multi-graph on 2 vertices),\n ('P', (1, 2), Subgraph of (): Multi-graph on 2 vertices),\n ('P', (2, 3), Subgraph of (): Multi-graph on 2 vertices),\n ('P', (3, 4), Subgraph of (): Multi-graph on 2 vertices),\n ('S', (0, 1, 2, 3, 4), Subgraph of (): Multi-graph on 5 vertices)]\n```\n\n\nUpdated SPQR_Tree vertices with subgraphs and added tree construction along with P_Block part for `SG` cycle case. \\\\\nLet me know this is the right way to do. \\\\\nFrom this, we need to return only `Tree` and not need to return other blocks.\\\\\nStill, subgraph vertices are there in SPQR_Tree it's for testing which will be removed.",
    "created_at": "2018-06-27T11:45:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304347",
    "user": "saiharsh"
}
```


```
sage: from sage.graphs.connectivity import spqr_tree
....: G = Graph()
....: G.add_cycle(vertices=[0,1,2,3,4])
....: G.allow_multiple_edges(True)
....: G.add_edges(G.edges())
....: G.add_edge(2,3)
....: G.add_edge(3,4)
....: R,S,P,SPR,tricomp,SPQR_tree, tree_new = spqr_tree(G)
sage: tree_new == SPQR_tree
True
sage: SPQR_tree.vertices()
[('P', (0, 1), Subgraph of (): Multi-graph on 2 vertices),
 ('P', (0, 4), Subgraph of (): Multi-graph on 2 vertices),
 ('P', (1, 2), Subgraph of (): Multi-graph on 2 vertices),
 ('P', (2, 3), Subgraph of (): Multi-graph on 2 vertices),
 ('P', (3, 4), Subgraph of (): Multi-graph on 2 vertices),
 ('S', (0, 1, 2, 3, 4), Subgraph of (): Multi-graph on 5 vertices)]
```


Updated SPQR_Tree vertices with subgraphs and added tree construction along with P_Block part for `SG` cycle case. \\
Let me know this is the right way to do. \\
From this, we need to return only `Tree` and not need to return other blocks.\\
Still, subgraph vertices are there in SPQR_Tree it's for testing which will be removed.



---

archive/issue_comments_304348.json:
```json
{
    "body": "Do you agree that, if after the `Split_multiple_edge Algorithm`, `SG` is reduced to a cycle,  it means that the graph `G` is a cycle with possibly multiple edges, and so that the SPQR-tree contains a single vertex `('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges()))` ? \n\nIf so, you do directly:\n\n```\nif SG.is_cycle():\n    return Graph({('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges())): []})\n```\n",
    "created_at": "2018-06-27T15:48:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304348",
    "user": "@dcoudert"
}
```

Do you agree that, if after the `Split_multiple_edge Algorithm`, `SG` is reduced to a cycle,  it means that the graph `G` is a cycle with possibly multiple edges, and so that the SPQR-tree contains a single vertex `('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges()))` ? 

If so, you do directly:

```
if SG.is_cycle():
    return Graph({('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges())): []})
```




---

archive/issue_comments_304349.json:
```json
{
    "body": "Replying to [comment:69 dcoudert]:\n> Do you agree that, if after the `Split_multiple_edge Algorithm`, `SG` is reduced to a cycle,  it means that the graph `G` is a cycle with possibly multiple edges, and so that the SPQR-tree contains a single vertex `('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges()))` ? \n> \n> If so, you do directly:\n> {{{\n> if SG.is_cycle():\n>     return Graph({('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges())): []})\n> }}}\nYes, `SG` will be a cycle if `G` is a cycle with few multi edges but in SPQR-Tree I feel we will have morethan one vertex because `G` is multi-graph so some edges will be added to `cocycle` which will lead to creation of `P_Block`(P vertices). \\\\\n\n`return Graph({('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges())`. \\\\\nThis is true when `G` is cycle with `n - 1` edges. So no edges will contribute in creation of `P_Block`. \\\\\n\ncorrect me if I am wrong.",
    "created_at": "2018-06-27T17:02:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304349",
    "user": "saiharsh"
}
```

Replying to [comment:69 dcoudert]:
> Do you agree that, if after the `Split_multiple_edge Algorithm`, `SG` is reduced to a cycle,  it means that the graph `G` is a cycle with possibly multiple edges, and so that the SPQR-tree contains a single vertex `('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges()))` ? 
> 
> If so, you do directly:
> {{{
> if SG.is_cycle():
>     return Graph({('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges())): []})
> }}}
Yes, `SG` will be a cycle if `G` is a cycle with few multi edges but in SPQR-Tree I feel we will have morethan one vertex because `G` is multi-graph so some edges will be added to `cocycle` which will lead to creation of `P_Block`(P vertices). \\

`return Graph({('S', Graph(G, immutable=True, multiedges=G.has_multiple_edges())`. \\
This is true when `G` is cycle with `n - 1` edges. So no edges will contribute in creation of `P_Block`. \\

correct me if I am wrong.



---

archive/issue_comments_304350.json:
```json
{
    "body": "I'm not completely sure of that, but may be I missed something in the definitions (not clear for multigraphs). Somehow, the question we have to answer is: can a P node be a leaf of the SPQR tree ?\\\\\nIf so, a P node is a separator only if it is also an internal vertex of the tree.\n\n`@`Meghana: what's your understanding of this case ?",
    "created_at": "2018-06-28T08:15:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304350",
    "user": "@dcoudert"
}
```

I'm not completely sure of that, but may be I missed something in the definitions (not clear for multigraphs). Somehow, the question we have to answer is: can a P node be a leaf of the SPQR tree ?\\
If so, a P node is a separator only if it is also an internal vertex of the tree.

`@`Meghana: what's your understanding of this case ?



---

archive/issue_comments_304351.json:
```json
{
    "body": "Replying to [comment:71 dcoudert]:\n> I'm not completely sure of that, but may be I missed something in the definitions (not clear for multigraphs). Somehow, the question we have to answer is: can a P node be a leaf of the SPQR tree ?\\\\\nYes, it can be a leaf node.\n> If so, a P node is a separator only if it is also an internal vertex of the tree.\nYes, it will be a separator if it's an internal vertex.\n\n```\n        sage: G = graphs.CompleteBipartiteGraph(2,3)\n        sage: G.add_edge(2, 3)\n        sage: G.allow_multiple_edges(True)\n        sage: G.add_edges(G.edges())\n        sage: G.add_edges([[0,1],[0,1],[0,1]])\n        sage: R,S,P,SPR,tricomp,SPQR_tree,tree_new = spqr_tree(G)\n```\n\nIn the above example some `P` elements are acting as leaf and some as internal vertex(a seperator).",
    "created_at": "2018-06-28T10:19:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304351",
    "user": "saiharsh"
}
```

Replying to [comment:71 dcoudert]:
> I'm not completely sure of that, but may be I missed something in the definitions (not clear for multigraphs). Somehow, the question we have to answer is: can a P node be a leaf of the SPQR tree ?\\
Yes, it can be a leaf node.
> If so, a P node is a separator only if it is also an internal vertex of the tree.
Yes, it will be a separator if it's an internal vertex.

```
        sage: G = graphs.CompleteBipartiteGraph(2,3)
        sage: G.add_edge(2, 3)
        sage: G.allow_multiple_edges(True)
        sage: G.add_edges(G.edges())
        sage: G.add_edges([[0,1],[0,1],[0,1]])
        sage: R,S,P,SPR,tricomp,SPQR_tree,tree_new = spqr_tree(G)
```

In the above example some `P` elements are acting as leaf and some as internal vertex(a seperator).



---

archive/issue_comments_304352.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-28T10:22:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304352",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304353.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-28T18:00:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304353",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304354.json:
```json
{
    "body": "With what I did, you can do (don't add a third edge between 0 and 1 in this example. There is an error in `is_clique`: #25696):\n\n```\nsage: G = Graph([(0, 1), (0, 1), (0, 3), (1, 2), (2, 3)], multiedges=True)\nsage: spqr_tree(G)\nSPQR-tree of : Graph on 2 vertices\nsage: spqr_tree(G).edges()\n[(('P', Multi-graph on 2 vertices), ('S', Multi-graph on 4 vertices), None)]\n```\n\nI think the code is simpler and we return only what we need = the SPQR tree. Do you agree or you think something is missing ?\n\n\n\nAt some point, we will need a function that reconstruct a graph from a SPQR tree.",
    "created_at": "2018-06-28T18:05:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304354",
    "user": "@dcoudert"
}
```

With what I did, you can do (don't add a third edge between 0 and 1 in this example. There is an error in `is_clique`: #25696):

```
sage: G = Graph([(0, 1), (0, 1), (0, 3), (1, 2), (2, 3)], multiedges=True)
sage: spqr_tree(G)
SPQR-tree of : Graph on 2 vertices
sage: spqr_tree(G).edges()
[(('P', Multi-graph on 2 vertices), ('S', Multi-graph on 4 vertices), None)]
```

I think the code is simpler and we return only what we need = the SPQR tree. Do you agree or you think something is missing ?



At some point, we will need a function that reconstruct a graph from a SPQR tree.



---

archive/issue_comments_304355.json:
```json
{
    "body": "Replying to [comment:75 dcoudert]:\n> With what I did, you can do (don't add a third edge between 0 and 1 in this example. There is an error in `is_clique`: #25696):\n> {{{\n> sage: G = Graph([(0, 1), (0, 1), (0, 3), (1, 2), (2, 3)], multiedges=True)\n> sage: spqr_tree(G)\n> SPQR-tree of : Graph on 2 vertices\n> sage: spqr_tree(G).edges()\n> [(('P', Multi-graph on 2 vertices), ('S', Multi-graph on 4 vertices), None)]\n> }}}\n> I think the code is simpler and we return only what we need = the SPQR tree. Do you agree or you think something is missing ?\nYes, SPQR-Tree is sufficient as all blocks with edges are covered in it.\n> \n> At some point, we will need a function that reconstruct a graph from a SPQR tree.\nIs it for verification?",
    "created_at": "2018-06-28T18:28:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304355",
    "user": "saiharsh"
}
```

Replying to [comment:75 dcoudert]:
> With what I did, you can do (don't add a third edge between 0 and 1 in this example. There is an error in `is_clique`: #25696):
> {{{
> sage: G = Graph([(0, 1), (0, 1), (0, 3), (1, 2), (2, 3)], multiedges=True)
> sage: spqr_tree(G)
> SPQR-tree of : Graph on 2 vertices
> sage: spqr_tree(G).edges()
> [(('P', Multi-graph on 2 vertices), ('S', Multi-graph on 4 vertices), None)]
> }}}
> I think the code is simpler and we return only what we need = the SPQR tree. Do you agree or you think something is missing ?
Yes, SPQR-Tree is sufficient as all blocks with edges are covered in it.
> 
> At some point, we will need a function that reconstruct a graph from a SPQR tree.
Is it for verification?



---

archive/issue_comments_304356.json:
```json
{
    "body": "> > I think the code is simpler and we return only what we need = the SPQR tree. Do you agree or you think something is missing ?\n> Yes, SPQR-Tree is sufficient as all blocks with edges are covered in it.\n\nSo you can improve the last parts of the method in this way and update the examples and tests ?\n\n> > At some point, we will need a function that reconstruct a graph from a SPQR tree.\n> Is it for verification?\nYes. It can be an internal method of `connectivity.pyx`. Then we can reconstruct and check that the resulting graph is isomorphic to the original one.",
    "created_at": "2018-06-28T18:33:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304356",
    "user": "@dcoudert"
}
```

> > I think the code is simpler and we return only what we need = the SPQR tree. Do you agree or you think something is missing ?
> Yes, SPQR-Tree is sufficient as all blocks with edges are covered in it.

So you can improve the last parts of the method in this way and update the examples and tests ?

> > At some point, we will need a function that reconstruct a graph from a SPQR tree.
> Is it for verification?
Yes. It can be an internal method of `connectivity.pyx`. Then we can reconstruct and check that the resulting graph is isomorphic to the original one.



---

archive/issue_comments_304357.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-28T20:03:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304357",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304358.json:
```json
{
    "body": "Replying to [comment:78 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> ||[fdae153](https://git.sagemath.org/sage.git/commit/?id=fdae15359d6813b2a1fa4e7f1947ce0fa99c80d7)||`Updated examples and output definition`||\nIs there is a way we can future improve the tree creation? \\\\\nUpdated the examples and removed few unused statements.",
    "created_at": "2018-06-28T20:22:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304358",
    "user": "saiharsh"
}
```

Replying to [comment:78 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[fdae153](https://git.sagemath.org/sage.git/commit/?id=fdae15359d6813b2a1fa4e7f1947ce0fa99c80d7)||`Updated examples and output definition`||
Is there is a way we can future improve the tree creation? \\
Updated the examples and removed few unused statements.



---

archive/issue_comments_304359.json:
```json
{
    "body": "The merging of cycles is not working well :(\n\n```\nsage: G = Graph(2)\nsage: for _ in range(3):\n....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])\n....:     \nsage: H = spqr_tree(G)\nsage: H.order()\n8\nsage: for u in H:\n....:     print u[0],u[1].vertices()\n....:     \nP [1, 4]\nS [0, 1, 2]\nP [1, 2]\nS [0, 1, 6, 7]\nS [1, 2, 3]\nP [0, 1]\nS [0, 1, 4]\nS [1, 4, 5]\n```\n",
    "created_at": "2018-06-29T06:45:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304359",
    "user": "@dcoudert"
}
```

The merging of cycles is not working well :(

```
sage: G = Graph(2)
sage: for _ in range(3):
....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])
....:     
sage: H = spqr_tree(G)
sage: H.order()
8
sage: for u in H:
....:     print u[0],u[1].vertices()
....:     
P [1, 4]
S [0, 1, 2]
P [1, 2]
S [0, 1, 6, 7]
S [1, 2, 3]
P [0, 1]
S [0, 1, 4]
S [1, 4, 5]
```




---

archive/issue_comments_304360.json:
```json
{
    "body": "Replying to [comment:80 dcoudert]:\n> The merging of cycles is not working well :(\n> {{{\n> sage: G = Graph(2)\n> sage: for _ in range(3):\n> ....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])\n> ....:     \n> sage: H = spqr_tree(G)\n> sage: H.order()\n> 8\n> sage: for u in H:\n> ....:     print u[0],u[1].vertices()\n> ....:     \n> P [1, 4]\n> S [0, 1, 2]\n> P [1, 2]\n> S [0, 1, 6, 7]\n> S [1, 2, 3]\n> P [0, 1]\n> S [0, 1, 4]\n> S [1, 4, 5]\n> }}}\nIs the problem is there are not sorted? \\\\\nany problem in accessing vertices like this\n\n```\nsage: G = Graph(2)\nsage: for _ in range(3):\n....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])\n....:     \nsage: H = spqr_tree(G)\nsage: H.order() \n10\nsage: for u in H.vertices():\n....:     print u[0], u[1].vertices()\n....:     \nP [0, 7]\nP [1, 2]\nP [0, 5]\nP [0, 1]\nS [0, 6, 7]\nS [0, 1, 7]\nS [0, 4, 5]\nS [0, 1, 5]\nS [1, 2, 3]\nS [0, 1, 2]\n```\n",
    "created_at": "2018-06-29T18:15:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304360",
    "user": "saiharsh"
}
```

Replying to [comment:80 dcoudert]:
> The merging of cycles is not working well :(
> {{{
> sage: G = Graph(2)
> sage: for _ in range(3):
> ....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])
> ....:     
> sage: H = spqr_tree(G)
> sage: H.order()
> 8
> sage: for u in H:
> ....:     print u[0],u[1].vertices()
> ....:     
> P [1, 4]
> S [0, 1, 2]
> P [1, 2]
> S [0, 1, 6, 7]
> S [1, 2, 3]
> P [0, 1]
> S [0, 1, 4]
> S [1, 4, 5]
> }}}
Is the problem is there are not sorted? \\
any problem in accessing vertices like this

```
sage: G = Graph(2)
sage: for _ in range(3):
....:     G.add_path([0, G.add_vertex(), G.add_vertex(), 1])
....:     
sage: H = spqr_tree(G)
sage: H.order() 
10
sage: for u in H.vertices():
....:     print u[0], u[1].vertices()
....:     
P [0, 7]
P [1, 2]
P [0, 5]
P [0, 1]
S [0, 6, 7]
S [0, 1, 7]
S [0, 4, 5]
S [0, 1, 5]
S [1, 2, 3]
S [0, 1, 2]
```




---

archive/issue_comments_304361.json:
```json
{
    "body": "No. I expect the SPQR tree to have 1 P block and 3 S blocks. We have more, meaning that the merging of cycles is not well done.",
    "created_at": "2018-06-29T21:45:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304361",
    "user": "@dcoudert"
}
```

No. I expect the SPQR tree to have 1 P block and 3 S blocks. We have more, meaning that the merging of cycles is not well done.



---

archive/issue_comments_304362.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-30T13:18:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304362",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304363.json:
```json
{
    "body": "I did multiple changes in the code. Some parts were not clear to me. The main change is to separate the manipulation of the multiedges of the original graph from the cocycle edges. I have also changed some data structure to have easier stuff to manipulate. I think that the merging of cycles is now correct. Also, the construction of the graph is easier the way I did it (*).\n\nTODO:\n- check the code carefully. Some additional comments might be needed, and I may have missed some cases.\n- check that the number of edges in the P blocks is what we expect. \n- do many tests to check if it's working. We could add extra examples / tests. For instance, we could add a test with `G = graphs.Grid2dGraph(2, 5)`, or the graph of the wikipedia page, etc.\n\n(*) I raised an issue in the immutable graph backend. I don't know if we should open a ticket to change this behavior, possibly with a deprecation warning. We can't do it in this ticket.",
    "created_at": "2018-06-30T13:29:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304363",
    "user": "@dcoudert"
}
```

I did multiple changes in the code. Some parts were not clear to me. The main change is to separate the manipulation of the multiedges of the original graph from the cocycle edges. I have also changed some data structure to have easier stuff to manipulate. I think that the merging of cycles is now correct. Also, the construction of the graph is easier the way I did it (*).

TODO:
- check the code carefully. Some additional comments might be needed, and I may have missed some cases.
- check that the number of edges in the P blocks is what we expect. 
- do many tests to check if it's working. We could add extra examples / tests. For instance, we could add a test with `G = graphs.Grid2dGraph(2, 5)`, or the graph of the wikipedia page, etc.

(*) I raised an issue in the immutable graph backend. I don't know if we should open a ticket to change this behavior, possibly with a deprecation warning. We can't do it in this ticket.



---

archive/issue_comments_304364.json:
```json
{
    "body": "Replying to [comment:84 dcoudert]:\n> I did multiple changes in the code. Some parts were not clear to me. The main change is to separate the manipulation of the multiedges of the original graph from the cocycle edges. I have also changed some data structure to have easier stuff to manipulate. I think that the merging of cycles is now correct. Also, the construction of the graph is easier the way I did it (*).\nYes, the changes preform better. \\\\\nI was trying to get a verification way to cross-check the results but couldn't find a good way to reconstruct the graph from the `Tree` as we are adding few edges.\ncould you say is there a good way to reconstruct `G` from `Tree`?\\\\\nI am trying `OGDF` for `SPQR-Tree` but getting few issues.\\\\\n> \n> TODO:\n> - check the code carefully. Some additional comments might be needed, and I may have missed some cases.\nYes, I will try.\n> - check that the number of edges in the P blocks is what we expect. \n> - do many tests to check if it's working. We could add extra examples / tests. For instance, we could add a test with `G = graphs.Grid2dGraph(2, 5)`, or the graph of the wikipedia page, etc.\n> \nYes, I will test on some standard examples(in reference papers), update you on this.\n\n> (*) I raised an issue in the immutable graph backend. I don't know if we should open a ticket to change this behavior, possibly with a deprecation warning. We can't do it in this ticket.\nin my view, If it helps others by adding deprecation warning then we can open a ticket for it.",
    "created_at": "2018-07-01T22:22:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304364",
    "user": "saiharsh"
}
```

Replying to [comment:84 dcoudert]:
> I did multiple changes in the code. Some parts were not clear to me. The main change is to separate the manipulation of the multiedges of the original graph from the cocycle edges. I have also changed some data structure to have easier stuff to manipulate. I think that the merging of cycles is now correct. Also, the construction of the graph is easier the way I did it (*).
Yes, the changes preform better. \\
I was trying to get a verification way to cross-check the results but couldn't find a good way to reconstruct the graph from the `Tree` as we are adding few edges.
could you say is there a good way to reconstruct `G` from `Tree`?\\
I am trying `OGDF` for `SPQR-Tree` but getting few issues.\\
> 
> TODO:
> - check the code carefully. Some additional comments might be needed, and I may have missed some cases.
Yes, I will try.
> - check that the number of edges in the P blocks is what we expect. 
> - do many tests to check if it's working. We could add extra examples / tests. For instance, we could add a test with `G = graphs.Grid2dGraph(2, 5)`, or the graph of the wikipedia page, etc.
> 
Yes, I will test on some standard examples(in reference papers), update you on this.

> (*) I raised an issue in the immutable graph backend. I don't know if we should open a ticket to change this behavior, possibly with a deprecation warning. We can't do it in this ticket.
in my view, If it helps others by adding deprecation warning then we can open a ticket for it.



---

archive/issue_comments_304365.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-04T11:14:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304365",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304366.json:
```json
{
    "body": "I added method `spqr_tree_to_graph`. It is useful to check that the construction is correct.\nOn the way I solved an issue with the number of edges in the P blocks. It should now be OK.\n\n=> Please check again the code and test these methods with various examples. If you find errors / typos / etc. correct them.",
    "created_at": "2018-07-04T11:20:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304366",
    "user": "@dcoudert"
}
```

I added method `spqr_tree_to_graph`. It is useful to check that the construction is correct.
On the way I solved an issue with the number of edges in the P blocks. It should now be OK.

=> Please check again the code and test these methods with various examples. If you find errors / typos / etc. correct them.



---

archive/issue_comments_304367.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-07-04T11:20:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304367",
    "user": "@dcoudert"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_304368.json:
```json
{
    "body": "Replying to [comment:87 dcoudert]:\n> I added method `spqr_tree_to_graph`. It is useful to check that the construction is correct.\n> On the way I solved an issue with the number of edges in the P blocks. It should now be OK.\nYes, it's okay now, on the last version, I found only two counter case, in which the number of `S` and `P` block is (4, 2) which is expected to be (9, 8), verified by OGDF code. this occurred on the example graph provided by Hopcroft paper, that 4 S components are found by breaking 2 squares into 4 triangles by using 2 cut edges. But the current version is giving the correct answer now. \\\\\nThe second example was on a graph which is formed by combining 4 cycles of length 4, in which the previous version was giving 0 `S components` and the current version is giving the correct answer.\n\n> \n> => Please check again the code and test these methods with various examples. If you find errors / typos / etc. correct them.\n\nAdded the reference paper example to `spqr_tree_to_graph` function, it's the same graph on which the last version failed. \\\\\nAnd a very minor change in `spqr_tree` examples.\n\nFor the below graph there is a miss match in OGDF output and current version.\nfor Graph,\n\n```\nsage: G = graphs.CycleGraph(4)\nsage: G.allow_multiple_edges(True)\nsage: G.add_edges([(0, 2), (0, 2)])\nsage: T = spqr_tree(G)\nsage: T.vertices()\n[('R', Cycle graph: Multi-graph on 4 vertices)]\n```\n\nOGDF says it should have 2 `S components` and 2 `P components`. but both seems to be correct. \nExcept for this example, I feel everything is fine.",
    "created_at": "2018-07-04T20:59:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304368",
    "user": "saiharsh"
}
```

Replying to [comment:87 dcoudert]:
> I added method `spqr_tree_to_graph`. It is useful to check that the construction is correct.
> On the way I solved an issue with the number of edges in the P blocks. It should now be OK.
Yes, it's okay now, on the last version, I found only two counter case, in which the number of `S` and `P` block is (4, 2) which is expected to be (9, 8), verified by OGDF code. this occurred on the example graph provided by Hopcroft paper, that 4 S components are found by breaking 2 squares into 4 triangles by using 2 cut edges. But the current version is giving the correct answer now. \\
The second example was on a graph which is formed by combining 4 cycles of length 4, in which the previous version was giving 0 `S components` and the current version is giving the correct answer.

> 
> => Please check again the code and test these methods with various examples. If you find errors / typos / etc. correct them.

Added the reference paper example to `spqr_tree_to_graph` function, it's the same graph on which the last version failed. \\
And a very minor change in `spqr_tree` examples.

For the below graph there is a miss match in OGDF output and current version.
for Graph,

```
sage: G = graphs.CycleGraph(4)
sage: G.allow_multiple_edges(True)
sage: G.add_edges([(0, 2), (0, 2)])
sage: T = spqr_tree(G)
sage: T.vertices()
[('R', Cycle graph: Multi-graph on 4 vertices)]
```

OGDF says it should have 2 `S components` and 2 `P components`. but both seems to be correct. 
Except for this example, I feel everything is fine.



---

archive/issue_comments_304369.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-04T21:02:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304369",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304370.json:
```json
{
    "body": "> Added the reference paper example to `spqr_tree_to_graph` function, it's the same graph on which the last version failed. \\\\\n\nYou should add the link using `:wikipedia:`SPQR_tree``\n\n> And a very minor change in `spqr_tree` examples.\n\nWhy did you change this way ?\n\n```\n-        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'R')\n+        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'S')\n```\n\n a K4 is 3 connected, so it is a 'R' block, not a 'S' block.\n\n \n> For the below graph there is a miss match in OGDF output and current version.\n> for Graph,\n> {{{\n> sage: G = graphs.CycleGraph(4)\n> sage: G.allow_multiple_edges(True)\n> sage: G.add_edges([(0, 2), (0, 2)])\n> sage: T = spqr_tree(G)\n> sage: T.vertices()\n> [('R', Cycle graph: Multi-graph on 4 vertices)]\n> }}}\n> OGDF says it should have 2 `S components` and 2 `P components`. but both seems to be correct. \n> Except for this example, I feel everything is fine.\n\nIt's due to `is_clique`, as reported in #25696. The graph has 4 vertices and 6 edges...\n\nYou can rebase this ticket on top of #25696 and add the dependency. Then the example should work properly.\n\nOne case has not been treated yet: `Q` blocks when `G` is a single edge.",
    "created_at": "2018-07-04T21:45:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304370",
    "user": "@dcoudert"
}
```

> Added the reference paper example to `spqr_tree_to_graph` function, it's the same graph on which the last version failed. \\

You should add the link using `:wikipedia:`SPQR_tree``

> And a very minor change in `spqr_tree` examples.

Why did you change this way ?

```
-        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'R')
+        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'S')
```

 a K4 is 3 connected, so it is a 'R' block, not a 'S' block.

 
> For the below graph there is a miss match in OGDF output and current version.
> for Graph,
> {{{
> sage: G = graphs.CycleGraph(4)
> sage: G.allow_multiple_edges(True)
> sage: G.add_edges([(0, 2), (0, 2)])
> sage: T = spqr_tree(G)
> sage: T.vertices()
> [('R', Cycle graph: Multi-graph on 4 vertices)]
> }}}
> OGDF says it should have 2 `S components` and 2 `P components`. but both seems to be correct. 
> Except for this example, I feel everything is fine.

It's due to `is_clique`, as reported in #25696. The graph has 4 vertices and 6 edges...

You can rebase this ticket on top of #25696 and add the dependency. Then the example should work properly.

One case has not been treated yet: `Q` blocks when `G` is a single edge.



---

archive/issue_comments_304371.json:
```json
{
    "body": "Replying to [comment:90 dcoudert]:\n> > Added the reference paper example to `spqr_tree_to_graph` function, it's the same graph on which the last version failed. \\\\\n> \n> You should add the link using `:wikipedia:`SPQR_tree``\nYes added.\n\n> > And a very minor change in `spqr_tree` examples.\n> \n> Why did you change this way ?\n> {{{\n> -        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'R')\n> +        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'S')\n> }}}\n>  a K4 is 3 connected, so it is a 'R' block, not a 'S' block.\nYes, it should be `R` not `S`, as S contains cycles. my mistake.\n>  \n\n> \n> It's due to `is_clique`, as reported in #25696. The graph has 4 vertices and 6 edges...\n> \n> You can rebase this ticket on top of #25696 and add the dependency. Then the example should work properly.\n> \nI will rebase and try it.\n> One case has not been treated yet: `Q` blocks when `G` is a single edge.\nYes, all the examples are taken such that no `Q` block exists.",
    "created_at": "2018-07-04T22:09:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304371",
    "user": "saiharsh"
}
```

Replying to [comment:90 dcoudert]:
> > Added the reference paper example to `spqr_tree_to_graph` function, it's the same graph on which the last version failed. \\
> 
> You should add the link using `:wikipedia:`SPQR_tree``
Yes added.

> > And a very minor change in `spqr_tree` examples.
> 
> Why did you change this way ?
> {{{
> -        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'R')
> +        sage: all(u[1].is_isomorphic(K4) for u in Tree.vertices() if u[0] == 'S')
> }}}
>  a K4 is 3 connected, so it is a 'R' block, not a 'S' block.
Yes, it should be `R` not `S`, as S contains cycles. my mistake.
>  

> 
> It's due to `is_clique`, as reported in #25696. The graph has 4 vertices and 6 edges...
> 
> You can rebase this ticket on top of #25696 and add the dependency. Then the example should work properly.
> 
I will rebase and try it.
> One case has not been treated yet: `Q` blocks when `G` is a single edge.
Yes, all the examples are taken such that no `Q` block exists.



---

archive/issue_comments_304372.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-04T22:09:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304372",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304373.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-07T15:20:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304373",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304374.json:
```json
{
    "body": "`@`Meghana: can you do some tests ? This patch is almost ready, but we may have missed some cases.",
    "created_at": "2018-07-07T15:23:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304374",
    "user": "@dcoudert"
}
```

`@`Meghana: can you do some tests ? This patch is almost ready, but we may have missed some cases.



---

archive/issue_comments_304375.json:
```json
{
    "body": "Replying to [comment:94 dcoudert]:\n> `@`Meghana: can you do some tests ? This patch is almost ready, but we may have missed some cases.\n\nYes, I have been doing some tests. It seems correct with all the various test cases I checked till now. I am going through the code now. I will update if I find any errors.",
    "created_at": "2018-07-11T10:23:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304375",
    "user": "@meghanamreddy"
}
```

Replying to [comment:94 dcoudert]:
> `@`Meghana: can you do some tests ? This patch is almost ready, but we may have missed some cases.

Yes, I have been doing some tests. It seems correct with all the various test cases I checked till now. I am going through the code now. I will update if I find any errors.



---

archive/issue_comments_304376.json:
```json
{
    "body": "Can we add an example in the `cleave` function to show the usage of the parameter `virtual_edges`? Also, in which use case would we set the parameter to False? I was not sure about the use case since the definition of `virtual_edges` used in the `cleave` function is different from what we use in the linear time algorithm.",
    "created_at": "2018-07-11T12:45:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304376",
    "user": "@meghanamreddy"
}
```

Can we add an example in the `cleave` function to show the usage of the parameter `virtual_edges`? Also, in which use case would we set the parameter to False? I was not sure about the use case since the definition of `virtual_edges` used in the `cleave` function is different from what we use in the linear time algorithm.



---

archive/issue_comments_304377.json:
```json
{
    "body": "Replying to [comment:96 meghanamreddy]:\n> Can we add an example in the `cleave` function to show the usage of the parameter `virtual_edges`? \n\nSure. \n\n`@`Say Harsh: can you do that ?\n\n> Also, in which use case would we set the parameter to False? I was not sure about the use case since the definition of `virtual_edges` used in the `cleave` function is different from what we use in the linear time algorithm.\n\nThe way we implemented the `cleave` method is more general than for our needs only. It can be useful to set `virtual_edges=False` when you want the subgraphs induced by the cut. If `S` is the set of vertices of the cut, and `A` and `B` are the sets of vertices of connected components in `G-S`, then we get `G[A+S]` and `G[B+S]` with only edges from `G`.",
    "created_at": "2018-07-11T12:58:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304377",
    "user": "@dcoudert"
}
```

Replying to [comment:96 meghanamreddy]:
> Can we add an example in the `cleave` function to show the usage of the parameter `virtual_edges`? 

Sure. 

`@`Say Harsh: can you do that ?

> Also, in which use case would we set the parameter to False? I was not sure about the use case since the definition of `virtual_edges` used in the `cleave` function is different from what we use in the linear time algorithm.

The way we implemented the `cleave` method is more general than for our needs only. It can be useful to set `virtual_edges=False` when you want the subgraphs induced by the cut. If `S` is the set of vertices of the cut, and `A` and `B` are the sets of vertices of connected components in `G-S`, then we get `G[A+S]` and `G[B+S]` with only edges from `G`.



---

archive/issue_comments_304378.json:
```json
{
    "body": "Replying to [comment:97 dcoudert]:\n\n> `@`Say Harsh: can you do that ?\nYes, I will do that.",
    "created_at": "2018-07-11T13:12:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304378",
    "user": "saiharsh"
}
```

Replying to [comment:97 dcoudert]:

> `@`Say Harsh: can you do that ?
Yes, I will do that.



---

archive/issue_comments_304379.json:
```json
{
    "body": "> The way we implemented the `cleave` method is more general than for our needs only. It can be useful to set `virtual_edges=False` when you want the subgraphs induced by the cut. If `S` is the set of vertices of the cut, and `A` and `B` are the sets of vertices of connected components in `G-S`, then we get `G[A+S]` and `G[B+S]` with only edges from `G`.\n\nOk, I understood now.\n\nI was using the following example of a cycle on `5` vertices to test the parameter `virtual_edges`:\n\n```\nG = Graph()\nG.add_edges([(1,2),(1,5),(2,4),(3,4),(3,5)])\nS,C,f = cleave(G, cut_vertices=[1,2,3], virtual_edges=True)\n```\n\nIn the case where `virtual_edges` is set to True, `f` is a path graph on `3` vertices. In the case where it is set to False, it is a graph with `3` isolated vertices. However, according to the definition of `f`, \n    `f` is the complement of the subgraph of `G` induced by the vertex cut. Hence, its vertex set is the vertex cut, and its edge set is the set of virtual edges.\n\nHence, when `virtual_edges` is set to False, `f` in the above example should be a graph on vertices `1,2 and 3` with one edge between `2` and `3` (which is the complement of the subgraph). I am not sure what the output should be when `virtual_edges` is set to true.",
    "created_at": "2018-07-11T14:06:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304379",
    "user": "@meghanamreddy"
}
```

> The way we implemented the `cleave` method is more general than for our needs only. It can be useful to set `virtual_edges=False` when you want the subgraphs induced by the cut. If `S` is the set of vertices of the cut, and `A` and `B` are the sets of vertices of connected components in `G-S`, then we get `G[A+S]` and `G[B+S]` with only edges from `G`.

Ok, I understood now.

I was using the following example of a cycle on `5` vertices to test the parameter `virtual_edges`:

```
G = Graph()
G.add_edges([(1,2),(1,5),(2,4),(3,4),(3,5)])
S,C,f = cleave(G, cut_vertices=[1,2,3], virtual_edges=True)
```

In the case where `virtual_edges` is set to True, `f` is a path graph on `3` vertices. In the case where it is set to False, it is a graph with `3` isolated vertices. However, according to the definition of `f`, 
    `f` is the complement of the subgraph of `G` induced by the vertex cut. Hence, its vertex set is the vertex cut, and its edge set is the set of virtual edges.

Hence, when `virtual_edges` is set to False, `f` in the above example should be a graph on vertices `1,2 and 3` with one edge between `2` and `3` (which is the complement of the subgraph). I am not sure what the output should be when `virtual_edges` is set to true.



---

archive/issue_comments_304380.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-11T15:33:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304380",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304381.json:
```json
{
    "body": "> I was using the following example of a cycle on `5` vertices to test the parameter `virtual_edges`:\n...\n> Hence, when `virtual_edges` is set to False, `f` in the above example should be a graph on vertices `1,2 and 3` with one edge between `2` and `3` (which is the complement of the subgraph). I am not sure what the output should be when `virtual_edges` is set to true.\n\nWhen `virtual_edges==False`, we don't add virtual edges to the sides of the cut. `f` is the graph containing only the virtual edges, so when we don't add virtual edges, `f` has no edges. When `virtual_edges==True`, then `f` is the complement of the subgraph induced by the cut. We should update the documentation accordingly.\n\nConcerning last commit: \nThe convention in Sagemath is to write `Return the connected components...` and not `Returns the connected components...`.\nIt has not yet been unified. We change it step by step.",
    "created_at": "2018-07-11T15:56:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304381",
    "user": "@dcoudert"
}
```

> I was using the following example of a cycle on `5` vertices to test the parameter `virtual_edges`:
...
> Hence, when `virtual_edges` is set to False, `f` in the above example should be a graph on vertices `1,2 and 3` with one edge between `2` and `3` (which is the complement of the subgraph). I am not sure what the output should be when `virtual_edges` is set to true.

When `virtual_edges==False`, we don't add virtual edges to the sides of the cut. `f` is the graph containing only the virtual edges, so when we don't add virtual edges, `f` has no edges. When `virtual_edges==True`, then `f` is the complement of the subgraph induced by the cut. We should update the documentation accordingly.

Concerning last commit: 
The convention in Sagemath is to write `Return the connected components...` and not `Returns the connected components...`.
It has not yet been unified. We change it step by step.



---

archive/issue_comments_304382.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-11T17:16:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304382",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304383.json:
```json
{
    "body": "Replying to [comment:102 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> ||[a6f2a5a](https://git.sagemath.org/sage.git/commit/?id=a6f2a5ab5fe881193b4f081f9b0abf599ff872a9)||`Virtual edge case added`||\nWe will have the same output for virtual_edge == True and False if the complement subgraph of cut vertices has no edges, which means subgraph of cut vertices is a complete graph. \\\\\n\nAnd yes, `f` has no virtual edge when `virtual_edge == False` we can see it at virtual edges set to the false case in example.",
    "created_at": "2018-07-11T17:22:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304383",
    "user": "saiharsh"
}
```

Replying to [comment:102 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[a6f2a5a](https://git.sagemath.org/sage.git/commit/?id=a6f2a5ab5fe881193b4f081f9b0abf599ff872a9)||`Virtual edge case added`||
We will have the same output for virtual_edge == True and False if the complement subgraph of cut vertices has no edges, which means subgraph of cut vertices is a complete graph. \\

And yes, `f` has no virtual edge when `virtual_edge == False` we can see it at virtual edges set to the false case in example.



---

archive/issue_comments_304384.json:
```json
{
    "body": "> When `virtual_edges==False`, we don't add virtual edges to the sides of the cut. `f` is the graph containing only the virtual edges, so when we don't add virtual edges, `f` has no edges. When `virtual_edges==True`, then `f` is the complement of the subgraph induced by the cut. We should update the documentation accordingly.\n\nIn the example I considered, when `virtual_edges==True`, the virtual edges that are added are `(1,3)` and `(2,3)`. So when `virtual_edges==True`, `f` is the complement of the subgraph induced by the cut? Or `f` is the graph containing only the virtual edges? If it is the former, `f` would be a graph on `3` vertices with one edge between `(2,3)`. If it is the latter, `f` would be a path graph on three vertices. Currently, the output `f` is a path graph on `3` vertices. \n\nI know I am asking too many times, but I would like to update the documentation to make it more clear.\n\n> \n> Concerning last commit: \n> The convention in Sagemath is to write `Return the connected components...` and not `Returns the connected components...`.\n> It has not yet been unified. We change it step by step.\nMy mistake, I saw in `generic_graph.py` and followed the same. I will change it.",
    "created_at": "2018-07-11T19:01:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304384",
    "user": "@meghanamreddy"
}
```

> When `virtual_edges==False`, we don't add virtual edges to the sides of the cut. `f` is the graph containing only the virtual edges, so when we don't add virtual edges, `f` has no edges. When `virtual_edges==True`, then `f` is the complement of the subgraph induced by the cut. We should update the documentation accordingly.

In the example I considered, when `virtual_edges==True`, the virtual edges that are added are `(1,3)` and `(2,3)`. So when `virtual_edges==True`, `f` is the complement of the subgraph induced by the cut? Or `f` is the graph containing only the virtual edges? If it is the former, `f` would be a graph on `3` vertices with one edge between `(2,3)`. If it is the latter, `f` would be a path graph on three vertices. Currently, the output `f` is a path graph on `3` vertices. 

I know I am asking too many times, but I would like to update the documentation to make it more clear.

> 
> Concerning last commit: 
> The convention in Sagemath is to write `Return the connected components...` and not `Returns the connected components...`.
> It has not yet been unified. We change it step by step.
My mistake, I saw in `generic_graph.py` and followed the same. I will change it.



---

archive/issue_comments_304385.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-12T05:32:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304385",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304386.json:
```json
{
    "body": "As said Sai Harsh, when \n* `virtual_edges == True`, `f` contains all the virtual edges which are the edges of the complement of the subgraph of `G` induced by the cut. In your example, it is a path graph with edges `(1,3)` and `(2, 3)`.\n* `virtual_edges == False`, `f` is an independent set, so a graph containing only the vertices of the cut and no edge.",
    "created_at": "2018-07-12T07:20:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304386",
    "user": "@dcoudert"
}
```

As said Sai Harsh, when 
* `virtual_edges == True`, `f` contains all the virtual edges which are the edges of the complement of the subgraph of `G` induced by the cut. In your example, it is a path graph with edges `(1,3)` and `(2, 3)`.
* `virtual_edges == False`, `f` is an independent set, so a graph containing only the vertices of the cut and no edge.



---

archive/issue_comments_304387.json:
```json
{
    "body": "Okay, I understood now. I had done a silly mistake in my previous question, my bad, sorry for the repeated questions.\n\nI ran many test cases on the `sqpr_tree` and `spqr_tree_to_graph` functions, and there seemed to be no errors.",
    "created_at": "2018-07-12T07:42:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304387",
    "user": "@meghanamreddy"
}
```

Okay, I understood now. I had done a silly mistake in my previous question, my bad, sorry for the repeated questions.

I ran many test cases on the `sqpr_tree` and `spqr_tree_to_graph` functions, and there seemed to be no errors.



---

archive/issue_comments_304388.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-13T11:22:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304388",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_304389.json:
```json
{
    "body": "Minor edits so that the doc build properly.",
    "created_at": "2018-07-13T11:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304389",
    "user": "@dcoudert"
}
```

Minor edits so that the doc build properly.



---

archive/issue_comments_304390.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-07-13T17:36:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304390",
    "user": "@dcoudert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_304391.json:
```json
{
    "body": "For me this patch is now good to go !",
    "created_at": "2018-07-13T17:36:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304391",
    "user": "@dcoudert"
}
```

For me this patch is now good to go !



---

archive/issue_comments_304392.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-08-11T16:55:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21920",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21920#issuecomment-304392",
    "user": "@vbraun"
}
```

Resolution: fixed
