# Issue 26184: Polynomial roots cannot be calculated over a ring of Laurent polynomials

archive/issues_026184.json:
```json
{
    "body": "CC:  @tscrim\n\nKeywords: roots, factor, integral domain, Laurent polynomial\n\n... even if the polynomial is linear or the roots are integers:\n\n\n```\nsage: R.<t> = LaurentPolynomialRing(ZZ)\nsage: P.<x> = PolynomialRing(R)\nsage: p = x-t\nsage: p.roots()\n/home/sebastian/develop/sage/src/bin/sage-ipython:1: DeprecationWarning: content is deprecated. Please use content_ideal instead.\nSee http://trac.sagemath.org/16613 for details.\n  #!/usr/bin/env sage-python23\n---------------------------------------------------------------------------\nTraceback (most recent call last):\n...\nTypeError: ideal() takes exactly 1 argument (2 given)\n```\n\n\nThe calculation aborts, since the method `ideal`  of the class `LaurentPolynomialRing_generic` is not implemented but invoked via `content_ideal` which could be avoided or replaced by the function `lcm`.\n\nBut there are further problems:\n\n1) The method `ideal` of the class `LaurentPolynomialRing_generic` raises the wrong error, since it doesn't have the right number of arguments.\n\n2) The correct `NotImplementedError` would not be caught.\n\n3) Factorization over some cases of integral domains is not implemented in the method `factor` of  the class `Polynomial` (even though it should be possible using the field of fractions)\n\n4) Just aesthetically: The deprecation of the method `content` (#16613) has not been implemented properly (the warning can't be avoided by the user).\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/26421\n\n",
    "created_at": "2018-10-06T07:01:49Z",
    "labels": [
        "PLEASE CHANGE",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.1",
    "title": "Polynomial roots cannot be calculated over a ring of Laurent polynomials",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/26184",
    "user": "@soehms"
}
```
CC:  @tscrim

Keywords: roots, factor, integral domain, Laurent polynomial

... even if the polynomial is linear or the roots are integers:


```
sage: R.<t> = LaurentPolynomialRing(ZZ)
sage: P.<x> = PolynomialRing(R)
sage: p = x-t
sage: p.roots()
/home/sebastian/develop/sage/src/bin/sage-ipython:1: DeprecationWarning: content is deprecated. Please use content_ideal instead.
See http://trac.sagemath.org/16613 for details.
  #!/usr/bin/env sage-python23
---------------------------------------------------------------------------
Traceback (most recent call last):
...
TypeError: ideal() takes exactly 1 argument (2 given)
```


The calculation aborts, since the method `ideal`  of the class `LaurentPolynomialRing_generic` is not implemented but invoked via `content_ideal` which could be avoided or replaced by the function `lcm`.

But there are further problems:

1) The method `ideal` of the class `LaurentPolynomialRing_generic` raises the wrong error, since it doesn't have the right number of arguments.

2) The correct `NotImplementedError` would not be caught.

3) Factorization over some cases of integral domains is not implemented in the method `factor` of  the class `Polynomial` (even though it should be possible using the field of fractions)

4) Just aesthetically: The deprecation of the method `content` (#16613) has not been implemented properly (the warning can't be avoided by the user).


Issue created by migration from https://trac.sagemath.org/ticket/26421





---

archive/issue_comments_368939.json:
```json
{
    "body": "I do the following:\n\n1) Correct the argument list of `ideal`.\n\n2) Catch `NotImplementedError` on invocation from the method `roots` via `content_ideal` and inserted the use of `lcm` in case of exception\n\n3) Implement the factorization over proper integral domains via the field of fraction in former cases of `NotImplementedError`.\n\n4) Correct the deprecated invocations of `content`\n\nThe reason why I use `FractionField_generic` instead of `FractionField` in 3) is because the method `fraction_field` of the class `LaurentPolynomialRing_generic` returns the fraction field of the corresponding polynomial ring instead of the fraction field of itself (which would be the default from the class `CommutativeRing`). This causes coercion problems in `base_change` of the class `Factorization`.  \n----\nNew commits:",
    "created_at": "2018-10-06T07:33:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368939",
    "user": "@soehms"
}
```

I do the following:

1) Correct the argument list of `ideal`.

2) Catch `NotImplementedError` on invocation from the method `roots` via `content_ideal` and inserted the use of `lcm` in case of exception

3) Implement the factorization over proper integral domains via the field of fraction in former cases of `NotImplementedError`.

4) Correct the deprecated invocations of `content`

The reason why I use `FractionField_generic` instead of `FractionField` in 3) is because the method `fraction_field` of the class `LaurentPolynomialRing_generic` returns the fraction field of the corresponding polynomial ring instead of the fraction field of itself (which would be the default from the class `CommutativeRing`). This causes coercion problems in `base_change` of the class `Factorization`.  
----
New commits:



---

archive/issue_comments_368940.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-10-06T07:33:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368940",
    "user": "@soehms"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_368941.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to algebra.",
    "created_at": "2018-10-06T07:48:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368941",
    "user": "@tscrim"
}
```

Changing component from PLEASE CHANGE to algebra.



---

archive/issue_comments_368942.json:
```json
{
    "body": "Replying to [comment:2 soehms]:\n> The reason why I use `FractionField_generic` instead of `FractionField` in 3) is because the method `fraction_field` of the class `LaurentPolynomialRing_generic` returns the fraction field of the corresponding polynomial ring instead of the fraction field of itself (which would be the default from the class `CommutativeRing`). This causes coercion problems in `base_change` of the class `Factorization`.  \n\nI am not sure about doing that. The reason has to do with units and normalization of fractions. Since `x` is a unit, then implicitly `1/x` is different from `(1/x)/1`. Also, what about classes that have a custom `fraction_field` implementation? It feels like the wrong thing to do.\n\nSome other quick comments:\n\n- Please correct `:trac:`26421'` -> `:trac:`26421`` and\n  {{{#!diff\n-        check that trac:`26421` is fixed:\n+        Check that :trac:`26421` is fixed::\n  }}}\n- Do not have bare `except:` statements. List which errors you want to catch explicitly.",
    "created_at": "2018-10-06T07:48:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368942",
    "user": "@tscrim"
}
```

Replying to [comment:2 soehms]:
> The reason why I use `FractionField_generic` instead of `FractionField` in 3) is because the method `fraction_field` of the class `LaurentPolynomialRing_generic` returns the fraction field of the corresponding polynomial ring instead of the fraction field of itself (which would be the default from the class `CommutativeRing`). This causes coercion problems in `base_change` of the class `Factorization`.  

I am not sure about doing that. The reason has to do with units and normalization of fractions. Since `x` is a unit, then implicitly `1/x` is different from `(1/x)/1`. Also, what about classes that have a custom `fraction_field` implementation? It feels like the wrong thing to do.

Some other quick comments:

- Please correct `:trac:`26421'` -> `:trac:`26421`` and
  {{{#!diff
-        check that trac:`26421` is fixed:
+        Check that :trac:`26421` is fixed::
  }}}
- Do not have bare `except:` statements. List which errors you want to catch explicitly.



---

archive/issue_comments_368943.json:
```json
{
    "body": "Replying to [comment:3 tscrim]:\n\nThank you for your hints, Travis!\n\n> Replying to [comment:2 soehms]:\n> > The reason why I use `FractionField_generic` instead of `FractionField` in 3) is because \n> > ...\n> \n> I am not sure about doing that. The reason has to do with units and normalization of fractions. Since `x` is a unit, then implicitly `1/x` is different from `(1/x)/1`. \n\nI really don't understand the argument, why the field of fraction over the corresponding polynomial ring is preferred. Even not after reading the original discussion about that:\n\nhttps://trac.sagemath.org/ticket/15345#comment:13\n\nWithout the `fraction_field`-method in the Laurent polynomial class the following doctests change (like they have been resulting originally). \n\n\n```\nFile \"src/sage/rings/polynomial/polynomial_element.pyx\", line 4184, in sage.rings.polynomial.polynomial_element.Polynomial.factor\nFailed example:\n    factor(x^2 - q^2)\nExpected:\n    (x - q) * (x + q)\nGot:\n    (-1) * (-x + q) * (x + q)\n**********************************************************************\nFile \"src/sage/rings/polynomial/polynomial_element.pyx\", line 4186, in sage.rings.polynomial.polynomial_element.Polynomial.factor\nFailed example:\n    factor(x^2 - q^-2)\nExpected:\n    (x - 1/q) * (x + 1/q)\nGot:\n    (q^-2) * (q*x - 1) * (q*x + 1)\n```\n\n\nDoes this give a hint to the reason? Why is the current version of that doctests preferable?\n\n\n\n> Also, what about classes that have a custom `fraction_field` implementation? It feels like the wrong thing to do.\n> \n\n\nI agree! But how can I get the coercion work for the Laurent polynomial case?\n\n\n```\nsage: R.<t> = LaurentPolynomialRing(ZZ)\nsage: F = R.fraction_field()\nsage: ti = F(1/t)\nsage: R(ti)\nTraceback (most recent call last):\n...\nTypeError: fraction must have unit denominator\n```\n\n\n\n> - Do not have bare `except:` statements. List which errors you want to catch explicitly.\n\nThe bare `except` in the `factor` method I use because I don't want to change the previous behavior to much (which is a `NotImplementedError`). So a change should only be in the case of success. I can change the `pass` to an explicit `raise` command, to make this clear.\n\nThe other occurrence in the `roots` method I will erase, since a second try with `lcm` (which should have been `gcd`) doesn't make much sense.",
    "created_at": "2018-10-06T19:04:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368943",
    "user": "@soehms"
}
```

Replying to [comment:3 tscrim]:

Thank you for your hints, Travis!

> Replying to [comment:2 soehms]:
> > The reason why I use `FractionField_generic` instead of `FractionField` in 3) is because 
> > ...
> 
> I am not sure about doing that. The reason has to do with units and normalization of fractions. Since `x` is a unit, then implicitly `1/x` is different from `(1/x)/1`. 

I really don't understand the argument, why the field of fraction over the corresponding polynomial ring is preferred. Even not after reading the original discussion about that:

https://trac.sagemath.org/ticket/15345#comment:13

Without the `fraction_field`-method in the Laurent polynomial class the following doctests change (like they have been resulting originally). 


```
File "src/sage/rings/polynomial/polynomial_element.pyx", line 4184, in sage.rings.polynomial.polynomial_element.Polynomial.factor
Failed example:
    factor(x^2 - q^2)
Expected:
    (x - q) * (x + q)
Got:
    (-1) * (-x + q) * (x + q)
**********************************************************************
File "src/sage/rings/polynomial/polynomial_element.pyx", line 4186, in sage.rings.polynomial.polynomial_element.Polynomial.factor
Failed example:
    factor(x^2 - q^-2)
Expected:
    (x - 1/q) * (x + 1/q)
Got:
    (q^-2) * (q*x - 1) * (q*x + 1)
```


Does this give a hint to the reason? Why is the current version of that doctests preferable?



> Also, what about classes that have a custom `fraction_field` implementation? It feels like the wrong thing to do.
> 


I agree! But how can I get the coercion work for the Laurent polynomial case?


```
sage: R.<t> = LaurentPolynomialRing(ZZ)
sage: F = R.fraction_field()
sage: ti = F(1/t)
sage: R(ti)
Traceback (most recent call last):
...
TypeError: fraction must have unit denominator
```



> - Do not have bare `except:` statements. List which errors you want to catch explicitly.

The bare `except` in the `factor` method I use because I don't want to change the previous behavior to much (which is a `NotImplementedError`). So a change should only be in the case of success. I can change the `pass` to an explicit `raise` command, to make this clear.

The other occurrence in the `roots` method I will erase, since a second try with `lcm` (which should have been `gcd`) doesn't make much sense.



---

archive/issue_comments_368944.json:
```json
{
    "body": "Replying to [comment:4 soehms]:\n> Replying to [comment:3 tscrim]:\n> > Replying to [comment:2 soehms]:\n> > > The reason why I use `FractionField_generic` instead of `FractionField` in 3) is because \n> > > ...\n> > \n> > I am not sure about doing that. The reason has to do with units and normalization of fractions. Since `x` is a unit, then implicitly `1/x` is different from `(1/x)/1`. \n> \n> I really don't understand the argument, why the field of fraction over the corresponding polynomial ring is preferred. Even not after reading the original discussion about that:\n> \n> #15345#comment:13\n> \n> Without the `fraction_field`-method in the Laurent polynomial class the following doctests change (like they have been resulting originally). \n> \n> {{{\n> File \"src/sage/rings/polynomial/polynomial_element.pyx\", line 4184, in sage.rings.polynomial.polynomial_element.Polynomial.factor\n> Failed example:\n>     factor(x^2 - q^2)\n> Expected:\n>     (x - q) * (x + q)\n> Got:\n>     (-1) * (-x + q) * (x + q)\n> **********************************************************************\n> File \"src/sage/rings/polynomial/polynomial_element.pyx\", line 4186, in sage.rings.polynomial.polynomial_element.Polynomial.factor\n> Failed example:\n>     factor(x^2 - q^-2)\n> Expected:\n>     (x - 1/q) * (x + 1/q)\n> Got:\n>     (q^-2) * (q*x - 1) * (q*x + 1)\n> }}}\n> \n> Does this give a hint to the reason? Why is the current version of that doctests preferable?\n\nPerhaps think about it this way, would you write `x/-1` or `-x`? Basically, you do not want units in the denominator, you would rather normalize that to `1`. So that is why I would say the current behavior is better in the latter example. I believe in terms of commutative algebra, the usual polynomial ring has a better category than Laurent polynomials, but I am not 100% sure of that aspect.\n\nSomething else that was going wrong was going between the two \"different\" fraction fields: the one for polynomials and for Laurent polynomials (see comment 3 on #15345). It makes things much easier when `R[x]` and `R[x,x^-1]` both go to `R(x)`.\n\n> > Also, what about classes that have a custom `fraction_field` implementation? It feels like the wrong thing to do.\n> \n> I agree! But how can I get the coercion work for the Laurent polynomial case?\n> \n> {{{\n> sage: R.<t> = LaurentPolynomialRing(ZZ)\n> sage: F = R.fraction_field()\n> sage: ti = F(1/t)\n> sage: R(ti)\n> Traceback (most recent call last):\n> ...\n> TypeError: fraction must have unit denominator\n> }}}\n\nI would say that is a bug in the conversion of the Laurent polynomial ring (and deserves a separate ticket). It seems like it is not converting the denominator to `self` before seeing if it a unit.\n\n> > - Do not have bare `except:` statements. List which errors you want to catch explicitly.\n> \n> The bare `except` in the `factor` method I use because I don't want to change the previous behavior to much (which is a `NotImplementedError`). So a change should only be in the case of success. I can change the `pass` to an explicit `raise` command, to make this clear.\n\nBy having a bare `expect:` you are catching everything. Catch what you expect to be thrown as catching everything can further hide bugs. If you need to continue to propagate up an error, call `raise`. You can also have different behaviors for different exceptions, e.g.,:\n\n```\ntry:\n    foo\nexcept ValueError:\n    pass\nexcept TypeError:\n    raise\n```\n",
    "created_at": "2018-10-06T23:45:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368944",
    "user": "@tscrim"
}
```

Replying to [comment:4 soehms]:
> Replying to [comment:3 tscrim]:
> > Replying to [comment:2 soehms]:
> > > The reason why I use `FractionField_generic` instead of `FractionField` in 3) is because 
> > > ...
> > 
> > I am not sure about doing that. The reason has to do with units and normalization of fractions. Since `x` is a unit, then implicitly `1/x` is different from `(1/x)/1`. 
> 
> I really don't understand the argument, why the field of fraction over the corresponding polynomial ring is preferred. Even not after reading the original discussion about that:
> 
> #15345#comment:13
> 
> Without the `fraction_field`-method in the Laurent polynomial class the following doctests change (like they have been resulting originally). 
> 
> {{{
> File "src/sage/rings/polynomial/polynomial_element.pyx", line 4184, in sage.rings.polynomial.polynomial_element.Polynomial.factor
> Failed example:
>     factor(x^2 - q^2)
> Expected:
>     (x - q) * (x + q)
> Got:
>     (-1) * (-x + q) * (x + q)
> **********************************************************************
> File "src/sage/rings/polynomial/polynomial_element.pyx", line 4186, in sage.rings.polynomial.polynomial_element.Polynomial.factor
> Failed example:
>     factor(x^2 - q^-2)
> Expected:
>     (x - 1/q) * (x + 1/q)
> Got:
>     (q^-2) * (q*x - 1) * (q*x + 1)
> }}}
> 
> Does this give a hint to the reason? Why is the current version of that doctests preferable?

Perhaps think about it this way, would you write `x/-1` or `-x`? Basically, you do not want units in the denominator, you would rather normalize that to `1`. So that is why I would say the current behavior is better in the latter example. I believe in terms of commutative algebra, the usual polynomial ring has a better category than Laurent polynomials, but I am not 100% sure of that aspect.

Something else that was going wrong was going between the two "different" fraction fields: the one for polynomials and for Laurent polynomials (see comment 3 on #15345). It makes things much easier when `R[x]` and `R[x,x^-1]` both go to `R(x)`.

> > Also, what about classes that have a custom `fraction_field` implementation? It feels like the wrong thing to do.
> 
> I agree! But how can I get the coercion work for the Laurent polynomial case?
> 
> {{{
> sage: R.<t> = LaurentPolynomialRing(ZZ)
> sage: F = R.fraction_field()
> sage: ti = F(1/t)
> sage: R(ti)
> Traceback (most recent call last):
> ...
> TypeError: fraction must have unit denominator
> }}}

I would say that is a bug in the conversion of the Laurent polynomial ring (and deserves a separate ticket). It seems like it is not converting the denominator to `self` before seeing if it a unit.

> > - Do not have bare `except:` statements. List which errors you want to catch explicitly.
> 
> The bare `except` in the `factor` method I use because I don't want to change the previous behavior to much (which is a `NotImplementedError`). So a change should only be in the case of success. I can change the `pass` to an explicit `raise` command, to make this clear.

By having a bare `expect:` you are catching everything. Catch what you expect to be thrown as catching everything can further hide bugs. If you need to continue to propagate up an error, call `raise`. You can also have different behaviors for different exceptions, e.g.,:

```
try:
    foo
except ValueError:
    pass
except TypeError:
    raise
```




---

archive/issue_comments_368945.json:
```json
{
    "body": "I still don't understand the change of the `FractionField` in ticket #15345. I understand that we want to avoid units in the denominator. But IMO, this issue is an internal of the FractionField_generic class. Why should this be something special for Laurent polynomial rings (except that it should support some information of what is an normalized representation)? Furthermore, the issue in comment 3 seems not to be reproducible with recent code:\n\n\n```\nsage: R = LaurentPolynomialRing(ZZ, 'x')\nsage: T = PolynomialRing(ZZ, 'x')\nsage: R.gen() + T.gen()\n2*x\nsage: F1 = FractionField(R)\nsage: import_statements('FractionField_generic')\nfrom sage.rings.fraction_field import FractionField_generic\nsage: from sage.rings.fraction_field import FractionField_generic\nsage: F2 = FractionField_generic(R)\nsage: R.gen() + F1.gen()\n2*x\nsage: R.gen() + F2.gen()\n2*x\nsage:\n```\n\n\nand all tests of ticket #15345 (under sage.rings) passed, when I removed the `fraction_field` method from the Laurent polynomial ring. On the other hand, the coercion problem does not occur for the original field of fraction:\n\n\n```\nsage: R(F2(1/t))\nx^-1\nsage: R(F1(1/t))\nTraceback (most recent call last):\n...\nTypeError: fraction must have unit denominator\n```\n\n\n\nI have opened ticket #26425 for the coercion problem. Concerning this ticket I will reduce the coefficients of my example to polynomials in t, such that they will work for `R.fraction_field()` as well.",
    "created_at": "2018-10-07T09:42:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368945",
    "user": "@soehms"
}
```

I still don't understand the change of the `FractionField` in ticket #15345. I understand that we want to avoid units in the denominator. But IMO, this issue is an internal of the FractionField_generic class. Why should this be something special for Laurent polynomial rings (except that it should support some information of what is an normalized representation)? Furthermore, the issue in comment 3 seems not to be reproducible with recent code:


```
sage: R = LaurentPolynomialRing(ZZ, 'x')
sage: T = PolynomialRing(ZZ, 'x')
sage: R.gen() + T.gen()
2*x
sage: F1 = FractionField(R)
sage: import_statements('FractionField_generic')
from sage.rings.fraction_field import FractionField_generic
sage: from sage.rings.fraction_field import FractionField_generic
sage: F2 = FractionField_generic(R)
sage: R.gen() + F1.gen()
2*x
sage: R.gen() + F2.gen()
2*x
sage:
```


and all tests of ticket #15345 (under sage.rings) passed, when I removed the `fraction_field` method from the Laurent polynomial ring. On the other hand, the coercion problem does not occur for the original field of fraction:


```
sage: R(F2(1/t))
x^-1
sage: R(F1(1/t))
Traceback (most recent call last):
...
TypeError: fraction must have unit denominator
```



I have opened ticket #26425 for the coercion problem. Concerning this ticket I will reduce the coefficients of my example to polynomials in t, such that they will work for `R.fraction_field()` as well.



---

archive/issue_comments_368946.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-10-07T09:42:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368946",
    "user": "@soehms"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_368947.json:
```json
{
    "body": "Replying to [comment:6 soehms]:\n> I still don't understand the change of the `FractionField` in ticket #15345. I understand that we want to avoid units in the denominator. But IMO, this issue is an internal of the FractionField_generic class.\n\nNo, it is not. The field of fractions of Laurent polynomials means you have things like `(1/x)/1`. Mathematically, this is not really an issue, but for a computer trying to sort things out consistently (e.g., for hashing and equality), it is more subtle. See below.\n\n> Why should this be something special for Laurent polynomial rings (except that it should support some information of what is an normalized representation)?\n\nIt is because it has a relatively large set of units and it does not work as well wrt things like the Euclidean algorithm IIRC. This is what leads to the issues with normalizations.\n\n> Furthermore, the issue in comment 3 seems not to be reproducible with recent code:\n> {{{\n> sage: R = LaurentPolynomialRing(ZZ, 'x')\n> sage: T = PolynomialRing(ZZ, 'x')\n> sage: R.gen() + T.gen()\n> 2*x\n> sage: F1 = FractionField(R)\n> sage: from sage.rings.fraction_field import FractionField_generic\n> sage: F2 = FractionField_generic(R)\n> sage: R.gen() + F1.gen()\n> 2*x\n> sage: R.gen() + F2.gen()\n> 2*x\n> }}}\n\nThat is good, it means the coercion framework has independently gotten more robust. However, the last part bit of this example shows the problem:\n\n```\nsage: p = (1/F2.gen()) / (2 + F2.gen())\nsage: q = 1/(2*F2.gen() + F2.gen()^2)\nsage: q\n1/(2*x + x^2)\nsage: p == q\nTrue\nsage: hash(p) == hash(q)\nFalse\n```\n\nEqual objects should have equal hashes (in this case, there is no coercion involved, it definitely should be consistent). This can cause very subtle problems with, e.g., `dict`s.",
    "created_at": "2018-10-07T10:35:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368947",
    "user": "@tscrim"
}
```

Replying to [comment:6 soehms]:
> I still don't understand the change of the `FractionField` in ticket #15345. I understand that we want to avoid units in the denominator. But IMO, this issue is an internal of the FractionField_generic class.

No, it is not. The field of fractions of Laurent polynomials means you have things like `(1/x)/1`. Mathematically, this is not really an issue, but for a computer trying to sort things out consistently (e.g., for hashing and equality), it is more subtle. See below.

> Why should this be something special for Laurent polynomial rings (except that it should support some information of what is an normalized representation)?

It is because it has a relatively large set of units and it does not work as well wrt things like the Euclidean algorithm IIRC. This is what leads to the issues with normalizations.

> Furthermore, the issue in comment 3 seems not to be reproducible with recent code:
> {{{
> sage: R = LaurentPolynomialRing(ZZ, 'x')
> sage: T = PolynomialRing(ZZ, 'x')
> sage: R.gen() + T.gen()
> 2*x
> sage: F1 = FractionField(R)
> sage: from sage.rings.fraction_field import FractionField_generic
> sage: F2 = FractionField_generic(R)
> sage: R.gen() + F1.gen()
> 2*x
> sage: R.gen() + F2.gen()
> 2*x
> }}}

That is good, it means the coercion framework has independently gotten more robust. However, the last part bit of this example shows the problem:

```
sage: p = (1/F2.gen()) / (2 + F2.gen())
sage: q = 1/(2*F2.gen() + F2.gen()^2)
sage: q
1/(2*x + x^2)
sage: p == q
True
sage: hash(p) == hash(q)
False
```

Equal objects should have equal hashes (in this case, there is no coercion involved, it definitely should be consistent). This can cause very subtle problems with, e.g., `dict`s.



---

archive/issue_comments_368948.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-10-07T21:42:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368948",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_368949.json:
```json
{
    "body": "Now, I've got it! Thanks for your patients, Travis!",
    "created_at": "2018-10-07T21:43:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368949",
    "user": "@soehms"
}
```

Now, I've got it! Thanks for your patients, Travis!



---

archive/issue_comments_368950.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-10-07T21:43:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368950",
    "user": "@soehms"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_368951.json:
```json
{
    "body": "Sorry, lost track of this. Can you rebase? I will finish the review after that.",
    "created_at": "2020-01-28T00:10:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368951",
    "user": "@tscrim"
}
```

Sorry, lost track of this. Can you rebase? I will finish the review after that.



---

archive/issue_comments_368952.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-01-28T20:22:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368952",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_368953.json:
```json
{
    "body": "Replying to [comment:10 tscrim]:\n> Sorry, lost track of this. \nNo problem!\n> Can you rebase? \nI hope that it's no problem that I merged it on top of #4618 which is closed, right now!\n> I will finish the review after that.\nGreat!",
    "created_at": "2020-01-28T20:28:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368953",
    "user": "@soehms"
}
```

Replying to [comment:10 tscrim]:
> Sorry, lost track of this. 
No problem!
> Can you rebase? 
I hope that it's no problem that I merged it on top of #4618 which is closed, right now!
> I will finish the review after that.
Great!



---

archive/issue_comments_368954.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-01-28T21:29:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368954",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_368955.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-01-29T05:09:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368955",
    "user": "@tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_368956.json:
```json
{
    "body": "Thank you. LGTM now.",
    "created_at": "2020-01-29T05:09:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368956",
    "user": "@tscrim"
}
```

Thank you. LGTM now.



---

archive/issue_comments_368957.json:
```json
{
    "body": "Thanks!",
    "created_at": "2020-01-29T10:41:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368957",
    "user": "@soehms"
}
```

Thanks!



---

archive/issue_comments_368958.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2020-01-31T23:49:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368958",
    "user": "@vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_368959.json:
```json
{
    "body": "While I had a look at ticket #25227 I realized a bug in the above implementation. Therefore, I opened ticket #29266 for a fix!",
    "created_at": "2020-03-01T20:33:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26184",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26184#issuecomment-368959",
    "user": "@soehms"
}
```

While I had a look at ticket #25227 I realized a bug in the above implementation. Therefore, I opened ticket #29266 for a fix!
