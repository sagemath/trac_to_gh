# Issue 30482: Add build/pkgs/SPKG/install-requires.txt for all Python packages

Issue created by migration from https://trac.sagemath.org/ticket/30719

Original creator: mkoeppe

Original creation time: 2020-10-04 17:30:11

CC:  @tobiasdiez isuruf fbissey arojas dimpase

These files:

- serve as a marker that an SPKG is a Python package (for #29013)
- may include comments that explain why we reject certain versions
- provide version constraints (lower and upper bounds)
- can be used to generate other metadata such as `src/Pipfile`, `src/setup.cfg [install_requires]` (#29041) in the `bootstrap` phase, to avoid duplicating this information in various places


---

Comment by mkoeppe created at 2020-10-04 17:51:22

Tobias, before I add more of these, do you think this format is useful for generating other files?

----
New commits:


---

Comment by git created at 2020-10-04 18:21:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-10-04 18:50:08

So the idea would be to concatenate all these `install-requires.txt` files to obtain the `install_requires` section of `src/setup.cfg`? That should work. Except that cython is a more a compile time dependency (`[build-system] requires = ["cython"]` in `pyproject.toml`), right?

I have to admit though that I don't see the benefit of having all these text files over having a single `src/setup.cfg` (or pyproject for that matter). It feels like it's the same information, just in a different location.
In fact, it feels a bit like you are reinventing the wheel. pyproject etc also have support for different kinds of dependencies, e.g. optional, compile time (cython), test (pytest) and build dependencies (tox).

Maybe that's a bit too naÃ¯ve, but I would approach this as follows: `sagelib` (everything in `/src`) is a python library and as such only declares minimum dependencies and their requirements, trying not to pin versions (except if it's really necessary). I think, the most modern way would be to do this via a `pyproject.toml` file.
Then sage-the-application (the actual thing used by the enduser) is a python application and thus includes sagelib as a library and needs to satisfy its dependencies (this is the point where you have to specify in some way the exact version you want to use).
sage-the library should be completely independent of sage-the-application (i.e. it should work to have them in different git repositories).


---

Comment by mkoeppe created at 2020-10-04 19:38:12

Replying to [comment:4 gh-tobiasdiez]:
> So the idea would be to concatenate all these `install-requires.txt` files to obtain the `install_requires` section of `src/setup.cfg`?

Yes.

> That should work. Except that cython is a more a compile time dependency (`[build-system] requires = ["cython"]` in `pyproject.toml`), right?

Right; but sagelib also exposes cython at runtime for interactive use.

> I have to admit though that I don't see the benefit of having all these text files over having a single `src/setup.cfg` (or pyproject for that matter). It feels like it's the same information, just in a different location.

With modularization, I expect to see dozens of `setup.cfg` files for the various subset distributions. Basically, I don't want to duplicate version ranges between these.

> In fact, it feels a bit like you are reinventing the wheel. pyproject etc also have support for different kinds of dependencies, e.g. optional, compile time (cython), test (pytest) and build dependencies (tox).

What I want to do is define version ranges in one place for all of the Sage project.

Distinguishing the kinds of dependencies (build, test, ...) should be orthogonal -- and the mechanism in #29041 should be able to put these version ranges into whatever file/format is needed. 

(I don't think it would add sufficient value to Sage to have different version ranges for a given package in different roles, like "we need Cython >= 0.29.21 for build, but any Cython >= 0.27 is fine for runtime.)
 
> sage-the library should be completely independent of sage-the-application (i.e. it should work to have them in different git repositories). 

I don't like to go into this direction because it would add a big hurdle to our developer community. Having one git repository is key.


---

Comment by @tobiasdiez created at 2020-10-04 20:53:14

Replying to [comment:5 mkoeppe]:
> > I have to admit though that I don't see the benefit of having all these text files over having a single `src/setup.cfg` (or pyproject for that matter). It feels like it's the same information, just in a different location.
> 
> With modularization, I expect to see dozens of `setup.cfg` files for the various subset distributions. Basically, I don't want to duplicate version ranges between these.

Sounds like a valid point.


> Having one git repository is key. 

I agree! What I meant is that it might be helpful to approach it like this, i.e. how would you solve this problem if sage-library would be sitting in a different git repo? I think, this will be helpful e.g for distribution as pipy-installable package where it would be helpful if `src/` works independently of the `make` and `build` scripts. 


One more remark: I would try to make the version range specifications as general as possible, i.e. only add restrictions if its known that that this particular version doesn't work with sage (this in particular applies to the upper limit). Otherwise the sage-library (and its subdistributions) would be harder to use (e.g. if one cannot upgrade/downgrade a dependency because other code relies on it). In this context, it may actually turn out to be helpful if you could could control the dependency versions for each submodule sepereatly, e.g. if ModuleA breaks with a newer version but ModuleB doesn't have these problems.


---

Comment by mkoeppe created at 2020-10-04 21:05:05

Replying to [comment:6 gh-tobiasdiez]:
> What I meant is that it might be helpful to approach it like this, i.e. how would you solve this problem if sage-library would be sitting in a different git repo? I think, this will be helpful e.g for distribution as pipy-installable package where it would be helpful if `src/` works independently of the `make` and `build` scripts. 

Sounds like we are basically in agreement here. One detail, however, is the bootstrapping phase. The way I see it, after running `./bootstrap`, we would have standard Python package source trees (which will not depend on make and build) -- right now, `src` or `build/pkgs/sagelib/src/`, but many more after modularization (such as `build/pkgs/sage-ntl/src/`). By using scripts that are executed during bootstrapping, we can avoid duplicating a lot of information and thus reduce the maintenance burden.


---

Comment by mkoeppe created at 2020-10-04 21:10:33

Replying to [comment:6 gh-tobiasdiez]:
> I would try to make the version range specifications as general as possible, i.e. only add restrictions if its known that that this particular version doesn't work with sage (this in particular applies to the upper limit). Otherwise the sage-library (and its subdistributions) would be harder to use (e.g. if one cannot upgrade/downgrade a dependency because other code relies on it). 

Yes, this is tricky to get right and will probably need some detailed discussion for individual packages. But I do think that some upper bounds on the version are always needed because we do not want our package to stop working if a new major version of some package is released on pypi. For example, Cython has an upcoming 3.x version which we have not tested with at all.

> In this context, it may actually turn out to be helpful if you could could control the dependency versions for each submodule separately, e.g. if ModuleA breaks with a newer version but ModuleB doesn't have these problems.

Yes, this is conceivable but I would hope that if this ever becomes necessary, it can be implemented by overriding the default rather than defaulting to duplicate maintenance of the version ranges.


---

Comment by git created at 2020-10-04 21:57:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-10-04 21:58:11

Autogenerated for now, setting current version as lower bound


---

Comment by mkoeppe created at 2020-11-11 19:45:53

I'm hoping to gather version information for our Python packages here.


---

Comment by mkoeppe created at 2020-11-11 19:45:53

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2020-11-11 20:07:19

Changing priority from major to critical.


---

Comment by git created at 2020-11-11 20:12:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by fbissey created at 2020-11-11 20:16:22

That's a lot of packages to parse :(

Some stuff I can notice from a cursory inspection. I use sphinx 3.2.1 so the restriction `<3.2` seem useless. Similarly I currently use networkx 2.5. `python_openid` was a sagenb dependency, I don't think we need it anymore. I certainly do not have it anymore on my system. Same with `itsdangerous`.


---

Comment by @tobiasdiez created at 2020-11-11 20:48:56

The pipenv.lock file added in #30371 is a good indication, too.

The `<1.0` constraint for cython seems to be not necessary (at least they are very far off from version 1.0).


---

Comment by git created at 2020-11-11 22:03:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-11-11 22:04:02

Replying to [comment:18 gh-tobiasdiez]:
> The `<1.0` constraint for cython seems to be not necessary (at least they are very far off from version 1.0).
From comment 8:
  For example, Cython has an upcoming 3.x version which we have not tested with at all.


---

Comment by git created at 2020-11-11 22:12:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-11-11 22:34:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-11-12 00:08:02

See also: Upgrade ticket #30611


---

Comment by git created at 2020-11-12 00:23:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-11-12 00:55:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-11-12 00:59:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-11-12 01:33:30

Good enough as a first approximation?


---

Comment by mkoeppe created at 2020-11-12 22:22:23

Missing: numpy


---

Comment by git created at 2020-11-12 23:08:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2020-11-13 11:01:56

OK, good. (all tests of this branch pass on Fedora 30, too)


---

Comment by dimpase created at 2020-11-13 11:01:56

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2020-11-14 00:38:15

Thanks!


---

Comment by vbraun created at 2020-11-20 22:15:16

Resolution: fixed
