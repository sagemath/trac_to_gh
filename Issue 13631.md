# Issue 13631: pickle_function, unpickle_function don't handle default arguments properly

archive/issues_013631.json:
```json
{
    "body": "Assignee: was\n\nThe following came up in ticket #13814:\n\n\n```python\n   sage: f = Permutations \n   sage: from sage.misc.fpickle import pickle_function, unpickle_function \n   sage: g = unpickle_function(pickle_function(f)) \n   sage: print f(5) \n   Standard permutations of 5\n   sage: print g(5) \n   Traceback (most recent call last):\n   ...\n   TypeError: Permutations() takes exactly 2 arguments (1 given)\n```\n\n\nNicholas Thierry suggested to make this a separate ticket:\n> Yes, this is definitely a misfeature with sage.misc.fpickle. It should\n> be fixed to use standard pickling when it can (e.g. for a function\n> defined in a library). And it should return something that can be\n> unpickled with a plain loads. And, as mentioned in the code of family\n> it should be registered to copy_reg so that it would be called\n> automatically by dumps without needing to pollute one's code (like\n> family) with it. \n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/13835\n\n",
    "created_at": "2012-12-16T15:33:03Z",
    "labels": [
        "pickling",
        "major",
        "bug"
    ],
    "title": "pickle_function, unpickle_function don't handle default arguments properly",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13631",
    "user": "cnassau"
}
```
Assignee: was

The following came up in ticket #13814:


```python
   sage: f = Permutations 
   sage: from sage.misc.fpickle import pickle_function, unpickle_function 
   sage: g = unpickle_function(pickle_function(f)) 
   sage: print f(5) 
   Standard permutations of 5
   sage: print g(5) 
   Traceback (most recent call last):
   ...
   TypeError: Permutations() takes exactly 2 arguments (1 given)
```


Nicholas Thierry suggested to make this a separate ticket:
> Yes, this is definitely a misfeature with sage.misc.fpickle. It should
> be fixed to use standard pickling when it can (e.g. for a function
> defined in a library). And it should return something that can be
> unpickled with a plain loads. And, as mentioned in the code of family
> it should be registered to copy_reg so that it would be called
> automatically by dumps without needing to pollute one's code (like
> family) with it. 



Issue created by migration from https://trac.sagemath.org/ticket/13835





---

archive/issue_comments_168656.json:
```json
{
    "body": "Here are a few more failures from #13814 in Sage 5.5.rc0.\n\n   {{{#!python\n   sage: f=Family(NonNegativeIntegers(),Partitions) ; f\n   Lazy family (Partitions(i))_{i in Non negative integers}\n   sage: loads(dumps(f))\n   Traceback (most recent call last)\n   ...\n   ValueError: Cannot pickle code objects from closures\n\n   sage: f=Family(NonNegativeIntegers(),lambda n:Partitions(n))\n   sage: g=loads(dumps(f))\n   sage: f[5]\n   Partitions of the integer 5\n   sage: g[5]\n   Traceback (most recent call last)\n   ...\n   NameError: global name 'Partitions' is not defined\n   }}}",
    "created_at": "2012-12-17T06:44:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13631",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13631#issuecomment-168656",
    "user": "cnassau"
}
```

Here are a few more failures from #13814 in Sage 5.5.rc0.

   {{{#!python
   sage: f=Family(NonNegativeIntegers(),Partitions) ; f
   Lazy family (Partitions(i))_{i in Non negative integers}
   sage: loads(dumps(f))
   Traceback (most recent call last)
   ...
   ValueError: Cannot pickle code objects from closures

   sage: f=Family(NonNegativeIntegers(),lambda n:Partitions(n))
   sage: g=loads(dumps(f))
   sage: f[5]
   Partitions of the integer 5
   sage: g[5]
   Traceback (most recent call last)
   ...
   NameError: global name 'Partitions' is not defined
   }}}



---

archive/issue_comments_168657.json:
```json
{
    "body": "Perhaps #11845 has some relevant information?\n\nFurthermore: Don't do this as a way to make sage objects \"picklable\". The python marshal module does allow for serialization of code objects but one should not consider the resulting serializations as a \"pickle\". The level to which pickles are meant to be backward/forward compatible simply cannot be guaranteed for code objects.\n\nIf your object's state consists in an essential way on a code object: too bad, your object is not pickle-able in the normal sense of the word. You are depending on state that is only available in a python-version dependent form and that's not good enough for Pickle.\n\n(for instance, if sage were to move to Python 3, your pickle would have to break)",
    "created_at": "2012-12-21T09:20:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13631",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13631#issuecomment-168657",
    "user": "nbruin"
}
```

Perhaps #11845 has some relevant information?

Furthermore: Don't do this as a way to make sage objects "picklable". The python marshal module does allow for serialization of code objects but one should not consider the resulting serializations as a "pickle". The level to which pickles are meant to be backward/forward compatible simply cannot be guaranteed for code objects.

If your object's state consists in an essential way on a code object: too bad, your object is not pickle-able in the normal sense of the word. You are depending on state that is only available in a python-version dependent form and that's not good enough for Pickle.

(for instance, if sage were to move to Python 3, your pickle would have to break)
