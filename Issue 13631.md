# Issue 13631: pickle_function, unpickle_function don't handle default arguments properly

Issue created by migration from Trac.

Original creator: cnassau

Original creation time: 2012-12-16 15:33:03

Assignee: was

The following came up in ticket #13814:


```python
   sage: f = Permutations 
   sage: from sage.misc.fpickle import pickle_function, unpickle_function 
   sage: g = unpickle_function(pickle_function(f)) 
   sage: print f(5) 
   Standard permutations of 5
   sage: print g(5) 
   Traceback (most recent call last):
   ...
   TypeError: Permutations() takes exactly 2 arguments (1 given)
```


Nicholas Thierry suggested to make this a separate ticket:
> Yes, this is definitely a misfeature with sage.misc.fpickle. It should
> be fixed to use standard pickling when it can (e.g. for a function
> defined in a library). And it should return something that can be
> unpickled with a plain loads. And, as mentioned in the code of family
> it should be registered to copy_reg so that it would be called
> automatically by dumps without needing to pollute one's code (like
> family) with it. 




---

Comment by cnassau created at 2012-12-17 06:44:19

Here are a few more failures from #13814 in Sage 5.5.rc0.

   {{{#!python
   sage: f=Family(NonNegativeIntegers(),Partitions) ; f
   Lazy family (Partitions(i))_{i in Non negative integers}
   sage: loads(dumps(f))
   Traceback (most recent call last)
   ...
   ValueError: Cannot pickle code objects from closures

   sage: f=Family(NonNegativeIntegers(),lambda n:Partitions(n))
   sage: g=loads(dumps(f))
   sage: f[5]
   Partitions of the integer 5
   sage: g[5]
   Traceback (most recent call last)
   ...
   NameError: global name 'Partitions' is not defined
   }}}


---

Comment by nbruin created at 2012-12-21 09:20:09

Perhaps #11845 has some relevant information?

Furthermore: Don't do this as a way to make sage objects "picklable". The python marshal module does allow for serialization of code objects but one should not consider the resulting serializations as a "pickle". The level to which pickles are meant to be backward/forward compatible simply cannot be guaranteed for code objects.

If your object's state consists in an essential way on a code object: too bad, your object is not pickle-able in the normal sense of the word. You are depending on state that is only available in a python-version dependent form and that's not good enough for Pickle.

(for instance, if sage were to move to Python 3, your pickle would have to break)
