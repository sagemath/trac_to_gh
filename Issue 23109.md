# Issue 23109: Doing some maintanence on LieAlgebraElement

archive/issues_023109.json:
```json
{
    "body": "CC:  sage-combinat @bsalisbury1\n\nWe can now `cdef` the class `LieAlgebraElement` since #22632 is merged. This also does some other fixes to `__mul__` to better handle `int` input and to `lift` to handle when the UEA has a different indexing set or is the PBW basis.\n\nIssue created by migration from https://trac.sagemath.org/ticket/23346\n\n",
    "created_at": "2017-07-01T00:11:40Z",
    "labels": [
        "component: algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "Doing some maintanence on LieAlgebraElement",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/23109",
    "user": "https://github.com/tscrim"
}
```
CC:  sage-combinat @bsalisbury1

We can now `cdef` the class `LieAlgebraElement` since #22632 is merged. This also does some other fixes to `__mul__` to better handle `int` input and to `lift` to handle when the UEA has a different indexing set or is the PBW basis.

Issue created by migration from https://trac.sagemath.org/ticket/23346





---

archive/issue_comments_322873.json:
```json
{
    "body": "New commits:",
    "created_at": "2017-07-01T00:12:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322873",
    "user": "https://github.com/tscrim"
}
```

New commits:



---

archive/issue_comments_322874.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-07-01T00:12:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322874",
    "user": "https://github.com/tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_322875.json:
```json
{
    "body": "Just commenting on the Cython code in `lie_algebra_element.pyx`:\n\n1. You are cimporting various things that you don't actually use. I assume that this was for some earlier failed experiment?\n\n2. Is there any reason that `self` should have a `lift()` method? Remember that arithmetic in Cython is different from Python: you cannot assume that `self` is an instance of the class. For that reason, I would also avoid the name `self`: the signature would better be written as `def __mul__(left, right)`.\n\n3. Why did you change `self.lift() * y` to `coercion_model.bin_op(self.lift(), y, mul)`? There is normally no reason to explicitly invoke the coercion model like this.",
    "created_at": "2017-07-04T12:58:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322875",
    "user": "https://github.com/jdemeyer"
}
```

Just commenting on the Cython code in `lie_algebra_element.pyx`:

1. You are cimporting various things that you don't actually use. I assume that this was for some earlier failed experiment?

2. Is there any reason that `self` should have a `lift()` method? Remember that arithmetic in Cython is different from Python: you cannot assume that `self` is an instance of the class. For that reason, I would also avoid the name `self`: the signature would better be written as `def __mul__(left, right)`.

3. Why did you change `self.lift() * y` to `coercion_model.bin_op(self.lift(), y, mul)`? There is normally no reason to explicitly invoke the coercion model like this.



---

archive/issue_comments_322876.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-07-04T12:58:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322876",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_322877.json:
```json
{
    "body": "Replying to [comment:2 jdemeyer]:\n> Just commenting on the Cython code in `lie_algebra_element.pyx`:\n> \n> 1. You are cimporting various things that you don't actually use. I assume that this was for some earlier failed experiment?\n\n\nYes, that's right. Those should be removed.\n\n> 2. Is there any reason that `self` should have a `lift()` method? Remember that arithmetic in Cython is different from Python: you cannot assume that `self` is an instance of the class. For that reason, I would also avoid the name `self`: the signature would better be written as `def __mul__(left, right)`.\n  \n>\n> 3. Why did you change `self.lift() * y` to `coercion_model.bin_op(self.lift(), y, mul)`? There is normally no reason to explicitly invoke the coercion model like this.\n\n\nWhat I am trying to do is implement `x * y` such that if `x` is a Lie algebra element and `y` is not in is base ring (or with the role of `x` and `y` swapped), then it lifts `x` up to a bigger algebra (the universal enveloping algebra) where `*` is defined (associatively). So really this should be a coercion map where it converts `x` and `y` to a common parent as there is not an action of `y` on `x` (or vice versa).\n\nHowever, I don't know how to do this in the current system as the bigger algebra may not have been constructed yet (but is available through `L.universal_enveloping_algebra`). I would be happy enough if `x` and `y` were both elements of `L` (i.e., using `_mul_`) and then call `lift()` on both elements and multiply, but the coercion framework needs the result to be in `L`. So what I am trying to do is essentially emulate the coercion framework to get around this.\n\nDoing things this way is what got it to do what I wanted it to do without breaking anything. However, I am sure there is a better way to do this. Suggestions welcomed.\n\nMaybe an analogy in a less specialized area of math would be when you do `x + y` with two (multiplicative) group elements, then it would automatically coerce into the corresponding group algebras. (I'm not saying this is a feature we want, but merely would be the same concept).",
    "created_at": "2017-07-04T13:51:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322877",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:2 jdemeyer]:
> Just commenting on the Cython code in `lie_algebra_element.pyx`:
> 
> 1. You are cimporting various things that you don't actually use. I assume that this was for some earlier failed experiment?


Yes, that's right. Those should be removed.

> 2. Is there any reason that `self` should have a `lift()` method? Remember that arithmetic in Cython is different from Python: you cannot assume that `self` is an instance of the class. For that reason, I would also avoid the name `self`: the signature would better be written as `def __mul__(left, right)`.
  
>
> 3. Why did you change `self.lift() * y` to `coercion_model.bin_op(self.lift(), y, mul)`? There is normally no reason to explicitly invoke the coercion model like this.


What I am trying to do is implement `x * y` such that if `x` is a Lie algebra element and `y` is not in is base ring (or with the role of `x` and `y` swapped), then it lifts `x` up to a bigger algebra (the universal enveloping algebra) where `*` is defined (associatively). So really this should be a coercion map where it converts `x` and `y` to a common parent as there is not an action of `y` on `x` (or vice versa).

However, I don't know how to do this in the current system as the bigger algebra may not have been constructed yet (but is available through `L.universal_enveloping_algebra`). I would be happy enough if `x` and `y` were both elements of `L` (i.e., using `_mul_`) and then call `lift()` on both elements and multiply, but the coercion framework needs the result to be in `L`. So what I am trying to do is essentially emulate the coercion framework to get around this.

Doing things this way is what got it to do what I wanted it to do without breaking anything. However, I am sure there is a better way to do this. Suggestions welcomed.

Maybe an analogy in a less specialized area of math would be when you do `x + y` with two (multiplicative) group elements, then it would automatically coerce into the corresponding group algebras. (I'm not saying this is a feature we want, but merely would be the same concept).



---

archive/issue_comments_322878.json:
```json
{
    "body": "Replying to [comment:3 tscrim]:\n> Maybe an analogy in a less specialized area of math would be when you do `x + y` with two (multiplicative) group elements\n\n\nContinuing your analogy, it seems that your input is really one group element and one other object which could be anything. Since it really could be anything, you shouldn't force the Sage coercion model on it.\n\nWhat's wrong with something like\n\n```\ndef __mul__(left, right):\n    # ...\n    # handle base ring stuff first\n    # ...\n    if isinstance(left, LieAlgebraElement):\n        left = left.lift()   # Or (<LieAlgebraElement>left).lift() if lift is cpdef\n    if isinstance(right, LieAlgebraElement):\n        right = right.lift()\n    return left * right\n```",
    "created_at": "2017-07-04T14:04:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322878",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:3 tscrim]:
> Maybe an analogy in a less specialized area of math would be when you do `x + y` with two (multiplicative) group elements


Continuing your analogy, it seems that your input is really one group element and one other object which could be anything. Since it really could be anything, you shouldn't force the Sage coercion model on it.

What's wrong with something like

```
def __mul__(left, right):
    # ...
    # handle base ring stuff first
    # ...
    if isinstance(left, LieAlgebraElement):
        left = left.lift()   # Or (<LieAlgebraElement>left).lift() if lift is cpdef
    if isinstance(right, LieAlgebraElement):
        right = right.lift()
    return left * right
```



---

archive/issue_comments_322879.json:
```json
{
    "body": "Replying to [comment:4 jdemeyer]:\n> Replying to [comment:3 tscrim]:\n> > Maybe an analogy in a less specialized area of math would be when you do `x + y` with two (multiplicative) group elements\n\n> \n> Continuing your analogy, it seems that your input is really one group element and one other object which could be anything. Since it really could be anything, you shouldn't force the Sage coercion model on it.\n\n\nTrue, well, I want to assume that the other one is something coercible into a group element. So I need to invoke the coercion model at some point. Although I guess I can let the coercion model do its thing via `+` once I lift up the group element.\n\n> What's wrong with something like\n> \n> ```\n> def __mul__(left, right):\n>     # ...\n>     # handle base ring stuff first\n>     # ...\n>     if isinstance(left, LieAlgebraElement):\n>         left = left.lift()   # Or (<LieAlgebraElement>left).lift() if lift is cpdef\n>     if isinstance(right, LieAlgebraElement):\n>         right = right.lift()\n>     return left * right\n> ```\n\n\nI think that should work. At least I don't see anything wrong with that at this point. I will test.",
    "created_at": "2017-07-04T14:20:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322879",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:4 jdemeyer]:
> Replying to [comment:3 tscrim]:
> > Maybe an analogy in a less specialized area of math would be when you do `x + y` with two (multiplicative) group elements

> 
> Continuing your analogy, it seems that your input is really one group element and one other object which could be anything. Since it really could be anything, you shouldn't force the Sage coercion model on it.


True, well, I want to assume that the other one is something coercible into a group element. So I need to invoke the coercion model at some point. Although I guess I can let the coercion model do its thing via `+` once I lift up the group element.

> What's wrong with something like
> 
> ```
> def __mul__(left, right):
>     # ...
>     # handle base ring stuff first
>     # ...
>     if isinstance(left, LieAlgebraElement):
>         left = left.lift()   # Or (<LieAlgebraElement>left).lift() if lift is cpdef
>     if isinstance(right, LieAlgebraElement):
>         right = right.lift()
>     return left * right
> ```


I think that should work. At least I don't see anything wrong with that at this point. I will test.



---

archive/issue_comments_322880.json:
```json
{
    "body": "Replying to [comment:5 tscrim]:\n> Although I guess I can let the coercion model do its thing via `+` once I lift up the group element.\n\n\nYes, that is what I meant. There is usually no reason to call the coercion model directly.",
    "created_at": "2017-07-04T14:35:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322880",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:5 tscrim]:
> Although I guess I can let the coercion model do its thing via `+` once I lift up the group element.


Yes, that is what I meant. There is usually no reason to call the coercion model directly.



---

archive/issue_comments_322881.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-04T15:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322881",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_322882.json:
```json
{
    "body": "Okay, I've converted it to use the way suggested in comment:5. This also uncovered some other small issues with how lifting to the UEA is done in the `LieAlgebraFromAssociative`, which prompted the generic enough `lift` method in `LieAlgebrasWithBasis`. However, I did implement Cython `cpdef lift` versions because these might end up being used in my upcoming Verma module code. I also did some other tidying up I saw along the way.",
    "created_at": "2017-07-04T15:43:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322882",
    "user": "https://github.com/tscrim"
}
```

Okay, I've converted it to use the way suggested in comment:5. This also uncovered some other small issues with how lifting to the UEA is done in the `LieAlgebraFromAssociative`, which prompted the generic enough `lift` method in `LieAlgebrasWithBasis`. However, I did implement Cython `cpdef lift` versions because these might end up being used in my upcoming Verma module code. I also did some other tidying up I saw along the way.



---

archive/issue_comments_322883.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-07-04T15:43:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322883",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_322884.json:
```json
{
    "body": "Typo: `We are going to lift ``self`` the the UEA`",
    "created_at": "2017-07-05T12:59:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322884",
    "user": "https://github.com/jdemeyer"
}
```

Typo: `We are going to lift ``self`` the the UEA`



---

archive/issue_comments_322885.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-05T13:01:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322885",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_322886.json:
```json
{
    "body": "Fixed.",
    "created_at": "2017-07-05T13:01:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322886",
    "user": "https://github.com/tscrim"
}
```

Fixed.



---

archive/issue_comments_322887.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-07-05T13:05:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322887",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_322888.json:
```json
{
    "body": "1. Obvious mathematical question: is this multiplication always commutative? Because your code seems to assume that it is.\n\n2. I guess this can be dropped: `from operator import mul`\n\n3. Do you really need return `iter(D.iteritems())`? Is `D.iteritems()` not sufficient?\n\n4. This is considered bad style in PEP 8: `names_map = lambda x: x`. Write this as `def names_map(x): return x` (on 1 or 2 lines as you wish). Same for `get_var`.",
    "created_at": "2017-07-05T13:05:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322888",
    "user": "https://github.com/jdemeyer"
}
```

1. Obvious mathematical question: is this multiplication always commutative? Because your code seems to assume that it is.

2. I guess this can be dropped: `from operator import mul`

3. Do you really need return `iter(D.iteritems())`? Is `D.iteritems()` not sufficient?

4. This is considered bad style in PEP 8: `names_map = lambda x: x`. Write this as `def names_map(x): return x` (on 1 or 2 lines as you wish). Same for `get_var`.



---

archive/issue_comments_322889.json:
```json
{
    "body": "Replying to [comment:13 jdemeyer]:\n> 1. Obvious mathematical question: is this multiplication always commutative? Because your code seems to assume that it is.\n\n\nIt is not...ugg...right...I will have to think a little more about how to fix this with making a super call. Simply doing `IndexedFreeModuleElement.__mul__(left, right)` didn't work for me when `left` is, e.g., an `int`.\n\n> 2. I guess this can be dropped: `from operator import mul`\n\n\nTrue.\n\n> 3. Do you really need return `iter(D.iteritems())`? Is `D.iteritems()` not sufficient?\n\n\nNo, I do not need that. Fixed.\n\n> 4. This is considered bad style in PEP 8: `names_map = lambda x: x`. Write this as `def names_map(x): return x` (on 1 or 2 lines as you wish). Same for `get_var`.\n\n\nFixed.\n\nI will push my changes once I figure out the best way to handle 1.",
    "created_at": "2017-07-06T00:18:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322889",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:13 jdemeyer]:
> 1. Obvious mathematical question: is this multiplication always commutative? Because your code seems to assume that it is.


It is not...ugg...right...I will have to think a little more about how to fix this with making a super call. Simply doing `IndexedFreeModuleElement.__mul__(left, right)` didn't work for me when `left` is, e.g., an `int`.

> 2. I guess this can be dropped: `from operator import mul`


True.

> 3. Do you really need return `iter(D.iteritems())`? Is `D.iteritems()` not sufficient?


No, I do not need that. Fixed.

> 4. This is considered bad style in PEP 8: `names_map = lambda x: x`. Write this as `def names_map(x): return x` (on 1 or 2 lines as you wish). Same for `get_var`.


Fixed.

I will push my changes once I figure out the best way to handle 1.



---

archive/issue_comments_322890.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-06T01:52:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322890",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_322891.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-07-06T01:56:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322891",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_322892.json:
```json
{
    "body": "Okay, here is the new fix. I ended up copying most of the logic from `Element.__mul__`, but I need to make sure it attempts to go through the usual coercion framework first in order to test for things like the Lie algebra element acting on something else. However, I don't mind how the code turned out; it ended up being more straightforward than I was originally thinking.",
    "created_at": "2017-07-06T01:56:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322892",
    "user": "https://github.com/tscrim"
}
```

Okay, here is the new fix. I ended up copying most of the logic from `Element.__mul__`, but I need to make sure it attempts to go through the usual coercion framework first in order to test for things like the Lie algebra element acting on something else. However, I don't mind how the code turned out; it ended up being more straightforward than I was originally thinking.



---

archive/issue_comments_322893.json:
```json
{
    "body": "Replying to [comment:14 tscrim]:\n> It is not...ugg...right...I will have to think a little more about how to fix this with making a super call. Simply doing `IndexedFreeModuleElement.__mul__(left, right)` didn't work for me when `left` is, e.g., an `int`.\n\n\nDid you try calling the `__rmul__` method, like `IndexedFreeModuleElement.__rmul__(right, left)`?",
    "created_at": "2017-07-06T09:05:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322893",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:14 tscrim]:
> It is not...ugg...right...I will have to think a little more about how to fix this with making a super call. Simply doing `IndexedFreeModuleElement.__mul__(left, right)` didn't work for me when `left` is, e.g., an `int`.


Did you try calling the `__rmul__` method, like `IndexedFreeModuleElement.__rmul__(right, left)`?



---

archive/issue_comments_322894.json:
```json
{
    "body": "Replying to [comment:17 jdemeyer]:\n> Replying to [comment:14 tscrim]:\n> > It is not...ugg...right...I will have to think a little more about how to fix this with making a super call. Simply doing `IndexedFreeModuleElement.__mul__(left, right)` didn't work for me when `left` is, e.g., an `int`.\n\n> \n> Did you try calling the `__rmul__` method, like `IndexedFreeModuleElement.__rmul__(right, left)`?\n\n\nNo, I didn't. I believe we would have to do type checking first in order to do that. Super calls (including `Foo.__bar__(x, y)`) for special methods in Cython seem to be a little fragile.",
    "created_at": "2017-07-07T00:01:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322894",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:17 jdemeyer]:
> Replying to [comment:14 tscrim]:
> > It is not...ugg...right...I will have to think a little more about how to fix this with making a super call. Simply doing `IndexedFreeModuleElement.__mul__(left, right)` didn't work for me when `left` is, e.g., an `int`.

> 
> Did you try calling the `__rmul__` method, like `IndexedFreeModuleElement.__rmul__(right, left)`?


No, I didn't. I believe we would have to do type checking first in order to do that. Super calls (including `Foo.__bar__(x, y)`) for special methods in Cython seem to be a little fragile.



---

archive/issue_comments_322895.json:
```json
{
    "body": "It seems to me like copying a large part of the element `__mul__` just to avoid one or two `super()` calls is a bit overkill.\n\nI have no idea why you think that `super()` wouldn't work with slot wrappers (I guess that's technically what you mean with \"special methods in Cython\"). I think that `super()` simply works on the level of attributes. I don't see why it would matter if the attribute is a Python method or a slot wrapper.",
    "created_at": "2017-07-07T08:43:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322895",
    "user": "https://github.com/jdemeyer"
}
```

It seems to me like copying a large part of the element `__mul__` just to avoid one or two `super()` calls is a bit overkill.

I have no idea why you think that `super()` wouldn't work with slot wrappers (I guess that's technically what you mean with "special methods in Cython"). I think that `super()` simply works on the level of attributes. I don't see why it would matter if the attribute is a Python method or a slot wrapper.



---

archive/issue_comments_322896.json:
```json
{
    "body": "I'm not doing it because I want to (although we do get a faster hook when both are elements of the same Lie algebra and directly treating the `int` as a scalar). If I do something like\n\n```\nreturn Element.__mul__(left, right)\n```\nto handle the base ring input, then I get\n\n```\nsage: x = L.an_element()\nsage: int(3) * x\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n...\nTypeError: descriptor '__mul__' requires a 'sage.structure.element.Element' object but received a 'int'\n```\nI agree that it does work properly when you can promise that `left` is a subclass of `Element`.\n\nNow, I can catch that error and then proceed in the reversed order, but that creates some messy code. Well, at least I don't see a clean way to do it to separate out the `TypeError` from the bad object type vs the one from not being able to actually do the multiplication. Even still, it would mean doing some logic to keep track of which one is what type.",
    "created_at": "2017-07-07T13:52:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322896",
    "user": "https://github.com/tscrim"
}
```

I'm not doing it because I want to (although we do get a faster hook when both are elements of the same Lie algebra and directly treating the `int` as a scalar). If I do something like

```
return Element.__mul__(left, right)
```
to handle the base ring input, then I get

```
sage: x = L.an_element()
sage: int(3) * x
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: descriptor '__mul__' requires a 'sage.structure.element.Element' object but received a 'int'
```
I agree that it does work properly when you can promise that `left` is a subclass of `Element`.

Now, I can catch that error and then proceed in the reversed order, but that creates some messy code. Well, at least I don't see a clean way to do it to separate out the `TypeError` from the bad object type vs the one from not being able to actually do the multiplication. Even still, it would mean doing some logic to keep track of which one is what type.



---

archive/issue_comments_322897.json:
```json
{
    "body": "Replying to [comment:20 tscrim]:\n> Now, I can catch that error and then proceed in the reversed order, but that creates some messy code.\n\n\nIn this case, LBYL is better than EAFP. You are doing `isinstance()` checks anyway, so you really already know whether to use `__mul__` or `__rmul__`.\n\nFor example, the old code\n\n```\n        if isinstance(left, LieAlgebraElement):\n            self = <LieAlgebraElement> left\n            y = right\n        else:\n            self = <LieAlgebraElement> right\n            y = left\n        try:\n            return super(LieAlgebraElement, self).__mul__(y)\n        except TypeError:\n            pass\n```\ncould be rewritten as\n\n```\n        try:\n            if isinstance(left, LieAlgebraElement):\n                return super(LieAlgebraElement, left).__mul__(right)\n            else:\n                return super(LieAlgebraElement, right).__rmul__(left)\n        except TypeError:\n            pass\n```",
    "created_at": "2017-07-07T14:01:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322897",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:20 tscrim]:
> Now, I can catch that error and then proceed in the reversed order, but that creates some messy code.


In this case, LBYL is better than EAFP. You are doing `isinstance()` checks anyway, so you really already know whether to use `__mul__` or `__rmul__`.

For example, the old code

```
        if isinstance(left, LieAlgebraElement):
            self = <LieAlgebraElement> left
            y = right
        else:
            self = <LieAlgebraElement> right
            y = left
        try:
            return super(LieAlgebraElement, self).__mul__(y)
        except TypeError:
            pass
```
could be rewritten as

```
        try:
            if isinstance(left, LieAlgebraElement):
                return super(LieAlgebraElement, left).__mul__(right)
            else:
                return super(LieAlgebraElement, right).__rmul__(left)
        except TypeError:
            pass
```



---

archive/issue_comments_322898.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-07T14:12:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322898",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_322899.json:
```json
{
    "body": "With the current implementation, I only need to do that when one of them is not an element and can assume it is a scalar. (Although I noticed some bad copy/pasting: `left = (<LieAlgebraElement> right).lift()` :P). Moreover, it saves a few `isinstance` checks; granted, this is far from the bottleneck point in practical code. I also think the logic is easier to follow this way, but yes, there is a technical debt from doing a bit of near duplication.\n\nReally, I think Cython should let `Element.__mul__(left, right)` work since it makes no assumptions on the type of `Foo.__mul__(left, right)`. I would almost consider this to be a bug in Cython because of that.",
    "created_at": "2017-07-07T14:19:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322899",
    "user": "https://github.com/tscrim"
}
```

With the current implementation, I only need to do that when one of them is not an element and can assume it is a scalar. (Although I noticed some bad copy/pasting: `left = (<LieAlgebraElement> right).lift()` :P). Moreover, it saves a few `isinstance` checks; granted, this is far from the bottleneck point in practical code. I also think the logic is easier to follow this way, but yes, there is a technical debt from doing a bit of near duplication.

Really, I think Cython should let `Element.__mul__(left, right)` work since it makes no assumptions on the type of `Foo.__mul__(left, right)`. I would almost consider this to be a bug in Cython because of that.



---

archive/issue_comments_322900.json:
```json
{
    "body": "Replying to [comment:23 tscrim]:\n> Really, I think Cython should let `Element.__mul__(left, right)` work\n\n\nIt's not a Cython issue but a Python issue. I understand the confusion because\n\n```\ncdef class Element:\n    def __mul__(left, right):\n        ...\n```\nlooks like it is providing `Element.__mul__` but that isn't actually the case. In Cython, the syntax `def __mul__(left, right)` is used to define the `nb_multiply` function in the `PyTypeObject` structure. Python (not Cython) then adds `__mul__` and `__rmul__` attributes which call the `nb_multiply` function implementated by Cython.\n\nMaybe it's easier to understand with `__richcmp__` on the one hand and `__eq__`, `__lt__`, ... on the other hand. `__richcmp__` is just Cython syntax, there is no actual method called `__richcmp__`. But Python does generate `__eq__`, ... methods from this.\n\nThinking about it, you *could* actually call `nb_multiply` directly from Cython. But that would not qualify as a clean solution.",
    "created_at": "2017-07-07T14:55:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322900",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:23 tscrim]:
> Really, I think Cython should let `Element.__mul__(left, right)` work


It's not a Cython issue but a Python issue. I understand the confusion because

```
cdef class Element:
    def __mul__(left, right):
        ...
```
looks like it is providing `Element.__mul__` but that isn't actually the case. In Cython, the syntax `def __mul__(left, right)` is used to define the `nb_multiply` function in the `PyTypeObject` structure. Python (not Cython) then adds `__mul__` and `__rmul__` attributes which call the `nb_multiply` function implementated by Cython.

Maybe it's easier to understand with `__richcmp__` on the one hand and `__eq__`, `__lt__`, ... on the other hand. `__richcmp__` is just Cython syntax, there is no actual method called `__richcmp__`. But Python does generate `__eq__`, ... methods from this.

Thinking about it, you *could* actually call `nb_multiply` directly from Cython. But that would not qualify as a clean solution.



---

archive/issue_comments_322901.json:
```json
{
    "body": "Thinking more about it: I think I know how to make the call `Element.__mul__(left, right)` work. I could write a function `wrapperdescr_call_nocheck()` which overrides some checks that Python does. Then `Element.__mul__(left, right)` would become\n\n```\nwrapperdescr_call_nocheck(Element.__mul__, left, right)\n```\nwhich would skip the check of the `self` argument.\n\nWould that make you happy or do you think it's a bad idea?",
    "created_at": "2017-07-07T15:08:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322901",
    "user": "https://github.com/jdemeyer"
}
```

Thinking more about it: I think I know how to make the call `Element.__mul__(left, right)` work. I could write a function `wrapperdescr_call_nocheck()` which overrides some checks that Python does. Then `Element.__mul__(left, right)` would become

```
wrapperdescr_call_nocheck(Element.__mul__, left, right)
```
which would skip the check of the `self` argument.

Would that make you happy or do you think it's a bad idea?



---

archive/issue_comments_322902.json:
```json
{
    "body": "Just to be certain, the error is coming from Python with the wrapper `Element.__mul__(left, right)`, but when `def __mul__(left, right):` in `Foo` is called, it is actually just calling the underlying `nb_multiply`. So by instead calling `nb_multiply`, it would avoid the Python checks and start the `Element.__mul__` code. Is that correct?\n\nAm also I correct in that `wrapperdescr_call_nocheck()` is just a more general-purpose function instead of calling `nb_multiply` (or other similar functions) directly in the Cython code? Since this is likely a more special case, I would say for now we can just call directly `nb_multiply` with some comments about it is done to avoid Python type checks. However, I would be happy with such a function if you think it is better to not call `nb_multiply`. If you're okay with directly calling `nb_multiply`, what is the syntax I should use and what do I need to do to import it?",
    "created_at": "2017-07-07T15:37:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322902",
    "user": "https://github.com/tscrim"
}
```

Just to be certain, the error is coming from Python with the wrapper `Element.__mul__(left, right)`, but when `def __mul__(left, right):` in `Foo` is called, it is actually just calling the underlying `nb_multiply`. So by instead calling `nb_multiply`, it would avoid the Python checks and start the `Element.__mul__` code. Is that correct?

Am also I correct in that `wrapperdescr_call_nocheck()` is just a more general-purpose function instead of calling `nb_multiply` (or other similar functions) directly in the Cython code? Since this is likely a more special case, I would say for now we can just call directly `nb_multiply` with some comments about it is done to avoid Python type checks. However, I would be happy with such a function if you think it is better to not call `nb_multiply`. If you're okay with directly calling `nb_multiply`, what is the syntax I should use and what do I need to do to import it?



---

archive/issue_comments_322903.json:
```json
{
    "body": "Replying to [comment:26 tscrim]:\n> Just to be certain, the error is coming from Python with the wrapper `Element.__mul__(left, right)`, but when `def __mul__(left, right):` in `Foo` is called, it is actually just calling the underlying `nb_multiply`.\n\n\nI don't really understand your question. But let me try to clarify anyway. Consider\n\n```\ncdef class Foo:\n    def __mul__(left, right):\n        pass\n```\nNow, this `def __mul__` is not a Python method or function or anything like that. It's really a C function to put in the `nb_multiply` slot. Cython chose the syntax `def __mul__` because it would be familiar to Python programmers, but the similar syntax hides the difference in what it really is.\n\nNow, when a type(*) is initialized by Python, ordinary Python attributes `__mul__` and `__rmul__` are generated from the slots like `nb_multiply`. These attributes are of type \"slot wrapper\" and you can see them in the `__dict__`:\n\n```\nsage: Integer.__mul__\n<slot wrapper '__mul__' of 'sage.rings.integer.Integer' objects>\nsage: Integer.__rmul__\n<slot wrapper '__rmul__' of 'sage.rings.integer.Integer' objects>\nsage: Integer.__dict__\ndict_proxy({'__abs__': <slot wrapper '__abs__' of 'sage.rings.integer.Integer' objects>,\n            '__add__': <slot wrapper '__add__' of 'sage.rings.integer.Integer' objects>,\n            '__and__': <slot wrapper '__and__' of 'sage.rings.integer.Integer' objects>,\n            '__array_interface__': <attribute '__array_interface__' of 'sage.rings.integer.Integer' objects>,\n            '__copy__': <method '__copy__' of 'sage.rings.integer.Integer' objects>,\n            '__div__': <slot wrapper '__div__' of 'sage.rings.integer.Integer' objects>,\n            .......\n```\nThese behave mostly like ordinary methods. They are implemented by Python and call the underlying slot function, which is `nb_multiply` for both `__mul__` and `__rmul__`.\n\nIn other words, the Python code `cls.__mul__(left, right)` roughly translates to `cls->nb_multiply(left, right)` in C, *with extra checking* added (like ordinary methods, the first argument `self` should be a suitable type). Now what I propose is to have a special function\n\n```\ndef wrapperdescr_call_nocheck(slotwrapper, *args)\n```\nwhich would call the underlying slot function but *without checks*.\n\nI haven't actually tried if it would work, but it should. And I can imagine it being useful for other purposes too. This might turn out to be one of these things where, if you know that it exists, you start seeing lots of use cases.\n\nYou might think that the problem could also be solved by implementing a custom `__mul__` method-like attribute on the type(*), which would be like the standard `__mul__` slot wrapper, except that it would not check that the first argument is of the right type. That sounds good, but breaks when subtyping(*): Python insists on \"restoring\" the slot wrapper in the subtype(*). I know because this broke an earlier attempt of #23102.\n\n(*) \"type\" and \"class\" mean the same thing in Python. However, there is a tendency to use \"type\" when talking about Python internals but \"class\" when talking about user code. The only exception are old-style classes, which are not types: indeed, `type(obj)` is not the same as `obj.__class__` for instances of old-style classes.",
    "created_at": "2017-07-07T20:49:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322903",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:26 tscrim]:
> Just to be certain, the error is coming from Python with the wrapper `Element.__mul__(left, right)`, but when `def __mul__(left, right):` in `Foo` is called, it is actually just calling the underlying `nb_multiply`.


I don't really understand your question. But let me try to clarify anyway. Consider

```
cdef class Foo:
    def __mul__(left, right):
        pass
```
Now, this `def __mul__` is not a Python method or function or anything like that. It's really a C function to put in the `nb_multiply` slot. Cython chose the syntax `def __mul__` because it would be familiar to Python programmers, but the similar syntax hides the difference in what it really is.

Now, when a type(*) is initialized by Python, ordinary Python attributes `__mul__` and `__rmul__` are generated from the slots like `nb_multiply`. These attributes are of type "slot wrapper" and you can see them in the `__dict__`:

```
sage: Integer.__mul__
<slot wrapper '__mul__' of 'sage.rings.integer.Integer' objects>
sage: Integer.__rmul__
<slot wrapper '__rmul__' of 'sage.rings.integer.Integer' objects>
sage: Integer.__dict__
dict_proxy({'__abs__': <slot wrapper '__abs__' of 'sage.rings.integer.Integer' objects>,
            '__add__': <slot wrapper '__add__' of 'sage.rings.integer.Integer' objects>,
            '__and__': <slot wrapper '__and__' of 'sage.rings.integer.Integer' objects>,
            '__array_interface__': <attribute '__array_interface__' of 'sage.rings.integer.Integer' objects>,
            '__copy__': <method '__copy__' of 'sage.rings.integer.Integer' objects>,
            '__div__': <slot wrapper '__div__' of 'sage.rings.integer.Integer' objects>,
            .......
```
These behave mostly like ordinary methods. They are implemented by Python and call the underlying slot function, which is `nb_multiply` for both `__mul__` and `__rmul__`.

In other words, the Python code `cls.__mul__(left, right)` roughly translates to `cls->nb_multiply(left, right)` in C, *with extra checking* added (like ordinary methods, the first argument `self` should be a suitable type). Now what I propose is to have a special function

```
def wrapperdescr_call_nocheck(slotwrapper, *args)
```
which would call the underlying slot function but *without checks*.

I haven't actually tried if it would work, but it should. And I can imagine it being useful for other purposes too. This might turn out to be one of these things where, if you know that it exists, you start seeing lots of use cases.

You might think that the problem could also be solved by implementing a custom `__mul__` method-like attribute on the type(*), which would be like the standard `__mul__` slot wrapper, except that it would not check that the first argument is of the right type. That sounds good, but breaks when subtyping(*): Python insists on "restoring" the slot wrapper in the subtype(*). I know because this broke an earlier attempt of #23102.

(*) "type" and "class" mean the same thing in Python. However, there is a tendency to use "type" when talking about Python internals but "class" when talking about user code. The only exception are old-style classes, which are not types: indeed, `type(obj)` is not the same as `obj.__class__` for instances of old-style classes.



---

archive/issue_comments_322904.json:
```json
{
    "body": "Side comment: most special methods (like `__init__`, `__getattribute__`, `__hash__`, `__repr__`, `__iter__`, ...) are implemented this way. Usually, there is a close correspondence between the Python attribute and the C function: the first argument really is `self` and 1 slot function only has 1 attribute. The main exceptions to these are:\n\n1. `__new__` which is special in many \"interesting\" ways\n\n2. Rich comparison like `__eq__` because one C function corresponds to six Python methods. The first argument is still `self` though.\n\n3. Arithmetic like `__mul__` because the first argument may not be `self`.\n\nInterestingly, Cython already special cases calls to `__new__` (`cls.__new__(cls)` does not mean the same thing in Python and Cython) and I recently dealt with various tickets to improve Python support for rich comparisons. So, to finish the list, maybe there should be a ticket to close the gap between the Python and C implementations of arithmetic too.",
    "created_at": "2017-07-07T21:15:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322904",
    "user": "https://github.com/jdemeyer"
}
```

Side comment: most special methods (like `__init__`, `__getattribute__`, `__hash__`, `__repr__`, `__iter__`, ...) are implemented this way. Usually, there is a close correspondence between the Python attribute and the C function: the first argument really is `self` and 1 slot function only has 1 attribute. The main exceptions to these are:

1. `__new__` which is special in many "interesting" ways

2. Rich comparison like `__eq__` because one C function corresponds to six Python methods. The first argument is still `self` though.

3. Arithmetic like `__mul__` because the first argument may not be `self`.

Interestingly, Cython already special cases calls to `__new__` (`cls.__new__(cls)` does not mean the same thing in Python and Cython) and I recently dealt with various tickets to improve Python support for rich comparisons. So, to finish the list, maybe there should be a ticket to close the gap between the Python and C implementations of arithmetic too.



---

archive/issue_comments_322905.json:
```json
{
    "body": "Thank you for the explanation; that is very useful. So my question right now is should we simply use `nb_multiply` as the super call? Although there definitely should be other use-cases for a `wrapperdescr_call_nocheck`, and from looking at #23102, I agree that it should be possible to write such a function. I'm wondering what you think the best approach is?",
    "created_at": "2017-07-09T06:29:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322905",
    "user": "https://github.com/tscrim"
}
```

Thank you for the explanation; that is very useful. So my question right now is should we simply use `nb_multiply` as the super call? Although there definitely should be other use-cases for a `wrapperdescr_call_nocheck`, and from looking at #23102, I agree that it should be possible to write such a function. I'm wondering what you think the best approach is?



---

archive/issue_comments_322906.json:
```json
{
    "body": "Replying to [comment:29 tscrim]:\n> Thank you for the explanation; that is very useful. So my question right now is should we simply use `nb_multiply` as the super call? Although there definitely should be other use-cases for a `wrapperdescr_call_nocheck`, and from looking at #23102, I agree that it should be possible to write such a function. I'm wondering what you think the best approach is?\n\n\nI would prefer `wrapperdescr_call_nocheck` because it's a general solution. The `nb_multiply` thing would be very specific and it would probably also require some trivial changes to Cython upstream.",
    "created_at": "2017-07-10T08:13:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322906",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:29 tscrim]:
> Thank you for the explanation; that is very useful. So my question right now is should we simply use `nb_multiply` as the super call? Although there definitely should be other use-cases for a `wrapperdescr_call_nocheck`, and from looking at #23102, I agree that it should be possible to write such a function. I'm wondering what you think the best approach is?


I would prefer `wrapperdescr_call_nocheck` because it's a general solution. The `nb_multiply` thing would be very specific and it would probably also require some trivial changes to Cython upstream.



---

archive/issue_comments_322907.json:
```json
{
    "body": "Replying to [comment:30 jdemeyer]:\n> Replying to [comment:29 tscrim]:\n> > Thank you for the explanation; that is very useful. So my question right now is should we simply use `nb_multiply` as the super call? Although there definitely should be other use-cases for a `wrapperdescr_call_nocheck`, and from looking at #23102, I agree that it should be possible to write such a function. I'm wondering what you think the best approach is?\n\n> \n> I would prefer `wrapperdescr_call_nocheck` because it's a general solution. The `nb_multiply` thing would be very specific and it would probably also require some trivial changes to Cython upstream.\n\n\nIf you write such a function, I will make the appropriate changes in here to use it.",
    "created_at": "2017-07-10T15:40:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322907",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:30 jdemeyer]:
> Replying to [comment:29 tscrim]:
> > Thank you for the explanation; that is very useful. So my question right now is should we simply use `nb_multiply` as the super call? Although there definitely should be other use-cases for a `wrapperdescr_call_nocheck`, and from looking at #23102, I agree that it should be possible to write such a function. I'm wondering what you think the best approach is?

> 
> I would prefer `wrapperdescr_call_nocheck` because it's a general solution. The `nb_multiply` thing would be very specific and it would probably also require some trivial changes to Cython upstream.


If you write such a function, I will make the appropriate changes in here to use it.



---

archive/issue_comments_322908.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-07-12T12:15:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322908",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_322909.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-12T14:19:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322909",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_322910.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-07-12T14:29:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322910",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_322911.json:
```json
{
    "body": "Rebased. Thank you for adding the function. Although this does result in a slowdown in some of the operations:\n\n```\nsage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z':1}})\nsage: %timeit int(3) * x\n100000 loops, best of 3: 4.09 \u00b5s per loop\nsage: %timeit x * int(3)\n100000 loops, best of 3: 4.14 \u00b5s per loop\nsage: %timeit x * y\n10000 loops, best of 3: 86.1 \u00b5s per loop\nsage: %timeit 3 * x\n100000 loops, best of 3: 4.15 \u00b5s per loop\nsage: %timeit x * 3\n100000 loops, best of 3: 4.11 \u00b5s per loop\nsage: %timeit (3/2) * x\n100000 loops, best of 3: 3.1 \u00b5s per loop\nsage: %timeit x * (3/2)\n100000 loops, best of 3: 3.02 \u00b5s per loop\nsage: %timeit for _ in range(1000): 3 * x\n100 loops, best of 3: 4.01 ms per loop\nsage: %timeit for _ in range(1000): x * 3\n100 loops, best of 3: 3.99 ms per loop\n```\nversus the previous commit:\n\n```\nLsage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z':1}})\nsage: %timeit int(3) * x\n100000 loops, best of 3: 3.07 \u00b5s per loop\nsage: %timeit x * int(3)\n100000 loops, best of 3: 2.85 \u00b5s per loop\nsage: %timeit x * y\n100000 loops, best of 3: 7.32 \u00b5s per loop\nsage: %timeit 3 * x\n100000 loops, best of 3: 3.87 \u00b5s per loop\nsage: %timeit x * 3\n100000 loops, best of 3: 3.67 \u00b5s per loop\nsage: %timeit (3/2) * x\n100000 loops, best of 3: 2.93 \u00b5s per loop\nsage: %timeit x * (3/2)\n100000 loops, best of 3: 2.81 \u00b5s per loop\nsage: %timeit for _ in range(1000): 3 * x\n100 loops, best of 3: 3.88 ms per loop\nsage: %timeit for _ in range(1000): x * 3\n100 loops, best of 3: 3.74 ms per loop\n```\nThe multiplication of elements in the Lie algebra should be a rare event and is mainly used as a convenience (the better way is to do the lift within the code itself). I also would say multiplying by an `int` should not really be done either.\n\nTL;DR - I can live with the 5-10% regression for the typical multiplication cases in order to have cleaner code.",
    "created_at": "2017-07-12T14:29:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322911",
    "user": "https://github.com/tscrim"
}
```

Rebased. Thank you for adding the function. Although this does result in a slowdown in some of the operations:

```
sage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z':1}})
sage: %timeit int(3) * x
100000 loops, best of 3: 4.09 s per loop
sage: %timeit x * int(3)
100000 loops, best of 3: 4.14 s per loop
sage: %timeit x * y
10000 loops, best of 3: 86.1 s per loop
sage: %timeit 3 * x
100000 loops, best of 3: 4.15 s per loop
sage: %timeit x * 3
100000 loops, best of 3: 4.11 s per loop
sage: %timeit (3/2) * x
100000 loops, best of 3: 3.1 s per loop
sage: %timeit x * (3/2)
100000 loops, best of 3: 3.02 s per loop
sage: %timeit for _ in range(1000): 3 * x
100 loops, best of 3: 4.01 ms per loop
sage: %timeit for _ in range(1000): x * 3
100 loops, best of 3: 3.99 ms per loop
```
versus the previous commit:

```
Lsage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z':1}})
sage: %timeit int(3) * x
100000 loops, best of 3: 3.07 s per loop
sage: %timeit x * int(3)
100000 loops, best of 3: 2.85 s per loop
sage: %timeit x * y
100000 loops, best of 3: 7.32 s per loop
sage: %timeit 3 * x
100000 loops, best of 3: 3.87 s per loop
sage: %timeit x * 3
100000 loops, best of 3: 3.67 s per loop
sage: %timeit (3/2) * x
100000 loops, best of 3: 2.93 s per loop
sage: %timeit x * (3/2)
100000 loops, best of 3: 2.81 s per loop
sage: %timeit for _ in range(1000): 3 * x
100 loops, best of 3: 3.88 ms per loop
sage: %timeit for _ in range(1000): x * 3
100 loops, best of 3: 3.74 ms per loop
```
The multiplication of elements in the Lie algebra should be a rare event and is mainly used as a convenience (the better way is to do the lift within the code itself). I also would say multiplying by an `int` should not really be done either.

TL;DR - I can live with the 5-10% regression for the typical multiplication cases in order to have cleaner code.



---

archive/issue_comments_322912.json:
```json
{
    "body": "I can think of 2 reasons for the slowdown:\n\n1. The method access `IndexedFreeModuleElement.__mul__` takes some time. You could do this at the top-level like\n\n```\ncdef object IndexedFreeModuleElement__mul__ = IndexedFreeModuleElement.__mul__\n```\n\n2. You are constructing `{}` for every call of `wrapperdescr_fastcall`. Since this `kwds` argument is not actually used, you could pass `None` instead.",
    "created_at": "2017-07-12T14:38:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322912",
    "user": "https://github.com/jdemeyer"
}
```

I can think of 2 reasons for the slowdown:

1. The method access `IndexedFreeModuleElement.__mul__` takes some time. You could do this at the top-level like

```
cdef object IndexedFreeModuleElement__mul__ = IndexedFreeModuleElement.__mul__
```

2. You are constructing `{}` for every call of `wrapperdescr_fastcall`. Since this `kwds` argument is not actually used, you could pass `None` instead.



---

archive/issue_comments_322913.json:
```json
{
    "body": "Instead of passing `None` as `kwds`, even faster would be passing `<object>NULL`.",
    "created_at": "2017-07-12T14:46:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322913",
    "user": "https://github.com/jdemeyer"
}
```

Instead of passing `None` as `kwds`, even faster would be passing `<object>NULL`.



---

archive/issue_comments_322914.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-12T14:47:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322914",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_322915.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-07-12T14:49:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322915",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_322916.json:
```json
{
    "body": "That does put me back in the same timing realm as before, thank you.",
    "created_at": "2017-07-12T14:50:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322916",
    "user": "https://github.com/tscrim"
}
```

That does put me back in the same timing realm as before, thank you.



---

archive/issue_comments_322917.json:
```json
{
    "body": "Ping. I also checked that this does not conflict with #23440.",
    "created_at": "2017-07-26T02:57:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322917",
    "user": "https://github.com/tscrim"
}
```

Ping. I also checked that this does not conflict with #23440.



---

archive/issue_comments_322918.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-31T03:09:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322918",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_322919.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-08-10T22:40:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322919",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_322920.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-08-20T13:45:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322920",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_322921.json:
```json
{
    "body": "ok, I am setting this to positive",
    "created_at": "2017-08-20T13:45:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322921",
    "user": "https://github.com/fchapoton"
}
```

ok, I am setting this to positive



---

archive/issue_events_060092.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-08-26T09:58:04Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/23109#event-60092"
}
```



---

archive/issue_comments_322922.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-08-26T09:58:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/23109",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/23109#issuecomment-322922",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
