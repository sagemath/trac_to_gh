# Issue 23109: Doing some maintanence on LieAlgebraElement

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2017-07-01 00:11:40

CC:  sage-combinat bsalisbury1

We can now `cdef` the class `LieAlgebraElement` since #22632 is merged. This also does some other fixes to `__mul__` to better handle `int` input and to `lift` to handle when the UEA has a different indexing set or is the PBW basis.


---

Comment by tscrim created at 2017-07-01 00:12:35

New commits:


---

Comment by tscrim created at 2017-07-01 00:12:35

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-07-04 12:58:48

Just commenting on the Cython code in `lie_algebra_element.pyx`:

1. You are cimporting various things that you don't actually use. I assume that this was for some earlier failed experiment?

2. Is there any reason that `self` should have a `lift()` method? Remember that arithmetic in Cython is different from Python: you cannot assume that `self` is an instance of the class. For that reason, I would also avoid the name `self`: the signature would better be written as `def __mul__(left, right)`.

3. Why did you change `self.lift() * y` to `coercion_model.bin_op(self.lift(), y, mul)`? There is normally no reason to explicitly invoke the coercion model like this.


---

Comment by jdemeyer created at 2017-07-04 12:58:48

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2017-07-04 13:51:24

Replying to [comment:2 jdemeyer]:
> Just commenting on the Cython code in `lie_algebra_element.pyx`:
> 
> 1. You are cimporting various things that you don't actually use. I assume that this was for some earlier failed experiment?

Yes, that's right. Those should be removed.

> 2. Is there any reason that `self` should have a `lift()` method? Remember that arithmetic in Cython is different from Python: you cannot assume that `self` is an instance of the class. For that reason, I would also avoid the name `self`: the signature would better be written as `def __mul__(left, right)`.
>
> 3. Why did you change `self.lift() * y` to `coercion_model.bin_op(self.lift(), y, mul)`? There is normally no reason to explicitly invoke the coercion model like this.

What I am trying to do is implement `x * y` such that if `x` is a Lie algebra element and `y` is not in is base ring (or with the role of `x` and `y` swapped), then it lifts `x` up to a bigger algebra (the universal enveloping algebra) where `*` is defined (associatively). So really this should be a coercion map where it converts `x` and `y` to a common parent as there is not an action of `y` on `x` (or vice versa).

However, I don't know how to do this in the current system as the bigger algebra may not have been constructed yet (but is available through `L.universal_enveloping_algebra`). I would be happy enough if `x` and `y` were both elements of `L` (i.e., using `_mul_`) and then call `lift()` on both elements and multiply, but the coercion framework needs the result to be in `L`. So what I am trying to do is essentially emulate the coercion framework to get around this.

Doing things this way is what got it to do what I wanted it to do without breaking anything. However, I am sure there is a better way to do this. Suggestions welcomed.

Maybe an analogy in a less specialized area of math would be when you do `x + y` with two (multiplicative) group elements, then it would automatically coerce into the corresponding group algebras. (I'm not saying this is a feature we want, but merely would be the same concept).


---

Comment by jdemeyer created at 2017-07-04 14:04:13

Replying to [comment:3 tscrim]:
> Maybe an analogy in a less specialized area of math would be when you do `x + y` with two (multiplicative) group elements

Continuing your analogy, it seems that your input is really one group element and one other object which could be anything. Since it really could be anything, you shouldn't force the Sage coercion model on it.

What's wrong with something like

```
def __mul__(left, right):
    # ...
    # handle base ring stuff first
    # ...
    if isinstance(left, LieAlgebraElement):
        left = left.lift()   # Or (<LieAlgebraElement>left).lift() if lift is cpdef
    if isinstance(right, LieAlgebraElement):
        right = right.lift()
    return left * right
```



---

Comment by tscrim created at 2017-07-04 14:20:34

Replying to [comment:4 jdemeyer]:
> Replying to [comment:3 tscrim]:
> > Maybe an analogy in a less specialized area of math would be when you do `x + y` with two (multiplicative) group elements
> 
> Continuing your analogy, it seems that your input is really one group element and one other object which could be anything. Since it really could be anything, you shouldn't force the Sage coercion model on it.

True, well, I want to assume that the other one is something coercible into a group element. So I need to invoke the coercion model at some point. Although I guess I can let the coercion model do its thing via `+` once I lift up the group element.

> What's wrong with something like
> {{{
> def __mul__(left, right):
>     # ...
>     # handle base ring stuff first
>     # ...
>     if isinstance(left, LieAlgebraElement):
>         left = left.lift()   # Or (<LieAlgebraElement>left).lift() if lift is cpdef
>     if isinstance(right, LieAlgebraElement):
>         right = right.lift()
>     return left * right
> }}}

I think that should work. At least I don't see anything wrong with that at this point. I will test.


---

Comment by jdemeyer created at 2017-07-04 14:35:14

Replying to [comment:5 tscrim]:
> Although I guess I can let the coercion model do its thing via `+` once I lift up the group element.

Yes, that is what I meant. There is usually no reason to call the coercion model directly.


---

Comment by git created at 2017-07-04 15:39:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-07-04 15:43:10

Okay, I've converted it to use the way suggested in comment:5. This also uncovered some other small issues with how lifting to the UEA is done in the `LieAlgebraFromAssociative`, which prompted the generic enough `lift` method in `LieAlgebrasWithBasis`. However, I did implement Cython `cpdef lift` versions because these might end up being used in my upcoming Verma module code. I also did some other tidying up I saw along the way.


---

Comment by tscrim created at 2017-07-04 15:43:37

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-07-05 12:59:12

Typo: `We are going to lift ``self`` the the UEA`


---

Comment by git created at 2017-07-05 13:01:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-07-05 13:01:45

Fixed.


---

Comment by jdemeyer created at 2017-07-05 13:05:34

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-07-05 13:05:34

1. Obvious mathematical question: is this multiplication always commutative? Because your code seems to assume that it is.

2. I guess this can be dropped: `from operator import mul`

3. Do you really need return `iter(D.iteritems())`? Is `D.iteritems()` not sufficient?

4. This is considered bad style in PEP 8: `names_map = lambda x: x`. Write this as `def names_map(x): return x` (on 1 or 2 lines as you wish). Same for `get_var`.


---

Comment by tscrim created at 2017-07-06 00:18:27

Replying to [comment:13 jdemeyer]:
> 1. Obvious mathematical question: is this multiplication always commutative? Because your code seems to assume that it is.

It is not...ugg...right...I will have to think a little more about how to fix this with making a super call. Simply doing `IndexedFreeModuleElement.__mul__(left, right)` didn't work for me when `left` is, e.g., an `int`.

> 2. I guess this can be dropped: `from operator import mul`

True.

> 3. Do you really need return `iter(D.iteritems())`? Is `D.iteritems()` not sufficient?

No, I do not need that. Fixed.

> 4. This is considered bad style in PEP 8: `names_map = lambda x: x`. Write this as `def names_map(x): return x` (on 1 or 2 lines as you wish). Same for `get_var`.

Fixed.

I will push my changes once I figure out the best way to handle 1.


---

Comment by git created at 2017-07-06 01:52:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-07-06 01:56:41

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2017-07-06 01:56:41

Okay, here is the new fix. I ended up copying most of the logic from `Element.__mul__`, but I need to make sure it attempts to go through the usual coercion framework first in order to test for things like the Lie algebra element acting on something else. However, I don't mind how the code turned out; it ended up being more straightforward than I was originally thinking.


---

Comment by jdemeyer created at 2017-07-06 09:05:44

Replying to [comment:14 tscrim]:
> It is not...ugg...right...I will have to think a little more about how to fix this with making a super call. Simply doing `IndexedFreeModuleElement.__mul__(left, right)` didn't work for me when `left` is, e.g., an `int`.

Did you try calling the `__rmul__` method, like `IndexedFreeModuleElement.__rmul__(right, left)`?


---

Comment by tscrim created at 2017-07-07 00:01:43

Replying to [comment:17 jdemeyer]:
> Replying to [comment:14 tscrim]:
> > It is not...ugg...right...I will have to think a little more about how to fix this with making a super call. Simply doing `IndexedFreeModuleElement.__mul__(left, right)` didn't work for me when `left` is, e.g., an `int`.
> 
> Did you try calling the `__rmul__` method, like `IndexedFreeModuleElement.__rmul__(right, left)`?

No, I didn't. I believe we would have to do type checking first in order to do that. Super calls (including `Foo.__bar__(x, y)`) for special methods in Cython seem to be a little fragile.


---

Comment by jdemeyer created at 2017-07-07 08:43:03

It seems to me like copying a large part of the element `__mul__` just to avoid one or two `super()` calls is a bit overkill.

I have no idea why you think that `super()` wouldn't work with slot wrappers (I guess that's technically what you mean with "special methods in Cython"). I think that `super()` simply works on the level of attributes. I don't see why it would matter if the attribute is a Python method or a slot wrapper.


---

Comment by tscrim created at 2017-07-07 13:52:25

I'm not doing it because I want to (although we do get a faster hook when both are elements of the same Lie algebra and directly treating the `int` as a scalar). If I do something like

```
return Element.__mul__(left, right)
```

to handle the base ring input, then I get

```
sage: x = L.an_element()
sage: int(3) * x
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: descriptor '__mul__' requires a 'sage.structure.element.Element' object but received a 'int'
```

I agree that it does work properly when you can promise that `left` is a subclass of `Element`.

Now, I can catch that error and then proceed in the reversed order, but that creates some messy code. Well, at least I don't see a clean way to do it to separate out the `TypeError` from the bad object type vs the one from not being able to actually do the multiplication. Even still, it would mean doing some logic to keep track of which one is what type.


---

Comment by jdemeyer created at 2017-07-07 14:01:31

Replying to [comment:20 tscrim]:
> Now, I can catch that error and then proceed in the reversed order, but that creates some messy code.

In this case, LBYL is better than EAFP. You are doing `isinstance()` checks anyway, so you really already know whether to use `__mul__` or `__rmul__`.

For example, the old code

```
        if isinstance(left, LieAlgebraElement):
            self = <LieAlgebraElement> left
            y = right
        else:
            self = <LieAlgebraElement> right
            y = left
        try:
            return super(LieAlgebraElement, self).__mul__(y)
        except TypeError:
            pass
```

could be rewritten as

```
        try:
            if isinstance(left, LieAlgebraElement):
                return super(LieAlgebraElement, left).__mul__(right)
            else:
                return super(LieAlgebraElement, right).__rmul__(left)
        except TypeError:
            pass
```



---

Comment by git created at 2017-07-07 14:12:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-07-07 14:19:31

With the current implementation, I only need to do that when one of them is not an element and can assume it is a scalar. (Although I noticed some bad copy/pasting: `left = (<LieAlgebraElement> right).lift()` :P). Moreover, it saves a few `isinstance` checks; granted, this is far from the bottleneck point in practical code. I also think the logic is easier to follow this way, but yes, there is a technical debt from doing a bit of near duplication.

Really, I think Cython should let `Element.__mul__(left, right)` work since it makes no assumptions on the type of `Foo.__mul__(left, right)`. I would almost consider this to be a bug in Cython because of that.


---

Comment by jdemeyer created at 2017-07-07 14:55:57

Replying to [comment:23 tscrim]:
> Really, I think Cython should let `Element.__mul__(left, right)` work

It's not a Cython issue but a Python issue. I understand the confusion because

```
cdef class Element:
    def __mul__(left, right):
        ...
```

looks like it is providing `Element.__mul__` but that isn't actually the case. In Cython, the syntax `def __mul__(left, right)` is used to define the `nb_multiply` function in the `PyTypeObject` structure. Python (not Cython) then adds `__mul__` and `__rmul__` attributes which call the `nb_multiply` function implementated by Cython.

Maybe it's easier to understand with `__richcmp__` on the one hand and `__eq__`, `__lt__`, ... on the other hand. `__richcmp__` is just Cython syntax, there is no actual method called `__richcmp__`. But Python does generate `__eq__`, ... methods from this.

Thinking about it, you _could_ actually call `nb_multiply` directly from Cython. But that would not qualify as a clean solution.


---

Comment by jdemeyer created at 2017-07-07 15:08:35

Thinking more about it: I think I know how to make the call `Element.__mul__(left, right)` work. I could write a function `wrapperdescr_call_nocheck()` which overrides some checks that Python does. Then `Element.__mul__(left, right)` would become

```
wrapperdescr_call_nocheck(Element.__mul__, left, right)
```

which would skip the check of the `self` argument.

Would that make you happy or do you think it's a bad idea?


---

Comment by tscrim created at 2017-07-07 15:37:31

Just to be certain, the error is coming from Python with the wrapper `Element.__mul__(left, right)`, but when `def __mul__(left, right):` in `Foo` is called, it is actually just calling the underlying `nb_multiply`. So by instead calling `nb_multiply`, it would avoid the Python checks and start the `Element.__mul__` code. Is that correct?

Am also I correct in that `wrapperdescr_call_nocheck()` is just a more general-purpose function instead of calling `nb_multiply` (or other similar functions) directly in the Cython code? Since this is likely a more special case, I would say for now we can just call directly `nb_multiply` with some comments about it is done to avoid Python type checks. However, I would be happy with such a function if you think it is better to not call `nb_multiply`. If you're okay with directly calling `nb_multiply`, what is the syntax I should use and what do I need to do to import it?


---

Comment by jdemeyer created at 2017-07-07 20:49:35

Replying to [comment:26 tscrim]:
> Just to be certain, the error is coming from Python with the wrapper `Element.__mul__(left, right)`, but when `def __mul__(left, right):` in `Foo` is called, it is actually just calling the underlying `nb_multiply`.

I don't really understand your question. But let me try to clarify anyway. Consider

```
cdef class Foo:
    def __mul__(left, right):
        pass
```

Now, this `def __mul__` is not a Python method or function or anything like that. It's really a C function to put in the `nb_multiply` slot. Cython chose the syntax `def __mul__` because it would be familiar to Python programmers, but the similar syntax hides the difference in what it really is.

Now, when a type(*) is initialized by Python, ordinary Python attributes `__mul__` and `__rmul__` are generated from the slots like `nb_multiply`. These attributes are of type "slot wrapper" and you can see them in the `__dict__`:

```
sage: Integer.__mul__
<slot wrapper '__mul__' of 'sage.rings.integer.Integer' objects>
sage: Integer.__rmul__
<slot wrapper '__rmul__' of 'sage.rings.integer.Integer' objects>
sage: Integer.__dict__
dict_proxy({'__abs__': <slot wrapper '__abs__' of 'sage.rings.integer.Integer' objects>,
            '__add__': <slot wrapper '__add__' of 'sage.rings.integer.Integer' objects>,
            '__and__': <slot wrapper '__and__' of 'sage.rings.integer.Integer' objects>,
            '__array_interface__': <attribute '__array_interface__' of 'sage.rings.integer.Integer' objects>,
            '__copy__': <method '__copy__' of 'sage.rings.integer.Integer' objects>,
            '__div__': <slot wrapper '__div__' of 'sage.rings.integer.Integer' objects>,
            .......
```

These behave mostly like ordinary methods. They are implemented by Python and call the underlying slot function, which is `nb_multiply` for both `__mul__` and `__rmul__`.

In other words, the Python code `cls.__mul__(left, right)` roughly translates to `cls->nb_multiply(left, right)` in C, _with extra checking_ added (like ordinary methods, the first argument `self` should be a suitable type). Now what I propose is to have a special function

```
def wrapperdescr_call_nocheck(slotwrapper, *args)
```

which would call the underlying slot function but _without checks_.

I haven't actually tried if it would work, but it should. And I can imagine it being useful for other purposes too. This might turn out to be one of these things where, if you know that it exists, you start seeing lots of use cases.

You might think that the problem could also be solved by implementing a custom `__mul__` method-like attribute on the type(*), which would be like the standard `__mul__` slot wrapper, except that it would not check that the first argument is of the right type. That sounds good, but breaks when subtyping(*): Python insists on "restoring" the slot wrapper in the subtype(*). I know because this broke an earlier attempt of #23102.

(*) "type" and "class" mean the same thing in Python. However, there is a tendency to use "type" when talking about Python internals but "class" when talking about user code. The only exception are old-style classes, which are not types: indeed, `type(obj)` is not the same as `obj.__class__` for instances of old-style classes.


---

Comment by jdemeyer created at 2017-07-07 21:15:36

Side comment: most special methods (like `__init__`, `__getattribute__`, `__hash__`, `__repr__`, `__iter__`, ...) are implemented this way. Usually, there is a close correspondence between the Python attribute and the C function: the first argument really is `self` and 1 slot function only has 1 attribute. The main exceptions to these are:

1. `__new__` which is special in many "interesting" ways

2. Rich comparison like `__eq__` because one C function corresponds to six Python methods. The first argument is still `self` though.

3. Arithmetic like `__mul__` because the first argument may not be `self`.

Interestingly, Cython already special cases calls to `__new__` (`cls.__new__(cls)` does not mean the same thing in Python and Cython) and I recently dealt with various tickets to improve Python support for rich comparisons. So, to finish the list, maybe there should be a ticket to close the gap between the Python and C implementations of arithmetic too.


---

Comment by tscrim created at 2017-07-09 06:29:10

Thank you for the explanation; that is very useful. So my question right now is should we simply use `nb_multiply` as the super call? Although there definitely should be other use-cases for a `wrapperdescr_call_nocheck`, and from looking at #23102, I agree that it should be possible to write such a function. I'm wondering what you think the best approach is?


---

Comment by jdemeyer created at 2017-07-10 08:13:10

Replying to [comment:29 tscrim]:
> Thank you for the explanation; that is very useful. So my question right now is should we simply use `nb_multiply` as the super call? Although there definitely should be other use-cases for a `wrapperdescr_call_nocheck`, and from looking at #23102, I agree that it should be possible to write such a function. I'm wondering what you think the best approach is?

I would prefer `wrapperdescr_call_nocheck` because it's a general solution. The `nb_multiply` thing would be very specific and it would probably also require some trivial changes to Cython upstream.


---

Comment by tscrim created at 2017-07-10 15:40:33

Replying to [comment:30 jdemeyer]:
> Replying to [comment:29 tscrim]:
> > Thank you for the explanation; that is very useful. So my question right now is should we simply use `nb_multiply` as the super call? Although there definitely should be other use-cases for a `wrapperdescr_call_nocheck`, and from looking at #23102, I agree that it should be possible to write such a function. I'm wondering what you think the best approach is?
> 
> I would prefer `wrapperdescr_call_nocheck` because it's a general solution. The `nb_multiply` thing would be very specific and it would probably also require some trivial changes to Cython upstream.

If you write such a function, I will make the appropriate changes in here to use it.


---

Comment by jdemeyer created at 2017-07-12 12:15:18

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-07-12 14:19:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-07-12 14:29:49

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2017-07-12 14:29:49

Rebased. Thank you for adding the function. Although this does result in a slowdown in some of the operations:

```
sage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z':1}})
sage: %timeit int(3) * x
100000 loops, best of 3: 4.09 µs per loop
sage: %timeit x * int(3)
100000 loops, best of 3: 4.14 µs per loop
sage: %timeit x * y
10000 loops, best of 3: 86.1 µs per loop
sage: %timeit 3 * x
100000 loops, best of 3: 4.15 µs per loop
sage: %timeit x * 3
100000 loops, best of 3: 4.11 µs per loop
sage: %timeit (3/2) * x
100000 loops, best of 3: 3.1 µs per loop
sage: %timeit x * (3/2)
100000 loops, best of 3: 3.02 µs per loop
sage: %timeit for _ in range(1000): 3 * x
100 loops, best of 3: 4.01 ms per loop
sage: %timeit for _ in range(1000): x * 3
100 loops, best of 3: 3.99 ms per loop
```

versus the previous commit:

```
Lsage: L.<x,y,z> = LieAlgebra(QQ, {('x','y'): {'z':1}})
sage: %timeit int(3) * x
100000 loops, best of 3: 3.07 µs per loop
sage: %timeit x * int(3)
100000 loops, best of 3: 2.85 µs per loop
sage: %timeit x * y
100000 loops, best of 3: 7.32 µs per loop
sage: %timeit 3 * x
100000 loops, best of 3: 3.87 µs per loop
sage: %timeit x * 3
100000 loops, best of 3: 3.67 µs per loop
sage: %timeit (3/2) * x
100000 loops, best of 3: 2.93 µs per loop
sage: %timeit x * (3/2)
100000 loops, best of 3: 2.81 µs per loop
sage: %timeit for _ in range(1000): 3 * x
100 loops, best of 3: 3.88 ms per loop
sage: %timeit for _ in range(1000): x * 3
100 loops, best of 3: 3.74 ms per loop
```

The multiplication of elements in the Lie algebra should be a rare event and is mainly used as a convenience (the better way is to do the lift within the code itself). I also would say multiplying by an `int` should not really be done either.

TL;DR - I can live with the 5-10% regression for the typical multiplication cases in order to have cleaner code.


---

Comment by jdemeyer created at 2017-07-12 14:38:25

I can think of 2 reasons for the slowdown:

1. The method access `IndexedFreeModuleElement.__mul__` takes some time. You could do this at the top-level like

```
cdef object IndexedFreeModuleElement__mul__ = IndexedFreeModuleElement.__mul__
```


2. You are constructing `{}` for every call of `wrapperdescr_fastcall`. Since this `kwds` argument is not actually used, you could pass `None` instead.


---

Comment by jdemeyer created at 2017-07-12 14:46:44

Instead of passing `None` as `kwds`, even faster would be passing `<object>NULL`.


---

Comment by git created at 2017-07-12 14:47:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-07-12 14:49:35

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2017-07-12 14:50:20

That does put me back in the same timing realm as before, thank you.


---

Comment by tscrim created at 2017-07-26 02:57:00

Ping. I also checked that this does not conflict with #23440.


---

Comment by git created at 2017-07-31 03:09:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-10 22:40:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2017-08-20 13:45:35

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2017-08-20 13:45:35

ok, I am setting this to positive


---

Comment by vbraun created at 2017-08-26 09:58:04

Resolution: fixed
