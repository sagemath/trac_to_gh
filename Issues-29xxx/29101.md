# Issue 29101: Refined protocol for _element_constructor_ in element classes with mutability

archive/issues_028864.json:
```json
{
    "assignees": [],
    "body": "**Problem description:**\n\nGiven a vector `v` with base ring `R`, the constructions \n- `w = vector(R, v)`\n- `w = vector(v, R)`\n- `w = vector(v)`\nall return the original vector `v`. As a consequence, all changes applied to `w` are also applied to `v` and vice versa. \n\n```\nsage: v = vector([1,2,3])\nsage: w = vector(v, ZZ)\nsage: w is v\nTrue\nsage: w[1] = 7\nsage: v\n(1, 7, 3)\n```\n\n\n**Proposal:**\n\nThe `__call__` method of a parent object serves several purposes:  In one-argument calls, (1) it is the identity (in the strong sense of Python's `id`) on elements of its parent and (2) in general, a convert map, with (3) input `0` as a permissive special case, which is also the default argument of `Parent.__call__`. (4) In multiple-argument calls, it is the element constructor.\n\nProposal: Define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:\n- In element classes with mutability, `_element_constructor_(x, ...)` MUST support optional arguments `copy` and `mutable`. \n\n- These arguments are allowed to have various defaulting behavior that is the most appropriate for the specific class, but there are some restrictions:\n\n- `copy` MUST NOT default to `True` for mutable inputs `x` because (as discussed) this is not compatible with (1).\n\n- `mutable=False` and `copy=False` MUST be an error for mutable input `x`. \n\nMoreover, **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.\n\nWe add `_test_...` methods that check this protocol.\n\n\nRelated:\n\n- https://groups.google.com/g/sage-devel/c/DNrbtItMVmQ\n- #32353 Guide for parents with immutable elements\n\n\nCC:  @kliem @mjungmath @mkoeppe @tscrim @nbruin @dcoudert @mwageringel @pjbruin @kwankyu @williamstein\n\nComponent: **misc**\n\nKeywords: **vector, constructor, copy**\n\nBranch/Commit: **[u/mkoeppe/refined_protocol_for__element_constructor__in_element_classes_with_mutability](https://github.com/sagemath/sagetrac-mirror/tree/u/mkoeppe/refined_protocol_for__element_constructor__in_element_classes_with_mutability) @ [`501e7ef`](https://github.com/sagemath/sagetrac-mirror/commit/501e7ef60ae4f46843464ed6a7c93c0ea050dec3)**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/29101_\n\n",
    "created_at": "2020-01-29T15:15:52Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20info"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.8",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Refined protocol for _element_constructor_ in element classes with mutability",
    "type": "issue",
    "updated_at": "2022-08-31T05:25:02Z",
    "url": "https://github.com/sagemath/sage/issues/29101",
    "user": "https://github.com/sagetrac-nailuj"
}
```
**Problem description:**

Given a vector `v` with base ring `R`, the constructions 
- `w = vector(R, v)`
- `w = vector(v, R)`
- `w = vector(v)`
all return the original vector `v`. As a consequence, all changes applied to `w` are also applied to `v` and vice versa. 

```
sage: v = vector([1,2,3])
sage: w = vector(v, ZZ)
sage: w is v
True
sage: w[1] = 7
sage: v
(1, 7, 3)
```


**Proposal:**

The `__call__` method of a parent object serves several purposes:  In one-argument calls, (1) it is the identity (in the strong sense of Python's `id`) on elements of its parent and (2) in general, a convert map, with (3) input `0` as a permissive special case, which is also the default argument of `Parent.__call__`. (4) In multiple-argument calls, it is the element constructor.

Proposal: Define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:
- In element classes with mutability, `_element_constructor_(x, ...)` MUST support optional arguments `copy` and `mutable`. 

- These arguments are allowed to have various defaulting behavior that is the most appropriate for the specific class, but there are some restrictions:

- `copy` MUST NOT default to `True` for mutable inputs `x` because (as discussed) this is not compatible with (1).

- `mutable=False` and `copy=False` MUST be an error for mutable input `x`. 

Moreover, **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.

We add `_test_...` methods that check this protocol.


Related:

- https://groups.google.com/g/sage-devel/c/DNrbtItMVmQ
- #32353 Guide for parents with immutable elements


CC:  @kliem @mjungmath @mkoeppe @tscrim @nbruin @dcoudert @mwageringel @pjbruin @kwankyu @williamstein

Component: **misc**

Keywords: **vector, constructor, copy**

Branch/Commit: **[u/mkoeppe/refined_protocol_for__element_constructor__in_element_classes_with_mutability](https://github.com/sagemath/sagetrac-mirror/tree/u/mkoeppe/refined_protocol_for__element_constructor__in_element_classes_with_mutability) @ [`501e7ef`](https://github.com/sagemath/sagetrac-mirror/commit/501e7ef60ae4f46843464ed6a7c93c0ea050dec3)**

_Issue created by migration from https://trac.sagemath.org/ticket/29101_





---

archive/issue_events_396962.json:
```json
{
    "actor": "https://github.com/sagetrac-nailuj",
    "created_at": "2020-01-29T15:15:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396962"
}
```



---

archive/issue_events_396963.json:
```json
{
    "actor": "https://github.com/sagetrac-nailuj",
    "created_at": "2020-01-29T15:15:52Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396963"
}
```



---

archive/issue_events_396964.json:
```json
{
    "actor": "https://github.com/sagetrac-nailuj",
    "created_at": "2020-01-29T15:15:52Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396964"
}
```



---

archive/issue_comments_455555.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nSome examples for comparison:\n\nFor basic python types, \nsimilar constructions return \n- a new object, if it's mutable (`list`, `set`, `dict`)\n\n```\nsage: L = [1,2,3]\nsage: M = list(L)\nsage: L is M\nFalse\nsage: S = {1,2,3}\nsage: T = set(S)\nsage: S is T\nFalse\nsage: D = dict({1:2, 3:4})\nsage: E = dict(D)\nsage: D is E\nFalse\n```\n\n- the old object, if it's immutable (`tuple`)\n\n```\nsage: X = (1,2,3)\nsage: Y = tuple(X)\nsage: X is Y\nTrue\n```\n\nRegarding two examples of Sage objects,\n\n- in `Graph`s, a new object is returned, whether the old one was set immutable or not\n\n```\nsage: G = graphs.CompleteGraph(5)\nsage: H = Graph(G)\nsage: H is G\nFalse\n```\n\n- in `Set`s, which wrap around an immutable frozenset, the old object is returned\n\n```\nsage: S = Set([1,2,3])\nsage: T = Set(S)\nsage: S is T\nTrue\n```",
    "created_at": "2020-01-29T15:17:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455555",
    "user": "https://github.com/sagetrac-nailuj"
}
```

<div id="comment:1" align="right">comment:1</div>

Some examples for comparison:

For basic python types, 
similar constructions return 
- a new object, if it's mutable (`list`, `set`, `dict`)

```
sage: L = [1,2,3]
sage: M = list(L)
sage: L is M
False
sage: S = {1,2,3}
sage: T = set(S)
sage: S is T
False
sage: D = dict({1:2, 3:4})
sage: E = dict(D)
sage: D is E
False
```

- the old object, if it's immutable (`tuple`)

```
sage: X = (1,2,3)
sage: Y = tuple(X)
sage: X is Y
True
```

Regarding two examples of Sage objects,

- in `Graph`s, a new object is returned, whether the old one was set immutable or not

```
sage: G = graphs.CompleteGraph(5)
sage: H = Graph(G)
sage: H is G
False
```

- in `Set`s, which wrap around an immutable frozenset, the old object is returned

```
sage: S = Set([1,2,3])
sage: T = Set(S)
sage: S is T
True
```



---

archive/issue_events_396965.json:
```json
{
    "actor": "https://github.com/sagetrac-nailuj",
    "created_at": "2020-02-04T12:11:03Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396965"
}
```



---

archive/issue_events_396966.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-05-01T04:28:42Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396966"
}
```



---

archive/issue_events_396967.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-05-01T04:28:42Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396967"
}
```



---

archive/issue_comments_455556.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nMoving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.",
    "created_at": "2020-05-01T04:28:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455556",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:3" align="right">comment:3</div>

Moving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.



---

archive/issue_comments_455557.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nWe have a similar discussion running for `FiniteRankFreeModule` and elements in the manifolds module, take a look at #30302, especially [comment:3](https://github.com/sagemath/sage/issues/30302#comment:3).\n\nIn my opinion, this should not happen.",
    "created_at": "2020-08-07T19:31:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455557",
    "user": "https://github.com/mjungmath"
}
```

<div id="comment:5" align="right">comment:5</div>

We have a similar discussion running for `FiniteRankFreeModule` and elements in the manifolds module, take a look at #30302, especially [comment:3](https://github.com/sagemath/sage/issues/30302#comment:3).

In my opinion, this should not happen.



---

archive/issue_comments_455558.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nEven though the corresponding check via the flac `copy` is implemented in `FreeModule`, the coercion model preempts it. The corresponding change should be\n\n```diff\n-        if R is self and no_extra_args:\n-            return x\n```\n\nin `sage.structure.parent.Parent`.\n\nBut I don't know anything about the whole string of consequences coming from this.",
    "created_at": "2020-08-10T17:03:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455558",
    "user": "https://github.com/mjungmath"
}
```

<div id="comment:6" align="right">comment:6</div>

Even though the corresponding check via the flac `copy` is implemented in `FreeModule`, the coercion model preempts it. The corresponding change should be

```diff
-        if R is self and no_extra_args:
-            return x
```

in `sage.structure.parent.Parent`.

But I don't know anything about the whole string of consequences coming from this.



---

archive/issue_comments_455559.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nJust for fun, I've deleted these lines and ran a doctest:\n\n```\nFile \"src/sage/structure/parent.pyx\", line 1473, in sage.structure.parent.Parent._is_valid_homomorphism_._is_coercion_cached\nFailed example:\n    R._is_coercion_cached(QQ)\nExpected:\n    False\nGot:\n    True\n```",
    "created_at": "2020-08-10T17:12:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455559",
    "user": "https://github.com/mjungmath"
}
```

<div id="comment:7" align="right">comment:7</div>

Just for fun, I've deleted these lines and ran a doctest:

```
File "src/sage/structure/parent.pyx", line 1473, in sage.structure.parent.Parent._is_valid_homomorphism_._is_coercion_cached
Failed example:
    R._is_coercion_cached(QQ)
Expected:
    False
Got:
    True
```



---

archive/issue_comments_455560.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nNote that `FreeModule_generic._element_constructor_` has some optional arguments...\n\n```\n    def _element_constructor_(self, x, coerce=True, copy=True, check=True):\n```",
    "created_at": "2020-08-10T18:10:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455560",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:8" align="right">comment:8</div>

Note that `FreeModule_generic._element_constructor_` has some optional arguments...

```
    def _element_constructor_(self, x, coerce=True, copy=True, check=True):
```



---

archive/issue_comments_455561.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nReplying to [@mkoeppe](#comment%3A8):\n> Note that `FreeModule_generic._element_constructor_` has some optional arguments...\n> \n> ```\n>     def _element_constructor_(self, x, coerce=True, copy=True, check=True):\n> ```\n\nRegarding the default `copy=True` argument, a copy should be returned. But it is not due to the coercion framework.",
    "created_at": "2020-08-10T18:21:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455561",
    "user": "https://github.com/mjungmath"
}
```

<div id="comment:9" align="right">comment:9</div>

Replying to [@mkoeppe](#comment%3A8):
> Note that `FreeModule_generic._element_constructor_` has some optional arguments...
> 
> ```
>     def _element_constructor_(self, x, coerce=True, copy=True, check=True):
> ```

Regarding the default `copy=True` argument, a copy should be returned. But it is not due to the coercion framework.



---

archive/issue_comments_455562.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nRight. So how about changing this default to `False`?\nIf one really needs a copy (which is currently not guaranteed, as you have observed), then one would call it with `copy=True`. I think (haven't tested!) that this will not go through coercion because this path is only taken for 1-argument calls of the parent.",
    "created_at": "2020-08-12T05:24:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455562",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:10" align="right">comment:10</div>

Right. So how about changing this default to `False`?
If one really needs a copy (which is currently not guaranteed, as you have observed), then one would call it with `copy=True`. I think (haven't tested!) that this will not go through coercion because this path is only taken for 1-argument calls of the parent.



---

archive/issue_comments_455563.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nThis could only be a temporary solution. As you already pointed out, and I totally agree with you, the element constructor should behave consistently, i.e. always returning a mutable element. Returning the very same instant, assuming it is immutable, would contradict this behavior.",
    "created_at": "2020-08-12T06:35:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455563",
    "user": "https://github.com/mjungmath"
}
```

<div id="comment:11" align="right">comment:11</div>

This could only be a temporary solution. As you already pointed out, and I totally agree with you, the element constructor should behave consistently, i.e. always returning a mutable element. Returning the very same instant, assuming it is immutable, would contradict this behavior.



---

archive/issue_events_396968.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-12T22:20:55Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "title_is": "Refined protocol for _element_constructor_ in element classes with mutability",
    "title_was": "New vector from old vector returns the same object",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396968"
}
```



---

archive/issue_comments_455564.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nReplying to [@mjungmath](#comment%3A11):\n> As you already pointed out, and I totally agree with you, the element constructor should behave consistently, i.e. always returning a mutable element. Returning the very same instant, assuming it is immutable, would contradict this behavior. \n\nI don't think this is my position; if I did say this, let me try to refine it here. \n\nIn [#30302 comment:3](https://github.com/sagemath/sage/issues/30302#comment:3) I pointed out that **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.\n\nIt is not true that the parent object \"is\" the element constructor. Its `__call__` methods serves several purposes:  In one-argument calls, (1) it is the identity (in the strong sense of Python's `id`) on elements of its parent and (2) in general, a convert map, with (3) input `0` as a permissive special case, which is also the default argument of `Parent.__call__`. (4) In multiple-argument calls, it is the element constructor.\n\nMy proposal is to define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:\n- In element classes with mutability, `_element_constructor_(x, ...)` MUST support optional arguments `copy` and `mutable`. \n\n- These arguments are allowed to have various defaulting behavior that is the most appropriate for the specific class, but there are some restrictions:\n\n- `copy` MUST NOT default to `True` for mutable inputs `x` because (as discussed) this is not compatible with (1).\n\n- `mutable=False` and `copy=False` MUST be an error for mutable input `x`. \n\nWe could add `_test_...` methods that check this protocol.",
    "created_at": "2020-08-12T22:20:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455564",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:12" align="right">comment:12</div>

Replying to [@mjungmath](#comment%3A11):
> As you already pointed out, and I totally agree with you, the element constructor should behave consistently, i.e. always returning a mutable element. Returning the very same instant, assuming it is immutable, would contradict this behavior. 

I don't think this is my position; if I did say this, let me try to refine it here. 

In [#30302 comment:3](https://github.com/sagemath/sage/issues/30302#comment:3) I pointed out that **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.

It is not true that the parent object "is" the element constructor. Its `__call__` methods serves several purposes:  In one-argument calls, (1) it is the identity (in the strong sense of Python's `id`) on elements of its parent and (2) in general, a convert map, with (3) input `0` as a permissive special case, which is also the default argument of `Parent.__call__`. (4) In multiple-argument calls, it is the element constructor.

My proposal is to define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:
- In element classes with mutability, `_element_constructor_(x, ...)` MUST support optional arguments `copy` and `mutable`. 

- These arguments are allowed to have various defaulting behavior that is the most appropriate for the specific class, but there are some restrictions:

- `copy` MUST NOT default to `True` for mutable inputs `x` because (as discussed) this is not compatible with (1).

- `mutable=False` and `copy=False` MUST be an error for mutable input `x`. 

We could add `_test_...` methods that check this protocol.



---

archive/issue_comments_455565.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nReplying to [@mkoeppe](#comment%3A12):\n> Replying to [@mjungmath](#comment%3A11):\n> > As you already pointed out, and I totally agree with you, the element constructor should behave consistently, i.e. always returning a mutable element. Returning the very same instant, assuming it is immutable, would contradict this behavior. \n\n> \n> I don't think this is my position; if I did say this, let me try to refine it here. \n> \n> In [#30302 comment:3](https://github.com/sagemath/sage/issues/30302#comment:3) I pointed out that **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.\n\nI was more referring to your first paragraph:\n\n> Both `M()` and `M(0)` return a new mutable element. That's how one creates a new vector, whose components can then be modified. If you want the immutable 0 element, you can use `M.zero()`.\n\nConsider the following code:\n\n```\nsage: M = FreeModule(QQ, 3)\nsage: v = M([1,2,3])\nsage: v.set_immutable()\nsage: M(v).is_immutable()\nTrue\n```\n\nI don't see a point if the element constructor sometimes returns a mutable and sometimes an immutable element. This is how I understood your argument that we should `M(0)` return a new mutable \"zero\" istead of the same instance as `M.zero()`. If it really doesn't matter whether the element is mutable or not, we should allow `M(0)` returning the cached `M.zero()` instance since this is much much faster (especially in the manifold setting).\n\nI'd say, if `M` a priori creates mutable elements, the element constructor should *always* return mutable elements. This would be consistent.",
    "created_at": "2020-08-14T07:40:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455565",
    "user": "https://github.com/mjungmath"
}
```

<div id="comment:16" align="right">comment:16</div>

Replying to [@mkoeppe](#comment%3A12):
> Replying to [@mjungmath](#comment%3A11):
> > As you already pointed out, and I totally agree with you, the element constructor should behave consistently, i.e. always returning a mutable element. Returning the very same instant, assuming it is immutable, would contradict this behavior. 

> 
> I don't think this is my position; if I did say this, let me try to refine it here. 
> 
> In [#30302 comment:3](https://github.com/sagemath/sage/issues/30302#comment:3) I pointed out that **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.

I was more referring to your first paragraph:

> Both `M()` and `M(0)` return a new mutable element. That's how one creates a new vector, whose components can then be modified. If you want the immutable 0 element, you can use `M.zero()`.

Consider the following code:

```
sage: M = FreeModule(QQ, 3)
sage: v = M([1,2,3])
sage: v.set_immutable()
sage: M(v).is_immutable()
True
```

I don't see a point if the element constructor sometimes returns a mutable and sometimes an immutable element. This is how I understood your argument that we should `M(0)` return a new mutable "zero" istead of the same instance as `M.zero()`. If it really doesn't matter whether the element is mutable or not, we should allow `M(0)` returning the cached `M.zero()` instance since this is much much faster (especially in the manifold setting).

I'd say, if `M` a priori creates mutable elements, the element constructor should *always* return mutable elements. This would be consistent.



---

archive/issue_events_396969.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-27T04:26:21Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396969"
}
```



---

archive/issue_events_396970.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-27T04:26:21Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396970"
}
```



---

archive/issue_events_396971.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-03-15T22:07:04Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396971"
}
```



---

archive/issue_events_396972.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-03-15T22:07:04Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396972"
}
```



---

archive/issue_comments_455566.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nSetting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-15T22:07:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455566",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:19" align="right">comment:19</div>

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_396973.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T00:44:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396973"
}
```



---

archive/issue_events_396974.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T00:44:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396974"
}
```



---

archive/issue_comments_455567.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nSetting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455567",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:20" align="right">comment:20</div>

Setting a new milestone for this ticket based on a cursory review.



---

archive/issue_comments_455568.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,5 @@\n+**Problem description:**\n+\n Given a vector `v` with base ring `R`, the constructions \n - `w = vector(R, v)`\n - `w = vector(v, R)`\n@@ -14,4 +16,26 @@\n (1, 7, 3)\n ```\n \n-Is this supposed to happen?\n+\n+**Proposal:**\n+\n+The `__call__` method of a parent object serves several purposes:  In one-argument calls, (1) it is the identity (in the strong sense of Python's `id`) on elements of its parent and (2) in general, a convert map, with (3) input `0` as a permissive special case, which is also the default argument of `Parent.__call__`. (4) In multiple-argument calls, it is the element constructor.\n+\n+My proposal is to define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:\n+- In element classes with mutability, `_element_constructor_(x, ...)` MUST support optional arguments `copy` and `mutable`. \n+\n+- These arguments are allowed to have various defaulting behavior that is the most appropriate for the specific class, but there are some restrictions:\n+\n+- `copy` MUST NOT default to `True` for mutable inputs `x` because (as discussed) this is not compatible with (1).\n+\n+- `mutable=False` and `copy=False` MUST be an error for mutable input `x`. \n+\n+Moreover, **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.\n+\n+We could add `_test_...` methods that check this protocol.\n+\n+\n+Related discussion:\n+\n+- https://groups.google.com/g/sage-devel/c/DNrbtItMVmQ\n+\n``````\n",
    "created_at": "2021-08-09T20:45:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455568",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,5 @@
+**Problem description:**
+
 Given a vector `v` with base ring `R`, the constructions 
 - `w = vector(R, v)`
 - `w = vector(v, R)`
@@ -14,4 +16,26 @@
 (1, 7, 3)
 ```
 
-Is this supposed to happen?
+
+**Proposal:**
+
+The `__call__` method of a parent object serves several purposes:  In one-argument calls, (1) it is the identity (in the strong sense of Python's `id`) on elements of its parent and (2) in general, a convert map, with (3) input `0` as a permissive special case, which is also the default argument of `Parent.__call__`. (4) In multiple-argument calls, it is the element constructor.
+
+My proposal is to define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:
+- In element classes with mutability, `_element_constructor_(x, ...)` MUST support optional arguments `copy` and `mutable`. 
+
+- These arguments are allowed to have various defaulting behavior that is the most appropriate for the specific class, but there are some restrictions:
+
+- `copy` MUST NOT default to `True` for mutable inputs `x` because (as discussed) this is not compatible with (1).
+
+- `mutable=False` and `copy=False` MUST be an error for mutable input `x`. 
+
+Moreover, **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.
+
+We could add `_test_...` methods that check this protocol.
+
+
+Related discussion:
+
+- https://groups.google.com/g/sage-devel/c/DNrbtItMVmQ
+
``````




---

archive/issue_comments_455569.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nGiven that in some parents it is possible to create both mutable and immutable elements, having a `mutable` parameter for the relevant `_element_constructor_` makes perfect sense. Calls to it are usually only made indirectly, since generally element construction happens through conversion or coercion. So we still need methods for getting the appropriate setting to it and most importantly, control what the default value is that needs to be passed in. In particular, for arithmetic like\n\n```\nD=dict()\nD[v+w] = D[v]+D[w]\n```\nwe need a way to have parents that use default value \"immutable\".\n\nIn the usual paradigm of mutable data structures, there should be a way of getting an uninitialized mutable element; something like `v=VectorSpace(QQ,3).mutable_element` and, it being mutable, should have an easy way of being assigned to; like `v.assign(bla)` or, perhaps more pythonic, `v[:]= ...`.\n\nWith that in place, there would be a clear expressive way for people to get mutable vectors and matrices, freeing up the default constructors to just produce immutable elements. This would be quite backwards incompatible, but that might be a hit we need to take.\n\nNote that for efficient use of mutable elements, we need a whole slew of extra routines as well, because normal expression notation doesn't jive with efficient use of mutable data structures.\nFor instance, for efficient mutable vector sums and scalar products, we'd need\n\n```\nv.assign_sum(v,w) #make sure in-place mutation works!\nv.scale_by(c)\n```\n\nSee the API of libraries like `mpfr` for inspiration.",
    "created_at": "2021-08-11T21:21:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455569",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:22" align="right">comment:22</div>

Given that in some parents it is possible to create both mutable and immutable elements, having a `mutable` parameter for the relevant `_element_constructor_` makes perfect sense. Calls to it are usually only made indirectly, since generally element construction happens through conversion or coercion. So we still need methods for getting the appropriate setting to it and most importantly, control what the default value is that needs to be passed in. In particular, for arithmetic like

```
D=dict()
D[v+w] = D[v]+D[w]
```
we need a way to have parents that use default value "immutable".

In the usual paradigm of mutable data structures, there should be a way of getting an uninitialized mutable element; something like `v=VectorSpace(QQ,3).mutable_element` and, it being mutable, should have an easy way of being assigned to; like `v.assign(bla)` or, perhaps more pythonic, `v[:]= ...`.

With that in place, there would be a clear expressive way for people to get mutable vectors and matrices, freeing up the default constructors to just produce immutable elements. This would be quite backwards incompatible, but that might be a hit we need to take.

Note that for efficient use of mutable elements, we need a whole slew of extra routines as well, because normal expression notation doesn't jive with efficient use of mutable data structures.
For instance, for efficient mutable vector sums and scalar products, we'd need

```
v.assign_sum(v,w) #make sure in-place mutation works!
v.scale_by(c)
```

See the API of libraries like `mpfr` for inspiration.



---

archive/issue_comments_455570.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nFor that, we would want to (also?) override `__iadd__`, `__imul__` etc. for `+=` and `-=`.",
    "created_at": "2021-08-11T21:25:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455570",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:23" align="right">comment:23</div>

For that, we would want to (also?) override `__iadd__`, `__imul__` etc. for `+=` and `-=`.



---

archive/issue_comments_455571.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nReplying to [@tscrim](#comment%3A23):\n> For that, we would want to (also?) override `__iadd__`, `__imul__` etc. for `+=` and `-=`.\n\nYes. Does the coercion system already have preparation for this at all?",
    "created_at": "2021-08-11T21:28:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455571",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:24" align="right">comment:24</div>

Replying to [@tscrim](#comment%3A23):
> For that, we would want to (also?) override `__iadd__`, `__imul__` etc. for `+=` and `-=`.

Yes. Does the coercion system already have preparation for this at all?



---

archive/issue_comments_455572.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nReplying to [@mkoeppe](#comment%3A24):\n> Replying to [@tscrim](#comment%3A23):\n> > For that, we would want to (also?) override `__iadd__`, `__imul__` etc. for `+=` and `-=`.\n\n> Yes. Does the coercion system already have preparation for this at all?\n\nStrictly speaking, coercion doesn't quite make sense here because the coefficients might have to leave the current coefficient ring (say, we are working over `ZZ['x']` and then add something in `QQ`, we get something in `QQ['x']`). So it doesn't quite fit into the pattern for the other binary operators. Instead, we would need something like this:\n\n```python\nP = self.parent()\nif P.has_coerce_map_from(other.parent()):\n    return self.inplace_add(P(other))\nreturn coercion_model.bin_op(self, other, op)\n```\nHowever, we currently do not have, e.g., `_iadd_` methods. Perhaps we should have a generic one? This might slow some code down due using `v += w` for some extra indirection/checks when it has the same result as `v = v + w`.",
    "created_at": "2021-08-11T21:36:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455572",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:25" align="right">comment:25</div>

Replying to [@mkoeppe](#comment%3A24):
> Replying to [@tscrim](#comment%3A23):
> > For that, we would want to (also?) override `__iadd__`, `__imul__` etc. for `+=` and `-=`.

> Yes. Does the coercion system already have preparation for this at all?

Strictly speaking, coercion doesn't quite make sense here because the coefficients might have to leave the current coefficient ring (say, we are working over `ZZ['x']` and then add something in `QQ`, we get something in `QQ['x']`). So it doesn't quite fit into the pattern for the other binary operators. Instead, we would need something like this:

```python
P = self.parent()
if P.has_coerce_map_from(other.parent()):
    return self.inplace_add(P(other))
return coercion_model.bin_op(self, other, op)
```
However, we currently do not have, e.g., `_iadd_` methods. Perhaps we should have a generic one? This might slow some code down due using `v += w` for some extra indirection/checks when it has the same result as `v = v + w`.



---

archive/issue_comments_455573.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nI agree, this is not a normal binop-coercion; nevertheless taking care of it is a task for the coercion system, so I'm +1 for single-underscore `_iadd_` etc. methods.",
    "created_at": "2021-08-11T22:09:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455573",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:26" align="right">comment:26</div>

I agree, this is not a normal binop-coercion; nevertheless taking care of it is a task for the coercion system, so I'm +1 for single-underscore `_iadd_` etc. methods.



---

archive/issue_comments_455574.json:
```json
{
    "body": "Branch: **[u/mkoeppe/refined_protocol_for__element_constructor__in_element_classes_with_mutability](https://github.com/sagemath/sagetrac-mirror/tree/u/mkoeppe/refined_protocol_for__element_constructor__in_element_classes_with_mutability)**",
    "created_at": "2021-08-11T23:01:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455574",
    "user": "https://github.com/mkoeppe"
}
```

Branch: **[u/mkoeppe/refined_protocol_for__element_constructor__in_element_classes_with_mutability](https://github.com/sagemath/sagetrac-mirror/tree/u/mkoeppe/refined_protocol_for__element_constructor__in_element_classes_with_mutability)**



---

archive/issue_comments_455575.json:
```json
{
    "body": "Commit: **[`501e7ef`](https://github.com/sagemath/sagetrac-mirror/commit/501e7ef60ae4f46843464ed6a7c93c0ea050dec3)**",
    "created_at": "2021-08-11T23:04:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455575",
    "user": "https://github.com/mkoeppe"
}
```

Commit: **[`501e7ef`](https://github.com/sagemath/sagetrac-mirror/commit/501e7ef60ae4f46843464ed6a7c93c0ea050dec3)**



---

archive/issue_comments_455576.json:
```json
{
    "body": "<div id=\"comment:28\" align=\"right\">comment:28</div>\n\nHere's the beginning of a `_test_...` method to enforce the proposed protocol. \n\n`git grep mutable=` reveals that various classes use the keyword `mutable=...`, others use `immutable=...`. Should we aim to support both for all classes?\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/501e7ef60ae4f46843464ed6a7c93c0ea050dec3\"><code>501e7ef</code></a></td><td><code>Parent._test_call: New</code></td></tr></table>\n",
    "created_at": "2021-08-11T23:04:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455576",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:28" align="right">comment:28</div>

Here's the beginning of a `_test_...` method to enforce the proposed protocol. 

`git grep mutable=` reveals that various classes use the keyword `mutable=...`, others use `immutable=...`. Should we aim to support both for all classes?

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/501e7ef60ae4f46843464ed6a7c93c0ea050dec3"><code>501e7ef</code></a></td><td><code>Parent._test_call: New</code></td></tr></table>




---

archive/issue_comments_455577.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -21,7 +21,7 @@\n \n The `__call__` method of a parent object serves several purposes:  In one-argument calls, (1) it is the identity (in the strong sense of Python's `id`) on elements of its parent and (2) in general, a convert map, with (3) input `0` as a permissive special case, which is also the default argument of `Parent.__call__`. (4) In multiple-argument calls, it is the element constructor.\n \n-My proposal is to define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:\n+Proposal: Define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:\n - In element classes with mutability, `_element_constructor_(x, ...)` MUST support optional arguments `copy` and `mutable`. \n \n - These arguments are allowed to have various defaulting behavior that is the most appropriate for the specific class, but there are some restrictions:\n@@ -32,10 +32,11 @@\n \n Moreover, **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.\n \n-We could add `_test_...` methods that check this protocol.\n+We add `_test_...` methods that check this protocol.\n \n \n-Related discussion:\n+Related:\n \n - https://groups.google.com/g/sage-devel/c/DNrbtItMVmQ\n+- #32353 Guide for parents with immutable elements\n \n``````\n",
    "created_at": "2021-08-11T23:07:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455577",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -21,7 +21,7 @@
 
 The `__call__` method of a parent object serves several purposes:  In one-argument calls, (1) it is the identity (in the strong sense of Python's `id`) on elements of its parent and (2) in general, a convert map, with (3) input `0` as a permissive special case, which is also the default argument of `Parent.__call__`. (4) In multiple-argument calls, it is the element constructor.
 
-My proposal is to define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:
+Proposal: Define a general protocol for element classes with mutability which does NOT change the above but only refines it for mutable classes as follows:
 - In element classes with mutability, `_element_constructor_(x, ...)` MUST support optional arguments `copy` and `mutable`. 
 
 - These arguments are allowed to have various defaulting behavior that is the most appropriate for the specific class, but there are some restrictions:
@@ -32,10 +32,11 @@
 
 Moreover, **arithmetic** operations need to be consistent: Either always return a new element (even for trivial operations), or always return an immutable element.
 
-We could add `_test_...` methods that check this protocol.
+We add `_test_...` methods that check this protocol.
 
 
-Related discussion:
+Related:
 
 - https://groups.google.com/g/sage-devel/c/DNrbtItMVmQ
+- #32353 Guide for parents with immutable elements
 
``````




---

archive/issue_comments_455578.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nReplying to [@mkoeppe](#comment%3A26):\n> I agree, this is not a normal binop-coercion; nevertheless taking care of it is a task for the coercion system, so I'm +1 for single-underscore `_iadd_` etc. methods. \n\nBefore you start designing all kinds of fancy features, I think you first want to establish a need. I don't think there is one. By the time you need micro-optimizations such as using mutable structures and in-place modification, you don't want the overhead of coercion to occur.\n\nAnyway, for a `v += w` the question really is: is there a coercion from `w.base_ring()` into `v.base_ring()` or for `v *= c` if there is an action of `c` on `v` and whether you can unwind that to a coefficient-wise operation (the action discovery currently available won't tell you).\n\nIn any case, these 2-argument mutation operations do not cover what is needed for efficient mutable object manipulation. There is the three-argument version too:\n`for i in range(n): u[i] = v[i] + w[i]` where the target is not one of the operands. It would really defeat the purpose if you'd have to execute that as `u[:]=v; u+=w`.\n\n(I have some recent experience with inplace mutation (with mpfr) in order to get a fast evaluation of Riemann theta functions -- ticket TBA :-). If these inplace features above would have existed, I would still not have used them, because I really needed the 3-operand versions and because I wouldn't want to pay the incref/decref price for manipulating python objects. Make sure you have a usage scenario before you design the tools!)",
    "created_at": "2021-08-12T07:13:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455578",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:30" align="right">comment:30</div>

Replying to [@mkoeppe](#comment%3A26):
> I agree, this is not a normal binop-coercion; nevertheless taking care of it is a task for the coercion system, so I'm +1 for single-underscore `_iadd_` etc. methods. 

Before you start designing all kinds of fancy features, I think you first want to establish a need. I don't think there is one. By the time you need micro-optimizations such as using mutable structures and in-place modification, you don't want the overhead of coercion to occur.

Anyway, for a `v += w` the question really is: is there a coercion from `w.base_ring()` into `v.base_ring()` or for `v *= c` if there is an action of `c` on `v` and whether you can unwind that to a coefficient-wise operation (the action discovery currently available won't tell you).

In any case, these 2-argument mutation operations do not cover what is needed for efficient mutable object manipulation. There is the three-argument version too:
`for i in range(n): u[i] = v[i] + w[i]` where the target is not one of the operands. It would really defeat the purpose if you'd have to execute that as `u[:]=v; u+=w`.

(I have some recent experience with inplace mutation (with mpfr) in order to get a fast evaluation of Riemann theta functions -- ticket TBA :-). If these inplace features above would have existed, I would still not have used them, because I really needed the 3-operand versions and because I wouldn't want to pay the incref/decref price for manipulating python objects. Make sure you have a usage scenario before you design the tools!)



---

archive/issue_comments_455579.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">comment:31</div>\n\nReplying to [@nbruin](#comment%3A30):\n> for a `v += w` the question really is: is there a coercion from `w.base_ring()` into `v.base_ring()` or for `v *= c` if there is an action of `c` on `v` and whether you can unwind that to a coefficient-wise operation (the action discovery currently available won't tell you).\n\nThat's a great point, although for sparse updates of the kind (`large_sparse_vector += small_sparse_vector`) even with coercion kicking in on the route `__iadd__` -> `_iadd_` ( converting `small_sparse_vector` first), there could be a speedup over what we have now.\n\nIn any case, I wouldn't expect that anyone has immediate plans to work on the mutable-update business, so we can shelve this until a need arises.",
    "created_at": "2021-08-12T20:07:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/29101#issuecomment-455579",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:31" align="right">comment:31</div>

Replying to [@nbruin](#comment%3A30):
> for a `v += w` the question really is: is there a coercion from `w.base_ring()` into `v.base_ring()` or for `v *= c` if there is an action of `c` on `v` and whether you can unwind that to a coefficient-wise operation (the action discovery currently available won't tell you).

That's a great point, although for sparse updates of the kind (`large_sparse_vector += small_sparse_vector`) even with coercion kicking in on the route `__iadd__` -> `_iadd_` ( converting `small_sparse_vector` first), there could be a speedup over what we have now.

In any case, I wouldn't expect that anyone has immediate plans to work on the mutable-update business, so we can shelve this until a need arises.



---

archive/issue_events_396975.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396975"
}
```



---

archive/issue_events_396976.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396976"
}
```



---

archive/issue_events_396977.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T00:06:20Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396977"
}
```



---

archive/issue_events_396978.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T00:06:20Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396978"
}
```



---

archive/issue_events_396979.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T05:25:02Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396979"
}
```



---

archive/issue_events_396980.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T05:25:02Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/29101",
    "milestone_number": null,
    "milestone_title": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/29101#event-396980"
}
```
