# Issue 19082: iterator over pairs on diagonals a la Cantor pairing

Issue created by migration from Trac.

Original creator: dkrenn

Original creation time: 2015-09-30 12:06:08

CC:  behackl cheuberg ncohen

Add an iterator, which goes over pairs of (possible infinite) inputs along the diagonals like the [Cantor pairing function](https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function).

This is factored out from #19048.


---

Comment by dkrenn created at 2015-09-30 12:07:09

New commits:


---

Comment by dkrenn created at 2015-09-30 12:07:09

Changing status from new to needs_review.


---

Comment by ncohen created at 2015-09-30 12:09:16

`O_o`


---

Comment by ncohen created at 2015-09-30 12:10:45

Yeah, I also believed that it should be shorter.

Do you really need this Kantor enumeration, or perhaps you don't care for as long as the product of two infinite iterators works correctly?


---

Comment by ncohen created at 2015-09-30 12:20:42

If you don't care, I just gave it a try:


```
def product(A,B):
    B = iter(B)
    lb = []
    b_done = False
    for a in A:
        try:
            if not b_done:
                lb.append(B.next())
        except StopIteration:
            b_done = True
        for b in lb:
            yield (a,b)
```


Does the job.

Nathann


---

Comment by ncohen created at 2015-09-30 12:26:12

About your 5 copy/paste: if you want to link every function to all others, I think the best is to have an index of methods at the head of the module and add a link toward the module.

By the way, if you feel like reviewing some doc patch: #19061

Nathann


---

Comment by dkrenn created at 2015-09-30 12:38:49

Replying to [comment:4 ncohen]:
> Yeah, I also believed that it should be shorter.

:)

> Do you really need this Kantor enumeration, or perhaps you don't care for as long as the product of two infinite iterators works correctly?

I care (at least a bit)...so I would leave it as it is.


---

Comment by ncohen created at 2015-09-30 12:39:57

> I care (at least a bit)...so I would leave it as it is.

Could you say why? I do not see the point of having a complicated code in Sage if ten lines provide the feature.


---

Comment by dkrenn created at 2015-09-30 12:55:05

Replying to [comment:5 ncohen]:
> If you don't care, I just gave it a try:
> 
> {{{
> def product(A,B):
>     B = iter(B)
>     lb = []
>     b_done = False
>     for a in A:
>         try:
>             if not b_done:
>                 lb.append(B.next())
>         except StopIteration:
>             b_done = True
>         for b in lb:
>             yield (a,b)
> }}}

Your code does not give all pairs...


---

Comment by ncohen created at 2015-09-30 12:56:52

> Your code does not give all pairs...

Yeah, only works for infinite sets.


---

Comment by dkrenn created at 2015-09-30 12:59:51

Replying to [comment:5 ncohen]:
> If you don't care, I just gave it a try:
> 
> {{{
> def product(A,B):
>     B = iter(B)
>     lb = []
>     b_done = False
>     for a in A:
>         try:
>             if not b_done:
>                 lb.append(B.next())
>         except StopIteration:
>             b_done = True
>         for b in lb:
>             yield (a,b)
> }}}


```
sage: list(product(srange(2), ['a', 'b', 'c']))
[(0, 'a'), (1, 'a'), (1, 'b')]
```



---

Comment by ncohen created at 2015-09-30 13:04:46

Yeah true, it's really bad. Soooooo I need two lists. Wanted to avoid that.

The question remains, though: is there a reason to insist on Kantor ordering, or would any other order do the job?


---

Comment by dkrenn created at 2015-09-30 13:12:40

Replying to [comment:12 ncohen]:
> The question remains, though: is there a reason to insist on Kantor ordering, or would any other order do the job?

In #19048 it does not really (except from aesthetic aspects) matter (but it has to deal with the finite case as well and it would be nice if then all pairs would occur). But I use the same code in some other Sage projects as well (not public (yet)), where it matters: There I need an order my the sums of the indices, which is Cantor.
Thus having this tool in SageMath would be great.


---

Comment by ncohen created at 2015-09-30 13:15:10

Okay. Longer than the first attempt, though

```
def product(A,B):
    A = iter(A)
    B = iter(B)
    list_a = []
    list_b = []
    a_nonempty = b_nonempty = True
    while a_nonempty or b_nonempty:
        if a_nonempty:
            try:
                list_a.append(A.next())
            except StopIteration:
                a_nonempty = False
            else:
                for b in list_b:
                    yield (list_a[-1],b)
        if b_nonempty:
            try:
                list_b.append(B.next())
            except StopIteration:
                b_nonempty = False
            else:
                for a in list_a:
                    yield (a, list_b[-1])
```



---

Comment by ncohen created at 2015-09-30 13:15:37

ARgggg.. Fails too `>_<`


---

Comment by ncohen created at 2015-09-30 13:16:47

Oh no, false alarm. Seems ok.


---

Comment by cheuberg created at 2015-09-30 13:34:35

A few comments on Daniel's code:
1. Does not terminate if `A` is empty and `B` is infinite, thus I'd simply try to yield A[0], B[0] initially and then start `s` at `1`.
2. `try:` `except:` block in `iter_as_list` can be removed


---

Comment by git created at 2015-09-30 13:40:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-09-30 13:40:38

Replying to [comment:17 cheuberg]:
> A few comments on Daniel's code:
> 1. Does not terminate if `A` is empty and `B` is infinite, thus I'd simply try to yield A[0], B[0] initially and then start `s` at `1`.
> 2. `try:` `except:` block in `iter_as_list` can be removed

Both changed.


---

Comment by dkrenn created at 2015-09-30 13:43:20

Replying to [comment:6 ncohen]:
> About your 5 copy/paste: if you want to link every function to all others, I think the best is to have an index of methods at the head of the module and add a link toward the module.

I think having SEEALSO blocks with links pointing directly to related functions/classes is a very useful thing (There have been some discussions on sage-devel about this.); it makes it easy for the user to find functions without a long search (Finding the "correct" function is definitly a problem for Sage users have...)


---

Comment by cheuberg created at 2015-09-30 13:54:11

I have an alternative implementation (pushed as `u/cheuberg/product_cantor_pairing`):

```
    from itertools import count
    from sage.rings.infinity import infinity
    A = iter(A)
    B = iter(B)
    max_A = infinity
    max_B = infinity
    cache_A = []
    cache_B = []
    for s in count():
        if s <= max_A:
            try:
                cache_A.append(next(A))
            except StopIteration:
                max_A = s-1
        if s <= max_B:
            try:
                cache_B.append(next(B))
            except StopIteration:
                max_B = s-1
        if s > max_A + max_B or max_A < 0 or max_B < 0:
            return

        for i in range(max(0, s-max_B), min(s, max_A)+1):
            yield cache_A[i], cache_B[s-i]
```



---

Comment by ncohen created at 2015-09-30 13:54:26

> I think having SEEALSO blocks with links pointing directly to related functions/classes is a very useful thing (There have been some discussions on sage-devel about this.); it makes it easy for the user to find functions without a long search (Finding the "correct" function is definitly a problem for Sage users have...)

You got me wrong: I did not ask you to remove the seealso block. I proposed to have a

```
SEEALSO::

    For related functions, refer to the module's documentation
```

with a link of course.

Linking n functions to each other requires n*(n-1) different links. If a function is moved, if a function is added, that requires much more work. Additionally, it possible that somebody *adding* a function may forget to update the others, which will not happen if we have an index of function at the head of the module.

Nathann


---

Comment by ncohen created at 2015-09-30 13:57:45

> I have an alternative implementation (pushed as `u/cheuberg/product_cantor_pairing`):
+1 for the abscence of private class.

Nathann


---

Comment by cheuberg created at 2015-09-30 14:22:24

New commits:


---

Comment by dkrenn created at 2015-09-30 14:35:50

Replying to [comment:22 ncohen]:
> You got me wrong: I did not ask you to remove the seealso block. I proposed to have a
> {{{
> SEEALSO::
> 
>     For related functions, refer to the module's documentation
> }}}
> with a link of course.

I understood.

> Linking n functions to each other requires n*(n-1) different links. If a function is moved, if a function is added, that requires much more work. Additionally, it possible that somebody *adding* a function may forget to update the others, which will not happen if we have an index of function at the head of the module.

Having these links directly in the `SEEALSO` block of the function helps the user...and this ranks higher to me than what a developer has to add when moving something around (and of course there is `--warn-links` which alerts when something is not where it should be). When adding a new function it is fine that not all `SEEALSO` blocks contain it; maybe only the close related ones. In `sage.misc.mrange` there are just a few functions and all those should IMHO be linked. In larger files I would *not* link all in all, but only build "cliques" of very related functions (but this depends on the functions, of course).


---

Comment by dkrenn created at 2015-09-30 14:42:17

Alternative implementation looks good to be (and all tests pass).
----
New commits:


---

Comment by cheuberg created at 2015-09-30 14:47:30

Replying to [comment:27 dkrenn]:
> New commits:
> ||[fde8e6d](http://git.sagemath.org/sage.git/commit/?id=fde8e6d09f41645ec4faf9d071cf60c7b35ef9e3)||`minor changes to code: spacings, PEP8, remove comment`||

thanks.


---

Comment by vdelecroix created at 2015-10-01 00:32:23

What is the point of having it only for pairs? What if I want to iterate `ZZ x ZZ x ZZ`? Using  towers of iterators is definitely not a solution (hard to write/use and slow).


---

Comment by cheuberg created at 2015-10-02 07:14:53

Replying to [comment:29 vdelecroix]:
> What is the point of having it only for pairs? What if I want to iterate `ZZ x ZZ x ZZ`? Using  towers of iterators is definitely not a solution (hard to write/use and slow).

Short answer: iterating over pairs is what we need right now.

Iteration over the product of n iterators will, as far as I can see, always need some recursive algorithm. I do not know whether avoiding iterators internally would make that much of a difference with respect of speed; IMHO it will not make it more readable.

What about replacing `product_cantor_pairing(A, B)` by `product_cantor_pairing([A, B])` and implementing products of `>= 3` iterators by a recursive call to `product_cantor_pairing` (and flattening the results) for the time being?


---

Comment by vdelecroix created at 2015-10-02 11:49:04

Replying to [comment:30 cheuberg]:
> Replying to [comment:29 vdelecroix]:
> > What is the point of having it only for pairs? What if I want to iterate `ZZ x ZZ x ZZ`? Using  towers of iterators is definitely not a solution (hard to write/use and slow).
> 
> Short answer: iterating over pairs is what we need right now.

I perfectly understand.

> Iteration over the product of n iterators will, as far as I can see, always need some recursive algorithm. I do not know whether avoiding iterators internally would make that much of a difference with respect of speed; IMHO it will not make it more readable.

Nope. If you look at the code of `product` in Python there is no recursion involved. It 70 lines long, with a lot of spaces and written in pure C.

> What about replacing `product_cantor_pairing(A, B)` by `product_cantor_pairing([A, B])` and implementing products of `>= 3` iterators by a recursive call to `product_cantor_pairing` (and flattening the results) for the time being?
 
Is that the canonical order you want for a triple?


---

Comment by cheuberg created at 2015-10-02 12:49:37

Replying to [comment:31 vdelecroix]:
> Replying to [comment:30 cheuberg]:
> > Iteration over the product of n iterators will, as far as I can see, always need some recursive algorithm. I do not know whether avoiding iterators internally would make that much of a difference with respect of speed; IMHO it will not make it more readable.
> 
> Nope. If you look at the code of `product` in Python there is no recursion involved. It 70 lines long, with a lot of spaces and written in pure C.

for infinite iterators, I suppose that things get somewhat trickier.

> > What about replacing `product_cantor_pairing(A, B)` by `product_cantor_pairing([A, B])` and implementing products of `>= 3` iterators by a recursive call to `product_cantor_pairing` (and flattening the results) for the time being?
>  
> Is that the canonical order you want for a triple?

Well, I am not really eager for ordering triples anyway.

But I imagine that having 
`product_cantor_pairing([A, B, C])` returning the elements in the same order as
`product_cantor_pairing([product_cantor_pairing([A, B]), C])` (or the other way around, i.e., `product_cantor_pairing([A, product_cantor_pairing([B, C])])`) would make sense.


---

Comment by vdelecroix created at 2015-10-02 14:21:41

26 lines and no recursion.

Vincent
----
New commits:


---

Comment by git created at 2015-10-02 14:25:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2015-10-02 16:23:54

Perhaps consider using `sage.misc.lazy_list.lazy_list` as a cache? That should save you making explicit appends. You could even get slightly better memory use for cartesian powers (a common case) by sharing caches.


---

Comment by git created at 2015-10-02 17:30:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2015-10-02 17:34:53

Replying to [comment:33 vdelecroix]:
> 26 lines and no recursion.

thanks --- however, using `IntegerListsLex` amounts to a little cheating with respect to the length of this routine `;-)`.

I added three minor commits.

Any particular reason that you return lists instead of tuples?


---

Comment by vdelecroix created at 2015-10-02 18:14:15

Replying to [comment:39 cheuberg]:
> Replying to [comment:33 vdelecroix]:
> > 26 lines and no recursion.
> 
> thanks --- however, using `IntegerListsLex` amounts to a little cheating with respect to the length of this routine `;-)`.

Sure. But the moto is "not reinvent the wheel".

> Any particular reason that you return lists instead of tuples?

Good question. `itertools` used to output tuples. But sometimes you want to play with the result (like appending some more elements). For me it is fine either way.


Replying to [comment:36 nbruin]:
> Perhaps consider using `sage.misc.lazy_list.lazy_list` as a cache? That should save you making explicit appends. You could even get slightly better memory use for cartesian powers (a common case) by sharing caches.

Using lazy list you would also need to catch `IndexError` or so until we use the Cython API I would not go with it.

I will add a trivial commit for handling sharing of slices (very good idea!).

Vincent


---

Comment by cheuberg created at 2015-10-02 18:19:52

Replying to [comment:40 vdelecroix]:
> Replying to [comment:39 cheuberg]:
> > Any particular reason that you return lists instead of tuples?
> 
> Good question. `itertools` used to output tuples. But sometimes you want to play with the result (like appending some more elements). For me it is fine either way.

I'd actually prefer tuples, for consistency with `itertools` and the other methods in this module.


---

Comment by vdelecroix created at 2015-10-02 18:50:18

Hi Clemens,

I added a commit on top of yours for returning tuples and accepting a `repeat` argument (with the very same specification as for `itertools.product`).

Vincent
----
New commits:


---

Comment by cheuberg created at 2015-10-03 05:04:23

Changing status from needs_review to positive_review.


---

Comment by cheuberg created at 2015-10-03 05:04:23

Code is fine, doctests pass, documentation builds. Thanks.


---

Comment by vbraun created at 2015-10-12 22:52:53

Resolution: fixed
