# Issue 33048: Specifying category spoils coercion

Issue created by migration from https://trac.sagemath.org/ticket/33285

Original creator: @matszang

Original creation time: 2022-02-03 20:44:22

CC:  vdelecroix

Keywords: category, coercion


```
D = CombinatorialFreeModule(ZZ, [1,2])
D(0)
```

works fine, however

```
C = CombinatorialFreeModule(ZZ, [1,2], category=AlgebrasWithBasis(ZZ))
C(0)
```

gets into an infinite loop:

```
File "/opt/sagemath-9.0/local/lib/python3.7/site-packages/sage/categories/magmas.py", line 488, in one
return self(1)
File "sage/structure/parent.pyx", line 900, in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9218)
return mor._call_(x)
File "sage/categories/map.pyx", line 1694, in sage.categories.map.FormalCompositeMap._call_ (build/cythonized/sage/categories/map.c:11607)
x = f._call_(x)
File "sage/categories/morphism.pyx", line 549, in sage.categories.morphism.SetMorphism._call_ (build/cythonized/sage/categories/morphism.c:8489)
cpdef Element _call_(self, x):
File "sage/categories/morphism.pyx", line 568, in sage.categories.morphism.SetMorphism._call_ (build/cythonized/sage/categories/morphism.c:8439)
return self._function(x)
File "/opt/sagemath-9.0/local/lib/python3.7/site-packages/sage/categories/unital_algebras.py", line 70, in from_base_ring
return self.one()._lmul_(r)
File "sage/misc/cachefunc.pyx", line 2310, in sage.misc.cachefunc.CachedMethodCallerNoArgs.__call__ (build/cythonized/sage/misc/cachefunc.c:12712)
self.cache = f(self._instance)
```


As pointed out on sage-devel, [https://groups.google.com/g/sage-devel/c/lF2Ot3rgYi0](https://groups.google.com/g/sage-devel/c/lF2Ot3rgYi0)
"The infinite loop comes from C.one() calling C(1)
calling C.one()... When you specify a category
the inheritance is different and this explains
the difference of behaviour."


---

Comment by vdelecroix created at 2022-02-03 21:17:38

More precisely: `C(0)` tries to use a generic conversion from the base ring. In the case of unital algebras this goes via the method `from_base_ring(self, r)` of `Magmas.Unital.ParentMethods`. But this function involves a call to `self.one()`. In the case the base ring element `r` is zero.


---

Comment by vdelecroix created at 2022-02-03 21:18:22

I am not convinced this is super useful but it should not have any bad consequence.
----
New commits:


---

Comment by vdelecroix created at 2022-02-03 21:18:35

Changing status from new to needs_review.


---

Comment by tscrim created at 2022-02-04 00:14:46

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2022-02-04 00:14:46

This is not correct because then the method is returning a wrong result. In fact, there is fundamentally no way to do this at the category level. It is up to the individual classes to handle creating their zero element as they are the only ones who know how to do it.

This is an example of creating a partially defined object, so you should expect some bad behavior. In particular, for it to be an algebra, it needs to have an identity, and hence a canonical embedding of the base ring. In short, this _should_ fail because it does not know what the identity is.

I propose we close this ticket.


---

Comment by vdelecroix created at 2022-02-04 07:24:28

Thanks Travis for having a look.

Replying to [comment:4 tscrim]:
> This is not correct because then the method is returning a wrong result.

Which method are you talking about ? What is wrong about it ?

> In fact, there is fundamentally no way to do this at the category level. It is up to the individual classes to handle creating their zero element as they are the only ones who know how to do it.

Sure and `CombinatorialFreeModule` knows how to do it via `C.zero()`. The branch just bypasses the multiplication `(zero in base ring) x (one in the algebra)`. I do not understand what is wrong about it.

> This is an example of creating a partially defined object, so you should expect some bad behavior.

Agreed. But you could also expect the object `C` to be partially working. In that particular example, we could hope for its module structure to survive. Especially calling `C(0)`.

> In particular, for it to be an algebra, it needs to have an identity, and hence a canonical embedding of the base ring. In short, this _should_ fail because it does not know what the identity is.

The canonical embedding of zero does not need the unit, hence my fix.

> I propose we close this ticket.

Sure but with a won't fix or my branch :) ?


---

Comment by vdelecroix created at 2022-02-04 07:27:31

Of course, it might be the case that `not r` is an expensive test. In that case, I agree that my proposition is not a reasonable idea.


---

Comment by tscrim created at 2022-02-04 07:41:28

Replying to [comment:5 vdelecroix]:
> Thanks Travis for having a look.

Thank you for your comments.

> Replying to [comment:4 tscrim]:
> > This is not correct because then the method is returning a wrong result.
> 
> Which method are you talking about ? What is wrong about it ?

There is only one method you modify in your branch `from_base_ring()`. However, I misread the code and thought it just returned `0` whenever it couldn't do the computation.

> > In fact, there is fundamentally no way to do this at the category level. It is up to the individual classes to handle creating their zero element as they are the only ones who know how to do it.
> 
> Sure and `CombinatorialFreeModule` knows how to do it via `C.zero()`. The branch just bypasses the multiplication `(zero in base ring) x (one in the algebra)`. I do not understand what is wrong about it.

Right. it only works because `CFM` has defined `zero()` through a specific implementation. There is a generic implementation that calls `self(0)`, which will run into the same problem now with a different infinite loop.

> > This is an example of creating a partially defined object, so you should expect some bad behavior.
> 
> Agreed. But you could also expect the object `C` to be partially working. In that particular example, we could hope for its module structure to survive. Especially calling `C(0)`.

I think it is bad form to make something work because someone is working with malformed input. This is in the category of algebras, so it should rightfully assume that it has `1` specified.

> > In particular, for it to be an algebra, it needs to have an identity, and hence a canonical embedding of the base ring. In short, this _should_ fail because it does not know what the identity is.
> 
> The canonical embedding of zero does not need the unit, hence my fix.

As I mentioned above, generically speaking, yes it does.

> > I propose we close this ticket.
> 
> Sure but with a won't fix or my branch :) ?

won't fix.

This could be useful as an optimization as the only (generally) expensive `== 0` test is for `SR`. However, I think this runs into an infinite loop for an algebra that only defines `1` and uses the default implementation of `0`. So the generic `AdditiveMagmas.zero()` method would need some modification to avoid coercion. If we did go this route, then the doctest needs to be changed.


---

Comment by vdelecroix created at 2022-02-04 07:50:00

Replying to [comment:7 tscrim]:
> Replying to [comment:5 vdelecroix]:
> This could be useful as an optimization as the only (generally) expensive `== 0` test is for `SR`.

Is it? In a complicated quotient ring `Zmod(2^16)[x, y, z] / I` or `Multizetas()` couldn't it be costly as well?

> However, I think this runs into an infinite loop for an algebra that only defines `1` and uses the default implementation of `0`. So the generic `AdditiveMagmas.zero()` method would need some modification to avoid coercion. If we did go this route, then the doctest needs to be changed.

Indeed, an algebra could also assume that it does not need `zero()` to be implemented since it can be recovered with `(zero in the base ring) x (one in the algebra)`.

This last comment make me think that even though it looked innocent, my branch might create some other problem. `wontfix` looks like a reasonable option.


---

Comment by vdelecroix created at 2022-02-04 07:50:00

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2022-02-04 07:55:18

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-02-04 07:55:18

Replying to [comment:8 vdelecroix]:
> Replying to [comment:7 tscrim]:
> > Replying to [comment:5 vdelecroix]:
> > This could be useful as an optimization as the only (generally) expensive `== 0` test is for `SR`.
> 
> Is it? In a complicated quotient ring `Zmod(2^16)[x, y, z] / I` or `Multizetas()` couldn't it be costly as well?

Fair enough. For the quotient, I think it always reduces elements, so checking 0 is quick. I might be mistaken there. However, I agree for `Multizetas()` or maybe in the group algebra of a (confluent) finitely presented group.

> > However, I think this runs into an infinite loop for an algebra that only defines `1` and uses the default implementation of `0`. So the generic `AdditiveMagmas.zero()` method would need some modification to avoid coercion. If we did go this route, then the doctest needs to be changed.
> 
> Indeed, an algebra could also assume that it does not need `zero()` to be implemented since it can be recovered with `(zero in the base ring) x (one in the algebra)`.
> 
> This last comment make me think that even though it looked innocent, my branch might create some other problem. `wontfix` looks like a reasonable option.

While I don't think we have any cases of this (since most roads for algebras lead through `CFM`), it might break something in the wild.

Thank you (both) for looking at this.


---

Comment by mkoeppe created at 2022-02-12 18:02:50

Resolution: invalid
