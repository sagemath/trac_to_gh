# Issue 20665: Move Parent.list() method to Sets category

Issue created by migration from Trac.

Original creator: klee

Original creation time: 2016-06-29 01:50:18

CC:  jsrn nbruin vbraun jdemeyer tscrim nthiery

The methods `__len__`, `list`, `_list_from_iterator_cashed` in the Parent class conflict with those of the `FiniteEnumerableSets` category.  One symptom is #20743. Arguably the proper place for them is the `EnumeratedSets` category (#12955). However many enumerable parents in Sage are not in that category, but nonetheless they are in Sets category. So, as a practical compromise, the three methods are moved  to the Sets category.


---

Comment by git created at 2016-06-29 01:59:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2016-06-29 02:42:23

Changing status from new to needs_review.


---

Comment by klee created at 2016-06-29 02:45:06

The patch introduces a doctest failure, which is not caused by the patch, but just revealed by it. The doctest failure is the issue treated in #20896.


---

Comment by jsrn created at 2016-07-13 02:28:54

I have some issues with this:

* You are arguing that these functions **should** be in `EnumeratedSets`, but you move them to `Sets`. Why not move them to `EnumeratedSets` and start adding parents to that category? At least, you should keep the TODO that this would be best?

* The `list` function now returns a copy of the (cached) list every time. We had a long discussion on sage-devel as well as on #20743 about this, and though complete consensus didn't arise, everyone seemed to think that `list` should **not** return a fresh copy every time. Rather we should somehow flag the list as being immutable.

Apart from that it makes sense to move those functions from `Parent`.

(I added a few of the debators on #20743 to Cc, hope you're all ok with that).


---

Comment by klee created at 2016-07-13 05:34:17

First let me thank you for raising these issues, which are legitimate.

> * You are arguing that these functions **should** be in `EnumeratedSets`, but you move them to `Sets`. Why not move them to `EnumeratedSets` and start adding parents to that category? At least, you should keep the TODO that this would be best?

Many parents in Sage do have `list` method, but are not declared as in enumerable set category. Some of them seems that their enumerability is determined only at runtime, so cannot be declared so in its defining class. For example, a free module over a ring can be either enumerable or not depending on the ring. So keeping the "list" method only in `EnumeratedSets` category is not the way to support `list` method for existing parents. For the reason, I doubt that the TODO is really what we have to do. Yes, I am arguing against myself, but the **should** is for a perfect world.

> * The `list` function now returns a copy of the (cached) list every time. We had a long discussion on sage-devel as well as on #20743 about this, and though complete consensus didn't arise, everyone seemed to think that `list` should **not** return a fresh copy every time. Rather we should somehow flag the list as being immutable.

I am aware of the discussion. I was one of the proponents that `list` method should return a cashed tuple rather than a list. But searching through Sage library, I find that (1) `list` method is inconsistently implemented for many parents in Sage; (2) The implementation of `list` method for finite sets category returns a fresh copy of a cached list each time  (the same is true for `list` method of the current `Parent` class). My conclusion is that the behavior of the `list` method of the parents in the finite sets category is the de facto standard in Sage. So I copied the "standard" implementation to `Sets` category. 

In the present ticket, I am not taking any position  about how the `list` method should be implemented, but just move around what is already in Sage. If we all agree on a proper implementation of the `list` methods of parents in the category framework, that should be another ticket.  Let me just say that for this issue, my present opinion is that the current implementation is reasonable in the category framework, and if a specific parent needs better performance, it can just implement its own `list` method.


---

Comment by klee created at 2016-07-13 07:37:38

Changing status from needs_review to needs_work.


---

Comment by klee created at 2016-07-13 07:37:38

Hmm. Now I suspect that I am wrong in the first answer. The category is determined at the parent creation time and need not be hardcoded into the class. Then a free module over a ring can declare itself as either enumerable or not at its creation time. Then the fact that it does not do that in the current Sage is simply a bug.  So at least free modules are not a good example for my argument.


---

Comment by jsrn created at 2016-07-14 13:09:17

OK, your arguments are compelling. I agree that making the move is orthogonal to changing the implementation of `list`.

Since it is possible to dynamically be a member of `EnumerableSets` or not, how hard would it be to move the functions into there immediately? It seems a bit wasteful to first make the move of this ticket, and then move them again. In `sets_cat.py` there's also a note on line 1368 that `cardinality` and other functions are intentionally left out of `Sets` to be put in subcategories. It seems a shame to put other functions into `Set` which actually belong elsewhere.

About the default implementation of `__len__()`: perhaps it could check whether `self` has a `cardinality` method, in which case it could return that.


---

Comment by klee created at 2016-07-14 13:43:46

> Since it is possible to dynamically be a member of `EnumerableSets` or not, how hard would it be to move the functions into there immediately? It seems a bit wasteful to first make the move of this ticket, and then move them again. 

I thought before that it is a daunting task, if at all possible, to put every enumerable parent  into `EnumerableSets` category. Now I feel that the task can at least be done to such an extent as to avoid doctest failures.

>In `sets_cat.py` there's also a note on line 1368 that `cardinality` and other functions are intentionally left out of `Sets` to be put in subcategories. It seems a shame to put other functions into `Set` which actually belong elsewhere.

I agree.
> About the default implementation of `__len__()`: perhaps it could check whether `self` has a `cardinality` method, in which case it could return that.

I will consider that while moving the methods again into `EnumerableSets` category. For that, now the ticket is in "needs work" status :-)


---

Comment by jsrn created at 2016-07-14 14:22:41

Sounds great. I'm glad you opened this ticket: I think one of the very confusing things about Sage is that many objects have generic methods that don't do anything sensible on them, exactly because some methods are not placed on the right category/parent object.


---

Comment by git created at 2016-09-04 13:14:37

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2016-09-04 19:13:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-09-05 06:20:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-09-05 09:46:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2016-09-07 05:50:40

In the patch, some old parents are modified to avoid doctest failures, but moving parents into enumerated sets cateogy is not attempted.


---

Comment by klee created at 2016-09-07 05:50:40

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-09-08 01:43:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-09-08 14:45:48

I don't understand why you removed `_test_enumerated_set_iter_cardinality`. This is a good check that any code cannot render invalid/redundant.

The change to Jordan algebras is incorrect. You should just let the `TypeError` (or whatever the error is from `tuple(self.algebra_generators())`) propagate up. Also, you should avoid having a bare `except:` statement.


---

Comment by klee created at 2016-09-08 15:30:52

Replying to [comment:19 tscrim]:
> I don't understand why you removed `_test_enumerated_set_iter_cardinality`. This is a good check that any code cannot render invalid/redundant.

It tests the method `_cardinality_from_iterator`, which is removed in the current patch. Now `.cardinality()` method is implemented instead just using `self.list()` inherited from the enumerated sets category, which itself uses the iterator of self.

So it seemed to me that the `_test_enumerated_set_iter_cardinality` lost its point with the current patch. Even the example ("let us now break...") under the test does not work. Would you try that?

But I may have missed the point of the test as intended by the original author. Then would you elaborate on that? 

> 
> The change to Jordan algebras is incorrect. You should just let the `TypeError` (or whatever the error is from `tuple(self.algebra_generators())`) propagate up. 

With the current patch, the original code `tuple(self.algebra_generators())` falls into an infinite loop in the case that `self.algebra_generators()` is an infinite set. The change is to avoid this. I don't know a better way to deal with this... 

> Also, you should avoid having a bare `except:` statement.

I see. I will correct that.


---

Comment by klee created at 2016-09-08 15:45:08

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2016-09-08 16:12:31

Replying to [comment:20 klee]:
> Replying to [comment:19 tscrim]:
> > I don't understand why you removed `_test_enumerated_set_iter_cardinality`. This is a good check that any code cannot render invalid/redundant.
> 
> It tests the method `_cardinality_from_iterator`, which is removed in the current patch. Now `.cardinality()` method is implemented instead just using `self.list()` inherited from the enumerated sets category, which itself uses the iterator of self.
> 
> So it seemed to me that the `_test_enumerated_set_iter_cardinality` lost its point with the current patch. Even the example ("let us now break...") under the test does not work. Would you try that?
> 
> But I may have missed the point of the test as intended by the original author. Then would you elaborate on that? 

It is there to test that (`X.list()` or) `list(X) == X.cardinality()`, which could break anytime a user directly implements `cardinality` (such as on the powerset of a finite set).

> > 
> > The change to Jordan algebras is incorrect. You should just let the `TypeError` (or whatever the error is from `tuple(self.algebra_generators())`) propagate up. 
> 
> With the current patch, the original code `tuple(self.algebra_generators())` falls into an infinite loop in the case that `self.algebra_generators()` is an infinite set. The change is to avoid this. I don't know a better way to deal with this... 

Previously, if we were calling `tuple(X)` when `X` was known to be infinite, then this would fail with IIRC a `NotImplementedError` (try `tuple(ZZ)`). In the example, `self.algebra_generators` is known to be infinite:

```
sage: J = JordanAlgebra(FreeAlgebra(QQ, 3, 'x,y,z'))
sage: J.algebra_generators().cardinality()
+Infinity
```

So the error is correct (although the reason was not because the family should know it is in the  infinite enumerated sets category). Thus I would propose fixing the category issue of `LazyFamily` when the keys are known to be infinite.

Also, I am slightly of the opinion that changing this behavior of enumerated sets with unknown cardinality is a regression. I believe that if the user knows the set is finite, they can do an explicit iteration over the object and we should force them to do that as a safeguard against the infinite loops.


---

Comment by nthiery created at 2016-09-08 16:36:24

Hi Kwankyu!

Thanks for your much needed work on cleaning the generic code for
enumerated sets. This code is tricky as it aims to cover many
different use cases, trying to do "just the right thing" in most of
them. It has grown from years of practice and this is all more artwork
than science ...

Replying to [comment:20 klee]:
> Replying to [comment:19 tscrim]:
> > I don't understand why you removed `_test_enumerated_set_iter_cardinality`. This is a good check that any code cannot render invalid/redundant.
> It tests the method `_cardinality_from_iterator`, which is removed in the current patch. Now `.cardinality()` method is implemented instead just using `self.list()` inherited from the enumerated sets category, which itself uses the iterator of self.

-1 on removing `_cardinality_from_iterator`. This methods
intentionally supports computing the cardinality of very large sets,
without paying the memory overhead of storing all the elements. It has
already been used for sets that just would not fit in memory.

-1 on removing `_test_enumerated_set_iter_cardinality`: it does not
only test `_cardinality_from_iterator`, but also all cases where both
`__iter__` and `cardinality` are implemented by an enumerated set.

Cheers,
                            Nicolas


---

Comment by klee created at 2016-09-08 19:57:16

Replying to [comment:23 nthiery]: 
> -1 on removing `_cardinality_from_iterator`. This methods
> intentionally supports computing the cardinality of very large sets,
> without paying the memory overhead of storing all the elements. It has
> already been used for sets that just would not fit in memory.

Good point. I missed this. 

> -1 on removing `_test_enumerated_set_iter_cardinality`: it does not
> only test `_cardinality_from_iterator`, but also all cases where both
> `__iter__` and `cardinality` are implemented by an enumerated set.

I agree.

I will recover these and also try to incorporate tscrim's criticisms. 

As you will understand, it is quite tricky to accomplish this ticket's task while not failing parents relying on the existing structure...


---

Comment by nthiery created at 2016-09-09 06:41:29

Replying to [comment:24 klee]:
> As you will understand, it is quite tricky to accomplish this ticket's task while not failing parents relying on the existing structure... 

You bet; that's why I am particularly grateful someone is taking up
the job!


---

Comment by git created at 2016-09-10 19:02:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2016-09-11 01:54:45

In the last commits, I tried to make the footprints of the patch as light as possible while accomplishing the task at hand.


---

Comment by klee created at 2016-09-11 01:54:45

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-09-11 22:39:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-09-12 16:54:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-09-12 22:57:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2016-10-25 09:24:39

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-10-25 14:30:17

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by klee created at 2016-10-25 21:20:27

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-11-03 08:57:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-11-03 13:47:30

From a quick look at things, I don't like all of the ``@`cached_method`'s on `__len__` because `cardinality` should be quick to compute or `list` is (generically) cached (and very fast to get the length of).

You should use ```self``` since it is essentially code.

This part of comment:22 is still true:
> Also, I am slightly of the opinion that changing this behavior of enumerated sets with unknown cardinality is a regression. I believe that if the user knows the set is finite, they can do an explicit iteration over the object and we should force them to do that as a safeguard against the infinite loops. 

Thinking about it a bit more, I am more convinced that this is a definite regression because it can cause infinite loops in cases that it previously did not.


---

Comment by git created at 2016-11-03 14:49:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2016-11-03 15:02:13

Replying to [comment:35 tscrim]:
> This part of comment:22 is still true:
> > Also, I am slightly of the opinion that changing this behavior of enumerated sets with unknown cardinality is a regression. I believe that if the user knows the set is finite, they can do an explicit iteration over the object and we should force them to do that as a safeguard against the infinite loops. 
> 
> Thinking about it a bit more, I am more convinced that this is a definite regression because it can cause infinite loops in cases that it previously did not.

I don't really understand exactly what change you mean. Would you help me by pinpointing the method where the change was introduced? And a concrete example will also help.. Perhaps I forgot something that I myself have done.


---

Comment by klee created at 2016-11-03 15:28:04

Replying to [comment:35 tscrim]:
> Thinking about it a bit more, I am more convinced that this is a definite regression because it can cause infinite loops in cases that it previously did not

I now see that you meant catching `TypeError` in the list method of enumerated sets.


---

Comment by git created at 2016-11-03 22:44:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2016-11-03 22:49:42

Changing status from needs_review to needs_work.


---

Comment by klee created at 2016-11-03 22:49:42

I made changes reflecting Travis' comments, perhaps except the last one.


---

Comment by tscrim created at 2016-11-04 14:22:15

The problem I have is if a set `X` has unknown cardinality, then previously, if you call `len(X)`, it would error out to prevent you from entering into an infinite loop. If I understand the current code, it will not do that, and instead try to compute the length (which generically would try `X.list()`) and run into that infinite loop if `X` was indeed infinite.

Before:

```sage
sage: R = RecursivelyEnumeratedSet([1], lambda a: [a+1])
sage: R.category()
Category of enumerated sets
sage: R.list()
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
...
NotImplementedError: unknown cardinality
```

With the branch:

```sage
sage: R = RecursivelyEnumeratedSet([1], lambda a: [a+1])
sage: R.list()  # Still waiting...
```

Actually, `__len__` is defined in `RecursivelyEnumeratedSet` to return `None`, but the same issue would occur if it was not.


---

Comment by klee created at 2016-11-04 15:45:15

Replying to [comment:41 tscrim]:
> The problem I have is if a set `X` has unknown cardinality, then previously, if you call `len(X)`, it would error out to prevent you from entering into an infinite loop. If I understand the current code, it will not do that, and instead try to compute the length (which generically would try `X.list()`) and run into that infinite loop if `X` was indeed infinite.

The current code for `list` method and `len` method for enumerated sets depend on `cardinality`. If cardinality is not defined, it just tries to list all elements (as the doc says). So it falls into an infinite loop when the set is actually infinite, as you said and shown by your example. An easy solution  would be to list elements only when the cardinality is known to be finite. I am now experimenting with the solution to see if it breaks other parts of Sage...


---

Comment by git created at 2016-11-04 17:35:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2016-11-04 17:36:19

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2016-11-04 18:10:29

Some little things:
- `cashed` -> `cached`
- Add back in the descriptive error message of "unknown cardinality"
- This needs to be changed:
  {{{#!diff
-If ``x`` is known to be infinite, then an exception is raised.
+If ``x`` is not known to be finite, then an exception is raised.
  }}}
- I don't see the point of `__len__` in `subword_complex.py`. If it is necessary, then it does not need to be cached and the `EXAMPLES::` needs a blankline after it.
- Same for `abelian_group.py`.
- Same for `libgap_mixin.py`.
- For `fgp_module.py`, the `EXAMPLES::` block and you should use ```self``` (although isn't this just `_list_from_iterator`?).
- In `homset.py`, use ```self```.
- Same for `parent.pyx`.


---

Comment by git created at 2016-11-04 18:48:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2016-11-04 18:49:57

Replying to [comment:45 tscrim]:
> Some little things:
> - `cashed` -> `cached`

Done.

> - Add back in the descriptive error message of "unknown cardinality"

Isn't this already there? Or do you mean somewhere else?

> - This needs to be changed:
>   {{{#!diff
> -If ``x`` is known to be infinite, then an exception is raised.
> +If ``x`` is not known to be finite, then an exception is raised.
>   }}}

Done.

> - I don't see the point of `__len__` in `subword_complex.py`.

This would not be necessary if `subword_complex` are in enumerated sets category (the same for below), but this ticket is not to put parents into proper category. This and removing unnecesary `__len__` would be tasks of one who knows `subword_complex` well. 

> - If it is necessary, then it does not need to be cached and the `EXAMPLES::` needs a blankline after it.
> - Same for `abelian_group.py`.
> - Same for `libgap_mixin.py`.
> - For `fgp_module.py`, the `EXAMPLES::` block and you should use ```self``` (although isn't this just `_list_from_iterator`?).
> - In `homset.py`, use ```self```.
> - Same for `parent.pyx`.

Done.
----
New commits:


---

Comment by tscrim created at 2016-11-05 17:23:42

Replying to [comment:47 klee]:
> Replying to [comment:45 tscrim]:
> > - Add back in the descriptive error message of "unknown cardinality"
> 
> Isn't this already there? Or do you mean somewhere else?

Sorry, I had misread this diff:

```diff
+                sage: R.<t,p> = QQ[]
+                sage: Q = R.quotient(t^2-t+1)
+                sage: Q.is_finite()
                 Traceback (most recent call last):
                 ...
-                NotImplementedError: unknown cardinality
+                NotImplementedError
```


> > - I don't see the point of `__len__` in `subword_complex.py`.
> 
> This would not be necessary if `subword_complex` are in enumerated sets category (the same for below), but this ticket is not to put parents into proper category. This and removing unnecesary `__len__` would be tasks of one who knows `subword_complex` well. 

The issue is that `SubwordComplex` is a `SimplicialComplex`, and while the latter is not an enumerated set, the former considers itself to be. However, `SimplicialComplex` does not take a category as input. So I added this and put `SubwordComplex` in the enumerated finite simplicial complexes category.

I also pushed some other improvements to the abelian groups and the libgap mixin groups. Although infinite abelian groups do not iterate properly, but that is a bug for another ticket.
----
New commits:


---

Comment by klee created at 2016-11-05 19:11:25

Replying to [comment:48 tscrim]:
> The issue is that `SubwordComplex` is a `SimplicialComplex`, and while the latter is not an enumerated set, the former considers itself to be. However, `SimplicialComplex` does not take a category as input. So I added this and put `SubwordComplex` in the enumerated finite simplicial complexes category.
> 
> I also pushed some other improvements to the abelian groups and the libgap mixin groups. Although infinite abelian groups do not iterate properly, but that is a bug for another ticket.

The patch looks good to me. Thank you.


---

Comment by tscrim created at 2016-11-06 02:58:43

Is that a positive review?


---

Comment by klee created at 2016-11-06 07:08:08

Replying to [comment:50 tscrim]:
> Is that a positive review?

Yes, to your portion of the code.


---

Comment by git created at 2016-11-06 14:42:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-11-06 14:43:05

Everything else looks good. I just did some trivial fixes from the patchbot report, so I'm allowing myself to set a positive review.


---

Comment by tscrim created at 2016-11-06 14:43:05

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-11-07 18:27:15

Resolution: fixed
