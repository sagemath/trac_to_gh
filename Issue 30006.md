# Issue 30006: fully-commutatve-elements

archive/issues_030006.json:
```json
{
    "body": "CC:  gfeinberg tscrim combinat\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/30243\n\n",
    "created_at": "2020-07-28T20:12:43Z",
    "labels": [
        "PLEASE CHANGE",
        "major",
        "PLEASE CHANGE"
    ],
    "title": "fully-commutatve-elements",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/30006",
    "user": "@cemulate"
}
```
CC:  gfeinberg tscrim combinat



Issue created by migration from https://trac.sagemath.org/ticket/30243





---

archive/issue_comments_426476.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2020-07-28T21:33:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426476",
    "user": "@cemulate"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_426477.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to combinatorics.",
    "created_at": "2020-07-28T21:33:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426477",
    "user": "@cemulate"
}
```

Changing component from PLEASE CHANGE to combinatorics.



---

archive/issue_comments_426478.json:
```json
{
    "body": "Changing priority from major to minor.",
    "created_at": "2020-07-28T21:33:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426478",
    "user": "@cemulate"
}
```

Changing priority from major to minor.



---

archive/issue_comments_426479.json:
```json
{
    "body": "Changing keywords from \"\" to \"fully commutative, coxeter, CoxeterGroup\".",
    "created_at": "2020-07-28T21:33:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426479",
    "user": "@cemulate"
}
```

Changing keywords from "" to "fully commutative, coxeter, CoxeterGroup".



---

archive/issue_comments_426480.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-28T21:34:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426480",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426481.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-07-28T21:37:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426481",
    "user": "@cemulate"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_426482.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-28T21:42:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426482",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426483.json:
```json
{
    "body": "Changing keywords from \"fully commutative, coxeter, CoxeterGroup\" to \"Coxeter systems, Coxeter groups, fully commutative elements\".",
    "created_at": "2020-07-28T22:40:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426483",
    "user": "@TianyuanX"
}
```

Changing keywords from "fully commutative, coxeter, CoxeterGroup" to "Coxeter systems, Coxeter groups, fully commutative elements".



---

archive/issue_comments_426484.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-29T11:29:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426484",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426485.json:
```json
{
    "body": "Attachment [FullyCommutativeElements.pdf](tarball://root/attachments/some-uuid/ticket30243/FullyCommutativeElements.pdf) by @cemulate created at 2020-07-29 11:59:24\n\nBuilt documentation page",
    "created_at": "2020-07-29T11:59:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426485",
    "user": "@cemulate"
}
```

Attachment [FullyCommutativeElements.pdf](tarball://root/attachments/some-uuid/ticket30243/FullyCommutativeElements.pdf) by @cemulate created at 2020-07-29 11:59:24

Built documentation page



---

archive/issue_comments_426486.json:
```json
{
    "body": "The test for an element of a Coxeter group to be fully commutative should also be available for the elements of a Coxeter group (probably in the category of `CoxeterGroups`).\n\n`FullyCommutativeElements` should also be a `UniqueRepresentation`. So you will also need to implement\n\n```python\n@staticmethod\n    def __classcall_private__(cls, data):\n        if isinstance(data, CoxeterMatrix):\n            matrix = data\n        else:\n            try:\n                t = CartanType(data)\n            except (TypeError, ValueError):\n                raise ValueError('input must be a CoxeterMatrix or data describing a Cartan/Coxeter type')\n            matrix = t.coxeter_matrix()\n        return super(cls, FullyCommutativeElements).__classcall__(cls, matrix)\n\n    def __init__(self, matrix):\n        self._matrix = matrix\n        # Rest of the initialization\n```\n\nI would also avoid the big `try-except` block in the `__init__` to handle more cases more explicitly. (This will make it easier to maintain the code later on.) I think you should also see if the data can be passed to a `CoxeterType`, possibly first before `CartanType`.",
    "created_at": "2020-07-30T01:07:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426486",
    "user": "tscrim"
}
```

The test for an element of a Coxeter group to be fully commutative should also be available for the elements of a Coxeter group (probably in the category of `CoxeterGroups`).

`FullyCommutativeElements` should also be a `UniqueRepresentation`. So you will also need to implement

```python
@staticmethod
    def __classcall_private__(cls, data):
        if isinstance(data, CoxeterMatrix):
            matrix = data
        else:
            try:
                t = CartanType(data)
            except (TypeError, ValueError):
                raise ValueError('input must be a CoxeterMatrix or data describing a Cartan/Coxeter type')
            matrix = t.coxeter_matrix()
        return super(cls, FullyCommutativeElements).__classcall__(cls, matrix)

    def __init__(self, matrix):
        self._matrix = matrix
        # Rest of the initialization
```

I would also avoid the big `try-except` block in the `__init__` to handle more cases more explicitly. (This will make it easier to maintain the code later on.) I think you should also see if the data can be passed to a `CoxeterType`, possibly first before `CartanType`.



---

archive/issue_comments_426487.json:
```json
{
    "body": "Actually, rather than the Coxeter matrix, it should have the Coxeter group as the input. That way it can immediately output the actual group elements (which can depend on your group's implementation) rather than converting from the reduced words. It just saves a little bit of time for the user, and I think that is more natural anyways.\n\nFinally, I would add a hook in the category of Coxeter groups of\n\n```python\ndef fully_commutative_elements(self):\n    from sage.combinat.fully_commutative_elements import FullyCommutativeElements\n    return FullyCommutativeElements(self)\n```\n\nThat way it is easy to access and more natural than having something in the global namespace (which I might even say should be removed).",
    "created_at": "2020-07-30T01:09:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426487",
    "user": "tscrim"
}
```

Actually, rather than the Coxeter matrix, it should have the Coxeter group as the input. That way it can immediately output the actual group elements (which can depend on your group's implementation) rather than converting from the reduced words. It just saves a little bit of time for the user, and I think that is more natural anyways.

Finally, I would add a hook in the category of Coxeter groups of

```python
def fully_commutative_elements(self):
    from sage.combinat.fully_commutative_elements import FullyCommutativeElements
    return FullyCommutativeElements(self)
```

That way it is easy to access and more natural than having something in the global namespace (which I might even say should be removed).



---

archive/issue_comments_426488.json:
```json
{
    "body": "I like the idea of exposing everything as `CoxeterGroup.fully_commutative_elements()`. And implementing UniqueRepresentation should be fine as well. I'll get this done shortly.\n\nThe reason we differentiated the element class from the elements of a `CoxeterGroup` in the first place is that we're treating all of our operations and manipulations on elements as pure combinatorics on reduced words; depending on the implementation, calling `.(from_)reduced_word()` all the time can be quite expensive. Furthermore, we *replace* methods on `CoxeterGroup` elements such as `has_descent` and co. to provide specialized criterion that work on fully commutative reduced words, and add various other methods as well. This is why we ended up inventing a lightweight element class that simply represents \"a canonical reduced word of a fully commutative element\". \n\nI agree it might be nice to be able to go seamlessly to an element of the ambient `CoxeterGroup` (if we're going to initialize with a `CoxeterGroup` as the \"core data\" instead of a matrix, which I like), but perhaps we could just have something like `.element()` that forgets the full commutivity and gives you a regular element of the `CoxeterGroup`?",
    "created_at": "2020-07-30T11:14:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426488",
    "user": "@cemulate"
}
```

I like the idea of exposing everything as `CoxeterGroup.fully_commutative_elements()`. And implementing UniqueRepresentation should be fine as well. I'll get this done shortly.

The reason we differentiated the element class from the elements of a `CoxeterGroup` in the first place is that we're treating all of our operations and manipulations on elements as pure combinatorics on reduced words; depending on the implementation, calling `.(from_)reduced_word()` all the time can be quite expensive. Furthermore, we *replace* methods on `CoxeterGroup` elements such as `has_descent` and co. to provide specialized criterion that work on fully commutative reduced words, and add various other methods as well. This is why we ended up inventing a lightweight element class that simply represents "a canonical reduced word of a fully commutative element". 

I agree it might be nice to be able to go seamlessly to an element of the ambient `CoxeterGroup` (if we're going to initialize with a `CoxeterGroup` as the "core data" instead of a matrix, which I like), but perhaps we could just have something like `.element()` that forgets the full commutivity and gives you a regular element of the `CoxeterGroup`?



---

archive/issue_comments_426489.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-30T20:45:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426489",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426490.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-30T20:50:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426490",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426491.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-30T21:54:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426491",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426492.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-30T21:57:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426492",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426493.json:
```json
{
    "body": "Alright, we've taken care of most of your suggestions:\n\n* In implementing unique representation, we've gone ahead and moved to your idea of a `CoxeterGroup` being the \"core data\" that a `FullyCommutativeElements` is initialized from. In doing so, we've restructured the initialization and category refinement steps to be a little more straightforward. To do so we had to add a .type() accessor to CoxeterType in `combinat/root_system/coxeter_type.py`, which was missing; hopefully that's no big deal. With this change we are now able to use `CoxeterType` throughout and not mention `CartanType` at all.\n\n* We've removed `FullyCommutativeElements` from the global namespace; usage is now via `CoxeterGroup(...).fully_commutative_elements()`. All docs and tests have been changed to reflect this.\n\n* We've added a `.group_element()` to get the plain Coxeter group element from a `FullyCommutativeElement`. This is in the spirit of your earlier suggestion that we should be able to \"output the actual group element\", although maybe not the \"immediately\" part:  if w is an instance of `FullyCommutativeElement`, then w itself is not to be viewed as an element of a Coxeter group in the sense of `categories/coxeter_group.py`; as such, `ElementMethods` like `cover_reflections()` from `sage.categories.coxeter_groups` make sense for `w.group_element()` but not for `w`, while methods like `.cartier_foata_form()` or `.star_operation()` from `fully_commutative_elements.py` are defined for `w` but not for `w.group_element()`. The methods in `coxeter_groups.py` and `fully_commutative_elements.py` seem to overlap only in some code about descents (though `coset_representative` from the former and `coset_decomposition` from the latter are also related), so maybe it's fine to keep the two worlds somewhat separate? We are open to other schemes with more thorough integration. Please let us know what you think.",
    "created_at": "2020-07-30T22:49:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426493",
    "user": "@cemulate"
}
```

Alright, we've taken care of most of your suggestions:

* In implementing unique representation, we've gone ahead and moved to your idea of a `CoxeterGroup` being the "core data" that a `FullyCommutativeElements` is initialized from. In doing so, we've restructured the initialization and category refinement steps to be a little more straightforward. To do so we had to add a .type() accessor to CoxeterType in `combinat/root_system/coxeter_type.py`, which was missing; hopefully that's no big deal. With this change we are now able to use `CoxeterType` throughout and not mention `CartanType` at all.

* We've removed `FullyCommutativeElements` from the global namespace; usage is now via `CoxeterGroup(...).fully_commutative_elements()`. All docs and tests have been changed to reflect this.

* We've added a `.group_element()` to get the plain Coxeter group element from a `FullyCommutativeElement`. This is in the spirit of your earlier suggestion that we should be able to "output the actual group element", although maybe not the "immediately" part:  if w is an instance of `FullyCommutativeElement`, then w itself is not to be viewed as an element of a Coxeter group in the sense of `categories/coxeter_group.py`; as such, `ElementMethods` like `cover_reflections()` from `sage.categories.coxeter_groups` make sense for `w.group_element()` but not for `w`, while methods like `.cartier_foata_form()` or `.star_operation()` from `fully_commutative_elements.py` are defined for `w` but not for `w.group_element()`. The methods in `coxeter_groups.py` and `fully_commutative_elements.py` seem to overlap only in some code about descents (though `coset_representative` from the former and `coset_decomposition` from the latter are also related), so maybe it's fine to keep the two worlds somewhat separate? We are open to other schemes with more thorough integration. Please let us know what you think.



---

archive/issue_comments_426494.json:
```json
{
    "body": "Sorry for the delay in responding; last week was super busy for me.\n\nHmm.. I that is a fair point with wanting to abstract away the group and just consider reduced words themselves. I like this current implementation that takes the best of both words: the abstraction and the link with a specific implementation of the group.\n\n----\n\nSome additional changes:\n\nMinor point, but can you use the standard copyright for Sage:\n\n```\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#                  https://www.gnu.org/licenses/\n# ****************************************************************************\n```\n\n\nThis is better in terms of the internal structure:\n\n```diff\n-class FullyCommutativeElements(Parent, UniqueRepresentation):\n+class FullyCommutativeElements(UniqueRepresentation, Parent):\n```\n\n\nThis check is not correct:\n\n```python\nif not ctype.is_affine() or (family == 'F' and rank == 5) or (family == 'E' and rank == 9):\n```\n\nThis says an indefinite type will have finitely many FC elements. This does not seem to match what is in the comment. I also don't like relying on `is_affine()` failing to check for indefinite type. That feels fragile.\n\nThe `__iter__` can be simplified a bit:\n\n```diff\n         # To make the iterator deterministic, use a dictionary rather than a\n         # set, for the keys are then ordered by default by Python 3.7+:\n         recent_words = {empty_word: True}\n         yield empty_word\n-        length = 1\n-        while True:\n+        while recent_words:\n             new_words = {}\n-            for w in recent_words.keys():\n+            for w in recent_words:\n                 for s in letters:\n                     if w.still_reduced_fc_after_prepending(s):\n                         sw = self.element_class(\n                             self, [s] + list(w), check=False)\n                         # \"Add\" sw to the \"set\"\n                         new_words[sw] = True\n-            if len(new_words) == 0:\n                 return\n-            for w in new_words.keys():\n+            for w in new_words:\n                 yield w\n             recent_words = new_words\n-            length += 1\n```\n\nIt might also be good to say in the docstring that it iterates by increasing length.\n\nIn `iterate_to_length`, I would remove the `assert length >= 0` since it doesn't match your docstring. Also\n\n```diff\n         INPUT:\n \n-        - ``length`` -- integer; maximum length of element to generate.\n+        - ``length`` -- integer; maximum length of element to generate\n```\n\n\nThe `.. PLOT::` is causing the docbuild to fail. I think you need to do this\n\n```diff\n         .. PLOT::\n+            :width: 400 px\n \n-            FC = FullyCommutativeElements(['B', 5])\n+            FC = CoxeterGroup(['B', 5]).fully_commutative_elements()\n             g = FC([3,2,4,3,1]).plot_heap()\n             sphinx_plot(g)\n```\n",
    "created_at": "2020-08-09T01:09:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426494",
    "user": "tscrim"
}
```

Sorry for the delay in responding; last week was super busy for me.

Hmm.. I that is a fair point with wanting to abstract away the group and just consider reduced words themselves. I like this current implementation that takes the best of both words: the abstraction and the link with a specific implementation of the group.

----

Some additional changes:

Minor point, but can you use the standard copyright for Sage:

```
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************
```


This is better in terms of the internal structure:

```diff
-class FullyCommutativeElements(Parent, UniqueRepresentation):
+class FullyCommutativeElements(UniqueRepresentation, Parent):
```


This check is not correct:

```python
if not ctype.is_affine() or (family == 'F' and rank == 5) or (family == 'E' and rank == 9):
```

This says an indefinite type will have finitely many FC elements. This does not seem to match what is in the comment. I also don't like relying on `is_affine()` failing to check for indefinite type. That feels fragile.

The `__iter__` can be simplified a bit:

```diff
         # To make the iterator deterministic, use a dictionary rather than a
         # set, for the keys are then ordered by default by Python 3.7+:
         recent_words = {empty_word: True}
         yield empty_word
-        length = 1
-        while True:
+        while recent_words:
             new_words = {}
-            for w in recent_words.keys():
+            for w in recent_words:
                 for s in letters:
                     if w.still_reduced_fc_after_prepending(s):
                         sw = self.element_class(
                             self, [s] + list(w), check=False)
                         # "Add" sw to the "set"
                         new_words[sw] = True
-            if len(new_words) == 0:
                 return
-            for w in new_words.keys():
+            for w in new_words:
                 yield w
             recent_words = new_words
-            length += 1
```

It might also be good to say in the docstring that it iterates by increasing length.

In `iterate_to_length`, I would remove the `assert length >= 0` since it doesn't match your docstring. Also

```diff
         INPUT:
 
-        - ``length`` -- integer; maximum length of element to generate.
+        - ``length`` -- integer; maximum length of element to generate
```


The `.. PLOT::` is causing the docbuild to fail. I think you need to do this

```diff
         .. PLOT::
+            :width: 400 px
 
-            FC = FullyCommutativeElements(['B', 5])
+            FC = CoxeterGroup(['B', 5]).fully_commutative_elements()
             g = FC([3,2,4,3,1]).plot_heap()
             sphinx_plot(g)
```




---

archive/issue_comments_426495.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-10T04:12:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426495",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426496.json:
```json
{
    "body": "No problem, thanks for the comments. I've taken care of all the issues you mentioned and  verified that the docs build successfully now.",
    "created_at": "2020-08-10T04:14:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426496",
    "user": "@cemulate"
}
```

No problem, thanks for the comments. I've taken care of all the issues you mentioned and  verified that the docs build successfully now.



---

archive/issue_comments_426497.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-10T17:11:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426497",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426498.json:
```json
{
    "body": "We had forgotten to address your comment about the FC-finite/infinite check, but we think it's more sound now. We're not entirely sure what you mean by \"indefinite type\", but now we do not mention affine at all, as it shouldn't be necessary.",
    "created_at": "2020-08-10T17:16:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426498",
    "user": "@cemulate"
}
```

We had forgotten to address your comment about the FC-finite/infinite check, but we think it's more sound now. We're not entirely sure what you mean by "indefinite type", but now we do not mention affine at all, as it shouldn't be necessary.



---

archive/issue_comments_426499.json:
```json
{
    "body": "An indefinite type is something that is not finite nor affine.\n\nHowever, there are still issues with reducible types:\n\n```\nsage: CT = CoxeterType('F4xA2')\nsage: CT.is_finite()\nTrue\nsage: CT.type()\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n...\n```\n\nAn `is_reducible` method is missing from `CoxeterType` as well, but the output of `type()` will be `'reducible'`.\n\nYou also forgot to fix the copyright statement.\n\nAlso, one docstring fix:\n\n```diff\n         def fully_commutative_elements(self):\n             r\"\"\"\n-            Return the combinatorial class of fully commutative elements in this\n-            Coxeter group. See\n-            :class:`~sage.combinat.fully_commutative_elements.FullyCommutativeElements`\n-            for details.\n+            Return the set of fully commutative elements in this Coxeter group.\n+\n+            .. SEEALSO::\n+\n+                :class:`~sage.combinat.fully_commutative_elements.FullyCommutativeElements`\n```\n",
    "created_at": "2020-08-11T01:00:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426499",
    "user": "tscrim"
}
```

An indefinite type is something that is not finite nor affine.

However, there are still issues with reducible types:

```
sage: CT = CoxeterType('F4xA2')
sage: CT.is_finite()
True
sage: CT.type()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
...
```

An `is_reducible` method is missing from `CoxeterType` as well, but the output of `type()` will be `'reducible'`.

You also forgot to fix the copyright statement.

Also, one docstring fix:

```diff
         def fully_commutative_elements(self):
             r"""
-            Return the combinatorial class of fully commutative elements in this
-            Coxeter group. See
-            :class:`~sage.combinat.fully_commutative_elements.FullyCommutativeElements`
-            for details.
+            Return the set of fully commutative elements in this Coxeter group.
+
+            .. SEEALSO::
+
+                :class:`~sage.combinat.fully_commutative_elements.FullyCommutativeElements`
```




---

archive/issue_comments_426500.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-11T02:09:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426500",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426501.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-11T10:17:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426501",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426502.json:
```json
{
    "body": "I've taken another stab at the category refinement step. I believe now it correctly refines to `.Finite()` or `Infinite()` in the finite or affine case, while not bothering / doing nothing in all remaining cases, which includes indefinite types and reducible types.\n\nI hope I understood your previous comment correctly; the only issue I took away from that is that we may incorrectly report the finite/infinite status of reducible or indefinite types. I was able to construct the FC elements for various product types and manipulate them just fine without any exceptions being thrown (the exception in your example session does not happen for me, as the addition of `CoxeterType.type()` resolves that).",
    "created_at": "2020-08-11T10:23:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426502",
    "user": "@cemulate"
}
```

I've taken another stab at the category refinement step. I believe now it correctly refines to `.Finite()` or `Infinite()` in the finite or affine case, while not bothering / doing nothing in all remaining cases, which includes indefinite types and reducible types.

I hope I understood your previous comment correctly; the only issue I took away from that is that we may incorrectly report the finite/infinite status of reducible or indefinite types. I was able to construct the FC elements for various product types and manipulate them just fine without any exceptions being thrown (the exception in your example session does not happen for me, as the addition of `CoxeterType.type()` resolves that).



---

archive/issue_comments_426503.json:
```json
{
    "body": "I don't see why you cannot handle reducible types. I believe the FC elements in a reducible type is just the product of each of the FC elements in each irreducible component. So a reducible type is finite if and only if all of its irreducible components are finite. So how I would do it would be like this:\n\n```python\nis_finite = True\nif ctype.is_reducible():\n    ctype = ctype.component_types()\nelse:\n    ctype = [ctype]\nfor ct in ctype:\n    if not is_a_finite_FC_type(ct):\n        is_finite = False\n        break\nif is_finite:\n    category = category.Finite()\nelse:\n    category = category.Infinite()\n```\n\nYou would need to add a few more little features to `CoxeterType` that I should have already added (but didn't think about as I didn't need it for my application at that time). However, they are all basically just redirects.",
    "created_at": "2020-08-11T23:00:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426503",
    "user": "tscrim"
}
```

I don't see why you cannot handle reducible types. I believe the FC elements in a reducible type is just the product of each of the FC elements in each irreducible component. So a reducible type is finite if and only if all of its irreducible components are finite. So how I would do it would be like this:

```python
is_finite = True
if ctype.is_reducible():
    ctype = ctype.component_types()
else:
    ctype = [ctype]
for ct in ctype:
    if not is_a_finite_FC_type(ct):
        is_finite = False
        break
if is_finite:
    category = category.Finite()
else:
    category = category.Infinite()
```

You would need to add a few more little features to `CoxeterType` that I should have already added (but didn't think about as I didn't need it for my application at that time). However, they are all basically just redirects.



---

archive/issue_comments_426504.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-12T01:27:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426504",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426505.json:
```json
{
    "body": "Ah, I see your point; agreed.\n\nI've redone it again, this time I think it's more straightforward. I was also able to do away with the try-catch block, as `CoxeterGroup.coxeter_type()` will be a `CoxeterMatrix` (which inherits from `CoxeterType`) in the indefinite case, and a `CoxeterType` when it is able to be detected as such. I believe this is a sound approach but let me know if I've made any faulty assumptions.",
    "created_at": "2020-08-12T01:32:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426505",
    "user": "@cemulate"
}
```

Ah, I see your point; agreed.

I've redone it again, this time I think it's more straightforward. I was also able to do away with the try-catch block, as `CoxeterGroup.coxeter_type()` will be a `CoxeterMatrix` (which inherits from `CoxeterType`) in the indefinite case, and a `CoxeterType` when it is able to be detected as such. I believe this is a sound approach but let me know if I've made any faulty assumptions.



---

archive/issue_comments_426506.json:
```json
{
    "body": "Thank you, it is looking a lot better. Now one last bit is you can simplify the checking for the infinite case by making it a positive statement:\n\n```python\nif (not ctype.is_finite() and\n    not ((family == 'F' and rank == 5) or (family == 'E' and rank == 9))):\n    is_finite = False\n    break\n```\n\nIMO, this makes the code easier to read.",
    "created_at": "2020-08-12T02:17:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426506",
    "user": "tscrim"
}
```

Thank you, it is looking a lot better. Now one last bit is you can simplify the checking for the infinite case by making it a positive statement:

```python
if (not ctype.is_finite() and
    not ((family == 'F' and rank == 5) or (family == 'E' and rank == 9))):
    is_finite = False
    break
```

IMO, this makes the code easier to read.



---

archive/issue_comments_426507.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-12T08:11:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426507",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426508.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-12T08:12:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426508",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426509.json:
```json
{
    "body": "OK, I've made it more straightforward and added some tests for the cardinality detection as well.",
    "created_at": "2020-08-12T08:12:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426509",
    "user": "@cemulate"
}
```

OK, I've made it more straightforward and added some tests for the cardinality detection as well.



---

archive/issue_comments_426510.json:
```json
{
    "body": "Thank you. The finite detection looks great now. We are almost there.\n\nI would just simply have `normalize = cartier_foata_form` rather than an explicit redirect. This becomes moot, but why is `normalize` even returning something when the `cartier_foata_form` returns nothing? Likewise moot, but you don't need to explicitly state the redirects.\n\nI would hide `still_reduced_fc_after_prepending` by renaming it `_still_reduced_fc_after_prepending` as the user doesn't really need that method.\n\nInstead of `\\mathbb{N}`, you can use `\\NN`, which is better for standardization within Sage. (This applies to anything similar, such at `\\ZZ` and `\\QQ`.)\n\nRemove `OPTIONAL ARGUMENTS:`; just include them in the `INPUT:` block. Also, input items should not end with a period/full-stop. Additionally, please format as ```'left'```.\n\nYou probably want this:\n\n```diff\n             (3) `t` is left descent of the word `u_3`  obtained by\n             removing the leftmost `s` from `u_2`;\n+\n             ...\n+\n             (m-1) the appropriate element in `\\{s, t\\}` is a left descent\n             of the word `u_{m-1}` obtained by removing the leftmost letter\n             required to be a descent in Condition (m-2) from `u_{m-2}`.\n```\n\n\nI think this is much more understandable on 1 line (and therefore worth breaking the 80 char/line guideline):\n\n```diff\n-            new_string = [other] + \\\n-                cur_string if side == 'left' else cur_string + [other]\n+            new_string = [other] + cur_string if side == 'left' else cur_string + [other]\n```\n\n\nIn the `FullyCommutativeElements.__init__`, I would make the doctests:\n\n```python\n    def __init__(self, coxeter_group):\n        r\"\"\"\n        Initialize ``self``.\n\n        EXAMPLES::\n\n            sage: from sage.combinat.fully_commutative_elements import FullyCommutativeElements\n            sage: FC = FullyCommutativeElements(CoxeterGroup(['H', 4]))\n            sage: TestSuite(FC).run()\n        \"\"\"\n```\n\n\n\n```\n#diff\n             sage: list(FCAffineA2.iterate_to_length(4))\n-            [[], [0], [1], [2], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [1,\n-            2], [2, 1, 0], [1, 2, 0], [2, 0, 1], [0, 2, 1], [1, 0, 2], [0, 1,\n-            2], [0, 2, 1, 0], [0, 1, 2, 0], [1, 2, 0, 1], [1, 0, 2, 1], [2, 1,\n-            0, 2], [2, 0, 1, 2]]\n+            [[], [0], [1], [2], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2],\n+             [1, 2], [2, 1, 0], [1, 2, 0], [2, 0, 1], [0, 2, 1], [1, 0, 2],\n+             [0, 1, 2], [0, 2, 1, 0], [0, 1, 2, 0], [1, 2, 0, 1],\n+             [1, 0, 2, 1], [2, 1, 0, 2], [2, 0, 1, 2]]\n```\n",
    "created_at": "2020-08-14T05:55:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426510",
    "user": "tscrim"
}
```

Thank you. The finite detection looks great now. We are almost there.

I would just simply have `normalize = cartier_foata_form` rather than an explicit redirect. This becomes moot, but why is `normalize` even returning something when the `cartier_foata_form` returns nothing? Likewise moot, but you don't need to explicitly state the redirects.

I would hide `still_reduced_fc_after_prepending` by renaming it `_still_reduced_fc_after_prepending` as the user doesn't really need that method.

Instead of `\mathbb{N}`, you can use `\NN`, which is better for standardization within Sage. (This applies to anything similar, such at `\ZZ` and `\QQ`.)

Remove `OPTIONAL ARGUMENTS:`; just include them in the `INPUT:` block. Also, input items should not end with a period/full-stop. Additionally, please format as ```'left'```.

You probably want this:

```diff
             (3) `t` is left descent of the word `u_3`  obtained by
             removing the leftmost `s` from `u_2`;
+
             ...
+
             (m-1) the appropriate element in `\{s, t\}` is a left descent
             of the word `u_{m-1}` obtained by removing the leftmost letter
             required to be a descent in Condition (m-2) from `u_{m-2}`.
```


I think this is much more understandable on 1 line (and therefore worth breaking the 80 char/line guideline):

```diff
-            new_string = [other] + \
-                cur_string if side == 'left' else cur_string + [other]
+            new_string = [other] + cur_string if side == 'left' else cur_string + [other]
```


In the `FullyCommutativeElements.__init__`, I would make the doctests:

```python
    def __init__(self, coxeter_group):
        r"""
        Initialize ``self``.

        EXAMPLES::

            sage: from sage.combinat.fully_commutative_elements import FullyCommutativeElements
            sage: FC = FullyCommutativeElements(CoxeterGroup(['H', 4]))
            sage: TestSuite(FC).run()
        """
```



```
#diff
             sage: list(FCAffineA2.iterate_to_length(4))
-            [[], [0], [1], [2], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [1,
-            2], [2, 1, 0], [1, 2, 0], [2, 0, 1], [0, 2, 1], [1, 0, 2], [0, 1,
-            2], [0, 2, 1, 0], [0, 1, 2, 0], [1, 2, 0, 1], [1, 0, 2, 1], [2, 1,
-            0, 2], [2, 0, 1, 2]]
+            [[], [0], [1], [2], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2],
+             [1, 2], [2, 1, 0], [1, 2, 0], [2, 0, 1], [0, 2, 1], [1, 0, 2],
+             [0, 1, 2], [0, 2, 1, 0], [0, 1, 2, 0], [1, 2, 0, 1],
+             [1, 0, 2, 1], [2, 1, 0, 2], [2, 0, 1, 2]]
```




---

archive/issue_comments_426511.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-14T07:42:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426511",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426512.json:
```json
{
    "body": "Alright, I believe I've addressed all your concerns. I did take care to fix other instances that were similar to the cases you pointed out when possible, and verified the docs build and look OK.\n\nPer the first suggestion, I eliminated `cartier_foata_form` and simply kept `normalize`; I think we were concerned that \"normalize\" isn't very descriptive, but given that the docstring says exactly how we are normalizing, I don't think it's a problem.",
    "created_at": "2020-08-14T07:45:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426512",
    "user": "@cemulate"
}
```

Alright, I believe I've addressed all your concerns. I did take care to fix other instances that were similar to the cases you pointed out when possible, and verified the docs build and look OK.

Per the first suggestion, I eliminated `cartier_foata_form` and simply kept `normalize`; I think we were concerned that "normalize" isn't very descriptive, but given that the docstring says exactly how we are normalizing, I don't think it's a problem.



---

archive/issue_comments_426513.json:
```json
{
    "body": "Thank you. Last tidbits:\n\nThe docstring of `normalize` is not correct because you are not returning anything. I would say\n\n```\nMutate ``self`` into Cartier-Foata normal form.\n```\n\n(the single hyphen is because this doesn't convert it to latex, sadly).\n\nI missed this when reading the docstring, but in `coset_decomposition`, I would change `l` to `\\ell` so there is no possible confusion with `1` or `I` (plus IMO, the latex version is prettier).",
    "created_at": "2020-08-14T08:07:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426513",
    "user": "tscrim"
}
```

Thank you. Last tidbits:

The docstring of `normalize` is not correct because you are not returning anything. I would say

```
Mutate ``self`` into Cartier-Foata normal form.
```

(the single hyphen is because this doesn't convert it to latex, sadly).

I missed this when reading the docstring, but in `coset_decomposition`, I would change `l` to `\ell` so there is no possible confusion with `1` or `I` (plus IMO, the latex version is prettier).



---

archive/issue_comments_426514.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-14T08:29:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426514",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_426515.json:
```json
{
    "body": "I agree; taken care of.",
    "created_at": "2020-08-14T08:29:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426515",
    "user": "@cemulate"
}
```

I agree; taken care of.



---

archive/issue_comments_426516.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-08-14T08:52:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426516",
    "user": "tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_426517.json:
```json
{
    "body": "Thank you.",
    "created_at": "2020-08-14T08:52:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426517",
    "user": "tscrim"
}
```

Thank you.



---

archive/issue_comments_426518.json:
```json
{
    "body": "No problem, thanks a lot for your time and effort; we appreciate the feedback! This will help inform us on code style and Sage convention for any future submissions.",
    "created_at": "2020-08-14T09:01:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426518",
    "user": "@cemulate"
}
```

No problem, thanks a lot for your time and effort; we appreciate the feedback! This will help inform us on code style and Sage convention for any future submissions.



---

archive/issue_comments_426519.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2020-08-20T02:58:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426519",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_426520.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2020-08-20T02:58:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426520",
    "user": "git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_426521.json:
```json
{
    "body": "I checked the test failures and fixed a pyflakes error.",
    "created_at": "2020-08-20T03:00:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426521",
    "user": "@cemulate"
}
```

I checked the test failures and fixed a pyflakes error.



---

archive/issue_comments_426522.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-08-20T23:02:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426522",
    "user": "tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_426523.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2020-08-26T21:15:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30006",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30006#issuecomment-426523",
    "user": "vbraun"
}
```

Resolution: fixed
