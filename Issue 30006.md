# Issue 30006: fully-commutatve-elements

Issue created by migration from https://trac.sagemath.org/ticket/30243

Original creator: @cemulate

Original creation time: 2020-07-28 20:12:43

CC:  gfeinberg tscrim combinat




---

Comment by @cemulate created at 2020-07-28 21:33:29

Changing type from PLEASE CHANGE to enhancement.


---

Comment by @cemulate created at 2020-07-28 21:33:29

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by @cemulate created at 2020-07-28 21:33:29

Changing priority from major to minor.


---

Comment by @cemulate created at 2020-07-28 21:33:29

Changing keywords from "" to "fully commutative, coxeter, CoxeterGroup".


---

Comment by git created at 2020-07-28 21:34:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @cemulate created at 2020-07-28 21:37:00

Changing status from new to needs_review.


---

Comment by git created at 2020-07-28 21:42:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @TianyuanX created at 2020-07-28 22:40:43

Changing keywords from "fully commutative, coxeter, CoxeterGroup" to "Coxeter systems, Coxeter groups, fully commutative elements".


---

Comment by git created at 2020-07-29 11:29:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Attachment

Built documentation page


---

Comment by tscrim created at 2020-07-30 01:07:06

The test for an element of a Coxeter group to be fully commutative should also be available for the elements of a Coxeter group (probably in the category of `CoxeterGroups`).

`FullyCommutativeElements` should also be a `UniqueRepresentation`. So you will also need to implement

```python
@staticmethod
    def __classcall_private__(cls, data):
        if isinstance(data, CoxeterMatrix):
            matrix = data
        else:
            try:
                t = CartanType(data)
            except (TypeError, ValueError):
                raise ValueError('input must be a CoxeterMatrix or data describing a Cartan/Coxeter type')
            matrix = t.coxeter_matrix()
        return super(cls, FullyCommutativeElements).__classcall__(cls, matrix)

    def __init__(self, matrix):
        self._matrix = matrix
        # Rest of the initialization
```

I would also avoid the big `try-except` block in the `__init__` to handle more cases more explicitly. (This will make it easier to maintain the code later on.) I think you should also see if the data can be passed to a `CoxeterType`, possibly first before `CartanType`.


---

Comment by tscrim created at 2020-07-30 01:09:53

Actually, rather than the Coxeter matrix, it should have the Coxeter group as the input. That way it can immediately output the actual group elements (which can depend on your group's implementation) rather than converting from the reduced words. It just saves a little bit of time for the user, and I think that is more natural anyways.

Finally, I would add a hook in the category of Coxeter groups of

```python
def fully_commutative_elements(self):
    from sage.combinat.fully_commutative_elements import FullyCommutativeElements
    return FullyCommutativeElements(self)
```

That way it is easy to access and more natural than having something in the global namespace (which I might even say should be removed).


---

Comment by @cemulate created at 2020-07-30 11:14:23

I like the idea of exposing everything as `CoxeterGroup.fully_commutative_elements()`. And implementing UniqueRepresentation should be fine as well. I'll get this done shortly.

The reason we differentiated the element class from the elements of a `CoxeterGroup` in the first place is that we're treating all of our operations and manipulations on elements as pure combinatorics on reduced words; depending on the implementation, calling `.(from_)reduced_word()` all the time can be quite expensive. Furthermore, we _replace_ methods on `CoxeterGroup` elements such as `has_descent` and co. to provide specialized criterion that work on fully commutative reduced words, and add various other methods as well. This is why we ended up inventing a lightweight element class that simply represents "a canonical reduced word of a fully commutative element". 

I agree it might be nice to be able to go seamlessly to an element of the ambient `CoxeterGroup` (if we're going to initialize with a `CoxeterGroup` as the "core data" instead of a matrix, which I like), but perhaps we could just have something like `.element()` that forgets the full commutivity and gives you a regular element of the `CoxeterGroup`?


---

Comment by git created at 2020-07-30 20:45:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-07-30 20:50:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-07-30 21:54:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-07-30 21:57:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @cemulate created at 2020-07-30 22:49:31

Alright, we've taken care of most of your suggestions:

* In implementing unique representation, we've gone ahead and moved to your idea of a `CoxeterGroup` being the "core data" that a `FullyCommutativeElements` is initialized from. In doing so, we've restructured the initialization and category refinement steps to be a little more straightforward. To do so we had to add a .type() accessor to CoxeterType in `combinat/root_system/coxeter_type.py`, which was missing; hopefully that's no big deal. With this change we are now able to use `CoxeterType` throughout and not mention `CartanType` at all.

* We've removed `FullyCommutativeElements` from the global namespace; usage is now via `CoxeterGroup(...).fully_commutative_elements()`. All docs and tests have been changed to reflect this.

* We've added a `.group_element()` to get the plain Coxeter group element from a `FullyCommutativeElement`. This is in the spirit of your earlier suggestion that we should be able to "output the actual group element", although maybe not the "immediately" part:  if w is an instance of `FullyCommutativeElement`, then w itself is not to be viewed as an element of a Coxeter group in the sense of `categories/coxeter_group.py`; as such, `ElementMethods` like `cover_reflections()` from `sage.categories.coxeter_groups` make sense for `w.group_element()` but not for `w`, while methods like `.cartier_foata_form()` or `.star_operation()` from `fully_commutative_elements.py` are defined for `w` but not for `w.group_element()`. The methods in `coxeter_groups.py` and `fully_commutative_elements.py` seem to overlap only in some code about descents (though `coset_representative` from the former and `coset_decomposition` from the latter are also related), so maybe it's fine to keep the two worlds somewhat separate? We are open to other schemes with more thorough integration. Please let us know what you think.


---

Comment by tscrim created at 2020-08-09 01:09:43

Sorry for the delay in responding; last week was super busy for me.

Hmm.. I that is a fair point with wanting to abstract away the group and just consider reduced words themselves. I like this current implementation that takes the best of both words: the abstraction and the link with a specific implementation of the group.

----

Some additional changes:

Minor point, but can you use the standard copyright for Sage:

```
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************
```


This is better in terms of the internal structure:

```diff
-class FullyCommutativeElements(Parent, UniqueRepresentation):
+class FullyCommutativeElements(UniqueRepresentation, Parent):
```


This check is not correct:

```python
if not ctype.is_affine() or (family == 'F' and rank == 5) or (family == 'E' and rank == 9):
```

This says an indefinite type will have finitely many FC elements. This does not seem to match what is in the comment. I also don't like relying on `is_affine()` failing to check for indefinite type. That feels fragile.

The `__iter__` can be simplified a bit:

```diff
         # To make the iterator deterministic, use a dictionary rather than a
         # set, for the keys are then ordered by default by Python 3.7+:
         recent_words = {empty_word: True}
         yield empty_word
-        length = 1
-        while True:
+        while recent_words:
             new_words = {}
-            for w in recent_words.keys():
+            for w in recent_words:
                 for s in letters:
                     if w.still_reduced_fc_after_prepending(s):
                         sw = self.element_class(
                             self, [s] + list(w), check=False)
                         # "Add" sw to the "set"
                         new_words[sw] = True
-            if len(new_words) == 0:
                 return
-            for w in new_words.keys():
+            for w in new_words:
                 yield w
             recent_words = new_words
-            length += 1
```

It might also be good to say in the docstring that it iterates by increasing length.

In `iterate_to_length`, I would remove the `assert length >= 0` since it doesn't match your docstring. Also

```diff
         INPUT:
 
-        - ``length`` -- integer; maximum length of element to generate.
+        - ``length`` -- integer; maximum length of element to generate
```


The `.. PLOT::` is causing the docbuild to fail. I think you need to do this

```diff
         .. PLOT::
+            :width: 400 px
 
-            FC = FullyCommutativeElements(['B', 5])
+            FC = CoxeterGroup(['B', 5]).fully_commutative_elements()
             g = FC([3,2,4,3,1]).plot_heap()
             sphinx_plot(g)
```



---

Comment by git created at 2020-08-10 04:12:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @cemulate created at 2020-08-10 04:14:50

No problem, thanks for the comments. I've taken care of all the issues you mentioned and  verified that the docs build successfully now.


---

Comment by git created at 2020-08-10 17:11:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @cemulate created at 2020-08-10 17:16:38

We had forgotten to address your comment about the FC-finite/infinite check, but we think it's more sound now. We're not entirely sure what you mean by "indefinite type", but now we do not mention affine at all, as it shouldn't be necessary.


---

Comment by tscrim created at 2020-08-11 01:00:14

An indefinite type is something that is not finite nor affine.

However, there are still issues with reducible types:

```
sage: CT = CoxeterType('F4xA2')
sage: CT.is_finite()
True
sage: CT.type()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
...
```

An `is_reducible` method is missing from `CoxeterType` as well, but the output of `type()` will be `'reducible'`.

You also forgot to fix the copyright statement.

Also, one docstring fix:

```diff
         def fully_commutative_elements(self):
             r"""
-            Return the combinatorial class of fully commutative elements in this
-            Coxeter group. See
-            :class:`~sage.combinat.fully_commutative_elements.FullyCommutativeElements`
-            for details.
+            Return the set of fully commutative elements in this Coxeter group.
+
+            .. SEEALSO::
+
+                :class:`~sage.combinat.fully_commutative_elements.FullyCommutativeElements`
```



---

Comment by git created at 2020-08-11 02:09:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-11 10:17:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @cemulate created at 2020-08-11 10:23:28

I've taken another stab at the category refinement step. I believe now it correctly refines to `.Finite()` or `Infinite()` in the finite or affine case, while not bothering / doing nothing in all remaining cases, which includes indefinite types and reducible types.

I hope I understood your previous comment correctly; the only issue I took away from that is that we may incorrectly report the finite/infinite status of reducible or indefinite types. I was able to construct the FC elements for various product types and manipulate them just fine without any exceptions being thrown (the exception in your example session does not happen for me, as the addition of `CoxeterType.type()` resolves that).


---

Comment by tscrim created at 2020-08-11 23:00:42

I don't see why you cannot handle reducible types. I believe the FC elements in a reducible type is just the product of each of the FC elements in each irreducible component. So a reducible type is finite if and only if all of its irreducible components are finite. So how I would do it would be like this:

```python
is_finite = True
if ctype.is_reducible():
    ctype = ctype.component_types()
else:
    ctype = [ctype]
for ct in ctype:
    if not is_a_finite_FC_type(ct):
        is_finite = False
        break
if is_finite:
    category = category.Finite()
else:
    category = category.Infinite()
```

You would need to add a few more little features to `CoxeterType` that I should have already added (but didn't think about as I didn't need it for my application at that time). However, they are all basically just redirects.


---

Comment by git created at 2020-08-12 01:27:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @cemulate created at 2020-08-12 01:32:35

Ah, I see your point; agreed.

I've redone it again, this time I think it's more straightforward. I was also able to do away with the try-catch block, as `CoxeterGroup.coxeter_type()` will be a `CoxeterMatrix` (which inherits from `CoxeterType`) in the indefinite case, and a `CoxeterType` when it is able to be detected as such. I believe this is a sound approach but let me know if I've made any faulty assumptions.


---

Comment by tscrim created at 2020-08-12 02:17:26

Thank you, it is looking a lot better. Now one last bit is you can simplify the checking for the infinite case by making it a positive statement:

```python
if (not ctype.is_finite() and
    not ((family == 'F' and rank == 5) or (family == 'E' and rank == 9))):
    is_finite = False
    break
```

IMO, this makes the code easier to read.


---

Comment by git created at 2020-08-12 08:11:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-12 08:12:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @cemulate created at 2020-08-12 08:12:59

OK, I've made it more straightforward and added some tests for the cardinality detection as well.


---

Comment by tscrim created at 2020-08-14 05:55:45

Thank you. The finite detection looks great now. We are almost there.

I would just simply have `normalize = cartier_foata_form` rather than an explicit redirect. This becomes moot, but why is `normalize` even returning something when the `cartier_foata_form` returns nothing? Likewise moot, but you don't need to explicitly state the redirects.

I would hide `still_reduced_fc_after_prepending` by renaming it `_still_reduced_fc_after_prepending` as the user doesn't really need that method.

Instead of `\mathbb{N}`, you can use `\NN`, which is better for standardization within Sage. (This applies to anything similar, such at `\ZZ` and `\QQ`.)

Remove `OPTIONAL ARGUMENTS:`; just include them in the `INPUT:` block. Also, input items should not end with a period/full-stop. Additionally, please format as ```'left'```.

You probably want this:

```diff
             (3) `t` is left descent of the word `u_3`  obtained by
             removing the leftmost `s` from `u_2`;
+
             ...
+
             (m-1) the appropriate element in `\{s, t\}` is a left descent
             of the word `u_{m-1}` obtained by removing the leftmost letter
             required to be a descent in Condition (m-2) from `u_{m-2}`.
```


I think this is much more understandable on 1 line (and therefore worth breaking the 80 char/line guideline):

```diff
-            new_string = [other] + \
-                cur_string if side == 'left' else cur_string + [other]
+            new_string = [other] + cur_string if side == 'left' else cur_string + [other]
```


In the `FullyCommutativeElements.__init__`, I would make the doctests:

```python
    def __init__(self, coxeter_group):
        r"""
        Initialize ``self``.

        EXAMPLES::

            sage: from sage.combinat.fully_commutative_elements import FullyCommutativeElements
            sage: FC = FullyCommutativeElements(CoxeterGroup(['H', 4]))
            sage: TestSuite(FC).run()
        """
```



```
#diff
             sage: list(FCAffineA2.iterate_to_length(4))
-            [[], [0], [1], [2], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [1,
-            2], [2, 1, 0], [1, 2, 0], [2, 0, 1], [0, 2, 1], [1, 0, 2], [0, 1,
-            2], [0, 2, 1, 0], [0, 1, 2, 0], [1, 2, 0, 1], [1, 0, 2, 1], [2, 1,
-            0, 2], [2, 0, 1, 2]]
+            [[], [0], [1], [2], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2],
+             [1, 2], [2, 1, 0], [1, 2, 0], [2, 0, 1], [0, 2, 1], [1, 0, 2],
+             [0, 1, 2], [0, 2, 1, 0], [0, 1, 2, 0], [1, 2, 0, 1],
+             [1, 0, 2, 1], [2, 1, 0, 2], [2, 0, 1, 2]]
```



---

Comment by git created at 2020-08-14 07:42:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @cemulate created at 2020-08-14 07:45:51

Alright, I believe I've addressed all your concerns. I did take care to fix other instances that were similar to the cases you pointed out when possible, and verified the docs build and look OK.

Per the first suggestion, I eliminated `cartier_foata_form` and simply kept `normalize`; I think we were concerned that "normalize" isn't very descriptive, but given that the docstring says exactly how we are normalizing, I don't think it's a problem.


---

Comment by tscrim created at 2020-08-14 08:07:13

Thank you. Last tidbits:

The docstring of `normalize` is not correct because you are not returning anything. I would say

```
Mutate ``self`` into Cartier-Foata normal form.
```

(the single hyphen is because this doesn't convert it to latex, sadly).

I missed this when reading the docstring, but in `coset_decomposition`, I would change `l` to `\ell` so there is no possible confusion with `1` or `I` (plus IMO, the latex version is prettier).


---

Comment by git created at 2020-08-14 08:29:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @cemulate created at 2020-08-14 08:29:29

I agree; taken care of.


---

Comment by tscrim created at 2020-08-14 08:52:41

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2020-08-14 08:52:41

Thank you.


---

Comment by @cemulate created at 2020-08-14 09:01:41

No problem, thanks a lot for your time and effort; we appreciate the feedback! This will help inform us on code style and Sage convention for any future submissions.


---

Comment by git created at 2020-08-20 02:58:50

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2020-08-20 02:58:50

Changing status from positive_review to needs_review.


---

Comment by @cemulate created at 2020-08-20 03:00:55

I checked the test failures and fixed a pyflakes error.


---

Comment by tscrim created at 2020-08-20 23:02:43

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-08-26 21:15:42

Resolution: fixed
