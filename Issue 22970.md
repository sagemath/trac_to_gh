# Issue 22970: Exterior powers of free modules of finite rank

archive/issues_022970.json:
```json
{
    "body": "CC:  @tscrim bpym\n\nKeywords: free module exterior power\n\nThis ticket implements the exterior power /\\<sup>*p*</sup>(*M*) for a free module of finite rank *M* (*p* being a positive integer), i.e. the set of alternating contravariant tensors of type (*p*,0) on *M*. Previously only the exterior power of the *dual* of *M*, i.e. /\\<sup>*p*</sup>(*M**), was implemented, as the parent of alternating forms of degree *p*. More specifically, the ticket introduces two new classes:\n\n- the parent class `ExtPowerFreeModule` for /\\<sup>*p*</sup>(*M*)\n- the element class `AlternatingContrTensor` for elements of /\\<sup>*p*</sup>(*M*)\n\nNote that the pre-existing class for  /\\<sup>*p*</sup>(*M**), which was called `ExtPowerFreeModule`, has been renamed `ExtPowerDualFreeModule`, since it regards the exterior power of the dual of *M*. \n\nThe class for the elements of *M*, `FiniteRankFreeModuleElement` , inherits from the new class `AlternatingContrTensor`, reflecting the fact that /\\<sup>1</sup>(*M*) = *M*. In particular, this allows one to consider module elements in operations like the exterior product or the interior product. For instance, for *a* and *b* in *M*,  `a.wedge(b)` returns now the element *a*/\\*b* of /\\<sup>2</sup>(*M*).\n\nIn addition, the ticket implements the interior products\n\n- /\\<sup>*p*</sup>(*M*) x /\\<sup>*q*</sup>(*M**)  --> /\\<sup>*q-p*</sup>(*M**)\n- /\\<sup>*p*</sup>(*M**) x /\\<sup>*q*</sup>(*M*)  --> /\\<sup>*q-p*</sup>(*M*)\n\nfor *p*<=*q* via the method `interior_product` in classes `AlternatingContrTensor` and `FreeModuleAltForm`.\n\nBesides, some slight updates in all source files in `src/sage/tensor/modules` have been performed:\n\n- a few `range(...)` have been changed to `list(range(...))` to prepare the migration to Python3\n- bibliographic references have been reformated to provide links to the master bibliography file `src/doc/en/reference/references/index.rst`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/23207\n\n",
    "created_at": "2017-06-10T09:44:22Z",
    "labels": [
        "linear algebra",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.1",
    "title": "Exterior powers of free modules of finite rank",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22970",
    "user": "@egourgoulhon"
}
```
CC:  @tscrim bpym

Keywords: free module exterior power

This ticket implements the exterior power /\<sup>*p*</sup>(*M*) for a free module of finite rank *M* (*p* being a positive integer), i.e. the set of alternating contravariant tensors of type (*p*,0) on *M*. Previously only the exterior power of the *dual* of *M*, i.e. /\<sup>*p*</sup>(*M**), was implemented, as the parent of alternating forms of degree *p*. More specifically, the ticket introduces two new classes:

- the parent class `ExtPowerFreeModule` for /\<sup>*p*</sup>(*M*)
- the element class `AlternatingContrTensor` for elements of /\<sup>*p*</sup>(*M*)

Note that the pre-existing class for  /\<sup>*p*</sup>(*M**), which was called `ExtPowerFreeModule`, has been renamed `ExtPowerDualFreeModule`, since it regards the exterior power of the dual of *M*. 

The class for the elements of *M*, `FiniteRankFreeModuleElement` , inherits from the new class `AlternatingContrTensor`, reflecting the fact that /\<sup>1</sup>(*M*) = *M*. In particular, this allows one to consider module elements in operations like the exterior product or the interior product. For instance, for *a* and *b* in *M*,  `a.wedge(b)` returns now the element *a*/\*b* of /\<sup>2</sup>(*M*).

In addition, the ticket implements the interior products

- /\<sup>*p*</sup>(*M*) x /\<sup>*q*</sup>(*M**)  --> /\<sup>*q-p*</sup>(*M**)
- /\<sup>*p*</sup>(*M**) x /\<sup>*q*</sup>(*M*)  --> /\<sup>*q-p*</sup>(*M*)

for *p*<=*q* via the method `interior_product` in classes `AlternatingContrTensor` and `FreeModuleAltForm`.

Besides, some slight updates in all source files in `src/sage/tensor/modules` have been performed:

- a few `range(...)` have been changed to `list(range(...))` to prepare the migration to Python3
- bibliographic references have been reformated to provide links to the master bibliography file `src/doc/en/reference/references/index.rst`.

Issue created by migration from https://trac.sagemath.org/ticket/23207





---

archive/issue_comments_321395.json:
```json
{
    "body": "New commits:",
    "created_at": "2017-06-10T09:45:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321395",
    "user": "@egourgoulhon"
}
```

New commits:



---

archive/issue_comments_321396.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-06-10T12:21:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321396",
    "user": "@egourgoulhon"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_321397.json:
```json
{
    "body": "Quick comment: Rather than `antisym=list(range(degree))` (and similar changes), I think it would be better if the Python3 `range` could be taken as valid input. It makes the code more robust and makes things like `list(range(5))` less random in some points of the code.\n\nI will look at the code itself soon.",
    "created_at": "2017-06-11T03:16:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321397",
    "user": "@tscrim"
}
```

Quick comment: Rather than `antisym=list(range(degree))` (and similar changes), I think it would be better if the Python3 `range` could be taken as valid input. It makes the code more robust and makes things like `list(range(5))` less random in some points of the code.

I will look at the code itself soon.



---

archive/issue_comments_321398.json:
```json
{
    "body": "Replying to [comment:3 tscrim]:\n> Quick comment: Rather than `antisym=list(range(degree))` (and similar changes), I think it would be better if the Python3 `range` could be taken as valid input.\n\nThis cannot be because the argument `antisym` is not intended to be an iterator, but a list of integers or tuples encoding the antisymmetries of the tensor; for instance `antisym=[(0,1), (2,3)]` means that the tensor is antisymmetric with respect to the permutation of its first (0) and second (1) argument/index, as well as with respect to the permutation of its third (2) and fourth (3) argument/index. In this context, `antisym=[0,1,2,3]` is a short-hand for `antisym=[(0,1,2,3)]`. For alternating tensors of degree `p`, one therefore should have `antisym=[(0,...,p-1)]`, short-handed as `antisym=[0,...,p-1]` and generated by `antisym=list(range(p))`. \n\n> \n> I will look at the code itself soon.\n\nThanks!",
    "created_at": "2017-06-11T12:26:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321398",
    "user": "@egourgoulhon"
}
```

Replying to [comment:3 tscrim]:
> Quick comment: Rather than `antisym=list(range(degree))` (and similar changes), I think it would be better if the Python3 `range` could be taken as valid input.

This cannot be because the argument `antisym` is not intended to be an iterator, but a list of integers or tuples encoding the antisymmetries of the tensor; for instance `antisym=[(0,1), (2,3)]` means that the tensor is antisymmetric with respect to the permutation of its first (0) and second (1) argument/index, as well as with respect to the permutation of its third (2) and fourth (3) argument/index. In this context, `antisym=[0,1,2,3]` is a short-hand for `antisym=[(0,1,2,3)]`. For alternating tensors of degree `p`, one therefore should have `antisym=[(0,...,p-1)]`, short-handed as `antisym=[0,...,p-1]` and generated by `antisym=list(range(p))`. 

> 
> I will look at the code itself soon.

Thanks!



---

archive/issue_comments_321399.json:
```json
{
    "body": "Replying to [comment:4 egourgoulhon]:\n> Replying to [comment:3 tscrim]:\n> > Quick comment: Rather than `antisym=list(range(degree))` (and similar changes), I think it would be better if the Python3 `range` could be taken as valid input.\n> \n> This cannot be because the argument `antisym` is not intended to be an iterator, but a list of integers or tuples encoding the antisymmetries of the tensor; for instance `antisym=[(0,1), (2,3)]` means that the tensor is antisymmetric with respect to the permutation of its first (0) and second (1) argument/index, as well as with respect to the permutation of its third (2) and fourth (3) argument/index. In this context, `antisym=[0,1,2,3]` is a short-hand for `antisym=[(0,1,2,3)]`. For alternating tensors of degree `p`, one therefore should have `antisym=[(0,...,p-1)]`, short-handed as `antisym=[0,...,p-1]` and generated by `antisym=list(range(p))`. \n\n`range` in Python3 has its own type (currently `xrange` in Python2) that you can explicitly check against:\n\n```\nsage: from six.moves import range as py3range\nsage: x = py3range(5)\nsage: isinstance(x, py3range)\nTrue\n```\n\nSo you can still support the Python3 range but not support iterators.",
    "created_at": "2017-06-11T12:37:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321399",
    "user": "@tscrim"
}
```

Replying to [comment:4 egourgoulhon]:
> Replying to [comment:3 tscrim]:
> > Quick comment: Rather than `antisym=list(range(degree))` (and similar changes), I think it would be better if the Python3 `range` could be taken as valid input.
> 
> This cannot be because the argument `antisym` is not intended to be an iterator, but a list of integers or tuples encoding the antisymmetries of the tensor; for instance `antisym=[(0,1), (2,3)]` means that the tensor is antisymmetric with respect to the permutation of its first (0) and second (1) argument/index, as well as with respect to the permutation of its third (2) and fourth (3) argument/index. In this context, `antisym=[0,1,2,3]` is a short-hand for `antisym=[(0,1,2,3)]`. For alternating tensors of degree `p`, one therefore should have `antisym=[(0,...,p-1)]`, short-handed as `antisym=[0,...,p-1]` and generated by `antisym=list(range(p))`. 

`range` in Python3 has its own type (currently `xrange` in Python2) that you can explicitly check against:

```
sage: from six.moves import range as py3range
sage: x = py3range(5)
sage: isinstance(x, py3range)
True
```

So you can still support the Python3 range but not support iterators.



---

archive/issue_comments_321400.json:
```json
{
    "body": "Replying to [comment:5 tscrim]:\n> `range` in Python3 has its own type (currently `xrange` in Python2) that you can explicitly check against:\n> {{{\n> sage: from six.moves import range as py3range\n> sage: x = py3range(5)\n> sage: isinstance(x, py3range)\n> True\n> }}}\n> So you can still support the Python3 range but not support iterators.\n\nYes, but I am afraid I don't understand what you have in mind. The attribute `_antisym` of tensors is a list, which in practice is very short: in most applications, it contains 0 or 1 element, sometimes 2 (e.g. [(0,1), (2,3)] for the fully covariant version of the Riemann tensor). The elements are tuples indicating which indices are involved in the antisymmetry. For the case of alternating tensors, `_antisym` is a list with a single element, since there is a single antisymmetry, the one corresponding to all possible permutations of the indices. This unique antisymmetry is encoded by the tuple `(0,1,...,p-1)`, `p` being the degree of the alternating tensor. So we must have `_antisym=[(0,1,...,p-1)]` in this case, with `(0,1,...,p-1)` being really a tuple of integers. What would be the advantage of using Python3 `range` in this context?",
    "created_at": "2017-06-11T13:39:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321400",
    "user": "@egourgoulhon"
}
```

Replying to [comment:5 tscrim]:
> `range` in Python3 has its own type (currently `xrange` in Python2) that you can explicitly check against:
> {{{
> sage: from six.moves import range as py3range
> sage: x = py3range(5)
> sage: isinstance(x, py3range)
> True
> }}}
> So you can still support the Python3 range but not support iterators.

Yes, but I am afraid I don't understand what you have in mind. The attribute `_antisym` of tensors is a list, which in practice is very short: in most applications, it contains 0 or 1 element, sometimes 2 (e.g. [(0,1), (2,3)] for the fully covariant version of the Riemann tensor). The elements are tuples indicating which indices are involved in the antisymmetry. For the case of alternating tensors, `_antisym` is a list with a single element, since there is a single antisymmetry, the one corresponding to all possible permutations of the indices. This unique antisymmetry is encoded by the tuple `(0,1,...,p-1)`, `p` being the degree of the alternating tensor. So we must have `_antisym=[(0,1,...,p-1)]` in this case, with `(0,1,...,p-1)` being really a tuple of integers. What would be the advantage of using Python3 `range` in this context?



---

archive/issue_comments_321401.json:
```json
{
    "body": "I understand what the input for `antisym` is suppose to be. I guess the fundamental question is do you want to suppose iterators for the input, whether or not they give the tuples or a integers. I'm just worried about the shock when going to Python3. The option I'm suggesting I guess would be to just automatically run `antisym = list(antisym)` at the start of the `__init__` method. I'm leaning towards the principle of trying  to support `range` whenever possible. However, it is currently not a very strong opinion, so if you don't want to, then it's not something I will hold up this ticket for.",
    "created_at": "2017-06-11T13:53:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321401",
    "user": "@tscrim"
}
```

I understand what the input for `antisym` is suppose to be. I guess the fundamental question is do you want to suppose iterators for the input, whether or not they give the tuples or a integers. I'm just worried about the shock when going to Python3. The option I'm suggesting I guess would be to just automatically run `antisym = list(antisym)` at the start of the `__init__` method. I'm leaning towards the principle of trying  to support `range` whenever possible. However, it is currently not a very strong opinion, so if you don't want to, then it's not something I will hold up this ticket for.



---

archive/issue_comments_321402.json:
```json
{
    "body": "Replying to [comment:7 tscrim]:\n> I understand what the input for `antisym` is suppose to be. I guess the fundamental question is do you want to suppose iterators for the input, whether or not they give the tuples or a integers. I'm just worried about the shock when going to Python3. The option I'm suggesting I guess would be to just automatically run `antisym = list(antisym)` at the start of the `__init__` method. \nOK I see.\n> I'm leaning towards the principle of trying  to support `range` whenever possible. However, it is currently not a very strong opinion, so if you don't want to, then it's not something I will hold up this ticket for.\nOK.",
    "created_at": "2017-06-11T19:16:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321402",
    "user": "@egourgoulhon"
}
```

Replying to [comment:7 tscrim]:
> I understand what the input for `antisym` is suppose to be. I guess the fundamental question is do you want to suppose iterators for the input, whether or not they give the tuples or a integers. I'm just worried about the shock when going to Python3. The option I'm suggesting I guess would be to just automatically run `antisym = list(antisym)` at the start of the `__init__` method. 
OK I see.
> I'm leaning towards the principle of trying  to support `range` whenever possible. However, it is currently not a very strong opinion, so if you don't want to, then it's not something I will hold up this ticket for.
OK.



---

archive/issue_comments_321403.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-03T08:45:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321403",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_321404.json:
```json
{
    "body": "The commit in comment:9 gets rid of some `six.iteritems` and `six.itervalues` since the lack of iterator is not crucial in the Python2 version; `.items()` and `.values()` suffice: no significant loss of performance and this makes the `python3_py` plugin of the patchbot happy ;-).",
    "created_at": "2017-07-03T08:54:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321404",
    "user": "@egourgoulhon"
}
```

The commit in comment:9 gets rid of some `six.iteritems` and `six.itervalues` since the lack of iterator is not crucial in the Python2 version; `.items()` and `.values()` suffice: no significant loss of performance and this makes the `python3_py` plugin of the patchbot happy ;-).



---

archive/issue_comments_321405.json:
```json
{
    "body": "Are you going to support input of `range`? I think this would be good and means you don't have to wrap so many of those calls with `list`. I know it is a shorthand, but it still seems very nice to have. Also, I think it would be really good to support\n\n```\nresu.set_comp()[:] = range(1, self._rank+1)\n```\n\n\nBoth `_init_derived` and `_del_derived` are unnecessary since they are just super calls.\n\nThe changes to `tensor_with_indices.py` are unnecessary as in Python3:\n\n```python\n>>> def foo(a1,a2):\n...     print(a1, a2)\n... \n>>> foo(*range(2))\n0 1\n```\n\n\n\n```diff\ntype-(1,0)\ntype-`(1,0)`\n```\n\n\nRemove the commented code:\n\n```\n# From sage/modules/module.pyx:\n#-----------------------------\n### The Element should also implement _rmul_ (or _lmul_)\n#\n# class MyElement(sage.structure.element.ModuleElement):\n#     def _rmul_(self, c):\n#         ...\n```\n\n\nBreak the long line here:\n\n```diff\n     The class :class:`FiniteRankFreeModuleElement` inherits from\n-    :class:`~sage.tensor.modules.alternating_contr_tensor.AlternatingContrTensor` because the elements of a free module `M` of\n+    :class:`~sage.tensor.modules.alternating_contr_tensor.AlternatingContrTensor`\n+    because the elements of a free module `M` of\n     finite rank over a commutative ring `R` are identified with tensors of\n     type `(1,0)` on `M` via the canonical map\n```\n\n\nI think this looks better (I believe there are two instances of this):\n\n```diff\n*p-th exterior power of*\n`p`-*th exterior power of*\n```\n\n\nAre you concerned about dealing with old pickles? If so, have you checked that you can correctly unpickle a previous object? In particular, I think because you renamed the class, the old pickles will not create the correct class, but instead the dual version you constructed here. Although it might just be much more feasible (on our side) to deal with the backwards incompatibility instead.",
    "created_at": "2017-07-04T01:30:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321405",
    "user": "@tscrim"
}
```

Are you going to support input of `range`? I think this would be good and means you don't have to wrap so many of those calls with `list`. I know it is a shorthand, but it still seems very nice to have. Also, I think it would be really good to support

```
resu.set_comp()[:] = range(1, self._rank+1)
```


Both `_init_derived` and `_del_derived` are unnecessary since they are just super calls.

The changes to `tensor_with_indices.py` are unnecessary as in Python3:

```python
>>> def foo(a1,a2):
...     print(a1, a2)
... 
>>> foo(*range(2))
0 1
```



```diff
type-(1,0)
type-`(1,0)`
```


Remove the commented code:

```
# From sage/modules/module.pyx:
#-----------------------------
### The Element should also implement _rmul_ (or _lmul_)
#
# class MyElement(sage.structure.element.ModuleElement):
#     def _rmul_(self, c):
#         ...
```


Break the long line here:

```diff
     The class :class:`FiniteRankFreeModuleElement` inherits from
-    :class:`~sage.tensor.modules.alternating_contr_tensor.AlternatingContrTensor` because the elements of a free module `M` of
+    :class:`~sage.tensor.modules.alternating_contr_tensor.AlternatingContrTensor`
+    because the elements of a free module `M` of
     finite rank over a commutative ring `R` are identified with tensors of
     type `(1,0)` on `M` via the canonical map
```


I think this looks better (I believe there are two instances of this):

```diff
*p-th exterior power of*
`p`-*th exterior power of*
```


Are you concerned about dealing with old pickles? If so, have you checked that you can correctly unpickle a previous object? In particular, I think because you renamed the class, the old pickles will not create the correct class, but instead the dual version you constructed here. Although it might just be much more feasible (on our side) to deal with the backwards incompatibility instead.



---

archive/issue_comments_321406.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-06T13:19:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321406",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_321407.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-06T13:40:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321407",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_321408.json:
```json
{
    "body": "Replying to [comment:11 tscrim]:\n\nThanks for your comments!\n\n> Are you going to support input of `range`? I think this would be good and means you don't have to wrap so many of those calls with `list`. I know it is a shorthand, but it still seems very nice to have. \n\nDone! We have now:\n\n\n```\nsage: from six.moves import range\nsage: M = FiniteRankFreeModule(QQ, 3, name='M')\nsage: e = M.basis('e')\nsage: a = M.tensor((2,1), sym=range(2))\nsage: a.symmetries()\nsymmetry: (0, 1); no antisymmetry\nsage: b = M.tensor((0,3), antisym=range(3))\nsage: b.symmetries()\nno symmetry; antisymmetry: (0, 1, 2)\nsage: c = M.tensor((0,3), antisym=range(1,3))\nsage: c.symmetries()\nno symmetry; antisymmetry: (1, 2)\nsage: t = M.tensor((2,0))\nsage: t[:] = [[2,1,-3],[0,-4,5],[-1,4,2]]\nsage: s = t.symmetrize(*range(2))\nsage: s.symmetries()\nsymmetry: (0, 1); no antisymmetry\nsage: s == t.symmetrize(0,1)\nTrue\nsage: s = t.antisymmetrize(*range(2))\nsage: s.symmetries()\nno symmetry; antisymmetry: (0, 1)\nsage: s == t.antisymmetrize(0, 1)\nTrue\n```\n\n\n\n\n> Also, I think it would be really good to support\n> {{{\n> resu.set_comp()[:] = range(1, self._rank+1)\n> }}}\n\nDone as well; with the same settings as above, we have:\n\n\n```\nsage: v = M(range(3))\nsage: v.display()\ne_1 + 2 e_2\nsage: v.set_comp()[:] = range(1, 4)\nsage: v.display()\ne_0 + 2 e_1 + 3 e_2\n```\n\n\n> Both `_init_derived` and `_del_derived` are unnecessary since they are just super calls.\n> \n\nIndeed; I've removed them.\n\n> The changes to `tensor_with_indices.py` are unnecessary as in Python3:\n> {{{#!python\n> >>> def foo(a1,a2):\n> ...     print(a1, a2)\n> ... \n> >>> foo(*range(2))\n> 0 1\n> }}}\n\nThanks for pointing this out. I've restored the original version of `tensor_with_indices.py`.\n\n> \n> Remove the commented code:\n> {{{\n> # From sage/modules/module.pyx:\n> #-----------------------------\n> ### The Element should also implement _rmul_ (or _lmul_)\n> #\n> # class MyElement(sage.structure.element.ModuleElement):\n> #     def _rmul_(self, c):\n> #         ...\n> }}}\n\nDone. \n\n> \n> Break the long line here:\n> {{{#!diff\n>      The class :class:`FiniteRankFreeModuleElement` inherits from\n> -    :class:`~sage.tensor.modules.alternating_contr_tensor.AlternatingContrTensor` because the elements of a free module `M` of\n> +    :class:`~sage.tensor.modules.alternating_contr_tensor.AlternatingContrTensor`\n> +    because the elements of a free module `M` of\n>      finite rank over a commutative ring `R` are identified with tensors of\n>      type `(1,0)` on `M` via the canonical map\n> }}}\n\nDone.\n> \n> I think this looks better (I believe there are two instances of this):\n> {{{#!diff\n> *p-th exterior power of*\n> `p`-*th exterior power of*\n> }}}\n\n\nDone.\n\n> Are you concerned about dealing with old pickles? \n\nNot at all. I don't think anybody is unpickling old exterior powers of dual free modules. So we can safely ignore this. But thanks for pointing it. One shall indeed have this in mind when changing the name of a class.",
    "created_at": "2017-07-06T13:51:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321408",
    "user": "@egourgoulhon"
}
```

Replying to [comment:11 tscrim]:

Thanks for your comments!

> Are you going to support input of `range`? I think this would be good and means you don't have to wrap so many of those calls with `list`. I know it is a shorthand, but it still seems very nice to have. 

Done! We have now:


```
sage: from six.moves import range
sage: M = FiniteRankFreeModule(QQ, 3, name='M')
sage: e = M.basis('e')
sage: a = M.tensor((2,1), sym=range(2))
sage: a.symmetries()
symmetry: (0, 1); no antisymmetry
sage: b = M.tensor((0,3), antisym=range(3))
sage: b.symmetries()
no symmetry; antisymmetry: (0, 1, 2)
sage: c = M.tensor((0,3), antisym=range(1,3))
sage: c.symmetries()
no symmetry; antisymmetry: (1, 2)
sage: t = M.tensor((2,0))
sage: t[:] = [[2,1,-3],[0,-4,5],[-1,4,2]]
sage: s = t.symmetrize(*range(2))
sage: s.symmetries()
symmetry: (0, 1); no antisymmetry
sage: s == t.symmetrize(0,1)
True
sage: s = t.antisymmetrize(*range(2))
sage: s.symmetries()
no symmetry; antisymmetry: (0, 1)
sage: s == t.antisymmetrize(0, 1)
True
```




> Also, I think it would be really good to support
> {{{
> resu.set_comp()[:] = range(1, self._rank+1)
> }}}

Done as well; with the same settings as above, we have:


```
sage: v = M(range(3))
sage: v.display()
e_1 + 2 e_2
sage: v.set_comp()[:] = range(1, 4)
sage: v.display()
e_0 + 2 e_1 + 3 e_2
```


> Both `_init_derived` and `_del_derived` are unnecessary since they are just super calls.
> 

Indeed; I've removed them.

> The changes to `tensor_with_indices.py` are unnecessary as in Python3:
> {{{#!python
> >>> def foo(a1,a2):
> ...     print(a1, a2)
> ... 
> >>> foo(*range(2))
> 0 1
> }}}

Thanks for pointing this out. I've restored the original version of `tensor_with_indices.py`.

> 
> Remove the commented code:
> {{{
> # From sage/modules/module.pyx:
> #-----------------------------
> ### The Element should also implement _rmul_ (or _lmul_)
> #
> # class MyElement(sage.structure.element.ModuleElement):
> #     def _rmul_(self, c):
> #         ...
> }}}

Done. 

> 
> Break the long line here:
> {{{#!diff
>      The class :class:`FiniteRankFreeModuleElement` inherits from
> -    :class:`~sage.tensor.modules.alternating_contr_tensor.AlternatingContrTensor` because the elements of a free module `M` of
> +    :class:`~sage.tensor.modules.alternating_contr_tensor.AlternatingContrTensor`
> +    because the elements of a free module `M` of
>      finite rank over a commutative ring `R` are identified with tensors of
>      type `(1,0)` on `M` via the canonical map
> }}}

Done.
> 
> I think this looks better (I believe there are two instances of this):
> {{{#!diff
> *p-th exterior power of*
> `p`-*th exterior power of*
> }}}


Done.

> Are you concerned about dealing with old pickles? 

Not at all. I don't think anybody is unpickling old exterior powers of dual free modules. So we can safely ignore this. But thanks for pointing it. One shall indeed have this in mind when changing the name of a class.



---

archive/issue_comments_321409.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-06T14:20:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321409",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_321410.json:
```json
{
    "body": "Replying to [comment:11 tscrim]:\n>\n> {{{#!diff\n> type-(1,0)\n> type-`(1,0)`\n> }}}\n> \nDone. I've also changed the phrases like \n` of type (0,1) ` \nto \n` of type `(0,1)``.",
    "created_at": "2017-07-06T14:25:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321410",
    "user": "@egourgoulhon"
}
```

Replying to [comment:11 tscrim]:
>
> {{{#!diff
> type-(1,0)
> type-`(1,0)`
> }}}
> 
Done. I've also changed the phrases like 
` of type (0,1) ` 
to 
` of type `(0,1)``.



---

archive/issue_comments_321411.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-07-06T23:54:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321411",
    "user": "@tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_321412.json:
```json
{
    "body": "Great, thank you.",
    "created_at": "2017-07-06T23:54:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321412",
    "user": "@tscrim"
}
```

Great, thank you.



---

archive/issue_comments_321413.json:
```json
{
    "body": "Thank you very much for the review!",
    "created_at": "2017-07-07T05:54:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321413",
    "user": "@egourgoulhon"
}
```

Thank you very much for the review!



---

archive/issue_comments_321414.json:
```json
{
    "body": "I don't understand why the latest patchbot reports an issue with the `.. SEEALSO::` blocks in `alternating_contr_tensor.py` and `free_module_alt_form.py`; they seems correctly formed to me and the output html is fine. Moreover, in line 433 of https://github.com/sagemath/sage-patchbot/blob/master/sage_patchbot/plugins.py , it is written \n\n``` \n1) correct syntax is .. SEEALSO::\n```\n",
    "created_at": "2017-07-09T16:12:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321414",
    "user": "@egourgoulhon"
}
```

I don't understand why the latest patchbot reports an issue with the `.. SEEALSO::` blocks in `alternating_contr_tensor.py` and `free_module_alt_form.py`; they seems correctly formed to me and the output html is fine. Moreover, in line 433 of https://github.com/sagemath/sage-patchbot/blob/master/sage_patchbot/plugins.py , it is written 

``` 
1) correct syntax is .. SEEALSO::
```




---

archive/issue_comments_321415.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-07-26T22:13:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22970#issuecomment-321415",
    "user": "@vbraun"
}
```

Resolution: fixed
