# Issue 21826: precision problem in elliptic curve integral points

Issue created by migration from Trac.

Original creator: cremona

Original creation time: 2016-12-15 17:10:27

Keywords: integral points

As reported on sage-support, sometimes the integral_points() method for elliptic curves over Q misses solutions because of a precision problem in the final stage.  This can be fixed with a minor change which will be posted to this ticket.

Note that there is a larger related ticket #10973 which will fix other integral points issues.  This ticket should *not* wait until that one is finished.




---

Comment by cremona created at 2016-12-15 17:18:55

The function integral_points_with_bounded_mw_coefficients() is now more robust.  A doctest has been added to show that all the examples in Zagier's paper are now found, including the two in the original report on sage-support.
----
New commits:


---

Comment by cremona created at 2016-12-15 17:18:55

Changing status from new to needs_review.


---

Comment by chapoton created at 2016-12-15 18:20:37

you need to add 4 spaces before the added doctests


---

Comment by git created at 2016-12-15 20:17:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2016-12-15 20:19:13

Replying to [comment:2 chapoton]:
> you need to add 4 spaces before the added doctests
Sorry about that.  Clearly it has been a while since I did this...I have uploaded a new version, but have not yet rebuilt the docs as I had to do "make doc-clean".
----
New commits:


---

Comment by chapoton created at 2016-12-15 20:23:45

also you should use new-style doctest continuation `....:` instead of `...`

and do not use \ in the doc, but also `....:` to break your long line


---

Comment by cremona created at 2016-12-15 20:30:33

Is that really four dots before : ?

Is this written down somewhere?  Is tere an automatic test which I can run before making yet another commit with trivial typographical errors?  Why can't we have a script which goes through any of our files and fixes these issues for us?!  Isn't that what machines are for??!!


---

Comment by cremona created at 2016-12-15 20:34:04

Anyway, "make doc" takes so long that I will not wait but will upload yet another version just in case by some fluke I have the right number of dots and spaces correct this time.  How stupid.  I will not be spending any more time on this.


---

Comment by chapoton created at 2016-12-15 20:34:22

This is explained in http://doc.sagemath.org/html/en/developer/coding_basics.html
(see Multiline doctests).

And the patchbot will build the doc for you, and check some points, including this one.

Sorry, I did not mean to be unpleasant, only to try and help you to advance this ticket.


---

Comment by git created at 2016-12-15 20:34:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2016-12-16 16:20:52

I hope the doscstring is OK now.  No offence taken!  I just wish there were more automatic tools for this.


---

Comment by chapoton created at 2016-12-16 17:55:43

looks good.

note that you can shorten `all([something(x) for x in y])`
by writing `all(something(x) for x in y)`

apart from that, I can set a positive review if you want.


---

Comment by cremona created at 2016-12-16 18:00:39

Thanks (and yes please)


---

Comment by chapoton created at 2016-12-16 18:02:02

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2016-12-16 18:02:02

ok, let's go


---

Comment by drazioti created at 2016-12-18 02:01:34

checking the patch, for the following curve


```
sage:n=67
sage:E1=EllipticCurve([0,0,0,2,n^2]);E1;S=E1.integral_points();S;4*n^6+4*n^2
Elliptic Curve defined by y^2 = x^3 + 2*x + 4489 over Rational Field
[(-16 : 19 : 1),
 (-11 : 56 : 1),
 (0 : 67 : 1),
 (5 : 68 : 1),
 (12 : 79 : 1),
 (25 : 142 : 1),
 (252 : 4001 : 1),
 (424 : 8731 : 1),
 (724 : 19481 : 1),
 (940544 : 912155069 : 1)]
361833546632
```

misses the point 

```
(361833546632,217652291371861061).
```


Same for n=71,74 again one point is missing, 
But for n=91, two points are missing 

```
(299128 : 163600867 : 1),(2271477041288 : 3423438475922164973:1)
```


If we take prec=150, then we shall find all the points (in the previous examples).
Maybe it is better to set as default prec , say 200, instead of 100, to the function
_integral_points_with_bounded_mw_coeffs(E, mw_base, N, prec=100)._
Setting a constant prec, is very likely not to cover all the cases. For instance, 
the curve 

```
n=1400,E1=EllipticCurve([0,0,0,-2,n^2])
```

needs prec=220 to find all the points.

Maybe it is a good idea to pass the prec also in the original function
_integral_points()._

A _weird example_ is the following,


```
n=201
E1=EllipticCurve([0,0,0,-2,n^2]);E1;
S=E1.integral_points(verbose=True);S;4*n^6-4*n^2
```

provides


```
Using mw_basis  [(0 : 201 : 1), (-5286719/1134225 :
242521441696/1207949625 : 1)]
e1,e2,e3:  17.1664256413477 - 29.6994698252302*I 17.1664256413477 +
29.6994698252302*I -34.3328512826954
Minimal eigenvalue of height pairing matrix:  3.51647868931990
x-coords of points on non-compact component with  -34 <=x<= 68
[0]
starting search of remaining points using coefficient bound  2
x-coords of extra integral points:
[0]
Total number of integral points: 1
[(0 : 201 : 1)]
263776642243200

```

I used the following code to check the relation with the precision,


```
def int_points(E,N,prec):
    from sage.schemes.elliptic_curves.ell_rational_field import integral_points_with_bounded_mw_coeffs
    mw_base = E.gens()
    I = integral_points_with_bounded_mw_coeffs(E, mw_base, N, prec=prec)
    I=list(I)
    for i in range(len(I)):
        print E.lift_x(I[i])
```




```
sage:int_points(E1,2,200)
(0 : 201 : 1)
sage:int_points(E1,3,100)
(263776642243200 : 4284049728241222722999 : 1)
(0 : 201 : 1)
```

Seems that, this is not a precision problem but the bound N does not take the right value 3.


---

Comment by cremona created at 2016-12-18 14:03:23

Perhaps a better idea, which I will now try:  it would be easy for the calling function (i.e. E.integral_points()) to provide an upper bound for |x| for (x,y) any integral point, in terms of the MW coefficient bound, the rank and maximum eigenvalue of the height-pairing matrix (whose minimal eigenvalue is already used) together with a bound on the difference between naive and canonical heights.  Then the function we have been improving can use this to decide how many bits of precision are needed.

I think this would be better than just increasing the precision to be used arbitrarily, or leaving it to the user to do.


---

Comment by cremona created at 2016-12-18 16:11:48

Changing status from positive_review to needs_work.


---

Comment by cremona created at 2016-12-18 16:36:16

The idea sketched above seems to work, though without doing more numerical analysis it is hard to say how much precision is needed even with a bound on the size of the integral x-coordinates.  I am using 2* the number of bits in the upper bound (which is itself usually much larger than the actual largest value, for example in the n=1400 example my upper bound on x is about `6*10^66` or 222 bits and I use 444 bits but the actual large x-value is only 65 bits).

I agree with the last example above, where one of the integral points has a coefficient of 3 and is not found because the bound is wrongly computed as 2.   This is caused by a quite different bug, as I mentioned before, and I would prefer to get this precision question fixed first.

I will add some more tests and upload a new patch soon.


---

Comment by git created at 2016-12-18 17:29:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2016-12-18 17:34:41

The latest version adds more doctests (most of the examples mentioned above), and implements the method of computing the required real precision from a bound on the x-coordinates.  I also changed the function which processes real points to just round x and try to lift, rather then rounding both x and y and testing whether the rounded values satisfy the equation, since this is slightly slower but will be more robust since y is approximately `x^(3/2)` so would require 1.5 times the precision to get right.

I could avoid the issue of the coefficient bound being smaller than it should be (in some cases) by just adding one to the computed value, but I think that would be dishonest (and would slow down all the cases which currently work).

Back to "needs review".


---

Comment by cremona created at 2016-12-18 17:34:41

Changing status from needs_work to needs_review.


---

Comment by drazioti created at 2016-12-18 18:52:29

ok, the patch indeed fixes the problems with precision. 
The last example n=201, does not belong in this specific case.
Also, I found the following curves 

```
y^2=x^3+2*x+n^2, for n\in{190,204,208,215,224},
```

 that this last patch fails to find all the integer points. But as you already point out this concerns the ticket 10973. So I think, at least the original problem (concerning precision) was fixed.

Back to positive review! 

-----
Also, as fas as the previous examples that the patch fails, I am not sure that, this is (always) a problem concerning the bound N. I checked for various large values of N (for n=215,224) using the function _integral_points_with_bounded_mw_coeffs_ and I didn't manage to find the missed large integral point.


---

Comment by drazioti created at 2016-12-18 18:52:29

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-12-27 16:32:14

Resolution: fixed
