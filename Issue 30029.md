# Issue 30029: immutability for scalar fields

Issue created by migration from https://trac.sagemath.org/ticket/30266

Original creator: @mjungmath

Original creation time: 2020-08-01 12:56:35

CC:  egourgoulhon tscrim mkoeppe




---

Comment by @mjungmath created at 2020-08-01 12:59:41

Changing keywords from "" to "immutability".


---

Comment by @mjungmath created at 2020-08-01 12:59:41

Changing component from PLEASE CHANGE to manifolds.


---

Comment by @mjungmath created at 2020-08-01 12:59:41

Changing status from new to needs_review.


---

Comment by @mjungmath created at 2020-08-01 12:59:41

New commits:


---

Comment by @mjungmath created at 2020-08-01 12:59:41

Changing type from PLEASE CHANGE to enhancement.


---

Comment by @mjungmath created at 2020-08-01 13:03:37

Is the hash input okay? Or should it be something more unique?


---

Comment by mkoeppe created at 2020-08-01 13:21:54

Given that `ScalarField_repr_` does not print any contents, this hash does not seem to be useful to distinguish non-equal elements. This will degrade the performance of sets to that of lists.

More importantly, it must be ensured that `f == g` implies `hash(f) == hash(g)`. Because equality does not take names into account but `repr` does, this is currently not satisfied.


---

Comment by @mjungmath created at 2020-08-01 13:27:42

Replying to [comment:5 mkoeppe]:
> Given that `ScalarField_repr_` does not print any contents, this hash does not seem to be useful to distinguish non-equal elements. This will degrade the performance of sets to that of lists.
> 
> More importantly, it must be ensured that `f == g` implies `hash(f) == hash(g)`. Because equality does not take names into account but `repr` does, this is currently not satisfied.
> 

I just copied the ideas from the elsewhere in the Sage code. This means that most `hash` functions are implemented wrong.

Are you sure it is not `f is g` implies `hash(f) == hash(g)`? `f == g` implies `hash(f) == hash(g)` is barely possible in cases where coercions apply, isn't it?


---

Comment by mkoeppe created at 2020-08-01 13:31:55

Replying to [comment:6 gh-mjungmath]:
> Are you sure it is not `f is g` implies `hash(f) == hash(g)`? 

This implication is trivially true.


---

Comment by @mjungmath created at 2020-08-01 13:38:51

Replying to [comment:7 mkoeppe]:
> Replying to [comment:6 gh-mjungmath]:
> > Are you sure it is not `f is g` implies `hash(f) == hash(g)`? 
> 
> This implication is trivially true.

Oh, yes, this is obviously right. >.< :D


---

Comment by @mjungmath created at 2020-08-01 13:44:00

Replying to [comment:6 gh-mjungmath]:
> Replying to [comment:5 mkoeppe]:
> > Given that `ScalarField_repr_` does not print any contents, this hash does not seem to be useful to distinguish non-equal elements. This will degrade the performance of sets to that of lists.
> > 
> > More importantly, it must be ensured that `f == g` implies `hash(f) == hash(g)`. Because equality does not take names into account but `repr` does, this is currently not satisfied.
> > 
> 
> I just copied the ideas from the elsewhere in the Sage code. This means that most `hash` functions are implemented wrong.

Ah yes, I see, apparently that were cases where the string representation cannot be changed. Due to the fact that we allow restrictions as coercion, `hash(self._manifold)` seem to be the only choice.

I will add a related doctest for this particular case.

Thank you.


---

Comment by git created at 2020-08-01 14:15:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-08-01 14:15:39

This should be better.


---

Comment by @mjungmath created at 2020-08-02 09:59:53

Is that `hash` function okay? I have added a short `f == g` implies `hash(f) == hash(g)` test.

Patchbot is green, btw.


---

Comment by @mjungmath created at 2020-08-02 21:29:04

Since #30116, scalar fields can be compared on common domains. I added the check of the hash condition in the doctest for this particular comparison.


---

Comment by git created at 2020-08-02 21:31:05

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2020-08-02 21:36:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-08-03 09:02:14

Patchbot is green.


---

Comment by tscrim created at 2020-08-03 12:04:32

I believe for `_richcmp_` you also have `self is not other`, but you should double check this.


---

Comment by @mjungmath created at 2020-08-03 12:39:37

Replying to [comment:17 tscrim]:
> I believe for `_richcmp_` you also have `self is not other`, but you should double check this.

In #30116, I used `if self is other:` instead. Is that what you mean?


---

Comment by tscrim created at 2020-08-03 12:53:42

Replying to [comment:18 gh-mjungmath]:
> Replying to [comment:17 tscrim]:
> > I believe for `_richcmp_` you also have `self is not other`, but you should double check this.
> 
> In #30116, I used `if self is other:` instead. Is that what you mean?

Ah, I missed it there. Yes, I mean that, and I think it is unnecessary because the coercion framework through `__eq__` handles that case. However, I don't trust myself here, so it is worth checking.


---

Comment by @mjungmath created at 2020-08-03 13:35:18

I changed the whole `_richcmp_` to `return False` and tried `f == f`. It returned `False`. So, no prior instance check here. For fun, I did the same with the opposite: no prior check there, too.


---

Comment by git created at 2020-08-03 22:32:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-08-04 00:25:55

Replying to [comment:20 gh-mjungmath]:
> I changed the whole `_richcmp_` to `return False` and tried `f == f`. It returned `False`. So, no prior instance check here. For fun, I did the same with the opposite: no prior check there, too.

Thank you for checking. `:)`


---

Comment by tscrim created at 2020-08-04 00:27:25

Unfortunately I am too busy right now to do the review. I can probably do it next week, but if someone else wants to step up and do it, please go ahead.


---

Comment by @mjungmath created at 2020-08-04 07:52:53

One question btw: must `1 == f` also imply `hash(1) == hash(f)`. The former can be fulfilled due to the coercion framework, the latter is rather difficult since both have different types. Is it enough for this condition to be fulfilled for objects of the same type?


---

Comment by @mjungmath created at 2020-08-04 15:00:19

For the ring of integers modulo some number, this behavior is not satisfied:


```
sage: 3 == GF(2)(3)
True
sage: hash(3) == hash(GF(2)(3))
False
```



---

Comment by mkoeppe created at 2020-08-04 15:09:13

Ensuring that this implication holds across coercion is very difficult, and it is done in Sage on a "best effort" basis -- such as for QQ as the fraction field of ZZ.

The rule of thumb is that if we form sets, they should be of elements of the same parent so that no coercion is involved.  Likewise for the keys of dictionaries.


---

Comment by @mjungmath created at 2020-08-04 15:19:20

Replying to [comment:26 mkoeppe]:
> Ensuring that this implication holds across coercion is very difficult, and it is done in Sage on a "best effort" basis -- such as for QQ as the fraction field of ZZ.
> 
> The rule of thumb is that if we form sets, they should be of elements of the same parent so that no coercion is involved.  Likewise for the keys of dictionaries.

Since the restriction is set as a coercion, and they live in different sets, maybe we should make the hash more unique? Namely:


```diff
-        return hash((type(self).__name__, self._manifold))
+        return hash((type(self).__name__, self._domain))
```


If that is what we want, I will, of course, adapt the doctest section.


---

Comment by mkoeppe created at 2020-08-04 15:46:27

I haven't followed the discussion regarding restriction and equality, so I would need more context here.


---

Comment by @mjungmath created at 2020-08-04 15:54:42

Replying to [comment:28 mkoeppe]:
> I haven't followed the discussion regarding restriction and equality, so I would need more context here.

Sorry, sure. See #30116 for the discussion.

Manifolds allows coercions from scalar fields on `M` to scalar fields on `U`, where `U` is a subset of `M`, i.e. a restriction. Since #30116, the equality check compares scalar fields on a common subset and returns `True` if they are the same on that domain. Nevertheless, both scalar fields on different domains are still distinct objects defined in distinct sets.


---

Comment by mkoeppe created at 2020-08-04 16:01:52

You probably discussed this on that ticket, but this kind of "equality" relation is not transitive without strong assumptions such as analyticity and connectedness, is it?


---

Comment by @mjungmath created at 2020-08-04 16:18:42

Replying to [comment:30 mkoeppe]:
> You probably discussed this on that ticket, but this kind of "equality" relation is not transitive without strong assumptions such as analyticity and connectedness, is it?

Actually, we didn't. But that is a crucial point! Without analyticity, which is not necessarily given, the transitivity is definitely violated.

However, coercible objects have to be comparable, right?


---

Comment by mkoeppe created at 2020-08-04 16:23:04

In general I don't think you should feel obligated to use the coercion framework for comparisons just because you use it for arithmetic. It's just a tool.


---

Comment by @mjungmath created at 2020-08-04 16:26:13

Replying to [comment:32 mkoeppe]:
> In general I don't think you should feel obligated to use the coercion framework for comparisons just because you use it for arithmetic. It's just a tool.

Probably you're right. The documentation, however, is not very explicit on that. I changed the ticket above to "needs info" and left a question. Perhaps you can take a short look?


---

Comment by @mjungmath created at 2020-08-04 16:35:27

I just want to mention that your contributions are always very beneficial. Thank you very much! :)


---

Comment by mkoeppe created at 2020-08-04 16:46:45

But soon I'll start bothering you with lots of naive questions about differential geometry... ;)


---

Comment by @mjungmath created at 2020-08-04 16:56:25

Replying to [comment:35 mkoeppe]:
> But soon I'll start bothering you with lots of naive questions about differential geometry... ;)

That's only fair. ;)


---

Comment by @mjungmath created at 2020-08-04 17:04:42

I will remove the dependence from #30116 again.


---

Comment by git created at 2020-08-04 17:17:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-04 17:18:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-04 17:27:50

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @mjungmath created at 2020-08-04 17:28:50

Here we go. Let's see what our friend the patchbot says...


---

Comment by git created at 2020-08-04 17:50:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2020-08-04 20:24:38

Patchbot is satisfied.


---

Comment by mkoeppe created at 2020-08-04 21:46:10

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-08-09 08:47:24

Resolution: fixed
