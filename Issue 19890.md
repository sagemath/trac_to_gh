# Issue 19890: test_relation: uncaught NoConvergence

archive/issues_019890.json:
```json
{
    "body": "CC:  @cheuberg @dkrenn @rwst\n\nTesting the following expression for zero randomly results in a `NoConvergence` error being thrown from `mpmath`:\n\n\n```\nsage: var('k')\nk\nsage: bool(gamma(k*pi) * zetaderiv(1, k*pi*I)/log(2)^2 == 0)\nFalse\n```\n\n\nor\n\n\n```\nsage: bool(gamma(k*pi) * zetaderiv(1, k*pi*I)/log(2)^2 == 0)\nTraceback (most recent call last):\n...\nNoConvergence: zeta: too much cancellation\n```\n\n\nThis ticket adds this error to the list of caught errors in `test_relation`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/20127\n\n",
    "created_at": "2016-02-27T07:20:30Z",
    "labels": [
        "symbolics",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.1",
    "title": "test_relation: uncaught NoConvergence",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19890",
    "user": "@behackl"
}
```
CC:  @cheuberg @dkrenn @rwst

Testing the following expression for zero randomly results in a `NoConvergence` error being thrown from `mpmath`:


```
sage: var('k')
k
sage: bool(gamma(k*pi) * zetaderiv(1, k*pi*I)/log(2)^2 == 0)
False
```


or


```
sage: bool(gamma(k*pi) * zetaderiv(1, k*pi*I)/log(2)^2 == 0)
Traceback (most recent call last):
...
NoConvergence: zeta: too much cancellation
```


This ticket adds this error to the list of caught errors in `test_relation`.

Issue created by migration from https://trac.sagemath.org/ticket/20127





---

archive/issue_comments_273502.json:
```json
{
    "body": "New commits:",
    "created_at": "2016-02-29T06:20:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273502",
    "user": "@behackl"
}
```

New commits:



---

archive/issue_comments_273503.json:
```json
{
    "body": "Looks fine, can you please add a doctest?",
    "created_at": "2016-03-05T07:13:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273503",
    "user": "@rwst"
}
```

Looks fine, can you please add a doctest?



---

archive/issue_comments_273504.json:
```json
{
    "body": "In principle I could, yes. However, the simplest (reliable) doctest I can construct takes about 25 sec., and that's not really ideal. I'd really like to understand why this takes so much time.",
    "created_at": "2016-03-08T11:43:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273504",
    "user": "@behackl"
}
```

In principle I could, yes. However, the simplest (reliable) doctest I can construct takes about 25 sec., and that's not really ideal. I'd really like to understand why this takes so much time.



---

archive/issue_comments_273505.json:
```json
{
    "body": "Which code would that be? Have you tried callgrind? I tried to confirm the random behaviour of the above but the first 16 tries all gave False. Do you have a reliable example?",
    "created_at": "2016-03-08T14:29:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273505",
    "user": "@rwst"
}
```

Which code would that be? Have you tried callgrind? I tried to confirm the random behaviour of the above but the first 16 tries all gave False. Do you have a reliable example?



---

archive/issue_comments_273506.json:
```json
{
    "body": "Replying to [comment:4 rws]:\n> Which code would that be? Have you tried callgrind? I tried to confirm the random behaviour of the above but the first 16 tries all gave False. Do you have a reliable example?\n\nCould you try it with the following expression? This is the original one which brought me to this error. If it works (which is rarely; maybe one out of 20 times on my laptop here), it takes several seconds.\n\n```\nsage: bool(gamma(2 + k*pi*I/log(2)) * zetaderiv(1, 1+k*pi*I/log(2))/log(2)^10 == 0)\n```\n",
    "created_at": "2016-03-08T14:43:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273506",
    "user": "@behackl"
}
```

Replying to [comment:4 rws]:
> Which code would that be? Have you tried callgrind? I tried to confirm the random behaviour of the above but the first 16 tries all gave False. Do you have a reliable example?

Could you try it with the following expression? This is the original one which brought me to this error. If it works (which is rarely; maybe one out of 20 times on my laptop here), it takes several seconds.

```
sage: bool(gamma(2 + k*pi*I/log(2)) * zetaderiv(1, 1+k*pi*I/log(2))/log(2)^10 == 0)
```




---

archive/issue_comments_273507.json:
```json
{
    "body": "I get 10 times immediately False with develop. I can even do\n\n```\nsage: %timeit assert not bool(gamma(2 + k*pi*I/log(2)) * zetaderiv(1,1+k*pi*I/log(2))/log(2)^10 == 0)\n10 loops, best of 3: 45.3 ms per loop\n```\n",
    "created_at": "2016-03-08T14:48:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273507",
    "user": "@rwst"
}
```

I get 10 times immediately False with develop. I can even do

```
sage: %timeit assert not bool(gamma(2 + k*pi*I/log(2)) * zetaderiv(1,1+k*pi*I/log(2))/log(2)^10 == 0)
10 loops, best of 3: 45.3 ms per loop
```




---

archive/issue_comments_273508.json:
```json
{
    "body": "I think the difference to your result is that I had a command `k = var('k', domain='complex')` instead of `k = var('k')`. With the latter I can confirm the issue. I thought I needed complex because I used `k` as integer before that. Now isn't the default complex anyway? It gets more mysterious.",
    "created_at": "2016-03-08T15:07:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273508",
    "user": "@rwst"
}
```

I think the difference to your result is that I had a command `k = var('k', domain='complex')` instead of `k = var('k')`. With the latter I can confirm the issue. I thought I needed complex because I used `k` as integer before that. Now isn't the default complex anyway? It gets more mysterious.



---

archive/issue_comments_273509.json:
```json
{
    "body": "Replying to [comment:5 behackl]:\n> Could you try it with the following expression? This is the original one which brought me to this error. If it works (which is rarely; maybe one out of 20 times on my laptop here), it takes several seconds.\n> {{{\n> sage: bool(gamma(2 + k*pi*I/log(2)) * zetaderiv(1, 1+k*pi*I/log(2))/log(2)^10 == 0)\n> }}}\n\n\n```\nfrom datetime import datetime\nvar('k')\n\nfor _ in range(10):\n    tic = datetime.now()\n    try:\n        result = bool(gamma(2 + k*pi*I/log(2)) * zetaderiv(1, 1+k*pi*I/log(2))/log(2)^10 == 0)\n    except Exception as e:\n        print datetime.now()-tic, 'exception:', e\n    else:\n        print datetime.now()-tic, 'successful:', result\n```\n\nreturns\n\n```\n0:00:11.445669 exception: zeta: too much cancellation\n0:00:08.250215 exception: zeta: too much cancellation\n0:00:03.706793 exception: zeta: too much cancellation\n0:00:02.428823 successful: False\n0:00:00.757367 successful: False\n0:00:16.853168 exception: zeta: too much cancellation\n0:00:00.228982 successful: False\n0:00:03.824248 successful: False\n0:00:37.852729 exception: zeta: too much cancellation\n0:00:15.264686 exception: zeta: too much cancellation\n```\n\nSeems like I am lucky to get that much exceptions ;)",
    "created_at": "2016-03-08T15:24:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273509",
    "user": "@dkrenn"
}
```

Replying to [comment:5 behackl]:
> Could you try it with the following expression? This is the original one which brought me to this error. If it works (which is rarely; maybe one out of 20 times on my laptop here), it takes several seconds.
> {{{
> sage: bool(gamma(2 + k*pi*I/log(2)) * zetaderiv(1, 1+k*pi*I/log(2))/log(2)^10 == 0)
> }}}


```
from datetime import datetime
var('k')

for _ in range(10):
    tic = datetime.now()
    try:
        result = bool(gamma(2 + k*pi*I/log(2)) * zetaderiv(1, 1+k*pi*I/log(2))/log(2)^10 == 0)
    except Exception as e:
        print datetime.now()-tic, 'exception:', e
    else:
        print datetime.now()-tic, 'successful:', result
```

returns

```
0:00:11.445669 exception: zeta: too much cancellation
0:00:08.250215 exception: zeta: too much cancellation
0:00:03.706793 exception: zeta: too much cancellation
0:00:02.428823 successful: False
0:00:00.757367 successful: False
0:00:16.853168 exception: zeta: too much cancellation
0:00:00.228982 successful: False
0:00:03.824248 successful: False
0:00:37.852729 exception: zeta: too much cancellation
0:00:15.264686 exception: zeta: too much cancellation
```

Seems like I am lucky to get that much exceptions ;)



---

archive/issue_comments_273510.json:
```json
{
    "body": "See #14305. Variables may by default be complex in Pynac, but they are not in Maxima, which is (still) used by `__nonzero__` (see #19040).",
    "created_at": "2016-03-08T15:28:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273510",
    "user": "@rwst"
}
```

See #14305. Variables may by default be complex in Pynac, but they are not in Maxima, which is (still) used by `__nonzero__` (see #19040).



---

archive/issue_comments_273511.json:
```json
{
    "body": "The exception happens when executing `test_relation()`. With `domain='complex'` `test_relation()` is not called at all because then the assumption `(k, 'complex')` has to be taken into account so Maxima is called for proof which, remarkably, is faster here and correct.\n\nHowever what happens with the original case is that in `test_relation()` random substitutions into the relation are performed to see if the resulting values differ. One substitution that causes the exception is for example `{k: -312.363505734545? + 152.010201758413?*I}` so you can get the exception with the code `(gamma(2 + k*pi*I/log(2)) * zetaderiv(1,1+k*pi*I/log(2))/log(2)^10 == 0).subs({k: CIF(-312.363505734545 + 152.010201758413*I)}).n()` reliably.",
    "created_at": "2016-03-08T16:06:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273511",
    "user": "@rwst"
}
```

The exception happens when executing `test_relation()`. With `domain='complex'` `test_relation()` is not called at all because then the assumption `(k, 'complex')` has to be taken into account so Maxima is called for proof which, remarkably, is faster here and correct.

However what happens with the original case is that in `test_relation()` random substitutions into the relation are performed to see if the resulting values differ. One substitution that causes the exception is for example `{k: -312.363505734545? + 152.010201758413?*I}` so you can get the exception with the code `(gamma(2 + k*pi*I/log(2)) * zetaderiv(1,1+k*pi*I/log(2))/log(2)^10 == 0).subs({k: CIF(-312.363505734545 + 152.010201758413*I)}).n()` reliably.



---

archive/issue_comments_273512.json:
```json
{
    "body": "Coincidentally, this solves my original problem. However, I still think that the fact that this\n\n```\nsage: zetaderiv(1, CIF(-600)).n()\n```\n\nis both very slow and raises the `NoConvergence`-error is a problem.\n\nIs it possible to use a numerically more stable version of the derivative of the zeta function? Maybe someone knowing more about this numerical stuff could help with this.",
    "created_at": "2016-03-08T16:30:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273512",
    "user": "@behackl"
}
```

Coincidentally, this solves my original problem. However, I still think that the fact that this

```
sage: zetaderiv(1, CIF(-600)).n()
```

is both very slow and raises the `NoConvergence`-error is a problem.

Is it possible to use a numerically more stable version of the derivative of the zeta function? Maybe someone knowing more about this numerical stuff could help with this.



---

archive/issue_comments_273513.json:
```json
{
    "body": "Change of title and component suggested so interested people find it better.",
    "created_at": "2016-03-09T09:06:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273513",
    "user": "@rwst"
}
```

Change of title and component suggested so interested people find it better.



---

archive/issue_comments_273514.json:
```json
{
    "body": "Changing component from symbolics to numerical.",
    "created_at": "2016-03-09T09:14:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273514",
    "user": "@behackl"
}
```

Changing component from symbolics to numerical.



---

archive/issue_comments_273515.json:
```json
{
    "body": "Arb can compute derivatives of the zeta function without difficulty. E.g. with my own python-flint interface, I can do\n\n\n```\n>>> ctx.cap = 10\n>>> acb_series([-600,1]).zeta()\n([7.82232679749e+928 +/- 8.22e+916])*x + ([-3.56689160315e+929 +/- 4.12e+917])*x^2 + ([7.8112800125e+929 +/- 5.34e+918])*x^3 + ([-1.08969439943e+930 +/- 6.02e+918])*x^4 + ([1.07928682824e+930 +/- 9.55e+918])*x^5 + ([-7.957487571e+929 +/- 4.23e+919])*x^6 + ([4.390792240e+929 +/- 6.15e+919])*x^7 + ([-1.700332217e+929 +/- 6.11e+919])*x^8 + ([3.04336993e+928 +/- 6.00e+919])*x^9 + O(x^10)\n```\n\n\nwhich takes 0.1 milliseconds.\n\nThis would be easier to wrap with a Sage wrapper for Arb power series in place, but it should not be too hard to do directly either: see `acb_poly_zeta_series` and `arb_poly_zeta_series`.\n\nIn the left half plane, `mpmath.diff(mpmath.zeta, s, n)` could also be used instead of `mpmath.zeta(s, 1, n)`.\n\nIt's a bit worrying that `zetaderiv` currently accepts CIF input and outputs a *nonrigorous* CIF without warning, by going through a plain numerical computation. It is easy to produce examples where the output is plain *wrong*:\n\n\n```\nsage: q = CIF(\"2.46316186945432128587439505331\", \"23.2983204927628579020109616266\")\nsage: zetaderiv(1,q)\n-3.8826886735960628?e-17 - 7.4180200774526877?e-17*I\nsage: q = ComplexIntervalField(128)(\"2.46316186945432128587439505331\", \"23.2983204927628579020109616266\")\nsage: zetaderiv(1,q)\n2.809208149461043895562049836274827424167?e-31 + 4.678424144202694674839595616043132108038?e-32*I\n```\n\n\nAre there other Sage functions that treat intervals as carelessly?",
    "created_at": "2016-03-09T12:02:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19890",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19890#issuecomment-273515",
    "user": "@fredrik-johansson"
}
```

Arb can compute derivatives of the zeta function without difficulty. E.g. with my own python-flint interface, I can do


```
>>> ctx.cap = 10
>>> acb_series([-600,1]).zeta()
([7.82232679749e+928 +/- 8.22e+916])*x + ([-3.56689160315e+929 +/- 4.12e+917])*x^2 + ([7.8112800125e+929 +/- 5.34e+918])*x^3 + ([-1.08969439943e+930 +/- 6.02e+918])*x^4 + ([1.07928682824e+930 +/- 9.55e+918])*x^5 + ([-7.957487571e+929 +/- 4.23e+919])*x^6 + ([4.390792240e+929 +/- 6.15e+919])*x^7 + ([-1.700332217e+929 +/- 6.11e+919])*x^8 + ([3.04336993e+928 +/- 6.00e+919])*x^9 + O(x^10)
```


which takes 0.1 milliseconds.

This would be easier to wrap with a Sage wrapper for Arb power series in place, but it should not be too hard to do directly either: see `acb_poly_zeta_series` and `arb_poly_zeta_series`.

In the left half plane, `mpmath.diff(mpmath.zeta, s, n)` could also be used instead of `mpmath.zeta(s, 1, n)`.

It's a bit worrying that `zetaderiv` currently accepts CIF input and outputs a *nonrigorous* CIF without warning, by going through a plain numerical computation. It is easy to produce examples where the output is plain *wrong*:


```
sage: q = CIF("2.46316186945432128587439505331", "23.2983204927628579020109616266")
sage: zetaderiv(1,q)
-3.8826886735960628?e-17 - 7.4180200774526877?e-17*I
sage: q = ComplexIntervalField(128)("2.46316186945432128587439505331", "23.2983204927628579020109616266")
sage: zetaderiv(1,q)
2.809208149461043895562049836274827424167?e-31 + 4.678424144202694674839595616043132108038?e-32*I
```


Are there other Sage functions that treat intervals as carelessly?
