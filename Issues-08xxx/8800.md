# Issue 8800: Doctest coverage of categories - numerous coercion fixes

archive/issues_008800.json:
```json
{
    "body": "According to William, the doctest coverage of categories is too low:\n\n```\naction.pyx: 0% (0 of 31)\nfunctor.pyx: 17% (3 of 17)\nmap.pyx: 27% (10 of 37)\nmorphism.pyx: 20% (5 of 24)\npushout.py: 24% (19 of 77) \n```\n\nThe original purpose of this ticket was to provide full doctest coverage for `functor.pyx` and `pushout.py`. **The doctest coverage of both files is now 100%**.\n\n\nHowever, the attempt to create meaningful doctests uncovered many bugs in various parts of Sage, and also motivated the implementation of coercion for various algebraic structures for which this has not been done before.\n\nThis a-posteriori ticket description lists the bugs killed and the features added by the patch, which should apply (with a little fuzz) after the patch from #8807. For more details on the bugs, see the comments below.\n\n1. Bug: Creating `ForgetfulFunctor` fails.\n\n   Was:\n\n  ```\n  sage: abgrps = CommutativeAdditiveGroups()\n  sage: ForgetfulFunctor(abgrps, abgrps)\n  ---------------------------------------------------------------------------\n  TypeError                                 Traceback (most recent call last)\n  \n  /home/king/SAGE/patches/doku/english/<ipython console> in <module>()\n  \n  /home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/functor.so in sage.categories.functor.ForgetfulFunctor (sage/categories/functor.c:2083)()\n  \n  TypeError: IdentityFunctor() takes exactly one argument (2 given)\n   ```\n\n   Now:\n\n  ```\n  sage: abgrps = CommutativeAdditiveGroups()\n  sage: ForgetfulFunctor(abgrps, abgrps)\n  The identity functor on Category of commutative additive groups\n   ```\n\n2. Bug: Applying `ForgetfulFunctor` returns `None`.\n\n   Was:\n\n  ```\n  sage: fields = Fields()\n  sage: rings = Rings()\n  sage: F = ForgetfulFunctor(fields,rings)\n  sage: F(QQ)\n   ```\n\n   Now:\n\n  ```\n  sage: fields = Fields()\n  sage: rings = Rings()\n  sage: F = ForgetfulFunctor(fields,rings)\n  sage: F(QQ)\n  Rational Field\n   ```\n\n3. Bug: Applying a functor does not complain if the argument is not contained in the domain.\n\n   Was:\n\n  ```\n  sage: fields = Fields()\n  sage: rings = Rings()\n  sage: F = ForgetfulFunctor(fields,rings)\n  # Yields None, see previous bug\n  sage: F(ZZ['x','y'])\n   ```\n\n   Now:\n\n  ```\n  sage: fields = Fields()\n  sage: rings = Rings()\n  sage: F = ForgetfulFunctor(fields,rings)\n  sage: F(ZZ['x','y'])\n  Traceback (most recent call last):\n  ...\n  TypeError: x (=Multivariate Polynomial Ring in x, y over Integer Ring) is not in Category of fields\n   ```\n\n4. Bug: Comparing identity functor with any functor only checks domain and codomain\n\n   Was:\n\n  ```\n  sage: F = QQ['x'].construction()[0]\n  sage: F\n  Poly[x]\n  sage: F == IdentityFunctor(Rings())\n  False\n  sage: IdentityFunctor(Rings()) == F\n  True\n   ```\n\n   Now:\n\n  ```\n  sage: F = QQ['x'].construction()[0]\n  sage: F\n  Poly[x]\n  sage: F == IdentityFunctor(Rings())\n  False\n  sage: IdentityFunctor(Rings()) == F\n  False\n   ```\n\n5. Bug: Comparing identity functor with anything that is not a functor produces an error\n\n   Was:\n\n  ```\n  sage: IdentityFunctor(Rings()) == QQ\n  Traceback (most recent call last):\n  ...\n  AttributeError: 'RationalField_with_category' object has no attribute 'domain'\n   ```\n\n   Now:\n\n  ```\n  sage: IdentityFunctor(Rings()) == QQ\n  False\n   ```\n\n6. Bug: The matrix functor is ill defined; moreover, ill-definedness does not result in an error.\n\n   Was:\n\n  ```\n  sage: F = MatrixSpace(ZZ,2,3).construction()[0]\n  sage: F(RR) in F.codomain()\n  False\n  # The codomain is wrong for non-square matrices!\n  sage: F.codomain()\n  Category of rings\n   ```\n\n   Now:\n\n  ```\n  sage: F = MatrixSpace(ZZ,2,3).construction()[0]\n  sage: F.codomain()\n  Category of commutative additive groups\n  sage: F(RR) in F.codomain()\n  True\n  sage: F = MatrixSpace(ZZ,2,2).construction()[0]\n  sage: F.codomain()\n  Category of rings\n  sage: F(RR) in F.codomain()\n  True\n   ```\n\n7. Bug: Wrong domain for `VectorFunctor`; and again, functors don't test if the domain is appropriate\n\n   Was:\n\n  ```\n  sage: F = FreeModule(ZZ,3).construction()[0]\n  sage: F\n  VectorFunctor\n  sage: F.domain()\n  Category of objects\n  sage: F.codomain()\n  Category of objects\n  sage: Set([1,2,3]) in F.domain()\n  True\n  sage: F(Set([1,2,3]))\n  Traceback (most recent call last):\n  ...\n  AttributeError: 'Set_object_enumerated' object has no attribute 'is_commutative'\n   ```\n\n   Now:\n\n  ```\n  sage: F = FreeModule(ZZ,3).construction()[0]\n  sage: F\n  VectorFunctor\n  sage: F.domain()\n  Category of commutative rings\n  sage: Set([1,2,3]) in F.domain()\n  False\n  sage: F(Set([1,2,3]))\n  Traceback (most recent call last):\n  ...\n  TypeError: x (={1, 2, 3}) is not in Category of commutative rings\n   ```\n\n8. Bug: `BlackBoxConstructionFunctor` is completely unusable\n\n`BlackBoxConstructionFunctor` should be a class, but is defined as a function. Moreover, the given init method is not using the init method of `ConstructionFunctor`. And the cmp method would raise an error if the second argument has no attribute `.box`. \n\n  The following did not work at all:\n\n  ```\n  sage: from sage.categories.pushout import BlackBoxConstructionFunctor\n  sage: FG = BlackBoxConstructionFunctor(gap)\n  sage: FS = BlackBoxConstructionFunctor(singular)\n  sage: FG\n  BlackBoxConstructionFunctor\n  sage: FG(ZZ)\n  Integers\n  sage: FG(ZZ).parent()\n  Gap\n  sage: FS(QQ['t'])\n  //   characteristic : 0\n  //   number of vars : 1\n  //        block   1 : ordering lp\n  //                  : names    t\n  //        block   2 : ordering C\n  sage: FG == FS\n  False\n  sage: FG == loads(dumps(FG))\n  True\n```\n\n9. Nitpicking: The `LocalizationFunctor` is nowhere used (yet)\n\nHence, I removed it.\n\n10. Bug / New Feature: Make completion and and fraction field construction functors commute.\n\nThe result of them not commuting is the following coercion bug.\n\n  Was:\n\n  ```\n  sage: R1.<x> = Zp(5)[]\n  sage: R2 = Qp(5)\n  sage: R2(1)+x\n  Traceback (most recent call last):\n  ...\n  TypeError: unsupported operand parent(s) for '+': '5-adic Field with capped relative precision 20' and 'Univariate Polynomial Ring in x over 5-adic Ring with capped relative precision 20'\n  ```\n\n  Now:\n\n  ```\n  sage: R1.<x> = Zp(5)[]\n  sage: R2 = Qp(5)\n  sage: R2(1)+x\n  (1 + O(5^20))*x + (1 + O(5^20))\n  ```\n\n11. New feature: Make the completion functor work on some objects that do not provide a completion method.\n\nThe idea is to use that the completion functor may commute with the construction of the given argument. That may safe the day.\n\n  Was:\n\n  ```\n  sage: P.<x> = ZZ[]\n  sage: C = P.completion(x).construction()[0]\n  sage: R = FractionField(P)\n  sage: hasattr(R,'completion')\n  False\n  sage: C(R)\n  Traceback (most recent  call last):\n  ...\n  AttributeError: 'FractionField_generic' object has no attribute 'completion'\n  ```\n\n  Now:\n\n  ```\n  sage: P.<x> = ZZ[]\n  sage: C = P.completion(x).construction()[0]\n  sage: R = FractionField(P)\n  sage: hasattr(R,'completion')\n  False\n  sage: C(R)\n  Fraction Field of Power Series Ring in x over Integer Ring\n  ```\n\n12. Bug / new feature: Coercion for free modules, taking into account a user-defined inner product\n\n   Was:\n\n  ```\n  sage: P.<t> = ZZ[]\n  sage: M1 = FreeModule(P,3)\n  sage: M2 = QQ^3\n  sage: M2([1,1/2,1/3]) + M1([t,t^2+t,3])     # This is ok\n  (t + 1, t^2 + t + 1/2, 10/3)\n  sage: M3 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,range(9)))\n  sage: M2([1,1/2,1/3]) + M3([t,t^2+t,3])     # This is ok\n  (t + 1, t^2 + t + 1/2, 10/3)\n  # The user defined inner product matrix is lost! Bug\n  sage: parent(M2([1,1/2,1/3]) + M3([t,t^2+t,3])).inner_product_matrix()\n  [1 0 0]\n  [0 1 0]\n  [0 0 1]\n   ```\n\n   Now:\n\n  ```\n  sage: parent(M2([1,1/2,1/3]) + M3([t,t^2+t,3])).inner_product_matrix()\n  [0 1 2]\n  [3 4 5]\n  [6 7 8]\n   ```\n\n   However, the real problem is that modules are not part of the coercion model. I tried to implement it, but that turned out to be a can of worms. So, **I suggest to deal with it on a different ticket**. Here is one bug that isn't removed, yet:\n\n  ```\n  sage: M4 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,[1,1,1,0,1,1,0,0,1]))\n  sage: M3([t,1,t^2]) + M4([t,t^2+t,3])     # This should result in an error\n  (2*t, t^2 + t + 1, t^2 + 3)\n   ```\n   Note that there should be no coercion between `M3` and `M4`, since they have different user-defined inner product matrices.\n\n\n23. Bug / new feature: Quotient rings of univariate polynomial rings do not have a construction method.\n\n   Was:\n\n  ```\n  sage: P.<x> = QQ[]\n  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])\n  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])\n  sage: from sage.categories.pushout import pushout\n  sage: pushout(Q1,Q2)\n  Traceback (most recent call last):\n  ...\n  CoercionException: No common base\n   ```\n\n   Now:\n\n  ```\n  sage: P.<x> = QQ[]\n  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])\n  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])\n  sage: from sage.categories.pushout import pushout\n  sage: pushout(Q1,Q2)\n  Univariate Quotient Polynomial Ring in xbar over Rational Field with modulus x^4 + 2*x^2 + 1\n   ```\n\n34. Insufficient coercion of quotient rings, if one modulus divides the other\n\n   Was:\n\n  ```\n  sage: P5.<x> = GF(5)[]\n  sage: Q = P5.quo([(x^2+1)^2])\n  sage: P.<x> = ZZ[]\n  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])\n  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])\n  sage: Q.has_coerce_map_from(Q1)\n  False\n   ```\n\n   Now: There is a coercion from `Q1` to `Q`.\n\n45. Coercion of `GF(p)` versus `Integers(p)`\n\nI am not sure if this is really a bug.\n\n  Was:\n\n  ```\n  sage: from sage.categories.pushout import pushout\n  sage: pushout(GF(5), Integers(5))\n  Ring of integers modulo 5\n  ```\n\n  Now\n\n  ```\n  sage: from sage.categories.pushout import pushout\n  sage: pushout(GF(5), Integers(5))\n  Finite Field of size 5\n  ```\n\n16. Bug / new feature: Construction for QQbar was missing.\n\n   Now:\n\n  ```\n  sage: QQbar.construction()\n  (AlgebraicClosureFunctor, Rational Field)\n   ```\n\n27. Bug / new feature: Construction for number fields is missing.\n\nThis became a rather complicated topic, including \"coercions for embedded versus non-embedded number fields and coercion for an order from a coercion from the ambient field\", \"pushout for number fields\", \"comparison of fractional ideals\", \"identity of residue fields\". See three discussions on sage-algebra and sage-nt\n* [Bidirectional coercions](http://groups.google.com/group/sage-nt/browse_thread/thread/32b65a5173f43267)\n* [Coercions for number fields](http://groups.google.com/group/sage-nt/browse_thread/thread/5c376dbf7e99ea97)\n* [Comparison of fractional ideals](http://groups.google.com/group/sage-nt/browse_thread/thread/54c1e33872d14334)\n\n__Coercion__\n\nImportant for the discussion is: What will we do with embeddings? \n\nCurrently, the embedding of two number fields is used to construct a coercion (compatible with the embedding). Of course, the given embedding is also used as a coerce map.\n\nIt was discussed to additionally have a \"forgetful\" coercion from an embedded to a non-embedded number field.\n\nIt turned out that with bidirectional and forgetful coercions together, one can construct examples in which the coercions do not form a commutative diagram. Hence, we do *not* introduce forgetful coercions here.\n\nHowever, some improvement of the existing implementation was needed.\n\n  Was:\n\n  ```\n  sage: K.<r4> = NumberField(x^4-2)\n  sage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)\n  sage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)\n  sage: r2_1+r2_2    # indirect doctest\n  ERROR: An unexpected error occurred while tokenizing input\n  The following traceback may be corrupted or invalid\n  The error message is: ('EOF in multi-line statement', (1109, 0))\n  \n  ERROR: An unexpected error occurred while tokenizing input\n  The following traceback may be corrupted or invalid\n  The error message is: ('EOF in multi-line statement', (1109, 0))\n  \n  ...\n  sage: K.has_coerce_map_from(L1.maximal_order())\n  False   # that's the wrong direction.\n  sage: L1.has_coerce_map_from(K.maximal_order())\n  True\n  ```\n\n  Now:\n\n  ```\n  sage: K.<r4> = NumberField(x^4-2)\n  sage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)\n  sage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)\n  sage: r2_1+r2_2    # indirect doctest\n  0\n  sage: (r2_1+r2_2).parent() is L1\n  True\n  sage: (r2_2+r2_1).parent() is L2\n  True\n  sage: K.has_coerce_map_from(L1.maximal_order())\n  True\n  sage: L1.has_coerce_map_from(K.maximal_order())\n  False\n  ```\n\n__Pushout__\n\n  Was:\n\n  ```\n  sage: P.<x> = QQ[]\n  sage: L.<b> = NumberField(x^8-x^4+1, embedding=CDF.0)\n  sage: M1.<c1> = NumberField(x^2+x+1, embedding=b^4-1)\n  sage: M2.<c2> = NumberField(x^2+1, embedding=-b^6)\n  sage: M1.coerce_map_from(M2)\n  sage: M2.coerce_map_from(M1)\n  sage: c1+c2; parent(c1+c2)    #indirect doctest\n  Traceback (most recent call last):\n  ...\n  TypeError: unsupported operand parent(s) for '+': 'Number Field in c1 with defining polynomial x^2 + x + 1' and 'Number Field in c2 with defining polynomial x^2 + 1'\n  sage: from sage.categories.pushout import pushout\n  sage: pushout(M1['x'],M2['x'])\n  Traceback (most recent call last):\n  ...\n  CoercionException: No common base\n  ```\n\n  Now: Note that we will only have a pushout if the codomains of the embeddings are number fields. Hence, in the second example, we won't use `CDF` as a pushout.\n\n  ```\n  sage: P.<x> = QQ[]\n  sage: L.<b> = NumberField(x^8-x^4+1, embedding=CDF.0)\n  sage: M1.<c1> = NumberField(x^2+x+1, embedding=b^4-1)\n  sage: M2.<c2> = NumberField(x^2+1, embedding=-b^6)\n  sage: M1.coerce_map_from(M2)\n  sage: M2.coerce_map_from(M1)\n  sage: c1+c2; parent(c1+c2)    #indirect doctest\n  -b^6 + b^4 - 1\n  Number Field in b with defining polynomial x^8 - x^4 + 1\n  sage: from sage.categories.pushout import pushout\n  sage: pushout(M1['x'],M2['x'])\n  Univariate Polynomial Ring in x over Number Field in b with defining polynomial x^8 - x^4 + 1\n  sage: K.<a> = NumberField(x^3-2, embedding=CDF(1/2*I*2^(1/3)*sqrt(3) - 1/2*2^(1/3)))\n  sage: L.<b> = NumberField(x^6-2, embedding=1.1)\n  sage: L.coerce_map_from(K)\n  sage: K.coerce_map_from(L)\n  sage: pushout(K,L)\n  Traceback (most recent call last):\n  ...\n  CoercionException: ('Ambiguous Base Extension', Number Field in a with defining polynomial x^3 - 2, Number Field in b with defining polynomial x^6 - 2)\n```\n\n__Comparison of fractional ideals / identity of Residue Fields__\n\n  Fractional ideals have a `__cmp__` method that only took into account the Hermite normal form. Originally, the comparison of fractional ideals by \"==\" and by \"cmp\" yields different results. Since \"==\" of fractional ideals is used for caching residue fields, but \"cmp\" was used for comparing residue fields, the residue fields did not provide unique parents.\n\n  Was:\n\n  ```\n  sage: L.<b> = NumberField(x^8-x^4+1)\n  sage: F_2 = L.fractional_ideal(b^2-1)\n  sage: F_4 = L.fractional_ideal(b^4-1)\n  sage: F_2==F_4\n  True\n  sage: K.<r4> = NumberField(x^4-2)\n  sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)\n  sage: FK = K.fractional_ideal(K.0)\n  sage: FL = L.fractional_ideal(L.0)\n  sage: FK != FL\n  True\n  sage: RL = ResidueField(FL)\n  sage: RK = ResidueField(FK)\n  sage: RK is RL\n  False\n  sage: RK == RL\n  True\n  ```\n\n  Now:\n\n  ```\n  sage: L.<b> = NumberField(x^8-x^4+1)\n  sage: F_2 = L.fractional_ideal(b^2-1)\n  sage: F_4 = L.fractional_ideal(b^4-1)\n  sage: F_2==F_4\n  True\n  sage: K.<r4> = NumberField(x^4-2)\n  sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)\n  sage: FK = K.fractional_ideal(K.0)\n  sage: FL = L.fractional_ideal(L.0)\n  sage: FK != FL\n  True\n  sage: RL = ResidueField(FL)\n  sage: RK = ResidueField(FK)\n  sage: RK is RL\n  False\n  sage: RK == RL\n  False\n  ```\n\n  Since `RL` is defined with the embedded field `L`, not with the unembedded `K`, there is no coercion from the order of `K` to `RL`. However, *conversion* works (this used to fail!):\n\n  ```\n  sage: OK = K.maximal_order()\n  sage: RL.has_coerce_map_from(OK)\n  False\n  sage: RL(OK.1)\n  0\n  ```\n\n  Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal. This assumption should still hold (since we do not introduce forgetful coercion), but I think it is OK to keep the change in _tate.\n\n**Apply:**\n1. [attachment:8800_functor_pushout_doc_and_fixes.patch](https://github.com/sagemath/sage/files/ticket8800/8800_functor_pushout_doc_and_fixes.patch)\n2. [attachment:referee.patch](https://github.com/sagemath/sage/files/ticket8800/referee.patch)\n\n**Dependencies:** #10677, #2329.\n\n**Assignee:** Simon King\n\n**Keywords:** categories doctests\n\n**Author:** Simon King\n\n**Reviewer:** Luis Felipe Tabera Alonso\n\n**Merged:** sage-4.7.alpha1\n\nIssue created by migration from https://trac.sagemath.org/ticket/8800\n\n",
    "closed_at": "2011-03-08T21:45:09Z",
    "created_at": "2010-04-28T08:47:56Z",
    "labels": [
        "component: categories",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-4.7",
    "title": "Doctest coverage of categories - numerous coercion fixes",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/8800",
    "user": "https://github.com/simon-king-jena"
}
```
According to William, the doctest coverage of categories is too low:

```
action.pyx: 0% (0 of 31)
functor.pyx: 17% (3 of 17)
map.pyx: 27% (10 of 37)
morphism.pyx: 20% (5 of 24)
pushout.py: 24% (19 of 77) 
```

The original purpose of this ticket was to provide full doctest coverage for `functor.pyx` and `pushout.py`. **The doctest coverage of both files is now 100%**.


However, the attempt to create meaningful doctests uncovered many bugs in various parts of Sage, and also motivated the implementation of coercion for various algebraic structures for which this has not been done before.

This a-posteriori ticket description lists the bugs killed and the features added by the patch, which should apply (with a little fuzz) after the patch from #8807. For more details on the bugs, see the comments below.

1. Bug: Creating `ForgetfulFunctor` fails.

   Was:

  ```
  sage: abgrps = CommutativeAdditiveGroups()
  sage: ForgetfulFunctor(abgrps, abgrps)
  ---------------------------------------------------------------------------
  TypeError                                 Traceback (most recent call last)
  
  /home/king/SAGE/patches/doku/english/<ipython console> in <module>()
  
  /home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/functor.so in sage.categories.functor.ForgetfulFunctor (sage/categories/functor.c:2083)()
  
  TypeError: IdentityFunctor() takes exactly one argument (2 given)
   ```

   Now:

  ```
  sage: abgrps = CommutativeAdditiveGroups()
  sage: ForgetfulFunctor(abgrps, abgrps)
  The identity functor on Category of commutative additive groups
   ```

2. Bug: Applying `ForgetfulFunctor` returns `None`.

   Was:

  ```
  sage: fields = Fields()
  sage: rings = Rings()
  sage: F = ForgetfulFunctor(fields,rings)
  sage: F(QQ)
   ```

   Now:

  ```
  sage: fields = Fields()
  sage: rings = Rings()
  sage: F = ForgetfulFunctor(fields,rings)
  sage: F(QQ)
  Rational Field
   ```

3. Bug: Applying a functor does not complain if the argument is not contained in the domain.

   Was:

  ```
  sage: fields = Fields()
  sage: rings = Rings()
  sage: F = ForgetfulFunctor(fields,rings)
  # Yields None, see previous bug
  sage: F(ZZ['x','y'])
   ```

   Now:

  ```
  sage: fields = Fields()
  sage: rings = Rings()
  sage: F = ForgetfulFunctor(fields,rings)
  sage: F(ZZ['x','y'])
  Traceback (most recent call last):
  ...
  TypeError: x (=Multivariate Polynomial Ring in x, y over Integer Ring) is not in Category of fields
   ```

4. Bug: Comparing identity functor with any functor only checks domain and codomain

   Was:

  ```
  sage: F = QQ['x'].construction()[0]
  sage: F
  Poly[x]
  sage: F == IdentityFunctor(Rings())
  False
  sage: IdentityFunctor(Rings()) == F
  True
   ```

   Now:

  ```
  sage: F = QQ['x'].construction()[0]
  sage: F
  Poly[x]
  sage: F == IdentityFunctor(Rings())
  False
  sage: IdentityFunctor(Rings()) == F
  False
   ```

5. Bug: Comparing identity functor with anything that is not a functor produces an error

   Was:

  ```
  sage: IdentityFunctor(Rings()) == QQ
  Traceback (most recent call last):
  ...
  AttributeError: 'RationalField_with_category' object has no attribute 'domain'
   ```

   Now:

  ```
  sage: IdentityFunctor(Rings()) == QQ
  False
   ```

6. Bug: The matrix functor is ill defined; moreover, ill-definedness does not result in an error.

   Was:

  ```
  sage: F = MatrixSpace(ZZ,2,3).construction()[0]
  sage: F(RR) in F.codomain()
  False
  # The codomain is wrong for non-square matrices!
  sage: F.codomain()
  Category of rings
   ```

   Now:

  ```
  sage: F = MatrixSpace(ZZ,2,3).construction()[0]
  sage: F.codomain()
  Category of commutative additive groups
  sage: F(RR) in F.codomain()
  True
  sage: F = MatrixSpace(ZZ,2,2).construction()[0]
  sage: F.codomain()
  Category of rings
  sage: F(RR) in F.codomain()
  True
   ```

7. Bug: Wrong domain for `VectorFunctor`; and again, functors don't test if the domain is appropriate

   Was:

  ```
  sage: F = FreeModule(ZZ,3).construction()[0]
  sage: F
  VectorFunctor
  sage: F.domain()
  Category of objects
  sage: F.codomain()
  Category of objects
  sage: Set([1,2,3]) in F.domain()
  True
  sage: F(Set([1,2,3]))
  Traceback (most recent call last):
  ...
  AttributeError: 'Set_object_enumerated' object has no attribute 'is_commutative'
   ```

   Now:

  ```
  sage: F = FreeModule(ZZ,3).construction()[0]
  sage: F
  VectorFunctor
  sage: F.domain()
  Category of commutative rings
  sage: Set([1,2,3]) in F.domain()
  False
  sage: F(Set([1,2,3]))
  Traceback (most recent call last):
  ...
  TypeError: x (={1, 2, 3}) is not in Category of commutative rings
   ```

8. Bug: `BlackBoxConstructionFunctor` is completely unusable

`BlackBoxConstructionFunctor` should be a class, but is defined as a function. Moreover, the given init method is not using the init method of `ConstructionFunctor`. And the cmp method would raise an error if the second argument has no attribute `.box`. 

  The following did not work at all:

  ```
  sage: from sage.categories.pushout import BlackBoxConstructionFunctor
  sage: FG = BlackBoxConstructionFunctor(gap)
  sage: FS = BlackBoxConstructionFunctor(singular)
  sage: FG
  BlackBoxConstructionFunctor
  sage: FG(ZZ)
  Integers
  sage: FG(ZZ).parent()
  Gap
  sage: FS(QQ['t'])
  //   characteristic : 0
  //   number of vars : 1
  //        block   1 : ordering lp
  //                  : names    t
  //        block   2 : ordering C
  sage: FG == FS
  False
  sage: FG == loads(dumps(FG))
  True
```

9. Nitpicking: The `LocalizationFunctor` is nowhere used (yet)

Hence, I removed it.

10. Bug / New Feature: Make completion and and fraction field construction functors commute.

The result of them not commuting is the following coercion bug.

  Was:

  ```
  sage: R1.<x> = Zp(5)[]
  sage: R2 = Qp(5)
  sage: R2(1)+x
  Traceback (most recent call last):
  ...
  TypeError: unsupported operand parent(s) for '+': '5-adic Field with capped relative precision 20' and 'Univariate Polynomial Ring in x over 5-adic Ring with capped relative precision 20'
  ```

  Now:

  ```
  sage: R1.<x> = Zp(5)[]
  sage: R2 = Qp(5)
  sage: R2(1)+x
  (1 + O(5^20))*x + (1 + O(5^20))
  ```

11. New feature: Make the completion functor work on some objects that do not provide a completion method.

The idea is to use that the completion functor may commute with the construction of the given argument. That may safe the day.

  Was:

  ```
  sage: P.<x> = ZZ[]
  sage: C = P.completion(x).construction()[0]
  sage: R = FractionField(P)
  sage: hasattr(R,'completion')
  False
  sage: C(R)
  Traceback (most recent  call last):
  ...
  AttributeError: 'FractionField_generic' object has no attribute 'completion'
  ```

  Now:

  ```
  sage: P.<x> = ZZ[]
  sage: C = P.completion(x).construction()[0]
  sage: R = FractionField(P)
  sage: hasattr(R,'completion')
  False
  sage: C(R)
  Fraction Field of Power Series Ring in x over Integer Ring
  ```

12. Bug / new feature: Coercion for free modules, taking into account a user-defined inner product

   Was:

  ```
  sage: P.<t> = ZZ[]
  sage: M1 = FreeModule(P,3)
  sage: M2 = QQ^3
  sage: M2([1,1/2,1/3]) + M1([t,t^2+t,3])     # This is ok
  (t + 1, t^2 + t + 1/2, 10/3)
  sage: M3 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,range(9)))
  sage: M2([1,1/2,1/3]) + M3([t,t^2+t,3])     # This is ok
  (t + 1, t^2 + t + 1/2, 10/3)
  # The user defined inner product matrix is lost! Bug
  sage: parent(M2([1,1/2,1/3]) + M3([t,t^2+t,3])).inner_product_matrix()
  [1 0 0]
  [0 1 0]
  [0 0 1]
   ```

   Now:

  ```
  sage: parent(M2([1,1/2,1/3]) + M3([t,t^2+t,3])).inner_product_matrix()
  [0 1 2]
  [3 4 5]
  [6 7 8]
   ```

   However, the real problem is that modules are not part of the coercion model. I tried to implement it, but that turned out to be a can of worms. So, **I suggest to deal with it on a different ticket**. Here is one bug that isn't removed, yet:

  ```
  sage: M4 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,[1,1,1,0,1,1,0,0,1]))
  sage: M3([t,1,t^2]) + M4([t,t^2+t,3])     # This should result in an error
  (2*t, t^2 + t + 1, t^2 + 3)
   ```
   Note that there should be no coercion between `M3` and `M4`, since they have different user-defined inner product matrices.


23. Bug / new feature: Quotient rings of univariate polynomial rings do not have a construction method.

   Was:

  ```
  sage: P.<x> = QQ[]
  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])
  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])
  sage: from sage.categories.pushout import pushout
  sage: pushout(Q1,Q2)
  Traceback (most recent call last):
  ...
  CoercionException: No common base
   ```

   Now:

  ```
  sage: P.<x> = QQ[]
  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])
  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])
  sage: from sage.categories.pushout import pushout
  sage: pushout(Q1,Q2)
  Univariate Quotient Polynomial Ring in xbar over Rational Field with modulus x^4 + 2*x^2 + 1
   ```

34. Insufficient coercion of quotient rings, if one modulus divides the other

   Was:

  ```
  sage: P5.<x> = GF(5)[]
  sage: Q = P5.quo([(x^2+1)^2])
  sage: P.<x> = ZZ[]
  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])
  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])
  sage: Q.has_coerce_map_from(Q1)
  False
   ```

   Now: There is a coercion from `Q1` to `Q`.

45. Coercion of `GF(p)` versus `Integers(p)`

I am not sure if this is really a bug.

  Was:

  ```
  sage: from sage.categories.pushout import pushout
  sage: pushout(GF(5), Integers(5))
  Ring of integers modulo 5
  ```

  Now

  ```
  sage: from sage.categories.pushout import pushout
  sage: pushout(GF(5), Integers(5))
  Finite Field of size 5
  ```

16. Bug / new feature: Construction for QQbar was missing.

   Now:

  ```
  sage: QQbar.construction()
  (AlgebraicClosureFunctor, Rational Field)
   ```

27. Bug / new feature: Construction for number fields is missing.

This became a rather complicated topic, including "coercions for embedded versus non-embedded number fields and coercion for an order from a coercion from the ambient field", "pushout for number fields", "comparison of fractional ideals", "identity of residue fields". See three discussions on sage-algebra and sage-nt
* [Bidirectional coercions](http://groups.google.com/group/sage-nt/browse_thread/thread/32b65a5173f43267)
* [Coercions for number fields](http://groups.google.com/group/sage-nt/browse_thread/thread/5c376dbf7e99ea97)
* [Comparison of fractional ideals](http://groups.google.com/group/sage-nt/browse_thread/thread/54c1e33872d14334)

__Coercion__

Important for the discussion is: What will we do with embeddings? 

Currently, the embedding of two number fields is used to construct a coercion (compatible with the embedding). Of course, the given embedding is also used as a coerce map.

It was discussed to additionally have a "forgetful" coercion from an embedded to a non-embedded number field.

It turned out that with bidirectional and forgetful coercions together, one can construct examples in which the coercions do not form a commutative diagram. Hence, we do *not* introduce forgetful coercions here.

However, some improvement of the existing implementation was needed.

  Was:

  ```
  sage: K.<r4> = NumberField(x^4-2)
  sage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)
  sage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)
  sage: r2_1+r2_2    # indirect doctest
  ERROR: An unexpected error occurred while tokenizing input
  The following traceback may be corrupted or invalid
  The error message is: ('EOF in multi-line statement', (1109, 0))
  
  ERROR: An unexpected error occurred while tokenizing input
  The following traceback may be corrupted or invalid
  The error message is: ('EOF in multi-line statement', (1109, 0))
  
  ...
  sage: K.has_coerce_map_from(L1.maximal_order())
  False   # that's the wrong direction.
  sage: L1.has_coerce_map_from(K.maximal_order())
  True
  ```

  Now:

  ```
  sage: K.<r4> = NumberField(x^4-2)
  sage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)
  sage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)
  sage: r2_1+r2_2    # indirect doctest
  0
  sage: (r2_1+r2_2).parent() is L1
  True
  sage: (r2_2+r2_1).parent() is L2
  True
  sage: K.has_coerce_map_from(L1.maximal_order())
  True
  sage: L1.has_coerce_map_from(K.maximal_order())
  False
  ```

__Pushout__

  Was:

  ```
  sage: P.<x> = QQ[]
  sage: L.<b> = NumberField(x^8-x^4+1, embedding=CDF.0)
  sage: M1.<c1> = NumberField(x^2+x+1, embedding=b^4-1)
  sage: M2.<c2> = NumberField(x^2+1, embedding=-b^6)
  sage: M1.coerce_map_from(M2)
  sage: M2.coerce_map_from(M1)
  sage: c1+c2; parent(c1+c2)    #indirect doctest
  Traceback (most recent call last):
  ...
  TypeError: unsupported operand parent(s) for '+': 'Number Field in c1 with defining polynomial x^2 + x + 1' and 'Number Field in c2 with defining polynomial x^2 + 1'
  sage: from sage.categories.pushout import pushout
  sage: pushout(M1['x'],M2['x'])
  Traceback (most recent call last):
  ...
  CoercionException: No common base
  ```

  Now: Note that we will only have a pushout if the codomains of the embeddings are number fields. Hence, in the second example, we won't use `CDF` as a pushout.

  ```
  sage: P.<x> = QQ[]
  sage: L.<b> = NumberField(x^8-x^4+1, embedding=CDF.0)
  sage: M1.<c1> = NumberField(x^2+x+1, embedding=b^4-1)
  sage: M2.<c2> = NumberField(x^2+1, embedding=-b^6)
  sage: M1.coerce_map_from(M2)
  sage: M2.coerce_map_from(M1)
  sage: c1+c2; parent(c1+c2)    #indirect doctest
  -b^6 + b^4 - 1
  Number Field in b with defining polynomial x^8 - x^4 + 1
  sage: from sage.categories.pushout import pushout
  sage: pushout(M1['x'],M2['x'])
  Univariate Polynomial Ring in x over Number Field in b with defining polynomial x^8 - x^4 + 1
  sage: K.<a> = NumberField(x^3-2, embedding=CDF(1/2*I*2^(1/3)*sqrt(3) - 1/2*2^(1/3)))
  sage: L.<b> = NumberField(x^6-2, embedding=1.1)
  sage: L.coerce_map_from(K)
  sage: K.coerce_map_from(L)
  sage: pushout(K,L)
  Traceback (most recent call last):
  ...
  CoercionException: ('Ambiguous Base Extension', Number Field in a with defining polynomial x^3 - 2, Number Field in b with defining polynomial x^6 - 2)
```

__Comparison of fractional ideals / identity of Residue Fields__

  Fractional ideals have a `__cmp__` method that only took into account the Hermite normal form. Originally, the comparison of fractional ideals by "==" and by "cmp" yields different results. Since "==" of fractional ideals is used for caching residue fields, but "cmp" was used for comparing residue fields, the residue fields did not provide unique parents.

  Was:

  ```
  sage: L.<b> = NumberField(x^8-x^4+1)
  sage: F_2 = L.fractional_ideal(b^2-1)
  sage: F_4 = L.fractional_ideal(b^4-1)
  sage: F_2==F_4
  True
  sage: K.<r4> = NumberField(x^4-2)
  sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)
  sage: FK = K.fractional_ideal(K.0)
  sage: FL = L.fractional_ideal(L.0)
  sage: FK != FL
  True
  sage: RL = ResidueField(FL)
  sage: RK = ResidueField(FK)
  sage: RK is RL
  False
  sage: RK == RL
  True
  ```

  Now:

  ```
  sage: L.<b> = NumberField(x^8-x^4+1)
  sage: F_2 = L.fractional_ideal(b^2-1)
  sage: F_4 = L.fractional_ideal(b^4-1)
  sage: F_2==F_4
  True
  sage: K.<r4> = NumberField(x^4-2)
  sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)
  sage: FK = K.fractional_ideal(K.0)
  sage: FL = L.fractional_ideal(L.0)
  sage: FK != FL
  True
  sage: RL = ResidueField(FL)
  sage: RK = ResidueField(FK)
  sage: RK is RL
  False
  sage: RK == RL
  False
  ```

  Since `RL` is defined with the embedded field `L`, not with the unembedded `K`, there is no coercion from the order of `K` to `RL`. However, *conversion* works (this used to fail!):

  ```
  sage: OK = K.maximal_order()
  sage: RL.has_coerce_map_from(OK)
  False
  sage: RL(OK.1)
  0
  ```

  Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal. This assumption should still hold (since we do not introduce forgetful coercion), but I think it is OK to keep the change in _tate.

**Apply:**
1. [attachment:8800_functor_pushout_doc_and_fixes.patch](https://github.com/sagemath/sage/files/ticket8800/8800_functor_pushout_doc_and_fixes.patch)
2. [attachment:referee.patch](https://github.com/sagemath/sage/files/ticket8800/referee.patch)

**Dependencies:** #10677, #2329.

**Assignee:** Simon King

**Keywords:** categories doctests

**Author:** Simon King

**Reviewer:** Luis Felipe Tabera Alonso

**Merged:** sage-4.7.alpha1

Issue created by migration from https://trac.sagemath.org/ticket/8800





---

archive/issue_comments_073434.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n-According to William at the doctest coverage of categories is too low:\n+According to William, the doctest coverage of categories is too low:\n \n ```\n action.pyx: 0% (0 of 31)\n``````\n",
    "created_at": "2010-04-28T08:51:17Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73434",
    "user": "https://github.com/simon-king-jena"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
-According to William at the doctest coverage of categories is too low:
+According to William, the doctest coverage of categories is too low:
 
 ```
 action.pyx: 0% (0 of 31)
``````




---

archive/issue_comments_073435.json:
```json
{
    "body": "<a id='comment:2'></a>\nShouldn't the following raise an error, since the argument is not contained in the domain? Instead, it returns ``None``.\n\n```\nsage: fields = Fields()\nsage: rings = Rings()\nsage: F = ForgetfulFunctor(fields,rings)\nsage: F(ZZ['x','y'])\n```",
    "created_at": "2010-04-28T09:01:41Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73435",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Shouldn't the following raise an error, since the argument is not contained in the domain? Instead, it returns ``None``.

```
sage: fields = Fields()
sage: rings = Rings()
sage: F = ForgetfulFunctor(fields,rings)
sage: F(ZZ['x','y'])
```



---

archive/issue_comments_073436.json:
```json
{
    "body": "<a id='comment:3'></a>\nReplying to [SimonKing](#comment%3A2):\n> Shouldn't the following raise an error, since the argument is not contained in the domain? Instead, it returns ``None``.\n\n\nAnd this is because the generic ``__call__`` method of ``Functor`` has *no* return value! That's clearly a bug.",
    "created_at": "2010-04-28T09:06:39Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73436",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Replying to [SimonKing](#comment%3A2):
> Shouldn't the following raise an error, since the argument is not contained in the domain? Instead, it returns ``None``.


And this is because the generic ``__call__`` method of ``Functor`` has *no* return value! That's clearly a bug.



---

archive/issue_comments_073437.json:
```json
{
    "body": "<a id='comment:4'></a>\nNext bug:\n\n```\nsage: F = QQ['x'].construction()[0]\nsage: F\nPoly[x]\nsage: F == IdentityFunctor(Rings())\nFalse\nsage: IdentityFunctor(Rings()) == F\nTrue\n\n```\nThis is since the cmp method of ``IdentityFunctor_generic`` only checks whether domain and codomain coincide, but doesn't check the type of the functor.\n\nEven worse, comparison it may raise an error - how unpythonic!\n\n```\nsage: IdentityFunctor(Rings()) == QQ\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n\n/home/king/SAGE/patches/doku/english/<ipython console> in <module>()\n\n/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/functor.so in sage.categories.functor.ForgetfulFunctor_generic.__cmp__ (sage/categories/functor.c:1429)()\n\n/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/structure/parent.so in sage.structure.parent.Parent.__getattr__ (sage/structure/parent.c:5064)()\n\n/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/structure/parent.so in sage.structure.parent.getattr_from_other_class (sage/structure/parent.c:2738)()\n\n/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/structure/parent.so in sage.structure.parent.raise_attribute_error (sage/structure/parent.c:2610)()\n\nAttributeError: 'RationalField_with_category' object has no attribute 'domain'\n```",
    "created_at": "2010-04-28T09:51:13Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73437",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
Next bug:

```
sage: F = QQ['x'].construction()[0]
sage: F
Poly[x]
sage: F == IdentityFunctor(Rings())
False
sage: IdentityFunctor(Rings()) == F
True

```
This is since the cmp method of ``IdentityFunctor_generic`` only checks whether domain and codomain coincide, but doesn't check the type of the functor.

Even worse, comparison it may raise an error - how unpythonic!

```
sage: IdentityFunctor(Rings()) == QQ
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)

/home/king/SAGE/patches/doku/english/<ipython console> in <module>()

/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/functor.so in sage.categories.functor.ForgetfulFunctor_generic.__cmp__ (sage/categories/functor.c:1429)()

/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/structure/parent.so in sage.structure.parent.Parent.__getattr__ (sage/structure/parent.c:5064)()

/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/structure/parent.so in sage.structure.parent.getattr_from_other_class (sage/structure/parent.c:2738)()

/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/structure/parent.so in sage.structure.parent.raise_attribute_error (sage/structure/parent.c:2610)()

AttributeError: 'RationalField_with_category' object has no attribute 'domain'
```



---

archive/issue_comments_073438.json:
```json
{
    "body": "<a id='comment:5'></a>\nI think the call method of the class Functor is not cleanly implemented.\n\nIt seems intended that the user does not implement the call method. Instead s/he should implement _apply_functor, which is supposed to return an object in the functor's codomain.\n\nBefore using _apply_functor, the default call method tests whether the argument belongs to the domain. If this is not the case, it **coerces** the argument into the domain. I don't think that this is always wanted. E.g., the forgetful functor from fields to rings, when applied to the integer ring, currently returns the rational field (so, the forgetful functor *adds* structure), since the default call method first coerces the integer ring into the category of fields (which is done by the fraction field construction functor).\n\nI suggest to introduce a method _coerce_into_domain. By default, it returns its argument without change. If the user wants coercion into the domain (e.g. Integer Ring --> Rational Field), then s/he must implement it here.\n\nThe default call method should first apply _coerce_into_domain, check whether the result is in the domain (raise an error if this is not the case), then use _apply_functor, and check whether the result is in the codomain (and raise an error otherwise). And of course it should return the result (which was forgotten!).\n\nThoughts?",
    "created_at": "2010-04-28T11:16:40Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73438",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
I think the call method of the class Functor is not cleanly implemented.

It seems intended that the user does not implement the call method. Instead s/he should implement _apply_functor, which is supposed to return an object in the functor's codomain.

Before using _apply_functor, the default call method tests whether the argument belongs to the domain. If this is not the case, it **coerces** the argument into the domain. I don't think that this is always wanted. E.g., the forgetful functor from fields to rings, when applied to the integer ring, currently returns the rational field (so, the forgetful functor *adds* structure), since the default call method first coerces the integer ring into the category of fields (which is done by the fraction field construction functor).

I suggest to introduce a method _coerce_into_domain. By default, it returns its argument without change. If the user wants coercion into the domain (e.g. Integer Ring --> Rational Field), then s/he must implement it here.

The default call method should first apply _coerce_into_domain, check whether the result is in the domain (raise an error if this is not the case), then use _apply_functor, and check whether the result is in the codomain (and raise an error otherwise). And of course it should return the result (which was forgotten!).

Thoughts?



---

archive/issue_comments_073439.json:
```json
{
    "body": "<a id='comment:6'></a>\nIt meanwhile seems to me that an overhaul of the category framework is needed, in order to properly support working with morphisms and functors. I therefore opened #8807. \n\nIt could be that this ticket will eventually be 'absorbed' by #8807. We will see...",
    "created_at": "2010-04-28T18:24:46Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73439",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
It meanwhile seems to me that an overhaul of the category framework is needed, in order to properly support working with morphisms and functors. I therefore opened #8807. 

It could be that this ticket will eventually be 'absorbed' by #8807. We will see...



---

archive/issue_comments_073440.json:
```json
{
    "body": "<a id='comment:7'></a>\nI think it would be better to base this ticket on #8807, since I believe that #8807 should be merged soon anyway. \n\nContinuing with the doc tests, I think I found another bug, namely in the ``merge`` method of the Quotient construction functor:\n\n```\nsage: Q15,R = (ZZ.quo(15*ZZ)).construction()\nsage: Q15\nQuotientFunctor\nsage: Q35,R = (ZZ.quo(35*ZZ)).construction()\nsage: Q35\nQuotientFunctor\nsage: Q15.merge(Q35) is None\nTrue\nsage: from sage.categories.pushout import pushout\nsage: pushout(ZZ.quo(15*ZZ),ZZ.quo(35*ZZ))\n---------------------------------------------------------------------------\nCoercionException                         Traceback (most recent call last)\n\n/home/SimonKing/<ipython console> in <module>()\n\n/usr/local/sage/local/lib/python2.6/site-packages/sage/categories/pushout.pyc in pushout(R, S)\n   1099                         else:\n   1100                             # Otherwise, we cannot proceed.\n-> 1101                             raise CoercionException, (\"Ambiguous Base Extension\", R, S)\n   1102\n   1103         return all(Z)\n\nCoercionException: ('Ambiguous Base Extension', Ring of integers modulo 15, Ring of integers modulo 35)\n```\n\nThe reason is that internally ``Q35.I + Q15.I`` is tried, but this raises an error. It works with ``Q35.I.gcd(Q15.I)``, though. If I do this (in a patch that I will hopefully post in a few days, one gets (as one *should*, if I am not mistaken)\n\n```\nsage: pushout(ZZ.quo(15*ZZ),ZZ.quo(35*ZZ))\nRing of integers modulo 5\n```",
    "created_at": "2010-05-02T19:11:29Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73440",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
I think it would be better to base this ticket on #8807, since I believe that #8807 should be merged soon anyway. 

Continuing with the doc tests, I think I found another bug, namely in the ``merge`` method of the Quotient construction functor:

```
sage: Q15,R = (ZZ.quo(15*ZZ)).construction()
sage: Q15
QuotientFunctor
sage: Q35,R = (ZZ.quo(35*ZZ)).construction()
sage: Q35
QuotientFunctor
sage: Q15.merge(Q35) is None
True
sage: from sage.categories.pushout import pushout
sage: pushout(ZZ.quo(15*ZZ),ZZ.quo(35*ZZ))
---------------------------------------------------------------------------
CoercionException                         Traceback (most recent call last)

/home/SimonKing/<ipython console> in <module>()

/usr/local/sage/local/lib/python2.6/site-packages/sage/categories/pushout.pyc in pushout(R, S)
   1099                         else:
   1100                             # Otherwise, we cannot proceed.
-> 1101                             raise CoercionException, ("Ambiguous Base Extension", R, S)
   1102
   1103         return all(Z)

CoercionException: ('Ambiguous Base Extension', Ring of integers modulo 15, Ring of integers modulo 35)
```

The reason is that internally ``Q35.I + Q15.I`` is tried, but this raises an error. It works with ``Q35.I.gcd(Q15.I)``, though. If I do this (in a patch that I will hopefully post in a few days, one gets (as one *should*, if I am not mistaken)

```
sage: pushout(ZZ.quo(15*ZZ),ZZ.quo(35*ZZ))
Ring of integers modulo 5
```



---

archive/issue_comments_073441.json:
```json
{
    "body": "<a id='comment:8'></a>\nAnother bug that I plan to remove:\n\n```\nsage: F = MatrixSpace(ZZ,2,3).construction()[0]\nsage: F(RR) in F.codomain()\nFalse\n```\n\nThe problem is that the codomain of ``F`` is supposed to be the category of rings, even for non-square matrices. I'll change it to the following:\n\n```\nsage: MatrixSpace(ZZ,2,3).construction()[0].codomain()\nCategory of commutative additive groups\nsage: MatrixSpace(ZZ,2,2).construction()[0].codomain()\nCategory of rings\n```\n\nI'd actually like to have the category of modules (rather than of additive groups), but this would require a ring over which the module is defined (and which the functor obviously can't know).",
    "created_at": "2010-05-07T14:30:55Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73441",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Another bug that I plan to remove:

```
sage: F = MatrixSpace(ZZ,2,3).construction()[0]
sage: F(RR) in F.codomain()
False
```

The problem is that the codomain of ``F`` is supposed to be the category of rings, even for non-square matrices. I'll change it to the following:

```
sage: MatrixSpace(ZZ,2,3).construction()[0].codomain()
Category of commutative additive groups
sage: MatrixSpace(ZZ,2,2).construction()[0].codomain()
Category of rings
```

I'd actually like to have the category of modules (rather than of additive groups), but this would require a ring over which the module is defined (and which the functor obviously can't know).



---

archive/issue_comments_073442.json:
```json
{
    "body": "<a id='comment:9'></a>\nThe next one:\n\n```\nsage: F = FreeModule(ZZ,3).construction()[0]\nsage: F\nVectorFunctor\nsage: F.domain()\nCategory of objects\nsage: F.codomain()\nCategory of objects\nsage: Set([1,2,3]) in F.domain()\nTrue\nsage: F(Set([1,2,3]))\nTraceback (most recent call last):\n...\nAttributeError: 'Set_object_enumerated' object has no attribute 'is_commutative'\n```\n\nSince the functor calls the ``FreeModule`` constructor, and since this constructor expects a commutative ring, the Vector functor should go from the category of commutative rings to the category of commutative additive groups (since the category of modules requires naming a base ring).",
    "created_at": "2010-05-07T14:49:48Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73442",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
The next one:

```
sage: F = FreeModule(ZZ,3).construction()[0]
sage: F
VectorFunctor
sage: F.domain()
Category of objects
sage: F.codomain()
Category of objects
sage: Set([1,2,3]) in F.domain()
True
sage: F(Set([1,2,3]))
Traceback (most recent call last):
...
AttributeError: 'Set_object_enumerated' object has no attribute 'is_commutative'
```

Since the functor calls the ``FreeModule`` constructor, and since this constructor expects a commutative ring, the Vector functor should go from the category of commutative rings to the category of commutative additive groups (since the category of modules requires naming a base ring).



---

archive/issue_comments_073443.json:
```json
{
    "body": "<a id='comment:10'></a>\nNext bug:\n\n``BlackBoxConstructionFunctor`` should be a class, but is defined as a function. Moreover, the given init method is not using the init method of ``ConstructionFunctor``. And the cmp method would raise an error if the second argument has no attribute ``.box``.",
    "created_at": "2010-05-07T19:26:52Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73443",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:10'></a>
Next bug:

``BlackBoxConstructionFunctor`` should be a class, but is defined as a function. Moreover, the given init method is not using the init method of ``ConstructionFunctor``. And the cmp method would raise an error if the second argument has no attribute ``.box``.



---

archive/issue_comments_073444.json:
```json
{
    "body": "<a id='comment:11'></a>\nMerging ``AlgebraicClosureFunctor`` with *anything* else always yields the ``AlgebraicClosureFunctor``. I doubt that this was intended. There should be a merging with an ``AlgebraicExtensionFunctor``, though.",
    "created_at": "2010-05-07T20:02:31Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73444",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'></a>
Merging ``AlgebraicClosureFunctor`` with *anything* else always yields the ``AlgebraicClosureFunctor``. I doubt that this was intended. There should be a merging with an ``AlgebraicExtensionFunctor``, though.



---

archive/issue_comments_073445.json:
```json
{
    "body": "<a id='comment:12'></a>\nReplying to [SimonKing](#comment%3A11):\n> ... There should be a merging with an ``AlgebraicExtensionFunctor``, though.\n\n\n... which is nowhere used, though. I think the method ``construction`` for number fields should be defined.",
    "created_at": "2010-05-07T20:14:32Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73445",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:12'></a>
Replying to [SimonKing](#comment%3A11):
> ... There should be a merging with an ``AlgebraicExtensionFunctor``, though.


... which is nowhere used, though. I think the method ``construction`` for number fields should be defined.



---

archive/issue_comments_073446.json:
```json
{
    "body": "<a id='comment:13'></a>\n\n```\nsage: P.<x> = QQ[]\nsage: CC.extension(x^3+x^2+1,'a')\nUnivariate Quotient Polynomial Ring in a over Complex Field with 53 bits of precision with modulus a^3 + a^2 + 1.00000000000000\nsage: CDF.extension(x^3+x^2+1,'a')\nUnivariate Quotient Polynomial Ring in a over Complex Double Field with modulus a^3 + a^2 + 1.0\nsage: QQbar.extension(x^3+x^2+1,'a')\nUnivariate Quotient Polynomial Ring in a over Algebraic Field with modulus a^3 + a^2 + 1\n```\n\nAren't the three above fields algebraically complete? So, I guess the ``extension`` method should be modified to take this into account.",
    "created_at": "2010-05-08T09:39:41Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73446",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:13'></a>

```
sage: P.<x> = QQ[]
sage: CC.extension(x^3+x^2+1,'a')
Univariate Quotient Polynomial Ring in a over Complex Field with 53 bits of precision with modulus a^3 + a^2 + 1.00000000000000
sage: CDF.extension(x^3+x^2+1,'a')
Univariate Quotient Polynomial Ring in a over Complex Double Field with modulus a^3 + a^2 + 1.0
sage: QQbar.extension(x^3+x^2+1,'a')
Univariate Quotient Polynomial Ring in a over Algebraic Field with modulus a^3 + a^2 + 1
```

Aren't the three above fields algebraically complete? So, I guess the ``extension`` method should be modified to take this into account.



---

archive/issue_comments_073447.json:
```json
{
    "body": "<a id='comment:14'></a>\nConcerning algebraic extension of algebraically complete fields: sage-devel expressed the opinion that it is better to do the construction (namely quotient of a univariate polynomial ring) in any case. So, I leave it as it is.\n\nHere is another problem:\n\n```\nsage: R1.<x> = Zp(5)[]\nsage: R2 = Qp(5)\nsage: R2(1)+x\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n\n/home/SimonKing/<ipython console> in <module>()\n\n/usr/local/sage/local/lib/python2.6/site-packages/sage/structure/element.so in sage.structure.element.RingElement.__add__ (sage/structure/element.c:10830)()\n\n/usr/local/sage/local/lib/python2.6/site-packages/sage/structure/coerce.so in sage.structure.coerce.CoercionModel_cache_maps.bin_op (sage/structure/coerce.c:6966)()\n\nTypeError: unsupported operand parent(s) for '+': '5-adic Field with capped relative precision 20' and 'Univariate Polynomial Ring in x over 5-adic Ring with capped relative precision 20'\n```\n\nThe reason is \n\n```\nsage: from sage.categories.pushout import pushout\nsage: pushout(R1,R2)\n---------------------------------------------------------------------------\nCoercionException                         Traceback (most recent call last)\n\n/home/SimonKing/<ipython console> in <module>()\n\n/usr/local/sage/local/lib/python2.6/site-packages/sage/categories/pushout.pyc in pushout(R, S)\n   1109         # make sense, and in this case simply want to return that a pushout\n   1110         # couldn't be found.\n-> 1111         raise CoercionException(ex)\n   1112\n   1113\n\nCoercionException: 'pAdicFieldCappedRelative' object has no attribute 'completion'\n```\n\nRather than implementing a completion of p-adic fields, I suggest to give the construction functors of fraction fields and of completions the same rank. This would already suffice (together with the existing merge method of the completion functor) so that one has\n\n```\nsage: R1.<x> = Zp(5)[]\nsage: R2 = Qp(5)\nsage: R2(1) + x\n(1 + O(5^20))*x + (1 + O(5^20))\n```\n\nNote that there is an additional problem, namely that there is no coercion from a p-adic field of high precision to a p-adic field of lower precision. I hope sage-devel will answer whether this issue is worth a separate ticket.",
    "created_at": "2010-05-14T13:59:06Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73447",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>
Concerning algebraic extension of algebraically complete fields: sage-devel expressed the opinion that it is better to do the construction (namely quotient of a univariate polynomial ring) in any case. So, I leave it as it is.

Here is another problem:

```
sage: R1.<x> = Zp(5)[]
sage: R2 = Qp(5)
sage: R2(1)+x
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/SimonKing/<ipython console> in <module>()

/usr/local/sage/local/lib/python2.6/site-packages/sage/structure/element.so in sage.structure.element.RingElement.__add__ (sage/structure/element.c:10830)()

/usr/local/sage/local/lib/python2.6/site-packages/sage/structure/coerce.so in sage.structure.coerce.CoercionModel_cache_maps.bin_op (sage/structure/coerce.c:6966)()

TypeError: unsupported operand parent(s) for '+': '5-adic Field with capped relative precision 20' and 'Univariate Polynomial Ring in x over 5-adic Ring with capped relative precision 20'
```

The reason is 

```
sage: from sage.categories.pushout import pushout
sage: pushout(R1,R2)
---------------------------------------------------------------------------
CoercionException                         Traceback (most recent call last)

/home/SimonKing/<ipython console> in <module>()

/usr/local/sage/local/lib/python2.6/site-packages/sage/categories/pushout.pyc in pushout(R, S)
   1109         # make sense, and in this case simply want to return that a pushout
   1110         # couldn't be found.
-> 1111         raise CoercionException(ex)
   1112
   1113

CoercionException: 'pAdicFieldCappedRelative' object has no attribute 'completion'
```

Rather than implementing a completion of p-adic fields, I suggest to give the construction functors of fraction fields and of completions the same rank. This would already suffice (together with the existing merge method of the completion functor) so that one has

```
sage: R1.<x> = Zp(5)[]
sage: R2 = Qp(5)
sage: R2(1) + x
(1 + O(5^20))*x + (1 + O(5^20))
```

Note that there is an additional problem, namely that there is no coercion from a p-adic field of high precision to a p-adic field of lower precision. I hope sage-devel will answer whether this issue is worth a separate ticket.



---

archive/issue_comments_073448.json:
```json
{
    "body": "<a id='comment:15'></a>\nPS:\n\nReplying to [SimonKing](#comment%3A14):\n> Rather than implementing a completion of p-adic fields, I suggest to give the construction functors of fraction fields and of completions the same rank...\n\n\n... since they commute anyway. I guess it wouldn't harm to implement the ``commutes`` method as well.\n\nI now consider the Localization functor. It uses the method \"localize\", but:\n\n```\nsage: search_def('localize')\n\nsage: search_src('localize')\ncategories/pushout.py:1294:        return R.localize(t)\nlibs/singular/option.pyx:367:    This object localizes changes to options.\n```\n\nIn other words, there is no class that has a localize method. So, I guess it is safe to comment the Localization functor out.",
    "created_at": "2010-05-14T14:59:02Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73448",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:15'></a>
PS:

Replying to [SimonKing](#comment%3A14):
> Rather than implementing a completion of p-adic fields, I suggest to give the construction functors of fraction fields and of completions the same rank...


... since they commute anyway. I guess it wouldn't harm to implement the ``commutes`` method as well.

I now consider the Localization functor. It uses the method "localize", but:

```
sage: search_def('localize')

sage: search_src('localize')
categories/pushout.py:1294:        return R.localize(t)
libs/singular/option.pyx:367:    This object localizes changes to options.
```

In other words, there is no class that has a localize method. So, I guess it is safe to comment the Localization functor out.



---

archive/issue_comments_073449.json:
```json
{
    "body": "<a id='comment:16'></a>\nWow, I count 7 bugs in the comments above!  What a testament for the need for writing good doctests (and to how careful you are!)",
    "created_at": "2010-05-14T15:55:14Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73449",
    "user": "https://github.com/jasongrout"
}
```

<a id='comment:16'></a>
Wow, I count 7 bugs in the comments above!  What a testament for the need for writing good doctests (and to how careful you are!)



---

archive/issue_comments_073450.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [SimonKing](#comment%3A14):\n> Note that there is an additional problem, namely that there is no coercion from a p-adic field of high precision to a p-adic field of lower precision. I hope sage-devel will answer whether this issue is worth a separate ticket.\n\n\nSage-devel (more precisely Robert Bradshaw) wrote that the meaning of \"precision\" is different for completion at Infinity and at finite primes, and it makes sense that sometimes the precision is non-decreasing and sometimes non-increasing under coercion.\n\nSo, I guess I have to modify the merge method of the Completion funtor, rather than the _coerce_map_from method of p-adic rings.",
    "created_at": "2010-05-14T18:24:11Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73450",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:17'></a>
Replying to [SimonKing](#comment%3A14):
> Note that there is an additional problem, namely that there is no coercion from a p-adic field of high precision to a p-adic field of lower precision. I hope sage-devel will answer whether this issue is worth a separate ticket.


Sage-devel (more precisely Robert Bradshaw) wrote that the meaning of "precision" is different for completion at Infinity and at finite primes, and it makes sense that sometimes the precision is non-decreasing and sometimes non-increasing under coercion.

So, I guess I have to modify the merge method of the Completion funtor, rather than the _coerce_map_from method of p-adic rings.



---

archive/issue_comments_073451.json:
```json
{
    "body": "<a id='comment:18'></a>\nI noticed the following:\n\n```\nsage: P.<x> = ZZ[]\nsage: C = P.completion(x).construction()[0]\nsage: R = FractionField(P)\nsage: hasattr(R,'completion')\nFalse\nsage: C(R)\nTraceback (most recent  call last):\n...\nAttributeError: 'FractionField_generic' object has no attribute 'completion'\n```\n\nThis is since the completion functor simply tries to call the completion method of its argument. However, one can use that the fraction field construction functor and the completion functor commute.\n\nSo, I first try to apply a completion method of the argument, R. If it fails with an AttributeError or NotImplementedError, I look at R's construction (F,R1). If F merges with completion, then I apply the result of merging to R1. Otherwise, if the completion commutes with F, I try to first apply the completion to R1 and then apply F to the result, and obtain:\n\n```\nsage: C(R)\nFraction Field of Power Series Ring in x over Integer Ring\n```\n\nNote that this would *not* be the first place where merging and commutation of construction functors is used outside the ``pushout`` function. The other place is the construction of infinite polynomial rings, which I wrote as well. Indeed I believe that construction functors should be used more intensely...",
    "created_at": "2010-05-15T12:22:58Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73451",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'></a>
I noticed the following:

```
sage: P.<x> = ZZ[]
sage: C = P.completion(x).construction()[0]
sage: R = FractionField(P)
sage: hasattr(R,'completion')
False
sage: C(R)
Traceback (most recent  call last):
...
AttributeError: 'FractionField_generic' object has no attribute 'completion'
```

This is since the completion functor simply tries to call the completion method of its argument. However, one can use that the fraction field construction functor and the completion functor commute.

So, I first try to apply a completion method of the argument, R. If it fails with an AttributeError or NotImplementedError, I look at R's construction (F,R1). If F merges with completion, then I apply the result of merging to R1. Otherwise, if the completion commutes with F, I try to first apply the completion to R1 and then apply F to the result, and obtain:

```
sage: C(R)
Fraction Field of Power Series Ring in x over Integer Ring
```

Note that this would *not* be the first place where merging and commutation of construction functors is used outside the ``pushout`` function. The other place is the construction of infinite polynomial rings, which I wrote as well. Indeed I believe that construction functors should be used more intensely...



---

archive/issue_comments_073452.json:
```json
{
    "body": "<a id='comment:19'></a>\nReplying to [SimonKing](#comment%3A18):\n> ...\n> \n> ```\n> sage: C(R)\n> Fraction Field of Power Series Ring in x over Integer Ring\n> ```\n\n\nI believe that the fraction field of a power series ring over a base ring ``B`` should be identical with the Laurent series ring over the fraction field of ``B``. This is implemented in ticket #8972.\n\nI am tempted to say \"let's wait until #8972 is refereed\", because the doc tests I am constructing here will depend on whether #8972 gets merged or not.\n\nWhat is the policy in those cases? Should I simply continue the work on the doc tests and care about #8972 later?",
    "created_at": "2010-05-17T09:03:12Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73452",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'></a>
Replying to [SimonKing](#comment%3A18):
> ...
> 
> ```
> sage: C(R)
> Fraction Field of Power Series Ring in x over Integer Ring
> ```


I believe that the fraction field of a power series ring over a base ring ``B`` should be identical with the Laurent series ring over the fraction field of ``B``. This is implemented in ticket #8972.

I am tempted to say "let's wait until #8972 is refereed", because the doc tests I am constructing here will depend on whether #8972 gets merged or not.

What is the policy in those cases? Should I simply continue the work on the doc tests and care about #8972 later?



---

archive/issue_comments_073453.json:
```json
{
    "body": "<a id='comment:20'></a>\nCurrently, the construction functors for free modules and for matrix spaces have the same rank, but they do not commute and do not merge. Hence, the following goes boom:\n\n```\nsage: from sage.categories.pushout import pushout\nsage: pushout(QQ^3,MatrixSpace(QQ,3))\n---------------------------------------------------------------------------\nCoercionException                         Traceback (most recent call last)\n...\nCoercionException: ('Ambiguous Base Extension', Vector space of dimension 3 over Rational Field, Full MatrixSpace of 3 by 3 dense matrices over Rational Field)\n```\n\nI think this pushout should exist. But what should result?\n\n1. ``MatrixSpace(QQ,3)<sup>3</sup>`` resp. ``FreeModule(MatrixSpace(QQ,3),3)``. This is currently not possible, since ``MatrixSpace_generic`` has no attribute ``is_commutative``.\n\n2. ``MatrixSpace(QQ<sup>3</sup>,3)`` makes no sense, as ``QQ<sup>3</sup>`` is no ring.\n\n3. ``MatrixSpace(QQ,27)`` makes not much sense, as I don't see coercion maps.\n\nSo, probably it is solution number 1, which at least requires to implement an ``is_commutative`` method, resp. to first test for the presence of such method in ``FreeModule``. I think I'll go for it.",
    "created_at": "2010-05-17T12:53:51Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73453",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:20'></a>
Currently, the construction functors for free modules and for matrix spaces have the same rank, but they do not commute and do not merge. Hence, the following goes boom:

```
sage: from sage.categories.pushout import pushout
sage: pushout(QQ^3,MatrixSpace(QQ,3))
---------------------------------------------------------------------------
CoercionException                         Traceback (most recent call last)
...
CoercionException: ('Ambiguous Base Extension', Vector space of dimension 3 over Rational Field, Full MatrixSpace of 3 by 3 dense matrices over Rational Field)
```

I think this pushout should exist. But what should result?

1. ``MatrixSpace(QQ,3)<sup>3</sup>`` resp. ``FreeModule(MatrixSpace(QQ,3),3)``. This is currently not possible, since ``MatrixSpace_generic`` has no attribute ``is_commutative``.

2. ``MatrixSpace(QQ<sup>3</sup>,3)`` makes no sense, as ``QQ<sup>3</sup>`` is no ring.

3. ``MatrixSpace(QQ,27)`` makes not much sense, as I don't see coercion maps.

So, probably it is solution number 1, which at least requires to implement an ``is_commutative`` method, resp. to first test for the presence of such method in ``FreeModule``. I think I'll go for it.



---

archive/issue_comments_073454.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [SimonKing](#comment%3A20):\n> So, probably it is solution number 1, which at least requires to implement an ``is_commutative`` method, resp. to first test for the presence of such method in ``FreeModule``. I think I'll go for it.\n\n\nOops, this is nonsense. The ``FreeModule`` constructor expects a commutative ring. So, solution 1. is no solution. I will change the constructor so that it is first tested whether the ``is_commutative`` method exists, so that the error message is clearer, but apart from that, it is OK that the pushout does not exist.",
    "created_at": "2010-05-17T12:58:55Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73454",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:21'></a>
Replying to [SimonKing](#comment%3A20):
> So, probably it is solution number 1, which at least requires to implement an ``is_commutative`` method, resp. to first test for the presence of such method in ``FreeModule``. I think I'll go for it.


Oops, this is nonsense. The ``FreeModule`` constructor expects a commutative ring. So, solution 1. is no solution. I will change the constructor so that it is first tested whether the ``is_commutative`` method exists, so that the error message is clearer, but apart from that, it is OK that the pushout does not exist.



---

archive/issue_comments_073455.json:
```json
{
    "body": "<a id='comment:22'></a>\nI believe that free modules of the same rank but with different inner product matrix should not allow coercion. Hence, I think the following is a bug:\n\n```\nsage: P.<t> = ZZ[]\nsage: M1 = FreeModule(P,3)\nsage: M2 = QQ^3\nsage: M2([1,1/2,1/3]) + M1([t,t^2+t,3])     # This is ok\n(t + 1, t^2 + t + 1/2, 10/3)\nsage: M3 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,range(9)))\nsage: M2([1,1/2,1/3]) + M3([t,t^2+t,3])     # This should result in an error\n(t + 1, t^2 + t + 1/2, 10/3)\n```\n\nThis inappropriate coercion can be avoided by modifying the merge method of the construction functors, so that the inner product matrices are used for comparison as well.\n\nBut I acknowledge that other people might think that a coercion should exist. Perhaps I shall ask on sage-algebra...",
    "created_at": "2010-05-17T13:22:44Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73455",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:22'></a>
I believe that free modules of the same rank but with different inner product matrix should not allow coercion. Hence, I think the following is a bug:

```
sage: P.<t> = ZZ[]
sage: M1 = FreeModule(P,3)
sage: M2 = QQ^3
sage: M2([1,1/2,1/3]) + M1([t,t^2+t,3])     # This is ok
(t + 1, t^2 + t + 1/2, 10/3)
sage: M3 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,range(9)))
sage: M2([1,1/2,1/3]) + M3([t,t^2+t,3])     # This should result in an error
(t + 1, t^2 + t + 1/2, 10/3)
```

This inappropriate coercion can be avoided by modifying the merge method of the construction functors, so that the inner product matrices are used for comparison as well.

But I acknowledge that other people might think that a coercion should exist. Perhaps I shall ask on sage-algebra...



---

archive/issue_comments_073456.json:
```json
{
    "body": "<a id='comment:23'></a>\nReplying to [SimonKing](#comment%3A22):\n> ...\n> But I acknowledge that other people might think that a coercion should exist. Perhaps I shall ask on sage-algebra...\n\n\nsage-algebra (John Cremona and William Stein) answered that the inner product is an important structure if and *only* if it is explicitly defined by the user. Hence, in the above example with ``M2`` and ``M3``, no error should be raised, since ``M2`` has no user-defined inner product. But if ``M2`` was *explicitly* be provided with the standard inner product, then an error should be raised.\n\nThat's easy to implement: The ``construction()`` method of the modules returns a ``VectorFunctor``, and this one carries the inner product matrix (if provided by the user) or None. And two ``VectorFunctor``s carrying different inner product matrices will not be merged.",
    "created_at": "2010-05-17T17:43:50Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73456",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:23'></a>
Replying to [SimonKing](#comment%3A22):
> ...
> But I acknowledge that other people might think that a coercion should exist. Perhaps I shall ask on sage-algebra...


sage-algebra (John Cremona and William Stein) answered that the inner product is an important structure if and *only* if it is explicitly defined by the user. Hence, in the above example with ``M2`` and ``M3``, no error should be raised, since ``M2`` has no user-defined inner product. But if ``M2`` was *explicitly* be provided with the standard inner product, then an error should be raised.

That's easy to implement: The ``construction()`` method of the modules returns a ``VectorFunctor``, and this one carries the inner product matrix (if provided by the user) or None. And two ``VectorFunctor``s carrying different inner product matrices will not be merged.



---

archive/issue_comments_073457.json:
```json
{
    "body": "<a id='comment:24'></a>\nNext issue: Quotient rings of univariate polynomial rings did not have a construction method. I am implementing it, so that one has:\n\n```\nsage: P.<t>=ZZ[]\nsage: Q = P.quo(5+t^2)\nsage: F,R = Q.construction()\nsage: F(R) == Q\nTrue\nsage: P.<t> = GF(3)[]\nsage: Q = P.quo([2+t^2])\nsage: F,R = Q.construction()\nsage: F(R) == Q\nTrue\n```",
    "created_at": "2010-05-18T15:14:58Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73457",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:24'></a>
Next issue: Quotient rings of univariate polynomial rings did not have a construction method. I am implementing it, so that one has:

```
sage: P.<t>=ZZ[]
sage: Q = P.quo(5+t^2)
sage: F,R = Q.construction()
sage: F(R) == Q
True
sage: P.<t> = GF(3)[]
sage: Q = P.quo([2+t^2])
sage: F,R = Q.construction()
sage: F(R) == Q
True
```



---

archive/issue_comments_073458.json:
```json
{
    "body": "<a id='comment:25'></a>\nI am now almost finished with the doc tests for pushout.py.\n\nThe soon-to-be-submitted patch is already quite big, and comprises various bug fixes. I suggest that this ticket will mainly be about pushout.py, and the other files will be done on a separate ticket.\n\nHere are three more bugs. Number one:\n\n```\nsage: sage: P.<x> = QQ[]\nsage: P.<x> = QQ[]\nsage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])\nsage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])\nsage: from sage.categories.pushout import pushout\nsage: pushout(Q1,Q2)\n---------------------------------------------------------------------------\nCoercionException                         Traceback (most recent call last)\n\n/home/king/SAGE/work/invarianten/<ipython console> in <module>()\n\n/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/pushout.pyc in pushout(R, S)\n   1037\n   1038     else:\n-> 1039         raise CoercionException, \"No common base\"\n   1040\n   1041     # Rc is a list of functors from Z to R and Sc is a list of functors from Z to S\n\nCoercionException: No common base\n```\nThis I can fix. The problem is that the quotient rings have no proper ``construction()`` method.\n\nNumber 2, continuing the above example:\n\n```\nsage: Q = P.quo([(x^2+1)^2])\nsage: Q.has_coerce_map_from(Q1)\nFalse\nsage: Q.has_coerce_map_from(Q2)\nFalse\n```\n\nThis is wrong since the modulus of Q divides the modulus of Q1 and Q2. Actually Q is supposed to be the pushout of Q1 and Q2.\n\nNumber three:\n\n```\nsage: Q(Q1.gen())\nERROR: An unexpected error occurred while tokenizing input\nThe following traceback may be corrupted or invalid\nThe error message is: ('EOF in multi-line statement', (932, 0))\n...\nTypeError: Unable to coerce xbar (<class 'sage.rings.polynomial.polynomial_quotient_ring_element.PolynomialQuotientRingElement'>) to Rational\n```\n\nBut I guess these last two errors should be on a different ticket.",
    "created_at": "2010-05-18T16:38:06Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73458",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:25'></a>
I am now almost finished with the doc tests for pushout.py.

The soon-to-be-submitted patch is already quite big, and comprises various bug fixes. I suggest that this ticket will mainly be about pushout.py, and the other files will be done on a separate ticket.

Here are three more bugs. Number one:

```
sage: sage: P.<x> = QQ[]
sage: P.<x> = QQ[]
sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])
sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])
sage: from sage.categories.pushout import pushout
sage: pushout(Q1,Q2)
---------------------------------------------------------------------------
CoercionException                         Traceback (most recent call last)

/home/king/SAGE/work/invarianten/<ipython console> in <module>()

/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/pushout.pyc in pushout(R, S)
   1037
   1038     else:
-> 1039         raise CoercionException, "No common base"
   1040
   1041     # Rc is a list of functors from Z to R and Sc is a list of functors from Z to S

CoercionException: No common base
```
This I can fix. The problem is that the quotient rings have no proper ``construction()`` method.

Number 2, continuing the above example:

```
sage: Q = P.quo([(x^2+1)^2])
sage: Q.has_coerce_map_from(Q1)
False
sage: Q.has_coerce_map_from(Q2)
False
```

This is wrong since the modulus of Q divides the modulus of Q1 and Q2. Actually Q is supposed to be the pushout of Q1 and Q2.

Number three:

```
sage: Q(Q1.gen())
ERROR: An unexpected error occurred while tokenizing input
The following traceback may be corrupted or invalid
The error message is: ('EOF in multi-line statement', (932, 0))
...
TypeError: Unable to coerce xbar (<class 'sage.rings.polynomial.polynomial_quotient_ring_element.PolynomialQuotientRingElement'>) to Rational
```

But I guess these last two errors should be on a different ticket.



---

archive/issue_comments_073459.json:
```json
{
    "body": "<a id='comment:26'></a>\n* The patch is to be applied *after the patches from* #8807.\n\n* It raises the **doctest coverage of sage.categories.functor and sage.categories.pushout to 100%** and occasionally adds doc tests in other places.\n\n* It fixes numerous bugs related with coercion, as indicated in the posts above.\n\nConstructing doc tests for pushout.py and functor.pyx revealed many bugs, so that I needed to change\n\n```\nsage/structure/parent.pyx\nsage/rings/ring.pyx\nsage/rings/rational_field.py\nsage/rings/quotient_ring.py\nsage/rings/qqbar.py\nsage/rings/polynomial/polynomial_quotient_ring.py\nsage/rings/number_field/number_field.py\nsage/modules/free_module.py\nsage/categories/pushout.py\nsage/categories/functor.pyx\n```\n\nThe doc tests for all these files still pass.\n\nI think it would make no sense to put more on this ticket. The work on doc tests in map.pyx, morphism.pyx and action.pyx will be moved to a different ticket.",
    "created_at": "2010-05-18T23:04:09Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73459",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:26'></a>
* The patch is to be applied *after the patches from* #8807.

* It raises the **doctest coverage of sage.categories.functor and sage.categories.pushout to 100%** and occasionally adds doc tests in other places.

* It fixes numerous bugs related with coercion, as indicated in the posts above.

Constructing doc tests for pushout.py and functor.pyx revealed many bugs, so that I needed to change

```
sage/structure/parent.pyx
sage/rings/ring.pyx
sage/rings/rational_field.py
sage/rings/quotient_ring.py
sage/rings/qqbar.py
sage/rings/polynomial/polynomial_quotient_ring.py
sage/rings/number_field/number_field.py
sage/modules/free_module.py
sage/categories/pushout.py
sage/categories/functor.pyx
```

The doc tests for all these files still pass.

I think it would make no sense to put more on this ticket. The work on doc tests in map.pyx, morphism.pyx and action.pyx will be moved to a different ticket.



---

archive/issue_events_063180.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2010-05-18T23:04:09Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63180"
}
```



---

archive/issue_comments_073460.json:
```json
{
    "body": "<a id='comment:27'></a>\nWow, this is looking very good! \n\nMatrixFunctor.__init__, is there not a module category that could be used in place of `CommutativeAdditiveGroups`? I guess if tbe basering is unknown then that's more difficult. \n\nMissing periods on `VectorFunctor.__cmp__` and `VectorFunctor.merge`. I agree with the logic for that merge function. \n\nThat's all I've seen so far (and I've read most of the patch.) You've fixed a lot of bugs too. Pending doctests passing, I'd say this is ready for a positive review.",
    "created_at": "2010-05-19T03:55:01Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73460",
    "user": "https://github.com/robertwb"
}
```

<a id='comment:27'></a>
Wow, this is looking very good! 

MatrixFunctor.__init__, is there not a module category that could be used in place of `CommutativeAdditiveGroups`? I guess if tbe basering is unknown then that's more difficult. 

Missing periods on `VectorFunctor.__cmp__` and `VectorFunctor.merge`. I agree with the logic for that merge function. 

That's all I've seen so far (and I've read most of the patch.) You've fixed a lot of bugs too. Pending doctests passing, I'd say this is ready for a positive review.



---

archive/issue_comments_073461.json:
```json
{
    "body": "<a id='comment:28'></a>\nHi Robert!\n\nReplying to [robertwb](#comment%3A27):\n> MatrixFunctor.__init__, is there not a module category that could be used in place of `CommutativeAdditiveGroups`? I guess if tbe basering is unknown then that's more difficult. \n\n\nYes, `Modules()` requires a base ring. There is currently no category of modules, but only a category of R-modules for any ring R. This is why I used `CommutativeAdditiveGroups()` in several cases. \n\n\n> Missing periods on `VectorFunctor.__cmp__` and `VectorFunctor.merge`.\n\n\nMissing where? In the doc string?\n\nConcerning positive review, note that technically this ticket depends on #8807, which has no review yet.\n\nBest regards,\nSimon",
    "created_at": "2010-05-19T08:23:57Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73461",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:28'></a>
Hi Robert!

Replying to [robertwb](#comment%3A27):
> MatrixFunctor.__init__, is there not a module category that could be used in place of `CommutativeAdditiveGroups`? I guess if tbe basering is unknown then that's more difficult. 


Yes, `Modules()` requires a base ring. There is currently no category of modules, but only a category of R-modules for any ring R. This is why I used `CommutativeAdditiveGroups()` in several cases. 


> Missing periods on `VectorFunctor.__cmp__` and `VectorFunctor.merge`.


Missing where? In the doc string?

Concerning positive review, note that technically this ticket depends on #8807, which has no review yet.

Best regards,
Simon



---

archive/issue_comments_073462.json:
```json
{
    "body": "<a id='comment:29'></a>\nReplying to [SimonKing](#comment%3A28):\n> Hi Robert!\n> \n> Replying to [robertwb](#comment%3A27):\n> > MatrixFunctor.__init__, is there not a module category that could be used in place of `CommutativeAdditiveGroups`? I guess if tbe basering is unknown then that's more difficult. \n\n> \n> Yes, `Modules()` requires a base ring. There is currently no category of modules, but only a category of R-modules for any ring R. This is why I used `CommutativeAdditiveGroups()` in several cases. \n\n\nHmm... does it make sense to have a category of Modules (over any basering)? \n\n> > Missing periods on `VectorFunctor.__cmp__` and `VectorFunctor.merge`.\n\n> \n> Missing where? In the doc string?\n\n\nYes, there were a couple of sentences without ending periods. Nothing major. \n\n> Concerning positive review, note that technically this ticket depends on #8807, which has no review yet.\n> \n\n\nYep. I started to look at that one too, and will review it if no one beats me too it when I have another spare moment (maybe the upcoming Sage days, depending on how good of shape my thesis is in by then).",
    "created_at": "2010-05-19T10:03:55Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73462",
    "user": "https://github.com/robertwb"
}
```

<a id='comment:29'></a>
Replying to [SimonKing](#comment%3A28):
> Hi Robert!
> 
> Replying to [robertwb](#comment%3A27):
> > MatrixFunctor.__init__, is there not a module category that could be used in place of `CommutativeAdditiveGroups`? I guess if tbe basering is unknown then that's more difficult. 

> 
> Yes, `Modules()` requires a base ring. There is currently no category of modules, but only a category of R-modules for any ring R. This is why I used `CommutativeAdditiveGroups()` in several cases. 


Hmm... does it make sense to have a category of Modules (over any basering)? 

> > Missing periods on `VectorFunctor.__cmp__` and `VectorFunctor.merge`.

> 
> Missing where? In the doc string?


Yes, there were a couple of sentences without ending periods. Nothing major. 

> Concerning positive review, note that technically this ticket depends on #8807, which has no review yet.
> 


Yep. I started to look at that one too, and will review it if no one beats me too it when I have another spare moment (maybe the upcoming Sage days, depending on how good of shape my thesis is in by then).



---

archive/issue_comments_073463.json:
```json
{
    "body": "<a id='comment:30'></a>\nReplying to [robertwb](#comment%3A29):\n> ...\n> Hmm... does it make sense to have a category of Modules (over any basering)? \n\n\nThe axioms of categories say that there must be the identity morphism for any object, and that composition of functors must be associative. It is not required that there is a morphism (e.g., the null-homomorphism) between any two objects. So, I guess a category of modules is just fine.\n\nCheers,\nSimon",
    "created_at": "2010-05-19T10:09:42Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73463",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:30'></a>
Replying to [robertwb](#comment%3A29):
> ...
> Hmm... does it make sense to have a category of Modules (over any basering)? 


The axioms of categories say that there must be the identity morphism for any object, and that composition of functors must be associative. It is not required that there is a morphism (e.g., the null-homomorphism) between any two objects. So, I guess a category of modules is just fine.

Cheers,
Simon



---

archive/issue_comments_073464.json:
```json
{
    "body": "<a id='comment:31'></a>\nThere was a change needed in the patch from #8807. So, I had to rebase the ticket here. I just did! \n\nI did not yet have the time to run `make ptestall`, but will start it right now.",
    "created_at": "2010-07-21T13:31:28Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73464",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:31'></a>
There was a change needed in the patch from #8807. So, I had to rebase the ticket here. I just did! 

I did not yet have the time to run `make ptestall`, but will start it right now.



---

archive/issue_events_063181.json:
```json
{
    "actor": "https://github.com/JohnCremona",
    "created_at": "2010-10-26T20:09:26Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63181"
}
```



---

archive/issue_events_063182.json:
```json
{
    "actor": "https://github.com/JohnCremona",
    "created_at": "2010-10-26T20:09:26Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63182"
}
```



---

archive/issue_comments_073465.json:
```json
{
    "body": "<a id='comment:32'></a>\nThe patch here does not apply cleanly after the one at #8807 (on 4.6.rc0).",
    "created_at": "2010-10-26T20:09:26Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73465",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:32'></a>
The patch here does not apply cleanly after the one at #8807 (on 4.6.rc0).



---

archive/issue_comments_073466.json:
```json
{
    "body": "<a id='comment:33'></a>\nReplying to [cremona](#comment%3A32):\n> The patch here does not apply cleanly after the one at #8807 (on 4.6.rc0).\n\n\nThank you for trying. Do you say that #8807 did apply, but the patch here did not?\n\nAnyway, it will take a until next week befor I will be able to resume work.\n\nBest regards, Simon",
    "created_at": "2010-10-26T20:13:29Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73466",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:33'></a>
Replying to [cremona](#comment%3A32):
> The patch here does not apply cleanly after the one at #8807 (on 4.6.rc0).


Thank you for trying. Do you say that #8807 did apply, but the patch here did not?

Anyway, it will take a until next week befor I will be able to resume work.

Best regards, Simon



---

archive/issue_comments_073467.json:
```json
{
    "body": "<a id='comment:34'></a>\nI just uploaded a new version of my patch. It does apply after the patch from #8807 (with some fuzz), but now various doctests fail.\n\nAt least in one case, the reason is that some matrices still have a custom `__mul__` method were they should have a `_mul_` (single underscore) and `_act_on_` method. I expect that it will be addressed on a different ticket.\n\nSo, it needs work, but feel free to experiment with the new patch...",
    "created_at": "2010-11-24T12:04:40Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73467",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:34'></a>
I just uploaded a new version of my patch. It does apply after the patch from #8807 (with some fuzz), but now various doctests fail.

At least in one case, the reason is that some matrices still have a custom `__mul__` method were they should have a `_mul_` (single underscore) and `_act_on_` method. I expect that it will be addressed on a different ticket.

So, it needs work, but feel free to experiment with the new patch...



---

archive/issue_comments_073468.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -7,18 +7,520 @@\n morphism.pyx: 20% (5 of 24)\n pushout.py: 24% (19 of 77) \n ```\n-Trying to add doc tests, I actually found a bug:\n-\n+\n+The original purpose of this ticket was to provide full doctest coverage for `functor.pyx` and `pushout.py`. **The doctest coverage of both files is now 100%**.\n+\n+\n+However, the attempt to create meaningful doctests uncovered many bugs in various parts of Sage, and also motivated the implementation of coercion for various algebraic structures for which this has not been done before.\n+\n+This a-posteriori ticket description lists the bugs killed and the features added by the patch, which should apply (with a little fuzz) after the patch from #8807. For more details on the bugs, see the comments below.\n+\n+1. Bug: Creating `ForgetfulFunctor` fails.\n+\n+   Was:\n+\n+  ```\n+  sage: abgrps = CommutativeAdditiveGroups()\n+  sage: ForgetfulFunctor(abgrps, abgrps)\n+  ---------------------------------------------------------------------------\n+  TypeError                                 Traceback (most recent call last)\n+  \n+  /home/king/SAGE/patches/doku/english/<ipython console> in <module>()\n+  \n+  /home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/functor.so in sage.categories.functor.ForgetfulFunctor (sage/categories/functor.c:2083)()\n+  \n+  TypeError: IdentityFunctor() takes exactly one argument (2 given)\n+   ```\n+\n+   Now:\n+\n+  ```\n+  sage: abgrps = CommutativeAdditiveGroups()\n+  sage: ForgetfulFunctor(abgrps, abgrps)\n+  The identity functor on Category of commutative additive groups\n+   ```\n+\n+2. Bug: Applying `ForgetfulFunctor` returns `None`.\n+\n+   Was:\n+\n+  ```\n+  sage: fields = Fields()\n+  sage: rings = Rings()\n+  sage: F = ForgetfulFunctor(fields,rings)\n+  sage: F(QQ)\n+   ```\n+\n+   Now:\n+\n+  ```\n+  sage: fields = Fields()\n+  sage: rings = Rings()\n+  sage: F = ForgetfulFunctor(fields,rings)\n+  sage: F(QQ)\n+  Rational Field\n+   ```\n+\n+3. Bug: Applying a functor does not complain if the argument is not contained in the domain.\n+\n+   Was:\n+\n+  ```\n+  sage: fields = Fields()\n+  sage: rings = Rings()\n+  sage: F = ForgetfulFunctor(fields,rings)\n+  # Yields None, see previous bug\n+  sage: F(ZZ['x','y'])\n+   ```\n+\n+   Now:\n+\n+  ```\n+  sage: fields = Fields()\n+  sage: rings = Rings()\n+  sage: F = ForgetfulFunctor(fields,rings)\n+  sage: F(ZZ['x','y'])\n+  Traceback (most recent call last):\n+  ...\n+  TypeError: x (=Multivariate Polynomial Ring in x, y over Integer Ring) is not in Category of fields\n+   ```\n+\n+4. Bug: Comparing identity functor with any functor only checks domain and codomain\n+\n+   Was:\n+\n+  ```\n+  sage: F = QQ['x'].construction()[0]\n+  sage: F\n+  Poly[x]\n+  sage: F == IdentityFunctor(Rings())\n+  False\n+  sage: IdentityFunctor(Rings()) == F\n+  True\n+   ```\n+\n+   Now:\n+\n+  ```\n+  sage: F = QQ['x'].construction()[0]\n+  sage: F\n+  Poly[x]\n+  sage: F == IdentityFunctor(Rings())\n+  False\n+  sage: IdentityFunctor(Rings()) == F\n+  False\n+   ```\n+\n+5. Bug: Comparing identity functor with anything that is not a functor produces an error\n+\n+   Was:\n+\n+  ```\n+  sage: IdentityFunctor(Rings()) == QQ\n+  Traceback (most recent call last):\n+  ...\n+  AttributeError: 'RationalField_with_category' object has no attribute 'domain'\n+   ```\n+\n+   Now:\n+\n+  ```\n+  sage: IdentityFunctor(Rings()) == QQ\n+  False\n+   ```\n+\n+6. Bug: The matrix functor is ill defined; moreover, ill-definedness does not result in an error.\n+\n+   Was:\n+\n+  ```\n+  sage: F = MatrixSpace(ZZ,2,3).construction()[0]\n+  sage: F(RR) in F.codomain()\n+  False\n+  # The codomain is wrong for non-square matrices!\n+  sage: F.codomain()\n+  Category of rings\n+   ```\n+\n+   Now:\n+\n+  ```\n+  sage: F = MatrixSpace(ZZ,2,3).construction()[0]\n+  sage: F.codomain()\n+  Category of commutative additive groups\n+  sage: F(RR) in F.codomain()\n+  True\n+  sage: F = MatrixSpace(ZZ,2,2).construction()[0]\n+  sage: F.codomain()\n+  Category of rings\n+  sage: F(RR) in F.codomain()\n+  True\n+   ```\n+\n+7. Bug: Wrong domain for `VectorFunctor`; and again, functors don't test if the domain is appropriate\n+\n+   Was:\n+\n+  ```\n+  sage: F = FreeModule(ZZ,3).construction()[0]\n+  sage: F\n+  VectorFunctor\n+  sage: F.domain()\n+  Category of objects\n+  sage: F.codomain()\n+  Category of objects\n+  sage: Set([1,2,3]) in F.domain()\n+  True\n+  sage: F(Set([1,2,3]))\n+  Traceback (most recent call last):\n+  ...\n+  AttributeError: 'Set_object_enumerated' object has no attribute 'is_commutative'\n+   ```\n+\n+   Now:\n+\n+  ```\n+  sage: F = FreeModule(ZZ,3).construction()[0]\n+  sage: F\n+  VectorFunctor\n+  sage: F.domain()\n+  Category of commutative rings\n+  sage: Set([1,2,3]) in F.domain()\n+  False\n+  sage: F(Set([1,2,3]))\n+  Traceback (most recent call last):\n+  ...\n+  TypeError: x (={1, 2, 3}) is not in Category of commutative rings\n+   ```\n+\n+8. Bug: `BlackBoxConstructionFunctor` is completely unusable\n+\n+`BlackBoxConstructionFunctor` should be a class, but is defined as a function. Moreover, the given init method is not using the init method of `ConstructionFunctor`. And the cmp method would raise an error if the second argument has no attribute `.box`. \n+\n+  The following did not work at all:\n+\n+  ```\n+  sage: from sage.categories.pushout import BlackBoxConstructionFunctor\n+  sage: FG = BlackBoxConstructionFunctor(gap)\n+  sage: FS = BlackBoxConstructionFunctor(singular)\n+  sage: FG\n+  BlackBoxConstructionFunctor\n+  sage: FG(ZZ)\n+  Integers\n+  sage: FG(ZZ).parent()\n+  Gap\n+  sage: FS(QQ['t'])\n+  //   characteristic : 0\n+  //   number of vars : 1\n+  //        block   1 : ordering lp\n+  //                  : names    t\n+  //        block   2 : ordering C\n+  sage: FG == FS\n+  False\n+  sage: FG == loads(dumps(FG))\n+  True\n ```\n-sage: abgrps = CommutativeAdditiveGroups()\n-sage: ForgetfulFunctor(abgrps, abgrps)\n----------------------------------------------------------------------------\n-TypeError                                 Traceback (most recent call last)\n-\n-/home/king/SAGE/patches/doku/english/<ipython console> in <module>()\n-\n-/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/functor.so in sage.categories.functor.ForgetfulFunctor (sage/categories/functor.c:2083)()\n-\n-TypeError: IdentityFunctor() takes exactly one argument (2 given)\n+\n+9. Nitpicking: The `LocalizationFunctor` is nowhere used (yet)\n+\n+Hence, I removed it.\n+\n+10. Bug / New Feature: Make completion and and fraction field construction functors commute.\n+\n+The result of them not commuting is the following coercion bug.\n+\n+  Was:\n+\n+  ```\n+  sage: R1.<x> = Zp(5)[]\n+  sage: R2 = Qp(5)\n+  sage: R2(1)+x\n+  Traceback (most recent call last):\n+  ...\n+  TypeError: unsupported operand parent(s) for '+': '5-adic Field with capped relative precision 20' and 'Univariate Polynomial Ring in x over 5-adic Ring with capped relative precision 20'\n+  ```\n+\n+  Now:\n+\n+  ```\n+  sage: R1.<x> = Zp(5)[]\n+  sage: R2 = Qp(5)\n+  sage: R2(1)+x\n+  (1 + O(5^20))*x + (1 + O(5^20))\n+  ```\n+\n+11. New feature: Make the completion functor work on some objects that do not provide a completion method.\n+\n+The idea is to use that the completion functor may commute with the construction of the given argument. That may safe the day.\n+\n+  Was:\n+\n+  ```\n+  sage: P.<x> = ZZ[]\n+  sage: C = P.completion(x).construction()[0]\n+  sage: R = FractionField(P)\n+  sage: hasattr(R,'completion')\n+  False\n+  sage: C(R)\n+  Traceback (most recent  call last):\n+  ...\n+  AttributeError: 'FractionField_generic' object has no attribute 'completion'\n+  ```\n+\n+  Now:\n+\n+  ```\n+  sage: P.<x> = ZZ[]\n+  sage: C = P.completion(x).construction()[0]\n+  sage: R = FractionField(P)\n+  sage: hasattr(R,'completion')\n+  False\n+  sage: C(R)\n+  Fraction Field of Power Series Ring in x over Integer Ring\n+  ```\n+\n+12. Bug / new feature: Coercion for free modules, taking into account a user-defined inner product\n+\n+   Was:\n+\n+  ```\n+  sage: P.<t> = ZZ[]\n+  sage: M1 = FreeModule(P,3)\n+  sage: M2 = QQ^3\n+  sage: M2([1,1/2,1/3]) + M1([t,t^2+t,3])     # This is ok\n+  (t + 1, t^2 + t + 1/2, 10/3)\n+  sage: M3 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,range(9)))\n+  sage: M2([1,1/2,1/3]) + M3([t,t^2+t,3])     # This is ok\n+  (t + 1, t^2 + t + 1/2, 10/3)\n+  # The user defined inner product matrix is lost! Bug\n+  sage: parent(M2([1,1/2,1/3]) + M3([t,t^2+t,3])).inner_product_matrix()\n+  [1 0 0]\n+  [0 1 0]\n+  [0 0 1]\n+   ```\n+\n+   Now:\n+\n+  ```\n+  sage: parent(M2([1,1/2,1/3]) + M3([t,t^2+t,3])).inner_product_matrix()\n+  [0 1 2]\n+  [3 4 5]\n+  [6 7 8]\n+   ```\n+\n+   However, the real problem is that modules are not part of the coercion model. I tried to implement it, but that turned out to be a can of worms. So, **I suggest to deal with it on a different ticket**. Here is one bug that isn't removed, yet:\n+\n+  ```\n+  sage: M4 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,[1,1,1,0,1,1,0,0,1]))\n+  sage: M3([t,1,t^2]) + M4([t,t^2+t,3])     # This should result in an error\n+  (2*t, t^2 + t + 1, t^2 + 3)\n+   ```\n+   Note that there should be no coercion between `M3` and `M4`, since they have different user-defined inner product matrices.\n+\n+\n+23. Bug / new feature: Quotient rings of univariate polynomial rings do not have a construction method.\n+\n+   Was:\n+\n+  ```\n+  sage: P.<x> = QQ[]\n+  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])\n+  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])\n+  sage: from sage.categories.pushout import pushout\n+  sage: pushout(Q1,Q2)\n+  Traceback (most recent call last):\n+  ...\n+  CoercionException: No common base\n+   ```\n+\n+   Now:\n+\n+  ```\n+  sage: P.<x> = QQ[]\n+  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])\n+  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])\n+  sage: from sage.categories.pushout import pushout\n+  sage: pushout(Q1,Q2)\n+  Univariate Quotient Polynomial Ring in xbar over Rational Field with modulus x^4 + 2*x^2 + 1\n+   ```\n+\n+34. Insufficient coercion of quotient rings, if one modulus divides the other\n+\n+   Was:\n+\n+  ```\n+  sage: P5.<x> = GF(5)[]\n+  sage: Q = P5.quo([(x^2+1)^2])\n+  sage: P.<x> = ZZ[]\n+  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])\n+  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])\n+  sage: Q.has_coerce_map_from(Q1)\n+  False\n+   ```\n+\n+   Now: There is a coercion from `Q1` to `Q`.\n+\n+45. Coercion of `GF(p)` versus `Integers(p)`\n+\n+I am not sure if this is really a bug.\n+\n+  Was:\n+\n+  ```\n+  sage: from sage.categories.pushout import pushout\n+  sage: pushout(GF(5), Integers(5))\n+  Ring of integers modulo 5\n+  ```\n+\n+  Now\n+\n+  ```\n+  sage: from sage.categories.pushout import pushout\n+  sage: pushout(GF(5), Integers(5))\n+  Finite Field of size 5\n+  ```\n+\n+16. Bug / new feature: Construction for QQbar was missing.\n+\n+   Now:\n+\n+  ```\n+  sage: QQbar.construction()\n+  (AlgebraicClosureFunctor, Rational Field)\n+   ```\n+\n+27. Bug / new feature: Construction for number fields is missing.\n+\n+This became a rather complicated topic, including \"coercions for embedded versus non-embedded number fields and coercion for an order from a coercion from the ambient field\", \"pushout for number fields\", \"comparison of fractional ideals\", \"identity of residue fields\". See three discussions on sage-algebra and sage-nt\n+* [Bidirectional coercions](http://groups.google.com/group/sage-nt/browse_thread/thread/32b65a5173f43267)\n+* [Coercions for number fields](http://groups.google.com/group/sage-nt/browse_thread/thread/5c376dbf7e99ea97)\n+* [Comparison of fractional ideals](http://groups.google.com/group/sage-nt/browse_thread/thread/54c1e33872d14334)\n+\n+__Coercion__\n+\n+  Was:\n+\n+  ```\n+  sage: K.<r4> = NumberField(x^4-2)\n+  sage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)\n+  sage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)\n+  sage: r2_1+r2_2    # indirect doctest\n+  ERROR: An unexpected error occurred while tokenizing input\n+  The following traceback may be corrupted or invalid\n+  The error message is: ('EOF in multi-line statement', (1109, 0))\n+  \n+  ERROR: An unexpected error occurred while tokenizing input\n+  The following traceback may be corrupted or invalid\n+  The error message is: ('EOF in multi-line statement', (1109, 0))\n+  \n+  ...\n+  sage: K.has_coerce_map_from(L1.maximal_order())\n+  False   # that's the wrong direction.\n+  sage: L1.has_coerce_map_from(K.maximal_order())\n+  True\n+  ```\n+\n+  Now:\n+\n+  ```\n+  sage: K.<r4> = NumberField(x^4-2)\n+  sage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)\n+  sage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)\n+  sage: r2_1+r2_2    # indirect doctest\n+  0\n+  sage: (r2_1+r2_2).parent() is L1\n+  True\n+  sage: (r2_2+r2_1).parent() is L2\n+  True\n+  sage: K.has_coerce_map_from(L1.maximal_order())\n+  True\n+  sage: L1.has_coerce_map_from(K.maximal_order())\n+  False\n+  ```\n+\n+__Pushout__\n+\n+  Was:\n+\n+  ```\n+  sage: P.<x> = QQ[]\n+  sage: L.<b> = NumberField(x^8-x^4+1, embedding=CDF.0)\n+  sage: M1.<c1> = NumberField(x^2+x+1, embedding=b^4-1)\n+  sage: M2.<c2> = NumberField(x^2+1, embedding=-b^6)\n+  sage: M1.coerce_map_from(M2)\n+  sage: M2.coerce_map_from(M1)\n+  sage: c1+c2; parent(c1+c2)    #indirect doctest\n+  Traceback (most recent call last):\n+  ...\n+  TypeError: unsupported operand parent(s) for '+': 'Number Field in c1 with defining polynomial x^2 + x + 1' and 'Number Field in c2 with defining polynomial x^2 + 1'\n+  sage: from sage.categories.pushout import pushout\n+  sage: pushout(M1['x'],M2['x'])\n+  Traceback (most recent call last):\n+  ...\n+  CoercionException: No common base\n+  ```\n+\n+  Now: Note that we will only have a pushout if the codomains of the embeddings are number fields. Hence, in the second example, we won't use `CDF` as a pushout.\n+\n+  ```\n+  sage: P.<x> = QQ[]\n+  sage: L.<b> = NumberField(x^8-x^4+1, embedding=CDF.0)\n+  sage: M1.<c1> = NumberField(x^2+x+1, embedding=b^4-1)\n+  sage: M2.<c2> = NumberField(x^2+1, embedding=-b^6)\n+  sage: M1.coerce_map_from(M2)\n+  sage: M2.coerce_map_from(M1)\n+  sage: c1+c2; parent(c1+c2)    #indirect doctest\n+  -b^6 + b^4 - 1\n+  Number Field in b with defining polynomial x^8 - x^4 + 1\n+  sage: from sage.categories.pushout import pushout\n+  sage: pushout(M1['x'],M2['x'])\n+  Univariate Polynomial Ring in x over Number Field in b with defining polynomial x^8 - x^4 + 1\n+  sage: K.<a> = NumberField(x^3-2, embedding=CDF(1/2*I*2^(1/3)*sqrt(3) - 1/2*2^(1/3)))\n+  sage: L.<b> = NumberField(x^6-2, embedding=1.1)\n+  sage: L.coerce_map_from(K)\n+  sage: K.coerce_map_from(L)\n+  sage: pushout(K,L)\n+  Traceback (most recent call last):\n+  ...\n+  CoercionException: ('Ambiguous Base Extension', Number Field in a with defining polynomial x^3 - 2, Number Field in b with defining polynomial x^6 - 2)\n ```\n-The forgetful functor should coincide with the identity functor, but inside ``ForgetfulFunctor``, the latter is called in the wrong way.\n+\n+__Comparison of fractional ideals / identity of Residue Fields__\n+\n+  Fractional ideals have a `__cmp__` method that only took into account the Hermite normal form. In addition with coercion, we obtain:\n+\n+  ```\n+  sage: L.<b> = NumberField(x^8-x^4+1)\n+  sage: F_2 = L.fractional_ideal(b^2-1)\n+  sage: F_4 = L.fractional_ideal(b^4-1)\n+  sage: F_2==F_4\n+  True\n+  sage: K.<r4> = NumberField(x^4-2)\n+  sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)\n+  sage: FK = K.fractional_ideal(K.0)\n+  sage: FL = L.fractional_ideal(L.0)\n+  sage: FK == FL\n+  True\n+  ```\n+\n+  Since the residue fields of two equal fractional fields are the same (caching), we obtain:\n+\n+  ```\n+  sage: RL = ResidueField(FL)\n+  sage: RK = ResidueField(FK)\n+  sage: RK is RL\n+  True\n+  ```\n+\n+  Thus, `RK` is in fact defined with the embedded field `L`, not with the unembedded `K`. Hence, there is no coercion from the order of `K` to `RK`. However, *conversion* works (this used to fail!):\n+\n+  ```\n+  sage: OK = K.maximal_order()\n+  sage: RK.has_coerce_map_from(OK)\n+  False\n+  sage: RK(OK.1)\n+  0\n+  ```\n+\n+  Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal.\n+\n``````\n",
    "created_at": "2010-12-06T10:48:31Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73468",
    "user": "https://github.com/simon-king-jena"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -7,18 +7,520 @@
 morphism.pyx: 20% (5 of 24)
 pushout.py: 24% (19 of 77) 
 ```
-Trying to add doc tests, I actually found a bug:
-
+
+The original purpose of this ticket was to provide full doctest coverage for `functor.pyx` and `pushout.py`. **The doctest coverage of both files is now 100%**.
+
+
+However, the attempt to create meaningful doctests uncovered many bugs in various parts of Sage, and also motivated the implementation of coercion for various algebraic structures for which this has not been done before.
+
+This a-posteriori ticket description lists the bugs killed and the features added by the patch, which should apply (with a little fuzz) after the patch from #8807. For more details on the bugs, see the comments below.
+
+1. Bug: Creating `ForgetfulFunctor` fails.
+
+   Was:
+
+  ```
+  sage: abgrps = CommutativeAdditiveGroups()
+  sage: ForgetfulFunctor(abgrps, abgrps)
+  ---------------------------------------------------------------------------
+  TypeError                                 Traceback (most recent call last)
+  
+  /home/king/SAGE/patches/doku/english/<ipython console> in <module>()
+  
+  /home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/functor.so in sage.categories.functor.ForgetfulFunctor (sage/categories/functor.c:2083)()
+  
+  TypeError: IdentityFunctor() takes exactly one argument (2 given)
+   ```
+
+   Now:
+
+  ```
+  sage: abgrps = CommutativeAdditiveGroups()
+  sage: ForgetfulFunctor(abgrps, abgrps)
+  The identity functor on Category of commutative additive groups
+   ```
+
+2. Bug: Applying `ForgetfulFunctor` returns `None`.
+
+   Was:
+
+  ```
+  sage: fields = Fields()
+  sage: rings = Rings()
+  sage: F = ForgetfulFunctor(fields,rings)
+  sage: F(QQ)
+   ```
+
+   Now:
+
+  ```
+  sage: fields = Fields()
+  sage: rings = Rings()
+  sage: F = ForgetfulFunctor(fields,rings)
+  sage: F(QQ)
+  Rational Field
+   ```
+
+3. Bug: Applying a functor does not complain if the argument is not contained in the domain.
+
+   Was:
+
+  ```
+  sage: fields = Fields()
+  sage: rings = Rings()
+  sage: F = ForgetfulFunctor(fields,rings)
+  # Yields None, see previous bug
+  sage: F(ZZ['x','y'])
+   ```
+
+   Now:
+
+  ```
+  sage: fields = Fields()
+  sage: rings = Rings()
+  sage: F = ForgetfulFunctor(fields,rings)
+  sage: F(ZZ['x','y'])
+  Traceback (most recent call last):
+  ...
+  TypeError: x (=Multivariate Polynomial Ring in x, y over Integer Ring) is not in Category of fields
+   ```
+
+4. Bug: Comparing identity functor with any functor only checks domain and codomain
+
+   Was:
+
+  ```
+  sage: F = QQ['x'].construction()[0]
+  sage: F
+  Poly[x]
+  sage: F == IdentityFunctor(Rings())
+  False
+  sage: IdentityFunctor(Rings()) == F
+  True
+   ```
+
+   Now:
+
+  ```
+  sage: F = QQ['x'].construction()[0]
+  sage: F
+  Poly[x]
+  sage: F == IdentityFunctor(Rings())
+  False
+  sage: IdentityFunctor(Rings()) == F
+  False
+   ```
+
+5. Bug: Comparing identity functor with anything that is not a functor produces an error
+
+   Was:
+
+  ```
+  sage: IdentityFunctor(Rings()) == QQ
+  Traceback (most recent call last):
+  ...
+  AttributeError: 'RationalField_with_category' object has no attribute 'domain'
+   ```
+
+   Now:
+
+  ```
+  sage: IdentityFunctor(Rings()) == QQ
+  False
+   ```
+
+6. Bug: The matrix functor is ill defined; moreover, ill-definedness does not result in an error.
+
+   Was:
+
+  ```
+  sage: F = MatrixSpace(ZZ,2,3).construction()[0]
+  sage: F(RR) in F.codomain()
+  False
+  # The codomain is wrong for non-square matrices!
+  sage: F.codomain()
+  Category of rings
+   ```
+
+   Now:
+
+  ```
+  sage: F = MatrixSpace(ZZ,2,3).construction()[0]
+  sage: F.codomain()
+  Category of commutative additive groups
+  sage: F(RR) in F.codomain()
+  True
+  sage: F = MatrixSpace(ZZ,2,2).construction()[0]
+  sage: F.codomain()
+  Category of rings
+  sage: F(RR) in F.codomain()
+  True
+   ```
+
+7. Bug: Wrong domain for `VectorFunctor`; and again, functors don't test if the domain is appropriate
+
+   Was:
+
+  ```
+  sage: F = FreeModule(ZZ,3).construction()[0]
+  sage: F
+  VectorFunctor
+  sage: F.domain()
+  Category of objects
+  sage: F.codomain()
+  Category of objects
+  sage: Set([1,2,3]) in F.domain()
+  True
+  sage: F(Set([1,2,3]))
+  Traceback (most recent call last):
+  ...
+  AttributeError: 'Set_object_enumerated' object has no attribute 'is_commutative'
+   ```
+
+   Now:
+
+  ```
+  sage: F = FreeModule(ZZ,3).construction()[0]
+  sage: F
+  VectorFunctor
+  sage: F.domain()
+  Category of commutative rings
+  sage: Set([1,2,3]) in F.domain()
+  False
+  sage: F(Set([1,2,3]))
+  Traceback (most recent call last):
+  ...
+  TypeError: x (={1, 2, 3}) is not in Category of commutative rings
+   ```
+
+8. Bug: `BlackBoxConstructionFunctor` is completely unusable
+
+`BlackBoxConstructionFunctor` should be a class, but is defined as a function. Moreover, the given init method is not using the init method of `ConstructionFunctor`. And the cmp method would raise an error if the second argument has no attribute `.box`. 
+
+  The following did not work at all:
+
+  ```
+  sage: from sage.categories.pushout import BlackBoxConstructionFunctor
+  sage: FG = BlackBoxConstructionFunctor(gap)
+  sage: FS = BlackBoxConstructionFunctor(singular)
+  sage: FG
+  BlackBoxConstructionFunctor
+  sage: FG(ZZ)
+  Integers
+  sage: FG(ZZ).parent()
+  Gap
+  sage: FS(QQ['t'])
+  //   characteristic : 0
+  //   number of vars : 1
+  //        block   1 : ordering lp
+  //                  : names    t
+  //        block   2 : ordering C
+  sage: FG == FS
+  False
+  sage: FG == loads(dumps(FG))
+  True
 ```
-sage: abgrps = CommutativeAdditiveGroups()
-sage: ForgetfulFunctor(abgrps, abgrps)
----------------------------------------------------------------------------
-TypeError                                 Traceback (most recent call last)
-
-/home/king/SAGE/patches/doku/english/<ipython console> in <module>()
-
-/home/king/SAGE/sage-4.3.1/local/lib/python2.6/site-packages/sage/categories/functor.so in sage.categories.functor.ForgetfulFunctor (sage/categories/functor.c:2083)()
-
-TypeError: IdentityFunctor() takes exactly one argument (2 given)
+
+9. Nitpicking: The `LocalizationFunctor` is nowhere used (yet)
+
+Hence, I removed it.
+
+10. Bug / New Feature: Make completion and and fraction field construction functors commute.
+
+The result of them not commuting is the following coercion bug.
+
+  Was:
+
+  ```
+  sage: R1.<x> = Zp(5)[]
+  sage: R2 = Qp(5)
+  sage: R2(1)+x
+  Traceback (most recent call last):
+  ...
+  TypeError: unsupported operand parent(s) for '+': '5-adic Field with capped relative precision 20' and 'Univariate Polynomial Ring in x over 5-adic Ring with capped relative precision 20'
+  ```
+
+  Now:
+
+  ```
+  sage: R1.<x> = Zp(5)[]
+  sage: R2 = Qp(5)
+  sage: R2(1)+x
+  (1 + O(5^20))*x + (1 + O(5^20))
+  ```
+
+11. New feature: Make the completion functor work on some objects that do not provide a completion method.
+
+The idea is to use that the completion functor may commute with the construction of the given argument. That may safe the day.
+
+  Was:
+
+  ```
+  sage: P.<x> = ZZ[]
+  sage: C = P.completion(x).construction()[0]
+  sage: R = FractionField(P)
+  sage: hasattr(R,'completion')
+  False
+  sage: C(R)
+  Traceback (most recent  call last):
+  ...
+  AttributeError: 'FractionField_generic' object has no attribute 'completion'
+  ```
+
+  Now:
+
+  ```
+  sage: P.<x> = ZZ[]
+  sage: C = P.completion(x).construction()[0]
+  sage: R = FractionField(P)
+  sage: hasattr(R,'completion')
+  False
+  sage: C(R)
+  Fraction Field of Power Series Ring in x over Integer Ring
+  ```
+
+12. Bug / new feature: Coercion for free modules, taking into account a user-defined inner product
+
+   Was:
+
+  ```
+  sage: P.<t> = ZZ[]
+  sage: M1 = FreeModule(P,3)
+  sage: M2 = QQ^3
+  sage: M2([1,1/2,1/3]) + M1([t,t^2+t,3])     # This is ok
+  (t + 1, t^2 + t + 1/2, 10/3)
+  sage: M3 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,range(9)))
+  sage: M2([1,1/2,1/3]) + M3([t,t^2+t,3])     # This is ok
+  (t + 1, t^2 + t + 1/2, 10/3)
+  # The user defined inner product matrix is lost! Bug
+  sage: parent(M2([1,1/2,1/3]) + M3([t,t^2+t,3])).inner_product_matrix()
+  [1 0 0]
+  [0 1 0]
+  [0 0 1]
+   ```
+
+   Now:
+
+  ```
+  sage: parent(M2([1,1/2,1/3]) + M3([t,t^2+t,3])).inner_product_matrix()
+  [0 1 2]
+  [3 4 5]
+  [6 7 8]
+   ```
+
+   However, the real problem is that modules are not part of the coercion model. I tried to implement it, but that turned out to be a can of worms. So, **I suggest to deal with it on a different ticket**. Here is one bug that isn't removed, yet:
+
+  ```
+  sage: M4 = FreeModule(P,3, inner_product_matrix = Matrix(3,3,[1,1,1,0,1,1,0,0,1]))
+  sage: M3([t,1,t^2]) + M4([t,t^2+t,3])     # This should result in an error
+  (2*t, t^2 + t + 1, t^2 + 3)
+   ```
+   Note that there should be no coercion between `M3` and `M4`, since they have different user-defined inner product matrices.
+
+
+23. Bug / new feature: Quotient rings of univariate polynomial rings do not have a construction method.
+
+   Was:
+
+  ```
+  sage: P.<x> = QQ[]
+  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])
+  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])
+  sage: from sage.categories.pushout import pushout
+  sage: pushout(Q1,Q2)
+  Traceback (most recent call last):
+  ...
+  CoercionException: No common base
+   ```
+
+   Now:
+
+  ```
+  sage: P.<x> = QQ[]
+  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])
+  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])
+  sage: from sage.categories.pushout import pushout
+  sage: pushout(Q1,Q2)
+  Univariate Quotient Polynomial Ring in xbar over Rational Field with modulus x^4 + 2*x^2 + 1
+   ```
+
+34. Insufficient coercion of quotient rings, if one modulus divides the other
+
+   Was:
+
+  ```
+  sage: P5.<x> = GF(5)[]
+  sage: Q = P5.quo([(x^2+1)^2])
+  sage: P.<x> = ZZ[]
+  sage: Q1 = P.quo([(x^2+1)^2*(x^2-3)])
+  sage: Q2 = P.quo([(x^2+1)^2*(x^5+3)])
+  sage: Q.has_coerce_map_from(Q1)
+  False
+   ```
+
+   Now: There is a coercion from `Q1` to `Q`.
+
+45. Coercion of `GF(p)` versus `Integers(p)`
+
+I am not sure if this is really a bug.
+
+  Was:
+
+  ```
+  sage: from sage.categories.pushout import pushout
+  sage: pushout(GF(5), Integers(5))
+  Ring of integers modulo 5
+  ```
+
+  Now
+
+  ```
+  sage: from sage.categories.pushout import pushout
+  sage: pushout(GF(5), Integers(5))
+  Finite Field of size 5
+  ```
+
+16. Bug / new feature: Construction for QQbar was missing.
+
+   Now:
+
+  ```
+  sage: QQbar.construction()
+  (AlgebraicClosureFunctor, Rational Field)
+   ```
+
+27. Bug / new feature: Construction for number fields is missing.
+
+This became a rather complicated topic, including "coercions for embedded versus non-embedded number fields and coercion for an order from a coercion from the ambient field", "pushout for number fields", "comparison of fractional ideals", "identity of residue fields". See three discussions on sage-algebra and sage-nt
+* [Bidirectional coercions](http://groups.google.com/group/sage-nt/browse_thread/thread/32b65a5173f43267)
+* [Coercions for number fields](http://groups.google.com/group/sage-nt/browse_thread/thread/5c376dbf7e99ea97)
+* [Comparison of fractional ideals](http://groups.google.com/group/sage-nt/browse_thread/thread/54c1e33872d14334)
+
+__Coercion__
+
+  Was:
+
+  ```
+  sage: K.<r4> = NumberField(x^4-2)
+  sage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)
+  sage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)
+  sage: r2_1+r2_2    # indirect doctest
+  ERROR: An unexpected error occurred while tokenizing input
+  The following traceback may be corrupted or invalid
+  The error message is: ('EOF in multi-line statement', (1109, 0))
+  
+  ERROR: An unexpected error occurred while tokenizing input
+  The following traceback may be corrupted or invalid
+  The error message is: ('EOF in multi-line statement', (1109, 0))
+  
+  ...
+  sage: K.has_coerce_map_from(L1.maximal_order())
+  False   # that's the wrong direction.
+  sage: L1.has_coerce_map_from(K.maximal_order())
+  True
+  ```
+
+  Now:
+
+  ```
+  sage: K.<r4> = NumberField(x^4-2)
+  sage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)
+  sage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)
+  sage: r2_1+r2_2    # indirect doctest
+  0
+  sage: (r2_1+r2_2).parent() is L1
+  True
+  sage: (r2_2+r2_1).parent() is L2
+  True
+  sage: K.has_coerce_map_from(L1.maximal_order())
+  True
+  sage: L1.has_coerce_map_from(K.maximal_order())
+  False
+  ```
+
+__Pushout__
+
+  Was:
+
+  ```
+  sage: P.<x> = QQ[]
+  sage: L.<b> = NumberField(x^8-x^4+1, embedding=CDF.0)
+  sage: M1.<c1> = NumberField(x^2+x+1, embedding=b^4-1)
+  sage: M2.<c2> = NumberField(x^2+1, embedding=-b^6)
+  sage: M1.coerce_map_from(M2)
+  sage: M2.coerce_map_from(M1)
+  sage: c1+c2; parent(c1+c2)    #indirect doctest
+  Traceback (most recent call last):
+  ...
+  TypeError: unsupported operand parent(s) for '+': 'Number Field in c1 with defining polynomial x^2 + x + 1' and 'Number Field in c2 with defining polynomial x^2 + 1'
+  sage: from sage.categories.pushout import pushout
+  sage: pushout(M1['x'],M2['x'])
+  Traceback (most recent call last):
+  ...
+  CoercionException: No common base
+  ```
+
+  Now: Note that we will only have a pushout if the codomains of the embeddings are number fields. Hence, in the second example, we won't use `CDF` as a pushout.
+
+  ```
+  sage: P.<x> = QQ[]
+  sage: L.<b> = NumberField(x^8-x^4+1, embedding=CDF.0)
+  sage: M1.<c1> = NumberField(x^2+x+1, embedding=b^4-1)
+  sage: M2.<c2> = NumberField(x^2+1, embedding=-b^6)
+  sage: M1.coerce_map_from(M2)
+  sage: M2.coerce_map_from(M1)
+  sage: c1+c2; parent(c1+c2)    #indirect doctest
+  -b^6 + b^4 - 1
+  Number Field in b with defining polynomial x^8 - x^4 + 1
+  sage: from sage.categories.pushout import pushout
+  sage: pushout(M1['x'],M2['x'])
+  Univariate Polynomial Ring in x over Number Field in b with defining polynomial x^8 - x^4 + 1
+  sage: K.<a> = NumberField(x^3-2, embedding=CDF(1/2*I*2^(1/3)*sqrt(3) - 1/2*2^(1/3)))
+  sage: L.<b> = NumberField(x^6-2, embedding=1.1)
+  sage: L.coerce_map_from(K)
+  sage: K.coerce_map_from(L)
+  sage: pushout(K,L)
+  Traceback (most recent call last):
+  ...
+  CoercionException: ('Ambiguous Base Extension', Number Field in a with defining polynomial x^3 - 2, Number Field in b with defining polynomial x^6 - 2)
 ```
-The forgetful functor should coincide with the identity functor, but inside ``ForgetfulFunctor``, the latter is called in the wrong way.
+
+__Comparison of fractional ideals / identity of Residue Fields__
+
+  Fractional ideals have a `__cmp__` method that only took into account the Hermite normal form. In addition with coercion, we obtain:
+
+  ```
+  sage: L.<b> = NumberField(x^8-x^4+1)
+  sage: F_2 = L.fractional_ideal(b^2-1)
+  sage: F_4 = L.fractional_ideal(b^4-1)
+  sage: F_2==F_4
+  True
+  sage: K.<r4> = NumberField(x^4-2)
+  sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)
+  sage: FK = K.fractional_ideal(K.0)
+  sage: FL = L.fractional_ideal(L.0)
+  sage: FK == FL
+  True
+  ```
+
+  Since the residue fields of two equal fractional fields are the same (caching), we obtain:
+
+  ```
+  sage: RL = ResidueField(FL)
+  sage: RK = ResidueField(FK)
+  sage: RK is RL
+  True
+  ```
+
+  Thus, `RK` is in fact defined with the embedded field `L`, not with the unembedded `K`. Hence, there is no coercion from the order of `K` to `RK`. However, *conversion* works (this used to fail!):
+
+  ```
+  sage: OK = K.maximal_order()
+  sage: RK.has_coerce_map_from(OK)
+  False
+  sage: RK(OK.1)
+  0
+  ```
+
+  Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal.
+
``````




---

archive/issue_events_063183.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2010-12-06T10:48:31Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "rename": {
        "from": "Doctest coverage of categories",
        "to": "Doctest coverage of categories - numerous coercion fixes"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63183"
}
```



---

archive/issue_events_063184.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2010-12-06T10:51:44Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63184"
}
```



---

archive/issue_events_063185.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2010-12-06T10:51:44Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63185"
}
```



---

archive/issue_comments_073469.json:
```json
{
    "body": "<a id='comment:36'></a>\nNow, as the patch is updated, it is again ready for review. See the new ticket description for an account of what the patch does.",
    "created_at": "2010-12-06T10:51:44Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73469",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:36'></a>
Now, as the patch is updated, it is again ready for review. See the new ticket description for an account of what the patch does.



---

archive/issue_comments_073470.json:
```json
{
    "body": "<a id='comment:37'></a>\nThere is quite a lot of work here. Thanks!\n\nCould you please coordinate this patch with #10318? That ticket already has a positive review, is related to #8807 and is incompatible with #8800.\n\nI have not read the code yet, but about problem 17. In which I participated partially I am not sure to like the solution.\n\n```\nsage: K.<r4> = NumberField(x^4-2)\nsage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)\nsage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)\nsage: r2_1+r2_2    # indirect doctest\n0\nsage: (r2_1+r2_2).parent() is L1\nTrue\nsage: (r2_2+r2_1).parent() is L2\nTrue\n```\n\nNow I realise that there was some dicussion in sage-nt. Are there more examples in which the parent depends on the order of operands? I understand that this happen only where the parents are canonically isomorphic.",
    "created_at": "2010-12-06T11:54:29Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73470",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:37'></a>
There is quite a lot of work here. Thanks!

Could you please coordinate this patch with #10318? That ticket already has a positive review, is related to #8807 and is incompatible with #8800.

I have not read the code yet, but about problem 17. In which I participated partially I am not sure to like the solution.

```
sage: K.<r4> = NumberField(x^4-2)
sage: L1.<r2_1> = NumberField(x^2-2, embedding = r4**2)
sage: L2.<r2_2> = NumberField(x^2-2, embedding = -r4**2)
sage: r2_1+r2_2    # indirect doctest
0
sage: (r2_1+r2_2).parent() is L1
True
sage: (r2_2+r2_1).parent() is L2
True
```

Now I realise that there was some dicussion in sage-nt. Are there more examples in which the parent depends on the order of operands? I understand that this happen only where the parents are canonically isomorphic.



---

archive/issue_events_063186.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2010-12-06T11:54:29Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63186"
}
```



---

archive/issue_events_063187.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2010-12-06T11:54:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63187"
}
```



---

archive/issue_comments_073471.json:
```json
{
    "body": "<a id='comment:38'></a>\nI should have read the threads before posting. I see that the bahaviour with different parents was already present in Sage for fields with embedding to CDF. So I have nothing to say about this.",
    "created_at": "2010-12-06T12:05:02Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73471",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:38'></a>
I should have read the threads before posting. I see that the bahaviour with different parents was already present in Sage for fields with embedding to CDF. So I have nothing to say about this.



---

archive/issue_comments_073472.json:
```json
{
    "body": "**Work Issues:** Compatibility with #10318",
    "created_at": "2010-12-06T12:35:40Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73472",
    "user": "https://github.com/simon-king-jena"
}
```

**Work Issues:** Compatibility with #10318



---

archive/issue_comments_073473.json:
```json
{
    "body": "<a id='comment:39'></a>\nReplying to [lftabera](#comment%3A37):\n> Could you please coordinate this patch with #10318? That ticket already has a positive review, is related to #8807 and is incompatible with #8800.\n\n\nOK, I'll try. I'm putting it into the \"work issues\" field.",
    "created_at": "2010-12-06T12:35:40Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73473",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:39'></a>
Replying to [lftabera](#comment%3A37):
> Could you please coordinate this patch with #10318? That ticket already has a positive review, is related to #8807 and is incompatible with #8800.


OK, I'll try. I'm putting it into the "work issues" field.



---

archive/issue_comments_073474.json:
```json
{
    "body": "<a id='comment:40'></a>\nReplying to [SimonKing](#comment%3A39):\n> Replying to [lftabera](#comment%3A37):\n> > Could you please coordinate this patch with #10318? That ticket already has a positive review, is related to #8807 and is incompatible with #8800.\n\n> \n> OK, I'll try. I'm putting it into the \"work issues\" field.\n\n\nI'm sorry that it was my trivial patch (spelling correction) which cased this.  A simple search-and-replace will be all that is required to make this patch apply after #10318.",
    "created_at": "2010-12-06T12:38:17Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73474",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:40'></a>
Replying to [SimonKing](#comment%3A39):
> Replying to [lftabera](#comment%3A37):
> > Could you please coordinate this patch with #10318? That ticket already has a positive review, is related to #8807 and is incompatible with #8800.

> 
> OK, I'll try. I'm putting it into the "work issues" field.


I'm sorry that it was my trivial patch (spelling correction) which cased this.  A simple search-and-replace will be all that is required to make this patch apply after #10318.



---

archive/issue_events_063188.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2010-12-06T13:31:40Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63188"
}
```



---

archive/issue_events_063189.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2010-12-06T13:31:40Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63189"
}
```



---

archive/issue_comments_073475.json:
```json
{
    "body": "**Changing work issues** from \"Compatibility with #10318\" to \"\".",
    "created_at": "2010-12-06T13:31:40Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73475",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "Compatibility with #10318" to "".



---

archive/issue_comments_073476.json:
```json
{
    "body": "<a id='comment:41'></a>\nReplying to [cremona](#comment%3A40):\n> I'm sorry that it was my trivial patch (spelling correction) which cased this.  A simple search-and-replace will be all that is required to make this patch apply after #10318.\n\n\nYes, it seems that it was really to solve by a simple search-and-replace. The patch should now apply after #8807 and #10318. So, back to \"needs review\".\n\nBest regards,\n\nSimon",
    "created_at": "2010-12-06T13:31:40Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73476",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:41'></a>
Replying to [cremona](#comment%3A40):
> I'm sorry that it was my trivial patch (spelling correction) which cased this.  A simple search-and-replace will be all that is required to make this patch apply after #10318.


Yes, it seems that it was really to solve by a simple search-and-replace. The patch should now apply after #8807 and #10318. So, back to "needs review".

Best regards,

Simon



---

archive/issue_comments_073477.json:
```json
{
    "body": "<a id='comment:42'></a>\nCould one of you please test on 32 bit? I had to change the doc test of selmer_group: With my patch, I get on 64-bit the same output that was previously only expected on 32-bit. So, I could imagine that the expected output on 32-bit needs to be changed as well.\n\nCheers,\n\nSimon",
    "created_at": "2010-12-06T20:09:23Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73477",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:42'></a>
Could one of you please test on 32 bit? I had to change the doc test of selmer_group: With my patch, I get on 64-bit the same output that was previously only expected on 32-bit. So, I could imagine that the expected output on 32-bit needs to be changed as well.

Cheers,

Simon



---

archive/issue_comments_073478.json:
```json
{
    "body": "<a id='comment:43'></a>\nReplying to [SimonKing](#comment%3A42):\n> Could one of you please test on 32 bit? I had to change the doc test of selmer_group: With my patch, I get on 64-bit the same output that was previously only expected on 32-bit. So, I could imagine that the expected output on 32-bit needs to be changed as well.\n\n\nOK, will do -- it will on top of 4.6.1.alpha2 since I don't yet have a 32-bit build of alpha3.\n\n> \n> Cheers,\n> \n> Simon\n",
    "created_at": "2010-12-06T21:12:04Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73478",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:43'></a>
Replying to [SimonKing](#comment%3A42):
> Could one of you please test on 32 bit? I had to change the doc test of selmer_group: With my patch, I get on 64-bit the same output that was previously only expected on 32-bit. So, I could imagine that the expected output on 32-bit needs to be changed as well.


OK, will do -- it will on top of 4.6.1.alpha2 since I don't yet have a 32-bit build of alpha3.

> 
> Cheers,
> 
> Simon




---

archive/issue_comments_073479.json:
```json
{
    "body": "<a id='comment:44'></a>\nApplies fine after #8807 and #10318.  Testing now: will take some time.\n\nI'm not sure that the buildbot will know how to apply just the last patch from #8807 and then the one from #10318.",
    "created_at": "2010-12-06T21:18:35Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73479",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:44'></a>
Applies fine after #8807 and #10318.  Testing now: will take some time.

I'm not sure that the buildbot will know how to apply just the last patch from #8807 and then the one from #10318.



---

archive/issue_comments_073480.json:
```json
{
    "body": "<a id='comment:45'></a>\nTest failures:\n\n```\nsage -t  \"sage/groups/perm_gps/permgroup.py\"                \n**********************************************************************\nFile \"/home/john/sage-4.6.1.alpha2/devel/sage-main/sage/groups/perm_gps/permgroup.py\", line 1114:\n    sage: G.random_element()\nExpected:\n    (2,3)(4,5)\nGot:\n    (1,2)(4,5)\n**********************************************************************\n1 items had failures:\n   1 of   4 in __main__.example_34\n***Test Failed*** 1 failures.\nFor whitespace errors, see the file /home/john/.sage//tmp/.doctest_permgroup.py\n\t [7.8 s]\n \n----------------------------------------------------------------------\nThe following tests failed:\n\n\n\tsage -t  \"sage/groups/perm_gps/permgroup.py\"\nTotal time for all tests: 7.9 seconds\njohn@John-laptop%sage -t  \"sage/rings/number_field/number_field.py\"\nsage -t  \"sage/rings/number_field/number_field.py\"          \nException RuntimeError: 'maximum recursion depth exceeded in __subclasscheck__' in <type 'exceptions.TypeError'> ignored\nException RuntimeError: 'maximum recursion depth exceeded in __subclasscheck__' in <type 'exceptions.TypeError'> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.GeneratorExit'> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.GeneratorExit'> ignored\nException GeneratorExit in <generator object <genexpr> at 0xc094e64> ignored\nException RuntimeError: 'maximum recursion depth exceeded in __subclasscheck__' in <type 'exceptions.TypeError'> ignored\nException RuntimeError: 'maximum recursion depth exceeded in __subclasscheck__' in <type 'exceptions.TypeError'> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.GeneratorExit'> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.GeneratorExit'> ignored\nException GeneratorExit in <generator object <genexpr> at 0xc094d74> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.TypeError'> ignored\nException RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.TypeError'> ignored\n**********************************************************************\nFile \"/home/john/sage-4.6.1.alpha2/devel/sage-main/sage/rings/number_field/number_field.py\", line 2960:\n    sage: K.selmer_group([K.ideal(2, -a+1), K.ideal(3, a+1), K.ideal(a)], 3)\nExpected:\n    [2, a + 1, a]    \nGot:\n    [2, a + 1, -a]\n**********************************************************************\n1 items had failures:\n   1 of  12 in __main__.example_62\n***Test Failed*** 1 failures.\nFor whitespace errors, see the file /home/john/.sage//tmp/.doctest_number_field.py\n\t [82.3 s]\n \n----------------------------------------------------------------------\nThe following tests failed:\n\n\n\tsage -t  \"sage/rings/number_field/number_field.py\"\n```",
    "created_at": "2010-12-07T08:07:31Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73480",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:45'></a>
Test failures:

```
sage -t  "sage/groups/perm_gps/permgroup.py"                
**********************************************************************
File "/home/john/sage-4.6.1.alpha2/devel/sage-main/sage/groups/perm_gps/permgroup.py", line 1114:
    sage: G.random_element()
Expected:
    (2,3)(4,5)
Got:
    (1,2)(4,5)
**********************************************************************
1 items had failures:
   1 of   4 in __main__.example_34
***Test Failed*** 1 failures.
For whitespace errors, see the file /home/john/.sage//tmp/.doctest_permgroup.py
	 [7.8 s]
 
----------------------------------------------------------------------
The following tests failed:


	sage -t  "sage/groups/perm_gps/permgroup.py"
Total time for all tests: 7.9 seconds
john@John-laptop%sage -t  "sage/rings/number_field/number_field.py"
sage -t  "sage/rings/number_field/number_field.py"          
Exception RuntimeError: 'maximum recursion depth exceeded in __subclasscheck__' in <type 'exceptions.TypeError'> ignored
Exception RuntimeError: 'maximum recursion depth exceeded in __subclasscheck__' in <type 'exceptions.TypeError'> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.GeneratorExit'> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.GeneratorExit'> ignored
Exception GeneratorExit in <generator object <genexpr> at 0xc094e64> ignored
Exception RuntimeError: 'maximum recursion depth exceeded in __subclasscheck__' in <type 'exceptions.TypeError'> ignored
Exception RuntimeError: 'maximum recursion depth exceeded in __subclasscheck__' in <type 'exceptions.TypeError'> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.GeneratorExit'> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.GeneratorExit'> ignored
Exception GeneratorExit in <generator object <genexpr> at 0xc094d74> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.TypeError'> ignored
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.TypeError'> ignored
**********************************************************************
File "/home/john/sage-4.6.1.alpha2/devel/sage-main/sage/rings/number_field/number_field.py", line 2960:
    sage: K.selmer_group([K.ideal(2, -a+1), K.ideal(3, a+1), K.ideal(a)], 3)
Expected:
    [2, a + 1, a]    
Got:
    [2, a + 1, -a]
**********************************************************************
1 items had failures:
   1 of  12 in __main__.example_62
***Test Failed*** 1 failures.
For whitespace errors, see the file /home/john/.sage//tmp/.doctest_number_field.py
	 [82.3 s]
 
----------------------------------------------------------------------
The following tests failed:


	sage -t  "sage/rings/number_field/number_field.py"
```



---

archive/issue_comments_073481.json:
```json
{
    "body": "<a id='comment:46'></a>\nHi John!\n\nIs that 32 or 64 bit? Because:\n\nReplying to [cremona](#comment%3A45):\n> sage -t  \"sage/groups/perm_gps/permgroup.py\"                \n> **********************************************************************\n> File \"/home/john/sage-4.6.1.alpha2/devel/sage-main/sage/groups/perm_gps/permgroup.py\", line 1114:\n>     sage: G.random_element()\n> Expected:\n>     (2,3)(4,5)\n> Got:\n>     (1,2)(4,5)\n\n\nI changed the expected element. (1,2)(4,5) was originally expected, but I obtain (2,3)(4,5) on my machine (after applying the patch).\n\n> File \"/home/john/sage-4.6.1.alpha2/devel/sage-main/sage/rings/number_field/number_field.py\", line 2960:\n>     sage: K.selmer_group([K.ideal(2, -a+1), K.ideal(3, a+1), K.ideal(a)], 3)\n> Expected:\n>     [2, a + 1, a]    \n> Got:\n>     [2, a + 1, -a]\n\n\nThis one I also changed. [2, a + 1, -a] was originally expected with 64-bit. But after applying the patch, I got [2, a + 1, a], which was originally expected with 32-bit.\n\nStrange. What can one do to get a reproducible result?",
    "created_at": "2010-12-07T08:22:26Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73481",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:46'></a>
Hi John!

Is that 32 or 64 bit? Because:

Replying to [cremona](#comment%3A45):
> sage -t  "sage/groups/perm_gps/permgroup.py"                
> **********************************************************************
> File "/home/john/sage-4.6.1.alpha2/devel/sage-main/sage/groups/perm_gps/permgroup.py", line 1114:
>     sage: G.random_element()
> Expected:
>     (2,3)(4,5)
> Got:
>     (1,2)(4,5)


I changed the expected element. (1,2)(4,5) was originally expected, but I obtain (2,3)(4,5) on my machine (after applying the patch).

> File "/home/john/sage-4.6.1.alpha2/devel/sage-main/sage/rings/number_field/number_field.py", line 2960:
>     sage: K.selmer_group([K.ideal(2, -a+1), K.ideal(3, a+1), K.ideal(a)], 3)
> Expected:
>     [2, a + 1, a]    
> Got:
>     [2, a + 1, -a]


This one I also changed. [2, a + 1, -a] was originally expected with 64-bit. But after applying the patch, I got [2, a + 1, a], which was originally expected with 32-bit.

Strange. What can one do to get a reproducible result?



---

archive/issue_comments_073482.json:
```json
{
    "body": "<a id='comment:47'></a>\nI got the same error in permgroup.py in both 32 and 64 bits. I got the permutation (1,2)(4,5) in two different machines with 4.6 + patches from this ticket.\n\nWe can investigate further what is going on, but I do not like this kind of tests against random_element. Even if we use the same seed. Is there a policy to deal with random_element methods?\n\nWhat about something like?\n\n```\nsage: a= G.random_element()\nsage: a in G\nTrue\nsage: a.parent() is G\nTrue\nsage: a**6\n()\n```\n\nAbout the errors in number_field all tests passes in 64 bits but I get the same errors as John in 32 bits. Concerning selmer group. Are both results right or only one of them?",
    "created_at": "2010-12-07T08:56:50Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73482",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:47'></a>
I got the same error in permgroup.py in both 32 and 64 bits. I got the permutation (1,2)(4,5) in two different machines with 4.6 + patches from this ticket.

We can investigate further what is going on, but I do not like this kind of tests against random_element. Even if we use the same seed. Is there a policy to deal with random_element methods?

What about something like?

```
sage: a= G.random_element()
sage: a in G
True
sage: a.parent() is G
True
sage: a**6
()
```

About the errors in number_field all tests passes in 64 bits but I get the same errors as John in 32 bits. Concerning selmer group. Are both results right or only one of them?



---

archive/issue_comments_073483.json:
```json
{
    "body": "<a id='comment:48'></a>\nReplying to [lftabera](#comment%3A47):\n> I got the same error in permgroup.py in both 32 and 64 bits. I got the permutation (1,2)(4,5) in two different machines with 4.6 + patches from this ticket.\n\n\nReally strange.\n\n> We can investigate further what is going on, but I do not like this kind of tests against random_element. Even if we use the same seed.\n\n\nWell, we *do* use the same seed. So, it has to be reproducible.\n\n> What about something like?\n> \n> ```\n> sage: a= G.random_element()\n> sage: a in G\n> True\n> sage: a.parent() is G\n> True\n> sage: a**6\n> ()\n> ```\n\n\nI guess there is currently a related discussion at [sage-devel](http://groups.google.com/group/sage-devel/browse_thread/thread/c201930abdbd23d3)\n\n> About the errors in number_field all tests passes in 64 bits but I get the same errors as John in 32 bits. Concerning selmer group. Are both results right or only one of them?\n\n\nBoth are right. The method is supposed to return *a* generating set. And that is the case for both answers. And in the original version, the expected answer did depend on 32- versus 64-bit.\n\nBest regards,\n\nSimon",
    "created_at": "2010-12-07T09:08:26Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73483",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:48'></a>
Replying to [lftabera](#comment%3A47):
> I got the same error in permgroup.py in both 32 and 64 bits. I got the permutation (1,2)(4,5) in two different machines with 4.6 + patches from this ticket.


Really strange.

> We can investigate further what is going on, but I do not like this kind of tests against random_element. Even if we use the same seed.


Well, we *do* use the same seed. So, it has to be reproducible.

> What about something like?
> 
> ```
> sage: a= G.random_element()
> sage: a in G
> True
> sage: a.parent() is G
> True
> sage: a**6
> ()
> ```


I guess there is currently a related discussion at [sage-devel](http://groups.google.com/group/sage-devel/browse_thread/thread/c201930abdbd23d3)

> About the errors in number_field all tests passes in 64 bits but I get the same errors as John in 32 bits. Concerning selmer group. Are both results right or only one of them?


Both are right. The method is supposed to return *a* generating set. And that is the case for both answers. And in the original version, the expected answer did depend on 32- versus 64-bit.

Best regards,

Simon



---

archive/issue_comments_073484.json:
```json
{
    "body": "<a id='comment:49'></a>\nMy tests were on 32-bit 4.6.1.alpha2.\n\nIn the Selmer group test both results are correct. It is very common for pari output to be different on 32- and 64-bit, and that the underlying this computation. The output numbers are generating a group which is abstractly (Z/3Z)3, so there is no unique generating set; and (worse) the elements themselves are representatives of cosets of K*/(K*)3.",
    "created_at": "2010-12-07T09:11:55Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73484",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:49'></a>
My tests were on 32-bit 4.6.1.alpha2.

In the Selmer group test both results are correct. It is very common for pari output to be different on 32- and 64-bit, and that the underlying this computation. The output numbers are generating a group which is abstractly (Z/3Z)3, so there is no unique generating set; and (worse) the elements themselves are representatives of cosets of K*/(K*)3.



---

archive/issue_comments_073485.json:
```json
{
    "body": "<a id='comment:50'></a>\nHi John!\n\nReplying to [cremona](#comment%3A49):\n> My tests were on 32-bit 4.6.1.alpha2.\n\n\nOK, that means that the results on 32-bit and on 64-bit are switched: I get on 64-bit the result that was previously expected on 32-bit, and you get on 32-bit the result that was previously expected on 64-bit. Or am I confusing things?",
    "created_at": "2010-12-07T09:24:44Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73485",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:50'></a>
Hi John!

Replying to [cremona](#comment%3A49):
> My tests were on 32-bit 4.6.1.alpha2.


OK, that means that the results on 32-bit and on 64-bit are switched: I get on 64-bit the result that was previously expected on 32-bit, and you get on 32-bit the result that was previously expected on 64-bit. Or am I confusing things?



---

archive/issue_comments_073486.json:
```json
{
    "body": "<a id='comment:51'></a>\nIt is surely possible that there are other differences between alpha2 and alpha3, so perhaps I should test again when I have built alpha3.  I just started that.  (This is a different machine -- my desktop at work -- than the one I tested alpha2 on, which was my laptop at home).",
    "created_at": "2010-12-07T09:37:04Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73486",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:51'></a>
It is surely possible that there are other differences between alpha2 and alpha3, so perhaps I should test again when I have built alpha3.  I just started that.  (This is a different machine -- my desktop at work -- than the one I tested alpha2 on, which was my laptop at home).



---

archive/issue_comments_073487.json:
```json
{
    "body": "<a id='comment:52'></a>\nReplying to [cremona](#comment%3A51):\n> It is surely possible that there are other differences between alpha2 and alpha3, so perhaps I should test again when I have built alpha3.  I just started that.  (This is a different machine -- my desktop at work -- than the one I tested alpha2 on, which was my laptop at home).\n> \n\n\nEven more confusing...\n\nBy the way, I tested based on sage-4.6, so, no alpha version.",
    "created_at": "2010-12-07T10:15:58Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73487",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:52'></a>
Replying to [cremona](#comment%3A51):
> It is surely possible that there are other differences between alpha2 and alpha3, so perhaps I should test again when I have built alpha3.  I just started that.  (This is a different machine -- my desktop at work -- than the one I tested alpha2 on, which was my laptop at home).
> 


Even more confusing...

By the way, I tested based on sage-4.6, so, no alpha version.



---

archive/issue_comments_073488.json:
```json
{
    "body": "<a id='comment:53'></a>\nI just tested on a different 32-bit machine on which I have just built 4.6.1.alpha3 (and all tests passed):  Same failure as before for sage/groups/perm_gps/permgroup.py, and for sage/groups/perm_gps/permgroup.py\n\nThe second one of these is the more worrying in that it goes into an infinite recursion.",
    "created_at": "2010-12-07T14:36:06Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73488",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:53'></a>
I just tested on a different 32-bit machine on which I have just built 4.6.1.alpha3 (and all tests passed):  Same failure as before for sage/groups/perm_gps/permgroup.py, and for sage/groups/perm_gps/permgroup.py

The second one of these is the more worrying in that it goes into an infinite recursion.



---

archive/issue_events_063190.json:
```json
{
    "actor": "https://github.com/JohnCremona",
    "created_at": "2010-12-07T14:36:06Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63190"
}
```



---

archive/issue_events_063191.json:
```json
{
    "actor": "https://github.com/JohnCremona",
    "created_at": "2010-12-07T14:36:06Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63191"
}
```



---

archive/issue_comments_073489.json:
```json
{
    "body": "<a id='comment:54'></a>\nHi John,\n\nReplying to [cremona](#comment%3A53):\n> I just tested on a different 32-bit machine on which I have just built 4.6.1.alpha3 (and all tests passed):  Same failure as before for sage/groups/perm_gps/permgroup.py, and for sage/groups/perm_gps/permgroup.py\n> \n> The second one of these is the more worrying in that it goes into an infinite recursion.\n\n\nI wonder if the recursion comes from the testing framework. Once, I observed such recursion in a test, but I could not reproduce it in  an interactive session. In addition, I got a return value different from the expected - and when I changed the expected  value in the test, the recursion disappeared as well.\n\nCould you change the expected 32-bit value in the test of selmer_group to the value that you get in an interactive session, and then try `sage -t  \"sage/rings/number_field/number_field.py\"` again?\n\nCheers,\n\nSimon",
    "created_at": "2010-12-07T16:23:25Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73489",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:54'></a>
Hi John,

Replying to [cremona](#comment%3A53):
> I just tested on a different 32-bit machine on which I have just built 4.6.1.alpha3 (and all tests passed):  Same failure as before for sage/groups/perm_gps/permgroup.py, and for sage/groups/perm_gps/permgroup.py
> 
> The second one of these is the more worrying in that it goes into an infinite recursion.


I wonder if the recursion comes from the testing framework. Once, I observed such recursion in a test, but I could not reproduce it in  an interactive session. In addition, I got a return value different from the expected - and when I changed the expected  value in the test, the recursion disappeared as well.

Could you change the expected 32-bit value in the test of selmer_group to the value that you get in an interactive session, and then try `sage -t  "sage/rings/number_field/number_field.py"` again?

Cheers,

Simon



---

archive/issue_comments_073490.json:
```json
{
    "body": "<a id='comment:55'></a>\nOK, I tried that.  Now all tests pass.  The relevant lines now look like\n\n```\n            sage: K.selmer_group([K.ideal(2, -a+1), K.ideal(3, a+1), K.ideal(a)], 3)\n            [2, a + 1, -a]    # 32-bit\n            [2, a + 1, a]   # 64-bit\n```\nwhile before the two expected outputs were the same despite the separation into 32 and 64 bit cases.  Was this just a typo?\n\nThere is still no explanation for why, when the expected and actual output differed, there was that infinite recursion.",
    "created_at": "2010-12-07T18:18:22Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73490",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:55'></a>
OK, I tried that.  Now all tests pass.  The relevant lines now look like

```
            sage: K.selmer_group([K.ideal(2, -a+1), K.ideal(3, a+1), K.ideal(a)], 3)
            [2, a + 1, -a]    # 32-bit
            [2, a + 1, a]   # 64-bit
```
while before the two expected outputs were the same despite the separation into 32 and 64 bit cases.  Was this just a typo?

There is still no explanation for why, when the expected and actual output differed, there was that infinite recursion.



---

archive/issue_comments_073491.json:
```json
{
    "body": "<a id='comment:56'></a>\nReplying to [cremona](#comment%3A55):\n> while before the two expected outputs were the same despite the separation into 32 and 64 bit cases.  Was this just a typo?\n\n\nNo. I simply have no 32-bit machine and couldn't test it. That's why I asked that some of you please test on 32-bit.\n \n> There is still no explanation for why, when the expected and actual output differed, there was that infinite recursion.\n\n\nYes. But it seems to me that it is located in the doctest framework.\n\nSo, unless you find more issues, I will post another patch that changes the expected value in case of 32-bit.\n\nCheers,\n\nSimon",
    "created_at": "2010-12-07T18:46:20Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73491",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:56'></a>
Replying to [cremona](#comment%3A55):
> while before the two expected outputs were the same despite the separation into 32 and 64 bit cases.  Was this just a typo?


No. I simply have no 32-bit machine and couldn't test it. That's why I asked that some of you please test on 32-bit.
 
> There is still no explanation for why, when the expected and actual output differed, there was that infinite recursion.


Yes. But it seems to me that it is located in the doctest framework.

So, unless you find more issues, I will post another patch that changes the expected value in case of 32-bit.

Cheers,

Simon



---

archive/issue_comments_073492.json:
```json
{
    "body": "<a id='comment:57'></a>\n> \n> So, unless you find more issues, I will post another patch that changes the expected value in case of 32-bit.\n\n\nGo for it!",
    "created_at": "2010-12-07T19:41:09Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73492",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:57'></a>
> 
> So, unless you find more issues, I will post another patch that changes the expected value in case of 32-bit.


Go for it!



---

archive/issue_comments_073493.json:
```json
{
    "body": "<a id='comment:58'></a>\nI confirm that changing the doctest makes all doctest pass.\n\nHowever, with the coercion of embedded and non embedded number fields, now addition is not associative.\n\n```\nsage: K1.<r1>=NumberField(x^2-2)\nsage: K2.<r2>=NumberField(x^2-2, embedding=1)\nsage: K3.<r3>=NumberField(x^2-2, embedding=-1)\nsage: (r1+r2)+r3\n3*r1\nsage: r1+(r2+r3)\nr1\n```\n\nr1+r2 is ambiguous. So either this operation should raise an error or it should add an embedding to K1 compatible with K2. But as far as I understand the coercion model the latter is not possible.",
    "created_at": "2010-12-07T20:00:33Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73493",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:58'></a>
I confirm that changing the doctest makes all doctest pass.

However, with the coercion of embedded and non embedded number fields, now addition is not associative.

```
sage: K1.<r1>=NumberField(x^2-2)
sage: K2.<r2>=NumberField(x^2-2, embedding=1)
sage: K3.<r3>=NumberField(x^2-2, embedding=-1)
sage: (r1+r2)+r3
3*r1
sage: r1+(r2+r3)
r1
```

r1+r2 is ambiguous. So either this operation should raise an error or it should add an embedding to K1 compatible with K2. But as far as I understand the coercion model the latter is not possible.



---

archive/issue_comments_073494.json:
```json
{
    "body": "<a id='comment:59'></a>\nReplying to [lftabera](#comment%3A58):\n> I confirm that changing the doctest makes all doctest pass.\n\n\nGood!\n\n> However, with the coercion of embedded and non embedded number fields, now addition is not associative.\n> \n> ```\n> sage: K1.<r1>=NumberField(x^2-2)\n> sage: K2.<r2>=NumberField(x^2-2, embedding=1)\n> sage: K3.<r3>=NumberField(x^2-2, embedding=-1)\n> sage: (r1+r2)+r3\n> 3*r1\n> sage: r1+(r2+r3)\n> r1\n> ```\n> \n> r1+r2 is ambiguous. So either this operation should raise an error or it should add an embedding to K1 compatible with K2. But as far as I understand the coercion model the latter is not possible.\n\n\nI disagree: It should not raise an error. This is a side-effect of Sage's coercion model. We (see discussion on sage-nt) do want a forgetful coercion from K2 to K1 and from K3 to K1; and we want a coercion between two embedded number fields induced by the embedding.\n\nHence, we have a coercion between K2 and K3 sending `r3` to `-r2`. Therefore `r2+r3` is `K2.zero()`, thus, `r1+(r2+r3)==r1`. On the other hand, `r1+r2` is `2*r1`, since the coercion from K2 to K1 sends `r2` to `r1`; and similarly `r3` is sent to `r1`, hence `(r1+r2)+r3==3*r1`.\n\nBut I suggest to discuss on sage-algebra whether people are really happy with that consequence of a forgetful coercion.",
    "created_at": "2010-12-07T20:31:49Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73494",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:59'></a>
Replying to [lftabera](#comment%3A58):
> I confirm that changing the doctest makes all doctest pass.


Good!

> However, with the coercion of embedded and non embedded number fields, now addition is not associative.
> 
> ```
> sage: K1.<r1>=NumberField(x^2-2)
> sage: K2.<r2>=NumberField(x^2-2, embedding=1)
> sage: K3.<r3>=NumberField(x^2-2, embedding=-1)
> sage: (r1+r2)+r3
> 3*r1
> sage: r1+(r2+r3)
> r1
> ```
> 
> r1+r2 is ambiguous. So either this operation should raise an error or it should add an embedding to K1 compatible with K2. But as far as I understand the coercion model the latter is not possible.


I disagree: It should not raise an error. This is a side-effect of Sage's coercion model. We (see discussion on sage-nt) do want a forgetful coercion from K2 to K1 and from K3 to K1; and we want a coercion between two embedded number fields induced by the embedding.

Hence, we have a coercion between K2 and K3 sending `r3` to `-r2`. Therefore `r2+r3` is `K2.zero()`, thus, `r1+(r2+r3)==r1`. On the other hand, `r1+r2` is `2*r1`, since the coercion from K2 to K1 sends `r2` to `r1`; and similarly `r3` is sent to `r1`, hence `(r1+r2)+r3==3*r1`.

But I suggest to discuss on sage-algebra whether people are really happy with that consequence of a forgetful coercion.



---

archive/issue_comments_073495.json:
```json
{
    "body": "**Work Issues:** change 32-bit test; remove forgetful coercion",
    "created_at": "2010-12-08T06:53:49Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73495",
    "user": "https://github.com/simon-king-jena"
}
```

**Work Issues:** change 32-bit test; remove forgetful coercion



---

archive/issue_comments_073496.json:
```json
{
    "body": "<a id='comment:61'></a>\nReplying to [lftabera](#comment%3A58):\n> However, with the coercion of embedded and non embedded number fields, now addition is not associative.\n\n\nAs you (? I guess `luisfe == lftabera`) pointed out at [sage-algebra](http://groups.google.com/group/sage-algebra/browse_thread/thread/889464bee6a6a036), the actual problem is not the non-associativity of the addition (after all, we have different algebraic structures involved, so, there is no reason to expect that it can be globally extended to something that is associative).\n\nYou convinced me that the actual problem is the fact that the coercions in your example do not form a commuting triangle: Coercion from `K3` to `K2` followed by forgetful coercion from `K2` to `K1` is not the same as the forgetful coercion from `K3` to `K1`.\n\nHence, I have to modify the `_coerce_map_from_` of number fields and probably also the merge method of `AlgebraicExtensionFunctor`.",
    "created_at": "2010-12-08T07:00:40Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73496",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:61'></a>
Replying to [lftabera](#comment%3A58):
> However, with the coercion of embedded and non embedded number fields, now addition is not associative.


As you (? I guess `luisfe == lftabera`) pointed out at [sage-algebra](http://groups.google.com/group/sage-algebra/browse_thread/thread/889464bee6a6a036), the actual problem is not the non-associativity of the addition (after all, we have different algebraic structures involved, so, there is no reason to expect that it can be globally extended to something that is associative).

You convinced me that the actual problem is the fact that the coercions in your example do not form a commuting triangle: Coercion from `K3` to `K2` followed by forgetful coercion from `K2` to `K1` is not the same as the forgetful coercion from `K3` to `K1`.

Hence, I have to modify the `_coerce_map_from_` of number fields and probably also the merge method of `AlgebraicExtensionFunctor`.



---

archive/issue_comments_073497.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -397,6 +397,16 @@\n * [Comparison of fractional ideals](http://groups.google.com/group/sage-nt/browse_thread/thread/54c1e33872d14334)\n \n __Coercion__\n+\n+Important for the discussion is: What will we do with embeddings? \n+\n+Currently, the embedding of two number fields is used to construct a coercion (compatible with the embedding). Of course, the given embedding is also used as a coerce map.\n+\n+It was discussed to additionally have a \"forgetful\" coercion from an embedded to a non-embedded number field.\n+\n+It turned out that with bidirectional and forgetful coercions together, one can construct examples in which the coercions do not form a commutative diagram. Hence, we do *not* introduce forgetful coercions here.\n+\n+However, some improvement of the existing implementation was needed.\n \n   Was:\n \n@@ -487,7 +497,9 @@\n \n __Comparison of fractional ideals / identity of Residue Fields__\n \n-  Fractional ideals have a `__cmp__` method that only took into account the Hermite normal form. In addition with coercion, we obtain:\n+  Fractional ideals have a `__cmp__` method that only took into account the Hermite normal form. Originally, the comparison of fractional ideals by \"==\" and by \"cmp\" yields different results. Since \"==\" of fractional ideals is used for caching residue fields, but \"cmp\" was used for comparing residue fields, the residue fields did not provide unique parents.\n+\n+  Was:\n \n   ```\n   sage: L.<b> = NumberField(x^8-x^4+1)\n@@ -499,28 +511,47 @@\n   sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)\n   sage: FK = K.fractional_ideal(K.0)\n   sage: FL = L.fractional_ideal(L.0)\n-  sage: FK == FL\n-  True\n-  ```\n-\n-  Since the residue fields of two equal fractional fields are the same (caching), we obtain:\n-\n-  ```\n+  sage: FK != FL\n+  True\n   sage: RL = ResidueField(FL)\n   sage: RK = ResidueField(FK)\n   sage: RK is RL\n-  True\n-  ```\n-\n-  Thus, `RK` is in fact defined with the embedded field `L`, not with the unembedded `K`. Hence, there is no coercion from the order of `K` to `RK`. However, *conversion* works (this used to fail!):\n+  False\n+  sage: RK == RL\n+  True\n+  ```\n+\n+  Now:\n+\n+  ```\n+  sage: L.<b> = NumberField(x^8-x^4+1)\n+  sage: F_2 = L.fractional_ideal(b^2-1)\n+  sage: F_4 = L.fractional_ideal(b^4-1)\n+  sage: F_2==F_4\n+  True\n+  sage: K.<r4> = NumberField(x^4-2)\n+  sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)\n+  sage: FK = K.fractional_ideal(K.0)\n+  sage: FL = L.fractional_ideal(L.0)\n+  sage: FK != FL\n+  True\n+  sage: RL = ResidueField(FL)\n+  sage: RK = ResidueField(FK)\n+  sage: RK is RL\n+  False\n+  sage: RK == RL\n+  False\n+  ```\n+\n+  Since `RL` is defined with the embedded field `L`, not with the unembedded `K`, there is no coercion from the order of `K` to `RL`. However, *conversion* works (this used to fail!):\n \n   ```\n   sage: OK = K.maximal_order()\n-  sage: RK.has_coerce_map_from(OK)\n-  False\n-  sage: RK(OK.1)\n+  sage: RL.has_coerce_map_from(OK)\n+  False\n+  sage: RL(OK.1)\n   0\n   ```\n \n-  Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal.\n-\n+  Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal. This assumption should still hold (since we do not introduce forgetful coercion), but I think it is OK to keep the change in _tate.\n+\n``````\n",
    "created_at": "2010-12-08T09:01:10Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73497",
    "user": "https://github.com/simon-king-jena"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -397,6 +397,16 @@
 * [Comparison of fractional ideals](http://groups.google.com/group/sage-nt/browse_thread/thread/54c1e33872d14334)
 
 __Coercion__
+
+Important for the discussion is: What will we do with embeddings? 
+
+Currently, the embedding of two number fields is used to construct a coercion (compatible with the embedding). Of course, the given embedding is also used as a coerce map.
+
+It was discussed to additionally have a "forgetful" coercion from an embedded to a non-embedded number field.
+
+It turned out that with bidirectional and forgetful coercions together, one can construct examples in which the coercions do not form a commutative diagram. Hence, we do *not* introduce forgetful coercions here.
+
+However, some improvement of the existing implementation was needed.
 
   Was:
 
@@ -487,7 +497,9 @@
 
 __Comparison of fractional ideals / identity of Residue Fields__
 
-  Fractional ideals have a `__cmp__` method that only took into account the Hermite normal form. In addition with coercion, we obtain:
+  Fractional ideals have a `__cmp__` method that only took into account the Hermite normal form. Originally, the comparison of fractional ideals by "==" and by "cmp" yields different results. Since "==" of fractional ideals is used for caching residue fields, but "cmp" was used for comparing residue fields, the residue fields did not provide unique parents.
+
+  Was:
 
   ```
   sage: L.<b> = NumberField(x^8-x^4+1)
@@ -499,28 +511,47 @@
   sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)
   sage: FK = K.fractional_ideal(K.0)
   sage: FL = L.fractional_ideal(L.0)
-  sage: FK == FL
-  True
-  ```
-
-  Since the residue fields of two equal fractional fields are the same (caching), we obtain:
-
-  ```
+  sage: FK != FL
+  True
   sage: RL = ResidueField(FL)
   sage: RK = ResidueField(FK)
   sage: RK is RL
-  True
-  ```
-
-  Thus, `RK` is in fact defined with the embedded field `L`, not with the unembedded `K`. Hence, there is no coercion from the order of `K` to `RK`. However, *conversion* works (this used to fail!):
+  False
+  sage: RK == RL
+  True
+  ```
+
+  Now:
+
+  ```
+  sage: L.<b> = NumberField(x^8-x^4+1)
+  sage: F_2 = L.fractional_ideal(b^2-1)
+  sage: F_4 = L.fractional_ideal(b^4-1)
+  sage: F_2==F_4
+  True
+  sage: K.<r4> = NumberField(x^4-2)
+  sage: L.<r4> = NumberField(x^4-2, embedding=CDF.0)
+  sage: FK = K.fractional_ideal(K.0)
+  sage: FL = L.fractional_ideal(L.0)
+  sage: FK != FL
+  True
+  sage: RL = ResidueField(FL)
+  sage: RK = ResidueField(FK)
+  sage: RK is RL
+  False
+  sage: RK == RL
+  False
+  ```
+
+  Since `RL` is defined with the embedded field `L`, not with the unembedded `K`, there is no coercion from the order of `K` to `RL`. However, *conversion* works (this used to fail!):
 
   ```
   sage: OK = K.maximal_order()
-  sage: RK.has_coerce_map_from(OK)
-  False
-  sage: RK(OK.1)
+  sage: RL.has_coerce_map_from(OK)
+  False
+  sage: RL(OK.1)
   0
   ```
 
-  Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal.
-
+  Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal. This assumption should still hold (since we do not introduce forgetful coercion), but I think it is OK to keep the change in _tate.
+
``````




---

archive/issue_comments_073498.json:
```json
{
    "body": "<a id='comment:63'></a>\nI removed the \"forgetful coercions\" and changed the documentation and the ticket description accordingly.\n\nI modified the 32-bit expected value of selmer_group according to your findings (but please test if it really works 32-bit; I only tested 64-bit).\n\nI modified the annoying random_element test in permgroup.py as Luis suggested.\n\nHence, I think it is ready for review again!",
    "created_at": "2010-12-08T09:04:25Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73498",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:63'></a>
I removed the "forgetful coercions" and changed the documentation and the ticket description accordingly.

I modified the 32-bit expected value of selmer_group according to your findings (but please test if it really works 32-bit; I only tested 64-bit).

I modified the annoying random_element test in permgroup.py as Luis suggested.

Hence, I think it is ready for review again!



---

archive/issue_events_063192.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2010-12-08T09:04:25Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63192"
}
```



---

archive/issue_events_063193.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2010-12-08T09:04:25Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63193"
}
```



---

archive/issue_comments_073499.json:
```json
{
    "body": "**Changing work issues** from \"change 32-bit test; remove forgetful coercion\" to \"\".",
    "created_at": "2010-12-08T09:04:25Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73499",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "change 32-bit test; remove forgetful coercion" to "".



---

archive/issue_comments_073500.json:
```json
{
    "body": "<a id='comment:64'></a>\ndepends on #8807 #10318",
    "created_at": "2010-12-08T10:28:13Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73500",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:64'></a>
depends on #8807 #10318



---

archive/issue_comments_073501.json:
```json
{
    "body": "<a id='comment:65'></a>\nI confirm that the new patch applies to 32-bits linux and long doctest passes. I have not read the code yet.",
    "created_at": "2010-12-09T09:34:55Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73501",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:65'></a>
I confirm that the new patch applies to 32-bits linux and long doctest passes. I have not read the code yet.



---

archive/issue_comments_073502.json:
```json
{
    "body": "<a id='comment:66'></a>\nReplying to [lftabera](#comment%3A65):\n> I confirm that the new patch applies to 32-bits linux and long doctest passes. I have not read the code yet.\n\n\nCould the doctests be repeated, please? I just did it on my machine, based on `sage-4.6.1.alpha3`, and again the problem is the doctest for `selmer_group`. Recall that in the original patch I had to switch the expected values for 32- and 64-bit. And now, with `sage-4.6.1.alpha3`, I get again the value that was originally expected without the patch.\n\nTherefore I'll replace the patch again, in a few minutes. Please test!",
    "created_at": "2010-12-29T20:28:16Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73502",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:66'></a>
Replying to [lftabera](#comment%3A65):
> I confirm that the new patch applies to 32-bits linux and long doctest passes. I have not read the code yet.


Could the doctests be repeated, please? I just did it on my machine, based on `sage-4.6.1.alpha3`, and again the problem is the doctest for `selmer_group`. Recall that in the original patch I had to switch the expected values for 32- and 64-bit. And now, with `sage-4.6.1.alpha3`, I get again the value that was originally expected without the patch.

Therefore I'll replace the patch again, in a few minutes. Please test!



---

archive/issue_comments_073503.json:
```json
{
    "body": "<a id='comment:67'></a>\nI really don't see what the patchbot was complaining about. The old patch did apply to `sage-4.6.2.alpha0` with just a little fuzz.\n\nAnyway, I refreshed it. The dependencies of the ticket are already merged in `sage-4.6.2.alpha0`, so, it should now apply cleanly.\n\nPlease, try to review it! I really think that fixing so many bugs and providing full doctest coverage of a large chunk of the coercion machinery is worth the effort.",
    "created_at": "2011-01-29T09:11:20Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73503",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:67'></a>
I really don't see what the patchbot was complaining about. The old patch did apply to `sage-4.6.2.alpha0` with just a little fuzz.

Anyway, I refreshed it. The dependencies of the ticket are already merged in `sage-4.6.2.alpha0`, so, it should now apply cleanly.

Please, try to review it! I really think that fixing so many bugs and providing full doctest coverage of a large chunk of the coercion machinery is worth the effort.



---

archive/issue_events_063194.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2011-02-14T14:49:27Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63194"
}
```



---

archive/issue_events_063195.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2011-02-14T14:49:27Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63195"
}
```



---

archive/issue_comments_073504.json:
```json
{
    "body": "<a id='comment:68'></a>\nHi Simon,\n\nI am reading the code, it is a long patch but looks good, thanks for the work done.\n\nI have a question about functor AlgebraicExtensionFunctor and ZZ. According to the documentation:\n\nWhen applying a number field constructor to the ring of integers, the maximal order in the number field is returned::\n\nWhy is this chosen instead of ZZ[x]/polynomial?\n\nActually, the code does not follow the documentation except for CyclotomicField:\n\n```\nsage: N = NumberField(x^2 - 5, 'a')\nsage: F, R = N.construction()\nsage: F(ZZ).gens()\n[1, a]\nsage: F(ZZ).is_maximal()\nFalse\nsage: N.maximal_order().gens()\n[1/2*a + 1/2, a]\n```\n\nI add a patch that contains some small improvements (in my opinion). A couple of small tests and some style. Plase consider merging some of these changes. For example, in the code you usually write:\n\nreturn\n\ninstead of \n\nreturn None\n\nBoth are correct but, unless there are other reasons I am unaware, the second looks more readable to me (just an opinion).\n\nI have not yet finish to review the whole patch, so you may consider waiting untill I am done. I have to compile the documentation and check that the list of bugs you have solved appears in the TESTS of the patch.",
    "created_at": "2011-02-14T14:49:27Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73504",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:68'></a>
Hi Simon,

I am reading the code, it is a long patch but looks good, thanks for the work done.

I have a question about functor AlgebraicExtensionFunctor and ZZ. According to the documentation:

When applying a number field constructor to the ring of integers, the maximal order in the number field is returned::

Why is this chosen instead of ZZ[x]/polynomial?

Actually, the code does not follow the documentation except for CyclotomicField:

```
sage: N = NumberField(x^2 - 5, 'a')
sage: F, R = N.construction()
sage: F(ZZ).gens()
[1, a]
sage: F(ZZ).is_maximal()
False
sage: N.maximal_order().gens()
[1/2*a + 1/2, a]
```

I add a patch that contains some small improvements (in my opinion). A couple of small tests and some style. Plase consider merging some of these changes. For example, in the code you usually write:

return

instead of 

return None

Both are correct but, unless there are other reasons I am unaware, the second looks more readable to me (just an opinion).

I have not yet finish to review the whole patch, so you may consider waiting untill I am done. I have to compile the documentation and check that the list of bugs you have solved appears in the TESTS of the patch.



---

archive/issue_comments_073505.json:
```json
{
    "body": "<a id='comment:69'></a>\nHi Luis,\n\nFirst of all, thank you for looking at the patch and finding so many typos.\n\nReplying to [lftabera](#comment%3A68):\n> I have a question about functor AlgebraicExtensionFunctor and ZZ. According to the documentation:\n> \n> When applying a number field constructor to the ring of integers, the maximal order in the number field is returned::\n> \n> Why is this chosen instead of ZZ[x]/polynomial?\n\n\nThat is how currently extensions of `ZZ` behave:\n\n```\nsage: ZZ.extension(x^2+3*x+1,names=['y'])\nOrder in Number Field in y with defining polynomial x^2 + 3*x + 1\n```\nSo, it wasn't my idea; the construction functor is merely mimicking what the `extension` method of `ZZ` was doing anyway. \n\n> Actually, the code does not follow the documentation except for CyclotomicField:\n> \n> ```\n> sage: N = NumberField(x^2 - 5, 'a')\n> sage: F, R = N.construction()\n> sage: F(ZZ).gens()\n> [1, a]\n> sage: F(ZZ).is_maximal()\n> False\n> sage: N.maximal_order().gens()\n> [1/2*a + 1/2, a]\n> ```\n\n\nAgain, this is what `ZZ.extension` currently does:\n\n```\nsage: ZZ.extension(x^2 - 5, 'a').is_maximal()\nFalse\n```\n\nBut I don't understand why that contradicts the documentation? Is it since I wrote \"Note that the construction functor of a number field returns the order of that field\"? *The* order?\n\nPerhaps I should better write \"Note that the construction functor of a number field applied to the integers returns an order of that field, similar to the behaviour of `ZZ.extension`\"?\n\n\n> I add a patch that contains some small improvements (in my opinion). A couple of small tests and some style. Plase consider merging some of these changes.\n\n\nI agree with all changes that you suggest in your \"some_ideas\" patch - so, once you're done, please promote it to a referee patch!\n\nBest regards,\n\nSimon",
    "created_at": "2011-02-14T15:13:20Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73505",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:69'></a>
Hi Luis,

First of all, thank you for looking at the patch and finding so many typos.

Replying to [lftabera](#comment%3A68):
> I have a question about functor AlgebraicExtensionFunctor and ZZ. According to the documentation:
> 
> When applying a number field constructor to the ring of integers, the maximal order in the number field is returned::
> 
> Why is this chosen instead of ZZ[x]/polynomial?


That is how currently extensions of `ZZ` behave:

```
sage: ZZ.extension(x^2+3*x+1,names=['y'])
Order in Number Field in y with defining polynomial x^2 + 3*x + 1
```
So, it wasn't my idea; the construction functor is merely mimicking what the `extension` method of `ZZ` was doing anyway. 

> Actually, the code does not follow the documentation except for CyclotomicField:
> 
> ```
> sage: N = NumberField(x^2 - 5, 'a')
> sage: F, R = N.construction()
> sage: F(ZZ).gens()
> [1, a]
> sage: F(ZZ).is_maximal()
> False
> sage: N.maximal_order().gens()
> [1/2*a + 1/2, a]
> ```


Again, this is what `ZZ.extension` currently does:

```
sage: ZZ.extension(x^2 - 5, 'a').is_maximal()
False
```

But I don't understand why that contradicts the documentation? Is it since I wrote "Note that the construction functor of a number field returns the order of that field"? *The* order?

Perhaps I should better write "Note that the construction functor of a number field applied to the integers returns an order of that field, similar to the behaviour of `ZZ.extension`"?


> I add a patch that contains some small improvements (in my opinion). A couple of small tests and some style. Plase consider merging some of these changes.


I agree with all changes that you suggest in your "some_ideas" patch - so, once you're done, please promote it to a referee patch!

Best regards,

Simon



---

archive/issue_comments_073506.json:
```json
{
    "body": "<a id='comment:70'></a>\nOk, current behaviur is what I would expect. But then there is a typo in \nAlgebraicExtensionFunctor.__init__ which is where the documentation claims that returs the maximal order. Lines 2223 and 2224 of your patch:\n\n```\n+        When applying a number field constructor to the ring of integers,\n+        the maximal order in the number field is returned::\n```",
    "created_at": "2011-02-14T15:28:55Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73506",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:70'></a>
Ok, current behaviur is what I would expect. But then there is a typo in 
AlgebraicExtensionFunctor.__init__ which is where the documentation claims that returs the maximal order. Lines 2223 and 2224 of your patch:

```
+        When applying a number field constructor to the ring of integers,
+        the maximal order in the number field is returned::
```



---

archive/issue_comments_073507.json:
```json
{
    "body": "<a id='comment:71'></a>\nReplying to [lftabera](#comment%3A70):\n> Ok, current behaviur is what I would expect. But then there is a typo in \n> AlgebraicExtensionFunctor.__init__ which is where the documentation claims that returs the maximal order. Lines 2223 and 2224 of your patch:\n\n\nThanks! That ought to change, then. I only found the other place, where I wrote \"the order\" rather than \"an order\".",
    "created_at": "2011-02-14T15:37:47Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73507",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:71'></a>
Replying to [lftabera](#comment%3A70):
> Ok, current behaviur is what I would expect. But then there is a typo in 
> AlgebraicExtensionFunctor.__init__ which is where the documentation claims that returs the maximal order. Lines 2223 and 2224 of your patch:


Thanks! That ought to change, then. I only found the other place, where I wrote "the order" rather than "an order".



---

archive/issue_events_063196.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-02-14T16:44:44Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63196"
}
```



---

archive/issue_events_063197.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-02-14T16:44:44Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63197"
}
```



---

archive/issue_comments_073508.json:
```json
{
    "body": "<a id='comment:72'></a>\nDear Luis,\n\nReplying to [SimonKing](#comment%3A71):\n> Replying to [lftabera](#comment%3A70):\n> > Ok, current behaviur is what I would expect. But then there is a typo in \n> > AlgebraicExtensionFunctor.__init__ which is where the documentation claims that returs the maximal order. Lines 2223 and 2224 of your patch:\n\n> \n> Thanks! That ought to change, then. I only found the other place, where I wrote \"the order\" rather than \"an order\".\n\n\nThis is now fixed.\n\nI change the ticket status into \"needs review\" again, since I believe the other typos can be fixed with your reviewer patch.",
    "created_at": "2011-02-14T16:44:44Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73508",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:72'></a>
Dear Luis,

Replying to [SimonKing](#comment%3A71):
> Replying to [lftabera](#comment%3A70):
> > Ok, current behaviur is what I would expect. But then there is a typo in 
> > AlgebraicExtensionFunctor.__init__ which is where the documentation claims that returs the maximal order. Lines 2223 and 2224 of your patch:

> 
> Thanks! That ought to change, then. I only found the other place, where I wrote "the order" rather than "an order".


This is now fixed.

I change the ticket status into "needs review" again, since I believe the other typos can be fixed with your reviewer patch.



---

archive/issue_comments_073509.json:
```json
{
    "body": "<a id='comment:73'></a>\nSimon,\n\nWhat is the reason for the following change?\n\n```\ndiff -r f71dd979f978 -r 7097db76160e sage/rings/rational_field.py\n--- a/sage/rings/rational_field.py\tFri Dec 10 14:50:18 2010 +0100\n+++ b/sage/rings/rational_field.py\tWed Jul 21 14:25:41 2010 +0100\n@@ -253,7 +253,7 @@\n         import integer_ring\n         return FractionField(), integer_ring.ZZ\n         \n-    def completion(self, p, prec, extras = {}):\n+    def completion(self, p, prec, extras):\n```\n\nIn the completion method of the RationalField. I think it is an error to eliminate the default extras = {}. It is not a mandatory argument neither for Qp not for create_RealField and the user has no idea of what to put there (QQ.completion has no documentation, which is a bug, but not for this ticket)\n\nLuis",
    "created_at": "2011-02-16T18:01:17Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73509",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:73'></a>
Simon,

What is the reason for the following change?

```
diff -r f71dd979f978 -r 7097db76160e sage/rings/rational_field.py
--- a/sage/rings/rational_field.py	Fri Dec 10 14:50:18 2010 +0100
+++ b/sage/rings/rational_field.py	Wed Jul 21 14:25:41 2010 +0100
@@ -253,7 +253,7 @@
         import integer_ring
         return FractionField(), integer_ring.ZZ
         
-    def completion(self, p, prec, extras = {}):
+    def completion(self, p, prec, extras):
```

In the completion method of the RationalField. I think it is an error to eliminate the default extras = {}. It is not a mandatory argument neither for Qp not for create_RealField and the user has no idea of what to put there (QQ.completion has no documentation, which is a bug, but not for this ticket)

Luis



---

archive/issue_events_063198.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2011-02-16T18:01:17Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63198"
}
```



---

archive/issue_events_063199.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2011-02-16T18:01:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63199"
}
```



---

archive/issue_comments_073510.json:
```json
{
    "body": "<a id='comment:74'></a>\nHi Luis,\n\nReplying to [lftabera](#comment%3A73):\n> What is the reason for the following change?\n> \n\n>...\n>\n> In the completion method of the RationalField. I think it is an error to eliminate the default extras = {}.\n\n\nI have not the faintest idea why I did that change. Probably it was by accident. I'll try to revert that change and see if tests still pass.\n\nCheers, Simon",
    "created_at": "2011-02-16T18:13:58Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73510",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:74'></a>
Hi Luis,

Replying to [lftabera](#comment%3A73):
> What is the reason for the following change?
> 

>...
>
> In the completion method of the RationalField. I think it is an error to eliminate the default extras = {}.


I have not the faintest idea why I did that change. Probably it was by accident. I'll try to revert that change and see if tests still pass.

Cheers, Simon



---

archive/issue_comments_073511.json:
```json
{
    "body": "<a id='comment:75'></a>\nApply 8800_functor_pushout_doc_and_fixes.patch some_ideas.patch\n\n(For the patchbot, if that's necessary)",
    "created_at": "2011-02-16T20:45:18Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73511",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:75'></a>
Apply 8800_functor_pushout_doc_and_fixes.patch some_ideas.patch

(For the patchbot, if that's necessary)



---

archive/issue_comments_073512.json:
```json
{
    "body": "<a id='comment:76'></a>\nI reverted the obscure \"extras\" issue. That was no problem.\n\nI had to change two doctests that used the \".transpose()\" method for vectors, which is now deprecated. With the new patch applied to sage-4.6.2.alpha4, the long doctests pass on my machine.\n\nPresumably, your \"some_ideas.patch\" will become a reviewer patch, thus I told the  patchbot to apply it.\n\nBest regards,\n\nSimon",
    "created_at": "2011-02-16T20:49:17Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73512",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:76'></a>
I reverted the obscure "extras" issue. That was no problem.

I had to change two doctests that used the ".transpose()" method for vectors, which is now deprecated. With the new patch applied to sage-4.6.2.alpha4, the long doctests pass on my machine.

Presumably, your "some_ideas.patch" will become a reviewer patch, thus I told the  patchbot to apply it.

Best regards,

Simon



---

archive/issue_events_063200.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-02-16T20:49:17Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63200"
}
```



---

archive/issue_events_063201.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-02-16T20:49:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63201"
}
```



---

archive/issue_comments_073513.json:
```json
{
    "body": "<a id='comment:77'></a>\nFWIW, the doctest failure reported by the patchbot comes from the fact that the vector method \".column()\" seems to be a feature only introduced in 4.6.2.alpha2, replacing the now deprecated \".transpose()\".",
    "created_at": "2011-02-17T07:30:18Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73513",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:77'></a>
FWIW, the doctest failure reported by the patchbot comes from the fact that the vector method ".column()" seems to be a feature only introduced in 4.6.2.alpha2, replacing the now deprecated ".transpose()".



---

archive/issue_comments_073514.json:
```json
{
    "body": "Ideas to consider merging",
    "created_at": "2011-02-18T16:39:38Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73514",
    "user": "https://github.com/lftabera"
}
```

Ideas to consider merging



---

archive/issue_events_063202.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2011-02-18T16:44:13Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "milestone": "sage-4.6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63202"
}
```



---

archive/issue_events_063203.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2011-02-18T16:44:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "milestone": "sage-4.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63203"
}
```



---

archive/attachments_011423.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "some_ideas.patch",
    "asset_url": "tarball://root/attachments/ticket8800/some_ideas.patch",
    "created_at": "2011-02-18T16:44:13Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket8800/some_ideas.patch",
    "user": "https://github.com/lftabera"
}
```



---

archive/issue_comments_073515.json:
```json
{
    "body": "<a id='comment:78'></a>\n**Attachment:** [some_ideas.patch](https://github.com/sagemath/sage/files/ticket8800/some_ideas.patch)\n\nThe documentation of pushout is not built in the reference manual. I have added pushout.py to categories.rst, but I get warnings and errors in the html and pdf built that I do not know how to solve.",
    "created_at": "2011-02-18T16:44:13Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73515",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:78'></a>
**Attachment:** [some_ideas.patch](https://github.com/sagemath/sage/files/ticket8800/some_ideas.patch)

The documentation of pushout is not built in the reference manual. I have added pushout.py to categories.rst, but I get warnings and errors in the html and pdf built that I do not know how to solve.



---

archive/issue_events_063204.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2011-02-18T16:44:13Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63204"
}
```



---

archive/issue_events_063205.json:
```json
{
    "actor": "https://github.com/lftabera",
    "created_at": "2011-02-18T16:44:13Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63205"
}
```



---

archive/issue_comments_073516.json:
```json
{
    "body": "<a id='comment:79'></a>\nI just updated my patch, also merging your some_ideas.patch. The documentation seemed to build without problems (which required some editing). I am afraid I will probably be unable to see the documentation for the next ten days, as I will not be in my office.\n\nBut then I made a big mistake: I also included an autogenerated file into the repository, namely doc/en/reference/sage/categories/pushout.rst. When I noticed it and tried to `hg delete` it, apparently I managed to kill the entire documentation. I don't know whether I will recover from that stroke, because even `sage -docbuild reference html` did not help.\n\nBut perhaps you will be able to (1) see whether the documentation of sage.categories.pushout looks nice and (2) correct my patch?\n\nApply 8800_functor_pushout_doc_and_fixes.patch",
    "created_at": "2011-02-18T20:13:46Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73516",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:79'></a>
I just updated my patch, also merging your some_ideas.patch. The documentation seemed to build without problems (which required some editing). I am afraid I will probably be unable to see the documentation for the next ten days, as I will not be in my office.

But then I made a big mistake: I also included an autogenerated file into the repository, namely doc/en/reference/sage/categories/pushout.rst. When I noticed it and tried to `hg delete` it, apparently I managed to kill the entire documentation. I don't know whether I will recover from that stroke, because even `sage -docbuild reference html` did not help.

But perhaps you will be able to (1) see whether the documentation of sage.categories.pushout looks nice and (2) correct my patch?

Apply 8800_functor_pushout_doc_and_fixes.patch



---

archive/issue_comments_073517.json:
```json
{
    "body": "<a id='comment:80'></a>\nI think I solved the trouble with the reference manual. The new patch includes the some_ideas patch. So, only one patch needs to be applied.\n\nWith the patch, the references for sage.categories.pushout build, and no warning or error is raised. But I am currently not able to watch the result (this will take more than one week). So, I ask the reviewer to have a look on it.\n\nTo be on the safe side, I am now running doc tests (at least, `sage -tp 4 doc/en` passes). But I think I can revert it to \"needs review\".",
    "created_at": "2011-02-19T08:27:31Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73517",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:80'></a>
I think I solved the trouble with the reference manual. The new patch includes the some_ideas patch. So, only one patch needs to be applied.

With the patch, the references for sage.categories.pushout build, and no warning or error is raised. But I am currently not able to watch the result (this will take more than one week). So, I ask the reviewer to have a look on it.

To be on the safe side, I am now running doc tests (at least, `sage -tp 4 doc/en` passes). But I think I can revert it to "needs review".



---

archive/issue_events_063206.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-02-19T08:27:31Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63206"
}
```



---

archive/issue_events_063207.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-02-19T08:27:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63207"
}
```



---

archive/issue_comments_073518.json:
```json
{
    "body": "<a id='comment:81'></a>\nApply 8800_functor_pushout_doc_and_fixes.patch \n\n(for the patchbot)",
    "created_at": "2011-02-19T08:29:39Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73518",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:81'></a>
Apply 8800_functor_pushout_doc_and_fixes.patch 

(for the patchbot)



---

archive/issue_comments_073519.json:
```json
{
    "body": "<a id='comment:82'></a>\nAll long tests pass if one applies the patch to sage-4.6.2.alpha4. The patchbot uses sage-4.6.1, that's why it finds two errors.",
    "created_at": "2011-02-19T16:19:36Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73519",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:82'></a>
All long tests pass if one applies the patch to sage-4.6.2.alpha4. The patchbot uses sage-4.6.1, that's why it finds two errors.



---

archive/attachments_011424.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "referee.patch",
    "asset_url": "tarball://root/attachments/ticket8800/referee.patch",
    "created_at": "2011-02-26T11:29:16Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket8800/referee.patch",
    "user": "https://github.com/lftabera"
}
```



---

archive/issue_comments_073520.json:
```json
{
    "body": "<a id='comment:83'></a>\n**Attachment:** [referee.patch](https://github.com/sagemath/sage/files/ticket8800/referee.patch)\n\nI have tested with sage-4.6.1.rc0 the documentation builds and looks good. The bugs have been corrected and the patch introduces some very nice features. Good work. Positive review to Simon's patch.\n\nHowever, I have added a referee patch with some minor changes in the documentation. I have eliminated some latex code that, in my opinion, made the documentation harder to read.\n\nSimon, could you look at my patch? If you feel it is ok, put a positive review.",
    "created_at": "2011-02-26T11:29:16Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73520",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:83'></a>
**Attachment:** [referee.patch](https://github.com/sagemath/sage/files/ticket8800/referee.patch)

I have tested with sage-4.6.1.rc0 the documentation builds and looks good. The bugs have been corrected and the patch introduces some very nice features. Good work. Positive review to Simon's patch.

However, I have added a referee patch with some minor changes in the documentation. I have eliminated some latex code that, in my opinion, made the documentation harder to read.

Simon, could you look at my patch? If you feel it is ok, put a positive review.



---

archive/issue_comments_073521.json:
```json
{
    "body": "**Reviewer:** Luis Felipe Tabera Alonso",
    "created_at": "2011-02-26T11:29:16Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73521",
    "user": "https://github.com/lftabera"
}
```

**Reviewer:** Luis Felipe Tabera Alonso



---

archive/issue_comments_073522.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -555,3 +555,7 @@\n \n   Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal. This assumption should still hold (since we do not introduce forgetful coercion), but I think it is OK to keep the change in _tate.\n \n+Apply:\n+\n+1. 8800_functor_pushout_doc_and_fixes.patch[BR]\n+2. referee.patch\n``````\n",
    "created_at": "2011-02-26T11:29:16Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73522",
    "user": "https://github.com/lftabera"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -555,3 +555,7 @@
 
   Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal. This assumption should still hold (since we do not introduce forgetful coercion), but I think it is OK to keep the change in _tate.
 
+Apply:
+
+1. 8800_functor_pushout_doc_and_fixes.patch[BR]
+2. referee.patch
``````




---

archive/issue_events_063208.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-02-26T12:55:12Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63208"
}
```



---

archive/issue_events_063209.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-02-26T12:55:12Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63209"
}
```



---

archive/issue_comments_073523.json:
```json
{
    "body": "<a id='comment:84'></a>\nReplying to [lftabera](#comment%3A83):\n> However, I have added a referee patch with some minor changes in the documentation. I have eliminated some latex code that, in my opinion, made the documentation harder to read.\n> \n> Simon, could you look at my patch? If you feel it is ok, put a positive review.\n\n\nI have read the referee patch, and it seems fine. So, I guess it is a positive review then. Finally!\n\nThank you,\n\nSimon",
    "created_at": "2011-02-26T12:55:12Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73523",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:84'></a>
Replying to [lftabera](#comment%3A83):
> However, I have added a referee patch with some minor changes in the documentation. I have eliminated some latex code that, in my opinion, made the documentation harder to read.
> 
> Simon, could you look at my patch? If you feel it is ok, put a positive review.


I have read the referee patch, and it seems fine. So, I guess it is a positive review then. Finally!

Thank you,

Simon



---

archive/issue_events_063210.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-02-28T14:07:21Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63210"
}
```



---

archive/issue_events_063211.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-02-28T14:07:21Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63211"
}
```



---

archive/issue_comments_073524.json:
```json
{
    "body": "<a id='comment:85'></a>\nThis should be rebased to sage-4.6.2.rc1 + #10677 + #2329 (or, you can wait until sage-4.7.alpha1 is released and then rebase to that).",
    "created_at": "2011-02-28T14:07:21Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73524",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:85'></a>
This should be rebased to sage-4.6.2.rc1 + #10677 + #2329 (or, you can wait until sage-4.7.alpha1 is released and then rebase to that).



---

archive/issue_comments_073525.json:
```json
{
    "body": "**Work Issues:** rebase",
    "created_at": "2011-02-28T14:07:21Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73525",
    "user": "https://github.com/jdemeyer"
}
```

**Work Issues:** rebase



---

archive/issue_comments_073526.json:
```json
{
    "body": "Full doctest coverage for sage.categories.functor and sage.categories.pushout. Various coercion bug fixes.",
    "created_at": "2011-03-08T14:18:23Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73526",
    "user": "https://github.com/simon-king-jena"
}
```

Full doctest coverage for sage.categories.functor and sage.categories.pushout. Various coercion bug fixes.



---

archive/attachments_011425.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "8800_functor_pushout_doc_and_fixes.patch",
    "asset_url": "tarball://root/attachments/ticket8800/8800_functor_pushout_doc_and_fixes.patch",
    "created_at": "2011-03-08T14:20:11Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket8800/8800_functor_pushout_doc_and_fixes.patch",
    "user": "https://github.com/simon-king-jena"
}
```



---

archive/issue_comments_073527.json:
```json
{
    "body": "<a id='comment:86'></a>\n**Attachment:** [8800_functor_pushout_doc_and_fixes.patch](https://github.com/sagemath/sage/files/ticket8800/8800_functor_pushout_doc_and_fixes.patch)\n\nDepends on #10677 #2329\n\nApply 8800_functor_pushout_doc_and_fixes.patch referee.patch",
    "created_at": "2011-03-08T14:20:11Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73527",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:86'></a>
**Attachment:** [8800_functor_pushout_doc_and_fixes.patch](https://github.com/sagemath/sage/files/ticket8800/8800_functor_pushout_doc_and_fixes.patch)

Depends on #10677 #2329

Apply 8800_functor_pushout_doc_and_fixes.patch referee.patch



---

archive/issue_comments_073528.json:
```json
{
    "body": "**Changing work issues** from \"rebase\" to \"\".",
    "created_at": "2011-03-08T14:20:11Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73528",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "rebase" to "".



---

archive/issue_events_063212.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-03-08T14:20:11Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63212"
}
```



---

archive/issue_events_063213.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-03-08T14:20:11Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63213"
}
```



---

archive/issue_comments_073529.json:
```json
{
    "body": "<a id='comment:87'></a>\nI was rebasing the main patch, so that it applies cleanly on top of sage-4.6.2 plus #10677 plus #2329. I change it into \"needs review\", since I am now running doctests.\n\nI hope I am entitled to revert to the old positive review, provided that the long tests pass.",
    "created_at": "2011-03-08T14:22:25Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73529",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:87'></a>
I was rebasing the main patch, so that it applies cleanly on top of sage-4.6.2 plus #10677 plus #2329. I change it into "needs review", since I am now running doctests.

I hope I am entitled to revert to the old positive review, provided that the long tests pass.



---

archive/issue_comments_073530.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -555,7 +555,8 @@\n \n   Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal. This assumption should still hold (since we do not introduce forgetful coercion), but I think it is OK to keep the change in _tate.\n \n-Apply:\n-\n-1. 8800_functor_pushout_doc_and_fixes.patch[BR]\n-2. referee.patch\n+**Apply:**\n+1. [attachment:8800_functor_pushout_doc_and_fixes.patch](https://github.com/sagemath/sage/files/ticket8800/8800_functor_pushout_doc_and_fixes.patch)\n+2. [attachment:referee.patch](https://github.com/sagemath/sage/files/ticket8800/referee.patch)\n+\n+**Dependencies:** #10677, #2329.\n``````\n",
    "created_at": "2011-03-08T14:26:57Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73530",
    "user": "https://github.com/jdemeyer"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -555,7 +555,8 @@
 
   Note that I also had to change some arithmetic stuff in the `_tate` method of elliptic curves: The old implementation relied on the assumption that fractional ideals in an embedded field and in a non-embedded field can't be equal. This assumption should still hold (since we do not introduce forgetful coercion), but I think it is OK to keep the change in _tate.
 
-Apply:
-
-1. 8800_functor_pushout_doc_and_fixes.patch[BR]
-2. referee.patch
+**Apply:**
+1. [attachment:8800_functor_pushout_doc_and_fixes.patch](https://github.com/sagemath/sage/files/ticket8800/8800_functor_pushout_doc_and_fixes.patch)
+2. [attachment:referee.patch](https://github.com/sagemath/sage/files/ticket8800/referee.patch)
+
+**Dependencies:** #10677, #2329.
``````




---

archive/issue_comments_073531.json:
```json
{
    "body": "<a id='comment:89'></a>\nI have absolutely no idea what the patchbot is complaining about! Its shortlog states\n\n```\n2011-03-08 06:20:58 -0800\nNone\n2011-03-08 06:21:05 -0800\n7 seconds\n```\nwhich means???\n\nAnyway. All long tests both in `sage/` and in `doc/` pass. So, if nobody objects, I return to the old positive review.",
    "created_at": "2011-03-08T15:10:48Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73531",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:89'></a>
I have absolutely no idea what the patchbot is complaining about! Its shortlog states

```
2011-03-08 06:20:58 -0800
None
2011-03-08 06:21:05 -0800
7 seconds
```
which means???

Anyway. All long tests both in `sage/` and in `doc/` pass. So, if nobody objects, I return to the old positive review.



---

archive/issue_events_063214.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-03-08T15:10:48Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63214"
}
```



---

archive/issue_events_063215.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-03-08T15:10:48Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63215"
}
```



---

archive/issue_comments_073532.json:
```json
{
    "body": "**Merged:** sage-4.7.alpha1",
    "created_at": "2011-03-08T21:45:09Z",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/8800#issuecomment-73532",
    "user": "https://github.com/jdemeyer"
}
```

**Merged:** sage-4.7.alpha1



---

archive/issue_events_063216.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-03-08T21:45:09Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63216"
}
```



---

archive/issue_events_063217.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-03-08T21:45:09Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/8800",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/8800#event-63217"
}
```
