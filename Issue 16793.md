# Issue 16793: knots

Issue created by migration from Trac.

Original creator: amitjamadagni

Original creation time: 2014-09-23 14:33:27

CC:  mmarco jhpalmieri tscrim fuglede




---

Comment by amitjamadagni created at 2014-09-23 17:51:02

Changing type from PLEASE CHANGE to task.


---

Comment by amitjamadagni created at 2014-09-23 17:51:02

Set assignee to amitjamadagni.


---

Comment by amitjamadagni created at 2014-09-23 17:51:28

Changing status from new to needs_review.


---

Comment by amitjamadagni created at 2014-09-23 17:51:41

Changing status from needs_review to needs_work.


---

Comment by amitjamadagni created at 2014-09-23 17:53:24

Things to do:
1. Plot method needs to be added.
2. ncomponents needs to be worked upon.


---

Comment by mmarco created at 2014-09-24 09:15:56

I am not sure if it is a good idea that i would be the reviewer, since i have been involved in tge coding too. Besides, there is some polishing needed still and it would go faster if i directly work on it.

jhpamieri, do you feel able to do the revieweing? If yes, i will start working in the corrections. Otherwise, i will stay away from changing the code and just act as reviewer.


---

Comment by mmarco created at 2014-09-24 09:54:31

I get the following wrror when compiling:


running install_lib
byte-compiling /home/mmarco/sage/local/lib/python2.7/site-packages/sage/all.py to all.pyc
  File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/all.py", line 174
    <<<<<<< HEAD
     ^


Is it a problem with the commit? Over which branch is it based?


---

Comment by mmarco created at 2014-09-24 09:54:31

Changing component from PLEASE CHANGE to algebraic topology.


---

Comment by amitjamadagni created at 2014-09-24 11:37:33

Replying to [comment:9 mmarco]:
> I get the following wrror when compiling:
> 
> 
> running install_lib
> byte-compiling /home/mmarco/sage/local/lib/python2.7/site-packages/sage/all.py to all.pyc
>   File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/all.py", line 174
>     <<<<<<< HEAD
>      ^
> 
> 
> Is it a problem with the commit? Over which branch is it based?

I pushed the branch from github (the branch week15) onto the trac ticket. Let me try adding all.py and commit once again.


---

Comment by git created at 2014-09-24 11:40:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-09-24 11:57:43

It looks like a bad resolution to a merge, but it's a simple enough fix. Also on a quick look through:

- Doc formatting should follow:

```
INPUT:

- ``name`` -- some description that is very long and
  note the alignment

OUTPUT:

- these are not usually complete sentences but short descriptions
```

- Move the nice documentation from the `__init__` into the class-level doc so people can actually see it.
- All methods must have doctests.
- It's my pythonic to use `isinstance(input_, list)` instead of `type(input_) == list`.
- `input_` is a bad variable name (according to python standards), just use `input` (or perhaps the slightly more descriptive `data`)
- Don't raise `Exception`, instead raise `ValueError` or `TypeError` (after killing with fire and holy water :P).
- Change

```python
pd_error = _pd_check_(input_)
if pd_error == True:
    pass
elif pd_error == False:
    pass
```

  into (the pythonic)

```python
if _pd_check_(input_):
    pass
else:
    pass
```

- Use `is not None` instead of `!= None`.
- Make `_dt_internal_` a proper method of the class.
- Remove the trailing underscore of `_pd_check_`, ,`_dt_internal_` etc. as methods with a leading and trailing underscore are usually Sage special functions (and naming conventions of python).
- Is "dowker" a proper name (and hence, should be capitalized in the documentation)?
- The method name `Seifert_Matrix` should be `seifert_matrix` (naming conventions again).
- Could you change the name of `ncomponents` to `number_of_components` (although you can keep it as a shorthand alias)?
- This needs to be added to the documentation (probably as a new component).

I'll make a more detailed pass through the code after these are addressed. I also don't know how much of the math I'll be able to review as I've studied a little knot theory, but possibly not enough to check everything. Although Miguel could count as the reviewer on that front.

I think this will be a great addition to Sage, all it needs a little polish.

Best,

Travis


---

Comment by jdemeyer created at 2014-09-25 06:40:53

Also please respect [http://www.sagemath.org/doc/developer/coding_basics.html#headings-of-sage-library-code-files](http://www.sagemath.org/doc/developer/coding_basics.html#headings-of-sage-library-code-files) and add your new files to the reference manual (have a look at the files in `src/doc/en/reference` to see how that is done).

Even better, change

```
pd_error = _pd_check_(input_)
if pd_error == True:
    raise Exception("...")
elif pd_error == False:
    foo
```

to

```
if not _pd_check(input):
    raise ValueError("...")

foo
```

and change the last line of `def _pd_check_(pd):` to `return not pd_error`, since I would expect a "check" function to return `True` if the checking was successful. Also drop the trailing underscores.


---

Comment by jdemeyer created at 2014-09-25 06:45:22

Instead of returning a string in `_vogel_move_()`, you should return `None` in case of failure. That would be more efficient and one wouldn't need to remember a magic string (which is by the way wrong in the doc of that method, further proving my point).


---

Comment by amitjamadagni created at 2014-09-25 06:53:03

Replying to [comment:14 jdemeyer]:
> Instead of returning a string in `_vogel_move_()`, you should return `None` in case of failure. That would be more efficient and one wouldn't need to remember a magic string (which is by the way wrong in the doc of that method, further proving my point).

I am currently having few issues with pushing commits onto trac, once I am done with the setup I will be sending in the commits. Thanks for guiding me and sorry for missing on the rules.


---

Comment by kcrisman created at 2014-09-25 07:22:45

> I'll make a more detailed pass through the code after these are addressed. I also don't know how much of the math I'll be able to review as I've studied a little knot theory, but possibly not enough to check everything. Although Miguel could count as the reviewer on that front.

Yeah, I think it would be really wise for such a new component and with a lot of technicalities for determining e.g. whether a given link is a knot to have a couple actual knot theorists review it, at least by checking the output in lots of cases.  That may take some cold-calling, though perhaps a sage-devel email will turn up some all by itself, and there are Sage-friendly knot folks out there - though I don't know if they know how to review a branch.


---

Comment by mmarco created at 2014-09-25 09:10:58

I was planning on making a package with the database from the knot atlas, and use it to run automated tests, computing the invariants for the knots and links there.

The problem with that approach is that a) It needs some nontrivial work to be implemented, and b) it restricts to knots and links presented im spcially "nice" ways, so we could miss some bugs if they show up only when some strange representations are used.

Anyways, it would be a nice addition by itself, so i will try to work on it in the following weeks.

In the meantime, and since there are several other reviewers in the coding style part, i will just focus on checking the mathematical correctness of the methods.


---

Comment by mmarco created at 2014-09-25 10:27:31

There is something working wrong in the following case:


```
sage: L=Link([[1, 4, 2, 5], [7, 10, 8, 11], [3, 9, 4, 8], [9, 3, 10, 2], [5, 12, 6, 1], [11, 6, 12, 7]])
sage: L
<repr(<sage.knots.link.Link at 0x7f41771c8a28>) failed: Exception: Invalid Input>
```


It gets an error when trying to get the  connected components, which in turn tries to convert it to braid (which is probably not a good idea, it would be wiser to compute the components directly from the PD_code, since we might me loosing something in the conversion PD<->braid).

In any case, this example fails in the conversion to braid:


```
sage: L.braid()
...
Exception: Invalid Input
```


Please go through it and debug.
}}}


---

Comment by kcrisman created at 2014-09-25 12:21:26

> I was planning on making a package with the database from the knot atlas, and use it to run automated tests, computing the invariants for the knots and links there.
> 
> The problem with that approach is that a) It needs some nontrivial work to be implemented, and b) it restricts to knots and links presented im spcially "nice" ways, so we could miss some bugs if they show up only when some strange representations are used.
> 
> Anyways, it would be a nice addition by itself, so i will try to work on it in the following weeks.

That's a really excellent idea.  It's always good to have two ways to check information anyway.  Ideally one could have a prototype of that available in time to help test this ticket as well.


---

Comment by tscrim created at 2014-09-25 12:44:30

Replying to [comment:16 kcrisman]:
> Yeah, I think it would be really wise for such a new component and with a lot of technicalities for determining e.g. whether a given link is a knot to have a couple actual knot theorists review it, at least by checking the output in lots of cases.  That may take some cold-calling, though perhaps a sage-devel email will turn up some all by itself, and there are Sage-friendly knot folks out there - though I don't know if they know how to review a branch.

FTR - I might be able to pull a few of the knot theorists at Davis to do the review in a month or two.

----

Also here's some things that I'd like to see (although they don't have to be done here):

- Make the monoid of all knots (and/or links) under connect sum (and disjoint union).
- Implement a latex and/or a plotting method (although perhaps this would need specialized class for PL knots?).
- Handle input in Dowker notation (if I understand it correctly, it completely determines a knot), and subsequently make `_dowker_notation_` public (i.e. name it `dowker_notation`).


---

Comment by mmarco created at 2014-09-25 17:48:56

> That's a really excellent idea.  It's always good to have two ways to check information anyway.  Ideally one could have a prototype of that available in time to help test this ticket as well.

I am already running some of those tests. That's how i found the error in the conversion to braid.

I have been working on a cleaner rewrite of the code used to convert from knot to braid, but i am not sure if it is a better idea that i stay as a reviewer. If i commit some code, someone else should review it.


---

Comment by git created at 2014-09-25 18:50:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by amitjamadagni created at 2014-09-25 18:55:49

> Also here's some things that I'd like to see (although they don't have to be done here):
> 
> - Make the monoid of all knots (and/or links) under connect sum (and disjoint union).
> - Implement a latex and/or a plotting method (although perhaps this would need specialized class for PL knots?).
> - Handle input in Dowker notation (if I understand it correctly, it completely determines a knot), and subsequently make `_dowker_notation_` public (i.e. name it `dowker_notation`).


I am working on the plot method. Miguel has sent me the outline and I am on it.

The purpose of including the dowker notation was to implement the HOMFLY Polynomial which is in progress. The dowker notation as I understand is the incoming pair at each crossing. It completely determines the link but PD code is more complete. I guess we can include it but as PD is more complete I think we can exclude it. Anyways let me know your thoughts on this. 

Sorry for the previous comment which mentioned the DT which is different from the dowker code.


---

Comment by amitjamadagni created at 2014-09-25 19:00:25

Replying to [comment:17 mmarco]:
> I was planning on making a package with the database from the knot atlas, and use it to run automated tests, computing the invariants for the knots and links there.
> 
> The problem with that approach is that a) It needs some nontrivial work to be implemented, and b) it restricts to knots and links presented im spcially "nice" ways, so we could miss some bugs if they show up only when some strange representations are used.
> 
> Anyways, it would be a nice addition by itself, so i will try to work on it in the following weeks.
> 
> In the meantime, and since there are several other reviewers in the coding style part, i will just focus on checking the mathematical correctness of the methods.

Just to mention knot altas has other kind of representation of PD Code, they start on the under crossing and move in the anti clockwise direction around the cross while we move in the clockwise direction in the construction of the PD code.


---

Comment by git created at 2014-09-25 20:39:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2014-09-25 20:57:54

Regarding LaTeX, the following links (heh) might be helpful, although it doesn't look like they completely solve the problem:

- http://mathoverflow.net/questions/21424/how-to-draw-knots-with-latex
- http://tex.stackexchange.com/questions/17181/packages-for-creating-knot-diagrams
- http://tex.blogoverflow.com/2013/04/how-can-i-draw-a-knot-in-tex-let-me-count-the-ways/


---

Comment by mmarco created at 2014-09-26 11:20:41

I have done some changes cleaning up the conversion to braid. 

I have also run a script to check the results of .alexander_polynomial against the ones available in the knot atlas (taking into account the notation differences that Amit noted), and so far they match. Although my script is only checking 838 cases. There are some oddities, for example, in some knots, the knot atlas states that the Alexander polynomial is "ComplexInfinity", although our implementation returns an actual polynomial.

In other cases, the knot atlas shows no PD code, so i am not checking those.

----
New commits:


---

Comment by mmarco created at 2014-09-26 11:29:35

I have also checked the jones polynomial (in this case in 1064 cases). Almost all match, with the following exceptions:


```
<knot:L11n307>
-q^10 + 3*q^9 - 6*q^8 + 8*q^7 - 9*q^6 + 11*q^5 - 8*q^4 + 8*q^3 - 4*q^2 + 2*q
-q^10 + 3*q^9 - 6*q^8 + 8*q^7 - 9*q^6 + 11*q^5 - 8*q^4 + 8*q^3 - 4*q^2 + 2

<knot:K11n162>
-q^10 + 3*q^9 - 5*q^8 + 7*q^7 - 9*q^6 + 9*q^5 - 8*q^4 + 7*q^3 - 4*q^2 + 2*q
-q^10 + 3*q^9 - 5*q^8 + 7*q^7 - 9*q^6 + 9*q^5 - 8*q^4 + 7*q^3 - 4*q^2 + 2


<knot:L11n271>
-q^10 + 2*q^9 - 5*q^8 + 7*q^7 - 9*q^6 + 11*q^5 - 8*q^4 + 9*q^3 - 5*q^2 + 3*q
-q^10 + 2*q^9 - 5*q^8 + 7*q^7 - 9*q^6 + 11*q^5 - 8*q^4 + 9*q^3 - 5*q^2 + 3


<knot:L10n112>
q^9 - q^8 + 6*q^7 - 5*q^6 + 11*q^5 - 5*q^4 + 10*q^3 - 5*q^2 + 4*q
q^9 - q^8 + 6*q^7 - 5*q^6 + 11*q^5 - 5*q^4 + 10*q^3 - 5*q^2 + 4


<knot:K11n63>
-q^10 + 2*q^9 - 3*q^8 + 5*q^7 - 6*q^6 + 6*q^5 - 6*q^4 + 5*q^3 - 3*q^2 + 2*q
-q^10 + 2*q^9 - 3*q^8 + 5*q^7 - 6*q^6 + 6*q^5 - 6*q^4 + 5*q^3 - 3*q^2 + 2


<knot:10_165>
q^9 - 3*q^8 + 4*q^7 - 6*q^6 + 7*q^5 - 6*q^4 + 6*q^3 - 4*q^2 + 2*q
q^9 - 3*q^8 + 4*q^7 - 6*q^6 + 7*q^5 - 6*q^4 + 6*q^3 - 4*q^2 + 2


<knot:L11n316>
q^9 - 3*q^8 + 5*q^7 - 6*q^6 + 8*q^5 - 7*q^4 + 7*q^3 - 4*q^2 + 3*q
q^9 - 3*q^8 + 5*q^7 - 6*q^6 + 8*q^5 - 7*q^4 + 7*q^3 - 4*q^2 + 3


<knot:L9n20>
-q^8 + 2*q^7 - 4*q^6 + 5*q^5 - 4*q^4 + 6*q^3 - 3*q^2 + 3*q
-q^8 + 2*q^7 - 4*q^6 + 5*q^5 - 4*q^4 + 6*q^3 - 3*q^2 + 3

```


In each case, the first polynomial is the one given by our implementation, and the second the one given by the knot atlas.

Can someone confirm if the knot atlas results are correct?


---

Comment by amitjamadagni created at 2014-09-26 11:57:37

Replying to [comment:18 mmarco]:
> There is something working wrong in the following case:
> 
> {{{
> sage: L=Link([[1, 4, 2, 5], [7, 10, 8, 11], [3, 9, 4, 8], [9, 3, 10, 2], [5, 12, 6, 1], [11, 6, 12, 7]])
> sage: L
> <repr(<sage.knots.link.Link at 0x7f41771c8a28>) failed: Exception: Invalid Input>
> }}}
> 
> It gets an error when trying to get the  connected components, which in turn tries to convert it to braid (which is probably not a good idea, it would be wiser to compute the components directly from the PD_code, since we might me loosing something in the conversion PD<->braid).
> 
> In any case, this example fails in the conversion to braid:
> 
> {{{
> sage: L.braid()
> ...
> Exception: Invalid Input
> }}}
> 
> Please go through it and debug.
> }}}
I have worked along on the debug and here are the results :


```

sage: L = Link([[1,5,2,4],[7,11,8,10],[3,8,4,9],[9,2,10,3],[5,1,6,12],[11,7,12,6]])  
sage: L.braid()
s0*s1^-1*s2*s1^-1*s0^-1*s1^-1*s2^-1*s3^-1*s2*s1^-1*s0*s2*s1^-1

```



---

Comment by mmarco created at 2014-09-26 12:09:49

Please take a look at my previous commit, i have rewriten part of the braid conversion.
----
New commits:


---

Comment by mmarco created at 2014-09-26 12:39:40

My bad, the discrepancies with the knot atlas where due to my script not parsing correctly the file given by the knot atlas. So we can say that so far our implementation coincides with the knot atlas.


---

Comment by amitjamadagni created at 2014-09-26 12:46:15

Replying to [comment:33 mmarco]:
> My bad, the discrepancies with the knot atlas where due to my script not parsing correctly the file given by the knot atlas. So we can say that so far our implementation coincides with the knot atlas.

That's good to hear. :)
Sorry for the previous commit, but I have found out the bug in my code.
I will go through the rewritten parts. Could you please let me know the way you are testing things so that I can do it as well. Thanks.


---

Comment by vdelecroix created at 2014-09-28 13:46:37

Hello,

The logic of every if/else is completely crazy. Rewriting the `__init__` properly takes only half of the preceding implementation: see my commit at `u/vdelecroix/17030`. The code needs a lot of polishing. I did not dig in the details but it is clearly hard to read!

Vincent


---

Comment by amitjamadagni created at 2014-09-28 14:20:11

Replying to [comment:35 vdelecroix]:
> Hello,
> 
> The logic of every if/else is completely crazy. Rewriting the `__init__` properly takes only half of the preceding implementation: see my commit at `u/vdelecroix/17030`. The code needs a lot of polishing. I did not dig in the details but it is clearly hard to read!
> 
> Vincent

I have browsed through the commit, data can also be a PD code when its length is 2 it is not always oriented gauss code.


---

Comment by vdelecroix created at 2014-09-28 14:24:08

Replying to [comment:36 amitjamadagni]:
> Replying to [comment:35 vdelecroix]:
> > Hello,
> > 
> > The logic of every if/else is completely crazy. Rewriting the `__init__` properly takes only half of the preceding implementation: see my commit at `u/vdelecroix/17030`. The code needs a lot of polishing. I did not dig in the details but it is clearly hard to read!
> > 
> > Vincent
> 
> I have browsed through the commit, data can also be a PD code when its length is 2 it is not always oriented gauss code. 

Yes and this is fine. From my commit:

```
+            if len(data) != 2 or not all(isinstance(i,list) for i in data[0]):
+                # here we expect a PD code
```

Which mean that you expect a PD code if either `len(data) != 2` *or* if any element of `data[0]` is not a list.

Vincent


---

Comment by amitjamadagni created at 2014-09-28 15:21:20

Replying to [comment:37 vdelecroix]:
> Replying to [comment:36 amitjamadagni]:
> > Replying to [comment:35 vdelecroix]:
> > > Hello,
> > > 
> > > The logic of every if/else is completely crazy. Rewriting the `__init__` properly takes only half of the preceding implementation: see my commit at `u/vdelecroix/17030`. The code needs a lot of polishing. I did not dig in the details but it is clearly hard to read!
> > > 
> > > Vincent
> > 
> > I have browsed through the commit, data can also be a PD code when its length is 2 it is not always oriented gauss code. 
> 
> Yes and this is fine. From my commit:
> {{{
> +            if len(data) != 2 or not all(isinstance(i,list) for i in data[0]):
> +                # here we expect a PD code
> }}}
> Which mean that you expect a PD code if either `len(data) != 2` *or* if any element of `data[0]` is not a list.
> 
> Vincent

Yeah ! I get it.


---

Comment by mmarco created at 2014-09-28 18:38:06

Actually, i think that tuples should be allowed too. What do you think about storing the attributes as tuples ? (so they would be immutable)


---

Comment by git created at 2014-09-29 17:32:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2014-09-29 20:14:58

You should add this to the reference manual using changes like these:

```diff
diff --git a/src/doc/en/reference/index.rst b/src/doc/en/reference/index.rst
index 662a079..c5e2211 100644
--- a/src/doc/en/reference/index.rst
+++ b/src/doc/en/reference/index.rst
`@``@` -69,6 +69,7 `@``@` Geometry and Topology
 * :doc:`Cell Complexes and their Homology <homology/index>`
 * :doc:`Differential Forms <tensor/index>`
 * :doc:`Parametrized Surfaces <riemannian_geometry/index>`
+* :doc:`Knot Theory <knots/index>`
 
 Number Theory, Algebraic Geometry
 ---------------------------------
diff --git a/src/doc/en/reference/knots/conf.py b/src/doc/en/reference/knots/conf.py
new file mode 120000
index 0000000..2bdf7e6
--- /dev/null
+++ b/src/doc/en/reference/knots/conf.py
`@``@` -0,0 +1 `@``@`
+../conf_sub.py
\ No newline at end of file
diff --git a/src/doc/en/reference/knots/index.rst b/src/doc/en/reference/knots/index.rst
new file mode 100644
index 0000000..229ccac
--- /dev/null
+++ b/src/doc/en/reference/knots/index.rst
`@``@` -0,0 +1,9 `@``@`
+Knot theory
+===========
+
+.. toctree::
+   :maxdepth: 2
+
+   sage/knots/link
+
+.. include:: ../footer.txt
```

(It may not be clear from this, but `src/doc/en/reference/knots/conf.py` is a symlink pointing to `src/doc/en/reference/conf_sub.py`.) Once you do this, you will find that the documentation is a mess: indentations are wrong, etc. For example, here are some changes I found by looking at the first few methods:

```diff
diff --git a/src/sage/knots/link.py b/src/sage/knots/link.py
index 6259df0..3ed2dd6 100644
--- a/src/sage/knots/link.py
+++ b/src/sage/knots/link.py
`@``@` -44,18 +44,18 `@``@` class Link:
       2. Oriented Gauss Code
       3. Planar Diagram Code
 
-      EXAMPLES::
-
-          sage: B = BraidGroup(8)
-          sage: L = Link(B([1, 2, 1, -2,-1]))
-          sage: L
-          Link with 2 components represented by 5 crossings
-          sage: L = Link([This is the Trac macro *[-1, +2, -3, 4, +5, +1, -2, +6, +7, 3, -4, -7, -6,-5* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[-1, +2, -3, 4, +5, +1, -2, +6, +7, 3, -4, -7, -6,-5-macro),[-1, -1, -1, -1, 1, -1, 1]])
-          sage: L
-          Knot represented by 7 crossings
-          sage: L = Link([[1,8,2,7],[8,4,9,5],[3,9,4,10],[10,1,7,6],[5,3,6,2]])
-          sage: L
-          Link with 2 components represented by 5 crossings
+    EXAMPLES::
+
+        sage: B = BraidGroup(8)
+        sage: L = Link(B([1, 2, 1, -2,-1]))
+        sage: L
+        Link with 2 components represented by 5 crossings
+        sage: L = Link([This is the Trac macro *[-1, +2, -3, 4, +5, +1, -2, +6, +7, 3, -4, -7, -6,-5* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[-1, +2, -3, 4, +5, +1, -2, +6, +7, 3, -4, -7, -6,-5-macro),[-1, -1, -1, -1, 1, -1, 1]])
+        sage: L
+        Knot represented by 7 crossings
+        sage: L = Link([[1,8,2,7],[8,4,9,5],[3,9,4,10],[10,1,7,6],[5,3,6,2]])
+        sage: L
+        Link with 2 components represented by 5 crossings
     """
 
     def __init__(self, data):
`@``@` -70,6 +70,8 `@``@` class Link:
 
         Generators of the braid group are used to generate the link.
 
+        EXAMPLES::
+
             sage: B = BraidGroup(8)
             sage: L = Link(B([-1, -1, -1, -2,1, -2,3,-2,3]))
             sage: L
`@``@` -92,6 +94,8 `@``@` class Link:
         anti-clockwise, -1 if the direction from the leaving over-cross to the
         leaving under-cross is clockwise.
 
+        EXAMPLES::
+
             # for knots there is only a single component so the input is as follows
             sage: L = Link([This is the Trac macro *[-1, +2, 3, -4, 5, -6, 7, 8, -2, -5, +6, +1, -8, -3, 4, -7* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[-1, +2, 3, -4, 5, -6, 7, 8, -2, -5, +6, +1, -8, -3, 4, -7-macro),[-1,-1,-
             sage: L
`@``@` -240,8 +244,10 `@``@` class Link:
         r"""
         Return the oriented gauss code of the link. The oriented gauss
         code has two parts
+
         a. The gauss code
         b. The orientation of each crossing
+
         The following orientation was taken into consideration for consturction
         of knots:
```

(And now I just saw that "construction" is misspelled in the last sentence.)

Doctest coverage is not yet 100%:

```
$ sage --coverage src/sage/knots/link.py
------------------------------------------------------------------------
SCORE src/sage/knots/link.py: 85.3% (29 of 34)

Missing documentation:
     * line 1686: def _rule_1_(over)
     * line 1701: def _rule_2_(over)
     * line 1714: def _pd_error_(pd)
     * line 1728: def _bracket_(pd_code)
     * line 1768: def _rule_4_(rest, c_1, c_2)
------------------------------------------------------------------------
```



---

Comment by git created at 2014-10-05 16:48:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-10-05 16:53:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2014-10-08 11:22:49

Documentation does not build:


```
...
[knots    ] loading cross citations...
[knots    ] /home/mmarco/sage/local/lib/python2.7/site-packages/sage/knots/link.py:docstring of sage.knots.link:2: ERROR: Unexpected indentation.
[knots    ] /home/mmarco/sage/local/lib/python2.7/site-packages/sage/knots/link.py:docstring of sage.knots.link:4: WARNING: Block quote ends without a blank line; unexpected unindent.
[knots    ] <autodoc>:0: ERROR: Unexpected indentation.
[interface] reading sources... [ 25%] sage/interfaces/gap
[categorie] reading sources... [ 92%] sage/categories/semirings
Error building the documentation.
Traceback (most recent call last):
  File "/home/mmarco/sage/src/doc/common/builder.py", line 1491, in <module>
    getattr(get_builder(name), type)()
  File "/home/mmarco/sage/src/doc/common/builder.py", line 292, in _wrapper
    getattr(get_builder(document), 'inventory')(*args, **kwds)
  File "/home/mmarco/sage/src/doc/common/builder.py", line 503, in _wrapper
    x.get(99999)
  File "/home/mmarco/sage/local/lib/python/multiprocessing/pool.py", line 558, in get
    raise self._value
OSError: [knots    ] /home/mmarco/sage/local/lib/python2.7/site-packages/sage/knots/link.py:docstring of sage.knots.link:2: ERROR: Unexpected indentation.

Makefile:60: recipe for target 'doc-html' failed
make: *** [doc-html] Error 1

```



---

Comment by mmarco created at 2014-10-15 23:10:07

The conversion to braid gives wrong answer, which causes several other errors:


```
sage: L=Link([[1, 5, 2, 4], [7, 11, 8, 10], [3, 8, 4, 9], [9, 2, 10, 3], [5, 1, 6, 12], [11, 7, 12, 6]])
sage: L.braid()
s0*s1^-1*s2*s1^-1*s0^-1*s1^-1*s2^-1*s3^-1*s2*s1^-1*s0*s2*s1^-1
sage: L
Link with 2 components represented by 6 crossings
```



---

Comment by git created at 2014-10-16 07:34:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by amitjamadagni created at 2014-10-16 07:37:24

I guess its fixed.Here are the results

```
sage: L=Link([[1, 5, 2, 4], [7, 11, 8, 10], [3, 8, 4, 9], [9, 2, 10, 3], [5, 1, 6, 12], [11, 7, 12, 6]])
sage: L
Knot represented by 6 crossings
sage: L.braid()
s0*s1^-1*s2*s1^-1*s0^-1*s1^-1*s2^-1*s3^-1*s2*s1^-1*s2*s3  
sage: L.braidword()
(1, -2, 3, -2, -1, -2, -3, -4, 3, -2, 3, 4)
```

----
New commits:


---

Comment by mmarco created at 2014-10-16 10:43:55

Still broken:


```
sage: L=Link([[1, 9, 2, 8], [7, 15, 8, 14], [5, 17, 6, 16], [9, 1, 10, 18], [15, 7, 16, 6], [17, 11, 18, 10], [13, 3, 14, 2], [3, 13, 4, 12], [11, 5, 12, 4]])
sage: L.bra
L.braid      L.braidword  
sage: L.braidword()

```


(does not finish the computation).


---

Comment by amitjamadagni created at 2014-10-16 21:01:37

I am getting into an infinite loop with the _info_all_moves_ method.With this approach there seems that the regions with same sign never are in the same seifert circles there by the above method keeps on giving out the edited pd_code. Could you please let me know the knot reference ??


---

Comment by git created at 2014-10-26 14:57:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by amitjamadagni created at 2014-10-26 15:02:41

The above commit aims to fix the documentation. The documentation builds both pdf and html.


---

Comment by tscrim created at 2014-10-26 15:26:18

I think the bulk of the documentation should be at the class level, rather than the module level. That way when a user does `Link?`, the user sees all of that documentation. Also this way the doc is better associated with what it's documenting.

Side note, making things raw strings, the `r"""`, is usually safer, in particular when you have latex commands.


---

Comment by git created at 2014-10-26 21:52:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-11-04 17:57:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by amitjamadagni created at 2014-11-04 18:06:49

The idea of plot by Miguel has been added. I am trying on the refinement as it raises an error for the cases like :


```
sage: B = BraidGroup(8)
sage: L = Link(B([-1,3,1,5,1,7,1,6]))
sage: L.linkplot()
 
MIPSolverException: 'GLPK : Solution is undefined' 
```


The errors like this and the work on documentation for the plot remain.


---

Comment by mmarco created at 2014-11-04 18:11:04

I would dsy thast this fasils because the diagram has more than one connected component. It could be useful to have a method to list the different "completely unlinked" components, as they should be treated separatedly in several places.


---

Comment by amitjamadagni created at 2014-11-04 18:14:02

Replying to [comment:56 mmarco]:
> I would dsy thast this fasils because the diagram has more than one connected component. It could be useful to have a method to list the different "completely unlinked" components, as they should be treated separatedly in several places.
Okay then I guess a combination of braidwordcomponents which gives 


```
sage: L._braidwordcomponents_()
[[-1, 1, 1, 1], [3], [5, 7, 6]]
```


ncomponents could be used. I will try to set this up.


---

Comment by mmarco created at 2014-11-04 18:25:16

No, it is not the same as ncomponents. ncomponents counts how many different pieces of rope are in the link. What i am talking about is about pieces of the diagram that don't cross at all.

That is, the braid [1,1] has two connected components (that is, two pieces of rope), but they have crossings between them, so they are  in the same part of the diagram.

Whereas the braid [1,3] has also two connected components (two pieces of rope), but there is no crossing at all between them. The planar diagram is just two separated planar diagrams. 

This situation of "completely independent" pieces needs to be treated separatedly in several methods. For instance, try to check how many methods fail for things like Link([[1,1,2,2],[3,3,4,4]])


---

Comment by amitjamadagni created at 2014-11-04 18:31:30

So are we looking at something like the _braidwordcomponents_() which acts like :

```
sage: L._braidwordcomponents_()
[[-1, 1, 1, 1], [3], [5, 7, 6]]
```



---

Comment by mmarco created at 2014-11-04 18:33:54

Yes, that is the idea.

But be careful: thinkig only in terms of braids might lead to errors that appear when we deal with other representations.


---

Comment by mmarco created at 2014-11-25 18:05:30

Changing status from needs_work to needs_review.


---

Comment by mmarco created at 2014-11-25 18:05:30

Since Amit did not answer lately, i decided to step up and do some cleanup and polishing of the code. Maybe documentation can be improved, but i think besides that it is pretty much ready for review.

Bad news is that, since i am now an author, somebody else should do the reviewing instead of me.
----
New commits:


---

Comment by mmarco created at 2014-11-25 18:05:30

Changing type from task to enhancement.


---

Comment by kcrisman created at 2014-11-25 18:09:53

> Bad news is that, since i am now an author, somebody else should do the reviewing instead of me.
Not all bad news, because you can specify exactly which files/commits/contributions remain "yet to be reviewed".  You can also suggest ways for people (even non-knot theorists) to test things out, and which things need some outside eyes.


---

Comment by kcrisman created at 2014-11-25 18:11:31

By the way, once this has positive review, it might be worth making a new branch that just adds in all these new files at one fell swoop.   Or that might be a bad idea, depending on how you want the history to go in Sage.  Just pointing it out.


---

Comment by amitjamadagni created at 2014-11-25 18:37:34

In the case of testing, the polynomial invariants have been compared with Knot Atlas as mentioned by Miguel. The other major part that need to be tested are the conversions, I guess it is easy for anyone to have a go at this by reading the documentation.


---

Comment by kcrisman created at 2014-11-25 18:44:46

Alternately, if there is a good "core" of functionality you (mmarco) as reviewer approve of that is a coherent whole, then other stuff could be moved to a new ticket.  Especially if the stuff that still needs review is more peripheral, such as plotting...


---

Comment by mmarco created at 2014-11-25 18:52:22

Inthe case of git history, i like it to reflect the process that actually took place, in case that someone in the future wants to do some archeology.

But it is just a matter of personal taste. I understand why other people prefear to avoid haveing too many commits in the history.

My last changes touch most of the relevant methods, so it would be difficult to stablish a clear separation from my work and Amit's.

Here some ideas of things that non specialists in knot theory can do towards reviewing:

- Check the documentation. In fact, it is better if they are not specialist: the documentation should be clear for everybody. So if there is something that someone does not understand, please point it out.

- Test some results that are known in other sources. For instance go to the knot atlas, pick any knot or link there, create it in Sage, compute the different invariants and compare. (Note, here we follow a different convention than in the knot atlas for the PD code, Xa,b,c,d in the knot atlas corresponds here to [a,d,b,c]).

- Check out also the plotting of knots (no deep knowledge of knot theory is needed, although it is a complicated method, so it is hard to review... but it is really cool ;) ).


Regarding the idea of separting it into smaller tickets, we could do that, but besides the plotting, all the methods that can be separated into other tickets (i.e. the computation of the different invariants), are pretty trivial, since they are almost direct aplications of the conversion to braid).


---

Comment by mmarco created at 2014-11-25 18:54:02

I forgot to mention: the conversion to braid is one of the methods that i have rewriten. And it is really essential (i.e. it makes little sense to have a link class without it).


---

Comment by amitjamadagni created at 2014-11-25 18:55:14

I observe there is some problem with the regions method, I end up getting a build error.


---

Comment by mmarco created at 2014-11-25 19:01:17

Oops, i see there was some problem while merging different branches.

The actual branch is a mess. Let me try to solve it tonight.


---

Comment by mmarco created at 2014-11-25 19:20:41

How can i force the branch to go back to commit â€‹17a982e? If i try to push it i get the message:


```
Not pushing your changes because they would discard some of the commits on the remote branch
```



---

Comment by kcrisman created at 2014-11-25 19:29:29

There is a lot of discussion out there about this.  Git has the philosophy that once something is pushed to a public repo, it really shouldn't be changed.  See [this SO question](http://stackoverflow.com/questions/5509543/how-do-i-properly-force-a-git-push) and [this answer](http://stackoverflow.com/a/16702355/782821) for some points of view, though an internet search will yield a LOT more opinions on this, such as [this one](http://stackoverflow.com/a/10510482/782821) which seems more nuanced.

Basic is that you can "force" a push (and this happens on occasion on Sage Trac) or "revert" some commits.


---

Comment by vdelecroix created at 2014-11-25 20:51:16

I would be happy to participate in the review. But first, you have to read my two cents about git history. I think that the git history must be helpful to newcomers and not for archaeologists (for them, we have trac and sage-devel. Moreover, they do not necessarily want to know that in the first n commits you were just trying to understand how to use git).

More precisely:
- keep the history simple
- always have the following sentence in mind: "what is the most helpful for the reviewer?" 

More concretely
- merge as less as possible
- if you modify a lot on an already existing file, try to have one commit that deletes and an other one that adds
- if you are only providing new functionalities in independent file, try to minimize the number of commits (or at least make them coherent for the reader)

Git history could be really helpful to reviewer. For example, if you simply move a file, the commit will only be "mv old_file -> new_file". Hence, as a reviewer, I know that there is nothing to check in that file.

Vincent


---

Comment by git created at 2014-11-25 21:32:35

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmarco created at 2014-11-25 21:49:32

Ok, i forced a push that should simplify the history, and return to a sane state.


---

Comment by tscrim created at 2014-11-26 02:40:56

I'd have just merged the remote branch (from the message, it seems like your local branch was behind the one on trac). I'll try to take a look at this soon too.

Vincent and I disagree on the following git stuff. The general git philosophy, as far as I have seen, is to favor more commits into small logical chunks and to keep history that you can go back and see (or retrieve) code formats that you've tried before. The important thing is to have commit messages which describe what is done in the commit.


---

Comment by kcrisman created at 2015-01-05 17:48:50

> My last changes touch most of the relevant methods, so it would be difficult to stablish a clear separation from my work and Amit's.
Well, not exactly; in fact, you only did the last two commits, so in principle someone else could review just those commits (and the very last commit seems very straightforward).  What I was hoping to elicit from you is the answer to the following question:
> In your opinion, is everything not touched by your commits okay (even if fairly trivial), and do you feel there is any additional work needed beyond reviewing the pieces (many, granted) you did work on?


---

Comment by kcrisman created at 2015-01-05 18:17:43

Some minor things, just on a first glance:
* Various minor English misspellings.
* There should probably be an "intro" module-level section telling people what links and knots are (in particular, the difference, since lots of people have heard of knots but not so many of links).  See e.g. [the cooperative game theory doc](http://www.sagemath.org/doc/reference/game_theory/sage/game_theory/cooperative_game.html) though this is quite comprehensive.
* Sometimes there are sort-of-bullet lists that aren't formatted that way, such as for how to create a link.
* The plot example doesn't show how to make a plot.


---

Comment by mmarco created at 2015-01-05 18:30:16

Thank you for the review. You are totally right. I will work on that.


---

Comment by kcrisman created at 2015-01-06 03:53:06

Another random question.  So say I look at a random knot page at the atlas, say [K11a142](http://katlas.math.toronto.edu/wiki/K11a142).  We only seem to have a few of the invariants (which is fine) but what about the non-polynomial invariants?  Also, I think we have braid diagrams (?) so maybe we should have some of those in the examples.


---

Comment by mmarco created at 2015-01-06 10:46:31

Sorry, i don't really understand your question. Can you be more explicit about what you propose?


---

Comment by kcrisman created at 2015-01-06 13:52:30

What I mean is, are any of the non-polynomial invariants like "3-genus" available yet?  Just asking.

Secondly, I think that we have a way to [plot braids](http://www.sagemath.org/doc/reference/groups/sage/groups/braid.html#sage.groups.braid.Braid.plot), and this is in the atlas, so we should probably at least mention this in the documentation along with an example or two.

Sorry for any confusion.


---

Comment by amitjamadagni created at 2015-01-06 14:16:36

Yeah we have genus, signature, determinant, arf invariant (only for knots) which can be seen as invariants as they distinguish between different links. 
Coming to the plotting of braids, the closure of braids gives a link but the plotting of braids would be not sufficient here as we have to close the braids to get the corresponding link, so we did not consider it as an option.


---

Comment by kcrisman created at 2015-01-06 15:06:25

I wasn't suggesting plotting the braids as something in knots, just that the knot atlas picks some random braid rep of the link and shows a plot, so since that is such a standard reference we could include that in (perhaps the module-level) documentation.


---

Comment by git created at 2015-01-08 10:22:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2015-01-08 10:25:59

I have writen a module documentation (i think it still needs work), and solved some misspellings and the plot documentation.

We don't have implemented the 3-genus, as many other invariants.


---

Comment by kcrisman created at 2015-01-08 13:45:00

Thanks for this commit.
> I have writen a module documentation (i think it still needs work)
Perhaps, but at least now it is sufficient for people coming in with a reasonable mathematical background.  Often things are implemented in Sage for research first, then stuff making it more useful for pedagogy comes later.

Hopefully someone might be able to look at the remaining code, of course!  I won't have time for this in the immediate future.


---

Comment by mmarco created at 2015-02-16 10:44:56

There is a bug with the .regions method that shows up when there are edges with both ends in the same crossing:


```
sage: L=Link([This is the Trac macro *1,2,2,1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2,2,1-macro))
sage: L.regions()
[]
sage: L=Link([This is the Trac macro *1,1,2,2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1,2,2-macro))
sage: L.regions()
[[-2], [1], [2, -1]]
```


I don't have much time right now, but can try to solve it when i find some time. In the meantime, can Amit or someone else take a look?


---

Comment by amitjamadagni created at 2015-02-16 13:52:05

The problem with the first case is with the orientation of the knot. It seems the orientation of the knot is coming out as -1 which should be +1

```
sage: L = Link([This is the Trac macro *1, 2, 2, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 2, 2, 1-macro))  
sage: L.orientation()
[-1]
```


I will try looking into the construction of orientation.

As for the second input, single negative entry does not make sense and I have added a bit of code (not optimal yet works). Here are the results :

```
sage: L = Link([This is the Trac macro *1, 1, 2, 2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1, 2, 2-macro))
sage: L.orientation()
[-1]
sage: L.regions()
[[1], [2, -1]]
```


I will try working on the orientation to see where it is going wrong.


---

Comment by mmarco created at 2015-02-16 15:22:35

Wait, this part:


```
sage: L=Link([This is the Trac macro *1,1,2,2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1,2,2-macro))
sage: L.regions()
[[-2], [1], [2, -1]]
```


was correct. There is one region whose boundary is just the edge 2 in the negative direction.
----
New commits:


---

Comment by amitjamadagni created at 2015-02-16 15:37:05

As far as I remember we had to select an edge and turn left until we arrived at the edge where we started. I guess we do not consider the edges reversed which are the negative ones, in this case -2, so I thought we should not include -2. Please do correct me if I am missing something.


---

Comment by mmarco created at 2015-02-16 15:45:28

The regions with only one edge are regions like the others, and we have to describe them using the same convention as the others.

If you draw that knot diagram, you will see three regions: two "inside" (the [1] and the [-2]) and the exterior one (the [2, -1]).


---

Comment by mmarco created at 2015-03-11 16:05:56

Somebody else is getting an error message when building the documentation? I am unable to point the problem.


---

Comment by jhpalmieri created at 2015-03-11 17:27:46

The documentation builds for me if I make this change:

```diff
diff --git a/src/sage/knots/link.py b/src/sage/knots/link.py
index c15484f..72c9ce4 100644
--- a/src/sage/knots/link.py
+++ b/src/sage/knots/link.py
`@``@` -1352,7 +1352,7 `@``@` class Link:
         OUTPUT:
 
         - Jones Polynomial of the link. It is a polynomial in var, as an element
-        of the symbolic ring.
+          of the symbolic ring.
 
         EXAMPLES::
```



---

Comment by mmarco created at 2015-03-12 14:59:15

I have corrected the regions method, with some ad-hoc code for degenerated cases with two loops in the same crossing.

The plot method needs some work to handle too these kind of loops properly.
----
New commits:


---

Comment by kcrisman created at 2015-03-24 15:46:50

See also http://www.math.uic.edu/t3m/SnapPy/spherogram.html#the-link-class for how SnapPy deals with knots when inside of Sage.


---

Comment by chapoton created at 2015-03-24 21:18:36

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2015-03-24 21:18:36

One doctest failing

```
File "src/sage/knots/link.py", line 1475, in sage.knots.link.Link.plot
Failed example:
    L.plot()
Expected nothing
Got:
    Graphics object consisting of 28 graphics primitives
```



---

Comment by chapoton created at 2015-03-25 19:49:30

and also not yet at 100% coverage

```
Missing doctests  knots/link.py 27 / 29 = 93%
```



---

Comment by git created at 2015-03-30 11:14:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2015-03-30 11:22:44

Fixed the minor issues woth doctests.

I am also woriking on a method to compute the homfly polynomial, but it deppends on #18047 and #18057. Since this ticket is already quite big, and taking a lot to be reviewed, i prefear to wait for it in another ticket (unless somebody is willing to review this whole ticket plus the new functionality).


---

Comment by chapoton created at 2015-04-09 19:42:22

fixed the failing "plot" doctest
----
New commits:


---

Comment by chapoton created at 2015-07-30 16:03:54

+Missing doctests  knots/link.py 28 / 29 = 96%


---

Comment by mmarco created at 2015-07-30 18:56:49

Since this seems to be too big for a proper review, i am planning to split it in several smaller tickets. Does that sound like a good idea?


---

Comment by chapoton created at 2015-07-30 19:03:01

oh, well.. If it passes all tests, and has 100% doc, one could has well get it inside as a block.. Maybe ask on sage-devel (once 100% doctest has been reached !)


---

Comment by tscrim created at 2015-07-30 23:30:47

I don't think we necessarily need to split this into multiple tickets (in fact, that seems kind of hard). If someone can review the mathematics side of things, I'd be happy to do the code review.


---

Comment by mmarco created at 2015-07-31 04:25:50

Ok then, i will try to work in improving the doctest coverage.


---

Comment by git created at 2015-08-05 14:14:11

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by mmarco created at 2015-08-05 14:17:51

Ok, i added the misisng doctest. I also solved a bug in the orientation method, and while i were at it, i rebased the whole thing to the last development version.

If you feel able to review it, then please go for it. Otherwise i will try to tho de the splitting into smaller parts for easier review.


---

Comment by kcrisman created at 2015-08-05 15:28:19

I agree that in this particular case it could be useful to keep it in one piece.  However, if mmarco is willing to do the work to split this into coherent separate tickets that could be easily reviewed by people other than the authors, that is certainly not a bad idea.  For one thing, it might be possible for him to create a few tickets of material that he did _not_ write and could just give positive review to.  I'm sorry I haven't been able to help figure this out better although I think it should be very high priority, but I had a very busy year and couldn't learn enough knot theory algorithms to do this yet, nor to convince any knot theorist friends to take the time to learn Sage yet.


---

Comment by jhpalmieri created at 2015-08-05 16:58:03

One quick comment: the file `reference/knots/conf.py` should be a symlink to `../conf_sub.py`, not a copy of that file.


---

Comment by tscrim created at 2015-08-05 16:59:35

If Miguel thinks it is (now) mathematically solid, then I will do the final parts of the review over the next day or so.

Some things from a quick lookthrough:

- Is the definition of the writhe valid for links? Right now the documentation just says "of the knot".

- Methods like `alexander_polynomial` could use elaboration in their documentation, such as their definition and/or references.

- I want to create a separate class `Knot` inheriting from `Link` to make it easier for people expanding on this in the future (and there is already a method specifically for knots). Any objections to me doing this?

(John just outposted me on the symlink :P ).


---

Comment by jhpalmieri created at 2015-08-05 17:42:30

Hi Travis,

Please go ahead with a full review. I think a new `Knot` class would be good. For future work, it would also be nice to have a catalog of links and knots (e.g., `knots.Trefoil()`) and also ways of producing new links from old. Could you add a `.. todo` list?

I agree that more documentation would be great, with definitions, references, and (for `plot` at least) algorithms.

How is equality determined? How should it be? Should the oriented Gauss code be good enough?

```
sage: trefoil = Link([[1, 5, 2, 4], [5, 3, 6, 2], [3, 1, 4, 6]])
sage: trefoil == Link([[1, 5, 2, 4], [5, 3, 6, 2], [3, 1, 4, 6]])
False
```


I haven't actually looked at the code, and I don't know if I ever will. Some suggestions for miscellaneous minor cleanup:

```diff
diff --git a/src/sage/knots/link.py b/src/sage/knots/link.py
index 04facf8..89f9624 100644
--- a/src/sage/knots/link.py
+++ b/src/sage/knots/link.py
`@``@` -10,7 +10,7 `@``@` A link is an embedding of one or more copies of `\\mathbb{S}^1` in `\\mathbb{S}^
 considered up to ambient isotopy. That is, a link represents the idea of one or more
 tied ropes. Every knot is a link, but not every link is a knot.
 
-Generically, the projection of a link on `\\mathbb{R}^2`
+Generically, the projection of a link to `\\Bold{R}^2`
 is a curve with crossings. The crossings are represented to show which strand goes
 over the other. This curve is called a planar diagram of the link. If we remove the
 crossings, the resulting connected components are segments. These segments are
`@``@` -40,16 +40,12 `@``@` AUTHORS:
 
 from sage.matrix.constructor import matrix
 from sage.rings.integer_ring import ZZ
-from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
 from sage.rings.finite_rings.integer_mod import Mod
 from sage.graphs.digraph import DiGraph
 from sage.graphs.graph import Graph
 from copy import deepcopy, copy
 from sage.rings.polynomial.laurent_polynomial_ring import LaurentPolynomialRing
-from sage.rings.integer_ring import IntegerRing
-from sage.combinat.permutation import Permutations
-from sage.rings.finite_rings.integer_mod_ring import IntegerModRing
-from sage.symbolic.ring import SR, var
+from sage.symbolic.ring import SR
 from sage.rings.integer import Integer
 from sage.numerical.mip import MixedIntegerLinearProgram
 from sage.functions.generalized import sign
`@``@` -74,7 +70,7 `@``@` class Link:
         sage: L
         Link with 2 components represented by 5 crossings
 
-    Note that the strands of the braid that have no crossings at all are ignored.
+      Note that the strands of the braid that have no crossings at all are ignored.
 
     - Oriented Gauss Code:
 
`@``@` -82,7 +78,7 `@``@` class Link:
       crossings) and start moving along the link. Trace every component of
       the link, by starting at a particular point on one component of the link and
       writing down each of the crossings that you encounter until returning to the starting
-      point. The crossings are written with sign depending on wheter we cross them
+      point. The crossings are written with sign depending on whether we cross them
       as over or undercrossing. Each component is then represented as a list whose
       elements are the crossing numbers. A second list of +1 and -1's keeps track of
       the orientation of each crossing::
`@``@` -91,7 +87,7 `@``@` class Link:
         sage: L
         Knot represented by 8 crossings
 
-      For links there is more than one component and the input is as follows::
+      For links there may be more than one component and the input is as follows::
 
         sage: L = Link([[[-1, 2], [-3, 4], [1, 3, -4, -2]], [-1, -1, 1, 1]])
         sage: L
`@``@` -177,15 +173,13 `@``@` class Link:
                 self._PD_code = None
 
             else:
-                raise Exception("Invalid Input: Data must be either a list or a Braid")
+                raise ValueError("Invalid Input: Data must be either a list or a Braid")
 
     def __repr__(self):
         """
         Return a string representation.
 
-        OUTPUT:
-
-        - A string.
+        OUTPUT: string representation
 
         EXAMPLES::
 
`@``@` -211,9 +205,7 `@``@` class Link:
         """
         Return the braid representation of the link.
 
-        OUTPUT:
-
-        - Braid representation of the link.
+        OUTPUT: braid representation of the link
 
         EXAMPLES::
 
`@``@` -397,7 +389,7 `@``@` class Link:
 
         b. The orientation of each crossing
 
-        The following orientation was taken into consideration for consturction
+        The following orientation was taken into consideration for construction
         of knots:
 
         From the outgoing of the overcrossing if we move in the clockwise direction
`@``@` -411,11 +403,9 `@``@` class Link:
         The order of the orientation is same as the ordering of the crossings in the
         gauss code.
 
-        Convention : under is denoted by -1, and over by +1 in the crossing info.
+        Convention: under is denoted by -1, and over by +1 in the crossing info.
 
-        OUTPUT:
-
-        - Oriented gauss code of the link
+        OUTPUT: Oriented gauss code of the link
 
         EXAMPLES::
 
`@``@` -469,21 +459,19 `@``@` class Link:
 
     def PD_code(self):
         """
-        Return the Planar Diagram code of the link. The Planar Diagram is returned
+        Return the planar diagram code of the link. The planar diagram is returned
         in the following format.
 
         We construct the crossing by starting with the entering component of the
         undercrossing, move in the clockwise direction and then generate the list.
-        Suppose if the crossing is given by [a, b, c, d], then we interpret this
-        information as :
+        If the crossing is given by [a, b, c, d], then we interpret this
+        information as:
 
         1. a is the entering component of the undercrossing
         2. b, d are the components of the overcrossing
         3. c is the leaving component of the undercrossing
 
-        OUTPUT:
-
-        - Planar Diagram representation of the link.
+        OUTPUT: planar diagram representation of the link.
 
         EXAMPLES::
 
`@``@` -564,18 +552,16 `@``@` class Link:
 
     def gauss_code(self):
         """
-        Return the gauss_code of the link. Gauss code is generated by the
+        Return the Gauss code of the link. Gauss code is generated by the
         following procedure:
 
         a. Number the crossings from 1 to n.
         b. Select a point on the knot and start moving along the component.
         c. At each crossing, take the number of the crossing, along with
-           sign, which is '-' if it is a undercrossing and '+' if it is a
+           sign, which is '-' if it is an undercrossing and '+' if it is an
            overcrossing.
 
-        OUTPUT:
-
-        - Gauss code representation of the link.
+        OUTPUT: Gauss code representation of the link
 
         EXAMPLES::
 
`@``@` -594,7 +580,7 `@``@` class Link:
 
     def dt_code(self):
         """
-        Return the dt_code of the knot. DT code is generated by the following way.
+        Return the DT code of the knot. DT code is generated as follows.
 
         Start moving along the knot, as we encounter the crossings we
         start numbering them, so every crossing has two numbers assigned to
`@``@` -605,10 +591,7 `@``@` class Link:
         Take the even number with a negative sign if it is an overcrossing
         that we are encountering.
 
-        OUTPUT:
-
-        - DT Code representation of the knot. This is implemented only
-          for knots.
+        OUTPUT: DT Code representation of the knot. This is implemented only for knots.
 
         EXAMPLES::
 
`@``@` -644,7 +627,7 `@``@` class Link:
                         crossing = i
                         break
             if(label[2 * crossing + next_label % 2] == 1):
-                raise Exception("Implemented only for knots")
+                raise ValueError("Implemented only for knots")
             else:
                 label[2 * crossing + next_label % 2] = next_label
                 next_label = next_label + 1
`@``@` -674,15 +657,12 `@``@` class Link:
     def _dowker_notation_(self):
         """
         Return the dowker notation of the link. Similar to the PD Code we number the
-        components. So every crossing is represented by four numbers. We focus on
-        the incoming entites of the under and the over crossing. It is the pair of incoming
-        under cross and the incoming over cross. This information at every cross
+        components, so every crossing is represented by four numbers. We focus on
+        the incoming entities of the under and the overcrossing. It is the pair of incoming
+        undercross and the incoming overcross. This information at every cross
         gives the dowker notation.
 
-        OUTPUT:
-
-        - List containing the pair of incoming under cross and the incoming
-          over cross.
+        OUTPUT: List containing the pair of incoming undercross and the incoming overcross.
 
         EXAMPLES::
 
`@``@` -705,16 +685,14 `@``@` class Link:
 
     def _braidwordcomponents_(self):
         """
-        Return the disjoint braid components, if any, else returns the braid itself.
-        For example consider the braid [-1, 3, 1, 3] this can be viewed as a braid
+        Return the disjoint braid components, if any, else return the braid itself.
+        For example consider the braid [-1, 3, 1, 3]. This can be viewed as a braid
         with components as [-1, 1] and [3, 3]. There is no common crossing to these
         two (in sense there is a crossing between strand 1 and 2, crossing between
         3 and 4 but no crossing between strand 2 and 3,so these can be viewed as
         independent components in the braid).
 
-        OUTPUT:
-
-        - List containing the components is returned
+        OUTPUT: List containing the components is returned
 
         EXAMPLES::
 
`@``@` -733,7 +711,7 `@``@` class Link:
         b = self.braid()
         ml = list(b.Tietze())
         if ml == []:
-            raise Exception("The braid remains the same with no components")
+            raise ValueError("The braid remains the same with no components")
         else:
             l = list(set([abs(k) for k in ml]))
             missing1 = list(set(range(min(l), max(l) + 1)) - set(l))
`@``@` -755,11 +733,9 `@``@` class Link:
 
     def _braidwordcomponentsvector_(self):
         """
-        The list from the braidwordcomponents is flattened to give out the vector form.
+        The list from :meth:`_braidwordcomponents_` is flattened to give the vector form.
 
-        OUTPUT:
-
-        - Vector containing braidwordcomponents
+        OUTPUT: Vector containing :meth:`_braidwordcomponents_`
 
         EXAMPLES::
 
`@``@` -780,14 +756,13 `@``@` class Link:
 
     def _homology_generators_(self):
         """
-        The set of generators for the first homology group of the connected Seifert surface of the given link.
-        This method uses the braidwordcomponentsvector to generate the homology generators.
-        The position of the repeated element w.r.t the braidwordcomponentvector list is
-        compiled into a list.
-
-        OUTPUT:
+        The set of generators for the first homology group of the
+        connected Seifert surface of the given link.  This method uses
+        :meth:`_braidwordcomponentsvector_` to generate the homology
+        generators.  The position of the repeated element w.r.t.
+        :meth:`_braidwordcomponentsvector_` is compiled into a list.
 
-        - The homology generators relating to the braid word representation
+        OUTPUT: The homology generators relating to the braid word representation
 
         EXAMPLES::
 
`@``@` -802,6 +777,7 `@``@` class Link:
             sage: L = Link(B([-2, 4, 1, 6, 1, 4]))
             sage: L._homology_generators_()
             [0, 2, 0, 4, 0]
+
         """
         x4 = self._braidwordcomponentsvector_()
         hom_gen = []
`@``@` -819,10 +795,8 `@``@` class Link:
         """
         Return the Seifert Matrix associated with the link.
 
-        OUTPUT:
-
-        - The intersection matrix of a (not necessarily minimal) Seifert surface of the
-          link.
+        OUTPUT: The intersection matrix of a (not necessarily minimal) Seifert
+        surface of the link.
 
         EXAMPLES::
 
`@``@` -892,9 +866,7 `@``@` class Link:
         """
         Return the number of connected components of the link.
 
-        OUTPUT:
-
-        - Connected components of the link
+        OUTPUT: Connected components of the link
 
         EXAMPLES::
 
`@``@` -919,12 +891,10 `@``@` class Link:
 
     def is_knot(self):
         """
-        Return True if the link is knot.
+        Return True if the link is a knot.
         Every knot is a link but the converse is not true.
 
-        OUTPUT:
-
-        - True if knot else False
+        OUTPUT: True if knot else False
 
         EXAMPLES::
 
`@``@` -946,9 +916,7 `@``@` class Link:
         """
         Return the genus of the link
 
-        OUTPUT:
-
-        - Genus of the Link
+        OUTPUT: genus of the link
 
         EXAMPLES::
 
`@``@` -1004,9 +972,7 `@``@` class Link:
         """
         Return the signature of the link
 
-        OUTPUT:
-
-        - Signature of the Link
+        OUTPUT: signature of the link
 
         EXAMPLES::
 
`@``@` -1039,9 +1005,7 `@``@` class Link:
 
         - ``var`` -- (default: ``'t'``); the variable in the polynomial.
 
-        OUTPUT:
-
-        - Alexander Polynomial of the Link
+        OUTPUT: Alexander Polynomial of the Link
 
         EXAMPLES::
 
`@``@` -1067,9 +1031,7 `@``@` class Link:
         """
         Return the determinant of the knot
 
-        OUTPUT:
-
-        - Determinant of the Knot
+        OUTPUT: determinant of the knot
 
         EXAMPLES::
 
`@``@` -1089,15 +1051,13 `@``@` class Link:
             a = self.alexander_polynomial()
             return Integer(abs(a(-1)))
         else:
-            raise Exception("Determinant implmented only for knots")
+            raise ValueError("Determinant implemented only for knots")
 
     def arf_invariant(self):
         """
         Return the arf invariant. Arf invariant is defined only for knots.
 
-        OUTPUT:
-
-        - Arf invariant of knot
+        OUTPUT: Arf invariant of the knot
 
         EXAMPLES::
 
`@``@` -1120,20 +1080,16 `@``@` class Link:
             else:
                 return 1
         else:
-            raise Exception("Arf invariant is defined only for knots")
+            raise ValueError("Arf invariant is defined only for knots")
 
     def is_alternating(self):
         """
-        Return True if the given knot diagram is alternating else returns False.
-        Alternating diagram implies every over cross is followed by an under cross
+        Return True if the given knot diagram is alternating else return False.
+        Alternating diagram means that every over cross is followed by an under cross
         or the vice-versa.
 
-        We look at the gauss code if the sign is alternating, True is returned else
-        the knot is not alternating False is returned.
-
-        OUTPUT:
-
-        - True if the knot diagram is alternating else False
+        In the gauss code, if the sign is alternating, True is returned, else
+        the knot is not alternating so False is returned.
 
         EXAMPLES::
 
`@``@` -1169,10 +1125,6 `@``@` class Link:
         """
         Return the orientation of the crossings of the link diagram.
 
-        OUTPUT:
-
-        - Orientation  of the crossings.
-
         EXAMPLES::
 
             sage: L = Link([[1, 4, 5, 2], [3, 5, 6, 7], [4, 8, 9, 6], [7, 9, 10, 11], [8, 1, 13, 10], [11, 13, 2, 3]])
`@``@` -1201,15 +1153,11 `@``@` class Link:
 
     def seifert_circles(self):
         """
-        Return the seifert circles from the link diagram. Seifert circles are the circles
+        Return the Seifert circles from the link diagram. Seifert circles are the circles
         obtained by smoothing all crossings respecting the orientation of the segments.
 
         Each Seifert circle is represented as a list of the segments that form it.
 
-        OUTPUT:
-
-        - Seifert circles of the given link diagram.
-
         EXAMPLES::
 
             sage: L = Link([This is the Trac macro *[1, -2, 3, -4, 2, -1, 4, -3* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[1, -2, 3, -4, 2, -1, 4, -3-macro),[1, 1, -1, -1]])
`@``@` -1263,9 +1211,7 `@``@` class Link:
         its boundary, with a sign deppending on the orientation of the segment
         as part of the boundary.
 
-        OUTPUT:
-
-        - Regions of the knot.
+        OUTPUT: regions of the knot
 
         EXAMPLES::
 
`@``@` -1344,9 +1290,7 `@``@` class Link:
         """
         Return the writhe of the knot.
 
-        OUTPUT:
-
-        - Writhe of the knot.
+        OUTPUT: writhe of the knot
 
         EXAMPLES::
 
`@``@` -1367,16 +1311,14 `@``@` class Link:
 
     def jones_polynomial(self, var='q'):
         """
-        Return the jones polynomial of the link.
+        Return the Jones polynomial of the link.
 
         INPUT:
 
         - ``var`` -- (default: ``'q'``); the variable in the polynomial.
 
-        OUTPUT:
-
-        - Jones Polynomial of the link. It is a polynomial in var, as an element
-          of the symbolic ring.
+        OUTPUT: Jones polynomial of the link. It is a polynomial in
+        ``var``, as an element of the symbolic ring.
 
         EXAMPLES::
 
`@``@` -1394,6 +1336,7 `@``@` class Link:
             sage: L = Link(l5)
             sage: L.jones_polynomial()
             -q^(3/2) + sqrt(q) - 2/sqrt(q) + 1/q^(3/2) - 2/q^(5/2) + 1/q^(7/2)
+
         """
         t = SR(var)
         poly = self._bracket_(t)
`@``@` -1420,8 +1363,6 `@``@` class Link:
             sage: L = Link([[2, 1, 3, 4], [4, 3, 1, 2]])
             sage: L._bracket_()
             -q^4 - 1/q^4
-
-
         """
         t = SR(variable)
         if len(self.PD_code()) == 1:
`@``@` -1482,7 +1423,6 `@``@` class Link:
             sage: L = Link([[1, 1, 2, 2], [3, 3, 4, 4]])
             sage: L._isolated_components_()
             [This is the Trac macro *[1, 1, 2, 2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#[1, 1, 2, 2-macro), [This is the Trac macro *3, 3, 4, 4* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#3, 3, 4, 4-macro)]
-
         """
         G = Graph()
         for c in self.PD_code():
```



---

Comment by mmarco created at 2015-08-06 05:56:27

> 
> - Is the definition of the writhe valid for links? Right now the documentation just says "of the knot".
> 

It is as valid for link diagrams. The only difference with the knot case is that a change of orientation in a knot diagram does not change the writhe. However, in the case of link diagrams, a change of the orientation on a component might change the writhe. However, we are always internally considering an orientation in the diagrams, so it does make sense.

> - Methods like `alexander_polynomial` could use elaboration in their documentation, such as their definition and/or references.
> 

Ok, i will try to work on that, in the following days.

> - I want to create a separate class `Knot` inheriting from `Link` to make it easier for people expanding on this in the future (and there is already a method specifically for knots). Any objections to me doing this?

I had thought of keeping the same class (since they would be two almost identical classes), but have two different funcions to create the general links and the knots. The knot function would then just check that the given diagram corresponds to a knot and then create the corresponding link object.


---

Comment by mmarco created at 2015-08-06 06:07:00

> Please go ahead with a full review. I think a new `Knot` class would be good. For future work, it would also be nice to have a catalog of links and knots (e.g., `knots.Trefoil()`) and also ways of producing new links from old. Could you add a `.. todo` list?
> 
I am working on a package that would provide a knot/link database taken from the knot atlas (http://katlas.org).

Once done that, i would also like to have an "identify" method that, given a knot/link, computes its invariants and compares them with the ones in the database, giving then a list of possibilities from the database for the given knot/link.


> I agree that more documentation would be great, with definitions, references, and (for `plot` at least) algorithms.
> 
Agree on all. I defintely need to document better the plot method. That was one of the reasons for my proposal of splitting: right now the plot code is specially hard to review.

> How is equality determined? How should it be? Should the oriented Gauss code be good enough?
> {{{
> sage: trefoil = Link([[1, 5, 2, 4], [5, 3, 6, 2], [3, 1, 4, 6]])
> sage: trefoil == Link([[1, 5, 2, 4], [5, 3, 6, 2], [3, 1, 4, 6]])
> False
> }}}
> 
We can't realistically determine equality. Even determining if a given diagram corresponds to the unknot is a really hard problem. Oriented Gauss code is not even a knot invariant. 

Now that you mention it, i think that equality checking should raise "not implemented error".


Thanks for the suggestions. I will work on them.


---

Comment by tscrim created at 2015-08-06 06:11:43

I'm working on them right now. Give me a day to finish what I'm working on and after I push you can take over at that point.


---

Comment by git created at 2015-08-06 23:51:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-08-07 00:00:42

Okay, I've done my initial pass. There's still a lot more work to be done with respect to the documentation, in particular, the class level doc for the respective `Link` and `Knot` classes. (This needs to be cleaned up before a positive review; the other doc is not so important to me but it would be nice to have.)

I couldn't get one of the doctests to pass with cb84cec:

```
sage -t link.py
**********************************************************************
File "link.py", line 1185, in sage.knots.link.Link.orientation
Failed example:
    L.orientation()
Expected:
    [-1, -1, 1]
Got:
    [-1, -1, -1]
```

I believe this was a typo of a missing minus sign (if I understand the knot correctly from the plot).

I made a lot of minor to micro optimizations and code cleanup. I created a `Knot` class as Miguel suggested (and was what I had in mind initially). I created an equality check by looking at the braids (is that a link invariant?) and put a warning message about false negatives (but if it is a link invariant, then we should be able to remove the warning message).

There shouldn't be any more large refactoring of the code after this point I think.

I think for the catalog, we should open up a followup ticket rather than put an explicit todo in the file. However a big +1 on doing this.


---

Comment by mmarco created at 2015-08-07 17:53:31

I will look at it more carefully tomorrow.

In the meantime, the failing doctest is indeed a typo. The knot should be defined as 


```
sage: L = Link([[1, 2, 3, 3], [2, 4, 5, 5], [7, 4, 1, 7]])
```



> I made a lot of minor to micro optimizations and code cleanup. I created a `Knot` class as Miguel suggested (and was what I had in mind initially). I created an equality check by looking at the braids (is that a link invariant?) and put a warning message about false negatives (but if it is a link invariant, then we should be able to remove the warning message).

The braid is not a link invariant. Actually we should be careful about what equality means. If it means equality of diagrams (that is, the planar diagrams are actually the same, although maybe the elements are enumerated in a different order), we could write some method to check if there exists a different choice of labels that makes the presentations identical. If by equality we mean isotopy invariants, then we are definitely out of luck, since as far as a i know there is no effective method for that.

> 
> There shouldn't be any more large refactoring of the code after this point I think.
> 
> I think for the catalog, we should open up a followup ticket rather than put an explicit todo in the file. However a big +1 on doing this.


---

Comment by fuglede created at 2015-08-09 13:07:15

Carbon-copying a few remarks from [a sage-devel thread](https://groups.google.com/d/msg/sage-devel/ByJURRvRgLg/Jv37j-CTCwAJ): Link.jones_polynomial() has some issues for sufficiently trivial links.

In the following example -- which should be covered -- the method throws an exception:


```
sage: B = BraidGroup(2)
sage: b = B([])
sage: L = Link(b)
sage: L.jones_polynomial()
...
IndexError: list index out of range
```


And here's an example where it returns an incorrect value:


```
sage: B = BraidGroup(8)
sage: b = B([1])
sage: L = Link(b)
sage: L.jones_polynomial()
1
```



---

Comment by mmarco created at 2015-08-09 16:54:04

In the sacond case, the class documentation states that the strands of the braid that have no crossings are ignored. Considering that, the result is correct.

Maybe we should change that anyways. But would involve some redeisgn of the internal data structures.


---

Comment by fuglede created at 2015-08-09 17:05:36

Replying to [comment:125 mmarco]:
> In the sacond case, the class documentation states that the strands of the braid that have no crossings are ignored. Considering that, the result is correct.

Ah, sorry, you're right, I missed that.

> Maybe we should change that anyways. But would involve some redeisgn of the internal data structures.

Personally, I would find that more natural.


---

Comment by mmarco created at 2015-08-10 12:09:45

I get tthe following errors:


```

Running doctests with ID 2015-08-10-14-07-03-076dea73.
Git branch: ticket/17030
Using --optional=gdb,mpir,python2,sage,scons,tides
Doctesting 1 file.
sage -t --warn-long 59.0 src/sage/knots/link.py
**********************************************************************
File "src/sage/knots/link.py", line 1309, in sage.knots.link.Link.jones_polynomial
Failed example:
    L.jones_polynomial()
Exception raised:
    Traceback (most recent call last):
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 496, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 858, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.knots.link.Link.jones_polynomial[1]>", line 1, in <module>
        L.jones_polynomial()
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/knots/link.py", line 1323, in jones_polynomial
        poly = self._bracket_()
      File "sage/misc/cachefunc.pyx", line 1888, in sage.misc.cachefunc.CachedMethodCaller.__call__ (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:11438)
        w = self._cachedmethod._instance_call(self._instance, *args, **kwds)
      File "sage/misc/cachefunc.pyx", line 2544, in sage.misc.cachefunc.CachedMethod._instance_call (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:14884)
        return self._cachedfunc.f(inst, *args, **kwds)
    TypeError: _bracket_() takes exactly 2 arguments (1 given)
**********************************************************************
File "src/sage/knots/link.py", line 1312, in sage.knots.link.Link.jones_polynomial
Failed example:
    L.jones_polynomial()
Exception raised:
    Traceback (most recent call last):
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 496, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 858, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.knots.link.Link.jones_polynomial[3]>", line 1, in <module>
        L.jones_polynomial()
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/knots/link.py", line 1323, in jones_polynomial
        poly = self._bracket_()
      File "sage/misc/cachefunc.pyx", line 1888, in sage.misc.cachefunc.CachedMethodCaller.__call__ (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:11438)
        w = self._cachedmethod._instance_call(self._instance, *args, **kwds)
      File "sage/misc/cachefunc.pyx", line 2544, in sage.misc.cachefunc.CachedMethod._instance_call (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:14884)
        return self._cachedfunc.f(inst, *args, **kwds)
    TypeError: _bracket_() takes exactly 2 arguments (1 given)
**********************************************************************
File "src/sage/knots/link.py", line 1316, in sage.knots.link.Link.jones_polynomial
Failed example:
    L.jones_polynomial()
Exception raised:
    Traceback (most recent call last):
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 496, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 858, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.knots.link.Link.jones_polynomial[6]>", line 1, in <module>
        L.jones_polynomial()
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/knots/link.py", line 1323, in jones_polynomial
        poly = self._bracket_()
      File "sage/misc/cachefunc.pyx", line 1888, in sage.misc.cachefunc.CachedMethodCaller.__call__ (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:11438)
        w = self._cachedmethod._instance_call(self._instance, *args, **kwds)
      File "sage/misc/cachefunc.pyx", line 2544, in sage.misc.cachefunc.CachedMethod._instance_call (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:14884)
        return self._cachedfunc.f(inst, *args, **kwds)
    TypeError: _bracket_() takes exactly 2 arguments (1 given)
**********************************************************************
File "src/sage/knots/link.py", line 1320, in sage.knots.link.Link.jones_polynomial
Failed example:
    L.jones_polynomial()
Exception raised:
    Traceback (most recent call last):
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 496, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 858, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.knots.link.Link.jones_polynomial[9]>", line 1, in <module>
        L.jones_polynomial()
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/knots/link.py", line 1323, in jones_polynomial
        poly = self._bracket_()
      File "sage/misc/cachefunc.pyx", line 1888, in sage.misc.cachefunc.CachedMethodCaller.__call__ (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:11438)
        w = self._cachedmethod._instance_call(self._instance, *args, **kwds)
      File "sage/misc/cachefunc.pyx", line 2544, in sage.misc.cachefunc.CachedMethod._instance_call (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:14884)
        return self._cachedfunc.f(inst, *args, **kwds)
    TypeError: _bracket_() takes exactly 2 arguments (1 given)
**********************************************************************
File "src/sage/knots/link.py", line 1342, in sage.knots.link.Link._bracket_
Failed example:
    L._bracket_()
Exception raised:
    Traceback (most recent call last):
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 496, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 858, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.knots.link.Link._bracket_[1]>", line 1, in <module>
        L._bracket_()
      File "sage/misc/cachefunc.pyx", line 1888, in sage.misc.cachefunc.CachedMethodCaller.__call__ (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:11438)
        w = self._cachedmethod._instance_call(self._instance, *args, **kwds)
      File "sage/misc/cachefunc.pyx", line 2544, in sage.misc.cachefunc.CachedMethod._instance_call (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:14884)
        return self._cachedfunc.f(inst, *args, **kwds)
    TypeError: _bracket_() takes exactly 2 arguments (1 given)
**********************************************************************
File "src/sage/knots/link.py", line 1345, in sage.knots.link.Link._bracket_
Failed example:
    L._bracket_()
Exception raised:
    Traceback (most recent call last):
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 496, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/mmarco/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 858, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.knots.link.Link._bracket_[3]>", line 1, in <module>
        L._bracket_()
      File "sage/misc/cachefunc.pyx", line 1888, in sage.misc.cachefunc.CachedMethodCaller.__call__ (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:11438)
        w = self._cachedmethod._instance_call(self._instance, *args, **kwds)
      File "sage/misc/cachefunc.pyx", line 2544, in sage.misc.cachefunc.CachedMethod._instance_call (/home/mmarco/sage/src/build/cythonized/sage/misc/cachefunc.c:14884)
        return self._cachedfunc.f(inst, *args, **kwds)
    TypeError: _bracket_() takes exactly 2 arguments (1 given)
**********************************************************************
2 items had failures:
   2 of   5 in sage.knots.link.Link._bracket_
   4 of  11 in sage.knots.link.Link.jones_polynomial
    [221 tests, 6 failures, 1.63 s]
----------------------------------------------------------------------
sage -t --warn-long 59.0 src/sage/knots/link.py  # 6 doctests failed
----------------------------------------------------------------------
Total time for all tests: 1.7 seconds
    cpu time: 1.6 seconds
    cumulative wall time: 1.6 seconds
```


Also, doctest coverage is not complete:


```
mmarco`@`mountain ~/sage $ ./sage -coverage src/sage/knots/link.py
------------------------------------------------------------------------
SCORE src/sage/knots/link.py: 93.1% (27 of 29)

Missing doctests:
     * line 219: def __eq__(self, other)
     * line 233: def __ne__(self, other)
```


About the splitting of the classes, i think that what should be exposed to the user, is a  function that creates a Link or a Knot deppending of the input. That is: if the user wants to create a Link that happens to be a knot, why shouldn't it have a `arf_invariant`method?


---

Comment by git created at 2015-08-10 15:40:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-08-10 15:51:00

Hmm...weird, somehow some of my changes didn't get committed previously (most likely I forgot).

I don't like always doing an expensive check of the input with `Link`, even with a `check`. If the user think it's a knot or wants a knot, then they should create a `Knot` instance. Otherwise they are probably looking a links. We could put an example about this. IMO we do the same thing across Sage. The most direct comparison is with posets/lattices, but it also is similar to fraction fields, if you create elements that are of the proper base ring (say polynomials instead of rational functions).

PS - With high probability, knot theorists wanting to create knots are going to tab-complete find `Knot` before `Link` (if they even discover it).


---

Comment by mmarco created at 2015-08-10 15:58:38

Well, the check doesn't need to be expensive at all. What do other people think?

In any case, at a very minumum, we should have conversions from knot to link and vice-versa.


---

Comment by tscrim created at 2015-08-10 16:04:14

Getting the number of (connected) components seems very expensive from the code, but I haven't done any profiling. To compute it, we have to get the PD code (this looks like the most expensive part), construct a graph, and check the number of connected components on that. Is there a faster/better way to check?

I don't think we need a conversion from a knot to a link because of subclassing, however I'm not opposed to handling a `Link` as input to `Knot`/`Link`.


---

Comment by fuglede created at 2015-08-10 16:08:36

Replying to [comment:131 tscrim]:
> Getting the number of (connected) components seems very expensive from the code, but I haven't done any profiling. To compute it, we have to get the PD code (this looks like the most expensive part), construct a graph, and check the number of connected components on that. Is there a faster/better way to check?
> 
> I don't think we need a conversion from a knot to a link because of subclassing, however I'm not opposed to handling a `Link` as input to `Knot`/`Link`.

Sorry for coming in a bit from the sideline here, but if the link is given as a trace closure of a braid, the number of components is straightforward to compute: https://github.com/fuglede/jones-representation/blob/9305852913b9092f4ef18e547400fb8b66f33079/curverep.sage#L394


---

Comment by mmarco created at 2015-08-10 16:15:28

It deppends on the input. If the input is the oriented Gauss code, you have the number of components for free. If it is a braid, it is just the cycle representation of the corresponding permutation. If it is a PD code, then essentially it is a matter of computing the connected components of a graph.


---

Comment by fuglede created at 2015-08-11 13:42:58

Replying to [comment:132 fuglede]:
> Sorry for coming in a bit from the sideline here, but if the link is given as a trace closure of a braid, the number of components is straightforward to compute: https://github.com/fuglede/jones-representation/blob/9305852913b9092f4ef18e547400fb8b66f33079/curverep.sage#L394

As a bit of an aside for those interested, I included the methods from the link above in #19011.


---

Comment by mmarco created at 2015-08-12 12:01:23

Travis's latest changes look good to me.


---

Comment by fuglede created at 2015-09-16 15:50:50

With #19011 merged, I ran a number of different tests to compare the run times of the two algorithms for Jones polynomial computation (the one from #19011 and one from here). See [this gist](https://gist.github.com/fuglede/da35ac110ee17dc06beb#file-_jones_polynomial_comparison-md) for the results. Depending on the exact use case, there is a huge difference in performance, and optimally we would include some logic to figure out which algorithm sage should use.


---

Comment by tscrim created at 2015-09-16 22:25:09

From your data, it looks like the implementation on #19011 is the better one to use (except for perhaps small cases). My recommendation would be to add an `algorithm` argument for the Jones polynomial which dispatches to the correct algorithm (with the default being #19011). That way we can use both as extra verification of the result and the user can choose the other algorithm if the default happens to be slower.


---

Comment by fuglede created at 2015-09-17 08:51:11

Sounds reasonable enough. One thing I didn't consider by the way, is how long it actually takes to make the relevant conversions between the planar diagram and braid presentations of links.

And by the way, one could of course ask the same question about Alexander polynomials. Here, the algorithms are much more comparable and the difference might boil down to micro-optimisations(?):

https://gist.githubusercontent.com/fuglede/da35ac110ee17dc06beb/raw/c8f80d6f3d10d917a099d9559c58674b59cf686e/alexandercombined.png

On a related note, I think it would make sense to take the closure-related methods from `Braid` and refactor into `Link`, just because they logically fit there.


---

Comment by tscrim created at 2015-09-19 17:45:35

`@`fuglede
Are you planning to make that change?

`@`everyone
What else needs to be done to get this merged in? Is the Jones polynomial issue something that needs a serious fix? I think this ticket has been hanging around far too long and otherwise is in good enough shape to get a positive review.


---

Comment by mmarco created at 2015-09-19 20:02:18

It is not as polished as i would like, but i don't see it improving much anytime soon.

I think it is good enough to get it rolling. It would be better if we merge it now and then slowly do the small improvements that it needs, than to keep waiting for a complete exhaustive review process leading to a polished ticket that might never happen.


---

Comment by fuglede created at 2015-09-22 16:36:47

I pushed those changes to `u/fuglede/17030` ([GH mirror](https://github.com/fuglede/sage/commit/72bb738149541d2360c7ab131ae8830c5dbb8aee) of the commit if you just want to have a quick look). One obvious pain is that the two algorithms give different results when the link is not the trace closure of the braid used to initialize it, which happens when one has crossing-less strands, as the following example illustrates:


```
sage: B = BraidGroup(3)
sage: b = B([1])
sage: L = Link(b)
sage: b.components_in_closure()
2
sage: L.number_of_components()
1
sage: L.jones_polynomial(algorithm='jonesrep')
-sqrt(t) - 1/sqrt(t)
sage: L.jones_polynomial(algorithm='statesum')
1
```


Of course, this is not specific to Jones related stuff:


```
sage: B = BraidGroup(3)
sage: b = B([1])
sage: b.alexander_polynomial()
0
sage: Link(b).alexander_polynomial()
1
```


The branch also corrects a couple of typos.


---

Comment by fuglede created at 2015-09-23 15:12:56

Actually, I just noticed that the `alexander_polynomial` method currently gives incorrect results, even when no braid strands are ignored:


```
sage: B = BraidGroup(4)
sage: b = B([1,3])  # A braid where all strands play a role
sage: L = Link(b)   # Two disjoint unknots
sage: b.alexander_polynomial()
0
sage: L.alexander_polynomial()
1
```


In this case, 0 is the correct result as the link bounds a disconnected oriented surface (two disjoint disks).

To debug it, it would be helpful to document what `_homology_generators_` actually returns: according to the current docs, it returns 'homology generators' but it currently outputs a list of integers. Perhaps the constructed Seifert surface is not connected, or something like that? This would explain why `seifert_matrix` gives the following output:


```
sage: L.seifert_matrix()
[]
```


In this particular case, the simplest Seifert surface is probably the cylinder whose corresponding Seifert matrix is the 1x1 zero matrix.

Something else that seems weird is the following:


```
sage: L.genus()
-2
```



---

Comment by kcrisman created at 2016-02-22 11:55:10

I have some people (actual knot theorists) I've recruited to just try it out in a shared SMC instance (nothing necessary for them other than to try it and verify it performs as advertised) but I just haven't had time yet, was hoping for March :( but of course if you can finish this before that it would stupendous.


---

Comment by mmarco created at 2016-02-22 13:57:47

Can you add me to the SMC project? Aslo, take a look at

https://groups.google.com/forum/#!topic/sage-devel/4hp4SvCfEP0

If some time in March is good for you, it is ok for me too.


---

Comment by tscrim created at 2016-02-22 14:32:06

The biggest issue is fixing the discrepancy in `alexander_polynomial` noted in comment:142. I also took a look at `homology_generators`, but I had no idea what they were suppose to do either.


---

Comment by kcrisman created at 2016-02-22 16:39:03

> Can you add me to the SMC project? Aslo, take a look at

Well, I haven't created it yet :) but will do so if I am indeed able to get around to it.


---

Comment by amitjamadagni created at 2016-03-08 07:11:59

The reference to the `seifert_matrix` construction is the following by Julia Collins :

http://www.maths.ed.ac.uk/~jcollins/SeifertMatrix/

The results from the site are as follows :

You entered the braid [1,3] (Alphabetical notation: AC)
This has 2 component(s), i.e. it is a link.
The Seifert matrix is: [[]]
The genus of the Seifert surface is 0, and it has 2 connected component(s).
The braid is a disjoint union of unrelated subbraids: { [1], [3] }.

Also the reference to `homology_generators`, `genus` is the same. Though the results of the genus are different to what is reflected.


---

Comment by mmarco created at 2016-03-17 09:50:08

Replying to [comment:146 kcrisman]:
> I have some people (actual knot theorists) I've recruited to just try it out in a shared SMC instance (nothing necessary for them other than to try it and verify it performs as advertised) but I just haven't had time yet, was hoping for March :( but of course if you can finish this before that it would stupendous.

any news about it?


---

Comment by kcrisman created at 2016-03-17 12:44:15

No, but hope springs eternal... I do notice that the branch is red for some reason now.


---

Comment by git created at 2016-03-18 01:21:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-18 01:21:46

Replying to [comment:152 kcrisman]:
I do notice that the branch is red for some reason now.

This was a trivial merge conflict in `all.py`.


---

Comment by tscrim created at 2016-03-18 02:03:54

Linear algebra question: What is the determinant of a 0x0 matrix? FYI - The Sage answer:

```
sage: mat = matrix(ZZ, 0, 0)
sage: mat.det()
1
```

This is why the Alexander polynomial is returning 1 for the example in comment:142. IMO, I think it should be 0 because the sum in the definition of the determinant is vacuous. (A related question, is a 0x0 matrix invertible?)

I get the genus is 0 for the example in comment:142 with the current version.

I'm starting to understand what is going on with the code. The homology generators is setting a value of 0 if a particular pair `(L[i], L[i+1])` in the braid word component vector does not contribute to a homology generator. The braid word components are a nice reduced expression to compute these generators. See Lemma 3.1 in http://www.maths.ed.ac.uk/~jcollins/SeifertMatrix/SeifertMatrix.pdf.

I'm going through right now and doing some code improvements, seeing if I can simplify things, and working around the issue noted above.


---

Comment by git created at 2016-03-18 04:26:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-03-18 13:09:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-03-18 13:59:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-18 13:59:42

Okay, I have fixed the code issues I came across, merged in `u/fuglede/17030` but changed how the Jones polynomial was called (in particular, it should be available for the braid group elements), added a hack around the 0x0 matrix determinant issue noted in comment:155, and made it so the link actually removed unused strands from an input as a braid group element. So back to needing review.


---

Comment by tscrim created at 2016-03-18 13:59:42

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2016-03-18 14:10:55

Also, should we put a remark somewhere that we might be changing the behavior of how we handle input from the braid group to include unused strands?

One last remark, there are some oddities with plotting multiple links, but I think we can just put a warning about that for now (unless someone wants to delve into that code). We should also add a few pictures to that doc with the `.. PLOT::` directive...


---

Comment by mmarco created at 2016-03-18 16:43:19

Thanks a lot ofr the work Travis!

I wrote the code for the plotting, and I am aware that it needs some work, but I think it is good enough for now. +1 to the warning and the pics in the doc.

I hope to have some time in the next week to do a deep review.


---

Comment by git created at 2016-03-19 03:18:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-03-19 03:22:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-19 03:24:59

The issue with plotting seems to be a problem when there are multiple components that can be completely separated, but otherwise it seems to work very well.

I've added a bunch of pictures, the notes/warnings mentioned above, and did a little bit more cleanup. Hopefully this go-around we can get this finished and into Sage.


---

Comment by tscrim created at 2016-03-19 04:12:10

I created [this sage-devel thread](https://groups.google.com/forum/#!topic/sage-devel/sTQNFjCgXwc) asking about the determinant of a 0x0 matrix. There are good reasons for having it be 1, so we just have to work around that here.


---

Comment by git created at 2016-03-19 12:39:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by fuglede created at 2016-03-19 13:55:22

The determinant should definitely be 1; it's the Seifert matrix that doesn't really make sense to me (because as mentioned above, for the case of interest, one Seifert surface is the cylinder, but again, I have not understood what the algorithm actually does).

By treating only the symptoms, the algorithm now (in 7711771b) produces the incorrect result for the unknot:


```
sage: B = BraidGroup(2)
sage: b = B([1])
sage: b.alexander_polynomial()
1
sage: Link(b).alexander_polynomial()
0
```



---

Comment by git created at 2016-03-20 01:00:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-20 01:04:55

I see what the problem is now (after treating enough symptoms). In Definition 2.11, there is this: "For a link with a disconnected Seifert surface we define the Alexander polynomial to be zero." So we just need to check to see if the links can be separated, which means the braid representation can be broken into 2 disjoint components.

However, I believe the Seifert matrix is correct as it encodes the H<sub>1</sub> information of the Seifert surface. Since the unlink is a disjoint union of 2 disks, the positive homology groups are all trivial, so the Seifert matrix should be a 0x0 matrix. (If you want to think of it as a [empty] cylinder, H<sub>1</sub> is also trivial in that case as well. However, I don't think this is the correct construction of the Seifert surface from the reading I've done, but I'm not an expert.)


---

Comment by fuglede created at 2016-03-20 09:21:40

Cool, that's also what I suspected back then. Where I come from, Seifert surfaces are connected by definition; that can make life a bit easier -- in particular in this situation where you can just use the same definition for the Alexander polynomial regardless of the chosen surface.

In any case, by "cylinder", I meant something homeomorphic to _S_<sup>1</sup> Ã— [0, 1] which has boundary two separated unknots, and which has non-trivial _H_<sub>1</sub>. In that case, a Seifert matrix is the 1x1 zero matrix. Likewise in the case of the unknot, you can avoid having to ponder about 0x0 matrices, since _H_<sub>1</sub>(_D_<sup>2</sup> Ã— *R*, *Z*) may be presented by the 1x1 unit matrix.

For the case at hand, the algorithm still produces incorrect results for links which bound disconnected oriented surfaces (I would not call such links "disjoint", since link components are _always_ disjoint);


```
sage: B3 = BraidGroup(3)
sage: b = B3([1, 2, -2])
sage: b.alexander_polynomial()
0
sage: Link(b).alexander_polynomial()
1
```


And a weirder example:


```
sage: B2 = BraidGroup(2)
sage: b = B2([1, -1])
sage: b.alexander_polynomial()
0
sage: Link(b).alexander_polynomial()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-14-c27fd62b3305> in <module>()
----> 1 Link(b).alexander_polynomial()

/home/fuglede/repos/sage/local/lib/python2.7/site-packages/sage/knots/link.pyc in alexander_polynomial(self, var)
   1244         R = LaurentPolynomialRing(ZZ, var)
   1245         # The Alexander polynomial of disjoint links are defined to be 0
-> 1246         if len(self._braid_word_components()) > 1:
   1247             return R.zero()
   1248         t = R.gen()

/home/fuglede/repos/sage/local/lib/python2.7/site-packages/sage/knots/link.pyc in _braid_word_components(self)
    899         ml = list(self.braid().Tietze())
    900         if not ml:
--> 901             raise ValueError("the braid remains the same with no components")
    902 
    903         l = set(abs(k) for k in ml)

ValueError: the braid remains the same with no components
```


Edit: Ah, it looks like for the first one of those examples, the library throws away one of the components (is that intended? According to the docs, only "The strands of the braid that have no crossings at all are removed", and in this case, all of them have crossings; they just happen to be pretty trivial).


---

Comment by tscrim created at 2016-03-22 14:35:37

Replying to [comment:170 fuglede]:
> Cool, that's also what I suspected back then. Where I come from, Seifert surfaces are connected by definition; that can make life a bit easier -- in particular in this situation where you can just use the same definition for the Alexander polynomial regardless of the chosen surface.

Yes, definitely.

> In any case, by "cylinder", I meant something homeomorphic to _S_<sup>1</sup> Ã— [0, 1] which has boundary two separated unknots, and which has non-trivial _H_<sub>1</sub>.

In that case, I agree. Although this doesn't agree with Seifert's construction AFAIK, and for 4+ components, at least by my understanding of how you are constructing things, wouldn't give a surface.

> In that case, a Seifert matrix is the 1x1 zero matrix. Likewise in the case of the unknot, you can avoid having to ponder about 0x0 matrices, since _H_<sub>1</sub>(_D_<sup>2</sup> Ã— *R*, *Z*) may be presented by the 1x1 unit matrix.
> 
> For the case at hand, the algorithm still produces incorrect results for links which bound disconnected oriented surfaces (I would not call such links "disjoint", since link components are _always_ disjoint);
> 
> {{{
> sage: B3 = BraidGroup(3)
> sage: b = B3([1, 2, -2])
> sage: b.alexander_polynomial()
> 0
> sage: Link(b).alexander_polynomial()
> 1
> }}}

In that case the `2 -2` are canceled automatically by the braid group:

```
sage: B = BraidGroup(4)
sage: B([1,2,-2])
s0
```

So it becomes just 1 unknot as far as the code currently works. Which is why we get an Alexander polynomial of 1.

> And a weirder example:
> 
> {{{
> sage: B2 = BraidGroup(2)
> sage: b = B2([1, -1])
> sage: b.alexander_polynomial()
> 0
> sage: Link(b).alexander_polynomial()
> ---------------------------------------------------------------------------
> ValueError                                Traceback (most recent call last)
> <ipython-input-14-c27fd62b3305> in <module>()
> ----> 1 Link(b).alexander_polynomial()
> 
> /home/fuglede/repos/sage/local/lib/python2.7/site-packages/sage/knots/link.pyc in alexander_polynomial(self, var)
>    1244         R = LaurentPolynomialRing(ZZ, var)
>    1245         # The Alexander polynomial of disjoint links are defined to be 0
> -> 1246         if len(self._braid_word_components()) > 1:
>    1247             return R.zero()
>    1248         t = R.gen()
> 
> /home/fuglede/repos/sage/local/lib/python2.7/site-packages/sage/knots/link.pyc in _braid_word_components(self)
>     899         ml = list(self.braid().Tietze())
>     900         if not ml:
> --> 901             raise ValueError("the braid remains the same with no components")
>     902 
>     903         l = set(abs(k) for k in ml)
> 
> ValueError: the braid remains the same with no components
> }}}
> 
> Edit: Ah, it looks like for the first one of those examples, the library throws away one of the components (is that intended? According to the docs, only "The strands of the braid that have no crossings at all are removed", and in this case, all of them have crossings; they just happen to be pretty trivial).

In both cases this is what is going on. Although we could special case the identity element of the braid group, but this wouldn't handle when the input is `B([3, 1, -3, -1])`. I'm somewhat unsure if we really should push this in as-is. I think it is a very good addition, but not dealing with these lingering braid group issues seems to cause confusion... I can try to fix things up a little bit to handle all of these issues, but I'm not sure I will be successful with out a substantial rewrite (which I am not sure I have the mathematical knowledge to do).


---

Comment by tscrim created at 2016-03-22 14:39:10

PS - I agree, "disjoint" is not a good word. Perhaps "separable" is a better? Also, maybe we use `_isolated_components` to check for the Alexander polynomial instead of my current approach?


---

Comment by fuglede created at 2016-03-22 16:43:02

Replying to [comment:171 tscrim]:
> In that case, I agree. Although this doesn't agree with Seifert's construction AFAIK, and for 4+ components, at least by my understanding of how you are constructing things, wouldn't give a surface.

I'm not really constructing anything at all, so I'm not quite sure what it is that would not be a surface.

> In that case the `2 -2` are canceled automatically by the braid group:
> {{{
> sage: B = BraidGroup(4)
> sage: B([1,2,-2])
> s0
> }}}

Yeah, that makes sense. Isn't it a bit unfortunate that one would need to understand the `BraidGroup` internals in order to use the knot theory module, though? If I just read the documentation in `Link`, then I might assume that `[1, -2, -2]` contains knots on all three strands (that's what I did anyway).

> PS - I agree, "disjoint" is not a good word. Perhaps "separable" is a better?

Yes, I believe I've heard "separable" being used in this context as well, although I can't seem to find a written source at the moment. The word of course already has another meaning in the context of topological spaces, but that's not really an issue. In any case, you could always just go with "bounds and oriented disconnected surface".


---

Comment by tscrim created at 2016-03-22 18:55:05

Replying to [comment:173 fuglede]:
> Replying to [comment:171 tscrim]:
> > In that case, I agree. Although this doesn't agree with Seifert's construction AFAIK, and for 4+ components, at least by my understanding of how you are constructing things, wouldn't give a surface.
> 
> I'm not really constructing anything at all, so I'm not quite sure what it is that would not be a surface.

I thought you were taking *S*<sup>1</sup> x *S*<sup>1</sup> and then connecting up points inbetween. Now that I actually drew something, you were taking the two unknots and drawing them projected into the plane with overlap, where I did get a cylinder.

> > In that case the `2 -2` are canceled automatically by the braid group:
> > {{{
> > sage: B = BraidGroup(4)
> > sage: B([1,2,-2])
> > s0
> > }}}
> 
> Yeah, that makes sense. Isn't it a bit unfortunate that one would need to understand the `BraidGroup` internals in order to use the knot theory module, though? If I just read the documentation in `Link`, then I might assume that `[1, -2, -2]` contains knots on all three strands (that's what I did anyway).

I agree. Do you think a warning with an example would be sufficient (if it's not possible to quickly fix) to clarify things?

> > PS - I agree, "disjoint" is not a good word. Perhaps "separable" is a better?
> 
> Yes, I believe I've heard "separable" being used in this context as well, although I can't seem to find a written source at the moment. The word of course already has another meaning in the context of topological spaces, but that's not really an issue. In any case, you could always just go with "bounds and oriented disconnected surface".

True.


---

Comment by mmarco created at 2016-03-23 17:46:30

I propose to use the word "unlinked components" for the case you are talking about: they bound a disconnected surface, or, equivalently, they could be represented in a planar diagram where there are no crossings that involve two different components.

I chosed the word _isolated_components to reffer to that situation: where the planar representation that we are dealing with has no crossings that involve different components.

I considered other names, like "unlinked components", but I didin't like them because the concept I wanted to consider does not deppend on the 3-dimensional topology, but on the particular planar representation that we are using. If two components are shown as "isolated" in a planar diagram (which is the case that is troubling us here), they are clearly unlinked. But the converse is not true: we could have a very complicated diagram with crossings everywhere that actually represents 2 unlinked knots.

The implementation of the alexander polynomial assumes that the input doesn't have isolated components (that is why we need to treat that case separatedly), but is able to give the right output if there are several unlinked components that are not isolated. So i guess that the solution of detecting that case and giving a 0 output is the right one.

_isolated_components and _braid_word_components should do pretty much the same. The difference is that one computes it from the PD representation whereas the other uses the braid one.

So, can we give a positive review or are there still pending issues?


---

Comment by git created at 2016-03-23 20:05:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-23 20:10:07

If you think my last set of changes are good, then yes, I believe we can. In this last commit, I added support for the unknot given as the identity element in the braid group. I also was able to fix the plotting of multiple isolated components (a `+` to a `-`) as far as I can tell.

`@`fuglede From your previous comments, I am assuming you are good overall with the current version. Is this correct? Also, could you add your real name to the reviewers field?


---

Comment by fuglede created at 2016-03-23 20:23:43

`@`tscrim Unless it is customary to do for the kind of small discussion we had here, I hesitate to do so: all I did here was really to try out the Jones and Alexander polynomial implementations (and I still barely understand the implementation of the latter), so that doesn't constitute much of a review. I wish I had time to devote to a full-fleshed review, but unfortunately that's far from the case.


---

Comment by tscrim created at 2016-03-23 22:01:26

You looked at and tested a part of the code. Furthermore, you also made some additions. You definitely qualify as a reviewer.


---

Comment by mmarco created at 2016-03-24 14:38:33

I agree fuglede should be considered a reviewer. Maybe even an author.

Travis, do you want to add yourself to the authors list?


---

Comment by mmarco created at 2016-03-24 14:38:33

Changing status from needs_review to positive_review.


---

Comment by kcrisman created at 2016-03-24 15:29:27

mmarco: Do you think that this combined effort suffices for positive review?  Just checking that whatever stuff hadn't been looked at before is now really ready for inclusion - it would be great to have knots in Sage but it would also be good to have as close to "all correct" as possible.  Great teamwork, everybody!


---

Comment by mmarco created at 2016-03-24 15:45:16

Well, I think it is about as close to "all correct" as we can get before merging it. I am pretty sure that the base code is mostly correct (although there might be other bugs that show up in corner cases) .Unless there is a short term plan to make a substantial improvement (like the idea you mentioned to gather some specialists to work on a SMC project intensively), I would prefear to merge something that might have bugs (and solve them later in subsequent tickets), than risking it to bitrot again.

Of course, you might disagree. In that case, feel free to revert to needs_review.


---

Comment by kcrisman created at 2016-03-24 16:54:30

No disagreement, just checking in.  In which case my plan for making a SMC project would be vastly simplified - I just make a SMC project with a _standard_ Sage and invite them to it!


---

Comment by jhpalmieri created at 2016-03-24 18:24:34

Changing status from positive_review to needs_review.


---

Comment by git created at 2016-03-24 18:25:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2016-03-24 18:27:51

I made a few small changes: added a little documentation and added some doctests for some previously untested parts of the code. We should probably add more doctests to get even better coverage â€“ for example, I couldn't figure out how to create links with several isolated components in order to test the error-raising in the `regions` method â€“ but we can do more clean-up on another ticket.


---

Comment by git created at 2016-03-24 18:28:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-24 18:31:25

I went through most of everything once I have the references to the algorithms. At this point, I do not have any plans to making any (significant) improvements. I also agree with the philosophy of get good, but maybe not perfect, code in and fix bugs as we come across them.

As a followup, we might want to consider adding in optional spkgs of those other knot/link projects listed on Collins' webpage (e.g., [BraidProgramme](http://www.layer8.co.uk/maths/braids/)).

John, your changes look good to me. You should be able create isolated components with something like this:

```
sage: B = BraidGroup(4)
sage: L = Link(B([1,3]))
```

There's also a more interesting example with two isolated trefoils in the `plot()` examples:

```
sage: L = Link([[[-1, 2, -3, 1, -2, 3], [4, -5, 6, -4, 5, -6]], [1, 1, 1, 1, 1, 1]])
```


`@`fudlege I got your name from your Github page; I hope that was okay. Thank you for working on this, and I hope you continue to contribute to Sage.


---

Comment by git created at 2016-03-24 18:47:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2016-03-25 15:35:19

Should we set this back to "positive review"? I don't plan to make any more changes.


---

Comment by tscrim created at 2016-03-25 15:37:49

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-03-27 07:44:33

Resolution: fixed


---

Comment by jhpalmieri created at 2016-03-28 22:55:38

See #20315 for a followup.


---

Comment by jhpalmieri created at 2016-03-29 01:51:15

Replying to [comment:193 jhpalmieri]:
> See #20315 for a followup.

In more detail, whoever is familiar with the plotting code should review the changes there.


---

Comment by slelievre created at 2018-03-28 13:28:03

Follow-up ticket at #25050: allow braid computation for more links.
