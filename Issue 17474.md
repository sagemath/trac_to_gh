# Issue 17474: Pre-processing for vertex separation

Issue created by migration from https://trac.sagemath.org/ticket/17711

Original creator: dcoudert

Original creation time: 2015-02-01 14:53:53

CC:  ncohen

This patch cleans the module `sage.graphs.graph_decompositions.vertex_separation` to expose the new branch and bound algorithm #17647 and other methods into the `vertex_separation` method, as for the `path_decomposition` method. It makes the branch and bound the default method since it is the fastest one. It also adds a generic pre-processing method based on the decomposition of the input digraph into strongly connected components.


---

Comment by git created at 2015-02-01 17:09:15

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dcoudert created at 2015-02-01 17:13:32

Changing status from new to needs_review.


---

Comment by dcoudert created at 2015-02-01 17:13:32

Unless I mixed up something with my commits, this patch is ready to be reviewed.


---

Comment by ncohen created at 2015-02-03 09:57:54

Changing status from needs_review to needs_info.


---

Comment by ncohen created at 2015-02-03 09:57:54

Yooooooooooooo !

Does the job, very few comments (and a small commit at `public/17711b`):


- Calling `is_strongly_connected` is very cheap while
  `g.strongly_connected_components_digraph` actually copies the whole graph


```
sage: g=digraphs.DeBruijn(5,3)
sage: %timeit g.is_strongly_connected()
10000 loops, best of 3: 129 µs per loop
sage: %timeit g.strongly_connected_components_digraph()
1000 loops, best of 3: 1.31 ms per loop
```


  Better to only copy it if necessary.

- Is there any reason why you only deal with digraphs ? `Digraph(G)` (when `G`
  is a graph) is not always strongly connected: `G` may not be connected. The
  same code could handle everything at once, couldn't it ?

- (unrelated) what on earth is this `random_DAG` function doing in the global
  namespace instead of being in `digraphs.<tab>` ? `O_O`

Nathann


---

Comment by dcoudert created at 2015-02-03 12:05:48

Replying to [comment:5 ncohen]:
> Yooooooooooooo !
> 
> Does the job, very few comments (and a small commit at `public/17711b`):
> 
> 
> - Calling `is_strongly_connected` is very cheap while
>   `g.strongly_connected_components_digraph` actually copies the whole graph
> 
> {{{
> sage: g=digraphs.DeBruijn(5,3)
> sage: %timeit g.is_strongly_connected()
> 10000 loops, best of 3: 129 µs per loop
> sage: %timeit g.strongly_connected_components_digraph()
> 1000 loops, best of 3: 1.31 ms per loop
> }}}
> 
>   Better to only copy it if necessary.
> 
> - Is there any reason why you only deal with digraphs ? `Digraph(G)` (when `G`
>   is a graph) is not always strongly connected: `G` may not be connected. The
>   same code could handle everything at once, couldn't it ?
So you propose that I
1. test if the graph is connected. If not, then apply the algorithm on each connected component. 
2. If G is directed, test if is strongly connected. If not, then apply the algorithm on each scc

Is that correct?

 
> - (unrelated) what on earth is this `random_DAG` function doing in the global
>   namespace instead of being in `digraphs.<tab>` ? `O_O`

I had the same remark while reviewing patch #12181 (and certainly other tickets). Nothing has been done since. I don't even know where is the code.
In fact, we have many random<TAB> stuff in global namespace...

David.


---

Comment by ncohen created at 2015-02-03 12:12:36

> So you propose that I
> 1. test if the graph is connected. If not, then apply the algorithm on each connected component. 
> 2. If G is directed, test if is strongly connected. If not, then apply the algorithm on each scc

I had something simpler (and a it more ressource-consuming) in mind:
1) If you have a graph, test if it is connected. If it is not, turn it into a digraph
2) Now the scc code for digraphs will handle each connected component independently

So you get it for free, more or less.

> I had the same remark while reviewing patch #12181 (and certainly other tickets). Nothing has been done since. I don't even know where is the code.
> In fact, we have many random<TAB> stuff in global namespace...

Pffff.. It comes from the "sandpile" module and I am not even sure that any of that code is useful to anything.

Plus I am not very eager to move 'random_DAG' to `digraphs.<tab>` because I do not agree with the way it generates the random dag. Also, some random 'weights' are involved.

I will probably end up removing the imports into the global namespace, and that will be all.

I'll cc you if I do.

Nathann


---

Comment by dcoudert created at 2015-02-03 13:46:44

New commits:


---

Comment by git created at 2015-02-03 13:54:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2015-02-03 13:56:24

Changing status from needs_info to needs_review.


---

Comment by dcoudert created at 2015-02-03 13:56:24

I have implemented an alternative approach preventing conversion Graph to DiGraph.
I hope you will like it.

David.


---

Comment by git created at 2015-02-03 14:51:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2015-02-03 14:52:37

Sorry, I erased some of your modifications in my last commit. This is corrected.


---

Comment by ncohen created at 2015-02-03 19:32:54

Changing status from needs_review to positive_review.


---

Comment by ncohen created at 2015-02-03 19:32:54

> I have implemented an alternative approach preventing conversion Graph to DiGraph.
> I hope you will like it.

Perfect!

Thanks,

Nathann


---

Comment by dcoudert created at 2015-02-04 00:15:04

Thanks.


---

Comment by vbraun created at 2015-02-18 23:22:44

Resolution: fixed
