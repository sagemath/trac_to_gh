# Issue 22648: LatticePoset: test if lattice is constructible by doublings

archive/issues_022411.json:
```json
{
    "body": "Add functions to test if a lattice is constructible from the one-element lattice with Day doubling of 1) interval, 2) lower pseudo-interval, 3) upper pseudo-interval and 4) any convex subset.\n\n\nCC:  @fchapoton @tscrim\n\nBranch/Commit: 9974715d4de393b776eaefdc8f33113224a888cd\n\nReviewer: Martin Rubey\n\nAuthor: Jori M\u00e4ntysalo\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/22648\n\n",
    "closed_at": "2017-04-03T21:00:02Z",
    "created_at": "2017-03-19T20:28:07Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "LatticePoset: test if lattice is constructible by doublings",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22648",
    "user": "https://github.com/jm58660"
}
```
Add functions to test if a lattice is constructible from the one-element lattice with Day doubling of 1) interval, 2) lower pseudo-interval, 3) upper pseudo-interval and 4) any convex subset.


CC:  @fchapoton @tscrim

Branch/Commit: 9974715d4de393b776eaefdc8f33113224a888cd

Reviewer: Martin Rubey

Author: Jori MÃ¤ntysalo

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/22648





---

archive/issue_comments_332330.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2017-03-19T20:33:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332330",
    "user": "https://github.com/jm58660"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_332331.json:
```json
{
    "body": "<a id='comment:1'></a>What should be the names for these functions?\n\n4 is called *congruence normal*, 2 and 3 as *lower bounded* and *upper bounded* and 1 as *bounded*. But we can't add `is_bounded()` with different meaning to lattices that we already have for posets.\n\n(See for example http://www.math.hawaii.edu/~jb/inflation.pdf.)",
    "created_at": "2017-03-19T20:33:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332331",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:1'></a>What should be the names for these functions?

4 is called *congruence normal*, 2 and 3 as *lower bounded* and *upper bounded* and 1 as *bounded*. But we can't add `is_bounded()` with different meaning to lattices that we already have for posets.

(See for example http://www.math.hawaii.edu/~jb/inflation.pdf.)



---

archive/issue_comments_332332.json:
```json
{
    "body": "<a id='comment:2'></a>How about `is_interval_doubling()`?",
    "created_at": "2017-03-20T08:49:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332332",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>How about `is_interval_doubling()`?



---

archive/issue_comments_332333.json:
```json
{
    "body": "<a id='comment:3'></a>Replying to [comment:2 tscrim]:\n> How about `is_interval_doubling()`?\n\n\nFor case 1 only? Could be, got to think about this.\n\nWe now have `is_orthocomplemented()` (by me) with optional parameter `unique`. What you think about that, and having something like `is_doubling_constructable()` with mandratory string parameter having possible values `'convex', 'intevar'` etc?",
    "created_at": "2017-03-20T09:06:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332333",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:3'></a>Replying to [comment:2 tscrim]:
> How about `is_interval_doubling()`?


For case 1 only? Could be, got to think about this.

We now have `is_orthocomplemented()` (by me) with optional parameter `unique`. What you think about that, and having something like `is_doubling_constructable()` with mandratory string parameter having possible values `'convex', 'intevar'` etc?



---

archive/issue_comments_332334.json:
```json
{
    "body": "<a id='comment:4'></a>Some people (at least McConville https://arxiv.org/abs/1504.05213) use `congruence_uniform` instead of bounded, I think:\n\n5.2 Congruence-normal and congruence-uniform lattices\n\nA finite lattice L is congruence-normal if there exists a\nsequence of lattices L_1,..., L_l such that L_1 is the one-element lattice, L_l = L, and for\nall i, there exists an order convex subset C_i of L_i such that L_{i+1} = L_i[Ci].\n\nA lattice is congruence-uniform if it is both congruence-normal and semidistributive.",
    "created_at": "2017-03-20T11:59:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332334",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:4'></a>Some people (at least McConville https://arxiv.org/abs/1504.05213) use `congruence_uniform` instead of bounded, I think:

5.2 Congruence-normal and congruence-uniform lattices

A finite lattice L is congruence-normal if there exists a
sequence of lattices L_1,..., L_l such that L_1 is the one-element lattice, L_l = L, and for
all i, there exists an order convex subset C_i of L_i such that L_{i+1} = L_i[Ci].

A lattice is congruence-uniform if it is both congruence-normal and semidistributive.



---

archive/issue_comments_332335.json:
```json
{
    "body": "<a id='comment:6'></a>Replying to [comment:4 mantepse]:\n> Some people (at least McConville https://arxiv.org/abs/1504.05213) use `congruence_uniform` instead of bounded, I think:\n\n\nDuh. We already have `is_uniform` after #21861.\n\n> A finite lattice L is congruence-normal if there exists a\n> sequence of lattices L_1,..., L_l such that L_1 is the one-element lattice, L_l = L, and for\n> all i, there exists an order convex subset C_i of L_i such that L_{i+1} = L_i[Ci].\n> \n> A lattice is congruence-uniform if it is both congruence-normal and semidistributive.\n\n\nPage 3 says this more directly \"congruence-uniform lattice is any lattice constructable by a sequence of interval doubings.\"",
    "created_at": "2017-03-20T12:10:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332335",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:6'></a>Replying to [comment:4 mantepse]:
> Some people (at least McConville https://arxiv.org/abs/1504.05213) use `congruence_uniform` instead of bounded, I think:


Duh. We already have `is_uniform` after #21861.

> A finite lattice L is congruence-normal if there exists a
> sequence of lattices L_1,..., L_l such that L_1 is the one-element lattice, L_l = L, and for
> all i, there exists an order convex subset C_i of L_i such that L_{i+1} = L_i[Ci].
> 
> A lattice is congruence-uniform if it is both congruence-normal and semidistributive.


Page 3 says this more directly "congruence-uniform lattice is any lattice constructable by a sequence of interval doubings."



---

archive/issue_comments_332336.json:
```json
{
    "body": "<a id='comment:7'></a>In case it's possible, it would be great if the code could also produce a certificate.\n\nFor myself personally, what would be wonderful is a function that takes a lattice and produces all intervals that can be collapsed.  (I assume that, no matter which intervall is collapsed, the result should again be congruence uniform, if the original was.  But I admit that I do not know.)",
    "created_at": "2017-03-20T13:00:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332336",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:7'></a>In case it's possible, it would be great if the code could also produce a certificate.

For myself personally, what would be wonderful is a function that takes a lattice and produces all intervals that can be collapsed.  (I assume that, no matter which intervall is collapsed, the result should again be congruence uniform, if the original was.  But I admit that I do not know.)



---

archive/issue_events_059055.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2017-03-20T13:07:41Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "milestone": "sage-wishlist",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22648#event-59055"
}
```



---

archive/issue_comments_332337.json:
```json
{
    "body": "<a id='comment:8'></a>Certificate should be possible.\n\nFirst see a term 'inflation' in http://www.math.hawaii.edu/~jb/inflation.pdf and also figure 3 at page 8. Maybe doubling construction should be expanded to municipal subsets?\n\nFor decomposing see https://hal.archives-ouvertes.fr/hal-01282151/document.\n\nBut I can't be sure when I will look at this, and so I mark this as wishlist queue.",
    "created_at": "2017-03-20T13:07:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332337",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:8'></a>Certificate should be possible.

First see a term 'inflation' in http://www.math.hawaii.edu/~jb/inflation.pdf and also figure 3 at page 8. Maybe doubling construction should be expanded to municipal subsets?

For decomposing see https://hal.archives-ouvertes.fr/hal-01282151/document.

But I can't be sure when I will look at this, and so I mark this as wishlist queue.



---

archive/issue_comments_332338.json:
```json
{
    "body": "<a id='comment:9'></a>Replying to [comment:7 mantepse]:\n\n> For myself personally, what would be wonderful is a function that takes a lattice and produces all intervals that can be collapsed.\n\n\nI think it should be something like this:\n\n```\ndef antidouble(self):\n    ji = self.join_irreducibles()\n    mi = self.meet_irreducibles()\n\n    h = {}\n    i = 0\n    for l in self.level_sets():\n        for e in l:\n            h[e] = i\n        i += 1\n\n    for a in ji:\n        a_ = self.lower_covers(a)[0]\n        for b in mi:\n            if self.compare_elements(a, b) is not None:\n                continue\n            b_ = self.upper_covers(b)[0]\n            if h[b]-h[a_] == h[b_]-h[a]:\n                A = self.interval(a_, b)\n                B = self.interval(a, b_)\n                if len(A) == len(B):\n                    if self.subposet(A).is_isomorphic(self.subposet(B)):\n                        if LatticePoset(self.subposet([e for e in self if e not in B])).day_doubling(A).is_isomorphic(self):\n                            print((a_, b), (a, b_))\n```\n\nbut of course is much faster to work directly with Hasse Diagram. Having temporary posets is bad, as they eat memory that is not released until you restart the whole worksheet.",
    "created_at": "2017-03-21T05:15:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332338",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:9'></a>Replying to [comment:7 mantepse]:

> For myself personally, what would be wonderful is a function that takes a lattice and produces all intervals that can be collapsed.


I think it should be something like this:

```
def antidouble(self):
    ji = self.join_irreducibles()
    mi = self.meet_irreducibles()

    h = {}
    i = 0
    for l in self.level_sets():
        for e in l:
            h[e] = i
        i += 1

    for a in ji:
        a_ = self.lower_covers(a)[0]
        for b in mi:
            if self.compare_elements(a, b) is not None:
                continue
            b_ = self.upper_covers(b)[0]
            if h[b]-h[a_] == h[b_]-h[a]:
                A = self.interval(a_, b)
                B = self.interval(a, b_)
                if len(A) == len(B):
                    if self.subposet(A).is_isomorphic(self.subposet(B)):
                        if LatticePoset(self.subposet([e for e in self if e not in B])).day_doubling(A).is_isomorphic(self):
                            print((a_, b), (a, b_))
```

but of course is much faster to work directly with Hasse Diagram. Having temporary posets is bad, as they eat memory that is not released until you restart the whole worksheet.



---

archive/issue_comments_332339.json:
```json
{
    "body": "<a id='comment:10'></a>Wow!  Thank you!\n\nThere must be a small bug however, because\n\n```\nantidouble(posets.PentagonPoset())\n```\nshould print a collapsible interval (the middle relation in the longer chain), but doesn't.\n\nIn case I find out, I'll let you know!",
    "created_at": "2017-03-21T09:57:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332339",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:10'></a>Wow!  Thank you!

There must be a small bug however, because

```
antidouble(posets.PentagonPoset())
```
should print a collapsible interval (the middle relation in the longer chain), but doesn't.

In case I find out, I'll let you know!



---

archive/issue_comments_332340.json:
```json
{
    "body": "<a id='comment:11'></a>True, but I think they are just the double irreducible elements that are not seen by this code.\n\nAnyway, I guess I should extend `Posets.RandomLattice` to get some test material.",
    "created_at": "2017-03-21T11:32:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332340",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:11'></a>True, but I think they are just the double irreducible elements that are not seen by this code.

Anyway, I guess I should extend `Posets.RandomLattice` to get some test material.



---

archive/issue_comments_332341.json:
```json
{
    "body": "<a id='comment:12'></a>Random code could be like\n\n```\ndef random_bounded(n, p):\n    \"\"\"\n    Return a random \"bounded\" lattice.\n    \n    I.e. a lattice that can be made from the one-element lattice\n    by doubling an interval.\n    \"\"\"\n    if n < 4:\n        return Posets.ChainPoset(n)\n\n    g = digraphs.Path(2)\n    g = Posets.PentagonPoset().hasse_diagram()\n    n = n - 2\n\n    while n:\n        a = g.random_vertex()\n        a_up = list(g.depth_first_search(a))\n        b = a_up[randint(0, ceil(len(a_up)*p*random())-1)]\n        b_down = list(g.depth_first_search(b, neighbors=g.neighbors_in))\n        S = [x for x in a_up if x in b_down]\n        if n-len(S) < 0 or len(S) == 0:\n            continue  # New try...\n        g_S = g.subgraph(S)\n        g_S.relabel(lambda x: (1, x))\n        g = g.union(g_S)\n        for e in g.neighbor_out_iterator(b):\n            g.delete_edge(b, e)\n            g.add_edge((1, b), e)\n        for e in S:\n            g.add_edge(e, (1, e))\n        g.relabel()\n        n -= len(S)\n\n    return LatticePoset(g)\n```\n\nto test try for example\n\n```\nset_random_seed(0)\nrandom_bounded(15, 1).show()\n```",
    "created_at": "2017-03-21T12:15:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332341",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:12'></a>Random code could be like

```
def random_bounded(n, p):
    """
    Return a random "bounded" lattice.
    
    I.e. a lattice that can be made from the one-element lattice
    by doubling an interval.
    """
    if n < 4:
        return Posets.ChainPoset(n)

    g = digraphs.Path(2)
    g = Posets.PentagonPoset().hasse_diagram()
    n = n - 2

    while n:
        a = g.random_vertex()
        a_up = list(g.depth_first_search(a))
        b = a_up[randint(0, ceil(len(a_up)*p*random())-1)]
        b_down = list(g.depth_first_search(b, neighbors=g.neighbors_in))
        S = [x for x in a_up if x in b_down]
        if n-len(S) < 0 or len(S) == 0:
            continue  # New try...
        g_S = g.subgraph(S)
        g_S.relabel(lambda x: (1, x))
        g = g.union(g_S)
        for e in g.neighbor_out_iterator(b):
            g.delete_edge(b, e)
            g.add_edge((1, b), e)
        for e in S:
            g.add_edge(e, (1, e))
        g.relabel()
        n -= len(S)

    return LatticePoset(g)
```

to test try for example

```
set_random_seed(0)
random_bounded(15, 1).show()
```



---

archive/issue_comments_332342.json:
```json
{
    "body": "<a id='comment:13'></a>This needs more reading and thinking.\n\nBut a question: If we have a decomposition -- as `certificate` or as a specific function -- what should be the output type? Some kind of tuple or list, I guess.",
    "created_at": "2017-03-22T05:21:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332342",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:13'></a>This needs more reading and thinking.

But a question: If we have a decomposition -- as `certificate` or as a specific function -- what should be the output type? Some kind of tuple or list, I guess.



---

archive/issue_comments_332343.json:
```json
{
    "body": "<a id='comment:14'></a>More about this. *Free Lattices* by Ralph S. Freese, Jaroslav Je\u017eek and James Bryant Nation p. 76 says that a lattice `L` is lower bounded iff `|Ji(L)| = |Ji(Con L)|`, and of course dually for upper bounded. The congurence lattice of a lattice is always distributive. A distributive lattice L has `|Ji(L)| = |Mi(L)|`. Hence a lattice `L` can be (totally) bounded only if it has `|Ji(L)| = |Mi(L)|`. That can be used as a fast check to reject lattices that clearly can't be (totallyt) bounded.\n\nAnd of course `Posets.DiamondPoset(5)` shows that the last \"if\" is not \"iff\".\n\nBut I must continue to think and code. For me they are almost the same thing.",
    "created_at": "2017-03-25T07:00:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332343",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:14'></a>More about this. *Free Lattices* by Ralph S. Freese, Jaroslav JeÅ¾ek and James Bryant Nation p. 76 says that a lattice `L` is lower bounded iff `|Ji(L)| = |Ji(Con L)|`, and of course dually for upper bounded. The congurence lattice of a lattice is always distributive. A distributive lattice L has `|Ji(L)| = |Mi(L)|`. Hence a lattice `L` can be (totally) bounded only if it has `|Ji(L)| = |Mi(L)|`. That can be used as a fast check to reject lattices that clearly can't be (totallyt) bounded.

And of course `Posets.DiamondPoset(5)` shows that the last "if" is not "iff".

But I must continue to think and code. For me they are almost the same thing.



---

archive/issue_comments_332344.json:
```json
{
    "body": "<a id='comment:15'></a>New try, kind of proof-of-concept:\n\n```\ndef antidouble(L):\n    H = L._hasse_diagram\n    at = H.atoms_of_congruence_lattice()\n    for cong in at:\n        if all(len(p) <= 2 for p in cong):\n            tmp = [p for p in cong if len(p) == 2]\n            tmp1 = [min(p) for p in tmp]\n            tmp2 = [max(p) for p in tmp]\n            LatticePoset(L.subposet([L._vertex_to_element(e) for e in H if e not in tmp2])).show()\n            print([L._vertex_to_element(e) for e in tmp1])\n            break\n    else:\n        print(\"Nothing to double.\")\n```",
    "created_at": "2017-03-26T18:53:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332344",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:15'></a>New try, kind of proof-of-concept:

```
def antidouble(L):
    H = L._hasse_diagram
    at = H.atoms_of_congruence_lattice()
    for cong in at:
        if all(len(p) <= 2 for p in cong):
            tmp = [p for p in cong if len(p) == 2]
            tmp1 = [min(p) for p in tmp]
            tmp2 = [max(p) for p in tmp]
            LatticePoset(L.subposet([L._vertex_to_element(e) for e in H if e not in tmp2])).show()
            print([L._vertex_to_element(e) for e in tmp1])
            break
    else:
        print("Nothing to double.")
```



---

archive/issue_comments_332345.json:
```json
{
    "body": "<a id='comment:17'></a>OK, I started working with this. I think it is easier to proceed with smaller parts, and so put this on needs_review. The code is trivial, so the main question is about the design.\n\n---\nNew commits:",
    "created_at": "2017-03-27T08:13:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332345",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:17'></a>OK, I started working with this. I think it is easier to proceed with smaller parts, and so put this on needs_review. The code is trivial, so the main question is about the design.

---
New commits:



---

archive/issue_comments_332346.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2017-03-27T08:13:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332346",
    "user": "https://github.com/jm58660"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_events_059056.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2017-03-27T08:13:54Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "milestone": "sage-wishlist",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22648#event-59056"
}
```



---

archive/issue_events_059057.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2017-03-27T08:13:54Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "milestone": "sage-8.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22648#event-59057"
}
```



---

archive/issue_comments_332347.json:
```json
{
    "body": "<a id='comment:18'></a>Currently compiling...\n\nIn any case, I'd prefer `is_constructible_by_doublings` over `is_doubling_constructible`.  I am somewhat surprised that the test is now so simple.",
    "created_at": "2017-03-27T08:40:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332347",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:18'></a>Currently compiling...

In any case, I'd prefer `is_constructible_by_doublings` over `is_doubling_constructible`.  I am somewhat surprised that the test is now so simple.



---

archive/issue_comments_332348.json:
```json
{
    "body": "<a id='comment:19'></a>Another minor thing is that you should include something like the following in the docstring:\n\n  A lattice L is lower bounded if and only if |Ji(L)| = |Ji(Con L)|, dually for upper bounded, see Free Lattices by Ralph S. Freese, Jaroslav Je\u017eek and James Bryant Nation p. 76.\n\n  Note that a congruence lattice of a lattice is always distributive, and a distributive lattice L has |Ji(L)| = |Mi(L)|.  Hence a lattice L can be totally)bounded only if it has |Ji(L)| = |Mi(L)|.\n\n\nI'd like to ask you to also include a reference to the term *congruence uniform* (eg. McConville).",
    "created_at": "2017-03-27T09:13:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332348",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:19'></a>Another minor thing is that you should include something like the following in the docstring:

  A lattice L is lower bounded if and only if |Ji(L)| = |Ji(Con L)|, dually for upper bounded, see Free Lattices by Ralph S. Freese, Jaroslav JeÅ¾ek and James Bryant Nation p. 76.

  Note that a congruence lattice of a lattice is always distributive, and a distributive lattice L has |Ji(L)| = |Mi(L)|.  Hence a lattice L can be totally)bounded only if it has |Ji(L)| = |Mi(L)|.


I'd like to ask you to also include a reference to the term *congruence uniform* (eg. McConville).



---

archive/issue_comments_332349.json:
```json
{
    "body": "<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-27T09:55:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332349",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_332350.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-03-27T10:01:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332350",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_332351.json:
```json
{
    "body": "<a id='comment:22'></a>Replying to [comment:19 mantepse]:\n\nI changed the name and add a reference. I think that\n\n> Another minor thing is that you should include something like the following in the docstring:\n> \n>   Note that a congruence lattice of a lattice is always distributive, and a distributive lattice L has |Ji(L)| = |Mi(L)|.  Hence a lattice L can be totally)bounded only if it has |Ji(L)| = |Mi(L)|.\n\n\nis not needed to say, as we don't rely on it. This only uses Python's short-circuit evaluation of `a==b==c` as an optimization.\n\n> I'd like to ask you to also include a reference to the term *congruence uniform* (eg. McConville).\n\n\nI don't think it is necessary.\n\n> I am somewhat surprised that the test is now so simple.\n\n\nI think it comes from \"de-doubling\" algorithm quite naturally. Every interval doubling adds exactly one meet- and one join-irreducible element, i.e. the upper cover of bottom of the set to double and the top of the set to double. On the other direction if `|Ji(Con L)|` equals to `|Ji(L)|`, then every principal congruence must correspond to one of those \"de-doubling\" congruence.",
    "created_at": "2017-03-27T10:12:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332351",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:22'></a>Replying to [comment:19 mantepse]:

I changed the name and add a reference. I think that

> Another minor thing is that you should include something like the following in the docstring:
> 
>   Note that a congruence lattice of a lattice is always distributive, and a distributive lattice L has |Ji(L)| = |Mi(L)|.  Hence a lattice L can be totally)bounded only if it has |Ji(L)| = |Mi(L)|.


is not needed to say, as we don't rely on it. This only uses Python's short-circuit evaluation of `a==b==c` as an optimization.

> I'd like to ask you to also include a reference to the term *congruence uniform* (eg. McConville).


I don't think it is necessary.

> I am somewhat surprised that the test is now so simple.


I think it comes from "de-doubling" algorithm quite naturally. Every interval doubling adds exactly one meet- and one join-irreducible element, i.e. the upper cover of bottom of the set to double and the top of the set to double. On the other direction if `|Ji(Con L)|` equals to `|Ji(L)|`, then every principal congruence must correspond to one of those "de-doubling" congruence.



---

archive/issue_comments_332352.json:
```json
{
    "body": "<a id='comment:23'></a>Looks good!  The sequence\n\n```\n[len([1 for L in posets(r) if L.with_bounds().is_lattice() and LatticePoset(L.with_bounds()).is_constructible_by_doublings('interval')]) for r in range(1,8)]\n[1,2,4,9,22,60,174]\n```\nis not in the OEIS...",
    "created_at": "2017-03-27T12:02:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332352",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:23'></a>Looks good!  The sequence

```
[len([1 for L in posets(r) if L.with_bounds().is_lattice() and LatticePoset(L.with_bounds()).is_constructible_by_doublings('interval')]) for r in range(1,8)]
[1,2,4,9,22,60,174]
```
is not in the OEIS...



---

archive/issue_comments_332353.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-03-27T12:02:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332353",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_332354.json:
```json
{
    "body": "<a id='comment:25'></a>Replying to [comment:23 mantepse]:\n> Looks good!  The sequence\n> \n> ```\n> [len([1 for L in posets(r) if L.with_bounds().is_lattice() and LatticePoset(L.with_bounds()).is_constructible_by_doublings('interval')]) for r in range(1,8)]\n> [1,2,4,9,22,60,174]\n> ```\n> is not in the OEIS...\n\n\nThanks for the review.\n\nOEIS is missing most of series related to lattice enumeration. I have added some, see for example https://oeis.org/A261994. Here is code if you want to add more:\n\n```\nN = 8\nLL = []\nfor i in range(N-2):\n    x = []\n    for P in Posets(i):\n        try:\n            x.append(LatticePoset(P.with_bounds()))\n        except ValueError:\n            pass\n    LL.append(x)\n\nfunctions = ['is_planar', 'is_upper_semimodular']\n\nfor f in functions:\n    print(f)\n    for i in range(2, N):\n        print(i, len([L for L in LL[i-2] if attrcall(f)(L)]))\n```",
    "created_at": "2017-03-27T12:19:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332354",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:25'></a>Replying to [comment:23 mantepse]:
> Looks good!  The sequence
> 
> ```
> [len([1 for L in posets(r) if L.with_bounds().is_lattice() and LatticePoset(L.with_bounds()).is_constructible_by_doublings('interval')]) for r in range(1,8)]
> [1,2,4,9,22,60,174]
> ```
> is not in the OEIS...


Thanks for the review.

OEIS is missing most of series related to lattice enumeration. I have added some, see for example https://oeis.org/A261994. Here is code if you want to add more:

```
N = 8
LL = []
for i in range(N-2):
    x = []
    for P in Posets(i):
        try:
            x.append(LatticePoset(P.with_bounds()))
        except ValueError:
            pass
    LL.append(x)

functions = ['is_planar', 'is_upper_semimodular']

for f in functions:
    print(f)
    for i in range(2, N):
        print(i, len([L for L in LL[i-2] if attrcall(f)(L)]))
```



---

archive/issue_comments_332355.json:
```json
{
    "body": "<a id='comment:26'></a>Side question: is it clear (or false) that the number of doublings of intervals to construct a lattice is independent of the particular doublings chosen?",
    "created_at": "2017-03-27T15:22:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332355",
    "user": "https://github.com/mantepse"
}
```

<a id='comment:26'></a>Side question: is it clear (or false) that the number of doublings of intervals to construct a lattice is independent of the particular doublings chosen?



---

archive/issue_comments_332356.json:
```json
{
    "body": "<a id='comment:27'></a>Replying to [comment:26 mantepse]:\n> Side question: is it clear (or false) that the number of doublings of intervals to construct a lattice is independent of the particular doublings chosen?\n\n\nI think so, and even more has been said in some paper: If `S` and `T` are convex subsets so that their union is convex non-connected subset, then `L[S][T]` and `L[T][S]` are isomorphic.",
    "created_at": "2017-03-27T16:34:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332356",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:27'></a>Replying to [comment:26 mantepse]:
> Side question: is it clear (or false) that the number of doublings of intervals to construct a lattice is independent of the particular doublings chosen?


I think so, and even more has been said in some paper: If `S` and `T` are convex subsets so that their union is convex non-connected subset, then `L[S][T]` and `L[T][S]` are isomorphic.



---

archive/issue_comments_332357.json:
```json
{
    "body": "<a id='comment:28'></a>*cough*authorname*cough*",
    "created_at": "2017-03-27T22:09:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332357",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:28'></a>*cough*authorname*cough*



---

archive/issue_comments_332358.json:
```json
{
    "body": "<a id='comment:29'></a>Replying to [comment:28 tscrim]:\n> *cough*authorname*cough*\n\n\nDuh. Added.\n\nBtw, this can be optimized much more. First, we don't need to count all `Ji(Con L)`, as if we found `a, b \\in Ji(L)` such that `Cong(a, a_) == Cong(b, b_)`, where `e_` is the only element covered by `e`, we can't have `|Ji(Con L)|` as big as `|Ji(L)|`.\n\nNext, a congruence generated by \"antidoubling\" can only have blocks of one or two element. Hence we can stop when we found even one `e` such that `Cong(e, e_)` has at least one congruence block of three or more elements.",
    "created_at": "2017-03-28T03:25:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332358",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:29'></a>Replying to [comment:28 tscrim]:
> *cough*authorname*cough*


Duh. Added.

Btw, this can be optimized much more. First, we don't need to count all `Ji(Con L)`, as if we found `a, b \in Ji(L)` such that `Cong(a, a_) == Cong(b, b_)`, where `e_` is the only element covered by `e`, we can't have `|Ji(Con L)|` as big as `|Ji(L)|`.

Next, a congruence generated by "antidoubling" can only have blocks of one or two element. Hence we can stop when we found even one `e` such that `Cong(e, e_)` has at least one congruence block of three or more elements.



---

archive/issue_comments_332359.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-04-03T21:00:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22648#issuecomment-332359",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_059058.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-04-03T21:00:02Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/22648",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22648#event-59058"
}
```
