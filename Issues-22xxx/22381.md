# Issue 22381: Bugs in how ClusterQuiver handles coefficients

archive/issues_022144.json:
```json
{
    "body": "The code performing mutations on `ClusterQuiver` does not handle properly\ncoefficients. In particular this introduces arrows in between frozen vertices\nyielding issues when computing mutation classes.\nHere is the smallest example I could come up with.\n\n```\nsage: B = matrix(3,[0,1,-1]); B\n[ 0]\n[ 1]\n[-1]\nsage: Q = ClusterQuiver(B)\nsage: list(Q.mutation_class())\nTraceback (most recent call last):\n...\nValueError: The input digraph contains edges within the frozen vertices\n```\n\nThe problem is that, rather than performing matrix mutations the code calls an\nhelper function performing digraph mutations. I do not see the rationale behind\nthis. Not only it is slower than the simple matrix operations needed to perform\nmutations on matrices but it is also giving issues.\n\nHere is another similar issue:\n\n```\nsage: B = matrix(3,[0,1,-1]); B\n[ 0]\n[ 1]\n[-1]\nsage: Q = ClusterQuiver(B)\nsage: Q.mutate(0)\nsage: Q.b_matrix()\t# this gives the expected output\n[ 0]\n[-1]\n[ 1]\nsage: Q.show()\t\t# this output is wrong!!!\n```\n\nNote that consistency tests (which in theory should not be needed and which\ncontribute to the overall slowdown) are performed in `__init__` only when\ncreating a `ClusterQuiver` from a digraph.\n\nFinally coefficients also force wrong answers from the algorithm computing\nmutations classes:\n\n```\nsage: B = Matrix([[0,1,0],[-1,0,1],[0,-1,0],[0,1,0],[0,1,-1],[0,-1,0]])\nsage: Q = ClusterQuiver(B)\nsage: Q.mutation_class()\nTraceback (most recent call last):\n...\nValueError: The mutation class can - for infinite mutation types - only be computed up to a given depth\n```\n\n\nCC:  gmoose05 stumpc5 drupel vpilaud @slel\n\nKeywords: ClusterSeed, mutations, cluster\n\nStopgaps: #22464\n\nAuthor: Fr\u00e9d\u00e9ric Chapoton\n\nBranch: public/22381\n\nStatus: needs_work\n\nDependencies: #24924\n\nCommit: c719703f400e7076e5b3d9489a56cfdf2ebc53dd\n\nIssue created by migration from https://trac.sagemath.org/ticket/22381\n\n",
    "created_at": "2017-02-14T11:15:40Z",
    "labels": [
        "component: combinatorics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.2",
    "title": "Bugs in how ClusterQuiver handles coefficients",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22381",
    "user": "https://github.com/etn40ff"
}
```
The code performing mutations on `ClusterQuiver` does not handle properly
coefficients. In particular this introduces arrows in between frozen vertices
yielding issues when computing mutation classes.
Here is the smallest example I could come up with.

```
sage: B = matrix(3,[0,1,-1]); B
[ 0]
[ 1]
[-1]
sage: Q = ClusterQuiver(B)
sage: list(Q.mutation_class())
Traceback (most recent call last):
...
ValueError: The input digraph contains edges within the frozen vertices
```

The problem is that, rather than performing matrix mutations the code calls an
helper function performing digraph mutations. I do not see the rationale behind
this. Not only it is slower than the simple matrix operations needed to perform
mutations on matrices but it is also giving issues.

Here is another similar issue:

```
sage: B = matrix(3,[0,1,-1]); B
[ 0]
[ 1]
[-1]
sage: Q = ClusterQuiver(B)
sage: Q.mutate(0)
sage: Q.b_matrix()	# this gives the expected output
[ 0]
[-1]
[ 1]
sage: Q.show()		# this output is wrong!!!
```

Note that consistency tests (which in theory should not be needed and which
contribute to the overall slowdown) are performed in `__init__` only when
creating a `ClusterQuiver` from a digraph.

Finally coefficients also force wrong answers from the algorithm computing
mutations classes:

```
sage: B = Matrix([[0,1,0],[-1,0,1],[0,-1,0],[0,1,0],[0,1,-1],[0,-1,0]])
sage: Q = ClusterQuiver(B)
sage: Q.mutation_class()
Traceback (most recent call last):
...
ValueError: The mutation class can - for infinite mutation types - only be computed up to a given depth
```


CC:  gmoose05 stumpc5 drupel vpilaud @slel

Keywords: ClusterSeed, mutations, cluster

Stopgaps: #22464

Author: Frédéric Chapoton

Branch: public/22381

Status: needs_work

Dependencies: #24924

Commit: c719703f400e7076e5b3d9489a56cfdf2ebc53dd

Issue created by migration from https://trac.sagemath.org/ticket/22381





---

archive/issue_comments_327331.json:
```json
{
    "body": "<a id='comment:1'></a>Actually a better example for the third issue:\n\n```\nsage: B = Matrix([[0,1,0],[-1,0,1],[0,-1,0],[2,0,0]])\nsage: Q = ClusterQuiver(B)\nsage: Q.is_mutation_finite()\nFalse\n```",
    "created_at": "2017-02-14T13:24:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327331",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:1'></a>Actually a better example for the third issue:

```
sage: B = Matrix([[0,1,0],[-1,0,1],[0,-1,0],[2,0,0]])
sage: Q = ClusterQuiver(B)
sage: Q.is_mutation_finite()
False
```



---

archive/issue_comments_327332.json:
```json
{
    "body": "<a id='comment:2'></a>New commits:",
    "created_at": "2017-02-27T17:42:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327332",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:2'></a>New commits:



---

archive/issue_comments_327333.json:
```json
{
    "body": "<a id='comment:6'></a>New commits:",
    "created_at": "2018-02-26T12:55:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327333",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:6'></a>New commits:



---

archive/issue_comments_327334.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-02-26T12:55:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327334",
    "user": "https://github.com/fchapoton"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_327335.json:
```json
{
    "body": "<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-26T13:49:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327335",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327336.json:
```json
{
    "body": "Changing component from documentation to combinatorics.",
    "created_at": "2018-02-26T13:50:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327336",
    "user": "https://github.com/fchapoton"
}
```

Changing component from documentation to combinatorics.



---

archive/issue_events_058609.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2018-02-26T13:50:25Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "milestone": "sage-8.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22381#event-58609"
}
```



---

archive/issue_comments_327337.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-26T13:57:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327337",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327338.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-26T15:34:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327338",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327339.json:
```json
{
    "body": "<a id='comment:12'></a>Thank you for dealing with this Fr\u00e9d\u00e9ric. I wanted to help with the review but I have a quite old version of sage right now and recompiling I bumped into #24575. I'll return to this once that is fixed. If anyone gets to it before I do please do not feel obliged to wait for me.",
    "created_at": "2018-02-26T20:55:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327339",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:12'></a>Thank you for dealing with this Frédéric. I wanted to help with the review but I have a quite old version of sage right now and recompiling I bumped into #24575. I'll return to this once that is fixed. If anyone gets to it before I do please do not feel obliged to wait for me.



---

archive/issue_comments_327340.json:
```json
{
    "body": "<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-27T08:39:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327340",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327341.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-27T09:18:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327341",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327342.json:
```json
{
    "body": "<a id='comment:15'></a>I finally managed to recompile sage and I gave a quick spin to this patch.\nSomething seems to be still wrong as it still fails on type A_2 cluster algebras:\n\n```\nsage: B = Matrix([[0,1,0],[-1,0,1],[0,-1,0],[0,1,0],[0,1,-1],[0,-1,0]])\nsage: Q = ClusterQuiver(B)\nsage: Q.mutation_class()\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-17-64d1287a18f5> in <module>()\n----> 1 Q.mutation_class()\n\n/opt/sage/local/lib/python2.7/site-packages/sage/combinat/cluster_algebra_quiver/quiver.pyc in mutation_class(self, depth, show_depth, return_paths, data_type, up_to_equivalence, sink_source)\n   1883         \"\"\"\n   1884         if depth is infinity and not self.is_mutation_finite():\n-> 1885             raise ValueError('the mutation class can - for infinite mutation'\n   1886                              ' types - only be computed up to a given depth')\n   1887         return [Q for Q in self.mutation_class_iter(depth=depth, show_depth=show_depth,\n\nValueError: the mutation class can - for infinite mutation types - only be computed up to a given depth\n``` \n\n\n\nWhile having a look I could not avoid asking myself what is the point of `_digraph_mutate`.\nIt sounds like an extremely convoluted way of performing mutations. Dealing with\nmatrices instead should be as simple as \n\n```\ndef mutate(B, k):\n    m = B.nrows()\n    n = B.ncols()\n    M = matrix(m,n, lambda i,j: -B[i,j] if i==k or j==k else B[i,j] + (abs(B[i,k])*B[k,j] + B[i,k]*abs(B[k,j]))/2 )\n    return M\n```\n\nIs there any speed advantage in dealing with digraphs? Can some of the original contributors please comment on this point?",
    "created_at": "2018-02-27T15:30:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327342",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:15'></a>I finally managed to recompile sage and I gave a quick spin to this patch.
Something seems to be still wrong as it still fails on type A_2 cluster algebras:

```
sage: B = Matrix([[0,1,0],[-1,0,1],[0,-1,0],[0,1,0],[0,1,-1],[0,-1,0]])
sage: Q = ClusterQuiver(B)
sage: Q.mutation_class()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-17-64d1287a18f5> in <module>()
----> 1 Q.mutation_class()

/opt/sage/local/lib/python2.7/site-packages/sage/combinat/cluster_algebra_quiver/quiver.pyc in mutation_class(self, depth, show_depth, return_paths, data_type, up_to_equivalence, sink_source)
   1883         """
   1884         if depth is infinity and not self.is_mutation_finite():
-> 1885             raise ValueError('the mutation class can - for infinite mutation'
   1886                              ' types - only be computed up to a given depth')
   1887         return [Q for Q in self.mutation_class_iter(depth=depth, show_depth=show_depth,

ValueError: the mutation class can - for infinite mutation types - only be computed up to a given depth
``` 



While having a look I could not avoid asking myself what is the point of `_digraph_mutate`.
It sounds like an extremely convoluted way of performing mutations. Dealing with
matrices instead should be as simple as 

```
def mutate(B, k):
    m = B.nrows()
    n = B.ncols()
    M = matrix(m,n, lambda i,j: -B[i,j] if i==k or j==k else B[i,j] + (abs(B[i,k])*B[k,j] + B[i,k]*abs(B[k,j]))/2 )
    return M
```

Is there any speed advantage in dealing with digraphs? Can some of the original contributors please comment on this point?



---

archive/issue_comments_327343.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-02-27T15:31:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327343",
    "user": "https://github.com/etn40ff"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_327344.json:
```json
{
    "body": "<a id='comment:17'></a>It seems that `_digraph_to_dig6` and `_dig6_to_digraph` in `sage.combinat.cluster_algebra_quiver.mutation_class` are only dealing seriously with the case of no-coefficients. Always creating a square matrix..",
    "created_at": "2018-02-27T17:04:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327344",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:17'></a>It seems that `_digraph_to_dig6` and `_dig6_to_digraph` in `sage.combinat.cluster_algebra_quiver.mutation_class` are only dealing seriously with the case of no-coefficients. Always creating a square matrix..



---

archive/issue_comments_327345.json:
```json
{
    "body": "<a id='comment:18'></a>I just got an e-mail from Gregg. He basically says that the point of digraph is\nto be able to label the vertices. Other than that matrices should be sufficient\nand faster.\n\nThe only other things that comes to mind is that Christian might have done some\noptimization to identify mutation classes and this might be based on digraphs.\nIt is probably the cheapest way to check for isomorphism of (valued) quivers.\nShould we ask him explicitly to comment on this?\n\nMy impression is that there are now two competing codebases for doing mutations,\none with graphs and one with matrices, that somehow are simultaneously in\n`ClusterQuiver` there should be quite a lot of room for cleanup. This does not\nsound like a short term project though.",
    "created_at": "2018-02-27T19:15:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327345",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:18'></a>I just got an e-mail from Gregg. He basically says that the point of digraph is
to be able to label the vertices. Other than that matrices should be sufficient
and faster.

The only other things that comes to mind is that Christian might have done some
optimization to identify mutation classes and this might be based on digraphs.
It is probably the cheapest way to check for isomorphism of (valued) quivers.
Should we ask him explicitly to comment on this?

My impression is that there are now two competing codebases for doing mutations,
one with graphs and one with matrices, that somehow are simultaneously in
`ClusterQuiver` there should be quite a lot of room for cleanup. This does not
sound like a short term project though.



---

archive/issue_comments_327346.json:
```json
{
    "body": "<a id='comment:19'></a>I think most of the mutation_type and mutation_finite code is made for the coefficient-free case and will be hard work to update. Even in your example of type A3 with coeffs, after being convinced to start mutating, it seems to find an infinite number of quivers...\n\nI would suggest:\n\n(1) close this ticket with the improvements it brings, including progress towards py3\n\n(2) open another one for the mutation type and finiteness issues.",
    "created_at": "2018-02-27T19:46:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327346",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:19'></a>I think most of the mutation_type and mutation_finite code is made for the coefficient-free case and will be hard work to update. Even in your example of type A3 with coeffs, after being convinced to start mutating, it seems to find an infinite number of quivers...

I would suggest:

(1) close this ticket with the improvements it brings, including progress towards py3

(2) open another one for the mutation type and finiteness issues.



---

archive/issue_comments_327347.json:
```json
{
    "body": "Changing keywords from \"ClusterSeed, mutations\" to \"ClusterSeed, mutations, cluster\".",
    "created_at": "2018-02-27T20:05:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327347",
    "user": "https://github.com/fchapoton"
}
```

Changing keywords from "ClusterSeed, mutations" to "ClusterSeed, mutations, cluster".



---

archive/issue_comments_327348.json:
```json
{
    "body": "<a id='comment:21'></a>I agree this is not going to be a quick fix and there is no point in delaying py3.\nThe only thing is that we should really make sure that the stopgap #22464 is also updated to the new ticket.",
    "created_at": "2018-02-27T20:32:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327348",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:21'></a>I agree this is not going to be a quick fix and there is no point in delaying py3.
The only thing is that we should really make sure that the stopgap #22464 is also updated to the new ticket.



---

archive/issue_comments_327349.json:
```json
{
    "body": "<a id='comment:22'></a>Hi,\n\nthis whole code clusterseed / quiver code seems to be a disaster, I wonder how much of it was actually broken from my first version of its code -- sorry at least for these originally broken parts!\n\n> Is there any speed advantage in dealing with digraphs? Can some of the original contributors please comment on this point?\n\n\nI have certainly spent a lot of time optimizing mutations, and used matrix mutation written in cython whereever possible. I believe, I have even used this for quiver mutations, but I am not totally sure.\n\nI will try to give a slightly more informative comment tomorrow, hopefully after I had a look at the original code...",
    "created_at": "2018-02-27T22:07:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327349",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:22'></a>Hi,

this whole code clusterseed / quiver code seems to be a disaster, I wonder how much of it was actually broken from my first version of its code -- sorry at least for these originally broken parts!

> Is there any speed advantage in dealing with digraphs? Can some of the original contributors please comment on this point?


I have certainly spent a lot of time optimizing mutations, and used matrix mutation written in cython whereever possible. I believe, I have even used this for quiver mutations, but I am not totally sure.

I will try to give a slightly more informative comment tomorrow, hopefully after I had a look at the original code...



---

archive/issue_comments_327350.json:
```json
{
    "body": "<a id='comment:23'></a>Okay, it seems that the quiver code is indeed broken for frozen variables since a long time, maybe even from the beginning (we wrote the code initially without frozen variables), and we even used `_digraph_mutate` from the beginning. I don't see any reason for using `_digraph_mutate` but I don't recall why we used it in the first place either.\n\nThe b matrix mutation is cythonized from the beginning and was then as fast as possible, see the mutate method `matrix/matrix0.pyx: def mutate(self, Py_ssize_t k )`.\n\nI think I agree that `digraph_to_dig6` and `dig6_to_digraph` only deal with no coefficients. I actually don't think this is used at all in practice. Originally it is used to store mutation classes of quivers without coefficients for faster type recognition (and there, one never deals with coefficients).\n\nThe type recognition for seeds and quivers is done by taking the quiver without coefficients and determining its type by a nightmare case-analysis algorithm (I wrote it and knew from the beginning that it will be impossible to properly debug or understand, but it worked for all types...).\n\nThe `mutation_class_iter` method seems to be a horrible code duplication, done either for quivers (where `_digraph_mutate` is used in `mutation_class` line 253) or for seeds (where matrix mutation is used in `cluster_seed` line 3566).\n\nI would suggest to fix the broken quiver mutation method, and then first run tests if that fixes the issues with quivers, or if there are any further issues. And only then start improving the code, if desired -- though I had in mind that Salvatore's new stuff is anyway much better from all perspectives...",
    "created_at": "2018-02-28T14:23:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327350",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:23'></a>Okay, it seems that the quiver code is indeed broken for frozen variables since a long time, maybe even from the beginning (we wrote the code initially without frozen variables), and we even used `_digraph_mutate` from the beginning. I don't see any reason for using `_digraph_mutate` but I don't recall why we used it in the first place either.

The b matrix mutation is cythonized from the beginning and was then as fast as possible, see the mutate method `matrix/matrix0.pyx: def mutate(self, Py_ssize_t k )`.

I think I agree that `digraph_to_dig6` and `dig6_to_digraph` only deal with no coefficients. I actually don't think this is used at all in practice. Originally it is used to store mutation classes of quivers without coefficients for faster type recognition (and there, one never deals with coefficients).

The type recognition for seeds and quivers is done by taking the quiver without coefficients and determining its type by a nightmare case-analysis algorithm (I wrote it and knew from the beginning that it will be impossible to properly debug or understand, but it worked for all types...).

The `mutation_class_iter` method seems to be a horrible code duplication, done either for quivers (where `_digraph_mutate` is used in `mutation_class` line 253) or for seeds (where matrix mutation is used in `cluster_seed` line 3566).

I would suggest to fix the broken quiver mutation method, and then first run tests if that fixes the issues with quivers, or if there are any further issues. And only then start improving the code, if desired -- though I had in mind that Salvatore's new stuff is anyway much better from all perspectives...



---

archive/issue_comments_327351.json:
```json
{
    "body": "<a id='comment:24'></a>I would suggest moving my branch to another ticket \"various enhancements to cluster quivers\". Would somebody review that ticket then ?",
    "created_at": "2018-03-02T08:09:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327351",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:24'></a>I would suggest moving my branch to another ticket "various enhancements to cluster quivers". Would somebody review that ticket then ?



---

archive/issue_comments_327352.json:
```json
{
    "body": "<a id='comment:25'></a>> \"various enhancements to cluster quivers\"\n\n\nI will do a review of the code you provided. In principle, I find it much simpler to review changes that only have a single purpose, so having the formatting and py3 changes separated from the changes to the quiver mutation.\n\nI would suggest, you move all formatting changes into another ticket which could go directly, and keep the actual behaviour modifications to `_digraph_mutate` so I can have a closer look at these and see how fixing the mutation issue there also fixes other issues we encountered.",
    "created_at": "2018-03-02T08:41:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327352",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:25'></a>> "various enhancements to cluster quivers"


I will do a review of the code you provided. In principle, I find it much simpler to review changes that only have a single purpose, so having the formatting and py3 changes separated from the changes to the quiver mutation.

I would suggest, you move all formatting changes into another ticket which could go directly, and keep the actual behaviour modifications to `_digraph_mutate` so I can have a closer look at these and see how fixing the mutation issue there also fixes other issues we encountered.



---

archive/issue_comments_327353.json:
```json
{
    "body": "<a id='comment:26'></a>Here is a branch only changing _digraph_mutate. It DOES NOT fix any issue concerning mutation type and mutation finiteness.",
    "created_at": "2018-03-02T08:55:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327353",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:26'></a>Here is a branch only changing _digraph_mutate. It DOES NOT fix any issue concerning mutation type and mutation finiteness.



---

archive/issue_comments_327354.json:
```json
{
    "body": "<a id='comment:27'></a>There remains a few other minor corrections. It would be more complicated to separate them away, as they were in the same commit.",
    "created_at": "2018-03-02T08:59:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327354",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:27'></a>There remains a few other minor corrections. It would be more complicated to separate them away, as they were in the same commit.



---

archive/issue_comments_327355.json:
```json
{
    "body": "<a id='comment:28'></a>extracted ticket at #24882",
    "created_at": "2018-03-02T09:00:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327355",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:28'></a>extracted ticket at #24882



---

archive/issue_comments_327356.json:
```json
{
    "body": "<a id='comment:29'></a>EDIT: wrong ticket, sorry",
    "created_at": "2018-03-02T09:38:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327356",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:29'></a>EDIT: wrong ticket, sorry



---

archive/issue_comments_327357.json:
```json
{
    "body": "<a id='comment:31'></a>I will post here whatever I encounter in the code, so that I keep track of what I understand, and for others to read and comment on.\n\n> The only other things that comes to mind is that Christian might have done some optimization to identify mutation classes and this might be based on digraphs.\n\n\nThe big issue is that we consider quivers often as unlabelled graphs, see the `up_to_equivalence=True` flag in `mutation_class._mutation_class_iter`.\n\nThere are thus multiple issues to keep track of:\n\n1. getting quivers into canonical form (by relabelling the vertices into a canonical ordering) and mutate at as least as possible vertices:\n   * this is done in `_dg_canonical_form`, where the input quiver is put into a canonical form, while the relabelling of the vertices and the orbits of vertices under the isomorphism group is also collected.\n   * this done, we only need to mutate at one vertex per orbit, and keep track that of the relabelling.\n\n2. checking if we already have encountered a given quiver.\n   * this is done using its dig6 string because checking if a string is contained in a set of strings is infinitely much faster than checking if a digraph is contained in a set/list of digraphs.\n\nNone of this was ever properly done for using frozen vertices.\n\n`@`Frederic: am i correct that you now properly do the mutation with frozen vertices in `_digraph_mutate` ?\n\nI hope things will work out again once also the dig6 stuff is properly updated what I will do now.",
    "created_at": "2018-03-02T10:25:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327357",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:31'></a>I will post here whatever I encounter in the code, so that I keep track of what I understand, and for others to read and comment on.

> The only other things that comes to mind is that Christian might have done some optimization to identify mutation classes and this might be based on digraphs.


The big issue is that we consider quivers often as unlabelled graphs, see the `up_to_equivalence=True` flag in `mutation_class._mutation_class_iter`.

There are thus multiple issues to keep track of:

1. getting quivers into canonical form (by relabelling the vertices into a canonical ordering) and mutate at as least as possible vertices:
   * this is done in `_dg_canonical_form`, where the input quiver is put into a canonical form, while the relabelling of the vertices and the orbits of vertices under the isomorphism group is also collected.
   * this done, we only need to mutate at one vertex per orbit, and keep track that of the relabelling.

2. checking if we already have encountered a given quiver.
   * this is done using its dig6 string because checking if a string is contained in a set of strings is infinitely much faster than checking if a digraph is contained in a set/list of digraphs.

None of this was ever properly done for using frozen vertices.

`@`Frederic: am i correct that you now properly do the mutation with frozen vertices in `_digraph_mutate` ?

I hope things will work out again once also the dig6 stuff is properly updated what I will do now.



---

archive/issue_comments_327358.json:
```json
{
    "body": "<a id='comment:32'></a>NOTE: I assumed in my changes that the frozen vertices are always the final one, labelled from n+1 to n+m. I am unsure if this is always the case.",
    "created_at": "2018-03-02T10:29:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327358",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:32'></a>NOTE: I assumed in my changes that the frozen vertices are always the final one, labelled from n+1 to n+m. I am unsure if this is always the case.



---

archive/issue_comments_327359.json:
```json
{
    "body": "<a id='comment:33'></a>Replying to [comment:32 chapoton]:\n> NOTE: I assumed in my changes that the frozen vertices are always the final one, labelled from n+1 to n+m. I am unsure if this is always the case.\n\n\nsame here, I also just wondered if we can even assume the vertex labellings to be integers or numbers 0 through n+m-1. I really don't know how all this changed. The attributes `Q._nlist` and `Q._mlist` might suggest that other vertex labellings are possible.",
    "created_at": "2018-03-02T10:32:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327359",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:33'></a>Replying to [comment:32 chapoton]:
> NOTE: I assumed in my changes that the frozen vertices are always the final one, labelled from n+1 to n+m. I am unsure if this is always the case.


same here, I also just wondered if we can even assume the vertex labellings to be integers or numbers 0 through n+m-1. I really don't know how all this changed. The attributes `Q._nlist` and `Q._mlist` might suggest that other vertex labellings are possible.



---

archive/issue_comments_327360.json:
```json
{
    "body": "<a id='comment:34'></a>The reason to use `_digraph_mutate` over matrix mutation is that the canonical form algorithm \n\n```\n    from sage.groups.perm_gps.partn_ref.refinement_graphs import search_tree, get_orbits\n```\ntakes a digraph, so\n\n1. starting with a quiver `Q`\n2. taking its b matrix `B`\n3. mutating the b matrix to `B'`\n4. turning `B'` into a new quiver `Q'` (observe that `Q` and `Q'` largely coincide)\n5. computing the canonical form of `Q'`\n\nis much slower (especially for large quivers where the coincidence in 4. is even bigger) than directly doing the digraph mutation.\n\nObserve that the actual mutation is indeed much faster on matrices, so having an equally fast version of the canonical form directly on matrices (take a square matrix and bring it into a canonical form up to simultaneous row- and column permutations) would be also solving the problem.",
    "created_at": "2018-03-02T10:38:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327360",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:34'></a>The reason to use `_digraph_mutate` over matrix mutation is that the canonical form algorithm 

```
    from sage.groups.perm_gps.partn_ref.refinement_graphs import search_tree, get_orbits
```
takes a digraph, so

1. starting with a quiver `Q`
2. taking its b matrix `B`
3. mutating the b matrix to `B'`
4. turning `B'` into a new quiver `Q'` (observe that `Q` and `Q'` largely coincide)
5. computing the canonical form of `Q'`

is much slower (especially for large quivers where the coincidence in 4. is even bigger) than directly doing the digraph mutation.

Observe that the actual mutation is indeed much faster on matrices, so having an equally fast version of the canonical form directly on matrices (take a square matrix and bring it into a canonical form up to simultaneous row- and column permutations) would be also solving the problem.



---

archive/issue_comments_327361.json:
```json
{
    "body": "<a id='comment:35'></a>Given\n\n```\nsage: D = ClusterQuiver(['A',2])._digraph\nsage: D.relabel({0:\"A\",1:frozenset([1,2,\"A\"])})\nsage: ClusterQuiver(D)._digraph.edges()\n[('A', frozenset({1, 2, 'A'}), (1, -1))]\n```\nI must say that I am not willing to take this into account. I believe that `_digraph` should always be a digraph with vertices `range(n+m)` with mutable vertices `range(n)` and frozen vertices `range(n+1,n+m)` (*).\n\nI believe this extra layer should be handled separately at a \"high level\" and not changing the backend algorithms of quivers. All mutation class and mutation type code is written with this assumption (*).",
    "created_at": "2018-03-02T10:51:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327361",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:35'></a>Given

```
sage: D = ClusterQuiver(['A',2])._digraph
sage: D.relabel({0:"A",1:frozenset([1,2,"A"])})
sage: ClusterQuiver(D)._digraph.edges()
[('A', frozenset({1, 2, 'A'}), (1, -1))]
```
I must say that I am not willing to take this into account. I believe that `_digraph` should always be a digraph with vertices `range(n+m)` with mutable vertices `range(n)` and frozen vertices `range(n+1,n+m)` (*).

I believe this extra layer should be handled separately at a "high level" and not changing the backend algorithms of quivers. All mutation class and mutation type code is written with this assumption (*).



---

archive/issue_comments_327362.json:
```json
{
    "body": "<a id='comment:36'></a>Okay, there are plenty of errors, I have fixed a few, but cannot push currently:\n\n* `ClusterQuiver.canonical_label` has an obvious bug for frozen variables (it froze variables 0 ... m-1 rather then n ... n+m-1). fixed.\n\n* `_digraph_mutate` still makes mistakes:\n\n```\nsage: Q = ClusterQuiver(['B',2]).principal_extension()\nsage: Q.mutate(0)\nsage: Q.b_matrix()\n[ 0 -1]\n[ 2  0]\n[-1  1]\n[ 0  1]\nsage: Q._digraph.edges(labels=True)\n[(0, 2, (1, -1)), (1, 0, (2, -1)), (2, 1, (1, -2)), (3, 1, (1, -1))]\n```\n    The label for (2,1) should be (1,-1) if I see it correctly. (not fixed)\n\n* the dig6 conversion is broken (not fixed)\n\n* finally, vertices of the digraph different from 0 ... n-1, n ... n+m-1 are currently possible but not supported whatsoever (not going to fix)",
    "created_at": "2018-03-02T15:10:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327362",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:36'></a>Okay, there are plenty of errors, I have fixed a few, but cannot push currently:

* `ClusterQuiver.canonical_label` has an obvious bug for frozen variables (it froze variables 0 ... m-1 rather then n ... n+m-1). fixed.

* `_digraph_mutate` still makes mistakes:

```
sage: Q = ClusterQuiver(['B',2]).principal_extension()
sage: Q.mutate(0)
sage: Q.b_matrix()
[ 0 -1]
[ 2  0]
[-1  1]
[ 0  1]
sage: Q._digraph.edges(labels=True)
[(0, 2, (1, -1)), (1, 0, (2, -1)), (2, 1, (1, -2)), (3, 1, (1, -1))]
```
    The label for (2,1) should be (1,-1) if I see it correctly. (not fixed)

* the dig6 conversion is broken (not fixed)

* finally, vertices of the digraph different from 0 ... n-1, n ... n+m-1 are currently possible but not supported whatsoever (not going to fix)



---

archive/issue_comments_327363.json:
```json
{
    "body": "<a id='comment:37'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-03-02T15:22:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327363",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:37'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327364.json:
```json
{
    "body": "<a id='comment:38'></a>Replying to [comment:34 stumpc5]:\n\n> Observe that the actual mutation is indeed much faster on matrices, so having an equally fast version of the canonical form directly on matrices (take a square matrix and bring it into a canonical form up to simultaneous row- and column permutations) would be also solving the problem.\n\n\nWhat about the following for a canonical form of a (coefficient-free) exchange matrix?\n\n1) take the columns of B and sort each of them\n\n2) sort the resulting lists lexicographically\n\n3) 2 gives a permutation, use this permutation on rows and columns of B\n\nTo compare matrices in the canonical form you can then just use hashes.",
    "created_at": "2018-03-03T15:24:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327364",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:38'></a>Replying to [comment:34 stumpc5]:

> Observe that the actual mutation is indeed much faster on matrices, so having an equally fast version of the canonical form directly on matrices (take a square matrix and bring it into a canonical form up to simultaneous row- and column permutations) would be also solving the problem.


What about the following for a canonical form of a (coefficient-free) exchange matrix?

1) take the columns of B and sort each of them

2) sort the resulting lists lexicographically

3) 2 gives a permutation, use this permutation on rows and columns of B

To compare matrices in the canonical form you can then just use hashes.



---

archive/issue_comments_327365.json:
```json
{
    "body": "<a id='comment:39'></a>I did a few tests if it is possible to do the quiver mutation using matrices, and I got\n\n```\nsage: %timeit M.mutate(1)\n100000 loops, best of 3: 2.77 \u00b5s per loop\nsage: %timeit _digraph_mutate(D,1,5,5)\n10000 loops, best of 3: 37.8 \u00b5s per loop\nsage: %timeit digraph_mutate_new(D,1,5,5)\nThe slowest run took 611.92 times longer than the fastest. This could mean that an intermediate result is being cached.\n10000 loops, best of 3: 59.2 \u00b5s per loop\n```\nThe later turns the digraph into a matrix and back in cython, and I don't see how to improve this my much since the time is almost completely spend in reading the edges of the input graph, creating the matrix, and writing the output graph.",
    "created_at": "2018-03-04T07:14:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327365",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:39'></a>I did a few tests if it is possible to do the quiver mutation using matrices, and I got

```
sage: %timeit M.mutate(1)
100000 loops, best of 3: 2.77 µs per loop
sage: %timeit _digraph_mutate(D,1,5,5)
10000 loops, best of 3: 37.8 µs per loop
sage: %timeit digraph_mutate_new(D,1,5,5)
The slowest run took 611.92 times longer than the fastest. This could mean that an intermediate result is being cached.
10000 loops, best of 3: 59.2 µs per loop
```
The later turns the digraph into a matrix and back in cython, and I don't see how to improve this my much since the time is almost completely spend in reading the edges of the input graph, creating the matrix, and writing the output graph.



---

archive/issue_comments_327366.json:
```json
{
    "body": "<a id='comment:40'></a>`@`Salvatore: canonical form is up to **simultaneous** row and column permutation, not up to row and column permutation! This canonical form in particular solves graph isomorphism (two graphs are isomorphic if and only if their canonical form adjacency matrices coincide, observe that a simultaneous row and column permutation is a relabelling of the vertices of the graph) and the later is implemented and highly optimized in sage.\n\nThere is no chance to provide anything speedwise comparable directly on matrices without reimplementing the above algorithm, I did quite some tests when implementing it and the outcome was that graph canonical form is by far fastest available.",
    "created_at": "2018-03-04T07:26:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327366",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:40'></a>`@`Salvatore: canonical form is up to **simultaneous** row and column permutation, not up to row and column permutation! This canonical form in particular solves graph isomorphism (two graphs are isomorphic if and only if their canonical form adjacency matrices coincide, observe that a simultaneous row and column permutation is a relabelling of the vertices of the graph) and the later is implemented and highly optimized in sage.

There is no chance to provide anything speedwise comparable directly on matrices without reimplementing the above algorithm, I did quite some tests when implementing it and the outcome was that graph canonical form is by far fastest available.



---

archive/issue_comments_327367.json:
```json
{
    "body": "<a id='comment:41'></a>> To compare matrices in the canonical form you can then just use hashes.\n\n\nwell, on the level of the graphs, the dig6 string is basically the (invertible) hash, though you might be right that an ordinary hash might be faster and also working. I will recheck...",
    "created_at": "2018-03-04T07:30:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327367",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:41'></a>> To compare matrices in the canonical form you can then just use hashes.


well, on the level of the graphs, the dig6 string is basically the (invertible) hash, though you might be right that an ordinary hash might be faster and also working. I will recheck...



---

archive/issue_comments_327368.json:
```json
{
    "body": "<a id='comment:42'></a>Replying to [comment:40 stumpc5]:\n> `@`Salvatore: canonical form is up to **simultaneous** row and column permutation, not up to row and column permutation! This canonical form in particular solves graph isomorphism (two graphs are isomorphic if and only if their canonical form adjacency matrices coincide, observe that a simultaneous row and column permutation is a relabelling of the vertices of the graph) and the later is implemented and highly optimized in sage.\n> \n> There is no chance to provide anything speedwise comparable directly on matrices without reimplementing the above algorithm, I did quite some tests when implementing it and the outcome was that graph canonical form is by far fastest available.\n\n\nI think you misunderstood the algorithm I was suggesting: 3 would be applied to rows and columns of B simultaneously, not to the sorted vectors in 2. \n\nIn any case I think I was being stupid for other reasons: the algorithm proposed basically sorts vertices according to their in and out degrees (or actually some finer version of this where we keep track of how many arrows from distinct vertices are adjacent to each node). This is not enough information to distinguish any two quivers.\nThe first example that comes to mind is a \"figure 8 quiver\" with one vertex of degree 4 (2 in and 2 out) and 4 vertices of degree 2 (1 in and 1 out). The algorithm I had in mind can't distinguish the case with a 3 cycle attached to a 5 cycle from the case of two 4 cycles glued together.\n\nSorry about the stupid remark.",
    "created_at": "2018-03-04T07:53:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327368",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:42'></a>Replying to [comment:40 stumpc5]:
> `@`Salvatore: canonical form is up to **simultaneous** row and column permutation, not up to row and column permutation! This canonical form in particular solves graph isomorphism (two graphs are isomorphic if and only if their canonical form adjacency matrices coincide, observe that a simultaneous row and column permutation is a relabelling of the vertices of the graph) and the later is implemented and highly optimized in sage.
> 
> There is no chance to provide anything speedwise comparable directly on matrices without reimplementing the above algorithm, I did quite some tests when implementing it and the outcome was that graph canonical form is by far fastest available.


I think you misunderstood the algorithm I was suggesting: 3 would be applied to rows and columns of B simultaneously, not to the sorted vectors in 2. 

In any case I think I was being stupid for other reasons: the algorithm proposed basically sorts vertices according to their in and out degrees (or actually some finer version of this where we keep track of how many arrows from distinct vertices are adjacent to each node). This is not enough information to distinguish any two quivers.
The first example that comes to mind is a "figure 8 quiver" with one vertex of degree 4 (2 in and 2 out) and 4 vertices of degree 2 (1 in and 1 out). The algorithm I had in mind can't distinguish the case with a 3 cycle attached to a 5 cycle from the case of two 4 cycles glued together.

Sorry about the stupid remark.



---

archive/issue_comments_327369.json:
```json
{
    "body": "<a id='comment:43'></a>Replying to [comment:42 etn40ff]:\n\n> I think you misunderstood the algorithm I was suggesting: 3 would be applied to rows and columns of B simultaneously, not to the sorted vectors in 2. \n\n\nOh yes, I did, sorry. Anyway, highly optimized graph canonical form algorithms are hard to beat with an algorithm that in particular solves graph canonical form...",
    "created_at": "2018-03-04T08:07:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327369",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:43'></a>Replying to [comment:42 etn40ff]:

> I think you misunderstood the algorithm I was suggesting: 3 would be applied to rows and columns of B simultaneously, not to the sorted vectors in 2. 


Oh yes, I did, sorry. Anyway, highly optimized graph canonical form algorithms are hard to beat with an algorithm that in particular solves graph canonical form...



---

archive/issue_comments_327370.json:
```json
{
    "body": "<a id='comment:44'></a>Stern but just :D\n\nSince this is my day for random stupid ideas here is another.\nCan't we use CAIV to speed up the process? It is known that the exchange graph\nassociated to any quiver with any choice of coefficients is a quotient of the\nexchange graph associated to the same quiver but with principal coefficients.\n\nCan we just pretend we always have principal coefficients(by artificially adding\nthem) and then perform mutations on the matrices only? Deciding if two seeds\ncoincide is just a matter of comparing the associated lists of c-vectors (and\nthis is fast). If we care about the up to equivalence case we can always check\nfor graph isomorphisms in a second time.\n\nI am basically proposing to replace code duplication and digraphs with possibly\nmore mutations but performed much faster.\n\nThis is what me and Dylan do in `ClusterAlgebra` but there we never care about\nthe up to equivalence issue.",
    "created_at": "2018-03-04T09:49:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327370",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:44'></a>Stern but just :D

Since this is my day for random stupid ideas here is another.
Can't we use CAIV to speed up the process? It is known that the exchange graph
associated to any quiver with any choice of coefficients is a quotient of the
exchange graph associated to the same quiver but with principal coefficients.

Can we just pretend we always have principal coefficients(by artificially adding
them) and then perform mutations on the matrices only? Deciding if two seeds
coincide is just a matter of comparing the associated lists of c-vectors (and
this is fast). If we care about the up to equivalence case we can always check
for graph isomorphisms in a second time.

I am basically proposing to replace code duplication and digraphs with possibly
more mutations but performed much faster.

This is what me and Dylan do in `ClusterAlgebra` but there we never care about
the up to equivalence issue.



---

archive/issue_comments_327371.json:
```json
{
    "body": "<a id='comment:45'></a>I am not sure I really follow how you want to do the check.\n\nPlease let me note that we want to list all quivers up to equivalence. The best way approach I know of is the following much more general algorithm using a canonical form (where two objects are considered equivalent if they have the same canonical form):\n\n1. compute a new object (here using mutation from an old one)\n2. bring it into a canonical form\n3. check if you have seen this canonical form before (using a hash table)\n4. if yes: discard the element\n5. if no: store the canonical form in the hash table, and keep the element.\n\nObserve that you must in particular compute the canonical form for each element you encounter.\n\nI don't see how you could bypass this canonical form computation. In particular, I don't see how your approach could deal with this other than also computing it.",
    "created_at": "2018-03-04T10:34:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327371",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:45'></a>I am not sure I really follow how you want to do the check.

Please let me note that we want to list all quivers up to equivalence. The best way approach I know of is the following much more general algorithm using a canonical form (where two objects are considered equivalent if they have the same canonical form):

1. compute a new object (here using mutation from an old one)
2. bring it into a canonical form
3. check if you have seen this canonical form before (using a hash table)
4. if yes: discard the element
5. if no: store the canonical form in the hash table, and keep the element.

Observe that you must in particular compute the canonical form for each element you encounter.

I don't see how you could bypass this canonical form computation. In particular, I don't see how your approach could deal with this other than also computing it.



---

archive/issue_comments_327372.json:
```json
{
    "body": "<a id='comment:46'></a>You are more than welcome to try to beat the current algorithm!\n\n* I am sure that you will be able to do so if you spend enough time and thinking.\n* I am certainly willing to help you with this.\n\nI would personally expect that the optimal reachable solution is to generalize the graph canonical form to a matrix canonical form. Citation from https://en.wikipedia.org/wiki/Graph_canonization:\n  *A commonly known canonical form is the lexicographically smallest graph within the isomorphism class, which is the graph of the class with lexicographically smallest adjacency matrix considered as a linear string. However, the computation of the lexicographically smallest graph is NP-hard.*\n\nWe currently use `sage.groups.perm_gps.partn_ref.refinement_graphs.search_tree` which implements *McKay - Practical Graph Isomorphism*, see in particular https://arxiv.org/abs/1301.1493.",
    "created_at": "2018-03-04T10:50:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327372",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:46'></a>You are more than welcome to try to beat the current algorithm!

* I am sure that you will be able to do so if you spend enough time and thinking.
* I am certainly willing to help you with this.

I would personally expect that the optimal reachable solution is to generalize the graph canonical form to a matrix canonical form. Citation from https://en.wikipedia.org/wiki/Graph_canonization:
  *A commonly known canonical form is the lexicographically smallest graph within the isomorphism class, which is the graph of the class with lexicographically smallest adjacency matrix considered as a linear string. However, the computation of the lexicographically smallest graph is NP-hard.*

We currently use `sage.groups.perm_gps.partn_ref.refinement_graphs.search_tree` which implements *McKay - Practical Graph Isomorphism*, see in particular https://arxiv.org/abs/1301.1493.



---

archive/issue_comments_327373.json:
```json
{
    "body": "<a id='comment:47'></a>Ok, let me try to explain a little better if I can.\nSuppose that we have a square exchange matrix B and consider its \nits principal framing Bp (i.e. B with the identity matrix attached to the\nbottom). Suppose for a moment that we want to list all the matrices in the\nmutation class of Bp up to simultaneous permutations of columns and (the first\nn) rows. \n\nCall the columns of the bottom part of a matrix obtained by mutations from Bp\nits c-vectors.\n\nThm: B1 and B2 in the mutation class of Bp are equivalent if and only if the\nsets of their c-vectors coincide.\n\nSo here is the algorithm to list all the matrices mutationally equivalent to Bp:\nStart from Bp and perform mutations, at each step compare the set of c-vectors\nwith the one already known.\nThis completely solve the problem in the case of principal coefficients and is\nmuch faster than any other implementation using digraphs and canonical forms for\ncomparisons.\n\n\n\nSuppose now that Bf is any other rectangular matrix with the same B as the top\npart. Suppose that B1f is obtained from Bf by a certain sequence of mutations\nand suppose that B1 is obtained from Bp with the same sequence of mutations.\nThen, obviously, the top part of B1f and B1 coincide. Moreover there is a\ntransformation (that depends only on Bf so it applies to the entire mutation\nclass) that expresses the bottom part of B1f in terms of the c-vectors of B1.\nIn particular if B1 and B2 are equivalent so do B1f and B2f for any choice of \nframing. \n\nIt remains to test the situation in which B1 and B2 are distinct but have\nequivalent top parts to see if B1f and B2f are equivalent. For cluster algebras\nthis is an irrelevant issue and we just do not care in our implementation.\nIndeed the only relevant framing for the combinatorial structure of a cluster\nalgebra is the principal one.\n\nIf one is only interested in quiver mutations it could be relevant. In any case it\nshould be faster to compare using digraphs only the matrices the previous\nalgorithm produce rather than all of them.\n\n\nIn short: to compute mutation classes we do not need to solve the graph\nisomorphism problem in full generality.",
    "created_at": "2018-03-04T11:16:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327373",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:47'></a>Ok, let me try to explain a little better if I can.
Suppose that we have a square exchange matrix B and consider its 
its principal framing Bp (i.e. B with the identity matrix attached to the
bottom). Suppose for a moment that we want to list all the matrices in the
mutation class of Bp up to simultaneous permutations of columns and (the first
n) rows. 

Call the columns of the bottom part of a matrix obtained by mutations from Bp
its c-vectors.

Thm: B1 and B2 in the mutation class of Bp are equivalent if and only if the
sets of their c-vectors coincide.

So here is the algorithm to list all the matrices mutationally equivalent to Bp:
Start from Bp and perform mutations, at each step compare the set of c-vectors
with the one already known.
This completely solve the problem in the case of principal coefficients and is
much faster than any other implementation using digraphs and canonical forms for
comparisons.



Suppose now that Bf is any other rectangular matrix with the same B as the top
part. Suppose that B1f is obtained from Bf by a certain sequence of mutations
and suppose that B1 is obtained from Bp with the same sequence of mutations.
Then, obviously, the top part of B1f and B1 coincide. Moreover there is a
transformation (that depends only on Bf so it applies to the entire mutation
class) that expresses the bottom part of B1f in terms of the c-vectors of B1.
In particular if B1 and B2 are equivalent so do B1f and B2f for any choice of 
framing. 

It remains to test the situation in which B1 and B2 are distinct but have
equivalent top parts to see if B1f and B2f are equivalent. For cluster algebras
this is an irrelevant issue and we just do not care in our implementation.
Indeed the only relevant framing for the combinatorial structure of a cluster
algebra is the principal one.

If one is only interested in quiver mutations it could be relevant. In any case it
should be faster to compare using digraphs only the matrices the previous
algorithm produce rather than all of them.


In short: to compute mutation classes we do not need to solve the graph
isomorphism problem in full generality.



---

archive/issue_comments_327374.json:
```json
{
    "body": "<a id='comment:48'></a>> This completely solve the problem in the case of principal coefficients and is much faster than any other implementation using digraphs and canonical forms for comparisons.\n\n\nThis might be correct, but is not totally obvious. The canonical form tells which vertices are equivalent, so we do not need to mutate all, but only one per equivalence class of vertices (orbits of the isomorphism group).\n\n> Moreover there is a transformation (that depends only on Bf so it applies to the entire mutation class) that expresses the bottom part of B1f in terms of the c-vectors of B1. In particular if B1 and B2 are equivalent so do B1f and B2f for any choice of framing.\n\n\nI see this, but don't we rather also need the other direction, since we want to solve isomorphism for Bf? Imagine Bf is only the top part, so there are no c-vectors. We now need to check isomorphism for Bf? Could you apply your algorithm (for me to understand) to find the unique quiver of type A2, and an example of how to find the four quivers of type A3? (In the first case, you first find 5 quivers starting with principal coefficients, and in the second you find 14 -- and I fail to see how these are reduced to 1 and 4, resp.)\n\n> If one is only interested in quiver mutations it could be relevant. \n\n\nIsn't this complete thread and the algorithm about quiver mutations and not about cluster seed mutations? If I see your algorithm correctly, it would find the five non-equivalent quivers with principal coefficients, but how does this help to see that their top parts are actually all equivalent?",
    "created_at": "2018-03-04T11:54:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327374",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:48'></a>> This completely solve the problem in the case of principal coefficients and is much faster than any other implementation using digraphs and canonical forms for comparisons.


This might be correct, but is not totally obvious. The canonical form tells which vertices are equivalent, so we do not need to mutate all, but only one per equivalence class of vertices (orbits of the isomorphism group).

> Moreover there is a transformation (that depends only on Bf so it applies to the entire mutation class) that expresses the bottom part of B1f in terms of the c-vectors of B1. In particular if B1 and B2 are equivalent so do B1f and B2f for any choice of framing.


I see this, but don't we rather also need the other direction, since we want to solve isomorphism for Bf? Imagine Bf is only the top part, so there are no c-vectors. We now need to check isomorphism for Bf? Could you apply your algorithm (for me to understand) to find the unique quiver of type A2, and an example of how to find the four quivers of type A3? (In the first case, you first find 5 quivers starting with principal coefficients, and in the second you find 14 -- and I fail to see how these are reduced to 1 and 4, resp.)

> If one is only interested in quiver mutations it could be relevant. 


Isn't this complete thread and the algorithm about quiver mutations and not about cluster seed mutations? If I see your algorithm correctly, it would find the five non-equivalent quivers with principal coefficients, but how does this help to see that their top parts are actually all equivalent?



---

archive/issue_comments_327375.json:
```json
{
    "body": "<a id='comment:49'></a>You can see in `ClusterSeed.mutation_class_iter` that we do not do any graph isomorphism there and compare the cluster variables (instead of your c-vectors). We also perform matrix mutation in this case and no digraph mutation. What I thought we discuss in this thread is quiver mutation and quiver mutation class computations.",
    "created_at": "2018-03-04T12:07:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327375",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:49'></a>You can see in `ClusterSeed.mutation_class_iter` that we do not do any graph isomorphism there and compare the cluster variables (instead of your c-vectors). We also perform matrix mutation in this case and no digraph mutation. What I thought we discuss in this thread is quiver mutation and quiver mutation class computations.



---

archive/issue_comments_327376.json:
```json
{
    "body": "<a id='comment:50'></a>Replying to [comment:48 stumpc5]:\n> > This completely solve the problem in the case of principal coefficients and is much faster than any other implementation using digraphs and canonical forms for comparisons.\n\n> \n> This might be correct, but is not totally obvious. The canonical form tells which vertices are equivalent, so we do not need to mutate all, but only one per equivalence class of vertices (orbits of the isomorphism group).\n> \n\n\nSome tests of the current versions of `ClusterQuiver` for the coefficient-free case (because I could not make the general case run) and `ClusterAlgebraSeed` with principal coefficients\n\n```\nsage: A = ClusterAlgebra(['D',10], principal_coefficients=True)\nsage: %time _ = list(A.seeds(mutating_F=False))\nCPU times: user 1min 25s, sys: 525 ms, total: 1min 25s\nWall time: 1min 25s\nsage: Q = ClusterQuiver(['D',10])\nsage: %time _ = list(Q.mutation_class_iter())\nCPU times: user 1min 18s, sys: 64.5 ms, total: 1min 18s\nWall time: 1min 18s\n```\nshow that the two are comparable in finite types. \nActually implementing what I suggest is worse because then one has to further\nreduce the output according to coeffieicents.\nI do not know how well `ClusterQuiver` scales as the number of coefficients\ngrows (assuming we can make it work).\n\nBeyond finite types things are different because there are not as many\nsymmetries. For example\n\n```\nsage: B = matrix(10, lambda i,j: 1 if random() <0.5 else 0)\nsage: B -= B.transpose()\nsage: Q = ClusterQuiver(B)\nsage: mut_class = Q.mutation_class_iter()\nsage: count = 0\nsage: %time while count < 100000: _ = mut_class.next(); count +=1\nCPU times: user 3min 32s, sys: 13.7 ms, total: 3min 32s\nWall time: 3min 33s\nsage: A = ClusterAlgebra(B)\nsage: mut_class = A.seeds(mutating_F=False)\nsage: count = 0\nsage: %time while count < 100000: _ = mut_class.next(); count +=1\nCPU times: user 51.4 s, sys: 491 ms, total: 51.9 s\nWall time: 52.1 s\n```\n\n\n> > Moreover there is a transformation (that depends only on Bf so it applies to the entire mutation class) that expresses the bottom part of B1f in terms of the c-vectors of B1. In particular if B1 and B2 are equivalent so do B1f and B2f for any choice of framing.\n\n> \n> I see this, but don't we rather also need the other direction, since we want to solve isomorphism for Bf? Imagine Bf is only the top part, so there are no c-vectors. We now need to check isomorphism for Bf? Could you apply your algorithm (for me to understand) to find the unique quiver of type A2, and an example of how to find the four quivers of type A3? (In the first case, you first find 5 quivers starting with principal coefficients, and in the second you find 14 -- and I fail to see how these are reduced to 1 and 4, resp.)\n> \n\n\nJust run the same algorithm you run now: digraph isomorphism. In this example\nyou point out my suggestion is way more expensive than the one you implemented:\nI have to find 5 quivers and then test all of them to see that they coincide. \nOn a not so symmetric case though my approach could save quite some time.\n\n> > If one is only interested in quiver mutations it could be relevant. \n\n> \n> Isn't this complete thread and the algorithm about quiver mutations and not\n> about cluster seed mutations? If I see your algorithm correctly, it would find\n> the five non-equivalent quivers with principal coefficients, but how does this\n> help to see that their top parts are actually all equivalent?\n\n\nI am just saying we could consider the possibility to derive the algorithm for\nquivers out of the algorithm for cluster algebras with (possibly?) a speedup.\nOf course I am not even sure this is worth doing.",
    "created_at": "2018-03-04T12:40:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327376",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:50'></a>Replying to [comment:48 stumpc5]:
> > This completely solve the problem in the case of principal coefficients and is much faster than any other implementation using digraphs and canonical forms for comparisons.

> 
> This might be correct, but is not totally obvious. The canonical form tells which vertices are equivalent, so we do not need to mutate all, but only one per equivalence class of vertices (orbits of the isomorphism group).
> 


Some tests of the current versions of `ClusterQuiver` for the coefficient-free case (because I could not make the general case run) and `ClusterAlgebraSeed` with principal coefficients

```
sage: A = ClusterAlgebra(['D',10], principal_coefficients=True)
sage: %time _ = list(A.seeds(mutating_F=False))
CPU times: user 1min 25s, sys: 525 ms, total: 1min 25s
Wall time: 1min 25s
sage: Q = ClusterQuiver(['D',10])
sage: %time _ = list(Q.mutation_class_iter())
CPU times: user 1min 18s, sys: 64.5 ms, total: 1min 18s
Wall time: 1min 18s
```
show that the two are comparable in finite types. 
Actually implementing what I suggest is worse because then one has to further
reduce the output according to coeffieicents.
I do not know how well `ClusterQuiver` scales as the number of coefficients
grows (assuming we can make it work).

Beyond finite types things are different because there are not as many
symmetries. For example

```
sage: B = matrix(10, lambda i,j: 1 if random() <0.5 else 0)
sage: B -= B.transpose()
sage: Q = ClusterQuiver(B)
sage: mut_class = Q.mutation_class_iter()
sage: count = 0
sage: %time while count < 100000: _ = mut_class.next(); count +=1
CPU times: user 3min 32s, sys: 13.7 ms, total: 3min 32s
Wall time: 3min 33s
sage: A = ClusterAlgebra(B)
sage: mut_class = A.seeds(mutating_F=False)
sage: count = 0
sage: %time while count < 100000: _ = mut_class.next(); count +=1
CPU times: user 51.4 s, sys: 491 ms, total: 51.9 s
Wall time: 52.1 s
```


> > Moreover there is a transformation (that depends only on Bf so it applies to the entire mutation class) that expresses the bottom part of B1f in terms of the c-vectors of B1. In particular if B1 and B2 are equivalent so do B1f and B2f for any choice of framing.

> 
> I see this, but don't we rather also need the other direction, since we want to solve isomorphism for Bf? Imagine Bf is only the top part, so there are no c-vectors. We now need to check isomorphism for Bf? Could you apply your algorithm (for me to understand) to find the unique quiver of type A2, and an example of how to find the four quivers of type A3? (In the first case, you first find 5 quivers starting with principal coefficients, and in the second you find 14 -- and I fail to see how these are reduced to 1 and 4, resp.)
> 


Just run the same algorithm you run now: digraph isomorphism. In this example
you point out my suggestion is way more expensive than the one you implemented:
I have to find 5 quivers and then test all of them to see that they coincide. 
On a not so symmetric case though my approach could save quite some time.

> > If one is only interested in quiver mutations it could be relevant. 

> 
> Isn't this complete thread and the algorithm about quiver mutations and not
> about cluster seed mutations? If I see your algorithm correctly, it would find
> the five non-equivalent quivers with principal coefficients, but how does this
> help to see that their top parts are actually all equivalent?


I am just saying we could consider the possibility to derive the algorithm for
quivers out of the algorithm for cluster algebras with (possibly?) a speedup.
Of course I am not even sure this is worth doing.



---

archive/issue_comments_327377.json:
```json
{
    "body": "<a id='comment:51'></a>\n```\nsage: A = ClusterAlgebra(['D',10], principal_coefficients=True)\nsage: %time _ = list(A.seeds(mutating_F=False))\n```\nDoes this use matrix mutation, or another mutation algorithm you implemented?",
    "created_at": "2018-03-04T13:08:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327377",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:51'></a>
```
sage: A = ClusterAlgebra(['D',10], principal_coefficients=True)
sage: %time _ = list(A.seeds(mutating_F=False))
```
Does this use matrix mutation, or another mutation algorithm you implemented?



---

archive/issue_comments_327378.json:
```json
{
    "body": "<a id='comment:52'></a>Replying to [comment:51 stumpc5]:\n> {{{\n> sage: A = ClusterAlgebra(['D',10], principal_coefficients=True)\n> sage: %time _ = list(A.seeds(mutating_F=False))\n> }}}\n> Does this use matrix mutation, or another mutation algorithm you implemented?\n\n\nA bit of both: we mutate the top part by `sage.matrix.matrix0.Matrix.mutate` and the bottom part by hand. This is because we just wanted to keep c-vectors separate. We even perform several other computations that are needed for cluster algebras and that can be easily dropped if one only cares about quivers.\n\nIf one wanted to be smarter this could be entirely done with your cytonized code.",
    "created_at": "2018-03-04T13:17:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327378",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:52'></a>Replying to [comment:51 stumpc5]:
> {{{
> sage: A = ClusterAlgebra(['D',10], principal_coefficients=True)
> sage: %time _ = list(A.seeds(mutating_F=False))
> }}}
> Does this use matrix mutation, or another mutation algorithm you implemented?


A bit of both: we mutate the top part by `sage.matrix.matrix0.Matrix.mutate` and the bottom part by hand. This is because we just wanted to keep c-vectors separate. We even perform several other computations that are needed for cluster algebras and that can be easily dropped if one only cares about quivers.

If one wanted to be smarter this could be entirely done with your cytonized code.



---

archive/issue_comments_327379.json:
```json
{
    "body": "<a id='comment:53'></a>> If one wanted to be smarter this could be entirely done with your cytonized code.\n\n\nSo let me rephrase to see if I understand correctly and whether we are on the same page:\n\nThe best version of your suggestion is that we could compute the complete mutation class of a symmetrizable matrix using the cythonized `mutate` method in `matrix0.pyx` and then compute all canonical forms after.\n\nI will try to produce something similar to this and see how it compares...",
    "created_at": "2018-03-04T13:32:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327379",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:53'></a>> If one wanted to be smarter this could be entirely done with your cytonized code.


So let me rephrase to see if I understand correctly and whether we are on the same page:

The best version of your suggestion is that we could compute the complete mutation class of a symmetrizable matrix using the cythonized `mutate` method in `matrix0.pyx` and then compute all canonical forms after.

I will try to produce something similar to this and see how it compares...



---

archive/issue_comments_327380.json:
```json
{
    "body": "<a id='comment:54'></a>Yes, this is more or less what I was thinking of.\n\nIf the canonical form is able to distinguish also quivers with coefficients I would suggest this algorithm:\n\nB input matrix possibly with coefficients\n\nAppend an identity matrix to B\n\nperfome mutations with cytonized mutate on the resulting matrix and use the last n entries in each column to distinguish matrices.\n\nreturn canonical form of the resulting matrices.\n\nThis last step is not necessary if, at some stage, we find an identity matrix among the possibly permuted coefficient rows of a matrix. I am not sure it is worth testing for this though.",
    "created_at": "2018-03-04T13:42:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327380",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:54'></a>Yes, this is more or less what I was thinking of.

If the canonical form is able to distinguish also quivers with coefficients I would suggest this algorithm:

B input matrix possibly with coefficients

Append an identity matrix to B

perfome mutations with cytonized mutate on the resulting matrix and use the last n entries in each column to distinguish matrices.

return canonical form of the resulting matrices.

This last step is not necessary if, at some stage, we find an identity matrix among the possibly permuted coefficient rows of a matrix. I am not sure it is worth testing for this though.



---

archive/issue_comments_327381.json:
```json
{
    "body": "Attachment [2018_03-CythonTestMatrixMutation.py](tarball://root/attachments/some-uuid/ticket22381/2018_03-CythonTestMatrixMutation.py) by stumpc5 created at 2018-03-05 14:33:03",
    "created_at": "2018-03-05T14:33:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327381",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

Attachment [2018_03-CythonTestMatrixMutation.py](tarball://root/attachments/some-uuid/ticket22381/2018_03-CythonTestMatrixMutation.py) by stumpc5 created at 2018-03-05 14:33:03



---

archive/issue_comments_327382.json:
```json
{
    "body": "<a id='comment:55'></a>I have provided a toy example how to do the mutations on matrices instead at https://trac.sagemath.org/raw-attachment/ticket/22381/2018_03-CythonTestMatrixMutation.py.\n\nIt is what I think is an improved version of what Salvatore and I discussed yesterday:\n\n* I do not add any artificial principal coefficients but immediately do all possible matrix mutations and check for isomorphisms along the way. Reason: we have to canonicalize all matrices in the end anyways to check for duplicates. It is thus faster to do the canonicalization immediately after finding it and discarding if already existing (so we save additional mutations).\n\n* This is now ~2 times faster that what I had before using digraph mutation, and not yet completely optimized.\n\n* On the downside, more than 50% of the time is already spent in the canonical form cython function, so there is not much improvement possible currently.\n\n* On the upside, this new code is much cleaner, since I never canonicalize the matrices themselves, but only save the hashes of their canonical forms.\n\nDespite this code, I am not convinced it is worth changing all of `mutation_class` to use this new code given that I haven't used it in years and I would certainly takes days to get this done + proper debugging afterwards.\n\nWhat do you think how to proceed here?",
    "created_at": "2018-03-05T14:43:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327382",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:55'></a>I have provided a toy example how to do the mutations on matrices instead at https://trac.sagemath.org/raw-attachment/ticket/22381/2018_03-CythonTestMatrixMutation.py.

It is what I think is an improved version of what Salvatore and I discussed yesterday:

* I do not add any artificial principal coefficients but immediately do all possible matrix mutations and check for isomorphisms along the way. Reason: we have to canonicalize all matrices in the end anyways to check for duplicates. It is thus faster to do the canonicalization immediately after finding it and discarding if already existing (so we save additional mutations).

* This is now ~2 times faster that what I had before using digraph mutation, and not yet completely optimized.

* On the downside, more than 50% of the time is already spent in the canonical form cython function, so there is not much improvement possible currently.

* On the upside, this new code is much cleaner, since I never canonicalize the matrices themselves, but only save the hashes of their canonical forms.

Despite this code, I am not convinced it is worth changing all of `mutation_class` to use this new code given that I haven't used it in years and I would certainly takes days to get this done + proper debugging afterwards.

What do you think how to proceed here?



---

archive/issue_comments_327383.json:
```json
{
    "body": "Attachment [2018_03-CythonTestMatrixMutation.2.py](tarball://root/attachments/some-uuid/ticket22381/2018_03-CythonTestMatrixMutation.2.py) by stumpc5 created at 2018-03-05 15:30:46",
    "created_at": "2018-03-05T15:30:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327383",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

Attachment [2018_03-CythonTestMatrixMutation.2.py](tarball://root/attachments/some-uuid/ticket22381/2018_03-CythonTestMatrixMutation.2.py) by stumpc5 created at 2018-03-05 15:30:46



---

archive/issue_comments_327384.json:
```json
{
    "body": "<a id='comment:56'></a>Okay, I changed to a different canonical labelling algorithm (namely `bliss`) which speeded by another factor of ~2, see https://trac.sagemath.org/attachment/ticket/22381/2018_03-CythonTestMatrixMutation.2.py . Additional advantage now is that only 10% of the time is spent on the canonicalization, so there are multiple places for improvements.",
    "created_at": "2018-03-05T15:32:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327384",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:56'></a>Okay, I changed to a different canonical labelling algorithm (namely `bliss`) which speeded by another factor of ~2, see https://trac.sagemath.org/attachment/ticket/22381/2018_03-CythonTestMatrixMutation.2.py . Additional advantage now is that only 10% of the time is spent on the canonicalization, so there are multiple places for improvements.



---

archive/issue_comments_327385.json:
```json
{
    "body": "<a id='comment:57'></a>(The reason for this time improvement is that I don't care anymore about the automorphism group since matrix mutation is fast and I can afford to do all mutations at all vertices rather than knowing the automorphism group orbits.)",
    "created_at": "2018-03-05T15:34:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327385",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:57'></a>(The reason for this time improvement is that I don't care anymore about the automorphism group since matrix mutation is fast and I can afford to do all mutations at all vertices rather than knowing the automorphism group orbits.)



---

archive/issue_comments_327386.json:
```json
{
    "body": "Attachment [2018_03-CythonTestMatrixMutation.3.py](tarball://root/attachments/some-uuid/ticket22381/2018_03-CythonTestMatrixMutation.3.py) by stumpc5 created at 2018-03-05 16:11:59",
    "created_at": "2018-03-05T16:11:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327386",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

Attachment [2018_03-CythonTestMatrixMutation.3.py](tarball://root/attachments/some-uuid/ticket22381/2018_03-CythonTestMatrixMutation.3.py) by stumpc5 created at 2018-03-05 16:11:59



---

archive/issue_comments_327387.json:
```json
{
    "body": "<a id='comment:58'></a>The newest version https://trac.sagemath.org/attachment/ticket/22381/2018_03-CythonTestMatrixMutation.3.py is now in total 6 times faster than the original implementation. Now, 1/3 of the time is spent in the `bliss` method, and 1/2 of the time is spent preparing for `bliss`.",
    "created_at": "2018-03-05T16:14:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327387",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:58'></a>The newest version https://trac.sagemath.org/attachment/ticket/22381/2018_03-CythonTestMatrixMutation.3.py is now in total 6 times faster than the original implementation. Now, 1/3 of the time is spent in the `bliss` method, and 1/2 of the time is spent preparing for `bliss`.



---

archive/issue_comments_327388.json:
```json
{
    "body": "<a id='comment:59'></a>`@`Salvatore, I have a question concerning\n\n>  Thm: B1 and B2 in the mutation class of Bp are equivalent if and only if the sets of their c-vectors coincide.\n\n\nand in particular\n\n> This last step is not necessary if, at some stage, we find an identity matrix among the possibly permuted coefficient rows of a matrix. I am not sure it is worth testing for this though. \n\n\nThis seems not correct, since I believe you need to consider c-vectors up to index permutations:\n\nConsider bipartite A3 with principal coefficients and mutable vertices 0,1,2. Then vertices 0 and 2 form an orbit of its graph automorphism group and mutating at 0 and mutating at 2 yield the same quiver, while in the first case, you have c-vectors\n\n```\n[(1, 0, 0), (0, 1, 1), (0, 0, -1)]\n```\nand in the second case\n\n```\n[(-1, 0, 0), (1, 1, 0), (0, 0, 1)]\n```\nwhich do not coincide.\n\nAm I correct that there is no situation where you can forget about the isomorphism test, or am I misunderstanding what you meant?\n\nIn type A3, we have 10 different unlabelled quivers, while your algorithm found 14 = Cat(4).",
    "created_at": "2018-03-06T08:44:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327388",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:59'></a>`@`Salvatore, I have a question concerning

>  Thm: B1 and B2 in the mutation class of Bp are equivalent if and only if the sets of their c-vectors coincide.


and in particular

> This last step is not necessary if, at some stage, we find an identity matrix among the possibly permuted coefficient rows of a matrix. I am not sure it is worth testing for this though. 


This seems not correct, since I believe you need to consider c-vectors up to index permutations:

Consider bipartite A3 with principal coefficients and mutable vertices 0,1,2. Then vertices 0 and 2 form an orbit of its graph automorphism group and mutating at 0 and mutating at 2 yield the same quiver, while in the first case, you have c-vectors

```
[(1, 0, 0), (0, 1, 1), (0, 0, -1)]
```
and in the second case

```
[(-1, 0, 0), (1, 1, 0), (0, 0, 1)]
```
which do not coincide.

Am I correct that there is no situation where you can forget about the isomorphism test, or am I misunderstanding what you meant?

In type A3, we have 10 different unlabelled quivers, while your algorithm found 14 = Cat(4).



---

archive/issue_comments_327389.json:
```json
{
    "body": "<a id='comment:60'></a>Replying to [comment:59 stumpc5]:\n> `@`Salvatore, I have a question concerning\n> \n> >  Thm: B1 and B2 in the mutation class of Bp are equivalent if and only if the sets of their c-vectors coincide.\n\n> \n> and in particular\n> \n> > This last step is not necessary if, at some stage, we find an identity matrix among the possibly permuted coefficient rows of a matrix. I am not sure it is worth testing for this though. \n\n> \n> This seems not correct, since I believe you need to consider c-vectors up to index permutations:\n> \n> Consider bipartite A3 with principal coefficients and mutable vertices 0,1,2. Then vertices 0 and 2 form an orbit of its graph automorphism group and mutating at 0 and mutating at 2 yield the same quiver, while in the first case, you have c-vectors\n> \n> ```\n> [(1, 0, 0), (0, 1, 1), (0, 0, -1)]\n> ```\n> and in the second case\n> \n> ```\n> [(-1, 0, 0), (1, 1, 0), (0, 0, 1)]\n> ```\n> which do not coincide.\n> \n> Am I correct that there is no situation where you can forget about the isomorphism test, or am I misunderstanding what you meant?\n> \n> In type A3, we have 10 different unlabelled quivers, while your algorithm found 14 = Cat(4); how did you propose to get the 10 graph (or b-matrix) isomophism types out of this?",
    "created_at": "2018-03-06T08:45:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327389",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:60'></a>Replying to [comment:59 stumpc5]:
> `@`Salvatore, I have a question concerning
> 
> >  Thm: B1 and B2 in the mutation class of Bp are equivalent if and only if the sets of their c-vectors coincide.

> 
> and in particular
> 
> > This last step is not necessary if, at some stage, we find an identity matrix among the possibly permuted coefficient rows of a matrix. I am not sure it is worth testing for this though. 

> 
> This seems not correct, since I believe you need to consider c-vectors up to index permutations:
> 
> Consider bipartite A3 with principal coefficients and mutable vertices 0,1,2. Then vertices 0 and 2 form an orbit of its graph automorphism group and mutating at 0 and mutating at 2 yield the same quiver, while in the first case, you have c-vectors
> 
> ```
> [(1, 0, 0), (0, 1, 1), (0, 0, -1)]
> ```
> and in the second case
> 
> ```
> [(-1, 0, 0), (1, 1, 0), (0, 0, 1)]
> ```
> which do not coincide.
> 
> Am I correct that there is no situation where you can forget about the isomorphism test, or am I misunderstanding what you meant?
> 
> In type A3, we have 10 different unlabelled quivers, while your algorithm found 14 = Cat(4); how did you propose to get the 10 graph (or b-matrix) isomophism types out of this?



---

archive/issue_comments_327390.json:
```json
{
    "body": "<a id='comment:61'></a>Hi Christian,\nsorry for being AFK for some time: this is quite a busy period so I am not as responsive as I should.\n\nConcerning your question I guess you are right: from the perspective of (valued) quiver up to isomorphism you should allow also index permutations of the c-vectors. The thing I had in mind was quiver isomorphism relative to fixed principal coefficients. In short my suggestion was again bullshit and you should just disregard it.\n\nI am glad that my nonsense somehow lead you to a faster/cleaner implementation anyway.\n\nAs for what you say concerning a clean implementation to be added into sage I am\nmore or less in the same boat as you. I have not used this code in years. The\nonly thing I currently use of it is the ability to transform various data into\nan exchange matrix, afterwards I only use the code we implemented with Dylan. I\nmight put some effort into reviewing a ticket should it appear but I am not\nreally motivated to write one myself.",
    "created_at": "2018-03-06T09:45:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327390",
    "user": "https://github.com/etn40ff"
}
```

<a id='comment:61'></a>Hi Christian,
sorry for being AFK for some time: this is quite a busy period so I am not as responsive as I should.

Concerning your question I guess you are right: from the perspective of (valued) quiver up to isomorphism you should allow also index permutations of the c-vectors. The thing I had in mind was quiver isomorphism relative to fixed principal coefficients. In short my suggestion was again bullshit and you should just disregard it.

I am glad that my nonsense somehow lead you to a faster/cleaner implementation anyway.

As for what you say concerning a clean implementation to be added into sage I am
more or less in the same boat as you. I have not used this code in years. The
only thing I currently use of it is the ability to transform various data into
an exchange matrix, afterwards I only use the code we implemented with Dylan. I
might put some effort into reviewing a ticket should it appear but I am not
really motivated to write one myself.



---

archive/issue_comments_327391.json:
```json
{
    "body": "<a id='comment:62'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-03-06T14:45:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327391",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:62'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327392.json:
```json
{
    "body": "<a id='comment:63'></a>I pushed what I currently have, but put this ticket on hold until #24917 is resolved.",
    "created_at": "2018-03-06T14:48:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327392",
    "user": "https://trac.sagemath.org/admin/accounts/users/stumpc5"
}
```

<a id='comment:63'></a>I pushed what I currently have, but put this ticket on hold until #24917 is resolved.



---

archive/issue_comments_327393.json:
```json
{
    "body": "<a id='comment:64'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-03-07T15:52:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327393",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:64'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327394.json:
```json
{
    "body": "<a id='comment:65'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-03-08T15:04:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327394",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:65'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327395.json:
```json
{
    "body": "<a id='comment:67'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-03-08T15:08:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327395",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:67'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327396.json:
```json
{
    "body": "<a id='comment:68'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-03-22T16:05:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327396",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:68'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_327397.json:
```json
{
    "body": "<a id='comment:69'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-11T10:01:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22381",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22381#issuecomment-327397",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:69'></a>Branch pushed to git repo; I updated commit sha1. New commits:
