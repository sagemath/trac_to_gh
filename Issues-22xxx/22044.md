# Issue 22044: fix incompatibility with py3 in autogen/pari

archive/issues_021807.json:
```json
{
    "body": "CC:  @embray @mkoeppe @jdemeyer\n\ncaused by #21613\n\nIssue created by migration from https://trac.sagemath.org/ticket/22044\n\n",
    "closed_at": "2016-12-14T15:20:11Z",
    "created_at": "2016-12-11T09:52:34Z",
    "labels": [
        "component: python3",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.5",
    "title": "fix incompatibility with py3 in autogen/pari",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22044",
    "user": "https://github.com/fchapoton"
}
```
CC:  @embray @mkoeppe @jdemeyer

caused by #21613

Issue created by migration from https://trac.sagemath.org/ticket/22044





---

archive/issue_comments_302227.json:
```json
{
    "body": "New commits:",
    "created_at": "2016-12-11T09:53:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302227",
    "user": "https://github.com/fchapoton"
}
```

New commits:



---

archive/issue_comments_302228.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-12-11T09:53:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302228",
    "user": "https://github.com/fchapoton"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_302229.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-12-11T12:51:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302229",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_302230.json:
```json
{
    "body": "This does't look right to me.  Instead you should change `pari_share` to return a string instead of bytes (by decoding the output with the system's filesystem encoding): https://github.com/sagemath/sagetrac-mirror/blob/master/src/sage_setup/autogen/pari/parser.py?id=02c50619cbb13a5c8e32a604e2e55642f5fbad4e#n41",
    "created_at": "2016-12-12T10:32:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302230",
    "user": "https://github.com/embray"
}
```

This does't look right to me.  Instead you should change `pari_share` to return a string instead of bytes (by decoding the output with the system's filesystem encoding): https://github.com/sagemath/sagetrac-mirror/blob/master/src/sage_setup/autogen/pari/parser.py?id=02c50619cbb13a5c8e32a604e2e55642f5fbad4e#n41



---

archive/issue_comments_302231.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2016-12-12T10:32:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302231",
    "user": "https://github.com/embray"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_302232.json:
```json
{
    "body": "Please take care of that in whatever way you want.",
    "created_at": "2016-12-12T10:35:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302232",
    "user": "https://github.com/fchapoton"
}
```

Please take care of that in whatever way you want.



---

archive/issue_comments_302233.json:
```json
{
    "body": "Replying to [comment:3 embray]:\n> Instead you should change `pari_share` to return a string instead of bytes\n\n\nWhy introduce an extra decoding/encoding step? The native format for filenames is `bytes` since that is what the system calls accept. If Python has to convert the filename to `bytes` anyway, why not just feed it `bytes`?",
    "created_at": "2016-12-12T12:19:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302233",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:3 embray]:
> Instead you should change `pari_share` to return a string instead of bytes


Why introduce an extra decoding/encoding step? The native format for filenames is `bytes` since that is what the system calls accept. If Python has to convert the filename to `bytes` anyway, why not just feed it `bytes`?



---

archive/issue_comments_302234.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-12-12T12:19:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302234",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_302235.json:
```json
{
    "body": "Well for one, the patch as it stands is creating an inhomogeneous list containing `bytes` and `str` object.  Of course, you can do that, but it's a little surprising and confusing.  Either treat filenames as byte strings everywhere, or nowhere (but I suggest nowhere because it is user- and developer-hostile to have to look at `bytes` objects containing non-ASCII character data :)  In fact it's more common to deal with filenames as `str` objects in Python for exactly this reason, except for right at the system boundary, or when dealing directly with binary data.\n\nIn fact there is no \"native format for filenames\" in Python in part because it's more complicated than that especially when you consider Windows--there is no one right answer to that question.  Which is why all the stdlib functions which take a filesystem path accept both bytes and unicode.\n\nIn any case, the general pattern in Python 3 with functions at the system boundary is to immediately convert from bytes to text, use text, and the convert back to bytes when going back out to the system (which in many cases, like opening files, happens transparently in Python).  The only exception is when those bytes will never, ever be used in another context, like working with file and network protocols directly.  The extra encoding/decoding steps are trivial otherwise.",
    "created_at": "2016-12-12T13:10:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302235",
    "user": "https://github.com/embray"
}
```

Well for one, the patch as it stands is creating an inhomogeneous list containing `bytes` and `str` object.  Of course, you can do that, but it's a little surprising and confusing.  Either treat filenames as byte strings everywhere, or nowhere (but I suggest nowhere because it is user- and developer-hostile to have to look at `bytes` objects containing non-ASCII character data :)  In fact it's more common to deal with filenames as `str` objects in Python for exactly this reason, except for right at the system boundary, or when dealing directly with binary data.

In fact there is no "native format for filenames" in Python in part because it's more complicated than that especially when you consider Windows--there is no one right answer to that question.  Which is why all the stdlib functions which take a filesystem path accept both bytes and unicode.

In any case, the general pattern in Python 3 with functions at the system boundary is to immediately convert from bytes to text, use text, and the convert back to bytes when going back out to the system (which in many cases, like opening files, happens transparently in Python).  The only exception is when those bytes will never, ever be used in another context, like working with file and network protocols directly.  The extra encoding/decoding steps are trivial otherwise.



---

archive/issue_comments_302236.json:
```json
{
    "body": "FWIW an easy enough workaround is to pass `universal_newlines=True` to the `subprocess.Popen`.  On Python 2 this doesn't make an enormous difference, especially in Sage since it's not likely going to be calling any programs that output CRLFs.  But on Python 3 it does make a difference since it wraps the streams in `TextIOWrapper`s, which decode bytes to text, by default using `locale.getpreferredencoding()` which is generally appropriate.",
    "created_at": "2016-12-12T13:25:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302236",
    "user": "https://github.com/embray"
}
```

FWIW an easy enough workaround is to pass `universal_newlines=True` to the `subprocess.Popen`.  On Python 2 this doesn't make an enormous difference, especially in Sage since it's not likely going to be calling any programs that output CRLFs.  But on Python 3 it does make a difference since it wraps the streams in `TextIOWrapper`s, which decode bytes to text, by default using `locale.getpreferredencoding()` which is generally appropriate.



---

archive/issue_comments_302237.json:
```json
{
    "body": "Replying to [comment:8 embray]:\n> Either treat filenames as byte strings everywhere, or nowhere (but I suggest nowhere because it is user- and developer-hostile to have to look at `bytes` objects containing non-ASCII character data :)  In fact it's more common to deal with filenames as `str` objects in Python for exactly this reason, except for right at the system boundary, or when dealing directly with binary data.\n\n\nI don't get what the problem is with treating filenames as `bytes` everywhere. It seems to me that things are least error-prone if you avoid conversions `bytes` <-> `str`.\n\n> FWIW an easy enough workaround[...]\n\n\nWhen you use `bytes`, you don't need a workaround at all.",
    "created_at": "2016-12-12T14:02:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302237",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:8 embray]:
> Either treat filenames as byte strings everywhere, or nowhere (but I suggest nowhere because it is user- and developer-hostile to have to look at `bytes` objects containing non-ASCII character data :)  In fact it's more common to deal with filenames as `str` objects in Python for exactly this reason, except for right at the system boundary, or when dealing directly with binary data.


I don't get what the problem is with treating filenames as `bytes` everywhere. It seems to me that things are least error-prone if you avoid conversions `bytes` <-> `str`.

> FWIW an easy enough workaround[...]


When you use `bytes`, you don't need a workaround at all.



---

archive/issue_comments_302238.json:
```json
{
    "body": "It's not really a \"workaround\"--poor choice of words.  What I mean is it's an easy way to go from binary to text in that context.\n\n> It seems to me that things are least error-prone if you avoid conversions bytes <-> str.\n\n\nThat's where you're wrong.  The further away bytes get from their original source, the harder it is to know where they came from or how they should be interpreted.  This compounded when you have bytes coming from multiple sources, in possibly different encodings, and you try to combine them while ignoring where they came from.  Many examples of where this can go wrong are discussed here: http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#why-not-just-assume-utf-8-and-avoid-having-to-decode-at-system-boundaries and even in the rather recent PEP 529: https://www.python.org/dev/peps/pep-0529/\n\nYou're not in poor company having doubts about this.  Armin Ronacher has written extensively about it, such as here: http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/  I don't agree with him (and for some reasons he doesn't give in his list of possible objections), but he's not without a point, and in fact has since pushed for many useful updates to Python 3 to make dealing with bytes and strings a bit less of a hassle.",
    "created_at": "2016-12-12T16:23:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302238",
    "user": "https://github.com/embray"
}
```

It's not really a "workaround"--poor choice of words.  What I mean is it's an easy way to go from binary to text in that context.

> It seems to me that things are least error-prone if you avoid conversions bytes <-> str.


That's where you're wrong.  The further away bytes get from their original source, the harder it is to know where they came from or how they should be interpreted.  This compounded when you have bytes coming from multiple sources, in possibly different encodings, and you try to combine them while ignoring where they came from.  Many examples of where this can go wrong are discussed here: http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#why-not-just-assume-utf-8-and-avoid-having-to-decode-at-system-boundaries and even in the rather recent PEP 529: https://www.python.org/dev/peps/pep-0529/

You're not in poor company having doubts about this.  Armin Ronacher has written extensively about it, such as here: http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/  I don't agree with him (and for some reasons he doesn't give in his list of possible objections), but he's not without a point, and in fact has since pushed for many useful updates to Python 3 to make dealing with bytes and strings a bit less of a hassle.



---

archive/issue_comments_302239.json:
```json
{
    "body": "Or if you want just a more practical argument, going back to my point that this is mixing bytes and strings in a single list, this easily results in something like:\n\n```pycon\n>>> paths = [b'/usr/lib', '/usr/local/lib']\n>>> filename = [os.path.join(p, 'libfoo.so') for p in paths]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 1, in <listcomp>\n  File \"/usr/lib/python3.4/posixpath.py\", line 89, in join\n    \"components\") from None\nTypeError: Can't mix strings and bytes in path components\n```\n\nAlthough that may or may not apply in *this specific* case, it's just bad practice in general for reasons like this.",
    "created_at": "2016-12-12T16:41:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302239",
    "user": "https://github.com/embray"
}
```

Or if you want just a more practical argument, going back to my point that this is mixing bytes and strings in a single list, this easily results in something like:

```pycon
>>> paths = [b'/usr/lib', '/usr/local/lib']
>>> filename = [os.path.join(p, 'libfoo.so') for p in paths]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 1, in <listcomp>
  File "/usr/lib/python3.4/posixpath.py", line 89, in join
    "components") from None
TypeError: Can't mix strings and bytes in path components
```

Although that may or may not apply in *this specific* case, it's just bad practice in general for reasons like this.



---

archive/issue_comments_302240.json:
```json
{
    "body": "Replying to [comment:11 embray]:\n> The further away bytes get from their original source, the harder it is to know where they came from or how they should be interpreted.\n\n\nEasy: as a `char *` in C. I don't see how one could get this wrong. With `str` of course, it is possible to get the encoding wrong.\n\n> This compounded when you have bytes coming from multiple sources, in possibly different encodings\n\n\nThis is not the case here.\n\n> Many examples of where this can go wrong are discussed here: http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#why-not-just-assume-utf-8-and-avoid-having-to-decode-at-system-boundaries\n\n\nThat's a general discussion about using unicode in Python. I am specifically talking about filenames\n\n> and even in the rather recent PEP 529: https://www.python.org/dev/peps/pep-0529/\n\n\nI see. If I understand things correctly, using `bytes` for filenames is currently problematic in Windows, but that would be fixed by that PEP. So it's still not a problem in the end.\n\nReplying to [comment:12 embray]:\n> Or if you want just a more practical argument, going back to my point that this is mixing bytes and strings in a single list, this easily results in something like:\n> \n> \n> ```\n> #!pycon\n> >>> paths = [b'/usr/lib', '/usr/local/lib']\n> >>> filename = [os.path.join(p, 'libfoo.so') for p in paths]\n> Traceback (most recent call last):\n>   File \"<stdin>\", line 1, in <module>\n>   File \"<stdin>\", line 1, in <listcomp>\n>   File \"/usr/lib/python3.4/posixpath.py\", line 89, in join\n>     \"components\") from None\n> TypeError: Can't mix strings and bytes in path components\n> ```\n\n\nRight. But I would argue to just use `bytes` everywhere.",
    "created_at": "2016-12-13T20:36:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302240",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:11 embray]:
> The further away bytes get from their original source, the harder it is to know where they came from or how they should be interpreted.


Easy: as a `char *` in C. I don't see how one could get this wrong. With `str` of course, it is possible to get the encoding wrong.

> This compounded when you have bytes coming from multiple sources, in possibly different encodings


This is not the case here.

> Many examples of where this can go wrong are discussed here: http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#why-not-just-assume-utf-8-and-avoid-having-to-decode-at-system-boundaries


That's a general discussion about using unicode in Python. I am specifically talking about filenames

> and even in the rather recent PEP 529: https://www.python.org/dev/peps/pep-0529/


I see. If I understand things correctly, using `bytes` for filenames is currently problematic in Windows, but that would be fixed by that PEP. So it's still not a problem in the end.

Replying to [comment:12 embray]:
> Or if you want just a more practical argument, going back to my point that this is mixing bytes and strings in a single list, this easily results in something like:
> 
> 
> ```
> #!pycon
> >>> paths = [b'/usr/lib', '/usr/local/lib']
> >>> filename = [os.path.join(p, 'libfoo.so') for p in paths]
> Traceback (most recent call last):
>   File "<stdin>", line 1, in <module>
>   File "<stdin>", line 1, in <listcomp>
>   File "/usr/lib/python3.4/posixpath.py", line 89, in join
>     "components") from None
> TypeError: Can't mix strings and bytes in path components
> ```


Right. But I would argue to just use `bytes` everywhere.



---

archive/issue_comments_302241.json:
```json
{
    "body": "Replying to [comment:11 embray]:\n> Armin Ronacher has written extensively about it, such as here: http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/\n\n\nI just read this and I agree almost with everything he says... Python 3 insists too much on unicode.\n\nOne particular pet peeve of mine not mentioned in that essay is `os.environ`. At the system level, that's just `char *` but Python 3 insists on interpreting these byte strings as unicode somehow.",
    "created_at": "2016-12-13T21:36:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302241",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:11 embray]:
> Armin Ronacher has written extensively about it, such as here: http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/


I just read this and I agree almost with everything he says... Python 3 insists too much on unicode.

One particular pet peeve of mine not mentioned in that essay is `os.environ`. At the system level, that's just `char *` but Python 3 insists on interpreting these byte strings as unicode somehow.



---

archive/issue_events_058014.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-12-13T23:55:36Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22044#event-58014"
}
```



---

archive/issue_comments_302242.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-12-13T23:55:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302242",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_302243.json:
```json
{
    "body": "Filenames are byte strings on Linux. I think there is a Windows issue somewhere here but hopefully thats ok if the path is plain ascii. Python is moving towards byte string filenames on Windows, too, to facilitate posix compatibility.",
    "created_at": "2016-12-14T00:15:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302243",
    "user": "https://github.com/vbraun"
}
```

Filenames are byte strings on Linux. I think there is a Windows issue somewhere here but hopefully thats ok if the path is plain ascii. Python is moving towards byte string filenames on Windows, too, to facilitate posix compatibility.



---

archive/issue_comments_302244.json:
```json
{
    "body": "Sorry, but no, this is absolutely wrong.  Why are you mixing bytes and str objects in a single list in application code?",
    "created_at": "2016-12-14T12:06:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302244",
    "user": "https://github.com/embray"
}
```

Sorry, but no, this is absolutely wrong.  Why are you mixing bytes and str objects in a single list in application code?



---

archive/issue_comments_302245.json:
```json
{
    "body": "Changing status from closed to new.",
    "created_at": "2016-12-14T12:06:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302245",
    "user": "https://github.com/embray"
}
```

Changing status from closed to new.



---

archive/issue_events_058015.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2016-12-14T12:06:10Z",
    "event": "reopened",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22044#event-58015"
}
```



---

archive/issue_comments_302246.json:
```json
{
    "body": "Resolution changed from fixed to ",
    "created_at": "2016-12-14T12:06:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302246",
    "user": "https://github.com/embray"
}
```

Resolution changed from fixed to 



---

archive/issue_comments_302247.json:
```json
{
    "body": "It is absolutely, 100% against the philosophy and design of Python 3 to be passing around `bytes` objects for filenames, or much anything else that isn't meant to be interacted with as binary data.  As soon as a user tries to join a (unicode) string to it all hell breaks loose.  In this specific example it is mostly irrelevant, but you're basically arguing that all filenames should be passed around in Sage as `bytes` objects which:\n\n    a) You haven't implemented yet--either be 100% consistent or go home.  To be clear, this also means that you have to fight a constant uphill battle with every Python API that returns  `str`, not `bytes` for filenames, such as `os.listdir`, `os.getcwd`, `os.curdir`, `os.sep`, and many others.  Some of these are functions that when passed bytes return bytes (which means if you want bytes you have to make sure they are *always* passed bytes regardless what some users pastes into their terminal).  In other cases they are not.\n\n    b) Is, as previously stated, not the right thing to do and is user- and developer-hostile.\n\nYou're confusing what filenames are as internally represented by the OS, and what they actually represent, semantically.  If I'm a human being, and my home directory is \"C:\\Users\\\u0440\u0438\u0433\u043e\u0301\u0440\u0438\u0439 \u041f\u0435\u0440\u0435\u043b\u044c\u043c\u0430\u0301\u043d\", then my home directory is \"C:\\Users\\\u0440\u0438\u0433\u043e\u0301\u0440\u0438\u0439 \u041f\u0435\u0440\u0435\u043b\u044c\u043c\u0430\u0301\u043d\", not `b'C:\\\\Users\\\\\\xd1\\x80\\xd0\\xb8\\xd0\\xb3\\xd0\\xbe\\xcc\\x81\\xd1\\x80\\xd0\\xb8\\xd0\\xb9 \\xd0\\x9f\\xd0\\xb5\\xd1\\x80\\xd0\\xb5\\xd0\\xbb\\xd1\\x8c\\xd0\\xbc\\xd0\\xb0\\xcc\\x81\\xd0\\xbd\\x00'`, or worse b`'\\xff\\xfeC\\x00:\\x00\\\\\\x00U\\x00s\\x00e\\x00r\\x00s\\x00\\\\\\x00`@`\\x048\\x043\\x04>\\x04\\x01\\x03`@`\\x048\\x049\\x04 \\x00\\x1f\\x045\\x04`@`\\x045\\x04;\\x04L\\x04<\\x040\\x04\\x01\\x03=\\x04'`.  That's how the computer (maybe--depending on the system I'm on or how network filesystems are mounted, etc.) sees it, but that's not what it *is*.  Decoding from bytes to unicode codepoints and operating solely on those until it has to go *back* to the OS the only consistent and safe way to treat such data.\n\nI speak from hard-fought experience here having helped lead the Python 3 porting effort of a large, 10-15 year old codebase, which interacts with legacy ASCII-based applications and file formats, and is used by international users across platforms and had to have backwards compatibility with users' assumptions that strings (i.e., when they type `\"abc\"`) are character strings, not opaque blobs of bytes.",
    "created_at": "2016-12-14T12:08:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302247",
    "user": "https://github.com/embray"
}
```

It is absolutely, 100% against the philosophy and design of Python 3 to be passing around `bytes` objects for filenames, or much anything else that isn't meant to be interacted with as binary data.  As soon as a user tries to join a (unicode) string to it all hell breaks loose.  In this specific example it is mostly irrelevant, but you're basically arguing that all filenames should be passed around in Sage as `bytes` objects which:

    a) You haven't implemented yet--either be 100% consistent or go home.  To be clear, this also means that you have to fight a constant uphill battle with every Python API that returns  `str`, not `bytes` for filenames, such as `os.listdir`, `os.getcwd`, `os.curdir`, `os.sep`, and many others.  Some of these are functions that when passed bytes return bytes (which means if you want bytes you have to make sure they are *always* passed bytes regardless what some users pastes into their terminal).  In other cases they are not.

    b) Is, as previously stated, not the right thing to do and is user- and developer-hostile.

You're confusing what filenames are as internally represented by the OS, and what they actually represent, semantically.  If I'm a human being, and my home directory is "C:\Users\риго́рий Перельма́н", then my home directory is "C:\Users\риго́рий Перельма́н", not `b'C:\\Users\\\xd1\x80\xd0\xb8\xd0\xb3\xd0\xbe\xcc\x81\xd1\x80\xd0\xb8\xd0\xb9 \xd0\x9f\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbc\xd0\xb0\xcc\x81\xd0\xbd\x00'`, or worse b`'\xff\xfeC\x00:\x00\\\x00U\x00s\x00e\x00r\x00s\x00\\\x00`@`\x048\x043\x04>\x04\x01\x03`@`\x048\x049\x04 \x00\x1f\x045\x04`@`\x045\x04;\x04L\x04<\x040\x04\x01\x03=\x04'`.  That's how the computer (maybe--depending on the system I'm on or how network filesystems are mounted, etc.) sees it, but that's not what it *is*.  Decoding from bytes to unicode codepoints and operating solely on those until it has to go *back* to the OS the only consistent and safe way to treat such data.

I speak from hard-fought experience here having helped lead the Python 3 porting effort of a large, 10-15 year old codebase, which interacts with legacy ASCII-based applications and file formats, and is used by international users across platforms and had to have backwards compatibility with users' assumptions that strings (i.e., when they type `"abc"`) are character strings, not opaque blobs of bytes.



---

archive/issue_comments_302248.json:
```json
{
    "body": "Replying to [comment:14 jdemeyer]:\n> Replying to [comment:11 embray]:\n> > Armin Ronacher has written extensively about it, such as here: http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/\n\n> \n> I just read this and I agree almost with everything he says... Python 3 insists too much on unicode.\n> \n> One particular pet peeve of mine not mentioned in that essay is `os.environ`. At the system level, that's just `char *` but Python 3 insists on interpreting these byte strings as unicode somehow.\n\n\nYou can agree with Armin, and you wouldn't be altogether wrong.  But where you are wrong is trying to defy the design and intent of Python 3.  Armin brought up these issues in part to influence how Python 3 moved forward in treating these issue more sanely to people like him who frequently work on boundary code.  However, nowhere does he argue that Python 3 should just be used incorrectly if you don't have to.",
    "created_at": "2016-12-14T12:11:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302248",
    "user": "https://github.com/embray"
}
```

Replying to [comment:14 jdemeyer]:
> Replying to [comment:11 embray]:
> > Armin Ronacher has written extensively about it, such as here: http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/

> 
> I just read this and I agree almost with everything he says... Python 3 insists too much on unicode.
> 
> One particular pet peeve of mine not mentioned in that essay is `os.environ`. At the system level, that's just `char *` but Python 3 insists on interpreting these byte strings as unicode somehow.


You can agree with Armin, and you wouldn't be altogether wrong.  But where you are wrong is trying to defy the design and intent of Python 3.  Armin brought up these issues in part to influence how Python 3 moved forward in treating these issue more sanely to people like him who frequently work on boundary code.  However, nowhere does he argue that Python 3 should just be used incorrectly if you don't have to.



---

archive/issue_comments_302249.json:
```json
{
    "body": "Replying to [comment:14 jdemeyer]:\n> One particular pet peeve of mine not mentioned in that essay is `os.environ`. At the system level, that's just `char *` but Python 3 insists on interpreting these byte strings as unicode somehow.\n\n\nIt's not \"somehow\"--it's using the `sys.getfilesystemencoding()` with surrogateescape handling, which most of the time is right.  `os.environb` was introduced to read the environment directly as bytes.",
    "created_at": "2016-12-14T12:24:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302249",
    "user": "https://github.com/embray"
}
```

Replying to [comment:14 jdemeyer]:
> One particular pet peeve of mine not mentioned in that essay is `os.environ`. At the system level, that's just `char *` but Python 3 insists on interpreting these byte strings as unicode somehow.


It's not "somehow"--it's using the `sys.getfilesystemencoding()` with surrogateescape handling, which most of the time is right.  `os.environb` was introduced to read the environment directly as bytes.



---

archive/issue_comments_302250.json:
```json
{
    "body": "Replying to [comment:20 embray]:\n> It's not \"somehow\"--it's using the `sys.getfilesystemencoding()` with surrogateescape handling, which most of the time is right.\n\n\nThe \"most of the time\" is going to bite you someday. `bytes` are never wrong.",
    "created_at": "2016-12-14T15:16:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302250",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:20 embray]:
> It's not "somehow"--it's using the `sys.getfilesystemencoding()` with surrogateescape handling, which most of the time is right.


The "most of the time" is going to bite you someday. `bytes` are never wrong.



---

archive/issue_comments_302251.json:
```json
{
    "body": "Whether you or me are right or wrong, you should **never** re-open a ticket that the release manager has closed. Feel free to continue the discussion on a new ticket or to complain directly to the release manager to revert this.",
    "created_at": "2016-12-14T15:20:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302251",
    "user": "https://github.com/jdemeyer"
}
```

Whether you or me are right or wrong, you should **never** re-open a ticket that the release manager has closed. Feel free to continue the discussion on a new ticket or to complain directly to the release manager to revert this.



---

archive/issue_comments_302252.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-12-14T15:20:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302252",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_058016.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2016-12-14T15:20:11Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/22044#event-58016"
}
```



---

archive/issue_comments_302253.json:
```json
{
    "body": "That's fair.",
    "created_at": "2016-12-15T11:40:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302253",
    "user": "https://github.com/embray"
}
```

That's fair.



---

archive/issue_comments_302254.json:
```json
{
    "body": "Replying to [comment:16 vbraun]:\n> Python is moving towards byte string filenames on Windows, too, to facilitate posix compatibility.\n\n\nThis doesn't make any sense.   In Python filenames are neither \"bytes\" or \"str\".  Python does not have a \"filename\" type (though it has been argued for in the past, and in fact there's a relevant PEP being drafted somewhere, though I think instead they went with yet another magic method of some kind :)\n\nIf you're writing code that is solely interfacing with POSIX interfaces then yes, filenames are just collections of bytes and can stay in bytes form.  But outside that narrow context you have to think about filenames in the abstract, which more-often-than-not a text string of human-readable glyphs (I think this is one thing Windows got right, though the POSIX approach has its advantages as well).  Filenames are a user-interface.  That's why they're not even stored in inodes, but rather in dirents as a convenient way for humans (and programs written and used by humans) to locate files.  While it's true in POSIX a filename can be any arbitrary sequence of bytes, and the kernel is agnostic to such sordid details as character encodings, that's an implementation choice.\n\nIn Python, although there are wrappers around POSIX interfaces, you're writing Python not POSIX, and there text is treated as text (especially in Python 3) and in most cases filenames too are text.  In order wedge the POSIX notion of \"filenames are `char` arrays\" the surrogateescape decoder allows round-tripping arbitrary bytes that can't be decoded to unicode codepoints.  The need for this in real filenames is rare--it's more commonly applicable in other contexts where the assumed encoding is not correct.",
    "created_at": "2016-12-15T11:56:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22044",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22044#issuecomment-302254",
    "user": "https://github.com/embray"
}
```

Replying to [comment:16 vbraun]:
> Python is moving towards byte string filenames on Windows, too, to facilitate posix compatibility.


This doesn't make any sense.   In Python filenames are neither "bytes" or "str".  Python does not have a "filename" type (though it has been argued for in the past, and in fact there's a relevant PEP being drafted somewhere, though I think instead they went with yet another magic method of some kind :)

If you're writing code that is solely interfacing with POSIX interfaces then yes, filenames are just collections of bytes and can stay in bytes form.  But outside that narrow context you have to think about filenames in the abstract, which more-often-than-not a text string of human-readable glyphs (I think this is one thing Windows got right, though the POSIX approach has its advantages as well).  Filenames are a user-interface.  That's why they're not even stored in inodes, but rather in dirents as a convenient way for humans (and programs written and used by humans) to locate files.  While it's true in POSIX a filename can be any arbitrary sequence of bytes, and the kernel is agnostic to such sordid details as character encodings, that's an implementation choice.

In Python, although there are wrappers around POSIX interfaces, you're writing Python not POSIX, and there text is treated as text (especially in Python 3) and in most cases filenames too are text.  In order wedge the POSIX notion of "filenames are `char` arrays" the surrogateescape decoder allows round-tripping arbitrary bytes that can't be decoded to unicode codepoints.  The need for this in real filenames is rare--it's more commonly applicable in other contexts where the assumed encoding is not correct.
