# Issue 16103: Model full subcategories

archive/issues_016103.json:
```json
{
    "body": "CC:  sage-combinat @hivert simonking @darijgr @nbruin @pjbruin @vbraun\n\nKeywords: full subcategories, homset\n\nIt has been desired for a while to be able to test, when B is a subcategory of A, whether it is a *full subcategory* or not; equivalently this is whether any A-morphism is a B-morphism (up to forgetfull functor; note that the converse always holds).\n\nThe main application is for #10668, which will let `B.homset_class` inherit from `A.homset_class` in this case and only in this case.\n\n# References\n\n- http://trac.sagemath.org/wiki/CategoriesRoadMap\n- The discussion around http://trac.sagemath.org/ticket/10668#comment:16\n- The terminology is subject to #16183\n\n# Implementation proposal\n\nFor each category `C`, we encode the following data: is `C` is a full\nsubcategory of the join of its super categories? Informally, the\nquestion is whether `C` introduces more structure or operations. For\nthe sake of the discussion, I am going to call `C` a *structure\ncategory* in this case, but a better name is to be found.\n\nHere are some of the main structure categories in Sage, and the\nstructure or main operation they introduce:\n\n- AdditiveMagmas: +\n- AdditiveMagmas.AdditiveUnital: 0\n- Magmas: *\n- Magmas.Unital: 1\n- Module: . (product by scalars)\n- Coalgebra: coproduct\n- Hopf algebra: antipode\n- Enumerated sets: a distinguished enumeration of the elements\n- Coxeter groups: distinguished coxeter generators\n- Euclidean ring: the euclidean division\n- Crystals: crystal operators\n\nPossible implementation: provide a method `C.is_structure_category()`\n(name to be found). The default implementation would return `True` for\na plain category and `False` for a CategoryWithAxiom. This would cover\nmost cases, and require to implement `foo` methods only in a few\ncategories (e.g. the Unital axiom categories).\n\nOnce we have this data encoded, we can implement recursively a\n(cached) method such as:\n\n```\n    sage: Rings().structure_super_categories()\n    {Magmas(), AdditiveMagmas()}\n```\n\n(just take the union of the structure super categories of the super\ncategories of ``self``, and add ``self`` if relevant).\n\nIt is now trivial to check whether a subcategory B of A is actually a\nfull subcategory: they just need to have the same structure super\ncategories! Hence `is_full_subcategory` can be written as:\n\n```\n    def is_full_subcategory(self, other):\n        return self.is_subcategory(other) and\n           len(self.structure_super_categories()) == len(other.structure_super_categories())\n```\n\n\n## Advantages of this proposal\n\nThis requires very little data to be encoded, and should be quite\ncheap to compute.\n\nThis is generally useful; in particular, for a user, the structure\nsuper categories together with the axioms would give an interesting\noverview of a category:\n\n```\n    sage: Rings().structure_super_categories()\n    {Magmas(), AdditiveMagmas()}\n    sage: Rings().axioms()\n    frozenset({'AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital', 'Associative', 'Distributive', 'Unital'})\n```\n\n\nIn fact, we could hope/want to always have:\n\n```\n    C is Category.join(C.structure_super_categories()).with_axioms(C.axioms())\n```\n\n\nwhich could be used e.g. for pickling by construction while exposing\nvery little implementation details.\n\n## Bonus\n\nEach structure category could name the main additional operations, so\nthat we could have something like:\n\n```\n    sage: Magmas().new_operation()\n    \"+\"\n    sage: Rings().operations()\n    {\"+\", \"0\", \"*\", \"1\"}\n```\n\nor maybe:\n\n```\n    sage: Rings().operations()\n    {Category of additive magmas: \"+\",\n     Category of additive unital additive magmas: \"0\",\n     Category of magmas: \"*\",\n     Category of unital magmas: \"1\"}\n```\n\n\n## Questions\n\n- Find good names for all the methods above\n\n- How to handle the case where the extra structure is forced by the\n  context, and automatically preserved by morphisms? E.g. the trivial\n  Euclidean structure on fields?\n\nIssue created by migration from https://trac.sagemath.org/ticket/16340\n\n",
    "created_at": "2014-05-12T21:51:51Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Model full subcategories",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16103",
    "user": "https://github.com/nthiery"
}
```
CC:  sage-combinat @hivert simonking @darijgr @nbruin @pjbruin @vbraun

Keywords: full subcategories, homset

It has been desired for a while to be able to test, when B is a subcategory of A, whether it is a *full subcategory* or not; equivalently this is whether any A-morphism is a B-morphism (up to forgetfull functor; note that the converse always holds).

The main application is for #10668, which will let `B.homset_class` inherit from `A.homset_class` in this case and only in this case.

# References

- http://trac.sagemath.org/wiki/CategoriesRoadMap
- The discussion around http://trac.sagemath.org/ticket/10668#comment:16
- The terminology is subject to #16183

# Implementation proposal

For each category `C`, we encode the following data: is `C` is a full
subcategory of the join of its super categories? Informally, the
question is whether `C` introduces more structure or operations. For
the sake of the discussion, I am going to call `C` a *structure
category* in this case, but a better name is to be found.

Here are some of the main structure categories in Sage, and the
structure or main operation they introduce:

- AdditiveMagmas: +
- AdditiveMagmas.AdditiveUnital: 0
- Magmas: *
- Magmas.Unital: 1
- Module: . (product by scalars)
- Coalgebra: coproduct
- Hopf algebra: antipode
- Enumerated sets: a distinguished enumeration of the elements
- Coxeter groups: distinguished coxeter generators
- Euclidean ring: the euclidean division
- Crystals: crystal operators

Possible implementation: provide a method `C.is_structure_category()`
(name to be found). The default implementation would return `True` for
a plain category and `False` for a CategoryWithAxiom. This would cover
most cases, and require to implement `foo` methods only in a few
categories (e.g. the Unital axiom categories).

Once we have this data encoded, we can implement recursively a
(cached) method such as:

```
    sage: Rings().structure_super_categories()
    {Magmas(), AdditiveMagmas()}
```

(just take the union of the structure super categories of the super
categories of ``self``, and add ``self`` if relevant).

It is now trivial to check whether a subcategory B of A is actually a
full subcategory: they just need to have the same structure super
categories! Hence `is_full_subcategory` can be written as:

```
    def is_full_subcategory(self, other):
        return self.is_subcategory(other) and
           len(self.structure_super_categories()) == len(other.structure_super_categories())
```


## Advantages of this proposal

This requires very little data to be encoded, and should be quite
cheap to compute.

This is generally useful; in particular, for a user, the structure
super categories together with the axioms would give an interesting
overview of a category:

```
    sage: Rings().structure_super_categories()
    {Magmas(), AdditiveMagmas()}
    sage: Rings().axioms()
    frozenset({'AdditiveAssociative', 'AdditiveCommutative', 'AdditiveInverse', 'AdditiveUnital', 'Associative', 'Distributive', 'Unital'})
```


In fact, we could hope/want to always have:

```
    C is Category.join(C.structure_super_categories()).with_axioms(C.axioms())
```


which could be used e.g. for pickling by construction while exposing
very little implementation details.

## Bonus

Each structure category could name the main additional operations, so
that we could have something like:

```
    sage: Magmas().new_operation()
    "+"
    sage: Rings().operations()
    {"+", "0", "*", "1"}
```

or maybe:

```
    sage: Rings().operations()
    {Category of additive magmas: "+",
     Category of additive unital additive magmas: "0",
     Category of magmas: "*",
     Category of unital magmas: "1"}
```


## Questions

- Find good names for all the methods above

- How to handle the case where the extra structure is forced by the
  context, and automatically preserved by morphisms? E.g. the trivial
  Euclidean structure on fields?

Issue created by migration from https://trac.sagemath.org/ticket/16340





---

archive/issue_comments_209720.json:
```json
{
    "body": "Suggestions anyone before I start implementing this?\n\nCheers,",
    "created_at": "2014-05-13T21:34:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209720",
    "user": "https://github.com/nthiery"
}
```

Suggestions anyone before I start implementing this?

Cheers,



---

archive/issue_comments_209721.json:
```json
{
    "body": "Ideally, for every piece of algebraic structure there should be both a full and a fully structure-aware subcategory. So there should be a UnitalAlgebrasWithUnitalMorphisms and a UnitalAlgebrasWithArbitraryMorphisms, etc.; more importantly, there should be categories for graded modules with graded morphisms and with arbitrary morphisms (I don't remember out of the hat which is the one we have) and categories for modules-with-basis with basis-preserving morphisms and with arbitrary morphisms etc.. This might not belong into this ticket, but please make sure that your model takes this into account and does not handle fullness as a hardcoded property of the relevant axiom / functorial construct.\n\nOther than this I like the proposal!",
    "created_at": "2014-05-14T02:32:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209721",
    "user": "https://github.com/darijgr"
}
```

Ideally, for every piece of algebraic structure there should be both a full and a fully structure-aware subcategory. So there should be a UnitalAlgebrasWithUnitalMorphisms and a UnitalAlgebrasWithArbitraryMorphisms, etc.; more importantly, there should be categories for graded modules with graded morphisms and with arbitrary morphisms (I don't remember out of the hat which is the one we have) and categories for modules-with-basis with basis-preserving morphisms and with arbitrary morphisms etc.. This might not belong into this ticket, but please make sure that your model takes this into account and does not handle fullness as a hardcoded property of the relevant axiom / functorial construct.

Other than this I like the proposal!



---

archive/issue_comments_209722.json:
```json
{
    "body": "Is it possible to have a proper subcategory (within Sage) which has the same number, but actually different set, of operators (i.e. is `len` a sufficient check or do we need to compare sorted lists)? I'm pretty sure this is mathematically wrong, but can someone confirm.",
    "created_at": "2014-05-14T03:58:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209722",
    "user": "https://github.com/tscrim"
}
```

Is it possible to have a proper subcategory (within Sage) which has the same number, but actually different set, of operators (i.e. is `len` a sufficient check or do we need to compare sorted lists)? I'm pretty sure this is mathematically wrong, but can someone confirm.



---

archive/issue_comments_209723.json:
```json
{
    "body": "Replying to [comment:2 darij]:\n> Ideally, for every piece of algebraic structure there should be both a full and a fully structure-aware subcategory. So there should be a UnitalAlgebrasWithUnitalMorphisms and a UnitalAlgebrasWithArbitraryMorphisms, etc.; more importantly, there should be categories for graded modules with graded morphisms and with arbitrary morphisms (I don't remember out of the hat which is the one we have) and categories for modules-with-basis with basis-preserving morphisms and with arbitrary morphisms etc.\n\nAgreed.\n\n> This might not belong into this ticket, but please make sure that your model takes this into account and does not handle fullness as a hardcoded property of the relevant axiom / functorial construct.\n\nI guess that's alright: when we will want both, we will just need to\nhave two distinct categories/axioms/functorial construction for the\ntwo situations. I am missing a good idiom / naming convention though.\n\nIn the mean time, the current implementation makes a default choice on\na case by case basis, according to the foreseen main use case for the\ncategory (see the doc).\n\n> Other than this I like the proposal!\n\nCool. I just pushed a first attempt. It's probably reasonably\ncomplete. The main things that need discussion are:\n\n- Terminology and method names\n\n- Are there categories which need special handling that I missed?\n\n- The default choices I have made.\n\nCheers,\n                                   Nicolas\n----\nLast 10 new commits:",
    "created_at": "2014-05-14T20:56:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209723",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:2 darij]:
> Ideally, for every piece of algebraic structure there should be both a full and a fully structure-aware subcategory. So there should be a UnitalAlgebrasWithUnitalMorphisms and a UnitalAlgebrasWithArbitraryMorphisms, etc.; more importantly, there should be categories for graded modules with graded morphisms and with arbitrary morphisms (I don't remember out of the hat which is the one we have) and categories for modules-with-basis with basis-preserving morphisms and with arbitrary morphisms etc.

Agreed.

> This might not belong into this ticket, but please make sure that your model takes this into account and does not handle fullness as a hardcoded property of the relevant axiom / functorial construct.

I guess that's alright: when we will want both, we will just need to
have two distinct categories/axioms/functorial construction for the
two situations. I am missing a good idiom / naming convention though.

In the mean time, the current implementation makes a default choice on
a case by case basis, according to the foreseen main use case for the
category (see the doc).

> Other than this I like the proposal!

Cool. I just pushed a first attempt. It's probably reasonably
complete. The main things that need discussion are:

- Terminology and method names

- Are there categories which need special handling that I missed?

- The default choices I have made.

Cheers,
                                   Nicolas
----
Last 10 new commits:



---

archive/issue_comments_209724.json:
```json
{
    "body": "Replying to [comment:3 tscrim]:\n> Is it possible to have a proper subcategory (within Sage) which has the same number, but actually different set, of operators (i.e. is `len` a sufficient check or do we need to compare sorted lists)? I'm pretty sure this is mathematically wrong, but can someone confirm.\n\nIn the current implementation, we are comparing the set of all super categories that define some structure. This set can only become larger for inclusion when going down the category hierarchy. So technically we are fine.\n\nAnd this implementation seems to correctly models the mathematics, right?",
    "created_at": "2014-05-14T20:59:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209724",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:3 tscrim]:
> Is it possible to have a proper subcategory (within Sage) which has the same number, but actually different set, of operators (i.e. is `len` a sufficient check or do we need to compare sorted lists)? I'm pretty sure this is mathematically wrong, but can someone confirm.

In the current implementation, we are comparing the set of all super categories that define some structure. This set can only become larger for inclusion when going down the category hierarchy. So technically we are fine.

And this implementation seems to correctly models the mathematics, right?



---

archive/issue_comments_209725.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-05-14T21:00:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209725",
    "user": "https://github.com/nthiery"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_209726.json:
```json
{
    "body": "I haven't had time to look at this in detail, but at first sight it looks like a good approach to me.\n\nFor me the main point to think about is the terminology \"structure category\".  It would be nice if the name made it slightly clearer that this property is not so much about the category itself as about its relation to its supercategories.  (Some random alternative names for `is_structure_category()`: `adds_structure()`? `is_augmented_category()`? `is_enriched_category()`?)",
    "created_at": "2014-05-14T21:27:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209726",
    "user": "https://github.com/pjbruin"
}
```

I haven't had time to look at this in detail, but at first sight it looks like a good approach to me.

For me the main point to think about is the terminology "structure category".  It would be nice if the name made it slightly clearer that this property is not so much about the category itself as about its relation to its supercategories.  (Some random alternative names for `is_structure_category()`: `adds_structure()`? `is_augmented_category()`? `is_enriched_category()`?)



---

archive/issue_comments_209727.json:
```json
{
    "body": "Replying to [comment:8 pbruin]:\n> For me the main point to think about is the terminology \"structure category\".\n> It would be nice if the name made it slightly clearer that this property is not so much about the category itself as about its relation to its supercategories. \n\nDefinitely!\n\n> (Some random alternative names for `is_structure_category()`: `adds_structure()`? `is_augmented_category()`? `is_enriched_category()`?)\n\nAlso, instead of an \"is_...\" method, we could name the method something like `additional_structure` and have it return something possibly meaningfull, like \"*\" for magmas or \"+\" for additive magmas, and None if there is none. It would still evaluate appropriately to True/False in boolean context.",
    "created_at": "2014-05-14T22:17:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209727",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:8 pbruin]:
> For me the main point to think about is the terminology "structure category".
> It would be nice if the name made it slightly clearer that this property is not so much about the category itself as about its relation to its supercategories. 

Definitely!

> (Some random alternative names for `is_structure_category()`: `adds_structure()`? `is_augmented_category()`? `is_enriched_category()`?)

Also, instead of an "is_..." method, we could name the method something like `additional_structure` and have it return something possibly meaningfull, like "*" for magmas or "+" for additive magmas, and None if there is none. It would still evaluate appropriately to True/False in boolean context.



---

archive/issue_comments_209728.json:
```json
{
    "body": "Replying to [comment:9 nthiery]:\n> Also, instead of an \"is_...\" method, we could name the method something like `additional_structure` and have it return something possibly meaningfull, like \"*\" for magmas or \"+\" for additive magmas, and None if there is none.\n\nOr, even more informative: Return a pair `(op, method)`, such that\n- `op` is the operator (either as in `operator.contains`, `operator.mul`, `operator.and`, or a  parent/element method such as `an_element`), and\n- `method` is an abstract parent/element method that has to be implemented for `op` (i.e., `__contains__`, `_mul_`, or `_an_element`)",
    "created_at": "2014-05-15T12:40:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209728",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:9 nthiery]:
> Also, instead of an "is_..." method, we could name the method something like `additional_structure` and have it return something possibly meaningfull, like "*" for magmas or "+" for additive magmas, and None if there is none.

Or, even more informative: Return a pair `(op, method)`, such that
- `op` is the operator (either as in `operator.contains`, `operator.mul`, `operator.and`, or a  parent/element method such as `an_element`), and
- `method` is an abstract parent/element method that has to be implemented for `op` (i.e., `__contains__`, `_mul_`, or `_an_element`)



---

archive/issue_comments_209729.json:
```json
{
    "body": "Replying to [comment:10 SimonKing]:\n> Or, even more informative: Return a pair `(op, method)`, such that\n> - `op` is the operator (either as in `operator.contains`, `operator.mul`, `operator.and`, or a  parent/element method such as `an_element`), and\n> - `method` is an abstract parent/element method that has to be implemented for `op` (i.e., `__contains__`, `_mul_`, or `_an_element`)\n\nPossibly so indeed. Although this would be duplicating a bit the job\nof `required_methods`. I am not sure we want to put a specific\nemphasis on the methods related to an operation that adds structure\n(e.g. '+') or that does not (e.g. '-').\n\nSpeaking of which: see #16363.",
    "created_at": "2014-05-16T16:27:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209729",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:10 SimonKing]:
> Or, even more informative: Return a pair `(op, method)`, such that
> - `op` is the operator (either as in `operator.contains`, `operator.mul`, `operator.and`, or a  parent/element method such as `an_element`), and
> - `method` is an abstract parent/element method that has to be implemented for `op` (i.e., `__contains__`, `_mul_`, or `_an_element`)

Possibly so indeed. Although this would be duplicating a bit the job
of `required_methods`. I am not sure we want to put a specific
emphasis on the methods related to an operation that adds structure
(e.g. '+') or that does not (e.g. '-').

Speaking of which: see #16363.



---

archive/issue_comments_209730.json:
```json
{
    "body": "Any other suggestions for the terminology? At this point, I am leaning toward `additional_structure`. But there remains to name \"structure categories\", and the method returning all the super \"structure categories\".",
    "created_at": "2014-05-16T16:30:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209730",
    "user": "https://github.com/nthiery"
}
```

Any other suggestions for the terminology? At this point, I am leaning toward `additional_structure`. But there remains to name "structure categories", and the method returning all the super "structure categories".



---

archive/issue_comments_209731.json:
```json
{
    "body": "One thing I don't know how to handle. Assume we want the morphisms of euclidean rings to preserve euclidean division (I'd say that this is equivalent to preserving the degree). Then, `EuclideanDomains()` is not a full subcategory of `Rings()`. Yet `Fields()`, which is a subcategory of `EuclideanDomains()`, is a full subcategory of `Rings()`. This is because the additional structure defined by `EuclideanDomains()` (the degree) is trivial in this case.\n\nWe can't model this in the current implementation. An approach might be to have `Fields()` explicitly remove `EuclideanDomains()` from its structure categories. But then we have to be more careful in the full subcategory test. Maybe we can test, for B a subcategory of A that `B.super_structure_categories()` is a subset of `A.super_structure_categories()`; given that we hash and check for equality by id, that should be fast enough if deemed correct.\n\nA similar situation appears for graded connected hopf algebras where there is a single choice for the antipode (and, IIRC, it's preserved for free by bialgebra morphisms). So this is a full subcategory of the category of bialgebras.\n\nCheers,\n                                              Nicolas",
    "created_at": "2014-05-16T16:42:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209731",
    "user": "https://github.com/nthiery"
}
```

One thing I don't know how to handle. Assume we want the morphisms of euclidean rings to preserve euclidean division (I'd say that this is equivalent to preserving the degree). Then, `EuclideanDomains()` is not a full subcategory of `Rings()`. Yet `Fields()`, which is a subcategory of `EuclideanDomains()`, is a full subcategory of `Rings()`. This is because the additional structure defined by `EuclideanDomains()` (the degree) is trivial in this case.

We can't model this in the current implementation. An approach might be to have `Fields()` explicitly remove `EuclideanDomains()` from its structure categories. But then we have to be more careful in the full subcategory test. Maybe we can test, for B a subcategory of A that `B.super_structure_categories()` is a subset of `A.super_structure_categories()`; given that we hash and check for equality by id, that should be fast enough if deemed correct.

A similar situation appears for graded connected hopf algebras where there is a single choice for the antipode (and, IIRC, it's preserved for free by bialgebra morphisms). So this is a full subcategory of the category of bialgebras.

Cheers,
                                              Nicolas



---

archive/issue_comments_209732.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-17T21:19:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209732",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209733.json:
```json
{
    "body": "\n```\nError building the documentation.\nTraceback (most recent call last):\n  File \"/home/ralf/sage/src/doc/common/builder.py\", line 1477, in <module>\n    getattr(get_builder(name), type)()\n  File \"/home/ralf/sage/src/doc/common/builder.py\", line 276, in _wrapper\n    getattr(get_builder(document), 'inventory')(*args, **kwds)\n  File \"/home/ralf/sage/src/doc/common/builder.py\", line 487, in _wrapper\n    x.get(99999)\n  File \"/home/ralf/sage/local/lib/python/multiprocessing/pool.py\", line 554, in get\n    raise self._value\nOSError: [categorie] /home/ralf/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:docstring of sage.categories.category_with_axiom.CategoryWithAxiom.is_structure_category:7: WARNING: Literal block expected; none found.\n\nmake: *** [doc-html] Error 1\n```\n",
    "created_at": "2014-05-18T16:14:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209733",
    "user": "https://github.com/rwst"
}
```


```
Error building the documentation.
Traceback (most recent call last):
  File "/home/ralf/sage/src/doc/common/builder.py", line 1477, in <module>
    getattr(get_builder(name), type)()
  File "/home/ralf/sage/src/doc/common/builder.py", line 276, in _wrapper
    getattr(get_builder(document), 'inventory')(*args, **kwds)
  File "/home/ralf/sage/src/doc/common/builder.py", line 487, in _wrapper
    x.get(99999)
  File "/home/ralf/sage/local/lib/python/multiprocessing/pool.py", line 554, in get
    raise self._value
OSError: [categorie] /home/ralf/sage/local/lib/python2.7/site-packages/sage/categories/category_with_axiom.py:docstring of sage.categories.category_with_axiom.CategoryWithAxiom.is_structure_category:7: WARNING: Literal block expected; none found.

make: *** [doc-html] Error 1
```




---

archive/issue_comments_209734.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-05-18T16:14:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209734",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_209735.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-18T20:40:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209735",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209736.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-21T01:31:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209736",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209737.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-07-02T15:44:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209737",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_209738.json:
```json
{
    "body": "There are some failing doctests, see patchbot report.",
    "created_at": "2014-07-26T12:02:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209738",
    "user": "https://github.com/fchapoton"
}
```

There are some failing doctests, see patchbot report.



---

archive/issue_comments_209739.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-07-26T12:02:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209739",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_209740.json:
```json
{
    "body": "I've fixed the trivial doctest failures in `category.py`. I get the same warning messages about the stack size using `develop` and I don't see any additional memory usage without this branch (so I'd say we can ignore those). I don't get any of the other failures.\n----\nNew commits:",
    "created_at": "2014-08-06T13:18:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209740",
    "user": "https://github.com/tscrim"
}
```

I've fixed the trivial doctest failures in `category.py`. I get the same warning messages about the stack size using `develop` and I don't see any additional memory usage without this branch (so I'd say we can ignore those). I don't get any of the other failures.
----
New commits:



---

archive/issue_comments_209741.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-08-06T13:18:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209741",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_events_048163.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16103#event-48163"
}
```



---

archive/issue_comments_209742.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-08-15T08:55:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209742",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209743.json:
```json
{
    "body": "Simon, could you review this ticket since we need it for other applications? Thanks!",
    "created_at": "2014-08-15T13:12:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209743",
    "user": "https://github.com/anneschilling"
}
```

Simon, could you review this ticket since we need it for other applications? Thanks!



---

archive/issue_comments_209744.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-08-16T08:03:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209744",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209745.json:
```json
{
    "body": "I put here for the record a summary of a private discussion by e-mail.\n\nDarij:\n\nI don't see any better names than \"full\" and \"structure\" subcategory.\nIn my opinion, these are clear and don't conflict with common usage.\nWhile I am still not very keen on the name \"subcategory\" itself, we\ncan keep the \"full\" and \"structure\" adjectives even if we change it.\n\nTravis:\n\nThis is the big thing that we needed. I can do the rest of the\nreview at this point I think. However thanks for looking things over\nand giving us your notes.\n\nDarij:\n\n<pointing to the limitation now explicitly mentioned in the description of the ticket>\n\nNicolas:\n\nI believe that this limitation could be raised, though at this point I\ndon't quite know what's the best approach. I also don't see a critical\nneed (it's already a good progress). So, as long as it's properly\ndocumented (I just reworked that piece of the documentation; now it's\nup to you guys to judge), I think that's fine for now.",
    "created_at": "2014-08-16T08:23:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209745",
    "user": "https://github.com/nthiery"
}
```

I put here for the record a summary of a private discussion by e-mail.

Darij:

I don't see any better names than "full" and "structure" subcategory.
In my opinion, these are clear and don't conflict with common usage.
While I am still not very keen on the name "subcategory" itself, we
can keep the "full" and "structure" adjectives even if we change it.

Travis:

This is the big thing that we needed. I can do the rest of the
review at this point I think. However thanks for looking things over
and giving us your notes.

Darij:

<pointing to the limitation now explicitly mentioned in the description of the ticket>

Nicolas:

I believe that this limitation could be raised, though at this point I
don't quite know what's the best approach. I also don't see a critical
need (it's already a good progress). So, as long as it's properly
documented (I just reworked that piece of the documentation; now it's
up to you guys to judge), I think that's fine for now.



---

archive/issue_comments_209746.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-08-16T08:24:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209746",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209747.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-10T21:24:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209747",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209748.json:
```json
{
    "body": "I made some other categories into non-structure categories. This made me wonder if we actually want the default category be a structure category. Yet I don't think we have enough data currently to answer this right now. I'm going to double-check to make sure I didn't miss any others and I'd appreciate if someone else could do the same. Otherwise I think we're okay to positive review it.\n\nDarij, I've added you as a reviewer since you did look over the code and give suggestions.",
    "created_at": "2014-09-10T21:29:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209748",
    "user": "https://github.com/tscrim"
}
```

I made some other categories into non-structure categories. This made me wonder if we actually want the default category be a structure category. Yet I don't think we have enough data currently to answer this right now. I'm going to double-check to make sure I didn't miss any others and I'd appreciate if someone else could do the same. Otherwise I think we're okay to positive review it.

Darij, I've added you as a reviewer since you did look over the code and give suggestions.



---

archive/issue_comments_209749.json:
```json
{
    "body": "Is it clear that the \"structure category\" terminology is the way to go?  Personally I still don't like it very much (again, it pretends to be about categories but instead is about relations to their supercategories).  I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.",
    "created_at": "2014-09-11T12:09:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209749",
    "user": "https://github.com/pjbruin"
}
```

Is it clear that the "structure category" terminology is the way to go?  Personally I still don't like it very much (again, it pretends to be about categories but instead is about relations to their supercategories).  I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.



---

archive/issue_comments_209750.json:
```json
{
    "body": "Replying to [comment:30 pbruin]:\n> Is it clear that the \"structure category\" terminology is the way to go?  Personally I still don't like it very much (again, it pretends to be about categories but instead is about relations to their supercategories).\n\nIt's more of there has been no better alternative proposed. If we move away from the terminology \"structure category\", then I feel like we loose the ability to name methods like `all_structure_super_categories`. However I do understand your objection.\n\n> I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.\n\nCurrently the default is that new subcategories are structure categories (so they are not full subcategories). If we were to go with returning pairs `(op, method)`, then the question becomes do we want the default to be `False` or do we allow `True` to remain the default and have it be when we can't adequately define the structure?\n\nActually, that made me have a thought. How about instead of `is_structure_category` we have `has_additional_structure`, and then we could extend this to `additional_structure` (on a followup ticket).",
    "created_at": "2014-09-11T16:48:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209750",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:30 pbruin]:
> Is it clear that the "structure category" terminology is the way to go?  Personally I still don't like it very much (again, it pretends to be about categories but instead is about relations to their supercategories).

It's more of there has been no better alternative proposed. If we move away from the terminology "structure category", then I feel like we loose the ability to name methods like `all_structure_super_categories`. However I do understand your objection.

> I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.

Currently the default is that new subcategories are structure categories (so they are not full subcategories). If we were to go with returning pairs `(op, method)`, then the question becomes do we want the default to be `False` or do we allow `True` to remain the default and have it be when we can't adequately define the structure?

Actually, that made me have a thought. How about instead of `is_structure_category` we have `has_additional_structure`, and then we could extend this to `additional_structure` (on a followup ticket).



---

archive/issue_comments_209751.json:
```json
{
    "body": "Hi Travis,\n> Replying to [comment:30 pbruin]:\n> > Is it clear that the \"structure category\" terminology is the way to go?  Personally I still don't like it very much (again, it pretends to be about categories but instead is about relations to their supercategories).\n> \n> It's more of there has been no better alternative proposed. If we move away from the terminology \"structure category\", then I feel like we loose the ability to name methods like `all_structure_super_categories`. However I do understand your objection.\nAfter looking at the code, I actually have the feeling that this `all_structure_super_categories()` method is a somewhat unnatural solution to the question of determining whether one category is a full subcategory of another.   At first sight it looks like a category should be able to simply declare if is it a full subcategory of its supercategories (for each supercategory individually, if necessary).  Then `is_full_subcategory()`, given two categories, could check if there is a sequence of full subcategory inclusions between the two categories.\n> > I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.\n> \n> Currently the default is that new subcategories are structure categories (so they are not full subcategories). If we were to go with returning pairs `(op, method)`, then the question becomes do we want the default to be `False` or do we allow `True` to remain the default and have it be when we can't adequately define the structure?\nHmm, it doesn't sound very desirable to define a category where you can't define what its extra structure is...\n> Actually, that made me have a thought. How about instead of `is_structure_category` we have `has_additional_structure`, and then we could extend this to `additional_structure` (on a followup ticket).\nThis sounds good.  We could go even further and formalise the notion of category with extra structure, so we would have\n1. `CategoryWithAxiom`: like the existing class, but more restrictive.  Specifies an additional axiom to be satisfied by the objects, and defines the full subcategory objects satisfying this axiom.  For example, commutativity for groups.\n2. `CategoryWithStructure`: proposed new class.  Specifies an additional structure on objects that must be preserved by morphisms, and defines a usually non-full subcategory.\nIn certain cases something that is now called an axiom would become an extra structure.  For example (thinking about the discussion on #16843) the `Unital` property for rings (as a subcategory of `Rngs`) would become a structure instead of an axiom, because morphisms are restricted by the requirement that they preserve the unit element.",
    "created_at": "2014-09-12T08:50:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209751",
    "user": "https://github.com/pjbruin"
}
```

Hi Travis,
> Replying to [comment:30 pbruin]:
> > Is it clear that the "structure category" terminology is the way to go?  Personally I still don't like it very much (again, it pretends to be about categories but instead is about relations to their supercategories).
> 
> It's more of there has been no better alternative proposed. If we move away from the terminology "structure category", then I feel like we loose the ability to name methods like `all_structure_super_categories`. However I do understand your objection.
After looking at the code, I actually have the feeling that this `all_structure_super_categories()` method is a somewhat unnatural solution to the question of determining whether one category is a full subcategory of another.   At first sight it looks like a category should be able to simply declare if is it a full subcategory of its supercategories (for each supercategory individually, if necessary).  Then `is_full_subcategory()`, given two categories, could check if there is a sequence of full subcategory inclusions between the two categories.
> > I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.
> 
> Currently the default is that new subcategories are structure categories (so they are not full subcategories). If we were to go with returning pairs `(op, method)`, then the question becomes do we want the default to be `False` or do we allow `True` to remain the default and have it be when we can't adequately define the structure?
Hmm, it doesn't sound very desirable to define a category where you can't define what its extra structure is...
> Actually, that made me have a thought. How about instead of `is_structure_category` we have `has_additional_structure`, and then we could extend this to `additional_structure` (on a followup ticket).
This sounds good.  We could go even further and formalise the notion of category with extra structure, so we would have
1. `CategoryWithAxiom`: like the existing class, but more restrictive.  Specifies an additional axiom to be satisfied by the objects, and defines the full subcategory objects satisfying this axiom.  For example, commutativity for groups.
2. `CategoryWithStructure`: proposed new class.  Specifies an additional structure on objects that must be preserved by morphisms, and defines a usually non-full subcategory.
In certain cases something that is now called an axiom would become an extra structure.  For example (thinking about the discussion on #16843) the `Unital` property for rings (as a subcategory of `Rngs`) would become a structure instead of an axiom, because morphisms are restricted by the requirement that they preserve the unit element.



---

archive/issue_comments_209752.json:
```json
{
    "body": "Replying to [comment:29 tscrim]:\n> I made some other categories into non-structure categories.\n\nThanks. I double checked on this, and mostly agree up to one point: I\nthink Coxeter Groups should be a structure category, the extra\nstructure being the chosen set of simple generators.\n\n> This made me wonder if we actually want the default category be a\n> structure category.\n\nI believe this would be dangerous. Being accidently a structure\ncategory means that your homsets will miss some code that could be\navailable. So just a missing feature. Whereas being accidently a non\nstructure category can let your homset inherit from code that is not\napplicable which can lead to wrong code.\n\nBesides, all the categories your changed should actually become\nCategoryWithAxioms at some point, which will have precisely the\ndesired effect.\n\nSo now one could wonder whether having a CategoryWithAxiom be a non\nstructure category is not a dangerous default. I believe it's ok,\nbecause for a category with axiom A.B, one only has to be careful\nabout being a full subcategory or not if A is the category defining\nthe axiom B. There are not soo many of them.\n\n> I'm going to double-check to make sure I didn't miss any others and\n> I'd appreciate if someone else could do the same.\n\nThanks!\n\nCheers,\n                                Nicolas",
    "created_at": "2014-09-12T16:03:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209752",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:29 tscrim]:
> I made some other categories into non-structure categories.

Thanks. I double checked on this, and mostly agree up to one point: I
think Coxeter Groups should be a structure category, the extra
structure being the chosen set of simple generators.

> This made me wonder if we actually want the default category be a
> structure category.

I believe this would be dangerous. Being accidently a structure
category means that your homsets will miss some code that could be
available. So just a missing feature. Whereas being accidently a non
structure category can let your homset inherit from code that is not
applicable which can lead to wrong code.

Besides, all the categories your changed should actually become
CategoryWithAxioms at some point, which will have precisely the
desired effect.

So now one could wonder whether having a CategoryWithAxiom be a non
structure category is not a dangerous default. I believe it's ok,
because for a category with axiom A.B, one only has to be careful
about being a full subcategory or not if A is the category defining
the axiom B. There are not soo many of them.

> I'm going to double-check to make sure I didn't miss any others and
> I'd appreciate if someone else could do the same.

Thanks!

Cheers,
                                Nicolas



---

archive/issue_comments_209753.json:
```json
{
    "body": "Replying to [comment:32 pbruin]:\n\n> At first sight it looks like a category should be able to simply\n> declare if is it a full subcategory of its supercategories (for each\n> supercategory individually, if necessary).  Then\n> `is_full_subcategory()`, given two categories, could check if there is\n> a sequence of full subcategory inclusions between the two categories.\n\nThat was the original plan, but this means having to encode much more\ninformation. And it's quite more costly to compute.\n\n\n\n\n> > > I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.\n> > \n> > Currently the default is that new subcategories are structure categories (so they are not full subcategories). If we were to go with returning pairs `(op, method)`, then the question becomes do we want the default to be `False` or do we allow `True` to remain the default and have it be when we can't adequately define the structure?\n\n\n> Hmm, it doesn't sound very desirable to define a category where you can't define what its extra structure is...\n\nBut this is imposing the category writer to do implement one more\nthing, when implementing a category is already a barrier.  Being a\nfull subcategory only adds extra features to homsets. In most cases,\nwhen implementing a category for the first time, one does not need\nthis feature. So being able to just not have to worry about it is a\ndefinite plus.\n\n\n> > Actually, that made me have a thought. How about instead of `is_structure_category` we have `has_additional_structure`, and then we could extend this to `additional_structure` (on a followup ticket).\n\nPossibly so. What would be the names for all the related methods (like\n`all_structure_categories`)?\n\n> This sounds good.  We could go even further and formalise the notion of category with extra structure, so we would have\n> 1. `CategoryWithAxiom`: like the existing class, but more restrictive.  Specifies an additional axiom to be satisfied by the objects, and defines the full subcategory objects satisfying this axiom.  For example, commutativity for groups.\n> 2. `CategoryWithStructure`: proposed new class.  Specifies an additional structure on objects that must be preserved by morphisms, and defines a usually non-full subcategory.\n> In certain cases something that is now called an axiom would become an extra structure.  For example (thinking about the discussion on #16843) the `Unital` property for rings (as a subcategory of `Rngs`) would become a structure instead of an axiom, because morphisms are restricted by the requirement that they preserve the unit element.\n\nWe want Unital to have all the other features of axioms like:\n\n```\n    sage: Rngs() & Semigroups().Unital()\n    Category of Rings\n```\n\n\nSo this would require a more complicated hierarchy of classes,\nespecially since one would also need to take care of the\nover_base_ring variations. I am not sure this is worth it for just a\nsingle method.\n\nBy the way: `Semigroups().Unital()` is indeed a structure\ncategory. But not `Rngs().Unital()`: all the structure is defined in\nthe super categories `Rngs()` and `Semigroups().Unital()`.\n\nAlso: there is room for improvement in functorial constructions: in\nsome cases, we could automatically deduce that the category is a\nstructure category. I believe this is easier to implement by mean of\nmethods than by inheriting from one class or the other (and past has\nproven that I can live with class surgery when needed).\n\nCheers,\n                                 Nicolas",
    "created_at": "2014-09-12T16:24:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209753",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:32 pbruin]:

> At first sight it looks like a category should be able to simply
> declare if is it a full subcategory of its supercategories (for each
> supercategory individually, if necessary).  Then
> `is_full_subcategory()`, given two categories, could check if there is
> a sequence of full subcategory inclusions between the two categories.

That was the original plan, but this means having to encode much more
information. And it's quite more costly to compute.




> > > I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.
> > 
> > Currently the default is that new subcategories are structure categories (so they are not full subcategories). If we were to go with returning pairs `(op, method)`, then the question becomes do we want the default to be `False` or do we allow `True` to remain the default and have it be when we can't adequately define the structure?


> Hmm, it doesn't sound very desirable to define a category where you can't define what its extra structure is...

But this is imposing the category writer to do implement one more
thing, when implementing a category is already a barrier.  Being a
full subcategory only adds extra features to homsets. In most cases,
when implementing a category for the first time, one does not need
this feature. So being able to just not have to worry about it is a
definite plus.


> > Actually, that made me have a thought. How about instead of `is_structure_category` we have `has_additional_structure`, and then we could extend this to `additional_structure` (on a followup ticket).

Possibly so. What would be the names for all the related methods (like
`all_structure_categories`)?

> This sounds good.  We could go even further and formalise the notion of category with extra structure, so we would have
> 1. `CategoryWithAxiom`: like the existing class, but more restrictive.  Specifies an additional axiom to be satisfied by the objects, and defines the full subcategory objects satisfying this axiom.  For example, commutativity for groups.
> 2. `CategoryWithStructure`: proposed new class.  Specifies an additional structure on objects that must be preserved by morphisms, and defines a usually non-full subcategory.
> In certain cases something that is now called an axiom would become an extra structure.  For example (thinking about the discussion on #16843) the `Unital` property for rings (as a subcategory of `Rngs`) would become a structure instead of an axiom, because morphisms are restricted by the requirement that they preserve the unit element.

We want Unital to have all the other features of axioms like:

```
    sage: Rngs() & Semigroups().Unital()
    Category of Rings
```


So this would require a more complicated hierarchy of classes,
especially since one would also need to take care of the
over_base_ring variations. I am not sure this is worth it for just a
single method.

By the way: `Semigroups().Unital()` is indeed a structure
category. But not `Rngs().Unital()`: all the structure is defined in
the super categories `Rngs()` and `Semigroups().Unital()`.

Also: there is room for improvement in functorial constructions: in
some cases, we could automatically deduce that the category is a
structure category. I believe this is easier to implement by mean of
methods than by inheriting from one class or the other (and past has
proven that I can live with class surgery when needed).

Cheers,
                                 Nicolas



---

archive/issue_comments_209754.json:
```json
{
    "body": "Replying to [comment:33 nthiery]:\n> Thanks. I double checked on this, and mostly agree up to one point: I\n> think Coxeter Groups should be a structure category, the extra\n> structure being the chosen set of simple generators.\n\nI don't think so. If we wanted the generators to be part of the structure (definition), that should be the category of Coxeter syetems as it is much more rigid than just the groups.\n\n> > This made me wonder if we actually want the default category be a\n> > structure category.\n> \n> I believe this would be dangerous. Being accidentally a structure\n> category means that your homsets will miss some code that could be\n> available. So just a missing feature. Whereas being accidentally a non\n> structure category can let your homset inherit from code that is not\n> applicable which can lead to wrong code.\n\nI agree with this, although my thought is more about how many categories will we have are structure categories. As I stated, we need more data and I agree that having this default is the safe route.\n\n> Besides, all the categories your changed should actually become\n> CategoryWithAxioms at some point, which will have precisely the\n> desired effect.\n\nProbably.\n\n> So now one could wonder whether having a CategoryWithAxiom be a non\n> structure category is not a dangerous default. I believe it's ok,\n> because for a category with axiom A.B, one only has to be careful\n> about being a full subcategory or not if A is the category defining\n> the axiom B. There are not soo many of them.\n\nMost axioms that come to my mind adds extra structure, but we can see what happens as we add more axioms.\n\n> > I'm going to double-check to make sure I didn't miss any others and\n> > I'd appreciate if someone else could do the same.\n> \n> Thanks!\n\nThanks for double-checking my double-check.\n\nReplying to [comment:34 nthiery]:\n> Possibly so. What would be the names for all the related methods (like all_structure_categories)?\n\nWith this, we could keep the same names (although I believe the method your referring to  is `all_structure_super_categories`).\n\nAre we all in agreement that we should change `is_structure_category` to `has_additional_structure` and the current framework is a good enough to merge in (since it could be extended at a later date to carry additional info)?",
    "created_at": "2014-09-12T17:10:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209754",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:33 nthiery]:
> Thanks. I double checked on this, and mostly agree up to one point: I
> think Coxeter Groups should be a structure category, the extra
> structure being the chosen set of simple generators.

I don't think so. If we wanted the generators to be part of the structure (definition), that should be the category of Coxeter syetems as it is much more rigid than just the groups.

> > This made me wonder if we actually want the default category be a
> > structure category.
> 
> I believe this would be dangerous. Being accidentally a structure
> category means that your homsets will miss some code that could be
> available. So just a missing feature. Whereas being accidentally a non
> structure category can let your homset inherit from code that is not
> applicable which can lead to wrong code.

I agree with this, although my thought is more about how many categories will we have are structure categories. As I stated, we need more data and I agree that having this default is the safe route.

> Besides, all the categories your changed should actually become
> CategoryWithAxioms at some point, which will have precisely the
> desired effect.

Probably.

> So now one could wonder whether having a CategoryWithAxiom be a non
> structure category is not a dangerous default. I believe it's ok,
> because for a category with axiom A.B, one only has to be careful
> about being a full subcategory or not if A is the category defining
> the axiom B. There are not soo many of them.

Most axioms that come to my mind adds extra structure, but we can see what happens as we add more axioms.

> > I'm going to double-check to make sure I didn't miss any others and
> > I'd appreciate if someone else could do the same.
> 
> Thanks!

Thanks for double-checking my double-check.

Replying to [comment:34 nthiery]:
> Possibly so. What would be the names for all the related methods (like all_structure_categories)?

With this, we could keep the same names (although I believe the method your referring to  is `all_structure_super_categories`).

Are we all in agreement that we should change `is_structure_category` to `has_additional_structure` and the current framework is a good enough to merge in (since it could be extended at a later date to carry additional info)?



---

archive/issue_comments_209755.json:
```json
{
    "body": "Hi Nicolas,\n> Replying to [comment:32 pbruin]:\n> > At first sight it looks like a category should be able to simply\n> > declare if is it a full subcategory of its supercategories (for\n> > each supercategory individually, if necessary).  Then\n> > `is_full_subcategory()`, given two categories, could check if\n> > there is a sequence of full subcategory inclusions between the two\n> > categories.\n> That was the original plan, but this means having to encode much\n> more information. And it's quite more costly to compute.\nI don't see why this should necessarily be the case; we would just encode for each direct supercategory (of which there are usually just one or two)\nwhether it is a full supercategory.  This makes computing all full\nsupercategories not any slower (and probably faster) than computing\nall supercategories, or presumably all \"structure supercategories\" for\nthat matter.\n> > > > I would prefer the proposals made by Nicolas in comment:9 and\n> > > > Simon in comment:10 to have an `additional_structure()` method\n> > > > that returns something meaningful about the additional\n> > > > structure, not just True or False.\n> > > Currently the default is that new subcategories are structure\n> > > categories (so they are not full subcategories). If we were to\n> > > go with returning pairs `(op, method)`, then the question\n> > > becomes do we want the default to be `False` or do we allow\n> > > `True` to remain the default and have it be when we can't\n> > > adequately define the structure?\n> > Hmm, it doesn't sound very desirable to define a category where\n> > you can't define what its extra structure is...\n> But this is imposing the category writer to do implement one more\n> thing, when implementing a category is already a barrier.  Being a\n> full subcategory only adds extra features to homsets. In most cases,\n> when implementing a category for the first time, one does not need\n> this feature. So being able to just not have to worry about it is a\n> definite plus.\nIt seems to me that the first thing one has to do when defining a\ncategory (and maybe the only essential thing!) should be to decide how\nto encode its mathematical meaning.  The distinction between adding a\nnew axiom to the objects (thereby creating a full subcategory) and\nadding a new type of structure (thereby creating a relationship that I\nwas thinking of as \"category refinement\" in earlier discussions) is\nreally fundamental in my opinion.\n> > > Actually, that made me have a thought. How about instead of\n> > > `is_structure_category` we have `has_additional_structure`, and\n> > > then we could extend this to `additional_structure` (on a\n> > > followup ticket).\n> Possibly so. What would be the names for all the related methods\n> (like `all_structure_categories`)?\n> > This sounds good.  We could go even further and formalise the\n> > notion of category with extra structure, so we would have\n> > 1. `CategoryWithAxiom`: like the existing class, but more\n> > restrictive.  Specifies an additional axiom to be satisfied by the\n> > objects, and defines the full subcategory objects satisfying this\n> > axiom.  For example, commutativity for groups.\n> > 2. `CategoryWithStructure`: proposed new class.  Specifies an\n> > additional structure on objects that must be preserved by\n> > morphisms, and defines a usually non-full subcategory.\n> > In certain cases something that is now called an axiom would\n> > become an extra structure.  For example (thinking about the\n> > discussion on #16843) the `Unital` property for rings (as a\n> > subcategory of `Rngs`) would become a structure instead of an\n> > axiom, because morphisms are restricted by the requirement that\n> > they preserve the unit element.\n> We want Unital to have all the other features of axioms like:\n> {{{\n>     sage: Rngs() & Semigroups().Unital()\n>     Category of Rings\n> }}}\nOf course, this type of construction should stay the same.\n> So this would require a more complicated hierarchy of classes,\n> especially since one would also need to take care of the\n> over_base_ring variations. I am not sure this is worth it for just a\n> single method.\nOn the contrary, I think it there is an essential distinction between\njust adding an axiom to the objects (hence creating a full\nsubcategory) and adding \"extra structure\".  (By the way, \"over a base ring\" is actually something that I am thinking of as another example of \"extra structure\".)\n> By the way: `Semigroups().Unital()` is indeed a structure\n> category. But not `Rngs().Unital()`: all the structure is defined in\n> the super categories `Rngs()` and `Semigroups().Unital()`.\nThis actually strengthens my conviction that \"structure category\" is\nnot a well-defined notion.  Instead, I have the impression that the\nstructure should be regarded as being attached to what is currently\ncalled the \"axiom\" rather than to the category.\n\nIn this example, it depends on how you define `Rings()`: either as\n`Rngs() & Semigroups().Unital()`, in which case it is just a join of\ncategories without new structure, _or_ as `Rngs().Unital()`, in which\nit does have extra structure (at least at first sight; you have to\nknow that the category code magically rearranges the construction to\nturn `Rngs().Unital()` into a join of larger categories).  In fact,\n`Semigroups().Unital()` (= `Monoids()`) is not a structure category\neither; it is the join of `Magmas().Unital()` and `Semigroups()`.\n> Also: there is room for improvement in functorial constructions: in\n> some cases, we could automatically deduce that the category is a\n> structure category.\nI am wondering how you could possibly detect such a thing.  In the\ncase of the `Unital()` structure (correct me if this is somehow an\nexception), how do you know that this does not just mean the existence\nof a unit element in the objects, but also the requirement that\nmorphisms preserve this element?  This seems to me precisely the type\nof information that has to be specified by the person implementing the\n`Unital()` structure.",
    "created_at": "2014-09-13T10:34:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209755",
    "user": "https://github.com/pjbruin"
}
```

Hi Nicolas,
> Replying to [comment:32 pbruin]:
> > At first sight it looks like a category should be able to simply
> > declare if is it a full subcategory of its supercategories (for
> > each supercategory individually, if necessary).  Then
> > `is_full_subcategory()`, given two categories, could check if
> > there is a sequence of full subcategory inclusions between the two
> > categories.
> That was the original plan, but this means having to encode much
> more information. And it's quite more costly to compute.
I don't see why this should necessarily be the case; we would just encode for each direct supercategory (of which there are usually just one or two)
whether it is a full supercategory.  This makes computing all full
supercategories not any slower (and probably faster) than computing
all supercategories, or presumably all "structure supercategories" for
that matter.
> > > > I would prefer the proposals made by Nicolas in comment:9 and
> > > > Simon in comment:10 to have an `additional_structure()` method
> > > > that returns something meaningful about the additional
> > > > structure, not just True or False.
> > > Currently the default is that new subcategories are structure
> > > categories (so they are not full subcategories). If we were to
> > > go with returning pairs `(op, method)`, then the question
> > > becomes do we want the default to be `False` or do we allow
> > > `True` to remain the default and have it be when we can't
> > > adequately define the structure?
> > Hmm, it doesn't sound very desirable to define a category where
> > you can't define what its extra structure is...
> But this is imposing the category writer to do implement one more
> thing, when implementing a category is already a barrier.  Being a
> full subcategory only adds extra features to homsets. In most cases,
> when implementing a category for the first time, one does not need
> this feature. So being able to just not have to worry about it is a
> definite plus.
It seems to me that the first thing one has to do when defining a
category (and maybe the only essential thing!) should be to decide how
to encode its mathematical meaning.  The distinction between adding a
new axiom to the objects (thereby creating a full subcategory) and
adding a new type of structure (thereby creating a relationship that I
was thinking of as "category refinement" in earlier discussions) is
really fundamental in my opinion.
> > > Actually, that made me have a thought. How about instead of
> > > `is_structure_category` we have `has_additional_structure`, and
> > > then we could extend this to `additional_structure` (on a
> > > followup ticket).
> Possibly so. What would be the names for all the related methods
> (like `all_structure_categories`)?
> > This sounds good.  We could go even further and formalise the
> > notion of category with extra structure, so we would have
> > 1. `CategoryWithAxiom`: like the existing class, but more
> > restrictive.  Specifies an additional axiom to be satisfied by the
> > objects, and defines the full subcategory objects satisfying this
> > axiom.  For example, commutativity for groups.
> > 2. `CategoryWithStructure`: proposed new class.  Specifies an
> > additional structure on objects that must be preserved by
> > morphisms, and defines a usually non-full subcategory.
> > In certain cases something that is now called an axiom would
> > become an extra structure.  For example (thinking about the
> > discussion on #16843) the `Unital` property for rings (as a
> > subcategory of `Rngs`) would become a structure instead of an
> > axiom, because morphisms are restricted by the requirement that
> > they preserve the unit element.
> We want Unital to have all the other features of axioms like:
> {{{
>     sage: Rngs() & Semigroups().Unital()
>     Category of Rings
> }}}
Of course, this type of construction should stay the same.
> So this would require a more complicated hierarchy of classes,
> especially since one would also need to take care of the
> over_base_ring variations. I am not sure this is worth it for just a
> single method.
On the contrary, I think it there is an essential distinction between
just adding an axiom to the objects (hence creating a full
subcategory) and adding "extra structure".  (By the way, "over a base ring" is actually something that I am thinking of as another example of "extra structure".)
> By the way: `Semigroups().Unital()` is indeed a structure
> category. But not `Rngs().Unital()`: all the structure is defined in
> the super categories `Rngs()` and `Semigroups().Unital()`.
This actually strengthens my conviction that "structure category" is
not a well-defined notion.  Instead, I have the impression that the
structure should be regarded as being attached to what is currently
called the "axiom" rather than to the category.

In this example, it depends on how you define `Rings()`: either as
`Rngs() & Semigroups().Unital()`, in which case it is just a join of
categories without new structure, _or_ as `Rngs().Unital()`, in which
it does have extra structure (at least at first sight; you have to
know that the category code magically rearranges the construction to
turn `Rngs().Unital()` into a join of larger categories).  In fact,
`Semigroups().Unital()` (= `Monoids()`) is not a structure category
either; it is the join of `Magmas().Unital()` and `Semigroups()`.
> Also: there is room for improvement in functorial constructions: in
> some cases, we could automatically deduce that the category is a
> structure category.
I am wondering how you could possibly detect such a thing.  In the
case of the `Unital()` structure (correct me if this is somehow an
exception), how do you know that this does not just mean the existence
of a unit element in the objects, but also the requirement that
morphisms preserve this element?  This seems to me precisely the type
of information that has to be specified by the person implementing the
`Unital()` structure.



---

archive/issue_comments_209756.json:
```json
{
    "body": "Replying to [comment:35 tscrim]:\n> I don't think so. If we wanted the generators to be part of the structure (definition), that should be the category of Coxeter syetems as it is much more rigid than just the groups.\n\nBoth concepts are useful, but it's far from clear for me that we want\nto maintain both categories Coxeter groups / coxeter systems. Given\nthat:\n\n- Our Coxeter groups all come endowed with a distinguished set of\n  generators.\n\n- It's easier to change a structure category to a non structure\n  category than the converse (since it's adding features).\n\n- With the current setting, we already have both concepts: e.g. when\n  constructing a morphism between two coxeter groups, you can choose\n  to construct it as a group morphism or as a Coxeter group morphism.\n\n\n> I agree with this, although my thought is more about how many\n> categories will we have are structure categories. As I stated, we\n> need more data and I agree that having this default is the safe\n> route.\n\nI agree that we need more data. My bet is that most categories will be\neither structure categories or categories with axioms.\n\n> Most axioms that come to my mind adds extra structure, but we can see what happens as we add more axioms.\n\nDo they? So far, only one of the existing axioms (Unital and its\nadditive variant) add extra structure. And the one I am thinking for\nthe future don't add extra structure (about monoids: L,R,J-Trivial,\n...).\n\n\n> With this, we could keep the same names (although I believe the\n> method your referring to is `all_structure_super_categories`).\n\nIf we switch to has_additional_structure, it feels like we are not\nusing `structure` as an adjective for qualifying a category anymore,\nbut rather as a noun. So ``all_structure_super_categories`` does not\nreally make sense. On the other hand, we could possibly name this\nmethod \"structure\":\n\n\tsage: Rings().structure()\n\t[Category of unital magmas, Category of additive unital\tadditive magmas]\n\nWe could actually get rid of \"has_additional_structure\" altogether,\nand instead have `C.additional_structure()` return `C` by default,\nwith the possibility to override it to return `None`, or, in the\nfuture, something more meaningful than `C`.\n\nCheers,\n                                  Nicolas",
    "created_at": "2014-09-14T20:35:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209756",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:35 tscrim]:
> I don't think so. If we wanted the generators to be part of the structure (definition), that should be the category of Coxeter syetems as it is much more rigid than just the groups.

Both concepts are useful, but it's far from clear for me that we want
to maintain both categories Coxeter groups / coxeter systems. Given
that:

- Our Coxeter groups all come endowed with a distinguished set of
  generators.

- It's easier to change a structure category to a non structure
  category than the converse (since it's adding features).

- With the current setting, we already have both concepts: e.g. when
  constructing a morphism between two coxeter groups, you can choose
  to construct it as a group morphism or as a Coxeter group morphism.


> I agree with this, although my thought is more about how many
> categories will we have are structure categories. As I stated, we
> need more data and I agree that having this default is the safe
> route.

I agree that we need more data. My bet is that most categories will be
either structure categories or categories with axioms.

> Most axioms that come to my mind adds extra structure, but we can see what happens as we add more axioms.

Do they? So far, only one of the existing axioms (Unital and its
additive variant) add extra structure. And the one I am thinking for
the future don't add extra structure (about monoids: L,R,J-Trivial,
...).


> With this, we could keep the same names (although I believe the
> method your referring to is `all_structure_super_categories`).

If we switch to has_additional_structure, it feels like we are not
using `structure` as an adjective for qualifying a category anymore,
but rather as a noun. So ``all_structure_super_categories`` does not
really make sense. On the other hand, we could possibly name this
method "structure":

	sage: Rings().structure()
	[Category of unital magmas, Category of additive unital	additive magmas]

We could actually get rid of "has_additional_structure" altogether,
and instead have `C.additional_structure()` return `C` by default,
with the possibility to override it to return `None`, or, in the
future, something more meaningful than `C`.

Cheers,
                                  Nicolas



---

archive/issue_comments_209757.json:
```json
{
    "body": "Replying to [comment:36 pbruin]:\n> This actually strengthens my conviction that \"structure category\" is\n> not a well-defined notion.\n\nIt's perfectly defined: C is a structure category if whenever A and B\nare in C and phi is a morphism between A and B for any strict super\ncategory of `C`, then phi is a `C` morphism. And it coincides with the\nintuition we have of it: does `C` define some additional structure\n(typically an operation) that has to be preserved by `C`-morphisms.\n\n> Instead, I have the impression that the structure should be regarded\n> as being attached to what is currently called the \"axiom\" rather\n> than to the category.\n\n> In this example, it depends on how you define `Rings()`: either as\n> `Rngs() & Semigroups().Unital()`, in which case it is just a join of\n> categories without new structure, _or_ as `Rngs().Unital()`, in which\n> it does have extra structure (at least at first sight; you have to\n> know that the category code magically rearranges the construction to\n> turn `Rngs().Unital()` into a join of larger categories).  In fact,\n> `Semigroups().Unital()` (= `Monoids()`) is not a structure category\n> either; it is the join of `Magmas().Unital()` and `Semigroups()`.\n\nI don't see why `Rngs().Unital()` should suggest it's a structure\ncategory. `A.Unital()` is never a structure category unless `A` is the\ncategory defining `Unital`. That is `A=Magmas()`.\n\n> I don't see why this should necessarily be the case; we would just\n> encode for each direct supercategory (of which there are usually\n> just one or two) whether it is a full supercategory.\n\nWell, I tried, and the code stunk with duplication, urging me to do it\ndifferently :-) Feel free to try for yourself. In particular, it\nbecomes painful for categories with axioms or functorial construction\ncategories where the super categories are computed automatically for\nyou.\n\n> This makes computing all full supercategories not any slower (and\n> probably faster) than computing all supercategories,\n\nYup.\n\n> or presumably all \"structure supercategories\" for that matter.\n\nPossibly so. There are few structure supercategories so that's rather\ncheap too.\n\nI'll answer the rest tomorrow.\n\nCheers,\n                            Nicolas",
    "created_at": "2014-09-14T21:27:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209757",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:36 pbruin]:
> This actually strengthens my conviction that "structure category" is
> not a well-defined notion.

It's perfectly defined: C is a structure category if whenever A and B
are in C and phi is a morphism between A and B for any strict super
category of `C`, then phi is a `C` morphism. And it coincides with the
intuition we have of it: does `C` define some additional structure
(typically an operation) that has to be preserved by `C`-morphisms.

> Instead, I have the impression that the structure should be regarded
> as being attached to what is currently called the "axiom" rather
> than to the category.

> In this example, it depends on how you define `Rings()`: either as
> `Rngs() & Semigroups().Unital()`, in which case it is just a join of
> categories without new structure, _or_ as `Rngs().Unital()`, in which
> it does have extra structure (at least at first sight; you have to
> know that the category code magically rearranges the construction to
> turn `Rngs().Unital()` into a join of larger categories).  In fact,
> `Semigroups().Unital()` (= `Monoids()`) is not a structure category
> either; it is the join of `Magmas().Unital()` and `Semigroups()`.

I don't see why `Rngs().Unital()` should suggest it's a structure
category. `A.Unital()` is never a structure category unless `A` is the
category defining `Unital`. That is `A=Magmas()`.

> I don't see why this should necessarily be the case; we would just
> encode for each direct supercategory (of which there are usually
> just one or two) whether it is a full supercategory.

Well, I tried, and the code stunk with duplication, urging me to do it
differently :-) Feel free to try for yourself. In particular, it
becomes painful for categories with axioms or functorial construction
categories where the super categories are computed automatically for
you.

> This makes computing all full supercategories not any slower (and
> probably faster) than computing all supercategories,

Yup.

> or presumably all "structure supercategories" for that matter.

Possibly so. There are few structure supercategories so that's rather
cheap too.

I'll answer the rest tomorrow.

Cheers,
                            Nicolas



---

archive/issue_comments_209758.json:
```json
{
    "body": "Replying to [comment:37 nthiery]:\n> Both concepts are useful, but it's far from clear for me that we want\n> to maintain both categories Coxeter groups / coxeter systems. Given\n> that:\n> \n> - Our Coxeter groups all come endowed with a distinguished set of\n>   generators.\n>\n> - It's easier to change a structure category to a non structure\n>   category than the converse (since it's adding features).\n> \n> - With the current setting, we already have both concepts: e.g. when\n>   constructing a morphism between two coxeter groups, you can choose\n>   to construct it as a group morphism or as a Coxeter group morphism.\n\nAfter looking over the category, I agree with you that it is modeling a Coxeter system. However I think we should expand the documentation at the beginning of the category to emphasize this (and I'd almost say we should rename the category to reflect this).\n\n> Do they? So far, only one of the existing axioms (Unital and its\n> additive variant) add extra structure. And the one I am thinking for\n> the future don't add extra structure (about monoids: L,R,J-Trivial,\n> ...).\n\nI was thinking associative and inverse add structure (to the morphism), but they don't, they just guarantee properties about the elements (and the axioms are preserved under the morphisms). I was also thinking of things like \"grading\", \"topogolical\", and \"metric\" but they aren't axioms (they are/would be functorial constructions). So perhaps axiom categories could not be structure categories by default...more data is probably needed.\n\nActually that brings up another question, should (regressive) functorial constructions be structure categories by default? Or again do you think more data needed?\n\n> If we switch to has_additional_structure, it feels like we are not\n> using `structure` as an adjective for qualifying a category anymore,\n> but rather as a noun. So ``all_structure_super_categories`` does not\n> really make sense. On the other hand, we could possibly name this\n> method \"structure\":\n> \n> \tsage: Rings().structure()\n> \t[Category of unital magmas, Category of additive unital\tadditive magmas]\n> \n> We could actually get rid of \"has_additional_structure\" altogether,\n> and instead have `C.additional_structure()` return `C` by default,\n> with the possibility to override it to return `None`, or, in the\n> future, something more meaningful than `C`.\n\nHowever with doing things this way, how is it different than explicitly specifying the full subcategories (well, in reverse)?",
    "created_at": "2014-09-14T22:28:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209758",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:37 nthiery]:
> Both concepts are useful, but it's far from clear for me that we want
> to maintain both categories Coxeter groups / coxeter systems. Given
> that:
> 
> - Our Coxeter groups all come endowed with a distinguished set of
>   generators.
>
> - It's easier to change a structure category to a non structure
>   category than the converse (since it's adding features).
> 
> - With the current setting, we already have both concepts: e.g. when
>   constructing a morphism between two coxeter groups, you can choose
>   to construct it as a group morphism or as a Coxeter group morphism.

After looking over the category, I agree with you that it is modeling a Coxeter system. However I think we should expand the documentation at the beginning of the category to emphasize this (and I'd almost say we should rename the category to reflect this).

> Do they? So far, only one of the existing axioms (Unital and its
> additive variant) add extra structure. And the one I am thinking for
> the future don't add extra structure (about monoids: L,R,J-Trivial,
> ...).

I was thinking associative and inverse add structure (to the morphism), but they don't, they just guarantee properties about the elements (and the axioms are preserved under the morphisms). I was also thinking of things like "grading", "topogolical", and "metric" but they aren't axioms (they are/would be functorial constructions). So perhaps axiom categories could not be structure categories by default...more data is probably needed.

Actually that brings up another question, should (regressive) functorial constructions be structure categories by default? Or again do you think more data needed?

> If we switch to has_additional_structure, it feels like we are not
> using `structure` as an adjective for qualifying a category anymore,
> but rather as a noun. So ``all_structure_super_categories`` does not
> really make sense. On the other hand, we could possibly name this
> method "structure":
> 
> 	sage: Rings().structure()
> 	[Category of unital magmas, Category of additive unital	additive magmas]
> 
> We could actually get rid of "has_additional_structure" altogether,
> and instead have `C.additional_structure()` return `C` by default,
> with the possibility to override it to return `None`, or, in the
> future, something more meaningful than `C`.

However with doing things this way, how is it different than explicitly specifying the full subcategories (well, in reverse)?



---

archive/issue_comments_209759.json:
```json
{
    "body": "Replying to [comment:38 nthiery]:\n> Replying to [comment:36 pbruin]:\n> > This actually strengthens my conviction that \"structure category\" is\n> > not a well-defined notion.\n> \n> It's perfectly defined: C is a structure category if whenever A and B\n> are in C and phi is a morphism between A and B for any strict super\n> category of `C`, then phi is a `C` morphism. And it coincides with the\n> intuition we have of it: does `C` define some additional structure\n> (typically an operation) that has to be preserved by `C`-morphisms.\n\nOK, but what I meant is that this notion depends on what supercategories of `C` have been defined, not just on `C` itself.\n\n> > In this example, it depends on how you define `Rings()`: either as\n> > `Rngs() & Semigroups().Unital()`, in which case it is just a join of\n> > categories without new structure, _or_ as `Rngs().Unital()`, in which\n> > it does have extra structure (at least at first sight; you have to\n> > know that the category code magically rearranges the construction to\n> > turn `Rngs().Unital()` into a join of larger categories).  In fact,\n> > `Semigroups().Unital()` (= `Monoids()`) is not a structure category\n> > either; it is the join of `Magmas().Unital()` and `Semigroups()`.\n> \n> I don't see why `Rngs().Unital()` should suggest it's a structure\n> category. `A.Unital()` is never a structure category unless `A` is the\n> category defining `Unital`. That is `A=Magmas()`.\n\nCertainly, but this relies on the the implementation choice of defining `Magmas().Unital()`.  I admit this may be a slightly silly example, but I could imagine a different scenario where the person implementing these categories did not think anyone would need unital magmas, and hence chose to define `Unital()` relative to a more specific category, which in an extreme case could be `Rngs()`.  In that case `Rings() = Rngs().Unital()` would have been a structure category, while being mathematically exactly the same as the actual `Rings()`.\n\n> > I don't see why this should necessarily be the case; we would just\n> > encode for each direct supercategory (of which there are usually\n> > just one or two) whether it is a full supercategory.\n> \n> Well, I tried, and the code stunk with duplication, urging me to do it\n> differently :-) Feel free to try for yourself.\n\nI wish I had the time, but given that I don't, the best I can do is to just add my perspective as a non-developer but potential user of the category framework...\n\n> > This makes computing all full supercategories not any slower (and\n> > probably faster) than computing all supercategories,\n> \n> Yup.\n> \n> > or presumably all \"structure supercategories\" for that matter.\n> \n> Possibly so. There are few structure supercategories so that's rather\n> cheap too.\n\nBut to find them I assume one needs to traverse all supercategories and pick out the ones that are structure supercategories, so the time would still depend on the number of all supercategories, or am I mistaken?",
    "created_at": "2014-09-15T08:27:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209759",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:38 nthiery]:
> Replying to [comment:36 pbruin]:
> > This actually strengthens my conviction that "structure category" is
> > not a well-defined notion.
> 
> It's perfectly defined: C is a structure category if whenever A and B
> are in C and phi is a morphism between A and B for any strict super
> category of `C`, then phi is a `C` morphism. And it coincides with the
> intuition we have of it: does `C` define some additional structure
> (typically an operation) that has to be preserved by `C`-morphisms.

OK, but what I meant is that this notion depends on what supercategories of `C` have been defined, not just on `C` itself.

> > In this example, it depends on how you define `Rings()`: either as
> > `Rngs() & Semigroups().Unital()`, in which case it is just a join of
> > categories without new structure, _or_ as `Rngs().Unital()`, in which
> > it does have extra structure (at least at first sight; you have to
> > know that the category code magically rearranges the construction to
> > turn `Rngs().Unital()` into a join of larger categories).  In fact,
> > `Semigroups().Unital()` (= `Monoids()`) is not a structure category
> > either; it is the join of `Magmas().Unital()` and `Semigroups()`.
> 
> I don't see why `Rngs().Unital()` should suggest it's a structure
> category. `A.Unital()` is never a structure category unless `A` is the
> category defining `Unital`. That is `A=Magmas()`.

Certainly, but this relies on the the implementation choice of defining `Magmas().Unital()`.  I admit this may be a slightly silly example, but I could imagine a different scenario where the person implementing these categories did not think anyone would need unital magmas, and hence chose to define `Unital()` relative to a more specific category, which in an extreme case could be `Rngs()`.  In that case `Rings() = Rngs().Unital()` would have been a structure category, while being mathematically exactly the same as the actual `Rings()`.

> > I don't see why this should necessarily be the case; we would just
> > encode for each direct supercategory (of which there are usually
> > just one or two) whether it is a full supercategory.
> 
> Well, I tried, and the code stunk with duplication, urging me to do it
> differently :-) Feel free to try for yourself.

I wish I had the time, but given that I don't, the best I can do is to just add my perspective as a non-developer but potential user of the category framework...

> > This makes computing all full supercategories not any slower (and
> > probably faster) than computing all supercategories,
> 
> Yup.
> 
> > or presumably all "structure supercategories" for that matter.
> 
> Possibly so. There are few structure supercategories so that's rather
> cheap too.

But to find them I assume one needs to traverse all supercategories and pick out the ones that are structure supercategories, so the time would still depend on the number of all supercategories, or am I mistaken?



---

archive/issue_comments_209760.json:
```json
{
    "body": "(cut out of previous comment since this is somewhat off topic)\n\nReplying to [comment:38 nthiery]:\n\n> In particular, it becomes painful for categories with axioms or functorial construction\n> categories where the super categories are computed automatically for\n> you.\n\nWhat is a functorial construction category?  From the documentation it appears that the idea is that one first defines a construction in some \"abstract\" sense, and only then decides in which category it takes its values, or even to construct a completely new category for this.  I realise that the code doesn't have to follow mathematical definitions exactly, but this seems to be quite the opposite of the usual pattern of doing things, where defining a function, functor or natural transformation presupposes that a domain and codomain have been fixed.  In general this is essential because the function (etc.) that one defines, and its properties, depend on these choices.  I am somewhat worried that the Sage implementation might rely (maybe just in subtle ways) on the intuition behind the cases where this advance choice of domain and codomain doesn't matter so much.",
    "created_at": "2014-09-15T08:28:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209760",
    "user": "https://github.com/pjbruin"
}
```

(cut out of previous comment since this is somewhat off topic)

Replying to [comment:38 nthiery]:

> In particular, it becomes painful for categories with axioms or functorial construction
> categories where the super categories are computed automatically for
> you.

What is a functorial construction category?  From the documentation it appears that the idea is that one first defines a construction in some "abstract" sense, and only then decides in which category it takes its values, or even to construct a completely new category for this.  I realise that the code doesn't have to follow mathematical definitions exactly, but this seems to be quite the opposite of the usual pattern of doing things, where defining a function, functor or natural transformation presupposes that a domain and codomain have been fixed.  In general this is essential because the function (etc.) that one defines, and its properties, depend on these choices.  I am somewhat worried that the Sage implementation might rely (maybe just in subtle ways) on the intuition behind the cases where this advance choice of domain and codomain doesn't matter so much.



---

archive/issue_comments_209761.json:
```json
{
    "body": "Replying to [comment:41 pbruin]:\n> What is a functorial construction category?  From the documentation it appears that the idea is that one first defines a construction in some \"abstract\" sense, and only then decides in which category it takes its values, or even to construct a completely new category for this.  I realise that the code doesn't have to follow mathematical definitions exactly, but this seems to be quite the opposite of the usual pattern of doing things, where defining a function, functor or natural transformation presupposes that a domain and codomain have been fixed.  In general this is essential because the function (etc.) that one defines, and its properties, depend on these choices.  I am somewhat worried that the Sage implementation might rely (maybe just in subtle ways) on the intuition behind the cases where this advance choice of domain and codomain doesn't matter so much.\n\nThe examples are graded modules/algebras and `WithRealizations`. From those examples, I would say the categories that are actually used have a fixed (co)domain. I also think this is similar to morphisms, which also makes the assumption of a fixed (co)domain, but perhaps things are different in this case? I'm not sure I understand your concern here...",
    "created_at": "2014-09-15T17:32:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209761",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:41 pbruin]:
> What is a functorial construction category?  From the documentation it appears that the idea is that one first defines a construction in some "abstract" sense, and only then decides in which category it takes its values, or even to construct a completely new category for this.  I realise that the code doesn't have to follow mathematical definitions exactly, but this seems to be quite the opposite of the usual pattern of doing things, where defining a function, functor or natural transformation presupposes that a domain and codomain have been fixed.  In general this is essential because the function (etc.) that one defines, and its properties, depend on these choices.  I am somewhat worried that the Sage implementation might rely (maybe just in subtle ways) on the intuition behind the cases where this advance choice of domain and codomain doesn't matter so much.

The examples are graded modules/algebras and `WithRealizations`. From those examples, I would say the categories that are actually used have a fixed (co)domain. I also think this is similar to morphisms, which also makes the assumption of a fixed (co)domain, but perhaps things are different in this case? I'm not sure I understand your concern here...



---

archive/issue_comments_209762.json:
```json
{
    "body": "Replying to [comment:39 tscrim]:\n\n> After looking over the category, I agree with you that it is\n> modeling a Coxeter system. However I think we should expand the\n> documentation at the beginning of the category to emphasize this\n\n+1, definitely (in a separate ticket of course)\n\n> (and I'd almost say we should rename the category to reflect this).\n\nPossibly so; but then one has to do the same for Weyl groups, and\nWeylSystems does not look so compelling. In any cases, things will\nbecome easier when this will have been axiomatized, so that in theory\nthere would be a single entry point (CoxeterGroups), with axioms\nCrystalographic, ...\n\n> So perhaps axiom categories could not be structure categories by default...more data is probably needed.\n\nThat felt like a reasonable default which is why I implemented this\nway; especially since anyway the only case where there can be\nadditional structure for the axiom category is within the category\ndefining the axiom.\n\n> Actually that brings up another question, should (regressive) functorial constructions be structure categories by default? Or again do you think more data needed?\n\nAt this point I'd be uncomfortable with it, since e.g. Graded is one\nsuch construction. So I guess it's best done construction by\nconstruction until we have more data. But it may well be that things\nshould be as for axiom categories: except within the category defining\nthe construction, there is no additional structure.\n\nIn fact, maybe the correct default would be to have,\n`A.B().has_additional_structure()` return True if and only if `A` is\nthe category defining the axiom/regressive construction `B`.\n\n> > We could actually get rid of \"has_additional_structure\" altogether,\n> > and instead have `C.additional_structure()` return `C` by default,\n> > with the possibility to override it to return `None`, or, in the\n> > future, something more meaningful than `C`.\n> \n> However with doing things this way, how is it different than explicitly specifying the full subcategories (well, in reverse)?\n\nWell, first it's more concise (just return None or `self`) and\ninvolves less duplication.\n\nAlso, it gives more information to the system: there are cases where a\ncategory defines no additional structure even though it's not a full\nsubcategory of any of its direct super categories. Think of some full\nsubcategory of `Magmas() & AdditiveMagmas()`. Granted, you could have\n`full_super_categories` return a join, but this would deviate from\neverywhere else (a category never has a join as super category), and\nthus probably be a source of problems.\n\nCheers,\n                        Nicolas",
    "created_at": "2014-09-15T21:44:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209762",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:39 tscrim]:

> After looking over the category, I agree with you that it is
> modeling a Coxeter system. However I think we should expand the
> documentation at the beginning of the category to emphasize this

+1, definitely (in a separate ticket of course)

> (and I'd almost say we should rename the category to reflect this).

Possibly so; but then one has to do the same for Weyl groups, and
WeylSystems does not look so compelling. In any cases, things will
become easier when this will have been axiomatized, so that in theory
there would be a single entry point (CoxeterGroups), with axioms
Crystalographic, ...

> So perhaps axiom categories could not be structure categories by default...more data is probably needed.

That felt like a reasonable default which is why I implemented this
way; especially since anyway the only case where there can be
additional structure for the axiom category is within the category
defining the axiom.

> Actually that brings up another question, should (regressive) functorial constructions be structure categories by default? Or again do you think more data needed?

At this point I'd be uncomfortable with it, since e.g. Graded is one
such construction. So I guess it's best done construction by
construction until we have more data. But it may well be that things
should be as for axiom categories: except within the category defining
the construction, there is no additional structure.

In fact, maybe the correct default would be to have,
`A.B().has_additional_structure()` return True if and only if `A` is
the category defining the axiom/regressive construction `B`.

> > We could actually get rid of "has_additional_structure" altogether,
> > and instead have `C.additional_structure()` return `C` by default,
> > with the possibility to override it to return `None`, or, in the
> > future, something more meaningful than `C`.
> 
> However with doing things this way, how is it different than explicitly specifying the full subcategories (well, in reverse)?

Well, first it's more concise (just return None or `self`) and
involves less duplication.

Also, it gives more information to the system: there are cases where a
category defines no additional structure even though it's not a full
subcategory of any of its direct super categories. Think of some full
subcategory of `Magmas() & AdditiveMagmas()`. Granted, you could have
`full_super_categories` return a join, but this would deviate from
everywhere else (a category never has a join as super category), and
thus probably be a source of problems.

Cheers,
                        Nicolas



---

archive/issue_comments_209763.json:
```json
{
    "body": "Hi Peter,\n\nSorry, still running behind. I'll just answer some easy points now.\n\nReplying to [comment:40 pbruin]:\n> I wish I had the time, but given that I don't, the best I can do is to just add my perspective as a non-developer but potential user of the category framework...\n\nI know, and appreciate this. I guess I am just expressing the\nfrustration when some things appear clearly after having manipulated\nthe code for a while, yet are hard to convey convincingly.\n\n> But to find them I assume one needs to traverse all supercategories and pick out the ones that are structure supercategories, so the time would still depend on the number of all supercategories, or am I mistaken?\n\nYes and no: this is obtained by taking the union of the structures of\nthe direct super categories, and cached. So yes, this can trigger a\ncalculation for all the super categories if such information has never\nbeen computed before higher above in the category hierarchy. But\notherwise, the cost is just that of the union, and that's essentially\nlinear in the number of structure super categories.\n\nCheers,\n                                Nicolas",
    "created_at": "2014-09-15T21:54:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209763",
    "user": "https://github.com/nthiery"
}
```

Hi Peter,

Sorry, still running behind. I'll just answer some easy points now.

Replying to [comment:40 pbruin]:
> I wish I had the time, but given that I don't, the best I can do is to just add my perspective as a non-developer but potential user of the category framework...

I know, and appreciate this. I guess I am just expressing the
frustration when some things appear clearly after having manipulated
the code for a while, yet are hard to convey convincingly.

> But to find them I assume one needs to traverse all supercategories and pick out the ones that are structure supercategories, so the time would still depend on the number of all supercategories, or am I mistaken?

Yes and no: this is obtained by taking the union of the structures of
the direct super categories, and cached. So yes, this can trigger a
calculation for all the super categories if such information has never
been computed before higher above in the category hierarchy. But
otherwise, the cost is just that of the union, and that's essentially
linear in the number of structure super categories.

Cheers,
                                Nicolas



---

archive/issue_comments_209764.json:
```json
{
    "body": "Dear Peter,\n\nReplying to [comment:36 pbruin]:\n> It seems to me that the first thing one has to do when defining a\n> category (and maybe the only essential thing!) should be to decide how\n> to encode its mathematical meaning.  The distinction between adding a\n> new axiom to the objects (thereby creating a full subcategory) and\n> adding a new type of structure (thereby creating a relationship that I\n> was thinking of as \"category refinement\" in earlier discussions) is\n> really fundamental in my opinion.\n\nI agree that clarifying what additional structure, if any, a category\ndefines can be a fundamental guideline for the design. Now, from what\nI have seen in practice, new category writers usually start with plain\nstructure categories, and they do intuitively the right thing (which\ntypically shows up in the documentation: a XXX is a YYY endowed with\nan operation zzz).\n\nWorst case, if XXX does not actually define new structure, the default\nbehavior remains safe. They just won't get some feature that they most\nlikely don't need anyway. Remember that the doc of\n\"is_full_subcategory\" specifies:\n\n\n```\n            A positive answer is guaranteed to be mathematically\n            correct. A negative answer may mean that Sage has not been\n            taught enough information to derive this information. See\n            :meth:`full_super_categories` for a discussion.\n```\n\n\nThings are also safe when implementing an existing axiom or\nconstruction in a category where it was not yet there.\n\nThe above guideline becomes important when implementing new axioms,\nnew constructions, or deciding which it should be; but there we can\nassume that the developer has gained enough experience.\n\n> > > > Actually, that made me have a thought. How about instead of\n> > > > `is_structure_category` we have `has_additional_structure`, and\n> > > > then we could extend this to `additional_structure` (on a\n> > > > followup ticket).\n\n\n> On the contrary, I think it there is an essential distinction between\n> just adding an axiom to the objects (hence creating a full\n> subcategory) and adding \"extra structure\".\n\nMy point is that the two concepts of axioms and of categories adding\nstructure are rather orthogonal.\n\nAxioms are relevant when a bunch of categories have something to say\nabout that axiom. An axiom by itself may or may not add structure.\nAnd there are non structure categories that need not be axioms.\n\nWhether a given category is a structure category or not is the matter\nof a single method, and it's not worth the complexity of duplicating\nthe category class hierarchy just for this.\n\n> (By the way, \"over a base ring\" is actually something that I am thinking of as another example of \"extra structure\".)\n\nHere, it's really the category `Modules` that adds the structure. The\nclass \"Category_over_base_ring\" is just a technical gadget to handle\nthe base ring parameter that the categories over base rings\ntakes. E.g. `Algebras.FiniteDimensional` is a category over a base\nring which does not add structure, whereas `Modules` does.\n\n> > Also: there is room for improvement in functorial constructions: in\n> > some cases, we could automatically deduce that the category is a\n> > structure category.\n> I am wondering how you could possibly detect such a thing.\n> In the case of the `Unital()` structure (correct me if this is\n> somehow an exception), how do you know that this does not just mean\n> the existence of a unit element in the objects, but also the\n> requirement that morphisms preserve this element?  This seems to me\n> precisely the type of information that has to be specified by the\n> person implementing the `Unital()` structure.\n\nYes, this need to be specified explicitly by the person *defining* a\nnew axiom. But if it's just about implementing an existing axiom for\nsome category where it was not yet there, then the answer is clear:\nthere is no new structure.\n\nAs we discussed with Travis, I believe something similar should hold\nfor functorial constructions categories, at least in the covariant\ncase, but I need to think more about it.\n\nCheers,\n                                 Nicolas",
    "created_at": "2014-09-16T08:43:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209764",
    "user": "https://github.com/nthiery"
}
```

Dear Peter,

Replying to [comment:36 pbruin]:
> It seems to me that the first thing one has to do when defining a
> category (and maybe the only essential thing!) should be to decide how
> to encode its mathematical meaning.  The distinction between adding a
> new axiom to the objects (thereby creating a full subcategory) and
> adding a new type of structure (thereby creating a relationship that I
> was thinking of as "category refinement" in earlier discussions) is
> really fundamental in my opinion.

I agree that clarifying what additional structure, if any, a category
defines can be a fundamental guideline for the design. Now, from what
I have seen in practice, new category writers usually start with plain
structure categories, and they do intuitively the right thing (which
typically shows up in the documentation: a XXX is a YYY endowed with
an operation zzz).

Worst case, if XXX does not actually define new structure, the default
behavior remains safe. They just won't get some feature that they most
likely don't need anyway. Remember that the doc of
"is_full_subcategory" specifies:


```
            A positive answer is guaranteed to be mathematically
            correct. A negative answer may mean that Sage has not been
            taught enough information to derive this information. See
            :meth:`full_super_categories` for a discussion.
```


Things are also safe when implementing an existing axiom or
construction in a category where it was not yet there.

The above guideline becomes important when implementing new axioms,
new constructions, or deciding which it should be; but there we can
assume that the developer has gained enough experience.

> > > > Actually, that made me have a thought. How about instead of
> > > > `is_structure_category` we have `has_additional_structure`, and
> > > > then we could extend this to `additional_structure` (on a
> > > > followup ticket).


> On the contrary, I think it there is an essential distinction between
> just adding an axiom to the objects (hence creating a full
> subcategory) and adding "extra structure".

My point is that the two concepts of axioms and of categories adding
structure are rather orthogonal.

Axioms are relevant when a bunch of categories have something to say
about that axiom. An axiom by itself may or may not add structure.
And there are non structure categories that need not be axioms.

Whether a given category is a structure category or not is the matter
of a single method, and it's not worth the complexity of duplicating
the category class hierarchy just for this.

> (By the way, "over a base ring" is actually something that I am thinking of as another example of "extra structure".)

Here, it's really the category `Modules` that adds the structure. The
class "Category_over_base_ring" is just a technical gadget to handle
the base ring parameter that the categories over base rings
takes. E.g. `Algebras.FiniteDimensional` is a category over a base
ring which does not add structure, whereas `Modules` does.

> > Also: there is room for improvement in functorial constructions: in
> > some cases, we could automatically deduce that the category is a
> > structure category.
> I am wondering how you could possibly detect such a thing.
> In the case of the `Unital()` structure (correct me if this is
> somehow an exception), how do you know that this does not just mean
> the existence of a unit element in the objects, but also the
> requirement that morphisms preserve this element?  This seems to me
> precisely the type of information that has to be specified by the
> person implementing the `Unital()` structure.

Yes, this need to be specified explicitly by the person *defining* a
new axiom. But if it's just about implementing an existing axiom for
some category where it was not yet there, then the answer is clear:
there is no new structure.

As we discussed with Travis, I believe something similar should hold
for functorial constructions categories, at least in the covariant
case, but I need to think more about it.

Cheers,
                                 Nicolas



---

archive/issue_comments_209765.json:
```json
{
    "body": "Replying to [comment:40 pbruin]:\n> OK, but what I meant is that this notion depends on what supercategories of `C` have been defined, not just on `C` itself.\n> \n> Certainly, but this relies on the the implementation choice of defining `Magmas().Unital()`.  I admit this may be a slightly silly example, but I could imagine a different scenario where the person implementing these categories did not think anyone would need unital magmas, and hence chose to define `Unital()` relative to a more specific category, which in an extreme case could be `Rngs()`.  In that case `Rings() = Rngs().Unital()` would have been a structure category, while being mathematically exactly the same as the actual `Rings()`.\n\nFair enough: this is indeed not something purely about the abstract\n(lattice of) mathematical categories, but about whatever subset has\nbeen actually modeled in Sage. It's not so bad though, since this does\nnot depend on how the categories have been implemented (e.g. through\naxioms or not); just on which categories are implemented or not.\n\nIn the above scenario, `Rings` would at first be a structure category;\nand then, when the definition of the `Unital` axioms gets lifted up to\nsome higher category like `Magmas`, Sage would learn that the\nstructure actually comes from some higher category. That's fine given\nthe specs about negative answers for \"X.is_full_super_category(Y)\".\n\nIn general, when adding new categories and \"moving structure up\", one\nindeed needs to update the \"additional structure\" methods of the lower\ncategories accordingly. Though if one forgets to do it, it should just\ncause a lack of new feature, rather than bugs. So we are on the safe\nside.\n\nCheers,\n                          Nicolas",
    "created_at": "2014-09-16T09:00:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209765",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:40 pbruin]:
> OK, but what I meant is that this notion depends on what supercategories of `C` have been defined, not just on `C` itself.
> 
> Certainly, but this relies on the the implementation choice of defining `Magmas().Unital()`.  I admit this may be a slightly silly example, but I could imagine a different scenario where the person implementing these categories did not think anyone would need unital magmas, and hence chose to define `Unital()` relative to a more specific category, which in an extreme case could be `Rngs()`.  In that case `Rings() = Rngs().Unital()` would have been a structure category, while being mathematically exactly the same as the actual `Rings()`.

Fair enough: this is indeed not something purely about the abstract
(lattice of) mathematical categories, but about whatever subset has
been actually modeled in Sage. It's not so bad though, since this does
not depend on how the categories have been implemented (e.g. through
axioms or not); just on which categories are implemented or not.

In the above scenario, `Rings` would at first be a structure category;
and then, when the definition of the `Unital` axioms gets lifted up to
some higher category like `Magmas`, Sage would learn that the
structure actually comes from some higher category. That's fine given
the specs about negative answers for "X.is_full_super_category(Y)".

In general, when adding new categories and "moving structure up", one
indeed needs to update the "additional structure" methods of the lower
categories accordingly. Though if one forgets to do it, it should just
cause a lack of new feature, rather than bugs. So we are on the safe
side.

Cheers,
                          Nicolas



---

archive/issue_comments_209766.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-16T09:25:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209766",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209767.json:
```json
{
    "body": "Hi,\n\nI just fixed some small typos, and reverted the change to\n`CoxeterGroups.is_structure_category()` as we discussed.\n\nTime for a checkpoint on the current status.\n\n## Permutation groups\n\nLooking back at Travis change, I would want to also revert the change\nto `PermutationGroups()`, to let it be a structure category. Indeed,\npermutation groups come with a distinguished action, and Wikipedia\nstates that this action should be preserved by isomorphisms:\n\nhttp://en.wikipedia.org/wiki/Permutation_group#Permutation_isomorphic_groups\n\nDo you agree?\n\n## additional_structure w.r.t. full_super_categories\n\nAs discussed above, I believe that having the developer implement\n`additional_structure` rather than `full_super_categories` is more\nconcise and involves less duplication. And also gives more information\n(which category define additional structure) which could be further\nrefined (e.g. \"Magmas()\" defines \"*\"), if deemed useful in later\niterations.\n\nIs this acceptable for everyone?\n\n## additional_structure w.r.t is_structure_category\n\nDo we have a consensus that the \"additional_structure / structure\"\nlanguage is better than \"is_structure_category /\nall_structure_super_categories\"? And that for now we can specify that\n`C.additional_structure()` shall return `C` or `None`?\n\nIf yes, I can implement this change shortly.\n\n## Default for axioms\n\nCurrently, axiom categories define no additional structure by default.\nTo be 100% foolproof even when defining new axioms, one could change\nthat so an axiom category `C().A()` would by default define additional\nstructure if and only if `C` is the category defining the axiom `A`.\n\nIt would be a relatively small change. The cost is that all but two of\nour current axioms would need to have an \"additional_structure\"\nmethod.  I also need to check whether it's easy to detect if `C` is\nthe category defining `A`.\n\nSomething similar could probably be done for functorial constructions,\nbut we need more data and thinking to do it right and the current\ndefault is safe in the mean time.\n\n## Anything else?\n\nCheers,\n                             Nicolas",
    "created_at": "2014-09-16T09:49:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209767",
    "user": "https://github.com/nthiery"
}
```

Hi,

I just fixed some small typos, and reverted the change to
`CoxeterGroups.is_structure_category()` as we discussed.

Time for a checkpoint on the current status.

## Permutation groups

Looking back at Travis change, I would want to also revert the change
to `PermutationGroups()`, to let it be a structure category. Indeed,
permutation groups come with a distinguished action, and Wikipedia
states that this action should be preserved by isomorphisms:

http://en.wikipedia.org/wiki/Permutation_group#Permutation_isomorphic_groups

Do you agree?

## additional_structure w.r.t. full_super_categories

As discussed above, I believe that having the developer implement
`additional_structure` rather than `full_super_categories` is more
concise and involves less duplication. And also gives more information
(which category define additional structure) which could be further
refined (e.g. "Magmas()" defines "*"), if deemed useful in later
iterations.

Is this acceptable for everyone?

## additional_structure w.r.t is_structure_category

Do we have a consensus that the "additional_structure / structure"
language is better than "is_structure_category /
all_structure_super_categories"? And that for now we can specify that
`C.additional_structure()` shall return `C` or `None`?

If yes, I can implement this change shortly.

## Default for axioms

Currently, axiom categories define no additional structure by default.
To be 100% foolproof even when defining new axioms, one could change
that so an axiom category `C().A()` would by default define additional
structure if and only if `C` is the category defining the axiom `A`.

It would be a relatively small change. The cost is that all but two of
our current axioms would need to have an "additional_structure"
method.  I also need to check whether it's easy to detect if `C` is
the category defining `A`.

Something similar could probably be done for functorial constructions,
but we need more data and thinking to do it right and the current
default is safe in the mean time.

## Anything else?

Cheers,
                             Nicolas



---

archive/issue_comments_209768.json:
```json
{
    "body": "Replying to [comment:41 pbruin]:\n> What is a functorial construction category?\n\nComing back to this side discussion ...\n\nThat's a good question. The documentation is certainly terse and could\ntake some love. I haven't spent on it the two weeks of hard work I put\non axioms!\n\n>  From the documentation it appears that the idea is that one first defines a construction in some \"abstract\" sense, and only then decides in which category it takes its values, or even to construct a completely new category for this.  I realise that the code doesn't have to follow mathematical definitions exactly, but this seems to be quite the opposite of the usual pattern of doing things, where defining a function, functor or natural transformation presupposes that a domain and codomain have been fixed.  In general this is essential because the function (etc.) that one defines, and its properties, depend on these choices.  I am somewhat worried that the Sage implementation might rely (maybe just in subtle ways) on the intuition behind the cases where this advance choice of domain and codomain doesn't matter so much.\n\nMaybe the doc is misleading. But the starting point is really the\nfunctorial construction, that is the collection `(F_C)_C` of related\nfunctors (e.g. the collection of algebra functors: `groups->group\nalgebras`, `monoids->monoid algebras`, `finite groups->finite groups\nalgebras`, ...).\n\nThen, the functorial construction category `C.F()` is meant to model\nthe codomain of the functor `F_C`, which is well defined.\n\nOf course the model might be incomplete. Categories in Sage are an\napproximation of the ideal mathematical categories; not all of them\nnor features thereof are implemented in Sage.\n\nOne possible source of confusion is that the functors `F_C` might not\nactually be modeled as a standalone objects in Sage. But that's just\nbecause we did not really need them at this point. In our example, we\njust need it was sufficient for now to have the construction\nimplemented as `G -> G.algebra(QQ)`. In general, at this point, the\ncentral feature really resides in the categories.\n\nAnother source of confusion is that some of the uses of the mechanism\nfor \"functorial construction categories\" go beyond functorial\nconstructions.  E.g. for subobjects, quotients, ... there is not\nreally a collection of functors behind the scene. Still the mechanism\nremains valid. It would be nice to come up with a better name and\ndefinition that would cover all cases. That's now #16991.\n\nCheers,\n                            Nicolas",
    "created_at": "2014-09-16T10:17:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209768",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:41 pbruin]:
> What is a functorial construction category?

Coming back to this side discussion ...

That's a good question. The documentation is certainly terse and could
take some love. I haven't spent on it the two weeks of hard work I put
on axioms!

>  From the documentation it appears that the idea is that one first defines a construction in some "abstract" sense, and only then decides in which category it takes its values, or even to construct a completely new category for this.  I realise that the code doesn't have to follow mathematical definitions exactly, but this seems to be quite the opposite of the usual pattern of doing things, where defining a function, functor or natural transformation presupposes that a domain and codomain have been fixed.  In general this is essential because the function (etc.) that one defines, and its properties, depend on these choices.  I am somewhat worried that the Sage implementation might rely (maybe just in subtle ways) on the intuition behind the cases where this advance choice of domain and codomain doesn't matter so much.

Maybe the doc is misleading. But the starting point is really the
functorial construction, that is the collection `(F_C)_C` of related
functors (e.g. the collection of algebra functors: `groups->group
algebras`, `monoids->monoid algebras`, `finite groups->finite groups
algebras`, ...).

Then, the functorial construction category `C.F()` is meant to model
the codomain of the functor `F_C`, which is well defined.

Of course the model might be incomplete. Categories in Sage are an
approximation of the ideal mathematical categories; not all of them
nor features thereof are implemented in Sage.

One possible source of confusion is that the functors `F_C` might not
actually be modeled as a standalone objects in Sage. But that's just
because we did not really need them at this point. In our example, we
just need it was sufficient for now to have the construction
implemented as `G -> G.algebra(QQ)`. In general, at this point, the
central feature really resides in the categories.

Another source of confusion is that some of the uses of the mechanism
for "functorial construction categories" go beyond functorial
constructions.  E.g. for subobjects, quotients, ... there is not
really a collection of functors behind the scene. Still the mechanism
remains valid. It would be nice to come up with a better name and
definition that would cover all cases. That's now #16991.

Cheers,
                            Nicolas



---

archive/issue_comments_209769.json:
```json
{
    "body": "I agree with reverting `PermtutationGroup` along with a warning or note about (iso)morphisms (although like Coxeter groups, it is not currently enforced AFAIK).\n\nI don't have a strong opinion on what the method are named and the proposed interface is fine with me.\n\nI'm okay with the default for axioms not being structure categories. However I'd rather have fuctorial construction categories being structure categories by default (I believe currently we only have two, graded and with-realizations, but the two I'd like to add, topological and metric, have additional structure).",
    "created_at": "2014-09-16T16:34:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209769",
    "user": "https://github.com/tscrim"
}
```

I agree with reverting `PermtutationGroup` along with a warning or note about (iso)morphisms (although like Coxeter groups, it is not currently enforced AFAIK).

I don't have a strong opinion on what the method are named and the proposed interface is fine with me.

I'm okay with the default for axioms not being structure categories. However I'd rather have fuctorial construction categories being structure categories by default (I believe currently we only have two, graded and with-realizations, but the two I'd like to add, topological and metric, have additional structure).



---

archive/issue_comments_209770.json:
```json
{
    "body": "Replying to [comment:48 nthiery]:\n> Time for a checkpoint on the current status.\n> \n> == Permutation groups ==\n> \n> Looking back at Travis change, I would want to also revert the change\n> to `PermutationGroups()`, to let it be a structure category. Indeed,\n> permutation groups come with a distinguished action, and Wikipedia\n> states that this action should be preserved by isomorphisms:\n> \n> http://en.wikipedia.org/wiki/Permutation_group#Permutation_isomorphic_groups\n> \n> Do you agree?\n\nYes, the set that is acted upon does seem to qualify as extra structure.\n\n> == additional_structure w.r.t. full_super_categories ==\n> \n> As discussed above, I believe that having the developer implement\n> `additional_structure` rather than `full_super_categories` is more\n> concise and involves less duplication. And also gives more information\n> (which category define additional structure) which could be further\n> refined (e.g. \"Magmas()\" defines \"*\"), if deemed useful in later\n> iterations.\n> \n> Is this acceptable for everyone?\n\nThat sounds good to me.\n\n> == additional_structure w.r.t is_structure_category ==\n> \n> Do we have a consensus that the \"additional_structure / structure\"\n> language is better than \"is_structure_category /\n> all_structure_super_categories\"? And that for now we can specify that\n> `C.additional_structure()` shall return `C` or `None`?\n> \n> If yes, I can implement this change shortly.\n\nI am in favour of this change.\n\n> == Default for axioms ==\n> \n> Currently, axiom categories define no additional structure by default.\n> To be 100% foolproof even when defining new axioms, one could change\n> that so an axiom category `C().A()` would by default define additional\n> structure if and only if `C` is the category defining the axiom `A`.\n\nI am not in favour of this, because it would conflate the notions of \"axiom\" and \"extra structure\" (which from my perspective are quite different) even more.",
    "created_at": "2014-09-26T08:16:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209770",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:48 nthiery]:
> Time for a checkpoint on the current status.
> 
> == Permutation groups ==
> 
> Looking back at Travis change, I would want to also revert the change
> to `PermutationGroups()`, to let it be a structure category. Indeed,
> permutation groups come with a distinguished action, and Wikipedia
> states that this action should be preserved by isomorphisms:
> 
> http://en.wikipedia.org/wiki/Permutation_group#Permutation_isomorphic_groups
> 
> Do you agree?

Yes, the set that is acted upon does seem to qualify as extra structure.

> == additional_structure w.r.t. full_super_categories ==
> 
> As discussed above, I believe that having the developer implement
> `additional_structure` rather than `full_super_categories` is more
> concise and involves less duplication. And also gives more information
> (which category define additional structure) which could be further
> refined (e.g. "Magmas()" defines "*"), if deemed useful in later
> iterations.
> 
> Is this acceptable for everyone?

That sounds good to me.

> == additional_structure w.r.t is_structure_category ==
> 
> Do we have a consensus that the "additional_structure / structure"
> language is better than "is_structure_category /
> all_structure_super_categories"? And that for now we can specify that
> `C.additional_structure()` shall return `C` or `None`?
> 
> If yes, I can implement this change shortly.

I am in favour of this change.

> == Default for axioms ==
> 
> Currently, axiom categories define no additional structure by default.
> To be 100% foolproof even when defining new axioms, one could change
> that so an axiom category `C().A()` would by default define additional
> structure if and only if `C` is the category defining the axiom `A`.

I am not in favour of this, because it would conflate the notions of "axiom" and "extra structure" (which from my perspective are quite different) even more.



---

archive/issue_comments_209771.json:
```json
{
    "body": "Replying to [comment:50 tscrim]:\n\n> I'm okay with the default for axioms not being structure categories. However I'd rather have fuctorial construction categories being structure categories by default (I believe currently we only have two, graded and with-realizations, but the two I'd like to add, topological and metric, have additional structure).\n\nIt may be because I'm still misled by the terminology, but I'm afraid this only increases my confusion about what functorial construction categories are.  In what sense do \"topological\" and \"metric\" have something to do with modelling codomains of a collection of functors?  (Of course topological/metric spaces can be domains/codomains of functors, but I don't think this is what Nicolas meant in comment:49).\n\nTo me \"topological\" and \"metric\" are examples of \"extra structure\", in the sense that there are canonical functors (metric spaces) -> (topological spaces) -> (sets).  In the current Sage implementation/parlance, I guess they would be regarded as examples of axioms.",
    "created_at": "2014-09-26T08:27:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209771",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:50 tscrim]:

> I'm okay with the default for axioms not being structure categories. However I'd rather have fuctorial construction categories being structure categories by default (I believe currently we only have two, graded and with-realizations, but the two I'd like to add, topological and metric, have additional structure).

It may be because I'm still misled by the terminology, but I'm afraid this only increases my confusion about what functorial construction categories are.  In what sense do "topological" and "metric" have something to do with modelling codomains of a collection of functors?  (Of course topological/metric spaces can be domains/codomains of functors, but I don't think this is what Nicolas meant in comment:49).

To me "topological" and "metric" are examples of "extra structure", in the sense that there are canonical functors (metric spaces) -> (topological spaces) -> (sets).  In the current Sage implementation/parlance, I guess they would be regarded as examples of axioms.



---

archive/issue_comments_209772.json:
```json
{
    "body": "Replying to [comment:52 pbruin]:\n> It may be because I'm still misled by the terminology, but I'm afraid this only increases my confusion about what functorial construction categories are.  In what sense do \"topological\" and \"metric\" have something to do with modelling codomains of a collection of functors?  (Of course topological/metric spaces can be domains/codomains of functors, but I don't think this is what Nicolas meant in comment:49).\n> \n> To me \"topological\" and \"metric\" are examples of \"extra structure\", in the sense that there are canonical functors (metric spaces) -> (topological spaces) -> (sets).  In the current Sage implementation/parlance, I guess they would be regarded as examples of axioms.\n\nThis may not be the right way, but I think of these functional construction categories as additional data to some base category `C` in which every object of `C` has a natural way to construct this data that preserves the morphisms. For graded, make everything be in the 0-th graded part. For metric/topological, give it the discrete metric/topology.\n\nActually running with that example, an object in graded algebras would be the pair `(A, deg)`, right? So if we consider the section of the forgetful function where `deg(x) = 0` for all `x` in `A`, this would have algebras as a full subcategory of graded algebras, right? So I think we might need to be careful with how we are considering the base categories inside of the functorial construction category. On that, I reverse my position, functorial construction categories should not be structure categories because of the natural inclusion mentioned above (unless I'm wrong).",
    "created_at": "2014-09-26T11:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209772",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:52 pbruin]:
> It may be because I'm still misled by the terminology, but I'm afraid this only increases my confusion about what functorial construction categories are.  In what sense do "topological" and "metric" have something to do with modelling codomains of a collection of functors?  (Of course topological/metric spaces can be domains/codomains of functors, but I don't think this is what Nicolas meant in comment:49).
> 
> To me "topological" and "metric" are examples of "extra structure", in the sense that there are canonical functors (metric spaces) -> (topological spaces) -> (sets).  In the current Sage implementation/parlance, I guess they would be regarded as examples of axioms.

This may not be the right way, but I think of these functional construction categories as additional data to some base category `C` in which every object of `C` has a natural way to construct this data that preserves the morphisms. For graded, make everything be in the 0-th graded part. For metric/topological, give it the discrete metric/topology.

Actually running with that example, an object in graded algebras would be the pair `(A, deg)`, right? So if we consider the section of the forgetful function where `deg(x) = 0` for all `x` in `A`, this would have algebras as a full subcategory of graded algebras, right? So I think we might need to be careful with how we are considering the base categories inside of the functorial construction category. On that, I reverse my position, functorial construction categories should not be structure categories because of the natural inclusion mentioned above (unless I'm wrong).



---

archive/issue_comments_209773.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-13T09:41:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209773",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209774.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-13T12:03:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209774",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209775.json:
```json
{
    "body": "For info: Simon is sitting with me in Orsay, and we will be banging\ntogether on this ticket and follow ups in the next few days.\n\nExpect some action :-) Finally!\n\nCheers,\n                        Nicolas",
    "created_at": "2014-10-13T12:04:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209775",
    "user": "https://github.com/nthiery"
}
```

For info: Simon is sitting with me in Orsay, and we will be banging
together on this ticket and follow ups in the next few days.

Expect some action :-) Finally!

Cheers,
                        Nicolas



---

archive/issue_comments_209776.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-14T12:44:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209776",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209777.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-15T10:06:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209777",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209778.json:
```json
{
    "body": "I went through all of the diff, fixed some typos, and I checked that with #10668 all tests pass. To be on the safe side, I will re-run certain tests with this branch, but it is close to a positive review.",
    "created_at": "2014-10-15T10:09:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209778",
    "user": "https://github.com/simon-king-jena"
}
```

I went through all of the diff, fixed some typos, and I checked that with #10668 all tests pass. To be on the safe side, I will re-run certain tests with this branch, but it is close to a positive review.



---

archive/issue_comments_209779.json:
```json
{
    "body": "Replying to [comment:30 pbruin]:\n> Is it clear that the \"structure category\" terminology is the way to go?  Personally I still don't like it very much (again, it pretends to be about categories but instead is about relations to their supercategories).  I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.\n\nThis is not really addressed yet: There is `additional_structure`, but it returns `self` or `None`.\n\nAnyway, I am still somewhat confident that I can make something out of the idea to use Gr\u00f6bner bases in boolean polynomial rings to deal with deduction rules (\u00e0 la Wedderburn Theorem) for axioms *and* structures. And then, it would be a matter of filling a dictionary with information about what structure corresponds to what operation.",
    "created_at": "2014-10-15T10:23:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209779",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:30 pbruin]:
> Is it clear that the "structure category" terminology is the way to go?  Personally I still don't like it very much (again, it pretends to be about categories but instead is about relations to their supercategories).  I would prefer the proposals made by Nicolas in comment:9 and Simon in comment:10 to have an `additional_structure()` method that returns something meaningful about the additional structure, not just True or False.

This is not really addressed yet: There is `additional_structure`, but it returns `self` or `None`.

Anyway, I am still somewhat confident that I can make something out of the idea to use Grbner bases in boolean polynomial rings to deal with deduction rules ( la Wedderburn Theorem) for axioms *and* structures. And then, it would be a matter of filling a dictionary with information about what structure corresponds to what operation.



---

archive/issue_comments_209780.json:
```json
{
    "body": "Replying to [comment:53 tscrim]:\n> Replying to [comment:52 pbruin]:\n> > It may be because I'm still misled by the terminology, but I'm afraid this only increases my confusion about what functorial construction categories are.  In what sense do \"topological\" and \"metric\" have something to do with modelling codomains of a collection of functors?  (Of course topological/metric spaces can be domains/codomains of functors, but I don't think this is what Nicolas meant in comment:49).\n> > \n> > To me \"topological\" and \"metric\" are examples of \"extra structure\", in the sense that there are canonical functors (metric spaces) -> (topological spaces) -> (sets).  In the current Sage implementation/parlance, I guess they would be regarded as examples of axioms.\n> \n> This may not be the right way, but I think of these functional construction categories as additional data to some base category `C` in which every object of `C` has a natural way to construct this data that preserves the morphisms. For graded, make everything be in the 0-th graded part. For metric/topological, give it the discrete metric/topology.\n> \n> Actually running with that example, an object in graded algebras would be the pair `(A, deg)`, right? So if we consider the section of the forgetful function where `deg(x) = 0` for all `x` in `A`, this would have algebras as a full subcategory of graded algebras, right? So I think we might need to be careful with how we are considering the base categories inside of the functorial construction category. On that, I reverse my position, functorial construction categories should not be structure categories because of the natural inclusion mentioned above (unless I'm wrong).\n\nI am not very much confident about the functorial constructions either. I am (re-)reading the chapter on functorial constructions in the category primer right now.\n\nAnyway, it seems to me that Nicolas has addressed the concerns expressed here (I was rereading all comments), the code is relatively clear (to me, the unclear parts concern things that existed before, like functorial constructions), and moreover all tests pass. So, if nobody objects, I am putting this to positive review, after reading the chapter in the primer...",
    "created_at": "2014-10-15T13:23:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209780",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:53 tscrim]:
> Replying to [comment:52 pbruin]:
> > It may be because I'm still misled by the terminology, but I'm afraid this only increases my confusion about what functorial construction categories are.  In what sense do "topological" and "metric" have something to do with modelling codomains of a collection of functors?  (Of course topological/metric spaces can be domains/codomains of functors, but I don't think this is what Nicolas meant in comment:49).
> > 
> > To me "topological" and "metric" are examples of "extra structure", in the sense that there are canonical functors (metric spaces) -> (topological spaces) -> (sets).  In the current Sage implementation/parlance, I guess they would be regarded as examples of axioms.
> 
> This may not be the right way, but I think of these functional construction categories as additional data to some base category `C` in which every object of `C` has a natural way to construct this data that preserves the morphisms. For graded, make everything be in the 0-th graded part. For metric/topological, give it the discrete metric/topology.
> 
> Actually running with that example, an object in graded algebras would be the pair `(A, deg)`, right? So if we consider the section of the forgetful function where `deg(x) = 0` for all `x` in `A`, this would have algebras as a full subcategory of graded algebras, right? So I think we might need to be careful with how we are considering the base categories inside of the functorial construction category. On that, I reverse my position, functorial construction categories should not be structure categories because of the natural inclusion mentioned above (unless I'm wrong).

I am not very much confident about the functorial constructions either. I am (re-)reading the chapter on functorial constructions in the category primer right now.

Anyway, it seems to me that Nicolas has addressed the concerns expressed here (I was rereading all comments), the code is relatively clear (to me, the unclear parts concern things that existed before, like functorial constructions), and moreover all tests pass. So, if nobody objects, I am putting this to positive review, after reading the chapter in the primer...



---

archive/issue_comments_209781.json:
```json
{
    "body": "Hm. I did not find the category primer very helpful, as it only gives an example (cartesian product) on objects. But it does not tell what actually happens to the categories, and it does not tell how it is defined, nor how it is implemented. I somehow recall from reviewing it how it was implemented, but I would not easily be able to provide a mathematical definition.\n\nAnyway. The new code that we are discussing here seems good to me.",
    "created_at": "2014-10-15T13:32:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209781",
    "user": "https://github.com/simon-king-jena"
}
```

Hm. I did not find the category primer very helpful, as it only gives an example (cartesian product) on objects. But it does not tell what actually happens to the categories, and it does not tell how it is defined, nor how it is implemented. I somehow recall from reviewing it how it was implemented, but I would not easily be able to provide a mathematical definition.

Anyway. The new code that we are discussing here seems good to me.



---

archive/issue_comments_209782.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-10-15T13:32:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209782",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_048164.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-10-16T21:10:33Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16103#event-48164"
}
```



---

archive/issue_comments_209783.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-10-16T21:10:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209783",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_209784.json:
```json
{
    "body": "Yeah! Thanks everyone for the review!",
    "created_at": "2014-10-16T21:22:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209784",
    "user": "https://github.com/nthiery"
}
```

Yeah! Thanks everyone for the review!



---

archive/issue_comments_209785.json:
```json
{
    "body": "`O_o`\n\nWasn't there a way to make all these classes inherit the `additional_structure` -> `return None` function ?..\n\nNathann",
    "created_at": "2014-10-17T14:15:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209785",
    "user": "https://github.com/nathanncohen"
}
```

`O_o`

Wasn't there a way to make all these classes inherit the `additional_structure` -> `return None` function ?..

Nathann



---

archive/issue_comments_209786.json:
```json
{
    "body": "Replying to [comment:65 ncohen]:\n> `O_o`\n> \n> Wasn't there a way to make all these classes inherit the `additional_structure` -> `return None` function ?..\n\nProbably not, if you talk about the case that `return self` is the default for categories that are not `CategoryWithAxiom`.\n\nIf you have a default (which here is chosen so that the test for a full subcategory will not give a false-positive answer by default), then you need to do something special for all cases that are special.",
    "created_at": "2014-10-17T14:23:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209786",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:65 ncohen]:
> `O_o`
> 
> Wasn't there a way to make all these classes inherit the `additional_structure` -> `return None` function ?..

Probably not, if you talk about the case that `return self` is the default for categories that are not `CategoryWithAxiom`.

If you have a default (which here is chosen so that the test for a full subcategory will not give a false-positive answer by default), then you need to do something special for all cases that are special.



---

archive/issue_comments_209787.json:
```json
{
    "body": "Yo !\n\n> Probably not, if you talk about the case that `return self` is the default for categories that are not `CategoryWithAxiom`.\n> \n> If you have a default (which here is chosen so that the test for a full subcategory will not give a false-positive answer by default), then you need to do something special for all cases that are special.\n\nHmmmmm... Then perhaps only a flag when this infrastructure is initialized ? Doesn't matter much I guess, I it just unpleasant to see the same (empty) function being copy/pasted one thousand times.\n\nNathann",
    "created_at": "2014-10-17T14:36:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209787",
    "user": "https://github.com/nathanncohen"
}
```

Yo !

> Probably not, if you talk about the case that `return self` is the default for categories that are not `CategoryWithAxiom`.
> 
> If you have a default (which here is chosen so that the test for a full subcategory will not give a false-positive answer by default), then you need to do something special for all cases that are special.

Hmmmmm... Then perhaps only a flag when this infrastructure is initialized ? Doesn't matter much I guess, I it just unpleasant to see the same (empty) function being copy/pasted one thousand times.

Nathann



---

archive/issue_comments_209788.json:
```json
{
    "body": "Replying to [comment:67 ncohen]:\n> Hmmmmm... Then perhaps only a flag when this infrastructure is initialized ? Doesn't matter much I guess, I it just unpleasant to see the same (empty) function being copy/pasted one thousand times.\n\nOr an attribute `_adds_structure`, and then define something like the following:\n\n```python\ndef additional_structure(self):\n    if getattr(self._adds_structure, None):\n        return self\n```\n\nIn that way, the method `additional_structure` would be defined only in three places (default for categories, for categories with axiom, and for functorial constructions), and non-default behaviour could be requested more light-weight.\n\nNicolas, what do you think about it? To me, it sounds like a good idea.",
    "created_at": "2014-10-17T14:42:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209788",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:67 ncohen]:
> Hmmmmm... Then perhaps only a flag when this infrastructure is initialized ? Doesn't matter much I guess, I it just unpleasant to see the same (empty) function being copy/pasted one thousand times.

Or an attribute `_adds_structure`, and then define something like the following:

```python
def additional_structure(self):
    if getattr(self._adds_structure, None):
        return self
```

In that way, the method `additional_structure` would be defined only in three places (default for categories, for categories with axiom, and for functorial constructions), and non-default behaviour could be requested more light-weight.

Nicolas, what do you think about it? To me, it sounds like a good idea.



---

archive/issue_comments_209789.json:
```json
{
    "body": "Also, if I may say: the name \"additional_structure\" is like *VERY* vague. Perhaps this is the best you can do on the \"mathematical side\" of the feature, but it may be possible to give it a more informative name describing what exactly this parameter does, i.e. a more code-specific description.\n\nBut of course I have absolutely no idea of what I am talking about.\n\nNathann",
    "created_at": "2014-10-17T14:47:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209789",
    "user": "https://github.com/nathanncohen"
}
```

Also, if I may say: the name "additional_structure" is like *VERY* vague. Perhaps this is the best you can do on the "mathematical side" of the feature, but it may be possible to give it a more informative name describing what exactly this parameter does, i.e. a more code-specific description.

But of course I have absolutely no idea of what I am talking about.

Nathann



---

archive/issue_comments_209790.json:
```json
{
    "body": "Replying to [comment:65 ncohen]:\n> Wasn't there a way to make all these classes inherit the `additional_structure` -> `return None` function ?..\n\nYeah, I agree it's verbose looking. But I am actually quite happy that\nthe design allowed us to explicitly insert so few additional\ninformation :-)\n\nWith this ticket, we are really adding a not so trivial mathematical\ninformation to almost 260+ categories (what shall, or not, be\npreserved by morphisms); thanks to the chosen defaults (which depend\non whether we have a category with axiom, a construction category, or\n...) we had to special case only about 20 categories. For each of\nthem, there was a conscious design decision taken, some of which took\na bit of discussion; each such decision has to be documented and\ntested. Hence we really want the doctests. In particular, having an\nattribute instead of a method would not save anything.\n\nCheers,\n                                 Nicolas",
    "created_at": "2014-10-18T08:20:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209790",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:65 ncohen]:
> Wasn't there a way to make all these classes inherit the `additional_structure` -> `return None` function ?..

Yeah, I agree it's verbose looking. But I am actually quite happy that
the design allowed us to explicitly insert so few additional
information :-)

With this ticket, we are really adding a not so trivial mathematical
information to almost 260+ categories (what shall, or not, be
preserved by morphisms); thanks to the chosen defaults (which depend
on whether we have a category with axiom, a construction category, or
...) we had to special case only about 20 categories. For each of
them, there was a conscious design decision taken, some of which took
a bit of discussion; each such decision has to be documented and
tested. Hence we really want the doctests. In particular, having an
attribute instead of a method would not save anything.

Cheers,
                                 Nicolas



---

archive/issue_comments_209791.json:
```json
{
    "body": "Replying to [comment:69 ncohen]:\n> Also, if I may say: the name \"additional_structure\" is like *VERY* vague. Perhaps this is the best you can do on the \"mathematical side\" of the feature, but it may be possible to give it a more informative name describing what exactly this parameter does, i.e. a more code-specific description.\n\nI am open to suggestions. This is completely local to categories and easy to change. That being said, since it's a method on categories, the context is rather well specified. And in this context, it's rather customary to say things like ``a ring is a set endowed with a *structure* of unital magma and unital additive magma satisfying the axioms xxx'':\n\n```\nsage: Rings().structure()\nfrozenset({Category of additive unital additive magmas,\n           Category of additive magmas,\n           Category of unital magmas,\n           Category of magmas,\n           Category of sets with partial maps,\n           Category of sets})\nsage: Rings().axioms()\nfrozenset({'AdditiveAssociative',\n           'AdditiveCommutative',\n           'AdditiveInverse',\n           'AdditiveUnital',\n           'Associative',\n           'Distributive',\n           'Unital'})\n```\n\n\n(btw: for that purpose, in the first example above, we might want to have a separate method that returns only the lowest categories, i.e. unital magmas and additive unital magmas).\n\nThen, from \"structure\" to \"additional structure\", the leap is not too big.\n\nCheers,\n                              Nicolas",
    "created_at": "2014-10-18T08:27:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16103#issuecomment-209791",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:69 ncohen]:
> Also, if I may say: the name "additional_structure" is like *VERY* vague. Perhaps this is the best you can do on the "mathematical side" of the feature, but it may be possible to give it a more informative name describing what exactly this parameter does, i.e. a more code-specific description.

I am open to suggestions. This is completely local to categories and easy to change. That being said, since it's a method on categories, the context is rather well specified. And in this context, it's rather customary to say things like ``a ring is a set endowed with a *structure* of unital magma and unital additive magma satisfying the axioms xxx'':

```
sage: Rings().structure()
frozenset({Category of additive unital additive magmas,
           Category of additive magmas,
           Category of unital magmas,
           Category of magmas,
           Category of sets with partial maps,
           Category of sets})
sage: Rings().axioms()
frozenset({'AdditiveAssociative',
           'AdditiveCommutative',
           'AdditiveInverse',
           'AdditiveUnital',
           'Associative',
           'Distributive',
           'Unital'})
```


(btw: for that purpose, in the first example above, we might want to have a separate method that returns only the lowest categories, i.e. unital magmas and additive unital magmas).

Then, from "structure" to "additional structure", the leap is not too big.

Cheers,
                              Nicolas
