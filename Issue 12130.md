# Issue 12130: Partial evaluation bug for callable vector functions

archive/issues_012130.json:
```json
{
    "body": "Assignee: gbe\n\nCC:  jason\n\nKeywords: sd35.5\n\nFor callable (scalar) functions, taking sections (partial evaluation) of functions works perfectly fine; that is to say the following code works perfectly as expected:\n\n```\nsage: f(x,y,z) = x*y*z; f\n(x, y, z) |--> x*y*z\nsage: g(x, z) = f(y=1); g\n(x, z) |--> x*z\n```\n\n\nMove up to callable vector functions and taking sections breaks however:\n\n```\nsage: v(x, y) = [x+y, x-y]; v\n(x, y) |--> (x + y, x - y)\nsage: v(x,0)\n(x, x)\nsage: w(x) = v(y=0)\nTypeError\n```\n\n\n**This is because *all* evaluation, even if partial, of a callable vector function returns a Vector_symbolic_dense.**\n\nThe fix, of course, is to make the code intelligent enough to know that an evaluation is only partial -- one hopes that ``type(vx)`` would return 'sage.modules.vector_callable_symbolic_dense.Vector_callable_symbolic_dense'> rather than 'sage.modules.vector_symbolic_dense.Vector_symbolic_dense'>\n\n```\nsage: v(x, y) = [x+y, x-y]\nsage: type(v)\n<class 'sage.modules.vector_callable_symbolic_dense.Vector_callable_symbolic_dense'>\nsage: vx = v(y=0); vx\n(x,x)\nsage: type(vx)\n<class 'sage.modules.vector_symbolic_dense.Vector_symbolic_dense'>\n```\n\n\n**Work-around**\n\nThis isn't *so* bad since we can still do:\n\n```\nsage: v(x, y) = [x+y, x-y]\nsage: vx = v(y=0)\n```\n\n\nNow, if every entry still has a variable everything, including positional rather than named arguments work. \n\n```\nsage: v(x, y) = [x+y, x-y]\nsage: vx = v(y=0)\nsage: vx(x=1)\n(1, 1)\nsage: vx(1) #deprecated, but works fine\n```\n\n\nHowever, things break if taking a section kills off all variables in any component we try to use positional arguments:\n\n```\nsage: v(x, y) = [x+y, x-y]\nsage: vy = v(y=x)\nsage: vy\n(2*x, 0)\nsage: vx\n(x, x)\nsage: vy(x=1) #named arguments still work\n(2, 0)\nsage: vy(1) #positional arguments don't\nValueError\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/12302\n\n",
    "created_at": "2012-01-12T19:44:46Z",
    "labels": [
        "symbolics",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Partial evaluation bug for callable vector functions",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/12130",
    "user": "gbe"
}
```
Assignee: gbe

CC:  jason

Keywords: sd35.5

For callable (scalar) functions, taking sections (partial evaluation) of functions works perfectly fine; that is to say the following code works perfectly as expected:

```
sage: f(x,y,z) = x*y*z; f
(x, y, z) |--> x*y*z
sage: g(x, z) = f(y=1); g
(x, z) |--> x*z
```


Move up to callable vector functions and taking sections breaks however:

```
sage: v(x, y) = [x+y, x-y]; v
(x, y) |--> (x + y, x - y)
sage: v(x,0)
(x, x)
sage: w(x) = v(y=0)
TypeError
```


**This is because *all* evaluation, even if partial, of a callable vector function returns a Vector_symbolic_dense.**

The fix, of course, is to make the code intelligent enough to know that an evaluation is only partial -- one hopes that ``type(vx)`` would return 'sage.modules.vector_callable_symbolic_dense.Vector_callable_symbolic_dense'> rather than 'sage.modules.vector_symbolic_dense.Vector_symbolic_dense'>

```
sage: v(x, y) = [x+y, x-y]
sage: type(v)
<class 'sage.modules.vector_callable_symbolic_dense.Vector_callable_symbolic_dense'>
sage: vx = v(y=0); vx
(x,x)
sage: type(vx)
<class 'sage.modules.vector_symbolic_dense.Vector_symbolic_dense'>
```


**Work-around**

This isn't *so* bad since we can still do:

```
sage: v(x, y) = [x+y, x-y]
sage: vx = v(y=0)
```


Now, if every entry still has a variable everything, including positional rather than named arguments work. 

```
sage: v(x, y) = [x+y, x-y]
sage: vx = v(y=0)
sage: vx(x=1)
(1, 1)
sage: vx(1) #deprecated, but works fine
```


However, things break if taking a section kills off all variables in any component we try to use positional arguments:

```
sage: v(x, y) = [x+y, x-y]
sage: vy = v(y=x)
sage: vy
(2*x, 0)
sage: vx
(x, x)
sage: vy(x=1) #named arguments still work
(2, 0)
sage: vy(1) #positional arguments don't
ValueError
```


Issue created by migration from https://trac.sagemath.org/ticket/12302


