# Issue 12130: Partial evaluation bug for callable vector functions

Issue created by migration from https://trac.sagemath.org/ticket/12302

Original creator: gbe

Original creation time: 2012-01-12 19:44:46

Assignee: gbe

CC:  jason

Keywords: sd35.5

For callable (scalar) functions, taking sections (partial evaluation) of functions works perfectly fine; that is to say the following code works perfectly as expected:

```
sage: f(x,y,z) = x*y*z; f
(x, y, z) |--> x*y*z
sage: g(x, z) = f(y=1); g
(x, z) |--> x*z
```


Move up to callable vector functions and taking sections breaks however:

```
sage: v(x, y) = [x+y, x-y]; v
(x, y) |--> (x + y, x - y)
sage: v(x,0)
(x, x)
sage: w(x) = v(y=0)
TypeError
```


*This is because _all_ evaluation, even if partial, of a callable vector function returns a Vector_symbolic_dense.*

The fix, of course, is to make the code intelligent enough to know that an evaluation is only partial -- one hopes that ``type(vx)`` would return 'sage.modules.vector_callable_symbolic_dense.Vector_callable_symbolic_dense'> rather than 'sage.modules.vector_symbolic_dense.Vector_symbolic_dense'>

```
sage: v(x, y) = [x+y, x-y]
sage: type(v)
<class 'sage.modules.vector_callable_symbolic_dense.Vector_callable_symbolic_dense'>
sage: vx = v(y=0); vx
(x,x)
sage: type(vx)
<class 'sage.modules.vector_symbolic_dense.Vector_symbolic_dense'>
```


*Work-around*

This isn't _so_ bad since we can still do:

```
sage: v(x, y) = [x+y, x-y]
sage: vx = v(y=0)
```


Now, if every entry still has a variable everything, including positional rather than named arguments work. 

```
sage: v(x, y) = [x+y, x-y]
sage: vx = v(y=0)
sage: vx(x=1)
(1, 1)
sage: vx(1) #deprecated, but works fine
```


However, things break if taking a section kills off all variables in any component we try to use positional arguments:

```
sage: v(x, y) = [x+y, x-y]
sage: vy = v(y=x)
sage: vy
(2*x, 0)
sage: vx
(x, x)
sage: vy(x=1) #named arguments still work
(2, 0)
sage: vy(1) #positional arguments don't
ValueError
```

