# Issue 18847: libSingular functions' ring parameter defaults to the last used ring

archive/issues_018847.json:
```json
{
    "body": "CC:  jakobkroeker malb\n\nlibSingular functions require a ring parameter set. But for some functions the ring parameter is redundant.\n\nMartin Albrecht answers to this issue:\n\nWe could do this: \n\n- if no ring is given, we try to find one as we do currently. \n- if that fails because the inputs are not polynomials of any kind, we could use a dummy ring.\n\nMy own solution to this problem is to store the last used ring in libSingular function calls, instead of using a dummy ring. In a Singular function call, if a ring is not found from the arguments, then the ring parameter defaults to the last used ring. The initial \"last used\" ring is set to `PolynomialRing(QQ,2,'x,y')`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/19084\n\n",
    "created_at": "2015-08-25T07:47:34Z",
    "labels": [
        "interfaces",
        "minor",
        "enhancement"
    ],
    "title": "libSingular functions' ring parameter defaults to the last used ring",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18847",
    "user": "klee"
}
```
CC:  jakobkroeker malb

libSingular functions require a ring parameter set. But for some functions the ring parameter is redundant.

Martin Albrecht answers to this issue:

We could do this: 

- if no ring is given, we try to find one as we do currently. 
- if that fails because the inputs are not polynomials of any kind, we could use a dummy ring.

My own solution to this problem is to store the last used ring in libSingular function calls, instead of using a dummy ring. In a Singular function call, if a ring is not found from the arguments, then the ring parameter defaults to the last used ring. The initial "last used" ring is set to `PolynomialRing(QQ,2,'x,y')`.

Issue created by migration from https://trac.sagemath.org/ticket/19084





---

archive/issue_comments_257937.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-25T07:50:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257937",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257938.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-08-25T13:50:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257938",
    "user": "klee"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_257939.json:
```json
{
    "body": "Could you just change the initial assignment to `last_ring` to\n\n```\nlast_ring=PolynomialRing(QQ,\"dummy\",1)\n```\n\nand *not* update `last_ring`? Perhaps rename the global variable to `dummy_ring` too.\n\nThere are some reasons why using a dedicated dummy ring might be nicer than reusing arbitrary objects for the purpose:\n- by making global links to arbitrary objects, where the global link has a rather unpredictable lifetime, you're making garbage collection and detection of memory leaks harder.\n- you're making a link to a globally unique object. In principle, you're allowed to do so, but this can have very subtle effects on the system, because it can change the minimal lifetime of all kinds of related objects. So for the sake of sanity in debugging elsewhere, it might be better to not do this.\n\nA pro of your current approach is that you might avoid having to create a dummy ring, thus saving the slight memory penalty for it.",
    "created_at": "2015-08-26T01:32:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257939",
    "user": "nbruin"
}
```

Could you just change the initial assignment to `last_ring` to

```
last_ring=PolynomialRing(QQ,"dummy",1)
```

and *not* update `last_ring`? Perhaps rename the global variable to `dummy_ring` too.

There are some reasons why using a dedicated dummy ring might be nicer than reusing arbitrary objects for the purpose:
- by making global links to arbitrary objects, where the global link has a rather unpredictable lifetime, you're making garbage collection and detection of memory leaks harder.
- you're making a link to a globally unique object. In principle, you're allowed to do so, but this can have very subtle effects on the system, because it can change the minimal lifetime of all kinds of related objects. So for the sake of sanity in debugging elsewhere, it might be better to not do this.

A pro of your current approach is that you might avoid having to create a dummy ring, thus saving the slight memory penalty for it.



---

archive/issue_comments_257940.json:
```json
{
    "body": "Replying to [comment:3 nbruin]:\n> Could you just change the initial assignment to `last_ring` to\n> {{{\n> last_ring=PolynomialRing(QQ,\"dummy\",1)\n> }}}\n\nThis seems better. I will do it.\n\n> There are some reasons why using a dedicated dummy ring might be nicer than reusing arbitrary objects for the purpose:\n>  - by making global links to arbitrary objects, where the global link has a rather unpredictable lifetime, you're making garbage collection and detection of memory leaks harder.\n\nI don't understand this very well, mainly because I don't have a good sense about the garbage collection and memory leaks problems.\n\n>  - you're making a link to a globally unique object. In principle, you're allowed to do so, but this can have very subtle effects on the system, because it can change the minimal lifetime of all kinds of related objects. So for the sake of sanity in debugging elsewhere, it might be better to not do this.\n\nI don't understand this...\n\n> A pro of your current approach is that you might avoid having to create a dummy ring, thus saving the slight memory penalty for it.\n\nThis is not true since a dummy ring is created initially.\n\nA pro of my approach, I think, is reusing the user's \"current\" ring, thus minimizing switching of the internal Singular (current) ring, which seems a good thing.\n\nAs I am not sure about the seriousness of the issues you raised, I will wait for Martin's opinion about this. If the two experts, Martin and you, concern about my approach, then I will adopt your suggestion.",
    "created_at": "2015-08-26T02:43:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257940",
    "user": "klee"
}
```

Replying to [comment:3 nbruin]:
> Could you just change the initial assignment to `last_ring` to
> {{{
> last_ring=PolynomialRing(QQ,"dummy",1)
> }}}

This seems better. I will do it.

> There are some reasons why using a dedicated dummy ring might be nicer than reusing arbitrary objects for the purpose:
>  - by making global links to arbitrary objects, where the global link has a rather unpredictable lifetime, you're making garbage collection and detection of memory leaks harder.

I don't understand this very well, mainly because I don't have a good sense about the garbage collection and memory leaks problems.

>  - you're making a link to a globally unique object. In principle, you're allowed to do so, but this can have very subtle effects on the system, because it can change the minimal lifetime of all kinds of related objects. So for the sake of sanity in debugging elsewhere, it might be better to not do this.

I don't understand this...

> A pro of your current approach is that you might avoid having to create a dummy ring, thus saving the slight memory penalty for it.

This is not true since a dummy ring is created initially.

A pro of my approach, I think, is reusing the user's "current" ring, thus minimizing switching of the internal Singular (current) ring, which seems a good thing.

As I am not sure about the seriousness of the issues you raised, I will wait for Martin's opinion about this. If the two experts, Martin and you, concern about my approach, then I will adopt your suggestion.



---

archive/issue_comments_257941.json:
```json
{
    "body": "Replying to [comment:4 klee]:\n> > A pro of your current approach is that you might avoid having to create a dummy ring, thus saving the slight memory penalty for it.\n> This is not true since a dummy ring is created initially.\n\nIf the first call that arrives does have a ring parameter (the usual circumstance) then doesn't that ring get used? You could just leave `last_ring` uninitialized and only give it your dummy value if the value is required before `last_ring = ring` is executed. But as I discussed, I think there are drawbacks reusing rings of interest to the user for this purpose.\n\nNote, by the way, that we have a `currRingHdl` just above it, which also gets initialized to a dummy value. If we're going to keep a dummy ring around on sage level, we might as well make the singular dummy ring the matching singular ring to that sage dummy ring. That should significantly simplify proper reference counting of that object, if we ever figure out how to properly interface with singular's reference counts (we currently don't).\n\n> A pro of my approach, I think, is reusing the user's \"current\" ring, thus minimizing switching of the internal Singular (current) ring, which seems a good thing.\n\nDo we check that? In that case you might want to do some timing. Note that most calls will have a ring anyway, so you'll have to search hard for an example where it matters.\n\n> As I am not sure about the seriousness of the issues you raised, I will wait for Martin's opinion about this. If the two experts, Martin and you, concern about my approach, then I will adopt your suggestion. \n\nYes, good plan (although I wouldn't call myself an expert on libSingular--I've just seen some truly horrible debugging of memory leaks around it)",
    "created_at": "2015-08-26T03:16:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257941",
    "user": "nbruin"
}
```

Replying to [comment:4 klee]:
> > A pro of your current approach is that you might avoid having to create a dummy ring, thus saving the slight memory penalty for it.
> This is not true since a dummy ring is created initially.

If the first call that arrives does have a ring parameter (the usual circumstance) then doesn't that ring get used? You could just leave `last_ring` uninitialized and only give it your dummy value if the value is required before `last_ring = ring` is executed. But as I discussed, I think there are drawbacks reusing rings of interest to the user for this purpose.

Note, by the way, that we have a `currRingHdl` just above it, which also gets initialized to a dummy value. If we're going to keep a dummy ring around on sage level, we might as well make the singular dummy ring the matching singular ring to that sage dummy ring. That should significantly simplify proper reference counting of that object, if we ever figure out how to properly interface with singular's reference counts (we currently don't).

> A pro of my approach, I think, is reusing the user's "current" ring, thus minimizing switching of the internal Singular (current) ring, which seems a good thing.

Do we check that? In that case you might want to do some timing. Note that most calls will have a ring anyway, so you'll have to search hard for an example where it matters.

> As I am not sure about the seriousness of the issues you raised, I will wait for Martin's opinion about this. If the two experts, Martin and you, concern about my approach, then I will adopt your suggestion. 

Yes, good plan (although I wouldn't call myself an expert on libSingular--I've just seen some truly horrible debugging of memory leaks around it)



---

archive/issue_comments_257942.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-04T04:45:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257942",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257943.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-04T04:54:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257943",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257944.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-04T05:00:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257944",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257945.json:
```json
{
    "body": "As there is no further comment from Martin, I decided to follow suggestions by `nbruin`. So we use the fixed dummy ring instead of the last used ring. The dummy ring, univariate polynomial ring over `QQ`, is created on the first use.",
    "created_at": "2015-09-04T05:07:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257945",
    "user": "klee"
}
```

As there is no further comment from Martin, I decided to follow suggestions by `nbruin`. So we use the fixed dummy ring instead of the last used ring. The dummy ring, univariate polynomial ring over `QQ`, is created on the first use.



---

archive/issue_comments_257946.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-04T06:16:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257946",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257947.json:
```json
{
    "body": "Hmmm. Perhaps I should not have done this. The last commit is to merge Sage 7.1.beta6.",
    "created_at": "2016-03-04T06:23:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257947",
    "user": "klee"
}
```

Hmmm. Perhaps I should not have done this. The last commit is to merge Sage 7.1.beta6.



---

archive/issue_comments_257948.json:
```json
{
    "body": "Replying to [ticket:19084 klee]:\n> libSingular functions require a ring parameter set. But for some functions the ring parameter is redundant.\n> \n> Martin Albrecht answers to this issue:\n> \n> We could do this: \n> \n> - if no ring is given, we try to find one as we do currently. \n> - if that fails because the inputs are not polynomials of any kind, we could use a dummy ring.\n> \n> We implement this.\n\nI thought I have seen dummy rings in the libsingular code a couple of years ago. So, I am surprised that you say \"we implement this\". I am not sure, though, whether I will find the time to check the current code.",
    "created_at": "2016-04-15T09:01:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257948",
    "user": "SimonKing"
}
```

Replying to [ticket:19084 klee]:
> libSingular functions require a ring parameter set. But for some functions the ring parameter is redundant.
> 
> Martin Albrecht answers to this issue:
> 
> We could do this: 
> 
> - if no ring is given, we try to find one as we do currently. 
> - if that fails because the inputs are not polynomials of any kind, we could use a dummy ring.
> 
> We implement this.

I thought I have seen dummy rings in the libsingular code a couple of years ago. So, I am surprised that you say "we implement this". I am not sure, though, whether I will find the time to check the current code.



---

archive/issue_comments_257949.json:
```json
{
    "body": "Replying to [comment:16 SimonKing]:\n> I thought I have seen dummy rings in the libsingular code a couple of years ago. \n\nI don't know. Anyway this seems to be the first implementation. The essential code is quite short. The others are docstring changes.",
    "created_at": "2016-04-15T09:19:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257949",
    "user": "klee"
}
```

Replying to [comment:16 SimonKing]:
> I thought I have seen dummy rings in the libsingular code a couple of years ago. 

I don't know. Anyway this seems to be the first implementation. The essential code is quite short. The others are docstring changes.



---

archive/issue_comments_257950.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-04-15T22:01:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257950",
    "user": "vbraun"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_257951.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-04-16T10:25:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18847",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18847#issuecomment-257951",
    "user": "vbraun"
}
```

Resolution: fixed
