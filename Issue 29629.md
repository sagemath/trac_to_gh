# Issue 29629: closest_vector for IntegerLattice is broken

Issue created by migration from https://trac.sagemath.org/ticket/29866

Original creator: dimpase

Original creation time: 2020-06-15 08:03:36

CC:  malb slelievre chapoton

in this example a closest vector in L is not in L: 

```
sage: from sage.modules.free_module_integer import IntegerLattice
....: L0 = matrix(ZZ,[[20957228, -4966110],[ 9411844, 19625639]])
....: L = IntegerLattice(L0)
....: v0 = vector([-423434678248195, -18882583298608161305227077482])
....: cv = L.closest_vector(v0)
....: print(cv in L)
....: 
False
```

A simplified version of Taylor Huang's example posted on sage-devel


---

Comment by dimpase created at 2020-06-16 08:23:39

this might be just a bug in membership testing

```
from sage.modules.free_module_integer import IntegerLattice
coef = Matrix([-44429982080874270968379672793605458, 98931650854481334735580708522902113])
bMat = Matrix([[20957228, -4966110],[ 9411844, 19625639]])
L = IntegerLattice(bMat)
coef*bMat in L
```

prints `False`. (cf. continutiation of the thread on sage-devel in ticket description)


---

Comment by @asd00012334 created at 2020-06-16 08:33:31

Hi, I'm the person who came up with these examples. I can be sure that it is not only about membership testing. I've checked my examples with Smith normal form and indeed some of the closest vectors returned is not in L. So both membership and closest_vector are broken.


---

Comment by dimpase created at 2020-06-16 08:42:24

we confirm that closest vector is broken, nothing to do with membership test bug

```
sage: MGAP=libgap(M)
sage: vGAP=libgap(v)
sage: libgap.SolutionIntMat(MGAP,vGAP)
fail
```



---

Comment by dimpase created at 2020-06-16 08:48:00

Changing priority from critical to blocker.


---

Comment by dimpase created at 2020-06-16 09:15:07

closest vector got broken somewhere between Sage 8.4 (works) and 8.5 (does not).
Membership test already broken in 8.2.


---

Comment by dimpase created at 2020-06-16 09:55:50

the heavy lifting is done by fplll/fpylll.

```
Python 3.7.7 (default, May 30 2020, 01:27:43) 
[GCC 8.3.1 20190518] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from fpylll import CVP, IntegerMatrix
>>> A = IntegerMatrix.from_matrix([[20957228, -4966110], [9411844, 19625639]])
>>> t=(-423434678248195, -18882583298608161305227077482)
>>> v0 = CVP.closest_vector(A, t)
>>> v0
(-423434681577544, -18882583298608161305224294058)
```


~~this is the same vector as computed by Sage code in the ticket description, oops. So the bug may be narrowed to fp(y)lll.~~

This vector is different from what Sage outputs, namely 

```
(-423434671769860, -18882583298608161305225815339)
```

and may be verified to be in L by calling libgap, say, or just
directly:

```
sage: vector((-423434681577544, -18882583298608161305224294058)) in L
True
```


Note a comment on https://github.com/fplll/fpylll/issues/124 which says that the basis should be LLL-reduced for this to work correctly.


---

Comment by dimpase created at 2020-06-16 10:09:36

~~Thus, in view of comment:11 (corrected) the closest_vector bug is a Sage interface to fp(y)lll bug. ~~

rather, Sage has a different implementation --- which seems to be unchanged since 2015 (i.e. much before Sage 8.5...)


---

Comment by dimpase created at 2020-06-16 13:34:54

The containment is "broken", as the 1x2 matrix `coef*bMat` fails to be coersed to a vector.
Namely, with the example in the 

```
sage: vector(coef)*bMat in L
True
sage: vector(coef*bMat) in L
True
sage: coef*bMat in L
False
sage: M=matrix([1,1])
sage: M*bMat in L
False
```


so this is not really a bug, it's just a conversion issue, absence of automatic conversion.


---

Comment by slelievre created at 2020-06-16 14:31:56

This seems suspicious.

```
sage: from sage.modules.free_module_integer import IntegerLattice
sage: a = vector(ZZ, [20957228, -4966110])
sage: b = vector(ZZ, [9411844, 19625639])
sage: L = IntegerLattice([a, b])
sage: R = L.voronoi_relevant_vectors()
sage: S = [-b, -a, b - a, b, a, a - b]
sage: print([r - s for r, s in zip(R, S)])
[(0, 0), (0, 0), (0, -1), (0, 0), (0, 0), (0, 1)]
sage: print(R[-1]); print(a - b)
(11545384, -24591748)
(11545384, -24591749)
```



---

Comment by dimpase created at 2020-06-16 14:50:07

note that on Sage 8.4 (where closest_vector() still worked) this is

```
...
sage: print([r - s for r, s in zip(R, S)])
[(-2133540, 44217388), (11545384, -24591749), (-9411844, -19625639), (2133540, -44217388), (0, 0), (-2133540, 44217388)]
sage: print(R[-1]); print(a - b)
(9411844, 19625639)
(11545384, -24591749)
```



---

Comment by dimpase created at 2020-06-16 14:56:05

If fact, R computed in comment:15 is the same as the one in comment:16 (with Sage 8.4), but in a different order.


---

Comment by slelievre created at 2020-06-16 15:05:40

The voronoi cell is slightly off. It should be exactly `P` below.


```
sage: V = L.voronoi_cell()
sage: ieqs = [(x^2 + y^2, 2*x, 2*y) for x, y in (-b, -a, a-b, b, a, b-a)]
sage: P = Polyhedron(ieqs=ieqs)
sage: VP = V.plot(fill='cyan', alpha=0.5) + P.plot(fill='magenta', alpha=0.5)
sage: for v in V.vertices():
....:     x, y = v.vector()
....:     VP.show(xmin=x-1, xmax=x+1, ymin=y-1, ymax=y+1, figsize=3)
```



---

Comment by dimpase created at 2020-06-16 15:19:34

indeed, on Sage 9.2.beta1

```
sage: V.vertices()
(A vertex at (-483879947381762629327/57254902852288, 315998472693125499957/28627451426144),
 A vertex at (483879947381762629327/57254902852288, -315998472693125499957/28627451426144),
 A vertex at (5728193175888805065973/458039243775532, 1390651404779390505975/229019621887766),
 A vertex at (-708599510920502622251/229019617181844, 1552002451289776620941/114509808590922),
 A vertex at (708599510920502622251/229019617181844, -1552002451289776620941/114509808590922),
 A vertex at (-5728193175888805065973/458039243775532, -1390651404779390505975/229019621887766))
```

but on Sage 8.4

```
sage: V.vertices()
(A vertex at (5728193175888805065973/458039243775532, 1390651404779390505975/229019621887766),
 A vertex at (3871039688862599879323/458039243775532, -2527988039232444116235/229019621887766),
 A vertex at (1417199267595526864965/458039243775532, -3104005018306403526499/229019621887766),
 A vertex at (-5728193175888805065973/458039243775532, -1390651404779390505975/229019621887766),
 A vertex at (-3871039688862599879323/458039243775532, 2527988039232444116235/229019621887766),
 A vertex at (-1417199267595526864965/458039243775532, 3104005018306403526499/229019621887766))
```

quite a bit different


---

Comment by dimpase created at 2020-06-16 17:18:39

I'll try bisecting Sage  8.4 and 8.5. Might take a while...


---

Comment by slelievre created at 2020-06-16 22:20:11

Could it be #26648 with this change to the function `diamond_cut`
in `src/sage/modules/diamond_cutting.py`?

```diff
-                hv = [QQ(round(elmt, 6)) for elmt in hv]
+                hv = [QQ(elmt.n(digits=6)) for elmt in hv]
```



---

Comment by dimpase created at 2020-06-16 22:36:51

good catch - this change is certainly bad. cf.

```
sage: r=5555.55555555555555555
sage: round(r,6)
5555.555556
sage: r.n(digits=6)
5555.56
```


why it's always 6 that suffices is another question, though


---

Comment by dimpase created at 2020-06-16 22:40:57

yes, this fixes this error:

```diff
--- a/src/sage/modules/diamond_cutting.py
+++ b/src/sage/modules/diamond_cutting.py
@@ -154,6 +154,7 @@ def diamond_cut(V, GM, C, verbose=False):
         (A vertex at (2), A vertex at (0))
     """
     # coerce to floats
+    from sage.misc.functional import round
     GM = GM.n()
     C = float(C)
     if verbose:
@@ -223,7 +224,8 @@ def diamond_cut(V, GM, C, verbose=False):
                 cut_count += 1
                 if verbose:
                     print("\n%d) Cut using normal vector %s" % (cut_count, hv))
-                hv = [QQ(elmt.n(digits=6)) for elmt in hv]
+                hv = [QQ(round(elmt,6)) for elmt in hv]
+                # hv = [QQ(elmt.n(digits=6)) for elmt in hv]
                 inequalities.append(plane_inequality(hv))
 
     if verbose:
```



---

Comment by dimpase created at 2020-06-16 23:41:05

Changing status from new to needs_review.


---

Comment by dimpase created at 2020-06-16 23:41:05

I wonder how many more of these `round()` calls were butchered this way, or this was an one-off event.
----
New commits:


---

Comment by dimpase created at 2020-06-17 08:38:13

The line

```
hv = [QQ(round(elmt, 6)) for elmt in hv]
}}} 
still bothers me a lot. Why `6` there? Is it just waiting for an example with bigger numbers to break it again?


---

Comment by git created at 2020-06-17 13:05:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2020-06-17 13:05:44

this should be robust now


---

Comment by slelievre created at 2020-06-17 13:21:16

Changing keywords from "" to "round".


---

Comment by slelievre created at 2020-06-17 13:21:16

Could it be that the conversion to `QQ` was there for inexact vectors,
say vectors over `RDF` or `RR`?

Should we add the example in the ticket description as a doctest?


---

Comment by dimpase created at 2020-06-17 13:47:24

Replying to [comment:28 slelievre]:
> Could it be that the conversion to `QQ` was there for inexact vectors,
> say vectors over `RDF` or `RR`?

for IntegerLattice this looks irrelevant.

probably it was a dodgy old workaround, from pre-PPL days.
> 
> Should we add the example in the ticket description as a doctest?

OK, I can do this.


---

Comment by slelievre created at 2020-06-17 17:52:22

Replying to [comment:29 dimpase]:
> Replying to [comment:28 slelievre]:
> > Could it be that the conversion to `QQ` was there for inexact vectors,
> > say vectors over `RDF` or `RR`?
> 
> for IntegerLattice this looks irrelevant.

Even though we are working with an integer lattice, doesn't this
offer to find the closest lattice point to a non-integer vector?


---

Comment by git created at 2020-06-17 18:38:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2020-06-17 23:20:45

Replying to [comment:30 slelievre]:
> Replying to [comment:29 dimpase]:
> > Replying to [comment:28 slelievre]:
> > > Could it be that the conversion to `QQ` was there for inexact vectors,
> > > say vectors over `RDF` or `RR`?
> > 
> > for IntegerLattice this looks irrelevant.
> 
> Even though we are working with an integer lattice, doesn't this
> offer to find the closest lattice point to a non-integer vector?

the code we're changing only deals with the lattice, not with the vector we
are finding a closest lattice point for.


---

Comment by slelievre created at 2020-06-17 23:59:08

Right! One last thing, QQ is now imported but not used,
can you remove the import?


---

Comment by git created at 2020-06-18 07:50:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2020-06-18 07:51:09

done


---

Comment by dimpase created at 2020-06-19 10:47:50

please review


---

Comment by mkoeppe created at 2020-06-19 16:49:37

Changing status from needs_review to positive_review.


---

Comment by slelievre created at 2020-06-19 21:21:36

Thanks!


---

Comment by vbraun created at 2020-06-23 22:17:50

Resolution: fixed
