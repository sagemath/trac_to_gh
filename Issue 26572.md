# Issue 26572: Wrong contains in Permutations avoiding a pattern

Issue created by migration from https://trac.sagemath.org/ticket/26809

Original creator: mantepse

Original creation time: 2018-12-03 20:58:38


```
sage: P = Permutations(3, avoiding=[[1,3,2]])
sage: P.list()
[[1, 2, 3], [3, 1, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1]]
sage: [1,3,2] in P
True
```



---

Comment by mantepse created at 2018-12-03 22:06:28

Changing status from new to needs_review.


---

Comment by mantepse created at 2018-12-03 22:06:28

New commits:


---

Comment by git created at 2018-12-04 09:10:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2019-01-06 17:35:44

Changing status from needs_review to needs_work.


---

Comment by dkrenn created at 2019-01-06 17:35:44

1.

```
+        if not StandardPermutations_n_abstract.__contains__(self, x):
```

Is it possible to user super here? (If so, I think this is the Pythonic way to do.)

2.

```
+        x = self.element_class(self, x)
```

I would write here `x = self(x)` as I think it is not guaranteed that the other works. (This comment is made from a general point of view how parent/elements are usually implemented. I have not looked at the particular implementation relevant for this code.)

3.

```
-        StandardPermutations_avoiding_generic.__init__(self, n, Permutations()([1, 2]))
+        StandardPermutations_avoiding_generic.__init__(self, n, (Permutations()([1, 2]),))
```

vs

```
-        super(StandardPermutations_avoiding_312, self).__init__(n, Permutations()([3, 1, 2]))
+        super(StandardPermutations_avoiding_312, self).__init__(n, (Permutations()([3, 1, 2]),))
```

Can one use super everywhere?

Apart from this, LGTM


---

Comment by git created at 2019-01-06 20:16:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-01-06 20:17:48

I'll do the remaining super changes in #26810.


---

Comment by mantepse created at 2019-01-06 20:18:02

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2019-01-07 13:19:45

Replying to [comment:6 mantepse]:
> I'll do the remaining super changes in #26810.

Fine for me.


---

Comment by dkrenn created at 2019-01-07 13:19:53

Changing status from needs_review to positive_review.


---

Comment by dkrenn created at 2019-01-07 13:19:53

LGTM


---

Comment by tscrim created at 2019-01-07 17:37:44

Changing status from positive_review to needs_work.


---

Comment by tscrim created at 2019-01-07 17:37:44

This could eventually raise an error if we end up adding checks:

```
        x = self(x)
        return all(x.avoids(p) for p in self.a)
```

I think you should make `x` be a generic `Permutations()(x)`.

A better way `if len(a) == 0:` changed to `if not a:`.

`@`dkernn `super` is not (more) pythonic than directly calling the base class. You lose explicitness but gain by taking the direct superclass (so it reflects changes in the MRO if you insert a new class between itself and the base). I would avoid changing explicit base class calls to `super` unless there is a good reason to do so as it is a needless change.

Also `self.element_class(self, x)` is usually what `self(x)` eventually calls for combinatorial objects because coercion/conversion does not play any role. In this case, it is guaranteed to work by how the code is currently implemented (and the check above). Yet, in this case it is not necessarily so future-proof.


---

Comment by mantepse created at 2019-01-07 18:03:41

I am confused.  Could you please be a bit more explict?  In particular, should I revert the super modifications?  Should I write `x = Permutations()(x)` instead of `x = self(x)`?


---

Comment by tscrim created at 2019-01-07 18:20:24

Replying to [comment:11 mantepse]:
> I am confused.  Could you please be a bit more explict?

Suppose you have `A < B`, i.e., class `A` inherits from `B`. Then you change the MRO to be `A < C < B`, then the `super` would try to call the corresponding method in `C` instead of `B`.

>  In particular, should I revert the super modifications?

You have already done them, then it is fine. However, I am pointing out that it is not a good change to enforce.

>  Should I write `x = Permutations()(x)` instead of `x = self(x)`?

Yes.


---

Comment by git created at 2019-01-07 18:40:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-01-07 18:40:26

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2019-01-07 18:53:36

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2019-01-07 18:53:36

Thank you.


---

Comment by dkrenn created at 2019-01-08 09:21:52

Replying to [comment:10 tscrim]:
> `@`dkernn `super` is not (more) pythonic than directly calling the base class. You lose explicitness but gain by taking the direct superclass (so it reflects changes in the MRO if you insert a new class between itself and the base). I would avoid changing explicit base class calls to `super` unless there is a good reason to do so as it is a needless change.

But now it is again quite inconsistent as there is a couple of times `super` and a couple of times not.

> Also `self.element_class(self, x)` is usually what `self(x)` eventually calls for combinatorial objects because coercion/conversion does not play any role. In this case, it is guaranteed to work by how the code is currently implemented (and the check above). Yet, in this case it is not necessarily so future-proof.

True, but in this case, one cannot guarantee that `x` has already the correct parent, therefore `self(x)`.


---

Comment by tscrim created at 2019-01-08 17:31:19

Replying to [comment:16 dkrenn]:
> Replying to [comment:10 tscrim]:
> > `@`dkernn `super` is not (more) pythonic than directly calling the base class. You lose explicitness but gain by taking the direct superclass (so it reflects changes in the MRO if you insert a new class between itself and the base). I would avoid changing explicit base class calls to `super` unless there is a good reason to do so as it is a needless change.
> 
> But now it is again quite inconsistent as there is a couple of times `super` and a couple of times not.

You missed the point, the inconsistency does not matter. There are reasons to do have both. 99% of the time, the difference is irrelevant. Yet, you can use both in a file and it doesn't matter.

> > Also `self.element_class(self, x)` is usually what `self(x)` eventually calls for combinatorial objects because coercion/conversion does not play any role. In this case, it is guaranteed to work by how the code is currently implemented (and the check above). Yet, in this case it is not necessarily so future-proof.
> 
> True, but in this case, one cannot guarantee that `x` has already the correct parent, therefore `self(x)`.

The parent and type of `x` is irrelevant. The fact that it is valid input is what is important.


---

Comment by embray created at 2019-01-15 18:16:10

Retarging tickets optimistically to the next milestone.  If you are responsible for this ticket (either its reporter or owner) and don't believe you are likely to complete this ticket before the next release (8.7) please retarget this ticket's milestone to sage-pending or sage-wishlist.


---

Comment by vbraun created at 2019-01-23 14:17:57

Resolution: fixed
