# Issue 15111: "R.<a> =" syntactic sugar incorrect for EquationOrder and ZZ.extension

archive/issues_015111.json:
```json
{
    "body": "After typing\n\n```\nsage: f = x^2+1\nsage: R.<i> = ZZ.extension(f)\n```\n\nI expect variable `i` to be the element of `R` named `'i'`. However, it is not. It is the element 1.\n\nThis is due to the generators of an order in Sage being its //module// generators (as noted by `EquationOrder?`):\n\n```\nsage: R.gens()\n[1, i]\nsage: preparse(\"R.<i> = ZZ.extension(f)\")\n\"R = ZZ.extension(f, names=('i',)); (i,) = R._first_ngens(1)\"\n```\n\n\nI see three ways of fixing this:\n1) redefine `AbsoluteOrder.gens()`,\n2) make `preparse(...)` output `i = R._element_constructor('i')` instead of `(i,) = R._first_ngens(1)`,\n3) disallow `R.<i> = ` for `EquationOrder`.\n\nWay (1) might make previously good code produce wrong results, so it is not a good idea.\nFor way (2), `_element_constructor` should have uniquitious support, about which I am unsure. I think way (3) might be achieved by renaming the argument `names` of `EquationOrder` to `field_names` or somesuch. (For the short term I think `names` should still be accepted, but with a warning.)\n\nIssue created by migration from https://trac.sagemath.org/ticket/15348\n\n",
    "created_at": "2013-11-02T16:24:26Z",
    "labels": [
        "number fields",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.0",
    "title": "\"R.<a> =\" syntactic sugar incorrect for EquationOrder and ZZ.extension",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15111",
    "user": "emassop"
}
```
After typing

```
sage: f = x^2+1
sage: R.<i> = ZZ.extension(f)
```

I expect variable `i` to be the element of `R` named `'i'`. However, it is not. It is the element 1.

This is due to the generators of an order in Sage being its //module// generators (as noted by `EquationOrder?`):

```
sage: R.gens()
[1, i]
sage: preparse("R.<i> = ZZ.extension(f)")
"R = ZZ.extension(f, names=('i',)); (i,) = R._first_ngens(1)"
```


I see three ways of fixing this:
1) redefine `AbsoluteOrder.gens()`,
2) make `preparse(...)` output `i = R._element_constructor('i')` instead of `(i,) = R._first_ngens(1)`,
3) disallow `R.<i> = ` for `EquationOrder`.

Way (1) might make previously good code produce wrong results, so it is not a good idea.
For way (2), `_element_constructor` should have uniquitious support, about which I am unsure. I think way (3) might be achieved by renaming the argument `names` of `EquationOrder` to `field_names` or somesuch. (For the short term I think `names` should still be accepted, but with a warning.)

Issue created by migration from https://trac.sagemath.org/ticket/15348





---

archive/issue_comments_193711.json:
```json
{
    "body": "Is it really the syntactic sugar that poses problem? It seems that `inject_variables()` is the problem.\n\n\n```python\nsage: f = x^2+1\nsage: R = ZZ.extension(f,'i')\nsage: R.inject_variables()\nDefining i\nsage: i\n1\n```\n\n\nThe problem seems to come from the fact that `R.variable_names()` is `('i',)` while `R.gens()` is `[1,i]`, and a `zip` is called on these two objects, resulting in `[('i',1)]`.",
    "created_at": "2014-12-19T11:56:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193711",
    "user": "bruno"
}
```

Is it really the syntactic sugar that poses problem? It seems that `inject_variables()` is the problem.


```python
sage: f = x^2+1
sage: R = ZZ.extension(f,'i')
sage: R.inject_variables()
Defining i
sage: i
1
```


The problem seems to come from the fact that `R.variable_names()` is `('i',)` while `R.gens()` is `[1,i]`, and a `zip` is called on these two objects, resulting in `[('i',1)]`.



---

archive/issue_comments_193712.json:
```json
{
    "body": "I would prefer solution (1) which is most consistent with other uses of `gens()`.",
    "created_at": "2014-12-19T19:47:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193712",
    "user": "jdemeyer"
}
```

I would prefer solution (1) which is most consistent with other uses of `gens()`.



---

archive/issue_comments_193713.json:
```json
{
    "body": "Changing `gens()` would definitely also be my preferred solution. My concern is that there might be code that assumes that `gens()` returns a list of module generators, which would no longer be the case.",
    "created_at": "2014-12-19T21:35:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193713",
    "user": "emassop"
}
```

Changing `gens()` would definitely also be my preferred solution. My concern is that there might be code that assumes that `gens()` returns a list of module generators, which would no longer be the case.



---

archive/issue_comments_193714.json:
```json
{
    "body": "Replying to [comment:3 emassop]:\n> Changing `gens()` would definitely also be my preferred solution. My concern is that there might be code that assumes that `gens()` returns a list of module generators, which would no longer be the case.\n\nThat's not a major problem. For `R.<x> =` to work, it suffices to change the `_first_ngens()` method (without deprecation).\n\nWe could then add a boolean argument `ring` to `gens()`, defaulting to `False` (deprecated) which returns the *ring* generator (i.e. new-style `gens()`) if `ring=True`.",
    "created_at": "2014-12-19T22:13:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193714",
    "user": "jdemeyer"
}
```

Replying to [comment:3 emassop]:
> Changing `gens()` would definitely also be my preferred solution. My concern is that there might be code that assumes that `gens()` returns a list of module generators, which would no longer be the case.

That's not a major problem. For `R.<x> =` to work, it suffices to change the `_first_ngens()` method (without deprecation).

We could then add a boolean argument `ring` to `gens()`, defaulting to `False` (deprecated) which returns the *ring* generator (i.e. new-style `gens()`) if `ring=True`.



---

archive/issue_comments_193715.json:
```json
{
    "body": "I agree with Jeroen that you should do (1). If something is dependent on assuming they are module generators, then they can use something like `module_generators()` (perhaps this needs such an implementation). See also #15381.",
    "created_at": "2014-12-20T00:50:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193715",
    "user": "tscrim"
}
```

I agree with Jeroen that you should do (1). If something is dependent on assuming they are module generators, then they can use something like `module_generators()` (perhaps this needs such an implementation). See also #15381.



---

archive/issue_comments_193716.json:
```json
{
    "body": "Replying to [comment:5 tscrim]:\n> If something is dependent on assuming they are module generators, then they can use something like `module_generators()`\nNo need for a new method, there is already `basis()` which does exactly that (currently `gens()` simply calls `basis()`).",
    "created_at": "2014-12-20T08:50:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193716",
    "user": "jdemeyer"
}
```

Replying to [comment:5 tscrim]:
> If something is dependent on assuming they are module generators, then they can use something like `module_generators()`
No need for a new method, there is already `basis()` which does exactly that (currently `gens()` simply calls `basis()`).



---

archive/issue_comments_193717.json:
```json
{
    "body": "Just a comment:  not every order is monogenic, so it is not so clear what gens() should return in general if not module generators, though of course this particular construction will always produce a monogenic order.\n\nBack to the original task I was trying, it is a pity if there is not a simple one-liner to define a ring of the form Z[a] from a polynomial (min poly of a) and simultaneously assigne the value a to a variable called a.",
    "created_at": "2014-12-20T12:35:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193717",
    "user": "cremona"
}
```

Just a comment:  not every order is monogenic, so it is not so clear what gens() should return in general if not module generators, though of course this particular construction will always produce a monogenic order.

Back to the original task I was trying, it is a pity if there is not a simple one-liner to define a ring of the form Z[a] from a polynomial (min poly of a) and simultaneously assigne the value a to a variable called a.



---

archive/issue_comments_193718.json:
```json
{
    "body": "Replying to [comment:7 cremona]:\n> Just a comment:  not every order is monogenic, so it is not so clear what gens() should return in general\nI wouldn't mind `raise ArithmeticError`...",
    "created_at": "2014-12-20T12:40:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193718",
    "user": "jdemeyer"
}
```

Replying to [comment:7 cremona]:
> Just a comment:  not every order is monogenic, so it is not so clear what gens() should return in general
I wouldn't mind `raise ArithmeticError`...



---

archive/issue_comments_193719.json:
```json
{
    "body": "Changing priority from minor to major.",
    "created_at": "2016-01-01T23:06:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193719",
    "user": "jdemeyer"
}
```

Changing priority from minor to major.



---

archive/issue_comments_193720.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-01-02T09:53:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193720",
    "user": "jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_193721.json:
```json
{
    "body": "New commits:",
    "created_at": "2016-01-02T09:53:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193721",
    "user": "jdemeyer"
}
```

New commits:



---

archive/issue_comments_193722.json:
```json
{
    "body": "I don't really like unconditionally preferring `ring_generators()` in such a general place as `_first_n_gens()` is. Perhaps this should be something like `defining_generators()` instead of `ring_generators()`. This would be set when defining something by generators, and always refer to the generators from the definition. That said, s/ring/defining/ can be done later, so out of pragmatism I'm not against the current approach.\n\nHowever, the current approach with `ring_generators()` doesn't always work as expected, which could be considered be a separate bug (namely lack of prepopulating ring_generators if defining something by ring generators). For instance\n\n```\nK.<i> = NumberField(x^2+1)\nO = K.order(-i+1)\ngens = O.ring_generators()\nif gens == [-i+1]:\n  print \"O.<a> = K.order(-i+1) would work as expected\"\nelse:\n  print \"O.<a> = K.order(-i+1) would make a equal to %r, not as -i+1 as expected.\" % gens[0]\n```\n\nprints\n\n```\nO.<a> = K.order(-i+1) would make a equal to i, not as -i+1 as expected.\n```\n\non https://sagecell.sagemath.org/.\n\nWhat do you think? Which `?_gens` should generally be used and should populating `?_gens` with the defining generators be separate bugs?",
    "created_at": "2016-01-05T15:33:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193722",
    "user": "emassop"
}
```

I don't really like unconditionally preferring `ring_generators()` in such a general place as `_first_n_gens()` is. Perhaps this should be something like `defining_generators()` instead of `ring_generators()`. This would be set when defining something by generators, and always refer to the generators from the definition. That said, s/ring/defining/ can be done later, so out of pragmatism I'm not against the current approach.

However, the current approach with `ring_generators()` doesn't always work as expected, which could be considered be a separate bug (namely lack of prepopulating ring_generators if defining something by ring generators). For instance

```
K.<i> = NumberField(x^2+1)
O = K.order(-i+1)
gens = O.ring_generators()
if gens == [-i+1]:
  print "O.<a> = K.order(-i+1) would work as expected"
else:
  print "O.<a> = K.order(-i+1) would make a equal to %r, not as -i+1 as expected." % gens[0]
```

prints

```
O.<a> = K.order(-i+1) would make a equal to i, not as -i+1 as expected.
```

on https://sagecell.sagemath.org/.

What do you think? Which `?_gens` should generally be used and should populating `?_gens` with the defining generators be separate bugs?



---

archive/issue_comments_193723.json:
```json
{
    "body": "Replying to [comment:12 emassop]:\n> {{{\n> K.<i> = NumberField(x^2+1)\n> O = K.order(-i+1)\n> }}}\n\nThat's a bit harder to solve since there currently is no way to recover the `-i+1` used to create the order. We would need to change `def order(...)` to store the given generators.",
    "created_at": "2016-01-05T16:35:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193723",
    "user": "jdemeyer"
}
```

Replying to [comment:12 emassop]:
> {{{
> K.<i> = NumberField(x^2+1)
> O = K.order(-i+1)
> }}}

That's a bit harder to solve since there currently is no way to recover the `-i+1` used to create the order. We would need to change `def order(...)` to store the given generators.



---

archive/issue_comments_193724.json:
```json
{
    "body": "If you want this to work:\n\n```\nsage: K.<i> = NumberField(x^2+1)\nsage: O.<a> = K.order(-i+1)\nsage: a\n-i + 1\n```\n\nyou'll need to drop unique representation for orders: currently, the following two return the exact same object:\n\n```\nsage: O1 = K.order(-i+1)\nsage: O2 = K.order(-i)\nsage: O1 is O2\nTrue\n```\n\nYou cannot have `O1.defining_generators()` and `O2.defining_generators()` be different if `O1` is the same object as `O2`. So this cannot be fixed without making major changes.",
    "created_at": "2016-01-05T16:48:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193724",
    "user": "jdemeyer"
}
```

If you want this to work:

```
sage: K.<i> = NumberField(x^2+1)
sage: O.<a> = K.order(-i+1)
sage: a
-i + 1
```

you'll need to drop unique representation for orders: currently, the following two return the exact same object:

```
sage: O1 = K.order(-i+1)
sage: O2 = K.order(-i)
sage: O1 is O2
True
```

You cannot have `O1.defining_generators()` and `O2.defining_generators()` be different if `O1` is the same object as `O2`. So this cannot be fixed without making major changes.



---

archive/issue_comments_193725.json:
```json
{
    "body": "We don't have unique representation for fields:\n\n```\nsage: K1 = QQ[sqrt(2)]                                                                                \nsage: K2 = QQ[1+sqrt(2)] \nsage: K1\nNumber Field in sqrt2 with defining polynomial x^2 - 2\nsage: K2\nNumber Field in a with defining polynomial x^2 - 2*x - 1                                                                         \nsage: K1 is K2\nFalse\nsage: K1 == K2                                                                                        \nFalse\nsage: K1.is_isomorphic(K2)                                                                            \nTrue\n```\n\nin a rather similar context.",
    "created_at": "2016-01-05T16:59:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193725",
    "user": "cremona"
}
```

We don't have unique representation for fields:

```
sage: K1 = QQ[sqrt(2)]                                                                                
sage: K2 = QQ[1+sqrt(2)] 
sage: K1
Number Field in sqrt2 with defining polynomial x^2 - 2
sage: K2
Number Field in a with defining polynomial x^2 - 2*x - 1                                                                         
sage: K1 is K2
False
sage: K1 == K2                                                                                        
False
sage: K1.is_isomorphic(K2)                                                                            
True
```

in a rather similar context.



---

archive/issue_comments_193726.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-05T17:02:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193726",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_193727.json:
```json
{
    "body": "Replying to [comment:12 emassop]:\n> I don't really like unconditionally preferring `ring_generators()` in such a general place as `_first_n_gens()` is. Perhaps this should be something like `defining_generators()` instead of `ring_generators()`. This would be set when defining something by generators, and always refer to the generators from the definition.\n\nDone.",
    "created_at": "2016-01-05T17:02:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193727",
    "user": "jdemeyer"
}
```

Replying to [comment:12 emassop]:
> I don't really like unconditionally preferring `ring_generators()` in such a general place as `_first_n_gens()` is. Perhaps this should be something like `defining_generators()` instead of `ring_generators()`. This would be set when defining something by generators, and always refer to the generators from the definition.

Done.



---

archive/issue_comments_193728.json:
```json
{
    "body": "Replying to [comment:15 cremona]:\n> We don't have unique representation for fields:\n\nWell, it all boils down to the difference between \"equal\" and \"isomorphic\" which is really a difference in how we use mathematics and not in mathematics itself.\n\nIn your example with `K1` and `K2`, one could argue that those fields are not equal because there is no canonical (again, this is not a mathematically well-defined term) isomorphism.\n\nFor orders on the other hand, it makes a lot of sense to see orders as subsets of a number field. Then obviously two orders are equal if they are the same subset of the number field. That's the view that Sage uses. I admit that it's all quite subtle.\n\nRegardless, I don't think that this should hold back this ticket. I'm sure that many people have stumbled on the bug on this ticket, so let's just fix it. It also makes it possible to implement #7545. We can still look at further subtleties later.",
    "created_at": "2016-01-05T17:12:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193728",
    "user": "jdemeyer"
}
```

Replying to [comment:15 cremona]:
> We don't have unique representation for fields:

Well, it all boils down to the difference between "equal" and "isomorphic" which is really a difference in how we use mathematics and not in mathematics itself.

In your example with `K1` and `K2`, one could argue that those fields are not equal because there is no canonical (again, this is not a mathematically well-defined term) isomorphism.

For orders on the other hand, it makes a lot of sense to see orders as subsets of a number field. Then obviously two orders are equal if they are the same subset of the number field. That's the view that Sage uses. I admit that it's all quite subtle.

Regardless, I don't think that this should hold back this ticket. I'm sure that many people have stumbled on the bug on this ticket, so let's just fix it. It also makes it possible to implement #7545. We can still look at further subtleties later.



---

archive/issue_comments_193729.json:
```json
{
    "body": "My point about wanting `O.<foo> = K.order(-i+1)` to work is moot, because `.order` doesn't take a names argument, so that the syntactic sugar doesn't work in this case anyway.\n\nAs far as I can tell these patches indeed fix `R.<a> = EquationOrder(f)` and `R.<a> = ZZ.extension(f)`, where `f` is a polynomial. Also AFAICT, this is by virtue of `NumberField` using `1, a, a^2, ...` as basis, and other things normalizing to that basis.\n\nI tried for instance the following to make sure `ring_generators` could not be distracted:\n\n```\nfrom sage.rings.number_field.order import AbsoluteOrder\nK.<i> = NumberField(x^2+1)\nV, from_v, to_v = K.vector_space()\nO = AbsoluteOrder(K, span([to_v(1), to_v(-i)], ZZ))\nprint O.ring_generators() == [i]  # True, so the ring generator is i, not -i.\n```\n\n\nHowever, these patches do not fix the case of `R<several letters> = ...`. For instance\n\n```\nO.<a,b> = EquationOrder([x^2+1, x^2+2])\nprint O.ring_generators()\n```\n\nprints `[-b*a - 1, -3*a + 2*b]` which for this patch to work should be `[a,b]`. (Incidentally, that first and confusing line is used in the docstring of `EquationOrder`. Can you get rid of that, or comment on its unexpected consequences for variables `a` and `b`?)\n\nReplying to [comment:17 jdemeyer]:\n> Replying to [comment:12 emassop]:\n> > I don't really like unconditionally preferring `ring_generators()` in such a general place as `_first_n_gens()` is. Perhaps this should be something like `defining_generators()` instead of `ring_generators()`. This would be set when defining something by generators, and always refer to the generators from the definition.\n> \n> Done.\n\nChanging `defining_generators` is indeed dangerous. Perhaps there could be `defining_generators.set(...)` that would\n* populate the cache if it has no value,\n* do nothing if the cache and the argument agree,\n* populate the cache with an invalid value when the argument and the cache disagree.\nThe invalid value would make a call to `defining_generators` raise an exception. Also, how does the cache behaving with pickling? Does a cache override get saved?\n\nFinally, does it make sense to define `defining_generators` in `category_object.pyx` as simply `gens()`, and put the override to `ring_generators` in `class Order`?\n\nPain, pain, pain. I think it's okay to pragmatically go with this approach now.\n\nSome speculation, since my ideas keep changing about this: Perhaps the preparser should translate `a.<b> = c(d)` to `a,(b,) = c._call_and_also_return_names(d, names=('b',))`. Then `_call_and_also_return_names` gets responsible for calling `c` and making sure the returned generators are the right ones. When `c` is a function, this can be implemented using a decorator, or next to `c` itself. For classes `c`, `_call_and_also_return_names` can be a class method of `CategoryObject` which calls instantiates an object and calls `_first_n_gens` on it. This would also circumvent the hack of prepopulating and having to change the cache of `defining_generators`. Of course this seems like a bigger change than this bug, so let's do the pragmatic thing first.",
    "created_at": "2016-01-06T15:36:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193729",
    "user": "emassop"
}
```

My point about wanting `O.<foo> = K.order(-i+1)` to work is moot, because `.order` doesn't take a names argument, so that the syntactic sugar doesn't work in this case anyway.

As far as I can tell these patches indeed fix `R.<a> = EquationOrder(f)` and `R.<a> = ZZ.extension(f)`, where `f` is a polynomial. Also AFAICT, this is by virtue of `NumberField` using `1, a, a^2, ...` as basis, and other things normalizing to that basis.

I tried for instance the following to make sure `ring_generators` could not be distracted:

```
from sage.rings.number_field.order import AbsoluteOrder
K.<i> = NumberField(x^2+1)
V, from_v, to_v = K.vector_space()
O = AbsoluteOrder(K, span([to_v(1), to_v(-i)], ZZ))
print O.ring_generators() == [i]  # True, so the ring generator is i, not -i.
```


However, these patches do not fix the case of `R<several letters> = ...`. For instance

```
O.<a,b> = EquationOrder([x^2+1, x^2+2])
print O.ring_generators()
```

prints `[-b*a - 1, -3*a + 2*b]` which for this patch to work should be `[a,b]`. (Incidentally, that first and confusing line is used in the docstring of `EquationOrder`. Can you get rid of that, or comment on its unexpected consequences for variables `a` and `b`?)

Replying to [comment:17 jdemeyer]:
> Replying to [comment:12 emassop]:
> > I don't really like unconditionally preferring `ring_generators()` in such a general place as `_first_n_gens()` is. Perhaps this should be something like `defining_generators()` instead of `ring_generators()`. This would be set when defining something by generators, and always refer to the generators from the definition.
> 
> Done.

Changing `defining_generators` is indeed dangerous. Perhaps there could be `defining_generators.set(...)` that would
* populate the cache if it has no value,
* do nothing if the cache and the argument agree,
* populate the cache with an invalid value when the argument and the cache disagree.
The invalid value would make a call to `defining_generators` raise an exception. Also, how does the cache behaving with pickling? Does a cache override get saved?

Finally, does it make sense to define `defining_generators` in `category_object.pyx` as simply `gens()`, and put the override to `ring_generators` in `class Order`?

Pain, pain, pain. I think it's okay to pragmatically go with this approach now.

Some speculation, since my ideas keep changing about this: Perhaps the preparser should translate `a.<b> = c(d)` to `a,(b,) = c._call_and_also_return_names(d, names=('b',))`. Then `_call_and_also_return_names` gets responsible for calling `c` and making sure the returned generators are the right ones. When `c` is a function, this can be implemented using a decorator, or next to `c` itself. For classes `c`, `_call_and_also_return_names` can be a class method of `CategoryObject` which calls instantiates an object and calls `_first_n_gens` on it. This would also circumvent the hack of prepopulating and having to change the cache of `defining_generators`. Of course this seems like a bigger change than this bug, so let's do the pragmatic thing first.



---

archive/issue_comments_193730.json:
```json
{
    "body": "Replying to [comment:19 emassop]:\n> Perhaps there could be `defining_generators.set(...)` that would\n> * populate the cache if it has no value,\n> * do nothing if the cache and the argument agree,\n> * populate the cache with an invalid value when the argument and the cache disagree.\n> The invalid value would make a call to `defining_generators` raise an exception.\nI see no reason for this additional layer of complexity. I don't know of any cached function in Sage which does this and I don't see why `defining_generators` would need it.\n\n> Also, how does the cache behaving with pickling? Does a cache override get saved?\nYes, it gets pickled although this might be changed in #15692.\n\n> Finally, does it make sense to define `defining_generators` in `category_object.pyx` as simply `gens()`, and put the override to `ring_generators` in `class Order`?\nI don't really see why. Currently, `Order` is the only class with `ring_generators` but if a new class comes around implementing `ring_generators`, I guess (but this is really guessing) that it would make sense to use it as defining generators.",
    "created_at": "2016-01-06T15:59:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193730",
    "user": "jdemeyer"
}
```

Replying to [comment:19 emassop]:
> Perhaps there could be `defining_generators.set(...)` that would
> * populate the cache if it has no value,
> * do nothing if the cache and the argument agree,
> * populate the cache with an invalid value when the argument and the cache disagree.
> The invalid value would make a call to `defining_generators` raise an exception.
I see no reason for this additional layer of complexity. I don't know of any cached function in Sage which does this and I don't see why `defining_generators` would need it.

> Also, how does the cache behaving with pickling? Does a cache override get saved?
Yes, it gets pickled although this might be changed in #15692.

> Finally, does it make sense to define `defining_generators` in `category_object.pyx` as simply `gens()`, and put the override to `ring_generators` in `class Order`?
I don't really see why. Currently, `Order` is the only class with `ring_generators` but if a new class comes around implementing `ring_generators`, I guess (but this is really guessing) that it would make sense to use it as defining generators.



---

archive/issue_comments_193731.json:
```json
{
    "body": "Replying to [comment:19 emassop]:\n> Finally, does it make sense to define `defining_generators` in `category_object.pyx` as simply `gens()`, and put the override to `ring_generators` in `class Order`?\n\nThinking twice about it, maybe this approach could help solving the problem for relative `EquationOrder`s.",
    "created_at": "2016-01-06T16:04:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193731",
    "user": "jdemeyer"
}
```

Replying to [comment:19 emassop]:
> Finally, does it make sense to define `defining_generators` in `category_object.pyx` as simply `gens()`, and put the override to `ring_generators` in `class Order`?

Thinking twice about it, maybe this approach could help solving the problem for relative `EquationOrder`s.



---

archive/issue_comments_193732.json:
```json
{
    "body": "Replying to [comment:20 jdemeyer]:\n> Replying to [comment:19 emassop]:\n> > Perhaps there could be `defining_generators.set(...)` that would\n> > * populate the cache if it has no value,\n> > * do nothing if the cache and the argument agree,\n> > * populate the cache with an invalid value when the argument and the cache disagree.\n> > The invalid value would make a call to `defining_generators` raise an exception.\n> I see no reason for this additional layer of complexity. I don't know of any cached function in Sage which does this and I don't see why `defining_generators` would need it.\n\nIt seems weird if the return value of `.defining_generators` changes during an object's life. If the value gets set only once during an object's life-time (and survives pickling), then not having this additional complexity is okay. The proposal above is merely to enforce that the value does not get changed accidentally.\n\n> > Finally, does it make sense to define `defining_generators` in `category_object.pyx` as simply `gens()`, and put the override to `ring_generators` in `class Order`?\n> I don't really see why. Currently, `Order` is the only class with `ring_generators` but if a new class comes around implementing `ring_generators`, I guess (but this is really guessing) that it would make sense to use it as defining generators.\n\nSo all other rings with generators use `gens()` for their ring generators? Why is `Order` different, especially given that there also is `basis()`?\n\nFor instance\n\n```\nR.<i> = ZZ.extension(x^2+1)\nS.<x> = QQ[]\n\nA.<a> = QQ.extension(x^2-3)\nB.<b> = ZZ.extension(x^2-3)\nC.<c> = R.extension(x^2-3)\nD.<d> = S.extension(x^2-3)\n\nprint A.gens(), B.gens(), C.gens(), D.gens()\n```\n\nprints `(a,) [1, b] (c,) (d,)` with B.gens() being the odd one out.",
    "created_at": "2016-01-06T17:10:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193732",
    "user": "emassop"
}
```

Replying to [comment:20 jdemeyer]:
> Replying to [comment:19 emassop]:
> > Perhaps there could be `defining_generators.set(...)` that would
> > * populate the cache if it has no value,
> > * do nothing if the cache and the argument agree,
> > * populate the cache with an invalid value when the argument and the cache disagree.
> > The invalid value would make a call to `defining_generators` raise an exception.
> I see no reason for this additional layer of complexity. I don't know of any cached function in Sage which does this and I don't see why `defining_generators` would need it.

It seems weird if the return value of `.defining_generators` changes during an object's life. If the value gets set only once during an object's life-time (and survives pickling), then not having this additional complexity is okay. The proposal above is merely to enforce that the value does not get changed accidentally.

> > Finally, does it make sense to define `defining_generators` in `category_object.pyx` as simply `gens()`, and put the override to `ring_generators` in `class Order`?
> I don't really see why. Currently, `Order` is the only class with `ring_generators` but if a new class comes around implementing `ring_generators`, I guess (but this is really guessing) that it would make sense to use it as defining generators.

So all other rings with generators use `gens()` for their ring generators? Why is `Order` different, especially given that there also is `basis()`?

For instance

```
R.<i> = ZZ.extension(x^2+1)
S.<x> = QQ[]

A.<a> = QQ.extension(x^2-3)
B.<b> = ZZ.extension(x^2-3)
C.<c> = R.extension(x^2-3)
D.<d> = S.extension(x^2-3)

print A.gens(), B.gens(), C.gens(), D.gens()
```

prints `(a,) [1, b] (c,) (d,)` with B.gens() being the odd one out.



---

archive/issue_comments_193733.json:
```json
{
    "body": "Replying to [comment:22 emassop]:\n> It seems weird if the return value of `.defining_generators` changes during an object's life. If the value gets set only once during an object's life-time (and survives pickling), then not having this additional complexity is okay. The proposal above is merely to enforce that the value does not get changed accidentally.\nI don't see how the value could get changed accidentally. And like I said: there are many cached functions in Sage, what makes this one so special?\n\n> So all other rings with generators use `gens()` for their ring generators? Why is `Order` different, especially given that there also is `basis()`?\nVery good question. Unfortunately, because of the deprecation policy, we cannot just change `gens()`.",
    "created_at": "2016-01-06T17:50:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193733",
    "user": "jdemeyer"
}
```

Replying to [comment:22 emassop]:
> It seems weird if the return value of `.defining_generators` changes during an object's life. If the value gets set only once during an object's life-time (and survives pickling), then not having this additional complexity is okay. The proposal above is merely to enforce that the value does not get changed accidentally.
I don't see how the value could get changed accidentally. And like I said: there are many cached functions in Sage, what makes this one so special?

> So all other rings with generators use `gens()` for their ring generators? Why is `Order` different, especially given that there also is `basis()`?
Very good question. Unfortunately, because of the deprecation policy, we cannot just change `gens()`.



---

archive/issue_comments_193734.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-06T22:16:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193734",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_193735.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-06T22:18:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193735",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_193736.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-07T08:28:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193736",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_193737.json:
```json
{
    "body": "Replying to [comment:23 jdemeyer]:\n> Replying to [comment:22 emassop]:\n> > It seems weird if the return value of `.defining_generators` changes during an object's life. If the value gets set only once during an object's life-time (and survives pickling), then not having this additional complexity is okay. The proposal above is merely to enforce that the value does not get changed accidentally.\n> I don't see how the value could get changed accidentally. And like I said: there are many cached functions in Sage, what makes this one so special?\n\nThe docstring says \"This is cached, so we can manually set the result if required\". As such, it seems intended for the cache to contain a value that would not be the result of executing the function. (Otherwise you would not need to set it manually.) This is against the idea of a cache as an optimization that speeds up a function call by remembering the previous result.\n\n\nDoes the [docstring change](http://git.sagemath.org/sage.git/commit/?id=af007674767ddfd652c10fb2bd79799377dc9ffb) of `RelativeOrder.basis` affect the community's ability to change this function's behavior? It previously seemed to me that it could start returning a basis relative to the base order at any time.\n\nWhy is it okay to change `gens_dict`, but not `gens` itself?\n\nHack: What about reordering the result of `gens()` (or probably `basis`?) such that desired generators form a prefix? Then the syntactic sugar would work because it uses only the first `n` items.",
    "created_at": "2016-01-07T10:47:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193737",
    "user": "emassop"
}
```

Replying to [comment:23 jdemeyer]:
> Replying to [comment:22 emassop]:
> > It seems weird if the return value of `.defining_generators` changes during an object's life. If the value gets set only once during an object's life-time (and survives pickling), then not having this additional complexity is okay. The proposal above is merely to enforce that the value does not get changed accidentally.
> I don't see how the value could get changed accidentally. And like I said: there are many cached functions in Sage, what makes this one so special?

The docstring says "This is cached, so we can manually set the result if required". As such, it seems intended for the cache to contain a value that would not be the result of executing the function. (Otherwise you would not need to set it manually.) This is against the idea of a cache as an optimization that speeds up a function call by remembering the previous result.


Does the [docstring change](http://git.sagemath.org/sage.git/commit/?id=af007674767ddfd652c10fb2bd79799377dc9ffb) of `RelativeOrder.basis` affect the community's ability to change this function's behavior? It previously seemed to me that it could start returning a basis relative to the base order at any time.

Why is it okay to change `gens_dict`, but not `gens` itself?

Hack: What about reordering the result of `gens()` (or probably `basis`?) such that desired generators form a prefix? Then the syntactic sugar would work because it uses only the first `n` items.



---

archive/issue_comments_193738.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-07T10:56:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193738",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_193739.json:
```json
{
    "body": "Replying to [comment:28 emassop]:\n> The docstring says \"This is cached, so we can manually set the result if required\".\nFixed.\n\n> Does the [docstring change](http://git.sagemath.org/sage.git/commit/?id=af007674767ddfd652c10fb2bd79799377dc9ffb) of `RelativeOrder.basis` affect the community's ability to change this function's behavior?\n\nI don't think so. I simply changed the docstring to the reality.\n\n> Why is it okay to change `gens_dict`, but not `gens` itself?\nBecause of the way how `gens_dict()` is used: `gens_dict` is supposed to return a dict of generators with their name as key. For example, it is often used to name variables for an `eval()` statement. So philosophically this is closer to `_defining_generators()` than to `gens()`.\n\n> Hack: What about reordering the result of `gens()` (or probably `basis`?) such that desired generators form a prefix?\nI would guess that would break stuff. I wouldn't be surprised if there was code assuming that `1` is the first element of `basis()`.",
    "created_at": "2016-01-07T11:01:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193739",
    "user": "jdemeyer"
}
```

Replying to [comment:28 emassop]:
> The docstring says "This is cached, so we can manually set the result if required".
Fixed.

> Does the [docstring change](http://git.sagemath.org/sage.git/commit/?id=af007674767ddfd652c10fb2bd79799377dc9ffb) of `RelativeOrder.basis` affect the community's ability to change this function's behavior?

I don't think so. I simply changed the docstring to the reality.

> Why is it okay to change `gens_dict`, but not `gens` itself?
Because of the way how `gens_dict()` is used: `gens_dict` is supposed to return a dict of generators with their name as key. For example, it is often used to name variables for an `eval()` statement. So philosophically this is closer to `_defining_generators()` than to `gens()`.

> Hack: What about reordering the result of `gens()` (or probably `basis`?) such that desired generators form a prefix?
I would guess that would break stuff. I wouldn't be surprised if there was code assuming that `1` is the first element of `basis()`.



---

archive/issue_comments_193740.json:
```json
{
    "body": "Replying to [comment:30 jdemeyer]:\n> Replying to [comment:28 emassop]:\n> > The docstring says \"This is cached, so we can manually set the result if required\".\n> Fixed.\n\nYeah, this works :).\n\n> > Why is it okay to change `gens_dict`, but not `gens` itself?\n> Because of the way how `gens_dict()` is used: `gens_dict` is supposed to return a dict of generators with their name as key. For example, it is often used to name variables for an `eval()` statement. So philosophically this is closer to `_defining_generators()` than to `gens()`.\n\nReading `gens_dict` as a dict version of `gens`, I would expect the same values to be present in `gens_dict` as in `gens`. However, with `gens` deprecated, maybe this is okay.\n\n> > Hack: What about reordering the result of `gens()` (or probably `basis`?) such that desired generators form a prefix?\n> I would guess that would break stuff. I wouldn't be surprised if there was code assuming that `1` is the first element of `basis()`.\n\nYeah, that seems likely :(. We can use such a trick to fix `R.<several letters> =` though, by  prepending `[x for x in self.number_field().gens() if x in self]` to `remaining` in `.ring_generators`. I don't like it very much, but I think it could work.",
    "created_at": "2016-01-07T11:22:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193740",
    "user": "emassop"
}
```

Replying to [comment:30 jdemeyer]:
> Replying to [comment:28 emassop]:
> > The docstring says "This is cached, so we can manually set the result if required".
> Fixed.

Yeah, this works :).

> > Why is it okay to change `gens_dict`, but not `gens` itself?
> Because of the way how `gens_dict()` is used: `gens_dict` is supposed to return a dict of generators with their name as key. For example, it is often used to name variables for an `eval()` statement. So philosophically this is closer to `_defining_generators()` than to `gens()`.

Reading `gens_dict` as a dict version of `gens`, I would expect the same values to be present in `gens_dict` as in `gens`. However, with `gens` deprecated, maybe this is okay.

> > Hack: What about reordering the result of `gens()` (or probably `basis`?) such that desired generators form a prefix?
> I would guess that would break stuff. I wouldn't be surprised if there was code assuming that `1` is the first element of `basis()`.

Yeah, that seems likely :(. We can use such a trick to fix `R.<several letters> =` though, by  prepending `[x for x in self.number_field().gens() if x in self]` to `remaining` in `.ring_generators`. I don't like it very much, but I think it could work.



---

archive/issue_comments_193741.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-07T11:41:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193741",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_193742.json:
```json
{
    "body": "I now changed `_defining_generators()` to use the number field gens instead. This fixes the case of relative extensions.",
    "created_at": "2016-01-07T11:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193742",
    "user": "jdemeyer"
}
```

I now changed `_defining_generators()` to use the number field gens instead. This fixes the case of relative extensions.



---

archive/issue_comments_193743.json:
```json
{
    "body": "Replying to [comment:33 jdemeyer]:\n> I now changed `_defining_generators()` to use the number field gens instead. This fixes the case of relative extensions.\n\nDisregarding the change to `gen_dict()`, this makes sense to me. I would on first sight argue that `defining_generators` should not be defined for an order that has not been defined by generators, but since this is a private method used only by `R.<...>` (disregarding `gen_dict`), which moreover throws an exception if the elements are not in the order, I think it's fine here.\n\nTaking `gen_dict()` back into the picture, I'm not so happy with its elements not necessarily generating the order anymore (as a module, or as a ring), as there is nothing in the name `gen_dict` that suggests this would not be the case. For instance\n\n```\nK.<a> = QuadraticField(-163)\nR = K.ring_of_integers()\ndict_gens_values = [R(x) for x in K.gens()]\nS = K.order(dict_gens_values)\nprint S.index_in(R)\n```\n\nprints 2 instead of the expected 1.\n\nTangentially, `NumberField.ring_of_integers` should pass its arguments to `self.maximal_order`, in the same way that `NumberField.OK` does. (For the deprecation policy, this is probably not currently feasible, but we can deprecate non-empty arguments.) As a side-effect, this prohibits the syntax `R.<w> = K.ring_of_integers()`, in the same that `R.<w> = K.order(...)` is prohibited (which made one of my earlier points moot). This also makes the following impossible, where `w` does not become the expected generator:\n\n```\nK.<a> = QuadraticField(-163)\nR.<w> = K.ring_of_integers()\nw = a # Since I'm not running the version with the patch.\nprint K.order(w).index_in(R)  # R.<w> suggests this prints 1, but it actually prints 2.\n```\n",
    "created_at": "2016-01-07T13:50:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193743",
    "user": "emassop"
}
```

Replying to [comment:33 jdemeyer]:
> I now changed `_defining_generators()` to use the number field gens instead. This fixes the case of relative extensions.

Disregarding the change to `gen_dict()`, this makes sense to me. I would on first sight argue that `defining_generators` should not be defined for an order that has not been defined by generators, but since this is a private method used only by `R.<...>` (disregarding `gen_dict`), which moreover throws an exception if the elements are not in the order, I think it's fine here.

Taking `gen_dict()` back into the picture, I'm not so happy with its elements not necessarily generating the order anymore (as a module, or as a ring), as there is nothing in the name `gen_dict` that suggests this would not be the case. For instance

```
K.<a> = QuadraticField(-163)
R = K.ring_of_integers()
dict_gens_values = [R(x) for x in K.gens()]
S = K.order(dict_gens_values)
print S.index_in(R)
```

prints 2 instead of the expected 1.

Tangentially, `NumberField.ring_of_integers` should pass its arguments to `self.maximal_order`, in the same way that `NumberField.OK` does. (For the deprecation policy, this is probably not currently feasible, but we can deprecate non-empty arguments.) As a side-effect, this prohibits the syntax `R.<w> = K.ring_of_integers()`, in the same that `R.<w> = K.order(...)` is prohibited (which made one of my earlier points moot). This also makes the following impossible, where `w` does not become the expected generator:

```
K.<a> = QuadraticField(-163)
R.<w> = K.ring_of_integers()
w = a # Since I'm not running the version with the patch.
print K.order(w).index_in(R)  # R.<w> suggests this prints 1, but it actually prints 2.
```




---

archive/issue_comments_193744.json:
```json
{
    "body": "Replying to [comment:34 emassop]:\n> {{{\n> K.<a> = QuadraticField(-163)\n> R.<w> = K.ring_of_integers()\n> w = a # Since I'm not running the version with the patch.\n> print K.order(w).index_in(R)  # R.<w> suggests this prints 1, but it actually prints 2.\n> }}}\n\nI don't see why `R.<w>` *suggests* that `K.order(w) == K.ring_of_integers()`. I *do* agree that `ring_of_integers`, `OK` and `maximal_order` should all behave exactly the same.",
    "created_at": "2016-01-07T14:02:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193744",
    "user": "jdemeyer"
}
```

Replying to [comment:34 emassop]:
> {{{
> K.<a> = QuadraticField(-163)
> R.<w> = K.ring_of_integers()
> w = a # Since I'm not running the version with the patch.
> print K.order(w).index_in(R)  # R.<w> suggests this prints 1, but it actually prints 2.
> }}}

I don't see why `R.<w>` *suggests* that `K.order(w) == K.ring_of_integers()`. I *do* agree that `ring_of_integers`, `OK` and `maximal_order` should all behave exactly the same.



---

archive/issue_comments_193745.json:
```json
{
    "body": "Replying to [comment:34 emassop]:\n> Taking `gen_dict()` back into the picture, I'm not so happy with its elements not necessarily generating the order anymore (as a module, or as a ring), as there is nothing in the name `gen_dict` that suggests this would not be the case.\n\nWell, `gens_dict()` is used to extract all \"variable names\" (that is what the docstring says and that is how it is used in practice). Perhaps the name `gens_dict()` is badly chosen, but I would not change that now. Maybe a better name would have been `variables_dict()` or `named_elements()` or something.\n\nIf you see it this way, using `_defining_generators()` is a better choice than `gens()`.",
    "created_at": "2016-01-07T14:07:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193745",
    "user": "jdemeyer"
}
```

Replying to [comment:34 emassop]:
> Taking `gen_dict()` back into the picture, I'm not so happy with its elements not necessarily generating the order anymore (as a module, or as a ring), as there is nothing in the name `gen_dict` that suggests this would not be the case.

Well, `gens_dict()` is used to extract all "variable names" (that is what the docstring says and that is how it is used in practice). Perhaps the name `gens_dict()` is badly chosen, but I would not change that now. Maybe a better name would have been `variables_dict()` or `named_elements()` or something.

If you see it this way, using `_defining_generators()` is a better choice than `gens()`.



---

archive/issue_comments_193746.json:
```json
{
    "body": "Replying to [comment:35 jdemeyer]:\n> Replying to [comment:34 emassop]:\n> > {{{\n> > K.<a> = QuadraticField(-163)\n> > R.<w> = K.ring_of_integers()\n> > w = a # Since I'm not running the version with the patch.\n> > print K.order(w).index_in(R)  # R.<w> suggests this prints 1, but it actually prints 2.\n> > }}}\n> \n> I don't see why `R.<w>` *suggests* that `K.order(w) == K.ring_of_integers()`. I *do* agree that `ring_of_integers`, `OK` and `maximal_order` should all behave exactly the same.\n\nWhat do you expect `w` to become in `R.<w> =`, if not a generator of `R`?",
    "created_at": "2016-01-07T14:31:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193746",
    "user": "emassop"
}
```

Replying to [comment:35 jdemeyer]:
> Replying to [comment:34 emassop]:
> > {{{
> > K.<a> = QuadraticField(-163)
> > R.<w> = K.ring_of_integers()
> > w = a # Since I'm not running the version with the patch.
> > print K.order(w).index_in(R)  # R.<w> suggests this prints 1, but it actually prints 2.
> > }}}
> 
> I don't see why `R.<w>` *suggests* that `K.order(w) == K.ring_of_integers()`. I *do* agree that `ring_of_integers`, `OK` and `maximal_order` should all behave exactly the same.

What do you expect `w` to become in `R.<w> =`, if not a generator of `R`?



---

archive/issue_comments_193747.json:
```json
{
    "body": "Replying to [comment:36 jdemeyer]:\n> Replying to [comment:34 emassop]:\n> > Taking `gen_dict()` back into the picture, I'm not so happy with its elements not necessarily generating the order anymore (as a module, or as a ring), as there is nothing in the name `gen_dict` that suggests this would not be the case.\n> \n> Well, `gens_dict()` is used to extract all \"variable names\" (that is what the docstring says and that is how it is used in practice). Perhaps the name `gens_dict()` is badly chosen, but I would not change that now. Maybe a better name would have been `variables_dict()` or `named_elements()` or something.\n> \n> If you see it this way, using `_defining_generators()` is a better choice than `gens()`.\n\nOkay, that makes sense. Perhaps `_defining_generators` should be renamed too then? Perhaps `_definition_names` or some such? (I like 'names' because it corresponds to the argument `names` that is passed to `f` when doing `a.<x> = f(...)`.)",
    "created_at": "2016-01-07T14:35:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193747",
    "user": "emassop"
}
```

Replying to [comment:36 jdemeyer]:
> Replying to [comment:34 emassop]:
> > Taking `gen_dict()` back into the picture, I'm not so happy with its elements not necessarily generating the order anymore (as a module, or as a ring), as there is nothing in the name `gen_dict` that suggests this would not be the case.
> 
> Well, `gens_dict()` is used to extract all "variable names" (that is what the docstring says and that is how it is used in practice). Perhaps the name `gens_dict()` is badly chosen, but I would not change that now. Maybe a better name would have been `variables_dict()` or `named_elements()` or something.
> 
> If you see it this way, using `_defining_generators()` is a better choice than `gens()`.

Okay, that makes sense. Perhaps `_defining_generators` should be renamed too then? Perhaps `_definition_names` or some such? (I like 'names' because it corresponds to the argument `names` that is passed to `f` when doing `a.<x> = f(...)`.)



---

archive/issue_comments_193748.json:
```json
{
    "body": "Replying to [comment:37 emassop]:\n> What do you expect `w` to become in `R.<w> =`, if not a generator of `R`?\n\nThe element named \"w\".",
    "created_at": "2016-01-07T14:47:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193748",
    "user": "jdemeyer"
}
```

Replying to [comment:37 emassop]:
> What do you expect `w` to become in `R.<w> =`, if not a generator of `R`?

The element named "w".



---

archive/issue_comments_193749.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-07T14:52:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193749",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_193750.json:
```json
{
    "body": "Replying to [comment:39 jdemeyer]:\n> Replying to [comment:37 emassop]:\n> > What do you expect `w` to become in `R.<w> =`, if not a generator of `R`?\n> \n> The element named \"w\".\n\nSure, but which element would be named \"w\"? Anyway, this is moot now :).",
    "created_at": "2016-01-07T15:00:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193750",
    "user": "emassop"
}
```

Replying to [comment:39 jdemeyer]:
> Replying to [comment:37 emassop]:
> > What do you expect `w` to become in `R.<w> =`, if not a generator of `R`?
> 
> The element named "w".

Sure, but which element would be named "w"? Anyway, this is moot now :).



---

archive/issue_comments_193751.json:
```json
{
    "body": "Some comments on the docstring of `_defining_names`:\n\n* There is a test for orders, which have this method overridden, so I think it would be better to move this test.\n* I'm not sure about the example \"For vector spaces and free modules, we get a basis\", given that submodules normalize the basis they are given as input, so that `_defining_names` does not necessarily return the basis that the submodule was defined with. For instance\n  {{{\nV = ZZ^3\nvectors = [(0,1,0), (1,3/2,0)]\nM = V.span(vectors)\nprint M.basis()\n  }}}\n  prints\n  {{{\n[\n(1, 1/2, 0),\n(0, 1, 0)\n]\n  }}}\n  Could you mention something like this as a caveat for this method? Or perhaps get rid of this example, given that this method really only is interesting for things defined by some explicitly named elements?\n* Please get rid of \"generator\" and perhaps mention the `names` argument used by `R.<...> =`\n\n\nOtherwise, this all looks good to me.",
    "created_at": "2016-01-07T17:15:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193751",
    "user": "emassop"
}
```

Some comments on the docstring of `_defining_names`:

* There is a test for orders, which have this method overridden, so I think it would be better to move this test.
* I'm not sure about the example "For vector spaces and free modules, we get a basis", given that submodules normalize the basis they are given as input, so that `_defining_names` does not necessarily return the basis that the submodule was defined with. For instance
  {{{
V = ZZ^3
vectors = [(0,1,0), (1,3/2,0)]
M = V.span(vectors)
print M.basis()
  }}}
  prints
  {{{
[
(1, 1/2, 0),
(0, 1, 0)
]
  }}}
  Could you mention something like this as a caveat for this method? Or perhaps get rid of this example, given that this method really only is interesting for things defined by some explicitly named elements?
* Please get rid of "generator" and perhaps mention the `names` argument used by `R.<...> =`


Otherwise, this all looks good to me.



---

archive/issue_comments_193752.json:
```json
{
    "body": "Replying to [comment:42 emassop]:\n> Some comments on the docstring of `_defining_names`:\n> \n> * There is a test for orders, which have this method overridden, so I think it would be better to move this test.\n\nThere are already two tests for orders in `order.py`, so I don't think we need to add an additional test. I think the test in `category_object.pyx` is useful to refer to this ticket and the general discussion of `_defining_names()`.",
    "created_at": "2016-01-10T19:49:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193752",
    "user": "jdemeyer"
}
```

Replying to [comment:42 emassop]:
> Some comments on the docstring of `_defining_names`:
> 
> * There is a test for orders, which have this method overridden, so I think it would be better to move this test.

There are already two tests for orders in `order.py`, so I don't think we need to add an additional test. I think the test in `category_object.pyx` is useful to refer to this ticket and the general discussion of `_defining_names()`.



---

archive/issue_comments_193753.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-10T19:59:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193753",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_193754.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-01-11T21:30:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193754",
    "user": "emassop"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_193755.json:
```json
{
    "body": "Thanks for the review!\n\nRemember to fill in your name as Reviewer.",
    "created_at": "2016-01-11T22:31:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193755",
    "user": "jdemeyer"
}
```

Thanks for the review!

Remember to fill in your name as Reviewer.



---

archive/issue_comments_193756.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2016-01-12T17:18:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193756",
    "user": "vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_193757.json:
```json
{
    "body": "Reviewer name",
    "created_at": "2016-01-12T17:18:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193757",
    "user": "vbraun"
}
```

Reviewer name



---

archive/issue_comments_193758.json:
```json
{
    "body": "Putting my name in Reviewers this time. Why can't Trac fill that in?",
    "created_at": "2016-01-13T01:07:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193758",
    "user": "emassop"
}
```

Putting my name in Reviewers this time. Why can't Trac fill that in?



---

archive/issue_comments_193759.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2016-01-13T01:07:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193759",
    "user": "emassop"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_193760.json:
```json
{
    "body": "Volker, it would make a lot of sense to merge this in Sage 7.0, is that still possible?",
    "created_at": "2016-01-13T08:50:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193760",
    "user": "jdemeyer"
}
```

Volker, it would make a lot of sense to merge this in Sage 7.0, is that still possible?



---

archive/issue_comments_193761.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-01-13T21:09:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15111",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15111#issuecomment-193761",
    "user": "vbraun"
}
```

Resolution: fixed
