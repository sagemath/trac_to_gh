# Issue 33023: .perfect_matchings() does not respect partite sets of a given bipartite graph

archive/issues_033023.json:
```json
{
    "body": "The order of edge endpoints in perfect matchings returned by `.perfect_matchings()` does not always consistent with the partite sets of a given bipartite graph:\n\n```\nB = BipartiteGraph( [(0, 5), (0, 7), (1, 4), (1, 6), (1, 7), (2, 4), (2, 5), (2, 8), (3, 4), (3, 5), (3, 6), (6, 9), (8, 9)] )\nprint('Partite sets:',B.left, B.right)\nfor p in B.perfect_matchings(labels=False):\n    if not all(q[0] in B.left for q in p):\n         print('Disrespectful matching:', p)\n```\n\nIssue created by migration from https://trac.sagemath.org/ticket/33260\n\n",
    "created_at": "2022-01-31T14:44:32Z",
    "labels": [
        "component: graph theory",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.6",
    "title": ".perfect_matchings() does not respect partite sets of a given bipartite graph",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/33023",
    "user": "https://github.com/maxale"
}
```
The order of edge endpoints in perfect matchings returned by `.perfect_matchings()` does not always consistent with the partite sets of a given bipartite graph:

```
B = BipartiteGraph( [(0, 5), (0, 7), (1, 4), (1, 6), (1, 7), (2, 4), (2, 5), (2, 8), (3, 4), (3, 5), (3, 6), (6, 9), (8, 9)] )
print('Partite sets:',B.left, B.right)
for p in B.perfect_matchings(labels=False):
    if not all(q[0] in B.left for q in p):
         print('Disrespectful matching:', p)
```

Issue created by migration from https://trac.sagemath.org/ticket/33260





---

archive/issue_comments_470284.json:
```json
{
    "body": "Actually, the `perfect_matchings` method is not working for bipartite graphs. With sage 9.5, I get\n\n```\nsage: B = BipartiteGraph( [(0, 5), (0, 7), (1, 4), (1, 6), (1, 7), (2, 4), (2, 5), (2, 8), (3, 4), (3, 5), (3, 6), (6, 9), (8, 9)] )\n....: print('Partite sets:',B.left, B.right)\n....: for p in B.perfect_matchings(labels=False):\n....:     if not all(q[0] in B.left for q in p):\n....:          print('Disrespectful matching:', p)\n....: \nPartite sets: {0, 1, 2, 3, 9} {4, 5, 6, 7, 8}\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\n<ipython-input-32-476f8468fd7b> in <module>\n      1 B = BipartiteGraph( [(Integer(0), Integer(5)), (Integer(0), Integer(7)), (Integer(1), Integer(4)), (Integer(1), Integer(6)), (Integer(1), Integer(7)), (Integer(2), Integer(4)), (Integer(2), Integer(5)), (Integer(2), Integer(8)), (Integer(3), Integer(4)), (Integer(3), Integer(5)), (Integer(3), Integer(6)), (Integer(6), Integer(9)), (Integer(8), Integer(9))] )\n      2 print('Partite sets:',B.left, B.right)\n----> 3 for p in B.perfect_matchings(labels=False):\n      4     if not all(q[Integer(0)] in B.left for q in p):\n      5          print('Disrespectful matching:', p)\n\n~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in perfect_matchings(self, labels)\n   8413 \n   8414         # For each unlabeled matching, we yield all its possible labelings\n-> 8415         for m in rec(G):\n   8416             for pm in itertools.product(*[edges[frozenset(e)] for e in m]):\n   8417                 yield pm\n\n~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)\n   8387                     Nu = list(G.neighbor_iterator(u))\n   8388                     G.delete_vertex(u)\n-> 8389                     for partial_matching in rec(G):\n   8390                         partial_matching.append((u, v))\n   8391                         yield partial_matching\n\n~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)\n   8387                     Nu = list(G.neighbor_iterator(u))\n   8388                     G.delete_vertex(u)\n-> 8389                     for partial_matching in rec(G):\n   8390                         partial_matching.append((u, v))\n   8391                         yield partial_matching\n\n~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)\n   8387                     Nu = list(G.neighbor_iterator(u))\n   8388                     G.delete_vertex(u)\n-> 8389                     for partial_matching in rec(G):\n   8390                         partial_matching.append((u, v))\n   8391                         yield partial_matching\n\n~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)\n   8387                     Nu = list(G.neighbor_iterator(u))\n   8388                     G.delete_vertex(u)\n-> 8389                     for partial_matching in rec(G):\n   8390                         partial_matching.append((u, v))\n   8391                         yield partial_matching\n\n~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)\n   8392                     G.add_vertex(u)\n   8393                     G.add_edges((u, nu) for nu in Nu)\n-> 8394                 G.add_vertex(v)\n   8395                 G.add_edges((v, nv) for nv in Nv)\n   8396 \n\n~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/bipartite_graph.py in add_vertex(self, name, left, right)\n    558             raise RuntimeError(\"only one partition may be specified\")\n    559         if not (left or right):\n--> 560             raise RuntimeError(\"partition must be specified (e.g. left=True)\")\n    561 \n    562         # do nothing if we already have this vertex (idempotent)\n\nRuntimeError: partition must be specified (e.g. left=True)\n```",
    "created_at": "2022-01-31T17:53:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470284",
    "user": "https://github.com/dcoudert"
}
```

Actually, the `perfect_matchings` method is not working for bipartite graphs. With sage 9.5, I get

```
sage: B = BipartiteGraph( [(0, 5), (0, 7), (1, 4), (1, 6), (1, 7), (2, 4), (2, 5), (2, 8), (3, 4), (3, 5), (3, 6), (6, 9), (8, 9)] )
....: print('Partite sets:',B.left, B.right)
....: for p in B.perfect_matchings(labels=False):
....:     if not all(q[0] in B.left for q in p):
....:          print('Disrespectful matching:', p)
....: 
Partite sets: {0, 1, 2, 3, 9} {4, 5, 6, 7, 8}
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
<ipython-input-32-476f8468fd7b> in <module>
      1 B = BipartiteGraph( [(Integer(0), Integer(5)), (Integer(0), Integer(7)), (Integer(1), Integer(4)), (Integer(1), Integer(6)), (Integer(1), Integer(7)), (Integer(2), Integer(4)), (Integer(2), Integer(5)), (Integer(2), Integer(8)), (Integer(3), Integer(4)), (Integer(3), Integer(5)), (Integer(3), Integer(6)), (Integer(6), Integer(9)), (Integer(8), Integer(9))] )
      2 print('Partite sets:',B.left, B.right)
----> 3 for p in B.perfect_matchings(labels=False):
      4     if not all(q[Integer(0)] in B.left for q in p):
      5          print('Disrespectful matching:', p)

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in perfect_matchings(self, labels)
   8413 
   8414         # For each unlabeled matching, we yield all its possible labelings
-> 8415         for m in rec(G):
   8416             for pm in itertools.product(*[edges[frozenset(e)] for e in m]):
   8417                 yield pm

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8387                     Nu = list(G.neighbor_iterator(u))
   8388                     G.delete_vertex(u)
-> 8389                     for partial_matching in rec(G):
   8390                         partial_matching.append((u, v))
   8391                         yield partial_matching

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8387                     Nu = list(G.neighbor_iterator(u))
   8388                     G.delete_vertex(u)
-> 8389                     for partial_matching in rec(G):
   8390                         partial_matching.append((u, v))
   8391                         yield partial_matching

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8387                     Nu = list(G.neighbor_iterator(u))
   8388                     G.delete_vertex(u)
-> 8389                     for partial_matching in rec(G):
   8390                         partial_matching.append((u, v))
   8391                         yield partial_matching

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8387                     Nu = list(G.neighbor_iterator(u))
   8388                     G.delete_vertex(u)
-> 8389                     for partial_matching in rec(G):
   8390                         partial_matching.append((u, v))
   8391                         yield partial_matching

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8392                     G.add_vertex(u)
   8393                     G.add_edges((u, nu) for nu in Nu)
-> 8394                 G.add_vertex(v)
   8395                 G.add_edges((v, nv) for nv in Nv)
   8396 

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/bipartite_graph.py in add_vertex(self, name, left, right)
    558             raise RuntimeError("only one partition may be specified")
    559         if not (left or right):
--> 560             raise RuntimeError("partition must be specified (e.g. left=True)")
    561 
    562         # do nothing if we already have this vertex (idempotent)

RuntimeError: partition must be specified (e.g. left=True)
```



---

archive/issue_comments_470285.json:
```json
{
    "body": "I do see it working (disrespectfully) in Sage 9.4 and in https://sagecell.sagemath.org/",
    "created_at": "2022-01-31T19:04:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470285",
    "user": "https://github.com/maxale"
}
```

I do see it working (disrespectfully) in Sage 9.4 and in https://sagecell.sagemath.org/



---

archive/issue_comments_470286.json:
```json
{
    "body": "This is due to #32475 that has been merge in 9.5. The new method has not been tested for bipartite graph and is not compatible...\nA solution is to do a specific method for bipartite graphs. I'll give it a try.",
    "created_at": "2022-02-01T10:30:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470286",
    "user": "https://github.com/dcoudert"
}
```

This is due to #32475 that has been merge in 9.5. The new method has not been tested for bipartite graph and is not compatible...
A solution is to do a specific method for bipartite graphs. I'll give it a try.



---

archive/issue_comments_470287.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-02-01T15:19:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470287",
    "user": "https://github.com/dcoudert"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_470288.json:
```json
{
    "body": "Let me know if this is suitable for you.\n\nI changed the description of the ticket to better reflect the content (fix a bug, improve the output).\n\n---\nNew commits:",
    "created_at": "2022-02-01T15:19:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470288",
    "user": "https://github.com/dcoudert"
}
```

Let me know if this is suitable for you.

I changed the description of the ticket to better reflect the content (fix a bug, improve the output).

---
New commits:



---

archive/issue_comments_470289.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-02-01T17:05:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470289",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_470290.json:
```json
{
    "body": "I forgot to add a test showing that we can handle multiple edges.",
    "created_at": "2022-02-01T17:05:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470290",
    "user": "https://github.com/dcoudert"
}
```

I forgot to add a test showing that we can handle multiple edges.



---

archive/issue_comments_470291.json:
```json
{
    "body": "As stated in the ticket description, it is good to have a specialized version that takes advantage of the fact it is bipartite.\n\nI don't think we should have the check `if len(G.left) == len(G.right)` in `rec`. It would be better to earlier on bail out if we encounter an isolated vertex by checking `if not Nu:`.\n\nActually, I am wondering if we want to get a little more information first, mainly the number of neighbors each vertex has. Then we pick one of the vertices, say, on the right with the most neighbors first, and we change simply keep track of the minimal number of neighbors a vertex has on the left. This should allow us to short circuit out of bad paths faster. The problem is that we are basically unrolling a bit what the graph manipulation is doing and at the cost of increased memory. Perhaps a middle ground approach would be to just keep track of the vertices that are neighbors of vertices we have seen? Well, this isn't something that needs to be done on here.",
    "created_at": "2022-02-03T00:21:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470291",
    "user": "https://github.com/tscrim"
}
```

As stated in the ticket description, it is good to have a specialized version that takes advantage of the fact it is bipartite.

I don't think we should have the check `if len(G.left) == len(G.right)` in `rec`. It would be better to earlier on bail out if we encounter an isolated vertex by checking `if not Nu:`.

Actually, I am wondering if we want to get a little more information first, mainly the number of neighbors each vertex has. Then we pick one of the vertices, say, on the right with the most neighbors first, and we change simply keep track of the minimal number of neighbors a vertex has on the left. This should allow us to short circuit out of bad paths faster. The problem is that we are basically unrolling a bit what the graph manipulation is doing and at the cost of increased memory. Perhaps a middle ground approach would be to just keep track of the vertices that are neighbors of vertices we have seen? Well, this isn't something that needs to be done on here.



---

archive/issue_comments_470292.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-02-03T12:49:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470292",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_470293.json:
```json
{
    "body": "I have implemented your suggestion in `rec`.\n\nI did some trial to change the order in which the vertices are considered, for instance always choosing the vertex in in right with largest or smallest degree, with/without ordering the vertices in left by increasing/decreasing degree. In all cases it was slower than the basic approach due to the extra cost of sorting or taking min/max.\nOne might also try to use caching, etc. but I prefer to let these potential optimizations for another ticket and someone interested in improving this particular iterator.",
    "created_at": "2022-02-03T12:55:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470293",
    "user": "https://github.com/dcoudert"
}
```

I have implemented your suggestion in `rec`.

I did some trial to change the order in which the vertices are considered, for instance always choosing the vertex in in right with largest or smallest degree, with/without ordering the vertices in left by increasing/decreasing degree. In all cases it was slower than the basic approach due to the extra cost of sorting or taking min/max.
One might also try to use caching, etc. but I prefer to let these potential optimizations for another ticket and someone interested in improving this particular iterator.



---

archive/issue_comments_470294.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2022-02-04T01:28:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470294",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_470295.json:
```json
{
    "body": "Thank you.\n\nThat is fine with me. Although I believe the current algorithm is heavily dependent on the order of the vertices. Take a \"fan\" bipartite graph with edges `(j, -i)` for all `1 <= j <= i <= n`. If you go through the vertices on the right one way, it is `O(n)` to find there is only one matching whereas the other way takes roughly `O(nC2) ~ O(n^2)`, where `nC2 = binom(n, 2)`. Anyways, for a later ticket if there is a desire for this sort of optimization.",
    "created_at": "2022-02-04T01:28:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470295",
    "user": "https://github.com/tscrim"
}
```

Thank you.

That is fine with me. Although I believe the current algorithm is heavily dependent on the order of the vertices. Take a "fan" bipartite graph with edges `(j, -i)` for all `1 <= j <= i <= n`. If you go through the vertices on the right one way, it is `O(n)` to find there is only one matching whereas the other way takes roughly `O(nC2) ~ O(n^2)`, where `nC2 = binom(n, 2)`. Anyways, for a later ticket if there is a desire for this sort of optimization.



---

archive/issue_events_087827.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2022-02-16T23:57:21Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/33023#event-87827"
}
```



---

archive/issue_comments_470296.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2022-02-16T23:57:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/33023",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/33023#issuecomment-470296",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
