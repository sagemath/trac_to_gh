# Issue 33023: .perfect_matchings() does not respect partite sets of a given bipartite graph

Issue created by migration from https://trac.sagemath.org/ticket/33260

Original creator: @maxale

Original creation time: 2022-01-31 14:44:32

The order of edge endpoints in perfect matchings returned by `.perfect_matchings()` does not always consistent with the partite sets of a given bipartite graph:


```
B = BipartiteGraph( [(0, 5), (0, 7), (1, 4), (1, 6), (1, 7), (2, 4), (2, 5), (2, 8), (3, 4), (3, 5), (3, 6), (6, 9), (8, 9)] )
print('Partite sets:',B.left, B.right)
for p in B.perfect_matchings(labels=False):
    if not all(q[0] in B.left for q in p):
         print('Disrespectful matching:', p)
```



---

Comment by dcoudert created at 2022-01-31 17:53:58

Actually, the `perfect_matchings` method is not working for bipartite graphs. With sage 9.5, I get

```
sage: B = BipartiteGraph( [(0, 5), (0, 7), (1, 4), (1, 6), (1, 7), (2, 4), (2, 5), (2, 8), (3, 4), (3, 5), (3, 6), (6, 9), (8, 9)] )
....: print('Partite sets:',B.left, B.right)
....: for p in B.perfect_matchings(labels=False):
....:     if not all(q[0] in B.left for q in p):
....:          print('Disrespectful matching:', p)
....: 
Partite sets: {0, 1, 2, 3, 9} {4, 5, 6, 7, 8}
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
<ipython-input-32-476f8468fd7b> in <module>
      1 B = BipartiteGraph( [(Integer(0), Integer(5)), (Integer(0), Integer(7)), (Integer(1), Integer(4)), (Integer(1), Integer(6)), (Integer(1), Integer(7)), (Integer(2), Integer(4)), (Integer(2), Integer(5)), (Integer(2), Integer(8)), (Integer(3), Integer(4)), (Integer(3), Integer(5)), (Integer(3), Integer(6)), (Integer(6), Integer(9)), (Integer(8), Integer(9))] )
      2 print('Partite sets:',B.left, B.right)
----> 3 for p in B.perfect_matchings(labels=False):
      4     if not all(q[Integer(0)] in B.left for q in p):
      5          print('Disrespectful matching:', p)

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in perfect_matchings(self, labels)
   8413 
   8414         # For each unlabeled matching, we yield all its possible labelings
-> 8415         for m in rec(G):
   8416             for pm in itertools.product(*[edges[frozenset(e)] for e in m]):
   8417                 yield pm

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8387                     Nu = list(G.neighbor_iterator(u))
   8388                     G.delete_vertex(u)
-> 8389                     for partial_matching in rec(G):
   8390                         partial_matching.append((u, v))
   8391                         yield partial_matching

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8387                     Nu = list(G.neighbor_iterator(u))
   8388                     G.delete_vertex(u)
-> 8389                     for partial_matching in rec(G):
   8390                         partial_matching.append((u, v))
   8391                         yield partial_matching

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8387                     Nu = list(G.neighbor_iterator(u))
   8388                     G.delete_vertex(u)
-> 8389                     for partial_matching in rec(G):
   8390                         partial_matching.append((u, v))
   8391                         yield partial_matching

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8387                     Nu = list(G.neighbor_iterator(u))
   8388                     G.delete_vertex(u)
-> 8389                     for partial_matching in rec(G):
   8390                         partial_matching.append((u, v))
   8391                         yield partial_matching

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/graph.py in rec(G)
   8392                     G.add_vertex(u)
   8393                     G.add_edges((u, nu) for nu in Nu)
-> 8394                 G.add_vertex(v)
   8395                 G.add_edges((v, nv) for nv in Nv)
   8396 

~/sage/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/graphs/bipartite_graph.py in add_vertex(self, name, left, right)
    558             raise RuntimeError("only one partition may be specified")
    559         if not (left or right):
--> 560             raise RuntimeError("partition must be specified (e.g. left=True)")
    561 
    562         # do nothing if we already have this vertex (idempotent)

RuntimeError: partition must be specified (e.g. left=True)
```



---

Comment by @maxale created at 2022-01-31 19:04:27

I do see it working (disrespectfully) in Sage 9.4 and in https://sagecell.sagemath.org/


---

Comment by dcoudert created at 2022-02-01 10:30:03

This is due to #32475 that has been merge in 9.5. The new method has not been tested for bipartite graph and is not compatible...
A solution is to do a specific method for bipartite graphs. I'll give it a try.


---

Comment by dcoudert created at 2022-02-01 15:19:42

Changing status from new to needs_review.


---

Comment by dcoudert created at 2022-02-01 15:19:42

Let me know if this is suitable for you.

I changed the description of the ticket to better reflect the content (fix a bug, improve the output).
----
New commits:


---

Comment by git created at 2022-02-01 17:05:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2022-02-01 17:05:50

I forgot to add a test showing that we can handle multiple edges.


---

Comment by tscrim created at 2022-02-03 00:21:37

As stated in the ticket description, it is good to have a specialized version that takes advantage of the fact it is bipartite.

I don't think we should have the check `if len(G.left) == len(G.right)` in `rec`. It would be better to earlier on bail out if we encounter an isolated vertex by checking `if not Nu:`.

Actually, I am wondering if we want to get a little more information first, mainly the number of neighbors each vertex has. Then we pick one of the vertices, say, on the right with the most neighbors first, and we change simply keep track of the minimal number of neighbors a vertex has on the left. This should allow us to short circuit out of bad paths faster. The problem is that we are basically unrolling a bit what the graph manipulation is doing and at the cost of increased memory. Perhaps a middle ground approach would be to just keep track of the vertices that are neighbors of vertices we have seen? Well, this isn't something that needs to be done on here.


---

Comment by git created at 2022-02-03 12:49:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2022-02-03 12:55:50

I have implemented your suggestion in `rec`.

I did some trial to change the order in which the vertices are considered, for instance always choosing the vertex in in right with largest or smallest degree, with/without ordering the vertices in left by increasing/decreasing degree. In all cases it was slower than the basic approach due to the extra cost of sorting or taking min/max.
One might also try to use caching, etc. but I prefer to let these potential optimizations for another ticket and someone interested in improving this particular iterator.


---

Comment by tscrim created at 2022-02-04 01:28:03

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-02-04 01:28:03

Thank you.

That is fine with me. Although I believe the current algorithm is heavily dependent on the order of the vertices. Take a "fan" bipartite graph with edges `(j, -i)` for all `1 <= j <= i <= n`. If you go through the vertices on the right one way, it is `O(n)` to find there is only one matching whereas the other way takes roughly `O(nC2) ~ O(n^2)`, where `nC2 = binom(n, 2)`. Anyways, for a later ticket if there is a desire for this sort of optimization.


---

Comment by vbraun created at 2022-02-16 23:57:21

Resolution: fixed
