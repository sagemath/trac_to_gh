# Issue 24252: modernize complex_mpfr

Issue created by migration from Trac.

Original creator: vdelecroix

Original creation time: 2018-01-08 08:46:13

CC:  mmezzarobba jpflori

- get rid of the factory `ComplexField` by making the class `ComplexField_class` inherits from `UniqueRepresentation`
- rename `CompleNumber`/`ComplexField` into `ComplexFloatingPoint`/`ComplexFloatingPointField`
- remove the attribute `_prec` of `ComplexNumber` (a `mpfr_t` carries its precision that can be obtained with `mpfr_get_prec`)
- deprecate `is_ComplexNumber(x)`/`is_ComplexField(x)` in favor of `isinstance(x, ComplexFloatingPoint)`/`isinstance(x, ComplexFloatingPointField)`
- clarify the behavior of rounding (currently there is a global (sic) variable taking care of it)


---

Comment by jdemeyer created at 2018-01-08 09:10:13

If you are going to do serious refactoring, here is a different proposal: deprecate `complex_mpfr` altogether and use `complex_mpc` instead as the default complex floating point field.


---

Comment by vdelecroix created at 2018-01-08 09:21:44

Replying to [comment:4 jdemeyer]:
> If you are going to do serious refactoring, here is a different proposal: deprecate `complex_mpfr` altogether and use `complex_mpc` instead as the default complex floating point field.

+1. I wanted to do that at some point but Marc Mezzarobba claimed that the mpfr version was faster and hence still needed. I will be more than happy to recycle this ticket in order to do this!

Though the branch in #24483 is still useful to liberate the module `sage.rings.complex_field` needed for #24456.


---

Comment by jdemeyer created at 2018-01-08 10:55:27

> +1. I wanted to do that at some point but Marc Mezzarobba claimed that the mpfr version was faster and hence still needed.

Please keep in mind #24353 which will almost certainly change timings. Unfortunately, that ticket is current stalled because it breaks MPFI. If there is a proper release of MPC, maybe I'll try to patch MPFI in Sage.


---

Comment by vdelecroix created at 2018-01-11 19:16:52

Changing type from enhancement to task.


---

Comment by vdelecroix created at 2018-01-25 21:20:26

Replying to [comment:5 vdelecroix]:
> Replying to [comment:4 jdemeyer]:
>> +1. I wanted to do that at some point but Marc Mezzarobba claimed that the mpfr version was faster and hence still needed. I will be more than happy to recycle this ticket in order to do this!

My bad: [it was JP Flori](https://groups.google.com/forum/#!topic/sage-devel/rCvZw4c0SYM).


---

Comment by jpflori created at 2018-01-26 09:19:36

Yes it used to be the case, and Paul Zimmerman improved MPC but my last souvenir is that for basic operations Sage's complex_mpfr was still faster than complex_mpc surely because it does not handle special cases (NaN, infinities, and i don't know what) gracefully.

Things can have changed but there is only one way to knwom: benchmark both implementations, and I don't think I have any time for this.

On a side note, I would think it is a very good idea to get rid of complex_mpfr if we can.


---

Comment by jdemeyer created at 2018-01-26 09:30:49

Replying to [comment:12 jpflori]:
> because it does not handle special cases (NaN, infinities, and i don't know what) gracefully.

Certainly _not_ because of that reason. First of all, checking for a special value is really trivial compared to dealing with Python objects. You need to work with least ~100 bits of precision to have a sensible benchmark because otherwise you are only benchmarking the Python overhead anyway.


---

Comment by jdemeyer created at 2018-01-26 17:00:44

Replying to [comment:12 jpflori]:
> my last souvenir is that for basic operations Sage's complex_mpfr was still faster than complex_mpc

Of course it's always going to be faster. But that's not the point. If you really want speed, use `CDF`.

The thing that we should focus on is the correctness. With MPC, you are guaranteed that the answer that you receive is as good as it can be. With MPFR complex numbers, we are using some arbitrary formulas and we hope that everything works. On the one hand, we use an arbitrary-precision library but we cannot say whether the many bits that you get are actually meaningful.
