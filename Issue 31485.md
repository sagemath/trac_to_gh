# Issue 31485: Move generic ring methods to category

archive/issues_031485.json:
```json
{
    "body": "CC:  tscrim mkoeppe vdelecroix slelievre\n\nAll generic methods such as `\u00ecs_field` or `is_integral_domain`, which are used all over Sage, are part of `rings/ring.pyx`.\n\nI suggest to move those method to `categories/rings.py`. This allows to replace any `_Fields = Fields()` allocation and `if R in _Fields` clauses by a simpler and quicker `R.is_field()` check.\n\nIssue created by migration from https://trac.sagemath.org/ticket/31722\n\n",
    "created_at": "2021-04-24T09:39:05Z",
    "labels": [
        "categories",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Move generic ring methods to category",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31485",
    "user": "@mjungmath"
}
```
CC:  tscrim mkoeppe vdelecroix slelievre

All generic methods such as `Ã¬s_field` or `is_integral_domain`, which are used all over Sage, are part of `rings/ring.pyx`.

I suggest to move those method to `categories/rings.py`. This allows to replace any `_Fields = Fields()` allocation and `if R in _Fields` clauses by a simpler and quicker `R.is_field()` check.

Issue created by migration from https://trac.sagemath.org/ticket/31722





---

archive/issue_comments_450319.json:
```json
{
    "body": "I am a -1 on doing this. You are changing a Cython function into a Python function (which can be further called indirectly) and this check is done in some parts that need to be fast. The `is_field` check is currently quicker because of this. However, I am not opposed to having some generic method somewhere about this.\n\nThis is suggesting that more rings inherit from `Ring` when possible rather than lifting stuff up to the category.\n----\nNew commits:",
    "created_at": "2021-04-24T22:12:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450319",
    "user": "tscrim"
}
```

I am a -1 on doing this. You are changing a Cython function into a Python function (which can be further called indirectly) and this check is done in some parts that need to be fast. The `is_field` check is currently quicker because of this. However, I am not opposed to having some generic method somewhere about this.

This is suggesting that more rings inherit from `Ring` when possible rather than lifting stuff up to the category.
----
New commits:



---

archive/issue_comments_450320.json:
```json
{
    "body": "Replying to [comment:4 tscrim]:\n> I am a -1 on doing this. You are changing a Cython function into a Python function (which can be further called indirectly) and this check is done in some parts that need to be fast. The `is_field` check is currently quicker because of this. However, I am not opposed to having some generic method somewhere about this.\n\nWait a second...but `is_field` is currently a pure Python function via `def` in `ring.pyx`. Then I don't understand what you mean.",
    "created_at": "2021-04-25T08:48:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450320",
    "user": "@mjungmath"
}
```

Replying to [comment:4 tscrim]:
> I am a -1 on doing this. You are changing a Cython function into a Python function (which can be further called indirectly) and this check is done in some parts that need to be fast. The `is_field` check is currently quicker because of this. However, I am not opposed to having some generic method somewhere about this.

Wait a second...but `is_field` is currently a pure Python function via `def` in `ring.pyx`. Then I don't understand what you mean.



---

archive/issue_comments_450321.json:
```json
{
    "body": "Methods in a Cython file are faster than those in plain python files.",
    "created_at": "2021-04-25T08:56:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450321",
    "user": "tscrim"
}
```

Methods in a Cython file are faster than those in plain python files.



---

archive/issue_comments_450322.json:
```json
{
    "body": "But then we can still overwrite the category's class and obtain the same speed, no?",
    "created_at": "2021-04-25T09:02:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450322",
    "user": "@mjungmath"
}
```

But then we can still overwrite the category's class and obtain the same speed, no?



---

archive/issue_comments_450323.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2021-04-25T10:59:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450323",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_450324.json:
```json
{
    "body": "I turned `is_field` and `is_integral_domain` into `cpdef` functions now. Doctests work all over Sage except for `sage: S.is_field = lambda : False` in line 4149 in `structure/element.pyx` which I really don't understand to be there...\n\nAfter that, I added `is_field` and `is_integral_domain` to the ring category, doctests run fine except for magmas. Even though magmas have their own `is_field` method, Sage prioritizes the one from rings which causes an error in line 380 of `categories/magmas.py`.\n\nI mean, this cannot only happen to magmas. Is there any way to handle this properly?",
    "created_at": "2021-04-25T11:03:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450324",
    "user": "@mjungmath"
}
```

I turned `is_field` and `is_integral_domain` into `cpdef` functions now. Doctests work all over Sage except for `sage: S.is_field = lambda : False` in line 4149 in `structure/element.pyx` which I really don't understand to be there...

After that, I added `is_field` and `is_integral_domain` to the ring category, doctests run fine except for magmas. Even though magmas have their own `is_field` method, Sage prioritizes the one from rings which causes an error in line 380 of `categories/magmas.py`.

I mean, this cannot only happen to magmas. Is there any way to handle this properly?



---

archive/issue_comments_450325.json:
```json
{
    "body": "Next steps: reduce the usage of `_Fields` and `_IntegralDomains` as much as possible and/or rather import from `rings/ring.pyx`.",
    "created_at": "2021-04-25T11:05:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450325",
    "user": "@mjungmath"
}
```

Next steps: reduce the usage of `_Fields` and `_IntegralDomains` as much as possible and/or rather import from `rings/ring.pyx`.



---

archive/issue_comments_450326.json:
```json
{
    "body": "What is the point of reducing the usage of `_Fields` and `_IntegralDomains` (which I believe mean the categories `Fields()` and `IntegralDomains()`)? The idiom `my_parent in Fields()` and `my_parent in IntegralDomains()` are the ways to test the parents. The methods `is_field()` and `is_integral_domain()` are convenience methods randomly defined on some parents (note that rings are not forced to inherit from `Ring`).",
    "created_at": "2021-04-25T16:01:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450326",
    "user": "vdelecroix"
}
```

What is the point of reducing the usage of `_Fields` and `_IntegralDomains` (which I believe mean the categories `Fields()` and `IntegralDomains()`)? The idiom `my_parent in Fields()` and `my_parent in IntegralDomains()` are the ways to test the parents. The methods `is_field()` and `is_integral_domain()` are convenience methods randomly defined on some parents (note that rings are not forced to inherit from `Ring`).



---

archive/issue_comments_450327.json:
```json
{
    "body": "See eg #28189",
    "created_at": "2021-04-25T16:04:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450327",
    "user": "vdelecroix"
}
```

See eg #28189



---

archive/issue_comments_450328.json:
```json
{
    "body": "Typical example\n\n```\nsage: A = ZZ.cartesian_product(ZZ)\nsage: A in Fields()\nFalse\nsage: A.is_field()\nTraceback (most recent call last):\n...\nAttributeError: 'CartesianProduct_with_category' object has no attribute 'is_field'\n```\n",
    "created_at": "2021-04-25T16:07:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450328",
    "user": "vdelecroix"
}
```

Typical example

```
sage: A = ZZ.cartesian_product(ZZ)
sage: A in Fields()
False
sage: A.is_field()
Traceback (most recent call last):
...
AttributeError: 'CartesianProduct_with_category' object has no attribute 'is_field'
```




---

archive/issue_comments_450329.json:
```json
{
    "body": "Replying to [comment:14 vdelecroix]:\n> What is the point of reducing the usage of `_Fields` and `_IntegralDomains` (which I believe mean the categories `Fields()` and `IntegralDomains()`)? The idiom `my_parent in Fields()` and `my_parent in IntegralDomains()` are the ways to test the parents. The methods `is_field()` and `is_integral_domain()` are convenience methods randomly defined on some parents (note that rings are not forced to inherit from `Ring`).\n\nSee Travis's comment: #31713#comment:17.\n\nThere are a lot of files that nail `_Fields` into memory whereas other files call `is_field` even though that ring does not admit this method (e.g. `free_module`). I think this should be unified together with a clear guideline for future developments.",
    "created_at": "2021-04-25T16:52:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450329",
    "user": "@mjungmath"
}
```

Replying to [comment:14 vdelecroix]:
> What is the point of reducing the usage of `_Fields` and `_IntegralDomains` (which I believe mean the categories `Fields()` and `IntegralDomains()`)? The idiom `my_parent in Fields()` and `my_parent in IntegralDomains()` are the ways to test the parents. The methods `is_field()` and `is_integral_domain()` are convenience methods randomly defined on some parents (note that rings are not forced to inherit from `Ring`).

See Travis's comment: #31713#comment:17.

There are a lot of files that nail `_Fields` into memory whereas other files call `is_field` even though that ring does not admit this method (e.g. `free_module`). I think this should be unified together with a clear guideline for future developments.



---

archive/issue_comments_450330.json:
```json
{
    "body": "Replying to [comment:17 gh-mjungmath]:\n> Replying to [comment:14 vdelecroix]:\n> > What is the point of reducing the usage of `_Fields` and `_IntegralDomains` (which I believe mean the categories `Fields()` and `IntegralDomains()`)? The idiom `my_parent in Fields()` and `my_parent in IntegralDomains()` are the ways to test the parents. The methods `is_field()` and `is_integral_domain()` are convenience methods randomly defined on some parents (note that rings are not forced to inherit from `Ring`).\n> \n> See Travis's comment: #31713#comment:17.\n> \n> There are a lot of files that nail `_Fields` into memory whereas other files call `is_field` even though that ring does not admit this method (e.g. `free_module`). I think this should be unified together with a clear guideline for future developments.\n\nI strongly agree that unification is required. I don't see why `is_field` has to be prefered.",
    "created_at": "2021-04-25T16:58:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450330",
    "user": "vdelecroix"
}
```

Replying to [comment:17 gh-mjungmath]:
> Replying to [comment:14 vdelecroix]:
> > What is the point of reducing the usage of `_Fields` and `_IntegralDomains` (which I believe mean the categories `Fields()` and `IntegralDomains()`)? The idiom `my_parent in Fields()` and `my_parent in IntegralDomains()` are the ways to test the parents. The methods `is_field()` and `is_integral_domain()` are convenience methods randomly defined on some parents (note that rings are not forced to inherit from `Ring`).
> 
> See Travis's comment: #31713#comment:17.
> 
> There are a lot of files that nail `_Fields` into memory whereas other files call `is_field` even though that ring does not admit this method (e.g. `free_module`). I think this should be unified together with a clear guideline for future developments.

I strongly agree that unification is required. I don't see why `is_field` has to be prefered.



---

archive/issue_comments_450331.json:
```json
{
    "body": "Alright. Could you elaborate on this a bit more? I naively thought `is_field` might be faster and avoids these memory cluttering entirely.",
    "created_at": "2021-04-25T17:11:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450331",
    "user": "@mjungmath"
}
```

Alright. Could you elaborate on this a bit more? I naively thought `is_field` might be faster and avoids these memory cluttering entirely.



---

archive/issue_comments_450332.json:
```json
{
    "body": "I just think that this requires more thoughts. It is good to have your branch as a \"proof of concept\" but I think this would be better discussed on sage-devel.\n\nNote that your implementation of `is_integral_domain` basically return `NotImplementedError` in most cases. What is the point of having such method? Also you are using the `proof` flag in the opposite way people would do: namely use randomized primality testing for `Zmod(n)` (does give (very rarely) false positives but never false negatives).",
    "created_at": "2021-04-25T17:31:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450332",
    "user": "vdelecroix"
}
```

I just think that this requires more thoughts. It is good to have your branch as a "proof of concept" but I think this would be better discussed on sage-devel.

Note that your implementation of `is_integral_domain` basically return `NotImplementedError` in most cases. What is the point of having such method? Also you are using the `proof` flag in the opposite way people would do: namely use randomized primality testing for `Zmod(n)` (does give (very rarely) false positives but never false negatives).



---

archive/issue_comments_450333.json:
```json
{
    "body": "Replying to [comment:20 vdelecroix]:\n> I just think that this requires more thoughts. It is good to have your branch as a \"proof of concept\" but I think this would be better discussed on sage-devel.\n\nAlright, I'll open a thread.\n\n> Note that your implementation of `is_integral_domain` basically return `NotImplementedError` in most cases. What is the point of having such method? Also you are using the `proof` flag in the opposite way people would do: namely use randomized primality testing for `Zmod(n)` (does give (very rarely) false positives but never false negatives).\n\nI agree, and I am not satisfied with that either. But for now I just copied the code from `ring.pyx`.",
    "created_at": "2021-04-25T18:18:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450333",
    "user": "@mjungmath"
}
```

Replying to [comment:20 vdelecroix]:
> I just think that this requires more thoughts. It is good to have your branch as a "proof of concept" but I think this would be better discussed on sage-devel.

Alright, I'll open a thread.

> Note that your implementation of `is_integral_domain` basically return `NotImplementedError` in most cases. What is the point of having such method? Also you are using the `proof` flag in the opposite way people would do: namely use randomized primality testing for `Zmod(n)` (does give (very rarely) false positives but never false negatives).

I agree, and I am not satisfied with that either. But for now I just copied the code from `ring.pyx`.



---

archive/issue_comments_450334.json:
```json
{
    "body": "What I could imagine is that `is_field` returns `False` in `categories/rings.py` by default and gets overridden by concrete implementations such as parents *and* other categories. Moreover I like the idea of `_is_Field` in `rings/ring.pyx` that checks `is_field` and refines the category if it returns `True`.",
    "created_at": "2021-04-25T18:21:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450334",
    "user": "@mjungmath"
}
```

What I could imagine is that `is_field` returns `False` in `categories/rings.py` by default and gets overridden by concrete implementations such as parents *and* other categories. Moreover I like the idea of `_is_Field` in `rings/ring.pyx` that checks `is_field` and refines the category if it returns `True`.



---

archive/issue_comments_450335.json:
```json
{
    "body": "Replying to [comment:22 gh-mjungmath]:\n> What I could imagine is that `is_field` returns `False` in `categories/rings.py` by default and gets overridden by concrete implementations such as parents *and* other categories. Moreover I like the idea of `_is_Field` in `rings/ring.pyx` that checks `is_field` and refines the category if it returns `True`.\n\nThe idea is nice but the realization is less nice. By refining the category you change the classes of parents and elements (except if it is an extension class). Namely, the following construction is not commutative\n\n```\nsage: a = P(...)        # create element\nsage: P in Fields()     # refine category\nsage: f(a)              # the type P.Element did not change, a inherits from Ring.ElementClass\n```\n\nversus\n\n```\nsage: P in Fields()     # refine category\nsage: a = P(...)        # create element\nsage: f(a)              # the type P.Element did change, a inherits from Field.ElementClass\n```\n\nMaybe even worse, the following scenario ends up with two elements having different classes\n\n```\nsage: a = P(...)     # inherits from Rings.ElementClass\nsage: P in Fields()\nsage: b = P(...)     # inherits from Fields.ElementClass\n```\n",
    "created_at": "2021-04-25T18:30:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450335",
    "user": "vdelecroix"
}
```

Replying to [comment:22 gh-mjungmath]:
> What I could imagine is that `is_field` returns `False` in `categories/rings.py` by default and gets overridden by concrete implementations such as parents *and* other categories. Moreover I like the idea of `_is_Field` in `rings/ring.pyx` that checks `is_field` and refines the category if it returns `True`.

The idea is nice but the realization is less nice. By refining the category you change the classes of parents and elements (except if it is an extension class). Namely, the following construction is not commutative

```
sage: a = P(...)        # create element
sage: P in Fields()     # refine category
sage: f(a)              # the type P.Element did not change, a inherits from Ring.ElementClass
```

versus

```
sage: P in Fields()     # refine category
sage: a = P(...)        # create element
sage: f(a)              # the type P.Element did change, a inherits from Field.ElementClass
```

Maybe even worse, the following scenario ends up with two elements having different classes

```
sage: a = P(...)     # inherits from Rings.ElementClass
sage: P in Fields()
sage: b = P(...)     # inherits from Fields.ElementClass
```




---

archive/issue_comments_450336.json:
```json
{
    "body": "But that would mean that the parent must already take care of its categories during initialization such that `P in Fields()` (or `is_field` respectively) already returns the appropriate result, right?\n\nIf that is the case, the implementation of `is_field` is even easier: just return `False` for the category of rings and `True` for the category of Fields.\n\nAnd the implementation of the category of magmas would be a violation of the above concept, i.e. a flawed implementation.",
    "created_at": "2021-04-25T18:35:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450336",
    "user": "@mjungmath"
}
```

But that would mean that the parent must already take care of its categories during initialization such that `P in Fields()` (or `is_field` respectively) already returns the appropriate result, right?

If that is the case, the implementation of `is_field` is even easier: just return `False` for the category of rings and `True` for the category of Fields.

And the implementation of the category of magmas would be a violation of the above concept, i.e. a flawed implementation.



---

archive/issue_comments_450337.json:
```json
{
    "body": "Replying to [comment:24 gh-mjungmath]:\n> But that would mean that the parent must already take care of its categories during initialization such that `P in Fields()` (or `is_field` respectively) already returns the appropriate result, right?\n\nOr at least before any element is created.\n\n> If that is the case, the implementation of `is_field` is even easier: just return `False` for the category of rings and `True` for the category of Fields.\n\nThat becomes annoying for `Zmod(n)` for which you do not want to check primality of `n` until it is strictly required. Maybe that could be an option of the constructor but something has to be done.\n\n> And the implementation of the category of magmas would be a violation of the above concept, i.e. a flawed implementation.",
    "created_at": "2021-04-25T21:03:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450337",
    "user": "vdelecroix"
}
```

Replying to [comment:24 gh-mjungmath]:
> But that would mean that the parent must already take care of its categories during initialization such that `P in Fields()` (or `is_field` respectively) already returns the appropriate result, right?

Or at least before any element is created.

> If that is the case, the implementation of `is_field` is even easier: just return `False` for the category of rings and `True` for the category of Fields.

That becomes annoying for `Zmod(n)` for which you do not want to check primality of `n` until it is strictly required. Maybe that could be an option of the constructor but something has to be done.

> And the implementation of the category of magmas would be a violation of the above concept, i.e. a flawed implementation.



---

archive/issue_comments_450338.json:
```json
{
    "body": "`Zmod(n)` (or anything that does a primality check) is a problem because of the expense of checking it is a field when you might not need it. Note that `Zmod(n)` does have an `is_field` argument for this reason (as well as a `category` argument).\n\nHowever, that being said, most parents take care of their category correctly.\n\nThe `foo.is_cat_obj()` method is likely generally faster than `foo in Cat` because no testing of subcategories is needed. Testing many different cases is likely needed here.",
    "created_at": "2021-04-25T23:57:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450338",
    "user": "tscrim"
}
```

`Zmod(n)` (or anything that does a primality check) is a problem because of the expense of checking it is a field when you might not need it. Note that `Zmod(n)` does have an `is_field` argument for this reason (as well as a `category` argument).

However, that being said, most parents take care of their category correctly.

The `foo.is_cat_obj()` method is likely generally faster than `foo in Cat` because no testing of subcategories is needed. Testing many different cases is likely needed here.



---

archive/issue_comments_450339.json:
```json
{
    "body": "Replying to [comment:26 vdelecroix]:\n> Replying to [comment:24 gh-mjungmath]:\n> > But that would mean that the parent must already take care of its categories during initialization such that `P in Fields()` (or `is_field` respectively) already returns the appropriate result, right?\n> \n> Or at least before any element is created.\n> \n> > If that is the case, the implementation of `is_field` is even easier: just return `False` for the category of rings and `True` for the category of Fields.\n> \n> That becomes annoying for `Zmod(n)` for which you do not want to check primality of `n` until it is strictly required. Maybe that could be an option of the constructor but something has to be done.\n\nNot a big issue, isn't it? A parent is still allowed to overwrite the category's method.\n\nBut honestly, I don't quite get your initial argument. Why can't a parent be in the category of fields and maintain the original ring implementation? Usually, the element class stays the same whereas only the category changes, or do I get something wrong here? As far as I understand the category framework, categories and concrete implementations are entirely decoupled. Do you have a concrete example where this might fail?",
    "created_at": "2021-04-26T14:40:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450339",
    "user": "@mjungmath"
}
```

Replying to [comment:26 vdelecroix]:
> Replying to [comment:24 gh-mjungmath]:
> > But that would mean that the parent must already take care of its categories during initialization such that `P in Fields()` (or `is_field` respectively) already returns the appropriate result, right?
> 
> Or at least before any element is created.
> 
> > If that is the case, the implementation of `is_field` is even easier: just return `False` for the category of rings and `True` for the category of Fields.
> 
> That becomes annoying for `Zmod(n)` for which you do not want to check primality of `n` until it is strictly required. Maybe that could be an option of the constructor but something has to be done.

Not a big issue, isn't it? A parent is still allowed to overwrite the category's method.

But honestly, I don't quite get your initial argument. Why can't a parent be in the category of fields and maintain the original ring implementation? Usually, the element class stays the same whereas only the category changes, or do I get something wrong here? As far as I understand the category framework, categories and concrete implementations are entirely decoupled. Do you have a concrete example where this might fail?



---

archive/issue_comments_450340.json:
```json
{
    "body": "Replying to [comment:28 gh-mjungmath]:\n> Replying to [comment:26 vdelecroix]:\n> > Replying to [comment:24 gh-mjungmath]:\n> > That becomes annoying for `Zmod(n)` for which you do not want to check primality of `n` until it is strictly required. Maybe that could be an option of the constructor but something has to be done.\n> \n> Not a big issue, isn't it? A parent is still allowed to overwrite the category's method.\n> \n> But honestly, I don't quite get your initial argument. Why can't a parent be in the category of fields and maintain the original ring implementation? Usually, the element class stays the same whereas only the category changes, or do I get something wrong here? As far as I understand the category framework, categories and concrete implementations are entirely decoupled. Do you have a concrete example where this might fail?\n\nAs we all know, you need to determine if `n` is a prime to know if `Zmod(n)` is a field or not. However, this can be really slow for large `n` and you may not care that `Zmod(n)` is a field (say you are looping over all `n` and checking some formula as `n` varies). Thus, you only want to trigger the primality test when you want to make sure `Zmod(n)` is a field (after which, if it is a field, it refines its category to put it in `Fields`, but this doesn't update the already existing elements).",
    "created_at": "2021-04-30T07:34:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31485#issuecomment-450340",
    "user": "tscrim"
}
```

Replying to [comment:28 gh-mjungmath]:
> Replying to [comment:26 vdelecroix]:
> > Replying to [comment:24 gh-mjungmath]:
> > That becomes annoying for `Zmod(n)` for which you do not want to check primality of `n` until it is strictly required. Maybe that could be an option of the constructor but something has to be done.
> 
> Not a big issue, isn't it? A parent is still allowed to overwrite the category's method.
> 
> But honestly, I don't quite get your initial argument. Why can't a parent be in the category of fields and maintain the original ring implementation? Usually, the element class stays the same whereas only the category changes, or do I get something wrong here? As far as I understand the category framework, categories and concrete implementations are entirely decoupled. Do you have a concrete example where this might fail?

As we all know, you need to determine if `n` is a prime to know if `Zmod(n)` is a field or not. However, this can be really slow for large `n` and you may not care that `Zmod(n)` is a field (say you are looping over all `n` and checking some formula as `n` varies). Thus, you only want to trigger the primality test when you want to make sure `Zmod(n)` is a field (after which, if it is a field, it refines its category to put it in `Fields`, but this doesn't update the already existing elements).
