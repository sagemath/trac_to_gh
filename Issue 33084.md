# Issue 33084: Compatibility of submodules and degree_on_basis

Issue created by migration from https://trac.sagemath.org/ticket/33321

Original creator: @louisng114

Original creation time: 2022-02-10 18:29:38

CC:  mkoeppe tscrim jhpalmieri

Keywords: submodule

Currently, submodules do not inherit grading from its ambient.


```
sage: M = ModulesWithBasis(QQ).Graded().example()
sage: M(Partition((4,2,1,1,1,1))).degree()
10
sage: N = M.submodule([M(Partition((4,2,1,1,1,1)))], category=GradedModulesWithBasis(QQ))
sage: n = N.basis()
sage: n[0].degree()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
...
AttributeError: 'SubmoduleWithBasis_with_category' object has no attribute 'degree_on_basis'
```


Ideally, the enhancement works for 'degree' and 'maximal degree'. It should also work for arbitrary layers of submoduling.


---

Comment by mkoeppe created at 2022-02-10 21:23:55

Can you please add some examples that illustrate what you would like to happen? 
Should submodules of graded modules always/sometimes/never be graded by default?


---

Comment by tscrim created at 2022-02-11 00:15:35

The current behavior is correct because there is no guarantee that an _arbitrary_ submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)

Now we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.

Perhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.

For your immediate computational purposes, you can monkey patch in a degree by

```python
def degree(self):
    return self.lift().degree()
```

Note, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.

The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.


---

Comment by mkoeppe created at 2022-02-11 02:13:04

+1 on developing it both for filtered and for graded modules


---

Comment by @louisng114 created at 2022-02-12 01:47:47

Replying to [comment:3 tscrim]:
> The current behavior is correct because there is no guarantee that an _arbitrary_ submodule is spanned by homogeneous elements. For a simple example, take the submodule spanned by `f = 1 + x` in the polynomial ring with the natural degree grading. (There are more pathological examples for the counterarguments I can see for this.)
> 
> Now we could do something where we check to see if the spanning elements are homogeneous and then use the ambient grading. This then likely has a solution at the category level by creating the category of subobjects of graded modules with basis and graded modules (with basis). (Note as I argue above, this is a strict subcategory of subobjects of graded modules with basis.) This might be slightly subtle as, in principle, by saying an object is graded, you are suppose to specify what graded structure you want. Thus doing it automatically is perhaps not quite mathematically valid.
> 
> Perhaps the better solution would be to provide a `graded_submodule` method that returns a specially implemented `GradedSubmoduleWithBasis` class (as a subclass of `SubmoduleWithBasis`) that does all of this. This has the advantage of being explicit about the grading structure you want (the inherited one), not having to be very careful about adding the new category, and will likely be faster. It also means we don't have to add checks for homogeneity when someone might not want/need it.
> 
> For your immediate computational purposes, you can monkey patch in a degree by
> {{{#!python
> def degree(self):
>     return self.lift().degree()
> }}}
> Note, as mentioned above, you have told the object that it is a graded module without specifying what the graded structure is. So this is a reasonable hack until a more long-term solution is implemented.
> 
> The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.


Would it make sense to use 'maximal_degree' for the grading for the submodule by default?


---

Comment by tscrim created at 2022-02-12 03:30:44

Replying to [comment:5 gh-louisng114]:
> Replying to [comment:3 tscrim]:
> > The situation for filtered modules is perhaps easier as we do not need to contend with homogeneity issues.
> 
> 
> Would it make sense to use 'maximal_degree' for the grading for the submodule by default?

Not for graded modules: take `1 / (1 - x)` in the ring of formal power series considered as a graded module by degree. There is no reasonable way to do this mathematically I believe.


---

Comment by tscrim created at 2022-02-12 23:42:07

I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be _very_ upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.


---

Comment by @louisng114 created at 2022-02-13 18:08:56

Replying to [comment:9 tscrim]:
> I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be _very_ upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.

But this is only for when we specify the category of the submodule to be graded.


---

Comment by tscrim created at 2022-02-13 23:24:52

Replying to [comment:10 gh-louisng114]:
> Replying to [comment:9 tscrim]:
> > I am still -1 on having by default a submodule inherit a grading. There is no reason to slow down code to test for homogeneity. If you want to inherit a grading, it should be a separate method (which returns a separate (sub)class). I would be _very_ upset if I couldn't build a submodule of a graded module of nonhomogeneous elements as this is a natural thing to do.
> 
> But this is only for when we specify the category of the submodule to be graded.

Still -1 because passing that category means I am promising to provide a grading, not have it inherited. Basically I could not create a submodue of nonhomogeneous elements that I provide a different grading to. Again, it does not make sense mathematically to do this. Thinking about how it would be coded further reinforces that to me. It also makes it easier to construct the object you want as you don't have to pass the category.

For free modules over a graded algebra, we also have different constructions if we want the module to be graded or not (although this was very recently merged #32505 and should appear in the next beta).


---

Comment by @louisng114 created at 2022-02-26 19:29:33

New commits:


---

Comment by mkoeppe created at 2022-02-26 20:36:09

In this docstring (and the next):

```
+        def filtered_submodule(self, gens):
+            r"""
+            Create a graded submodule by referencing the grading of
+            ``self``. The generators have to be each homogeneous.
```

it should say "filtered". Is the condition of being homogeneous needed in this case?


---

Comment by tscrim created at 2022-02-27 00:22:44

You have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading. Let me again say that you need to create a separate *class* for the graded module and for filtered modules you can do this at the category level.

However, I was thinking a bit more, and there is a subtle issue with my example in comment:7. That is in the direct *product*, but the standard graded module is a direct *sum*. So there is a way to define a grading by the minimal or maximal degree of any element. However, because there are two incompatible ways of doing it, we should not do it in general for the graded case. A particular class/method is different than at the category level because you are explicitly saying "I want this specific object in the category."

Note that formal power series is still a *filtered* module. For filtered modules, there is a unique way to do this because for any `x` there is a *unique* minimal (or maximal for a descending filteration) index `i` such that `x \in S_i`. Contrast this with the graded case.


---

Comment by mkoeppe created at 2022-02-27 01:04:10

Replying to [comment:14 tscrim]:
> You have a contradiction: the category has a default grading and a special method saying inherit the grading. This is telling you that the category should *not* have the default grading.

You are saying that a parent in the category of subobjects of graded modules is not necessarily graded as it is in Louis' code?


---

Comment by tscrim created at 2022-02-27 04:25:22

In the generic case, that is correct. Restricting to the homogeneously generated case, it is, but that is an additional restriction that would need an additional category. Although it is such a special case that IMO it is easier to understand and maintain as a particular parent class in the categories we already have.


---

Comment by tscrim created at 2022-02-27 04:26:29

Well, more precisely it is graded (since it is a direct sum), but not in a canonical way.


---

Comment by mkoeppe created at 2022-02-27 04:27:15

Isn't it the very definition of a graded submodule that the elements of the submodule have the same degree as upstairs?


---

Comment by mkoeppe created at 2022-02-27 04:27:56

I also don't know what you mean by "generic".


---

Comment by mkoeppe created at 2022-02-27 04:33:25

In fact, I don't think there's such a thing as a graded submodule that cannot be generated by homogeneous generators.


---

Comment by tscrim created at 2022-02-27 04:55:22

As a concrete example, take a polynomial ring as a graded module over its ground ring. Then take the submodule spanned by 1 + x. This is a submodule that has 2 natural gradings (that also extends to rings), one where it has degree 0 (min deg) and the other has degree 1 (max deg). This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO and needs to be supported.

However, I see the point you are making, and there seems to be an ambiguity in the definition. We need to be very precise about what category we are in. We need to allow the construction above, and so I would not want the subobjects of a graded category to have to respect the ambient grading. I think we should have an explicit hook when we want to have something that respects the ambient grading.


---

Comment by mkoeppe created at 2022-02-27 04:57:27

Replying to [comment:21 tscrim]:
> [...] This is a graded submodule in the sense that it is a submodule and it is graded, but not one that respects the ambient space grading. This is a natural submodule to construct IMO 

Yes, but it is in the join category of "subobjects of modules with basis" and "graded modules", not in the category that we're talking about.


---

Comment by tscrim created at 2022-02-27 05:11:40

So you are saying it is different than the subobjects of graded modules? This would be a very subtle point and not what I would expect by a submodule of a graded module.


---

Comment by mkoeppe created at 2022-02-27 05:18:00

Yes, your "natural submodule" is not a graded submodule. It is submodule that also happens to have a grading.


---

Comment by tscrim created at 2022-02-27 07:47:21

I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods. Actually, it is sufficient to implement this for filtered modules.

For checking the homogeneity (after converted to an echelon basis), we can either trust the user is creating something that satisfies the conditions (which keeps the code very simple) or we override the `submodule` to also do this check when the category is a subcategory of `self.category().Subobjects()`.

I think we should also override the `submodule` implementation for `FilteredModulesWithBasis` to make the category filtered by default since this is unambiguous.


---

Comment by tscrim created at 2022-02-27 07:50:43

We should also document the definition of a subobject of a graded module is a graded module whose grading agrees with its ambient module.


---

Comment by mkoeppe created at 2022-02-27 18:03:58

Replying to [comment:25 tscrim]:
> I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. 

Yes.

> So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.

I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?

And don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?


---

Comment by tscrim created at 2022-02-28 00:21:36

Replying to [comment:27 mkoeppe]:
> Replying to [comment:25 tscrim]:
> > I am not completely convinced we want the category of graded submodules (in your definition) should be `GradedModules().Subobjects()`, but since `Subobjects()` is given as a regressive (covariant) functorial construction, we should respect that in a canonical way. 
> 
> Yes.
> 
> > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.
> 
> I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?

You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Suobjects()`. These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves (or at least those where the generic implementations are sufficient). So I am being a bit more cautious here to clutter not the namespace so much.

> And don't we still (I believe this was your earlier point) want to allow users to construct plain (non-graded) submodules of a module that happens to be graded?

As long as there is either no homogeneity enforced when the category is not `GradedModulesWithBasis(R).Subobjects()`, then this shouldn't be a problem. In fact, if we do override `GradedModulesWithBasis(R).submodule()`, we can return the filtered category when given inhomogeneous elements.


---

Comment by mkoeppe created at 2022-02-28 02:38:43

Are there already examples of methods where a `category` argument can make the default category less specific, rather than more specific?


---

Comment by tscrim created at 2022-02-28 04:00:59

I am sure there are depending on how explicit you want. `Hom` would be an essential case, other examples could be the `radical` of a Hopf algebra (it looses the Hopf part, there are others like this) or `invariant_module` (loses the ring structure if the action is not by automorphisms), and `submodule` has always allowed this:

```
sage: SGA = SymmetricGroupAlgebra(QQ,3)
sage: SGA.submodule([SGA.an_element()])
Free module generated by {0} over Rational Field
sage: _.category()
Join of Category of finite dimensional modules with basis over Rational Field
 and Category of vector spaces with basis over Rational Field
 and Category of subobjects of sets
```

It is indirectly there by the center construction via `submodule` as the category needs to be passed.


---

Comment by mkoeppe created at 2022-02-28 20:10:34

Replying to [comment:28 tscrim]:
> Replying to [comment:27 mkoeppe]:
> > Replying to [comment:25 tscrim]:
> > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.
> > 
> > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?
> 
> You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. 

Currently, but we would change this default, right?

> These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves 

OK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. 

So if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.

Now what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?


---

Comment by tscrim created at 2022-03-01 00:30:45

Replying to [comment:31 mkoeppe]:
> Replying to [comment:28 tscrim]:
> > Replying to [comment:27 mkoeppe]:
> > > Replying to [comment:25 tscrim]:
> > > > So then we do actually want to implement it in the respective categories and not have any methods `graded_*` methods.
> > > 
> > > I don't see how this follows. The method is called `submodule` (note: not `subobject`) - so doesn't this specify the desired category?
> > 
> > You can pass it the correct category in that case. The default category for `submodule` is `ModulesWithBasis(R).Subobjects()`. 
> 
> Currently, but we would change this default, right?

Only for those cases that it makes sense for:

- Submodules of filtered modules are naturally filtered.
- Possibly submodules of graded modules generated by homogeneous elements are naturally graded.

> > These might make for good convenience methods, but we get a bit of a combinatorial explosion when we want different objects/categories (e.g., rings, Hopf algebras, etc.) that is already handled by the categories themselves 
> 
> OK, perhaps a way to think about this is that the word `submodule` indicates in what sense the resulting object is generated, not in what category it lies. 
> 
> So if the object generated as a submodule happens to be a graded submodule (in the sense of the functorial construction of `GradedModulesWithBasis(R).Subobjects()`), we put it in that category.

Yes to both. That's what I am now proposing, which was one of Louis's earlier suggestions.

> Now what if `self` is a `GradedAlgebraWithBasis(R)` and we call `submodule` on it, if the result happens to be a graded subalgebra (in the sense of its functorial construction), would we also be allowed to put it in that category?

Definitely if no category is specified. I am not sure it is worth the code complexity and CPU cycles to verify the user has given us good input by checking the passed category is a subcategory and the homogeneity.


---

Comment by tscrim created at 2022-03-01 00:32:01

I am cc-ing John in case he has any thoughts or opinions on this since he works a lot with graded modules I believe.


---

Comment by jhpalmieri created at 2022-03-01 19:28:54

I'm not sure I can process all of the discussion right now, but given that disclaimer, here is my take: if you are explicitly working with an instance of `ModulesWithBasis(QQ).Graded()` and ask for a submodule, then you are in a graded setting and the submodule should be graded. (Should the code test for that or just assume that it's okay? I don't know.) Mathematically if you want to define the submodule of `k[x]` generated by `1+x`, then you should apply a forgetful functor to pass to the category of ungraded modules first, and then define the submodule. Within Sage, I think the process in the previous sentence should be explicit: if you want to define the submodule generated by `1+x`, you need to explicitly say that you are not going work in the graded setting any more.

I think this is consistent with the recent comments.


---

Comment by git created at 2022-03-02 02:00:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-03-02 02:05:52

Here is my proposal based upon our discussion. I decided to let the specified category override the filtered default in case someone wants to consider the object without the filtration (say, for doing morphisms). I also extended the allowed input for `echelon_form` and `submodule` so it was more natural. I also wasn't completely sure for the filtered quotients, so I just left that alone and only did things for graded modules.


---

Comment by tscrim created at 2022-03-02 02:05:52

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2022-03-02 02:29:22

Great!

In this doctest:

```
If ``category`` is specified, then it does not give any extra
+            structure to the submodule (we can think of this as applying
+            the forgetful functor)::
+
+                sage: SM = E.submodule([x + y, x*y - y*z], category=ModulesWithBasis(QQ))
+                sage: SM.category()
+                Join of Category of finite dimensional modules with basis over Rational Field
+                 and Category of vector spaces with basis over Rational Field
+                 and Category of subobjects of sets
+                sage: FM = E.submodule([x + 1, x*y - x*y*z], category=ModulesWithBasis(QQ))
+                sage: FM.category()
+                Join of Category of finite dimensional modules with basis over Rational Field
+                 and Category of vector spaces with basis over Rational Field
+                 and Category of subobjects of sets
+
```


it looks like the category is not quite right yet. Apart from the confusion with "Join of ... finite-dimensional modules, vector spaces" that is unrelated to this ticket, shouldn't it be at least in the category of subobjects of modules?


---

Comment by tscrim created at 2022-03-02 03:39:19

The subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two). Likewise for adding the finite dimensional axiom. I added this doctest to show that it does not automatically inherent the graded/filtered structure when the category passed does not include it.


---

Comment by mkoeppe created at 2022-03-02 03:47:00

Replying to [comment:39 tscrim]:
> The subobjects of modules is the join of subobjects of sets and vector spaces. We just do not have that specific category defined (hence the join of those two).

OK, that makes sense.


---

Comment by tscrim created at 2022-03-02 03:54:26

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2022-03-02 03:54:26


```
sage -t --long src/sage/graphs/graph.py  # 1 doctest failed
sage -t --long src/sage/combinat/sf/k_dual.py  # 1 doctest failed
sage -t --long src/sage/combinat/sf/new_kschur.py  # 1 doctest failed
sage -t --long src/sage/matrix/matrix_space.py  # 4 doctests failed
sage -t --long src/sage/algebras/orlik_terao.py  # 21 doctests failed
sage -t --long src/sage/matroids/matroid.pyx  # 4 doctests failed
sage -t --long src/sage/categories/modules_with_basis.py  # 5 doctests failed
sage -t --long src/sage/algebras/orlik_solomon.py  # 30 doctests failed
sage -t --long src/sage/matroids/linear_matroid.pyx  # 4 doctests failed
sage -t --long src/sage/categories/filtered_modules_with_basis.py  # 2 doctests failed
sage -t --long src/sage/categories/graded_modules_with_basis.py  # 6 doctests failed
```

There are a number of trivial doctest failures that I will need to fix from the change in categories. However, some non-trivial ones from the invariant rings of Orlik-!Solomon/Terao algebras from the input-standardization change. I will have to look more closely. (The `graph.py` failure is unrelated IIRC.)


---

Comment by git created at 2022-03-02 06:52:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-03-02 07:08:37

I fixed the bug, which came down to not getting the correct type for the generator input to `submodule`.

Most of the other doctests are trivial updating. I think there are some new doctests added since beta1 (which is what I am currently using to work on this branch) to update. I still need to do that, which I probably won't do until tomorrow. However, two notable changes:

- I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. I think that kind of input is an abuse and the user should explicitly change the ring of the element as there is no, a priori, relation between the two modules.
- The change of the base ring of `Sym` in `matrix_space.py` is because I was getting an unable-to-resolve-MRO issue that I could not reproduce in a more isolated example:
  {{{
TypeError: Cannot create a consistent method resolution order (MRO) for bases
 VectorSpaces.subcategory_class, GradedModules.subcategory_class
  }}}
  This doesn't change the content of that doctest, but allows us to continue to sidestep this MRO resolution issue (see, e.g., #22962).


---

Comment by mkoeppe created at 2022-03-02 07:26:08

Replying to [comment:43 tscrim]:
> - I believe the change in `modules_with_basis.py` was needed from a doctest copy/paste that was not fully updated. 

Yes, I agree


---

Comment by git created at 2022-03-04 07:17:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-03-04 07:19:17

Here are the fixes.


---

Comment by tscrim created at 2022-03-04 07:19:17

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2022-03-09 07:56:55

Bot was morally green using beta3 and passes all tests (other than known failures) run on my machine for beta4.


---

Comment by mkoeppe created at 2022-03-09 18:14:44

Looks good to me. Refinements and generalizations can be done in follow-up tickets. Thanks for this work!


---

Comment by mkoeppe created at 2022-03-09 18:14:44

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-03-09 23:23:50

Thank you.

I hope this also works for the application you have in mind Louis. If not or if you have other questions, feel free to email me directly to discuss things further.


---

Comment by vbraun created at 2022-03-12 15:11:08

Resolution: fixed
