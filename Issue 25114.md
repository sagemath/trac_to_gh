# Issue 25114: Ideal operations unsupported over QQbar

archive/issues_025114.json:
```json
{
    "body": "CC:  jdemeyer\n\nSome basic ideal operations are unsupported when `QQbar` is the base field:\n\n\n```\nsage: R.<x,y,z> = QQbar[]\n\nsage: I = ideal(x,z)\nsage: J = ideal(R(1))\n```\n\n\nNow, both quotient and saturation:\n\n\n```\nsage: I.quotient(J)\nsage: I.saturation(J)\n```\n\n\nfail with almost the same error message:\n\n\n```\nTypeError: Cannot call Singular function 'quotient' with ring parameter of type '<class 'sage.rings.polynomial.multi_polynomial_ring.MPolynomialRing_polydict_domain_with_category'>'\n```\n\n\nSingular can perform these operations, but first we have to convert to a NumberField.\n\n\n```\nsage: S.<a> = QQ[]\nsage: NFa = NumberField(a^4+1, 'a')\n\nsage: R.<x,y,z> = NFa[]\n\nsage: I = ideal(x,z) \nsage: J = ideal(R(1))\n\nsage: I.quotient(J)\nIdeal (z, x) of Multivariate Polynomial Ring in x, y, z over Number Field in a with defining polynomial a^4 + 1\n```\n\n\nThe conversion just needs to be done automatically.\n\nIssue created by migration from https://trac.sagemath.org/ticket/25351\n\n",
    "created_at": "2018-05-12T00:02:48Z",
    "labels": [
        "commutative algebra",
        "minor",
        "bug"
    ],
    "title": "Ideal operations unsupported over QQbar",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25114",
    "user": "@BrentBaccala"
}
```
CC:  jdemeyer

Some basic ideal operations are unsupported when `QQbar` is the base field:


```
sage: R.<x,y,z> = QQbar[]

sage: I = ideal(x,z)
sage: J = ideal(R(1))
```


Now, both quotient and saturation:


```
sage: I.quotient(J)
sage: I.saturation(J)
```


fail with almost the same error message:


```
TypeError: Cannot call Singular function 'quotient' with ring parameter of type '<class 'sage.rings.polynomial.multi_polynomial_ring.MPolynomialRing_polydict_domain_with_category'>'
```


Singular can perform these operations, but first we have to convert to a NumberField.


```
sage: S.<a> = QQ[]
sage: NFa = NumberField(a^4+1, 'a')

sage: R.<x,y,z> = NFa[]

sage: I = ideal(x,z) 
sage: J = ideal(R(1))

sage: I.quotient(J)
Ideal (z, x) of Multivariate Polynomial Ring in x, y, z over Number Field in a with defining polynomial a^4 + 1
```


The conversion just needs to be done automatically.

Issue created by migration from https://trac.sagemath.org/ticket/25351





---

archive/issue_comments_353362.json:
```json
{
    "body": "The design to is create a decorator that can be placed on any function that can accept polynomials and/or ideals in a number field.  The decorator will convert from `QQbar` or `AA` into a suitable number field before calling the function's actual code.\n----\nNew commits:",
    "created_at": "2018-05-24T02:17:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353362",
    "user": "@BrentBaccala"
}
```

The design to is create a decorator that can be placed on any function that can accept polynomials and/or ideals in a number field.  The decorator will convert from `QQbar` or `AA` into a suitable number field before calling the function's actual code.
----
New commits:



---

archive/issue_comments_353363.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-07T19:58:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353363",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353364.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-14T19:43:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353364",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353365.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-06-14T19:50:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353365",
    "user": "@BrentBaccala"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_353366.json:
```json
{
    "body": "In addition to the ideal operations in the ticket description, I've added the new decorator to a number of additional methods (23 in all) where it seemed suitable.\n\nThe test case for primary decomposition will fail if #25390 isn't applied, since the `factor_field` option relies on the ability to factor multivariate polynomials.\n\nDecorated methods without the `factor_field` option should work without additional patches.",
    "created_at": "2018-06-14T19:50:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353366",
    "user": "@BrentBaccala"
}
```

In addition to the ideal operations in the ticket description, I've added the new decorator to a number of additional methods (23 in all) where it seemed suitable.

The test case for primary decomposition will fail if #25390 isn't applied, since the `factor_field` option relies on the ability to factor multivariate polynomials.

Decorated methods without the `factor_field` option should work without additional patches.



---

archive/issue_comments_353367.json:
```json
{
    "body": "Changing type from defect to enhancement.",
    "created_at": "2018-06-14T19:50:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353367",
    "user": "@BrentBaccala"
}
```

Changing type from defect to enhancement.



---

archive/issue_comments_353368.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-19T05:06:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353368",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353369.json:
```json
{
    "body": "Most of these decorated methods are surely correct, but I'm not 100% sure about the `factor_field=True` methods.  I don't know if being able to factor the ideal's generators is enough to compute a primary decomposition.",
    "created_at": "2018-06-19T05:09:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353369",
    "user": "@BrentBaccala"
}
```

Most of these decorated methods are surely correct, but I'm not 100% sure about the `factor_field=True` methods.  I don't know if being able to factor the ideal's generators is enough to compute a primary decomposition.



---

archive/issue_comments_353370.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-10T04:50:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353370",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353371.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-10T04:52:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353371",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353372.json:
```json
{
    "body": "So, after a [discussion on StackExchange](https://mathoverflow.net/questions/304525), I've realized that the `factor_field=True` code didn't work, and I've removed it.\n\nI also added `jdemeyer` to the cc list, as per `tscrim`'s suggestion, to try to move this code forward.  #25390 (polynomial factorization over `QQbar`) depends on this ticket, and I think that's an important enough feature to bump this to `major`.",
    "created_at": "2018-07-10T04:57:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353372",
    "user": "@BrentBaccala"
}
```

So, after a [discussion on StackExchange](https://mathoverflow.net/questions/304525), I've realized that the `factor_field=True` code didn't work, and I've removed it.

I also added `jdemeyer` to the cc list, as per `tscrim`'s suggestion, to try to move this code forward.  #25390 (polynomial factorization over `QQbar`) depends on this ticket, and I think that's an important enough feature to bump this to `major`.



---

archive/issue_comments_353373.json:
```json
{
    "body": "Changing priority from minor to major.",
    "created_at": "2018-07-10T04:57:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353373",
    "user": "@BrentBaccala"
}
```

Changing priority from minor to major.



---

archive/issue_comments_353374.json:
```json
{
    "body": "That's a detail, but I don't really understand why you are using a decorator. From a quick glance at the code, it seems to me that in most cases at least, you know beforehand which arguments will need to be converted, and there is no real need to flatten complicated nested structures. Is that correct? Do you have in mind other usecases where that wouldn't be the case?\n\nOn a related note, I'm not sure if it's a good idea, but you might want to perform the conversion in a cached method when the only argument that matters is `self`...",
    "created_at": "2018-07-10T07:27:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353374",
    "user": "mmezzarobba"
}
```

That's a detail, but I don't really understand why you are using a decorator. From a quick glance at the code, it seems to me that in most cases at least, you know beforehand which arguments will need to be converted, and there is no real need to flatten complicated nested structures. Is that correct? Do you have in mind other usecases where that wouldn't be the case?

On a related note, I'm not sure if it's a good idea, but you might want to perform the conversion in a cached method when the only argument that matters is `self`...



---

archive/issue_comments_353375.json:
```json
{
    "body": "Replying to [comment:10 mmezzarobba]:\n> That's a detail, but I don't really understand why you are using a decorator. From a quick glance at the code, it seems to me that in most cases at least, you know beforehand which arguments will need to be converted, and there is no real need to flatten complicated nested structures. Is that correct? Do you have in mind other usecases where that wouldn't be the case?\n\nWell, each of the 23 methods would have to be modified to check if their arguments were in `QQbar`, call a function to convert them to a number field, then set a flag so we'd know to convert the result back when we're done.  Adding a one-line decorator to each method seemed like the best way to achieve this with a minimum of code duplication.\n\nAs far as flattening nested structures, we do need to extract all of a polynomial's coefficients, and all coefficients from all ideal generators in order to call `number_field_elements_from_algebraics`, which gives us a `NumberField` containing all of those coefficients, which all of those polynomials and ideals have to be converted into.  I can't see any way to avoid digging into their structure.\n\nDo you have something simpler in mind that I've missed?\n\n> \n> On a related note, I'm not sure if it's a good idea, but you might want to perform the conversion in a cached method when the only argument that matters is `self`...\n\nIf I understand correctly, you're suggesting caching a polynomial (or ideal)'s conversion in the polynomial (or ideal) object.  The problem is that the conversion usually depends on the other arguments.  For example, if I call `(x+I*y).quo_rem(...)`, then I need to convert `x+I*y` into a `NumberField` that includes `I`, but depending on what  `...` is, that `NumberField` might also need to include additional algebraic numbers.\n\nSome of the ideal methods only depend on the ideal itself, so it would be possible to cache the conversion in that case.",
    "created_at": "2018-07-10T20:58:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353375",
    "user": "@BrentBaccala"
}
```

Replying to [comment:10 mmezzarobba]:
> That's a detail, but I don't really understand why you are using a decorator. From a quick glance at the code, it seems to me that in most cases at least, you know beforehand which arguments will need to be converted, and there is no real need to flatten complicated nested structures. Is that correct? Do you have in mind other usecases where that wouldn't be the case?

Well, each of the 23 methods would have to be modified to check if their arguments were in `QQbar`, call a function to convert them to a number field, then set a flag so we'd know to convert the result back when we're done.  Adding a one-line decorator to each method seemed like the best way to achieve this with a minimum of code duplication.

As far as flattening nested structures, we do need to extract all of a polynomial's coefficients, and all coefficients from all ideal generators in order to call `number_field_elements_from_algebraics`, which gives us a `NumberField` containing all of those coefficients, which all of those polynomials and ideals have to be converted into.  I can't see any way to avoid digging into their structure.

Do you have something simpler in mind that I've missed?

> 
> On a related note, I'm not sure if it's a good idea, but you might want to perform the conversion in a cached method when the only argument that matters is `self`...

If I understand correctly, you're suggesting caching a polynomial (or ideal)'s conversion in the polynomial (or ideal) object.  The problem is that the conversion usually depends on the other arguments.  For example, if I call `(x+I*y).quo_rem(...)`, then I need to convert `x+I*y` into a `NumberField` that includes `I`, but depending on what  `...` is, that `NumberField` might also need to include additional algebraic numbers.

Some of the ideal methods only depend on the ideal itself, so it would be possible to cache the conversion in that case.



---

archive/issue_comments_353376.json:
```json
{
    "body": "Replying to [comment:11 gh-BrentBaccala]:\n> Well, each of the 23 methods would have to be modified to check if their arguments were in `QQbar`, call a function to convert them to a number field, then set a flag so we'd know to convert the result back when we're done.  Adding a one-line decorator to each method seemed like the best way to achieve this with a minimum of code duplication.\n\nYou are right, I forgot about the need to convert back! This explains the decorator. (It might still be more robust to have it only inspect the arguments it really needs to, but it doesn't matter much.)\n\n> > On a related note, I'm not sure if it's a good idea, but you might want to perform the conversion in a cached method when the only argument that matters is `self`...\n> \n> If I understand correctly, you're suggesting caching a polynomial (or ideal)'s conversion in the polynomial (or ideal) object.  The problem is that the conversion usually depends on the other arguments.  For example, if I call `(x+I*y).quo_rem(...)`, then I need to convert `x+I*y` into a `NumberField` that includes `I`, but depending on what  `...` is, that `NumberField` might also need to include additional algebraic numbers.\n> \n> Some of the ideal methods only depend on the ideal itself, so it would be possible to cache the conversion in that case.\n\nYes, that's what I meant by \u201cwhen the only argument that matters is `self`\u201d, sorry for not being clearer. But I guess it is not worth the trouble if you have to use a decorator in any case.\n\nI'm happy with the ticket. Jeroen, do you have anything to add?",
    "created_at": "2018-07-11T07:45:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353376",
    "user": "mmezzarobba"
}
```

Replying to [comment:11 gh-BrentBaccala]:
> Well, each of the 23 methods would have to be modified to check if their arguments were in `QQbar`, call a function to convert them to a number field, then set a flag so we'd know to convert the result back when we're done.  Adding a one-line decorator to each method seemed like the best way to achieve this with a minimum of code duplication.

You are right, I forgot about the need to convert back! This explains the decorator. (It might still be more robust to have it only inspect the arguments it really needs to, but it doesn't matter much.)

> > On a related note, I'm not sure if it's a good idea, but you might want to perform the conversion in a cached method when the only argument that matters is `self`...
> 
> If I understand correctly, you're suggesting caching a polynomial (or ideal)'s conversion in the polynomial (or ideal) object.  The problem is that the conversion usually depends on the other arguments.  For example, if I call `(x+I*y).quo_rem(...)`, then I need to convert `x+I*y` into a `NumberField` that includes `I`, but depending on what  `...` is, that `NumberField` might also need to include additional algebraic numbers.
> 
> Some of the ideal methods only depend on the ideal itself, so it would be possible to cache the conversion in that case.

Yes, that's what I meant by “when the only argument that matters is `self`”, sorry for not being clearer. But I guess it is not worth the trouble if you have to use a decorator in any case.

I'm happy with the ticket. Jeroen, do you have anything to add?



---

archive/issue_comments_353377.json:
```json
{
    "body": "update milestone 8.3 -> 8.4",
    "created_at": "2018-08-03T19:20:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353377",
    "user": "vdelecroix"
}
```

update milestone 8.3 -> 8.4



---

archive/issue_comments_353378.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-20T19:47:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353378",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353379.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-12-09T03:02:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353379",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353380.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-12-14T00:27:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353380",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353381.json:
```json
{
    "body": "merge conflict",
    "created_at": "2019-03-04T19:59:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353381",
    "user": "vdelecroix"
}
```

merge conflict



---

archive/issue_comments_353382.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-03-04T19:59:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353382",
    "user": "vdelecroix"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_353383.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-03-08T23:01:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353383",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353384.json:
```json
{
    "body": "Merge conflict resolved.\n\nThe conflict was with 9b1492c4d82, that moved some Singular code from `elimination_ideal()` to `_elimination_ideal_libsingular()`, and moved the ``@`libsingular_gb_standard_options` decorator along with it.  I left ``@`libsingular_gb_stnadard_options` on `_elimination_ideal_libsingular()` (where 9b1492c4d82 put it), and left ``@`handle_AA_and_QQbar` on `elmination_ideal()`, since we only need the Singular-specific decorator on Singular-specific code, but any call to the generic method might need to handle `AA` or `QQbar`.",
    "created_at": "2019-03-08T23:09:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353384",
    "user": "@BrentBaccala"
}
```

Merge conflict resolved.

The conflict was with 9b1492c4d82, that moved some Singular code from `elimination_ideal()` to `_elimination_ideal_libsingular()`, and moved the ``@`libsingular_gb_standard_options` decorator along with it.  I left ``@`libsingular_gb_stnadard_options` on `_elimination_ideal_libsingular()` (where 9b1492c4d82 put it), and left ``@`handle_AA_and_QQbar` on `elmination_ideal()`, since we only need the Singular-specific decorator on Singular-specific code, but any call to the generic method might need to handle `AA` or `QQbar`.



---

archive/issue_comments_353385.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-03-08T23:09:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353385",
    "user": "@BrentBaccala"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_353386.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-03-09T09:30:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353386",
    "user": "vdelecroix"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_353387.json:
```json
{
    "body": "It is a really good move to provide a `AA <-> nf` or `QQbar <-> nf` general mechanism to make things work properly over `AA` and `QQbar`. However, I really don't like the (fragile) magic of the decorator `handle_AA_and_QQbar`. First of all the `forward_map` and `reverse_map` would better be some kind of `Maps` properly defined and tested. Secondly, applying blindly the conversion to all arguments of a function (ignoring keywords) is very much error prone. Some argument might not need to be checked for conversion. More dramatic, a function `def f(x)` in Python can be called as `f(3)` or `f(x=3)`. But your decorator would not apply the conversion with the second call.\n\nAlso, for most functions on which you applied `handle_AA_and_QQbar` you did not bother to make a doctest.",
    "created_at": "2019-03-09T09:30:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353387",
    "user": "vdelecroix"
}
```

It is a really good move to provide a `AA <-> nf` or `QQbar <-> nf` general mechanism to make things work properly over `AA` and `QQbar`. However, I really don't like the (fragile) magic of the decorator `handle_AA_and_QQbar`. First of all the `forward_map` and `reverse_map` would better be some kind of `Maps` properly defined and tested. Secondly, applying blindly the conversion to all arguments of a function (ignoring keywords) is very much error prone. Some argument might not need to be checked for conversion. More dramatic, a function `def f(x)` in Python can be called as `f(3)` or `f(x=3)`. But your decorator would not apply the conversion with the second call.

Also, for most functions on which you applied `handle_AA_and_QQbar` you did not bother to make a doctest.



---

archive/issue_comments_353388.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-03-20T01:06:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353388",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353389.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-03-20T03:02:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353389",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353390.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-03-20T04:35:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353390",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353391.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-03-21T03:45:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353391",
    "user": "@BrentBaccala"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_353392.json:
```json
{
    "body": "Replying to [comment:20 vdelecroix]:\n> It is a really good move to provide a `AA <-> nf` or `QQbar <-> nf` general mechanism to make things work properly over `AA` and `QQbar`. However, I really don't like the (fragile) magic of the decorator `handle_AA_and_QQbar`. First of all the `forward_map` and `reverse_map` would better be some kind of `Maps` properly defined and tested. Secondly, applying blindly the conversion to all arguments of a function (ignoring keywords) is very much error prone. Some argument might not need to be checked for conversion. \n\n\nI agree that ``@`handle_AA_and_QQbar` is somewhat fragile.  There's no real theory behind it.  It just does what it needs to do for the methods that it's attached to.\n\nThere's one method (`transformed_basis`) that it doesn't fully support because the method allows an optional ring to be passed in, and ``@`handle_AA_and_QQbar` doesn't know what to do with that.  I decided to attach the decorator anyway, since the ring argument is optional, and document the `# known bug` in the test suite.\n\nI'm not aware of any kind of `Map` that can take a disjoint union of types as its domain, and do something different with each of them.  Does such a thing exist in Sage?\n\nOn the other hand, what's the alternative?  Other than modifying each function individually, I don't really see any.  The decorator works for the functions it's currently attached to.\n\n\n> More dramatic, a function `def f(x)` in Python can be called as `f(3)` or `f(x=3)`. But your decorator would not apply the conversion with the second call.\n> \n\nFixed.\n\n> Also, for most functions on which you applied `handle_AA_and_QQbar` you did not bother to make a doctest.\n\nI've added tests to all of the newly decorated methods.",
    "created_at": "2019-03-21T03:45:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353392",
    "user": "@BrentBaccala"
}
```

Replying to [comment:20 vdelecroix]:
> It is a really good move to provide a `AA <-> nf` or `QQbar <-> nf` general mechanism to make things work properly over `AA` and `QQbar`. However, I really don't like the (fragile) magic of the decorator `handle_AA_and_QQbar`. First of all the `forward_map` and `reverse_map` would better be some kind of `Maps` properly defined and tested. Secondly, applying blindly the conversion to all arguments of a function (ignoring keywords) is very much error prone. Some argument might not need to be checked for conversion. 


I agree that ``@`handle_AA_and_QQbar` is somewhat fragile.  There's no real theory behind it.  It just does what it needs to do for the methods that it's attached to.

There's one method (`transformed_basis`) that it doesn't fully support because the method allows an optional ring to be passed in, and ``@`handle_AA_and_QQbar` doesn't know what to do with that.  I decided to attach the decorator anyway, since the ring argument is optional, and document the `# known bug` in the test suite.

I'm not aware of any kind of `Map` that can take a disjoint union of types as its domain, and do something different with each of them.  Does such a thing exist in Sage?

On the other hand, what's the alternative?  Other than modifying each function individually, I don't really see any.  The decorator works for the functions it's currently attached to.


> More dramatic, a function `def f(x)` in Python can be called as `f(3)` or `f(x=3)`. But your decorator would not apply the conversion with the second call.
> 

Fixed.

> Also, for most functions on which you applied `handle_AA_and_QQbar` you did not bother to make a doctest.

I've added tests to all of the newly decorated methods.



---

archive/issue_comments_353393.json:
```json
{
    "body": "Sorry, I took to long to have a new look. The branch needs rebase.",
    "created_at": "2019-04-18T20:33:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353393",
    "user": "vdelecroix"
}
```

Sorry, I took to long to have a new look. The branch needs rebase.



---

archive/issue_comments_353394.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-04-18T20:33:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353394",
    "user": "vdelecroix"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_353395.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-19T00:53:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353395",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353396.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-04-19T01:02:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353396",
    "user": "@BrentBaccala"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_353397.json:
```json
{
    "body": "this is not Python3 safe\n\n```\n            elif isinstance(item, list):\n                return map(forward_map, item)\n```\n\nIn Python 3 you have\n\n```\n>>> map(str, [1,2,3])\n<map object at ...>\n```\n\n\nOne way to make it behave similarly on Python2/Python3 is to add on top\n\n```\nfrom six.moves import map\n```\n\nand replace the statement with\n\n```\n            elif isinstance(item, list):\n                return list(map(forward_map, item))\n```\n",
    "created_at": "2019-04-19T07:51:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353397",
    "user": "vdelecroix"
}
```

this is not Python3 safe

```
            elif isinstance(item, list):
                return map(forward_map, item)
```

In Python 3 you have

```
>>> map(str, [1,2,3])
<map object at ...>
```


One way to make it behave similarly on Python2/Python3 is to add on top

```
from six.moves import map
```

and replace the statement with

```
            elif isinstance(item, list):
                return list(map(forward_map, item))
```




---

archive/issue_comments_353398.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-19T14:10:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353398",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353399.json:
```json
{
    "body": "I believe that this ticket solves more issues than it creates. Though I am still worried by the approach that is really fragile. The amount of work the wrapper is doing should just be minimal so that the wrapped methods should actually work. In that regard your `forward map` takes care about dictionaries but not your `backward_map`. Is that intentional? The only place where it used is\n\n```\nkwds = forward_map(kwds)\n```\n\nwhere it could be dealt with more directly.",
    "created_at": "2019-04-22T20:19:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353399",
    "user": "vdelecroix"
}
```

I believe that this ticket solves more issues than it creates. Though I am still worried by the approach that is really fragile. The amount of work the wrapper is doing should just be minimal so that the wrapped methods should actually work. In that regard your `forward map` takes care about dictionaries but not your `backward_map`. Is that intentional? The only place where it used is

```
kwds = forward_map(kwds)
```

where it could be dealt with more directly.



---

archive/issue_comments_353400.json:
```json
{
    "body": "Replying to [comment:30 vdelecroix]:\n> In that regard your `forward map` takes care about dictionaries but not your `backward_map`. Is that intentional? The only place where it used is\n> {{{\n> kwds = forward_map(kwds)\n> }}}\n> where it could be dealt with more directly.\n\nIt is intentional, since none of the wrapped methods return dictionaries.",
    "created_at": "2019-04-22T23:43:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353400",
    "user": "@BrentBaccala"
}
```

Replying to [comment:30 vdelecroix]:
> In that regard your `forward map` takes care about dictionaries but not your `backward_map`. Is that intentional? The only place where it used is
> {{{
> kwds = forward_map(kwds)
> }}}
> where it could be dealt with more directly.

It is intentional, since none of the wrapped methods return dictionaries.



---

archive/issue_comments_353401.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-05-16T19:15:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353401",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353402.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-06-06T09:19:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353402",
    "user": "vdelecroix"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_353403.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-06-07T22:44:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353403",
    "user": "vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_353404.json:
```json
{
    "body": "Did anyone check that there was not a performance regression for this that could affect tight loops (specifically for `quo_rem`)?",
    "created_at": "2019-06-12T02:04:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353404",
    "user": "tscrim"
}
```

Did anyone check that there was not a performance regression for this that could affect tight loops (specifically for `quo_rem`)?



---

archive/issue_comments_353405.json:
```json
{
    "body": "Replying to [comment:35 tscrim]:\n> Did anyone check that there was not a performance regression for this that could affect tight loops (specifically for `quo_rem`)?\n\nThe first thing that the new decorator does is check to see if any of its arguments are polynomials or ideals over the algebraic field, and if not, then call the original function with no changes.\n\nSo I don't expect performance regression for existing code.\n\nOn the other hand, no explicit check was made for performance.\n\nHave you seen any suspicious performance impact?",
    "created_at": "2019-06-12T03:22:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353405",
    "user": "@BrentBaccala"
}
```

Replying to [comment:35 tscrim]:
> Did anyone check that there was not a performance regression for this that could affect tight loops (specifically for `quo_rem`)?

The first thing that the new decorator does is check to see if any of its arguments are polynomials or ideals over the algebraic field, and if not, then call the original function with no changes.

So I don't expect performance regression for existing code.

On the other hand, no explicit check was made for performance.

Have you seen any suspicious performance impact?



---

archive/issue_comments_353406.json:
```json
{
    "body": "Having the wrapper means an extra (python) function call IIRC, then there are all of those imports and the check itself. So I could see this adding up if it was called frequently. Nearly free is not free. `;)` (You also are avoiding short-circuiting by having the list inside of the `any` instead of just the generator.)\n\nI have not seen any performance hit, but for what I have used `MPolynomial_polydict.quo_rem` for, it has not been in a tight loop. So it would not be something noticeable to me without specific testing, which I do below. Ultimately I don't care too much as this fixes a bug, but it does have a bit of a code smell to me.\n\nHere is the results of my timings. On this example, I am getting about a ~10% slowdown on `8.8.rc0`:\n\n```\nsage: R = QQ['a','b']['x','y','z']\n....: p1 = R('a + (1+2*b)*x*y + (3-a^2)*z')\n....: p2 = R('x-1')\nsage: %timeit p1.quo_rem(p2)\n1000 loops, best of 3: 238 \u00b5s per loop\n```\n\nvs `8.8.beta7`:\n\n```\nsage: %timeit p1.quo_rem(p2)\n1000 loops, best of 5: 211 \u00b5s per loop\n```\n\nFor the `CC` example from the doctest there is no change in the timing. My conclusion is it more impactful for fast examples, which is what I expected given the implementation. The question is what is more common, small (fast) `quo_rem` calls or more complex ones.",
    "created_at": "2019-06-12T03:45:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353406",
    "user": "tscrim"
}
```

Having the wrapper means an extra (python) function call IIRC, then there are all of those imports and the check itself. So I could see this adding up if it was called frequently. Nearly free is not free. `;)` (You also are avoiding short-circuiting by having the list inside of the `any` instead of just the generator.)

I have not seen any performance hit, but for what I have used `MPolynomial_polydict.quo_rem` for, it has not been in a tight loop. So it would not be something noticeable to me without specific testing, which I do below. Ultimately I don't care too much as this fixes a bug, but it does have a bit of a code smell to me.

Here is the results of my timings. On this example, I am getting about a ~10% slowdown on `8.8.rc0`:

```
sage: R = QQ['a','b']['x','y','z']
....: p1 = R('a + (1+2*b)*x*y + (3-a^2)*z')
....: p2 = R('x-1')
sage: %timeit p1.quo_rem(p2)
1000 loops, best of 3: 238 µs per loop
```

vs `8.8.beta7`:

```
sage: %timeit p1.quo_rem(p2)
1000 loops, best of 5: 211 µs per loop
```

For the `CC` example from the doctest there is no change in the timing. My conclusion is it more impactful for fast examples, which is what I expected given the implementation. The question is what is more common, small (fast) `quo_rem` calls or more complex ones.



---

archive/issue_comments_353407.json:
```json
{
    "body": "Replying to [comment:37 tscrim]:\n> Having the wrapper means an extra (python) function call IIRC, then there are all of those imports and the check itself. So I could see this adding up if it was called frequently. Nearly free is not free. `;)` (You also are avoiding short-circuiting by having the list inside of the `any` instead of just the generator.)\n\nAll good points.  The `any` isn't doing what I wanted; I should have used a generator comprehension instead of a list comprehension, but for the non-AA, non-QQbar case, it doesn't matter, because it still ends up checking everything.\n\n> Here is the results of my timings. On this example, I am getting about a ~10% slowdown on `8.8.rc0`:\n> {{{\n> sage: R = QQ['a','b']['x','y','z']\n> ....: p1 = R('a + (1+2*b)*x*y + (3-a^2)*z')\n> ....: p2 = R('x-1')\n> sage: %timeit p1.quo_rem(p2)\n> 1000 loops, best of 3: 238 \u00b5s per loop\n> }}}\n> vs `8.8.beta7`:\n> {{{\n> sage: %timeit p1.quo_rem(p2)\n> 1000 loops, best of 5: 211 \u00b5s per loop\n> }}}\n\n\nI tried a caching trick to only call the imports once:\n\n\n```\nif not hasattr(wrapper, 'class_list'):\n    from sage.rings.polynomial.polynomial_element import Polynomial\n    from sage.rings.polynomial.multi_polynomial import MPolynomial\n    from sage.rings.ideal import Ideal_generic\n    from sage.rings.qqbar import AlgebraicField_common\n\n    wrapper.class_list = (Polynomial, MPolynomial, Ideal_generic)\n    wrapper.algebraicfield = AlgebraicField_common\n\nif not any((isinstance(a, wrapper.class_list)\n            and isinstance(a.base_ring(), wrapper.algebraicfield) for a in args)):\n    return func(*args, **kwds)\n```\n\n\nbut it didn't have much impact on performance.  My timings went from an average of 438 to an average of 427.  Average was 402 without the decorator at all.  A decorator that does nothing but call the nested function (no imports or tests) runs in 418.\n\n\nSo, I also get about a 10% slowdown.  Looks like roughly a third of that is function call overhead, a third of it is running the tests, and a third of it is imports.\n\nI don't see any way to avoid running the tests.  We could drop the decorator design to avoid the function call overhead, and cache the imports to avoid that cost.\n\nUnless somebody suggests a better way, I'd be opposed to cluttering up the code like that to achieve a marginal performance gain.",
    "created_at": "2019-06-12T19:51:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353407",
    "user": "@BrentBaccala"
}
```

Replying to [comment:37 tscrim]:
> Having the wrapper means an extra (python) function call IIRC, then there are all of those imports and the check itself. So I could see this adding up if it was called frequently. Nearly free is not free. `;)` (You also are avoiding short-circuiting by having the list inside of the `any` instead of just the generator.)

All good points.  The `any` isn't doing what I wanted; I should have used a generator comprehension instead of a list comprehension, but for the non-AA, non-QQbar case, it doesn't matter, because it still ends up checking everything.

> Here is the results of my timings. On this example, I am getting about a ~10% slowdown on `8.8.rc0`:
> {{{
> sage: R = QQ['a','b']['x','y','z']
> ....: p1 = R('a + (1+2*b)*x*y + (3-a^2)*z')
> ....: p2 = R('x-1')
> sage: %timeit p1.quo_rem(p2)
> 1000 loops, best of 3: 238 µs per loop
> }}}
> vs `8.8.beta7`:
> {{{
> sage: %timeit p1.quo_rem(p2)
> 1000 loops, best of 5: 211 µs per loop
> }}}


I tried a caching trick to only call the imports once:


```
if not hasattr(wrapper, 'class_list'):
    from sage.rings.polynomial.polynomial_element import Polynomial
    from sage.rings.polynomial.multi_polynomial import MPolynomial
    from sage.rings.ideal import Ideal_generic
    from sage.rings.qqbar import AlgebraicField_common

    wrapper.class_list = (Polynomial, MPolynomial, Ideal_generic)
    wrapper.algebraicfield = AlgebraicField_common

if not any((isinstance(a, wrapper.class_list)
            and isinstance(a.base_ring(), wrapper.algebraicfield) for a in args)):
    return func(*args, **kwds)
```


but it didn't have much impact on performance.  My timings went from an average of 438 to an average of 427.  Average was 402 without the decorator at all.  A decorator that does nothing but call the nested function (no imports or tests) runs in 418.


So, I also get about a 10% slowdown.  Looks like roughly a third of that is function call overhead, a third of it is running the tests, and a third of it is imports.

I don't see any way to avoid running the tests.  We could drop the decorator design to avoid the function call overhead, and cache the imports to avoid that cost.

Unless somebody suggests a better way, I'd be opposed to cluttering up the code like that to achieve a marginal performance gain.



---

archive/issue_comments_353408.json:
```json
{
    "body": "Actually, I do see a different way to do this.  Functions like `quo_rem` could be moved to the parent ring.  Then no testing would be required; the various rings would be defined with whatever is the correct function for them.",
    "created_at": "2019-06-12T19:56:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353408",
    "user": "@BrentBaccala"
}
```

Actually, I do see a different way to do this.  Functions like `quo_rem` could be moved to the parent ring.  Then no testing would be required; the various rings would be defined with whatever is the correct function for them.



---

archive/issue_comments_353409.json:
```json
{
    "body": "Something else that could be done is having a subclass for the polynomials whose eventual base ring is `AA` or `QQbar` too, but this is a bit more work.",
    "created_at": "2019-06-13T03:38:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25114",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25114#issuecomment-353409",
    "user": "tscrim"
}
```

Something else that could be done is having a subclass for the polynomials whose eventual base ring is `AA` or `QQbar` too, but this is a bit more work.
