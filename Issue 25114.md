# Issue 25114: Ideal operations unsupported over QQbar

Issue created by migration from https://trac.sagemath.org/ticket/25351

Original creator: @BrentBaccala

Original creation time: 2018-05-12 00:02:48

CC:  jdemeyer

Some basic ideal operations are unsupported when `QQbar` is the base field:


```
sage: R.<x,y,z> = QQbar[]

sage: I = ideal(x,z)
sage: J = ideal(R(1))
```


Now, both quotient and saturation:


```
sage: I.quotient(J)
sage: I.saturation(J)
```


fail with almost the same error message:


```
TypeError: Cannot call Singular function 'quotient' with ring parameter of type '<class 'sage.rings.polynomial.multi_polynomial_ring.MPolynomialRing_polydict_domain_with_category'>'
```


Singular can perform these operations, but first we have to convert to a NumberField.


```
sage: S.<a> = QQ[]
sage: NFa = NumberField(a^4+1, 'a')

sage: R.<x,y,z> = NFa[]

sage: I = ideal(x,z) 
sage: J = ideal(R(1))

sage: I.quotient(J)
Ideal (z, x) of Multivariate Polynomial Ring in x, y, z over Number Field in a with defining polynomial a^4 + 1
```


The conversion just needs to be done automatically.


---

Comment by @BrentBaccala created at 2018-05-24 02:17:21

The design to is create a decorator that can be placed on any function that can accept polynomials and/or ideals in a number field.  The decorator will convert from `QQbar` or `AA` into a suitable number field before calling the function's actual code.
----
New commits:


---

Comment by git created at 2018-06-07 19:58:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-14 19:43:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2018-06-14 19:50:49

Changing status from new to needs_review.


---

Comment by @BrentBaccala created at 2018-06-14 19:50:49

In addition to the ideal operations in the ticket description, I've added the new decorator to a number of additional methods (23 in all) where it seemed suitable.

The test case for primary decomposition will fail if #25390 isn't applied, since the `factor_field` option relies on the ability to factor multivariate polynomials.

Decorated methods without the `factor_field` option should work without additional patches.


---

Comment by @BrentBaccala created at 2018-06-14 19:50:49

Changing type from defect to enhancement.


---

Comment by git created at 2018-06-19 05:06:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2018-06-19 05:09:10

Most of these decorated methods are surely correct, but I'm not 100% sure about the `factor_field=True` methods.  I don't know if being able to factor the ideal's generators is enough to compute a primary decomposition.


---

Comment by git created at 2018-07-10 04:50:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-10 04:52:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2018-07-10 04:57:26

So, after a [discussion on StackExchange](https://mathoverflow.net/questions/304525), I've realized that the `factor_field=True` code didn't work, and I've removed it.

I also added `jdemeyer` to the cc list, as per `tscrim`'s suggestion, to try to move this code forward.  #25390 (polynomial factorization over `QQbar`) depends on this ticket, and I think that's an important enough feature to bump this to `major`.


---

Comment by @BrentBaccala created at 2018-07-10 04:57:26

Changing priority from minor to major.


---

Comment by mmezzarobba created at 2018-07-10 07:27:33

That's a detail, but I don't really understand why you are using a decorator. From a quick glance at the code, it seems to me that in most cases at least, you know beforehand which arguments will need to be converted, and there is no real need to flatten complicated nested structures. Is that correct? Do you have in mind other usecases where that wouldn't be the case?

On a related note, I'm not sure if it's a good idea, but you might want to perform the conversion in a cached method when the only argument that matters is `self`...


---

Comment by @BrentBaccala created at 2018-07-10 20:58:21

Replying to [comment:10 mmezzarobba]:
> That's a detail, but I don't really understand why you are using a decorator. From a quick glance at the code, it seems to me that in most cases at least, you know beforehand which arguments will need to be converted, and there is no real need to flatten complicated nested structures. Is that correct? Do you have in mind other usecases where that wouldn't be the case?

Well, each of the 23 methods would have to be modified to check if their arguments were in `QQbar`, call a function to convert them to a number field, then set a flag so we'd know to convert the result back when we're done.  Adding a one-line decorator to each method seemed like the best way to achieve this with a minimum of code duplication.

As far as flattening nested structures, we do need to extract all of a polynomial's coefficients, and all coefficients from all ideal generators in order to call `number_field_elements_from_algebraics`, which gives us a `NumberField` containing all of those coefficients, which all of those polynomials and ideals have to be converted into.  I can't see any way to avoid digging into their structure.

Do you have something simpler in mind that I've missed?

> 
> On a related note, I'm not sure if it's a good idea, but you might want to perform the conversion in a cached method when the only argument that matters is `self`...

If I understand correctly, you're suggesting caching a polynomial (or ideal)'s conversion in the polynomial (or ideal) object.  The problem is that the conversion usually depends on the other arguments.  For example, if I call `(x+I*y).quo_rem(...)`, then I need to convert `x+I*y` into a `NumberField` that includes `I`, but depending on what  `...` is, that `NumberField` might also need to include additional algebraic numbers.

Some of the ideal methods only depend on the ideal itself, so it would be possible to cache the conversion in that case.


---

Comment by mmezzarobba created at 2018-07-11 07:45:00

Replying to [comment:11 gh-BrentBaccala]:
> Well, each of the 23 methods would have to be modified to check if their arguments were in `QQbar`, call a function to convert them to a number field, then set a flag so we'd know to convert the result back when we're done.  Adding a one-line decorator to each method seemed like the best way to achieve this with a minimum of code duplication.

You are right, I forgot about the need to convert back! This explains the decorator. (It might still be more robust to have it only inspect the arguments it really needs to, but it doesn't matter much.)

> > On a related note, I'm not sure if it's a good idea, but you might want to perform the conversion in a cached method when the only argument that matters is `self`...
> 
> If I understand correctly, you're suggesting caching a polynomial (or ideal)'s conversion in the polynomial (or ideal) object.  The problem is that the conversion usually depends on the other arguments.  For example, if I call `(x+I*y).quo_rem(...)`, then I need to convert `x+I*y` into a `NumberField` that includes `I`, but depending on what  `...` is, that `NumberField` might also need to include additional algebraic numbers.
> 
> Some of the ideal methods only depend on the ideal itself, so it would be possible to cache the conversion in that case.

Yes, that's what I meant by “when the only argument that matters is `self`”, sorry for not being clearer. But I guess it is not worth the trouble if you have to use a decorator in any case.

I'm happy with the ticket. Jeroen, do you have anything to add?


---

Comment by vdelecroix created at 2018-08-03 19:20:18

update milestone 8.3 -> 8.4


---

Comment by git created at 2018-08-20 19:47:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-12-09 03:02:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-12-14 00:27:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-03-04 19:59:25

merge conflict


---

Comment by vdelecroix created at 2019-03-04 19:59:25

Changing status from needs_review to needs_work.


---

Comment by git created at 2019-03-08 23:01:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2019-03-08 23:09:55

Merge conflict resolved.

The conflict was with 9b1492c4d82, that moved some Singular code from `elimination_ideal()` to `_elimination_ideal_libsingular()`, and moved the ``@`libsingular_gb_standard_options` decorator along with it.  I left ``@`libsingular_gb_stnadard_options` on `_elimination_ideal_libsingular()` (where 9b1492c4d82 put it), and left ``@`handle_AA_and_QQbar` on `elmination_ideal()`, since we only need the Singular-specific decorator on Singular-specific code, but any call to the generic method might need to handle `AA` or `QQbar`.


---

Comment by @BrentBaccala created at 2019-03-08 23:09:55

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2019-03-09 09:30:09

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2019-03-09 09:30:09

It is a really good move to provide a `AA <-> nf` or `QQbar <-> nf` general mechanism to make things work properly over `AA` and `QQbar`. However, I really don't like the (fragile) magic of the decorator `handle_AA_and_QQbar`. First of all the `forward_map` and `reverse_map` would better be some kind of `Maps` properly defined and tested. Secondly, applying blindly the conversion to all arguments of a function (ignoring keywords) is very much error prone. Some argument might not need to be checked for conversion. More dramatic, a function `def f(x)` in Python can be called as `f(3)` or `f(x=3)`. But your decorator would not apply the conversion with the second call.

Also, for most functions on which you applied `handle_AA_and_QQbar` you did not bother to make a doctest.


---

Comment by git created at 2019-03-20 01:06:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-03-20 03:02:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-03-20 04:35:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2019-03-21 03:45:46

Changing status from needs_work to needs_review.


---

Comment by @BrentBaccala created at 2019-03-21 03:45:46

Replying to [comment:20 vdelecroix]:
> It is a really good move to provide a `AA <-> nf` or `QQbar <-> nf` general mechanism to make things work properly over `AA` and `QQbar`. However, I really don't like the (fragile) magic of the decorator `handle_AA_and_QQbar`. First of all the `forward_map` and `reverse_map` would better be some kind of `Maps` properly defined and tested. Secondly, applying blindly the conversion to all arguments of a function (ignoring keywords) is very much error prone. Some argument might not need to be checked for conversion. 


I agree that ``@`handle_AA_and_QQbar` is somewhat fragile.  There's no real theory behind it.  It just does what it needs to do for the methods that it's attached to.

There's one method (`transformed_basis`) that it doesn't fully support because the method allows an optional ring to be passed in, and ``@`handle_AA_and_QQbar` doesn't know what to do with that.  I decided to attach the decorator anyway, since the ring argument is optional, and document the `# known bug` in the test suite.

I'm not aware of any kind of `Map` that can take a disjoint union of types as its domain, and do something different with each of them.  Does such a thing exist in Sage?

On the other hand, what's the alternative?  Other than modifying each function individually, I don't really see any.  The decorator works for the functions it's currently attached to.


> More dramatic, a function `def f(x)` in Python can be called as `f(3)` or `f(x=3)`. But your decorator would not apply the conversion with the second call.
> 

Fixed.

> Also, for most functions on which you applied `handle_AA_and_QQbar` you did not bother to make a doctest.

I've added tests to all of the newly decorated methods.


---

Comment by vdelecroix created at 2019-04-18 20:33:09

Sorry, I took to long to have a new look. The branch needs rebase.


---

Comment by vdelecroix created at 2019-04-18 20:33:09

Changing status from needs_review to needs_work.


---

Comment by git created at 2019-04-19 00:53:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2019-04-19 01:02:33

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2019-04-19 07:51:57

this is not Python3 safe

```
            elif isinstance(item, list):
                return map(forward_map, item)
```

In Python 3 you have

```
>>> map(str, [1,2,3])
<map object at ...>
```


One way to make it behave similarly on Python2/Python3 is to add on top

```
from six.moves import map
```

and replace the statement with

```
            elif isinstance(item, list):
                return list(map(forward_map, item))
```



---

Comment by git created at 2019-04-19 14:10:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-04-22 20:19:57

I believe that this ticket solves more issues than it creates. Though I am still worried by the approach that is really fragile. The amount of work the wrapper is doing should just be minimal so that the wrapped methods should actually work. In that regard your `forward map` takes care about dictionaries but not your `backward_map`. Is that intentional? The only place where it used is

```
kwds = forward_map(kwds)
```

where it could be dealt with more directly.


---

Comment by @BrentBaccala created at 2019-04-22 23:43:28

Replying to [comment:30 vdelecroix]:
> In that regard your `forward map` takes care about dictionaries but not your `backward_map`. Is that intentional? The only place where it used is
> {{{
> kwds = forward_map(kwds)
> }}}
> where it could be dealt with more directly.

It is intentional, since none of the wrapped methods return dictionaries.


---

Comment by git created at 2019-05-16 19:15:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-06-06 09:19:49

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2019-06-07 22:44:06

Resolution: fixed


---

Comment by tscrim created at 2019-06-12 02:04:37

Did anyone check that there was not a performance regression for this that could affect tight loops (specifically for `quo_rem`)?


---

Comment by @BrentBaccala created at 2019-06-12 03:22:51

Replying to [comment:35 tscrim]:
> Did anyone check that there was not a performance regression for this that could affect tight loops (specifically for `quo_rem`)?

The first thing that the new decorator does is check to see if any of its arguments are polynomials or ideals over the algebraic field, and if not, then call the original function with no changes.

So I don't expect performance regression for existing code.

On the other hand, no explicit check was made for performance.

Have you seen any suspicious performance impact?


---

Comment by tscrim created at 2019-06-12 03:45:57

Having the wrapper means an extra (python) function call IIRC, then there are all of those imports and the check itself. So I could see this adding up if it was called frequently. Nearly free is not free. `;)` (You also are avoiding short-circuiting by having the list inside of the `any` instead of just the generator.)

I have not seen any performance hit, but for what I have used `MPolynomial_polydict.quo_rem` for, it has not been in a tight loop. So it would not be something noticeable to me without specific testing, which I do below. Ultimately I don't care too much as this fixes a bug, but it does have a bit of a code smell to me.

Here is the results of my timings. On this example, I am getting about a ~10% slowdown on `8.8.rc0`:

```
sage: R = QQ['a','b']['x','y','z']
....: p1 = R('a + (1+2*b)*x*y + (3-a^2)*z')
....: p2 = R('x-1')
sage: %timeit p1.quo_rem(p2)
1000 loops, best of 3: 238 µs per loop
```

vs `8.8.beta7`:

```
sage: %timeit p1.quo_rem(p2)
1000 loops, best of 5: 211 µs per loop
```

For the `CC` example from the doctest there is no change in the timing. My conclusion is it more impactful for fast examples, which is what I expected given the implementation. The question is what is more common, small (fast) `quo_rem` calls or more complex ones.


---

Comment by @BrentBaccala created at 2019-06-12 19:51:44

Replying to [comment:37 tscrim]:
> Having the wrapper means an extra (python) function call IIRC, then there are all of those imports and the check itself. So I could see this adding up if it was called frequently. Nearly free is not free. `;)` (You also are avoiding short-circuiting by having the list inside of the `any` instead of just the generator.)

All good points.  The `any` isn't doing what I wanted; I should have used a generator comprehension instead of a list comprehension, but for the non-AA, non-QQbar case, it doesn't matter, because it still ends up checking everything.

> Here is the results of my timings. On this example, I am getting about a ~10% slowdown on `8.8.rc0`:
> {{{
> sage: R = QQ['a','b']['x','y','z']
> ....: p1 = R('a + (1+2*b)*x*y + (3-a^2)*z')
> ....: p2 = R('x-1')
> sage: %timeit p1.quo_rem(p2)
> 1000 loops, best of 3: 238 µs per loop
> }}}
> vs `8.8.beta7`:
> {{{
> sage: %timeit p1.quo_rem(p2)
> 1000 loops, best of 5: 211 µs per loop
> }}}


I tried a caching trick to only call the imports once:


```
if not hasattr(wrapper, 'class_list'):
    from sage.rings.polynomial.polynomial_element import Polynomial
    from sage.rings.polynomial.multi_polynomial import MPolynomial
    from sage.rings.ideal import Ideal_generic
    from sage.rings.qqbar import AlgebraicField_common

    wrapper.class_list = (Polynomial, MPolynomial, Ideal_generic)
    wrapper.algebraicfield = AlgebraicField_common

if not any((isinstance(a, wrapper.class_list)
            and isinstance(a.base_ring(), wrapper.algebraicfield) for a in args)):
    return func(*args, **kwds)
```


but it didn't have much impact on performance.  My timings went from an average of 438 to an average of 427.  Average was 402 without the decorator at all.  A decorator that does nothing but call the nested function (no imports or tests) runs in 418.


So, I also get about a 10% slowdown.  Looks like roughly a third of that is function call overhead, a third of it is running the tests, and a third of it is imports.

I don't see any way to avoid running the tests.  We could drop the decorator design to avoid the function call overhead, and cache the imports to avoid that cost.

Unless somebody suggests a better way, I'd be opposed to cluttering up the code like that to achieve a marginal performance gain.


---

Comment by @BrentBaccala created at 2019-06-12 19:56:12

Actually, I do see a different way to do this.  Functions like `quo_rem` could be moved to the parent ring.  Then no testing would be required; the various rings would be defined with whatever is the correct function for them.


---

Comment by tscrim created at 2019-06-13 03:38:41

Something else that could be done is having a subclass for the polynomials whose eventual base ring is `AA` or `QQbar` too, but this is a bit more work.
