# Issue 18360: Implement m-Cambrian lattices (using delta sequences)

Issue created by migration from Trac.

Original creator: nathanwilliams

Original creation time: 2015-06-02 23:23:46

CC:  stumpc5 vivianepons kdilks tscrim

Keywords: sagedays64.5,catalan,coxeter,cambrian

Implement m-Cambrian lattices for a finite Coxeter group W and a Coxeter element c using the description in arXiv:1503.00710 on D. Armstrong's delta sequences.


---

Comment by nathanwilliams created at 2015-06-04 20:03:50

New commits:


---

Comment by git created at 2015-06-04 22:47:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nathanwilliams created at 2015-06-04 22:48:42

Changing status from new to needs_review.


---

Comment by chapoton created at 2015-06-05 07:44:15

You should not introduce all these trailing whitespaces.

See what the diff looks like when clicking on the branch name on top of this page.


---

Comment by chapoton created at 2015-06-05 07:44:15

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-06-05 15:36:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-06-05 15:42:42

Hello, nice idea to implement these posets.

The doc of a function must start with a single line looking like

```
Return the c-Cambrian lattice on delta sequences.
```

then a blank line, then more explanations, and then

```
INPUT:
```

etc


---

Comment by nathanwilliams created at 2015-06-05 16:09:56

Replying to [comment:8 chapoton]:
> Hello, nice idea to implement these posets.
> 
> The doc of a function must start with a single line looking like
> {{{
> Return the c-Cambrian lattice on delta sequences.
> }}}
> then a blank line, then more explanations, and then
> {{{
> INPUT:
> }}}
> etc

Thank you for the clarification.  I will change the order of the documentation in the functions I have implemented.  Note that some previously existing documentation uses a different order (for example, `weak_poset` in `finite_coxeter_groups.py`).


---

Comment by git created at 2015-06-05 16:14:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nathanwilliams created at 2015-06-05 16:17:34

Changing status from needs_work to needs_review.


---

Comment by stumpc5 created at 2015-06-07 11:55:34

Hi Nathan --

would you please check what of `src/sage/categories/coxeter_groups.py` you really want in this ticket, you already have the dependency #18610.

Btw that was your first contribution to `Sage` that made its way into main Sage -- congrats!

Beside that, I will do the review today.


---

Comment by chapoton created at 2015-06-07 19:11:55

correct syntax for arxiv links is


```
:arxiv:`1503.00710`
```



---

Comment by git created at 2015-06-08 10:56:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-08 10:58:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2015-06-08 11:25:19

Left to do:

* recheck that the merge of the two methods worked out (i.e., `@`Nathan please recheck that I did everything right when deleting the cambrian stuff from weyl groups and moved it into coxeter groups

* consider a more intelligent way of accessing roots and their methods from the coxeter groups category. At the moment, Weyl groups have an ElementMethod `reflection_to_root`. I think this should be moved into the parent as this method is only available for reflections, see also #18634 and #18635.

* provide a preprocessing to turn lists into tuples, otherwise, most users will see the error

```
sage: W = WeylGroup(['A',2])
sage: W.cambrian_lattice([1,2])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: unhashable type: 'list'
```



---

Comment by chapoton created at 2015-11-01 17:29:02

Christian, maybe we could get rid of the dependency to #11187 ?

There is currently a problem with the `Twords` dictionary, because its keys are essentially in 

`Full MatrixSpace of 2 by 2 sparse matrices over Universal Cyclotomic Field`

but it is evaluated on some elements

`Full MatrixSpace of 2 by 2 dense matrices over Universal Cyclotomic Field`

Travis, may I ask for your help ?


---

Comment by tscrim created at 2015-11-01 17:46:20

I would think it shouldn't matter for dense versus sparse matrices other than some output, internal storage, and/or speed:

```
sage: M = matrix(QQ, [[1,2],[0,1]], sparse=True)
sage: M2 = matrix(QQ, [[1,2],[0,1]], sparse=False)
sage: M.set_immutable()
sage: M2.set_immutable()
sage: M == M2
True
sage: hash(M) == hash(M2)
True
```

What exactly are the issues you get? I'd guess that the reasons for some of the differences come from some of the matrices that get generated...


---

Comment by chapoton created at 2015-11-01 18:12:50

Well, some (but not all) matrices (in fact matrix group elements) are not recognized as keys, even if they are == to one of the keys of the dict Twords. The hash do not match, so I thought it was because of the sparse versus dense, but maybe it comes from somewhere else..


---

Comment by chapoton created at 2015-11-02 16:57:59

Here is the problem (sitting on this branch):

```
sage: a2=CoxeterGroup(["A",2])
sage: [hash(u) for u in a2.simple_reflections()]
[-6264216653212800886, 172961895888939822]
sage: [hash(u) for u in a2.reflections_from_w0()]
[-6264216653212800886, 6091272663176086308, 172961895888939822]
sage: [hash(u) for u in a2.inversion_sequence([1,2,1])]
[-3594435451552999106, -3594435451546834518, 3594435451550176244]
sage: [u for u in a2.inversion_sequence([1,2,1])]
[
[-1  1]  [ 0 -1]  [ 1  0]
[ 0  1], [-1  0], [ 1 -1]
]
sage: [u for u in a2.reflections_from_w0()]
[
[-1  1]  [ 0 -1]  [ 1  0]
[ 0  1], [-1  0], [ 1 -1]
]
sage: a2.reflections_from_w0()==a2.inversion_sequence([1,2,1])
True
```



---

Comment by chapoton created at 2015-11-03 10:29:49

Here is the core of the problem:

```
sage: m0=matrix(UniversalCyclotomicField(),2,2,[-1,-1,0,1],sparse=True)
sage: m1=matrix(UniversalCyclotomicField(),2,2,[-1,-1,0,1],sparse=False)
sage: m0.set_immutable()
sage: m1.set_immutable()
sage: hash(m0)
6264216653211852203
sage: hash(m1)
3594435451553950751
sage: m0==m1
True
```

No problem when using ZZ or QQ instead of UCF though..


---

Comment by chapoton created at 2015-11-03 10:56:03

Maybe due to that difference ?

```
sage: hash(UniversalCyclotomicField()(0))
3713081631936575706
sage: hash(ZZ(0))
0
sage: hash(QQ(0))
0
```



---

Comment by chapoton created at 2015-11-03 11:12:05

I made #19514, but I have not yet checked if that solves the issue here.


---

Comment by chapoton created at 2015-11-03 11:15:08

It seems to work.


---

Comment by chapoton created at 2015-11-03 11:19:51

Now complains about lattice property:

```
sage: a4=CoxeterGroup(["A",4])
sage: a4.m_cambrian_lattice((4,3,2,1))
...
ValueError: Not a lattice.
```



---

Comment by stumpc5 created at 2015-11-03 13:07:06


```
ValueError: Not a lattice.
```

Hm, we cannot ignore this :-)


---

Comment by stumpc5 created at 2015-11-03 14:03:45

Fred, as usual I either forget how to use git, or I never knew: Is there a way to merge 6.10.rc0 into this branch without me rebuilding all of sage?


---

Comment by chapoton created at 2015-11-03 14:09:37

0) I assume the name of the branch 6.10.beta2 is `develop`
1) `git checkout develop -b my_new_branch`
2) `git pull trac u/stumpc5/implement_m_cambrian_lattices__using_delta_sequences_`
(please choose shorter and simpler names for your branches, by the way)
3) `sage -b`

The trick is to always start over a copy of the develop branch (step 1) and pull
you old branch on that (step 2). Then the new branch created is just a few commits after develop,
and so should not trigger large-scale re-compilation, if you have compiled the develop branch before.


---

Comment by stumpc5 created at 2015-11-03 14:16:36

Awesome, thanks!


---

Comment by stumpc5 created at 2015-11-04 10:37:16

It does work using `WeylGroup(['A',4])` instead. The poset even gives me 48 elts for `CoxeterGroups` rather than the expected 42. I cannot say whether that ever worked, or whether this is some sort of hashing issue... `@`Nathan, could you briefly check for computation issues that might come from left vs. right multiplications ?


---

Comment by stumpc5 created at 2015-11-04 20:17:07

Okay, the problem is that `cov_element = sorted(cov_element)` does not turn `cov_element` into some canonical form. So the same element can be found multiple times without recognizing.


---

Comment by git created at 2015-11-04 20:35:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2015-11-04 20:38:25

I hope to have fixed it -- please have a look, Nathan. The two main changes are: we are now using `sets` so that containment test is faster, and we use `frozensets` for inversion sets. This way we bypass the problem to have somehow sorted lists. This is cleaner and faster anyway...

Fred, could you do some tests to see whether you can confirm this bug to be fixed?


---

Comment by chapoton created at 2015-11-06 13:57:10

ok, this looks good to me. 

Here is a new branch (on top of 6.10.beta3) where

I have made small changes to the doc, mainly formatting

and also a few changes to the code, for greater clarity.

If you agree with these changes, you can set to positive review on my behalf.
----
New commits:


---

Comment by stumpc5 created at 2015-11-06 14:03:07

okay, looks good to me, waiting for the patchbot before setting it to positive.


---

Comment by chapoton created at 2015-11-06 15:30:44

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-11-07 09:34:20

Resolution: fixed
