# Issue 24133: rs_alg_and_aut

Issue created by migration from Trac.

Original creator: sijsling

Original creation time: 2017-12-12 14:03:37




---

Comment by sijsling created at 2017-12-12 14:42:29

Changing keywords from "" to "endomorphisms, automorphisms".


---

Comment by sijsling created at 2017-12-12 14:42:29

Changing component from PLEASE CHANGE to algebraic geometry.


---

Comment by sijsling created at 2017-12-12 14:42:29

Changing type from PLEASE CHANGE to enhancement.


---

Comment by sijsling created at 2017-12-12 14:42:29

Changing priority from major to minor.


---

Comment by sijsling created at 2017-12-12 14:42:29

Changing status from new to needs_review.


---

Comment by sijsling created at 2017-12-13 08:13:34

Sorry for the lack of content so far, I messed up the branch and lost code. It is on the way...


---

Comment by git created at 2017-12-13 10:23:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2017-12-13 18:07:13

Nice!

For each function, the documentation string should follow the rules listed at
    http://doc.sagemath.org/html/en/developer/coding_basics.html#the-docstring-of-a-function-content

That is: a short one-line sentence description followed by an optional longer paragraph.


---

Comment by vdelecroix created at 2017-12-13 18:10:26

To find an invertible submatrix it is much better to perform an LU decomposition. This is implemented in scipy for standard floating point precision (https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.linalg.lu.html) and much more numerically stable than what you did.


---

Comment by vdelecroix created at 2017-12-13 18:12:26

What is the point of taking power of `10` for everything? It is much more natural to consider precision in bits...


---

Comment by vdelecroix created at 2017-12-13 18:14:02

Changing status from needs_review to needs_work.


---

Comment by nbruin created at 2017-12-13 18:36:05

Replying to [comment:9 vdelecroix]:
> To find an invertible submatrix it is much better to perform an LU decomposition. This is implemented in scipy for standard floating point precision (https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.linalg.lu.html) and much more numerically stable than what you did.

mpmath has a multiprecision version if necessary but hopefully we can just get away with the single precision version here.

http://mpmath.org/doc/current/matrices.html#matrix-factorization


---

Comment by nbruin created at 2017-12-14 04:06:20

Some small updates. Your old branch should still be there if you prefer. I haven't amended the code to use LU decomp yet, but the code as it was didn't work as intended anyway.
----
New commits:


---

Comment by nbruin created at 2017-12-14 18:04:46

Another note: can we choose default values for the various epsilons based on the precision provided? It's probably good to have some margin but it probably doesn't need to be more than 5-10 bits.


---

Comment by sijsling created at 2017-12-20 10:56:52

Thanks for all your comments!

I pulled Nils' modifications (please check) and added functionality for homomorphisms and isomorphisms as well. I will soon add some files that test this in Attachments.

I modified the descriptions to start with a single one-line summary. I have also used precision where relevant, and in bits, not in decimal digits.

There is just one problem remaining, which is the extraction of an invertible submatrix. I have used scipy.linalg.lu, but it gives an extremely uninformative error message. Moreover, that function seems to work for some matrices and fail for others, which does not help to isolate the source of the error. To see what I am talking about, try using invertible_submatrix_lu. I truly have no idea what to do to get this to work, but perhaps someone else sees a simple fix.


---

Comment by git created at 2017-12-20 11:01:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-12-20 18:30:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Attachment


---

Comment by sijsling created at 2017-12-20 18:31:51

Attachments now contains examples of failing LU decompositions.


---

Comment by nbruin created at 2017-12-20 22:28:19

scipy failure: You're hitting fortran code here. It's hard to imagine it would be capable of working with sage multiprecision floats. If you convert to python standard complex floats it's probably OK:


```
def invertible_submatrix_lu(M):
    Mt = M.transpose()
    rowsMt = Mt.rows()
    colsMt = Mt.columns()
    ccMt=scipy.matrix([[p.__complex__() for p in r] for r in Mt ])
    P, L, U = lu(ccMt)
    rowsP = matrix(P).rows()
    col_nums = [ ]
    for i in range(len(rowsP)):
        if any([ (rowsP[i][j].abs() > 0.1) for j in range(len(colsMt)) ]):
            col_nums.append(i)
    subM = Matrix([ rowsMt[i] for i in col_nums ]).transpose()
    return subM, col_nums
```

At least it helps with the example you gave.

Another observation: 

The first block of the large period matrix `P=(A|B)` MUST be invertible (these are the integrals wrt to first half of the symplectic basis). In fact, to get the small period matrix we compute `A^(-1)*B` anyway. So: is it worth looking for a "better" invertible submatrix than just the first block? I doubt it.

I've looked at the examples you've posted. `lu` decomposition often chooses something else than the first `g` columns, but the determinant of the matrix it chooses isn't always larger in absolute value (that's not the only measure: we'd like the matrix to be well-conditioned as well).

So I think you can defend just not doing any work and just taking the first block. I suspect that should work about as well. If you have examples to the contrary it'll be interesting to see, of course!


---

Comment by sijsling created at 2017-12-20 22:54:06

Thank you for giving me two solutions. What you suggest already convinces me that we should just take the first g columns. I did not do this before simply because of previous habits in circumstances where the first columns did not always give an invertible submatrix. Still, I should have realized that things do work out in this context. New version coming up.


---

Comment by git created at 2017-12-20 22:54:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2017-12-20 23:06:56

You should pull out the inverse from the loop, of course :-).
Furthermore, I'm not so sure that explicitly changing to the base ring of Q is better, so why not leave it to the system to choose the appropriate precision (it would probably choose the minimum of the two). Perhaps you shouldn't even base change back to `P.base_ring()` for that reason.

If course, if you think we have enough precision lying around already to get better results by doing the intermediate computations at a higher precision then you should do that explicitly. So I think the body can be shortened to something along the lines of:

```
        P = self.period_matrix()
        Q = other.period_matrix()
        g = P.nrows()
        s = range(g)
        subP = (P[:g,:g]).inverse()
        Ts = [(Q*R)[:,:g].transpose() * subP for R in Rs]
        return [ T.change_ring(P.base_ring()) for T in Ts ]
```

(if you need the number of rows you shouldn't ask for the length of the list constructed from the rows. Slicing vs. submatrix is probably just a matter of taste)

Another point: I see that "automorphism group" now returns a permutation group. I think you should also return the action of the group on something meaningful (returning the thing as a matrix group as was done previously did that).


---

Comment by sijsling created at 2017-12-21 07:16:10

Perfect. There was no transpose needed, but your code suggestion is much better. I have also reverted to returning a matrix group. This is also better if one ever wants to divide out by -1, like in the non-hyperelliptic case, and the example shows how to obtain a permutation group anyway.


---

Comment by git created at 2017-12-21 07:16:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2017-12-30 04:20:23

Compute matrix inverse using LU decomposition. This should be numerically a little better behaved.
----
New commits:


---

Comment by git created at 2018-01-03 00:13:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2018-01-03 00:16:41

Ensuring that this works:

```
sage: E=EllipticCurve([0,1])
sage: SE=E.riemann_surface()
sage: J=SE+SE
sage: J.symplectic_automorphism_group()
Matrix group over Integer Ring with 36 generators
```



---

Attachment


---

Attachment


---

Attachment

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2018-01-08 23:12:16

very temporary patch to get nonsquare LU decomp from mpmath.
----
New commits:


---

Comment by sijsling created at 2018-01-12 09:28:56

Changing status from needs_work to needs_review.


---

Comment by sijsling created at 2018-01-12 09:28:56

New commits:


---

Comment by git created at 2018-01-12 10:57:04

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by nbruin created at 2018-01-17 11:31:57

TODO: I think it could be quite common for people to first compute the endomorphism ring (which is expensive) and then compute the automorphism group. Currently this is quite horrible because we don't cache the result of the endomorphism ring computation. We should have something in the user interface that allows re-use of precomputed endomorphism ring info. Given that the endomorphism computation is subject to tuning parameters (although in practice this seems fairly robust), I can see why we might not want to cache  the result outright. But then at least we might want an interface, comparable to how `tangent_representation_*` works, that can take as input a list of matrices and then computes the automorphisms from it. That's actually something that should only need the Rosati involution.


---

Comment by sijsling created at 2018-01-18 09:33:40

That is true. I will add `Rs` as a keyword argument to the `symplectic_*` methods, so that they are calculated by default but can be passed by the user who already has the endomorphism/homomorphism basis.


---

Comment by git created at 2018-01-18 09:46:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-02-19 12:10:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-03-24 03:57:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2018-03-24 04:02:17

Merge conflict resolved (it wasn't clear to me what the conflict was, actually). This ticket has been tested quite a bit and contains very useful code. Ready to be reviewed and merged!

Also: patchbots are reporting no problems due to this ticket.


---

Comment by nbruin created at 2018-03-24 04:02:17

Changing priority from minor to major.


---

Comment by git created at 2018-03-26 02:33:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2018-03-26 02:43:59

Surprisingly, argument computation (used in the intersection pairing) can impose a quite measurable cost, so caching it makes sense. For instance with

```
R.<x,y>=QQ[]
f = x^10 + y^10 + x^3*y^3 + 1
C=Curve(f)
S=C.riemann_surface()
%time M=S.period_matrix()
```

*PRE:*

```
CPU times: user 5min 56s, sys: 151 ms, total: 5min 56s
Wall time: 5min 57s
```

*POST:*

```
CPU times: user 3min 8s, sys: 104 ms, total: 3min 8s
Wall time: 3min 9s
```



---

Comment by git created at 2018-03-28 17:50:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2018-03-29 11:45:00

Feel free to set this to positive review if you have checked that all tests actually pass. (The patchbot produces lots of errors but I guess that this is some sort of noise.)


---

Comment by nbruin created at 2018-03-29 16:02:14

Thank you, Julian!

I've run the doctests and I get good results:

My own build has some failing tests, but those aren't due to the commits here; and neither are the problems that the bots report. So: positive it is. Great work.

(we should watch the ticket in case it bitrots before it gets merged)


---

Comment by nbruin created at 2018-03-29 16:02:14

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2018-05-07 17:59:48

Changing status from positive_review to needs_work.


---

Comment by jdemeyer created at 2018-05-07 17:59:48

The release manager might not agree that I'm setting this to needs_work, but this breaks with #24742:

```
sage -t src/sage/schemes/riemann_surfaces/riemann_surface.py
**********************************************************************
File "src/sage/schemes/riemann_surfaces/riemann_surface.py", line 353, in sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface
Failed example:
    A = S.endomorphism_basis()
Exception raised:
    Traceback (most recent call last):
      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 551, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 961, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.schemes.riemann_surfaces.riemann_surface.RiemannSurface[11]>", line 1, in <module>
        A = S.endomorphism_basis()
      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/schemes/riemann_surfaces/riemann_surface.py", line 1693, in endomorphism_basis
        return integer_matrix_relations(M,M,b,r)
      File "/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/schemes/riemann_surfaces/riemann_surface.py", line 2089, in integer_matrix_relations
        A = Matrix(R,g1,g2,V[:g1*g2])
      File "sage/matrix/constructor.pyx", line 626, in sage.matrix.constructor.MatrixFactory.__call__ (build/cythonized/sage/matrix/constructor.c:2519)
        return MatrixArgs(*args, **kwds).matrix()
      File "sage/matrix/args.pyx", line 646, in sage.matrix.args.MatrixArgs.matrix (build/cythonized/sage/matrix/args.c:7896)
        self.finalize()
      File "sage/matrix/args.pyx", line 853, in sage.matrix.args.MatrixArgs.finalize (build/cythonized/sage/matrix/args.c:9655)
        raise TypeError(f"unable to convert {self.entries!r} to a matrix")
    TypeError: unable to convert ['a1'] to a matrix
**********************************************************************
```


This is because #24742 disallows using strings to construct matrix entries.


---

Comment by jdemeyer created at 2018-05-07 18:03:24

I think that the old code

```
    names = ["%s%s"%(n, i+1) for n in ["a","b","c","d"] for i in range(g**2)]
    R = PolynomialRing(CC, names)
    vars = R.gens()
    A = Matrix(R, g, g, vars[:g**2])
    B = Matrix(R, g, g, vars[g**2:2*g**2])
    C = Matrix(R, g, g, vars[2*g**2:3*g**2])
    D = Matrix(R, g, g, vars[3*g**2:4*g**2])
```

is clearly better than the new code from this ticket

```
    V = ["%s%s"%(n,i) for n in ["a","b","c","d"] for i in srange(1,1+g1*g2)]
    R = PolynomialRing(CC,V)
    A = Matrix(R,g1,g2,V[:g1*g2])
    B = Matrix(R,g1,g2,V[g1*g2:2*g1*g2])
    C = Matrix(R,g1,g2,V[2*g1*g2:3*g1*g2])
    D = Matrix(R,g1,g2,V[3*g1*g2:4*g1*g2])
```



---

Comment by nbruin created at 2018-05-07 19:37:21

Replying to [comment:55 jdemeyer]:
> I think that the old code
> {{{
>     names = ["%s%s"%(n, i+1) for n in ["a","b","c","d"] for i in range(g**2)]
>     R = PolynomialRing(CC, names)
>     vars = R.gens()
>     A = Matrix(R, g, g, vars[:g**2])
>     B = Matrix(R, g, g, vars[g**2:2*g**2])
>     C = Matrix(R, g, g, vars[2*g**2:3*g**2])
>     D = Matrix(R, g, g, vars[3*g**2:4*g**2])
> }}}
> is clearly better than the new code from this ticket
> {{{
>     V = ["%s%s"%(n,i) for n in ["a","b","c","d"] for i in srange(1,1+g1*g2)]
>     R = PolynomialRing(CC,V)
>     A = Matrix(R,g1,g2,V[:g1*g2])
>     B = Matrix(R,g1,g2,V[g1*g2:2*g1*g2])
>     C = Matrix(R,g1,g2,V[2*g1*g2:3*g1*g2])
>     D = Matrix(R,g1,g2,V[3*g1*g2:4*g1*g2])
> }}}

I agree with that in principle; I'll leave it to Jeroen to fix this. Perhaps he had a good reason to prefer strings (I fail to see any). I'm also fine with merging this ticket as-is, but that's unlikely to happen now that someone has reverted the positive review (grr).


---

Comment by git created at 2018-05-07 20:32:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2018-05-07 20:34:21

Jeroen can revert this if he wants strings. In the mean time, the quickest way forward is to just initialize with the variable objects instead.


---

Comment by nbruin created at 2018-05-07 20:34:21

Changing status from needs_work to positive_review.


---

Comment by jdemeyer created at 2018-05-07 21:55:33

When you said "Jeroen" in the last few comments, I guess you refer to Jeroen Sijsling? I didn't get that initially.


---

Comment by nbruin created at 2018-05-08 04:53:42

Replying to [comment:59 jdemeyer]:
> When you said "Jeroen" in the last few comments, I guess you refer to Jeroen Sijsling? I didn't get that initially.
Well, that's a namespace issue you'll have to solve yourselves :-)


---

Comment by sijsling created at 2018-05-08 14:29:01

This part of the functionality seems to date from before this particular ticket (thus saith git blame). And I do not recall changing this. Anyway, no need to revert on my account.


---

Comment by nbruin created at 2018-05-08 20:35:27

Hm. It is a little weird where this change happened. It takes a `git log --follow` to find the change:
It seems the change was made on #24884 to use variables instead of strings. Oddly enough, there is nothing in the history of the file that has since undone that change if I look in the history of the file. It seems git trac is basing its diffs on an alternate timeline ...


---

Comment by vbraun created at 2018-05-09 09:49:56

Resolution: fixed
