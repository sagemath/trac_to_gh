# Issue 18045: Improve the evaluation of polynomials on symbolic expressions

Issue created by migration from Trac.

Original creator: mmezzarobba

Original creation time: 2015-04-22 16:01:55

CC:  rws jpflori

Evaluating of a polynomial (from a polynomial ring) on an element of `SR` calls a generic implementation of Horner evaluation, so that the result is in (a kind of) Horner form:

```
sage: pol = QQ['x'](range(10))
sage: pol(x)
((((((((9*x + 8)*x + 7)*x + 6)*x + 5)*x + 4)*x + 3)*x + 2)*x + 1)*x
```

This is probably not what users expect. Additionally, the conversion could be much more efficient.


---

Comment by git created at 2015-04-23 11:03:02

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by rws created at 2015-04-24 12:30:11

Changing component from symbolics to commutative algebra.


---

Comment by git created at 2015-04-24 16:46:15

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2015-04-25 06:55:46

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2015-04-25 06:56:16

Changing status from new to needs_review.


---

Comment by nbruin created at 2015-04-25 19:08:22


```
sage: pol(y, 0)
1000*x^2*y^2 + 100*y + 10*x + 1
```

If I understand correctly, you now make this evaluate to `100*y+1`? In which ring? You've evaluated `x`, so the answer should lie in QQ['y'], which is not a ring that exists at this moment. What about `pol(y,I)`? should that return an answer in `QuadraticField(-1,name="I")['y']`?

-1 on this: The method you're calling is evaluating a univariate polynomial over an arbitrary ring. You don't know what "evaluation" of the coefficient would mean and, more importantly, whether it's supported at all. Furthermore, the rings in which the answer is supposed to lie likely don't exist yet. Letting sage choose which rings should be constructed likely leads to difficult to predict behaviour (you'd basically be relying on the common parents the coercion framework cooks up, and then I think it's better to let the user rely on it him/herself).

I think that `pol(y,0)` should be an error because there's an unhandled coefficient `0` present. It's not clear at all that the *second* argument should be used for the variable that gets mentioned *first* in `QQ['x']['y']`. One might think that `pol(y0,x0)==pol(y0)(x0)`, but that's not the case either. Error really is safer.


---

Comment by mmezzarobba created at 2015-04-26 07:09:05

Replying to [comment:8 nbruin]:
> {{{
> sage: pol(y, 0)
> 1000*x<sup>2*y</sup>2 + 100*y + 10*x + 1
> }}}
> If I understand correctly, you now make this evaluate to `100*y+1`?

Yes:

```
sage: pol(y, 0) # with patch
100*y + 1
```


Note that the previous implementation wouldn't work in the case of `pol(y, 0)`, but would happily compute

```
sage: sage: pol(y+1, 0) # without patch
100*y + 101
```


> In which ring? You've evaluated `x`, so the answer should lie in QQ['y'], which is not a ring that exists at this moment.

Not exactly:

```
sage: pol(y, 0).parent() # with patch
Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Rational Field
```

The logic here is that yes, I have evaluated x, so the evaluated coefficients lie in ℚ, _but_ then I'm evaluating the resulting element of ℚ[Y] on y ∈ ℚ[x][y], not y ∈ ℚ[y]. So the answer should lie in ℚ[x][y].

In contrast,

```
sage: pol(0, x).parent() # with patch
Univariate Polynomial Ring in x over Rational Field
```

since `x.parent()` is `QQ[x]`, not `QQ[x][y]`.

> What about `pol(y,I)`? should that return an answer in `QuadraticField(-1,name="I")['y']`?


```
sage: pol(y, I).parent() # with patch - TBI, see #18036
Symbolic Ring
sage: pol(y, I.pyobject()).parent() # with patch
Univariate Polynomial Ring in y over Univariate Polynomial Ring in x over Number Field in I with defining polynomial x^2 + 1
```


> Furthermore, the rings in which the answer is supposed to lie likely don't exist yet. Letting sage choose which rings should be constructed likely leads to difficult to predict behaviour (you'd basically be relying on the common parents the coercion framework cooks up,

Well, yes, but that's already the case when you just do `a + b`! Would you really want the evaluation of elements of ℤ[x][y] on y = y0 ∈ ℚ to raise an error?

> I think that `pol(y,0)` should be an error because there's an unhandled coefficient `0` present. It's not clear at all that the *second* argument should be used for the variable that gets mentioned *first* in `QQ['x']['y']`. One might think that `pol(y0,x0)==pol(y0)(x0)`, but that's not the case either. Error really is safer.

Perhaps, yes, but I didn't invent this feature. It has been present for years, and people use it! There are even examples in the sage library that rely on `pol(y,x)` working when pol ∈ R[y] where R is _not_ a polynomial ring (but another ring with callable elements). So really this ticket is only about making the implementation understandable, and fixing lots of corner cases such as those mentioned above.


---

Comment by nbruin created at 2015-04-26 17:18:14

Replying to [comment:9 mmezzarobba]:
> Perhaps, yes, but I didn't invent this feature. It has been present for years, and people use it! There are even examples in the sage library that rely on `pol(y,x)` working when pol ∈ R[y] where R is _not_ a polynomial ring (but another ring with callable elements). So really this ticket is only about making the implementation understandable, and fixing lots of corner cases such as those mentioned above.

OK, that seems to be the case indeed. Thanks for cleaning things up a bit.


---

Comment by git created at 2015-05-30 09:56:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2015-05-30 09:58:52

Rebased.


---

Comment by bruno created at 2015-06-03 15:11:22

In view of #18600 (and older sisters #18518 and #18585), I think `__call__` may be at the same time improved and adapted to high degree sparse polynomials: Basically, when a univariate polynomial `p` is evaluated on a value `v` (other than a symbolic variable), it uses a Horner scheme that ranges over all the coefficients of `p`, including the zeroes. One could easily modify lines 755-756 in `src/sage/rings/polynomial/polynomial_element.pyx` to make the loop ranges over the nonzero coefficients. I've not checked already whether it is slower in a sensible way for really dense polynomials or not, but it would be faster for sparse polynomials. And as a side benefit, one would be able to evaluate polynomials such as `x<sup>2</sup>500`, at least on "easy" values such as `1` or `-1` or on finite fields.

What do you think of my proposal?


---

Comment by mmezzarobba created at 2015-06-04 07:40:06

Replying to [comment:15 bruno]:
> One could easily modify lines 755-756 in `src/sage/rings/polynomial/polynomial_element.pyx` to make the loop ranges over the nonzero coefficients. I've not checked already whether it is slower in a sensible way for really dense polynomials or not, but it would be faster for sparse polynomials.

Sounds reasonable—or perhaps one should override `__call__` in `Polynomial_generic_sparse`, I don't know. In any case I have no time to spend on this ticket now, but please feel free to add improvements if you want!


---

Comment by bruno created at 2015-06-04 08:07:25

Replying to [comment:16 mmezzarobba]:
> Replying to [comment:15 bruno]:
> > One could easily modify lines 755-756 in `src/sage/rings/polynomial/polynomial_element.pyx` to make the loop ranges over the nonzero coefficients. I've not checked already whether it is slower in a sensible way for really dense polynomials or not, but it would be faster for sparse polynomials.
> 
> Sounds reasonable—or perhaps one should override `__call__` in `Polynomial_generic_sparse`, I don't know. In any case I have no time to spend on this ticket now, but please feel free to add improvements if you want!

Actually, I did some tests. It appears that it should be better to implement a `__call__` method in `Polynomial_generic_sparse` to avoid hindering performances. The other solution would be to have tests inside the current `__call__` method to check whether the `parent` is sparse or not. One advantage is to avoid code duplication (for `*args` and `*kwds`), though I guess it is not the right solution.

I'd better let this ticket as it is (and actually try to review it...) and open a new ticket for sparse polynomials.


---

Comment by rws created at 2015-07-29 15:45:08

Changing status from needs_review to positive_review.


---

Comment by rws created at 2015-07-29 15:45:08

In Pynac-0.4.3 (maybe 0.3.9.3) `sin(pi/5)` expands immediately to `1/4*sqrt(-2*sqrt(5) + 10)` (actually every `sin`/`cos`/`tan` value expressible with `sqrt`s of depth 3), so I'll change the doctest to `sin(pi/7)`.

As I trust Nils on the general purpose, and I can see nothing missing in the code, also the patchbot is happy and my patch is only a doctest change I'll take the liberty to set positive.
----
New commits:


---

Comment by vbraun created at 2015-07-31 17:52:27

Resolution: fixed


---

Comment by mmezzarobba created at 2015-08-01 08:35:32

Thanks!
