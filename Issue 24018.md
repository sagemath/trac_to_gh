# Issue 24018: Fix substitution with pattern given as equation

Issue created by migration from https://trac.sagemath.org/ticket/24255

Original creator: rws

Original creation time: 2017-11-21 06:21:47

There is a long-standing problem with substitution in that some substitutions do not work when given as equality but do work when given as dictionary.


```
sage: (x*pi).subs(x*pi==e)
x*pi
sage: (x*pi).subs({x*pi:e})
e
```


It looks like that in some cases the conversion to dict switches lhs and rhs of the equation.


---

Comment by rws created at 2017-11-23 09:02:47


```
class A(SageObject):
    def __init__(self):
        from sage.symbolic.ring import SR
        self._parent = SR
    def __eq__(a, b):
        print(a, b)
        return True
    def __repr__(self):
        return "A"

class B(A):
    def __eq__(a, b):
        print(a, b)
        return True
    def __repr__(self):
        return "B"

sage: from sage.symbolic.tests import A,B
sage: A() == B()
(B, A)
True

versus

class A():
    def __init__(self):
        from sage.symbolic.ring import SR
        self._parent = SR
    def __eq__(a, b):
        print(a, b)
        return True
    def __repr__(self):
        return "A"

class B(A):
    def __eq__(a, b):
        print(a, b)
        return True
    def __repr__(self):
        return "B"

sage: from sage.symbolic.tests import A,B
sage: A() == B()
(A, B)
True
```

The first has `A` inherit from `SageObject` the second not.


---

Comment by rws created at 2017-11-23 09:57:58

Since we cannot use the ``@`richcmp` decorator on a `cdef` class we cannot work around it but must investigate the reason for the argument switching, which is possibly in Cython.


---

Comment by rws created at 2017-11-23 16:11:32

Adding `__eq__` does not work I get a Cython compile error reported at https://github.com/cython/cython/issues/2019


---

Comment by jdemeyer created at 2017-11-25 09:23:44

Replying to [comment:7 rws]:
> {{{
> class A(SageObject):
>     def __init__(self):
>         from sage.symbolic.ring import SR
>         self._parent = SR
>     def __eq__(a, b):
>         print(a, b)
>         return True
>     def __repr__(self):
>         return "A"
> 
> class B(A):
>     def __eq__(a, b):
>         print(a, b)
>         return True
>     def __repr__(self):
>         return "B"
> 
> sage: from sage.symbolic.tests import A,B
> sage: A() == B()
> (B, A)
> True
> 
> versus
> 
> class A():
>     def __init__(self):
>         from sage.symbolic.ring import SR
>         self._parent = SR
>     def __eq__(a, b):
>         print(a, b)
>         return True
>     def __repr__(self):
>         return "A"
> 
> class B(A):
>     def __eq__(a, b):
>         print(a, b)
>         return True
>     def __repr__(self):
>         return "B"
> 
> sage: from sage.symbolic.tests import A,B
> sage: A() == B()
> (A, B)
> True
> }}}

I think this is just a difference between new-style and old-style classes. This has nothing to do with Cython.


---

Comment by jdemeyer created at 2017-11-25 09:25:27

Without any Cython classes involved:

```
sage: class A(object):
....:     def __eq__(a, b):
....:         print(a, b)
....:         return True
....:     def __repr__(self):
....:         return "A"
....: 
....: class B(A):
....:     def __eq__(a, b):
....:         print(a, b)
....:         return True
....:     def __repr__(self):
....:         return "B"
sage: A() == B()
(B, A)
True
```



---

Comment by rws created at 2017-11-25 13:45:30

Why then would `class A():` not switch arguments? Anyway, this ticket either should warn if subclasses are encountered or at least add explanations to the documentation.


---

Comment by rws created at 2017-11-25 13:51:06

Replying to [comment:13 rws]:
> Why then would `class A():` not switch arguments? Anyway, this ticket either should warn if subclasses are encountered or at least add explanations to the documentation.

Okay the answer is https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python and Python is a PITA.
