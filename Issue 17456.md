# Issue 17456: mutable poset: a data structure for asymptotic expressions

archive/issues_017456.json:
```json
{
    "body": "CC:  @behackl @cheuberg @jm58660\n\nKeywords: asymptotics\n\nThe aim of this ticket is to implement a data structure which is to be used within an asymptotic expression (see Meta-Ticket #17601). This mutable poset stores elements together with its successors and predecessors. Those data is updated when a new element is inserted or an element is removed. It offers a couple of efficient routines for manipulations (all of which will be needed for the asymptotic expression).\n\nIssue created by migration from https://trac.sagemath.org/ticket/17693\n\n",
    "closed_at": "2015-10-12T07:16:42Z",
    "created_at": "2015-01-30T08:37:22Z",
    "labels": [
        "component: asymptotic expansions"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.9",
    "title": "mutable poset: a data structure for asymptotic expressions",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17456",
    "user": "https://github.com/dkrenn"
}
```
CC:  @behackl @cheuberg @jm58660

Keywords: asymptotics

The aim of this ticket is to implement a data structure which is to be used within an asymptotic expression (see Meta-Ticket #17601). This mutable poset stores elements together with its successors and predecessors. Those data is updated when a new element is inserted or an element is removed. It offers a couple of efficient routines for manipulations (all of which will be needed for the asymptotic expression).

Issue created by migration from https://trac.sagemath.org/ticket/17693





---

archive/issue_comments_232922.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2015-01-30T08:44:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232922",
    "user": "https://github.com/dkrenn"
}
```

Last 10 new commits:



---

archive/issue_comments_232923.json:
```json
{
    "body": "A mutable poset class should be stored in `sage.combinat.posets`.\n\nNathann",
    "created_at": "2015-01-30T10:58:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232923",
    "user": "https://github.com/nathanncohen"
}
```

A mutable poset class should be stored in `sage.combinat.posets`.

Nathann



---

archive/issue_comments_232924.json:
```json
{
    "body": "This series of comments are the result of an email discussion. Its aim is to give a better understanding of the needs of the data structure used in an asymptotic expression.\n\nAn example of an asymptotic expression in say 2 variables (n->oo, t->oo) is\n\n```\nA = n^3*t^2 + 42*n^2*t^2 + 3*n*t^4 + O(t)\n```\nThis is stored in the mutable poset in the following way: the elements of the poset are exactly the summands of the expression above. This means\n\n```\nsage: A.data  # or however this may be called\nposet(n^3*t^2, 42*n^2*t^2, 3*n*t^4, O(t))\n```\n\nThe growth of these summands is partially ordered:\na) `n<sup>3*t</sup>2 >= n<sup>2*t</sup>2`\nb) `n<sup>3*t</sup>2 >= t`\nc) `n<sup>2*t</sup>2 >= t`\nd) `n*t^4 >= t`\nThe mutable poset stores/caches the direct successors/predecessors, i.e., only the relations a), c), d), but not b), since this follows by transitivity out of a) and c). Thus, for the example above, we have the following information stored\n\n```\nposet\n- term O(t)\n  successors: n^3*t^2, 42*n^2*t^2, 3*n*t^4\n  no predecessors\n- term 3*n*t^4\n  no successors\n  predecessors: O(t)\n- term 42*n^2*t^2\n  successors: n^3*t^2\n  predecessors: O(t)\n- term n^3*t^2\n  no successors\n  predecessors: 42*n^2*t^2\n```",
    "created_at": "2015-02-02T17:40:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232924",
    "user": "https://github.com/dkrenn"
}
```

This series of comments are the result of an email discussion. Its aim is to give a better understanding of the needs of the data structure used in an asymptotic expression.

An example of an asymptotic expression in say 2 variables (n->oo, t->oo) is

```
A = n^3*t^2 + 42*n^2*t^2 + 3*n*t^4 + O(t)
```
This is stored in the mutable poset in the following way: the elements of the poset are exactly the summands of the expression above. This means

```
sage: A.data  # or however this may be called
poset(n^3*t^2, 42*n^2*t^2, 3*n*t^4, O(t))
```

The growth of these summands is partially ordered:
a) `n<sup>3*t</sup>2 >= n<sup>2*t</sup>2`
b) `n<sup>3*t</sup>2 >= t`
c) `n<sup>2*t</sup>2 >= t`
d) `n*t^4 >= t`
The mutable poset stores/caches the direct successors/predecessors, i.e., only the relations a), c), d), but not b), since this follows by transitivity out of a) and c). Thus, for the example above, we have the following information stored

```
poset
- term O(t)
  successors: n^3*t^2, 42*n^2*t^2, 3*n*t^4
  no predecessors
- term 3*n*t^4
  no successors
  predecessors: O(t)
- term 42*n^2*t^2
  successors: n^3*t^2
  predecessors: O(t)
- term n^3*t^2
  no successors
  predecessors: 42*n^2*t^2
```



---

archive/issue_comments_232925.json:
```json
{
    "body": "We want to perform arithmetic with asymptotic expressions, in particular we need to do efficiently:\n1) addition (and multiplication)\n2) merging/absorbing terms, e.g.\n\n```\nn^4 + 2*n^2 + 3*n + O(1) + O(n^2) = n^4 + O(n^2)\n```\nor\n\n```\nO(n*t) + n + t = O(n*t)\n```\n3) removing elements of the poset, because of 2)\n\nTo make them efficent, we store successors and predecessors of each element in the poset. These are updated when inserting/removing elements.\n\nNote that an asymptotic expression can contain several O-terms, e.g.\n\n```\nO(n^3 t^2) + O(n^4 t^1) + O(n^2 t^3)\n```\nis a valid expression. In the poset each O-term is a minimal\nelement and they are all pairwise incomparable (thus, the O terms\nwill be an antichain in the poset). Anyhow, non-O-terms be be\ncompareable to other elements, e.g. in\n\n```\n3*n*t + O(n) + O(t)\n```\nwe have `n*t >= n` and `n*t >= t`.\n\nWe also need to deal with situations where we want to insert an\nelement of the same growth: E.g. `4n+3n = 7n`, `4n+O(n) = O(n)`,\nthus, the elements themselves can change during addition. When\nmerging/absorbing and working with O-Terms with explicit\nO-constants, this also occurrs frequently (even with terms of\ndifferent growth).",
    "created_at": "2015-02-02T17:41:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232925",
    "user": "https://github.com/dkrenn"
}
```

We want to perform arithmetic with asymptotic expressions, in particular we need to do efficiently:
1) addition (and multiplication)
2) merging/absorbing terms, e.g.

```
n^4 + 2*n^2 + 3*n + O(1) + O(n^2) = n^4 + O(n^2)
```
or

```
O(n*t) + n + t = O(n*t)
```
3) removing elements of the poset, because of 2)

To make them efficent, we store successors and predecessors of each element in the poset. These are updated when inserting/removing elements.

Note that an asymptotic expression can contain several O-terms, e.g.

```
O(n^3 t^2) + O(n^4 t^1) + O(n^2 t^3)
```
is a valid expression. In the poset each O-term is a minimal
element and they are all pairwise incomparable (thus, the O terms
will be an antichain in the poset). Anyhow, non-O-terms be be
compareable to other elements, e.g. in

```
3*n*t + O(n) + O(t)
```
we have `n*t >= n` and `n*t >= t`.

We also need to deal with situations where we want to insert an
element of the same growth: E.g. `4n+3n = 7n`, `4n+O(n) = O(n)`,
thus, the elements themselves can change during addition. When
merging/absorbing and working with O-Terms with explicit
O-constants, this also occurrs frequently (even with terms of
different growth).



---

archive/issue_comments_232926.json:
```json
{
    "body": "Note that all the terms (individual summands) support one\noperation, namely these can be multiplied, maybe coercion is\nused, e.g.\n\n```\n4*n^2*t * O(n) --> O(n^2*t) * O(n) --> O(n^3*t)\n```\nThus we have monoids here. \"Addition\" of terms is more complicated\nsince not always possible. E.g.\n\n```\nn + O(t) = n + O(t)\n```\nBut since this is an operation we want to have, the data\nstructure has to take this into consideration.\n\nHere an example of the addition of two asymptotic expressions, to\nsee what the poset should do:\n\n```\nB = n^2*t + n + O(1)\nC = n*t^2 + O(n)\n```\nSteps in computing B + C:\n\n1) calculate: B.poset union C.poset\nThis gives\n\n```\nposet(n^2*t, n, O(1), n*t^2, O(n)).\n```\n\n2) simplify: returns \n\n```\nposet(n^2*t, n*t^2, O(n))\n```\nTo achieve this, we have to search for what can be \"absorbed\" by the\nO-term `O(n)`. These are exactly all the predecessors of `O(n)` (not only\nthe direct, but also the predecessors of the predecessors...)\nThus some kind of caching of predecessors is necessary, but \"cache\"\nhas to be updated when modifying the poset.\n\nNote that this data structure does a preprocessing of its relations, which is definitely good for nonsmall instances. At the moment this class should provide an interface for the needed routines. A fine tuning (w.r.t. speed optimization for various sizes) can be done later (if the performance is too bad).\n\nTo conclude, the data structure needed in an asymptotic expression needs to deal with dynamic changes (mutability) and do some caching to provide efficient methods. And it needs to do more than a poset which is made mutable. In particular, it has to provide the methods for the above mentioned merging and absorbing.",
    "created_at": "2015-02-02T17:41:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232926",
    "user": "https://github.com/dkrenn"
}
```

Note that all the terms (individual summands) support one
operation, namely these can be multiplied, maybe coercion is
used, e.g.

```
4*n^2*t * O(n) --> O(n^2*t) * O(n) --> O(n^3*t)
```
Thus we have monoids here. "Addition" of terms is more complicated
since not always possible. E.g.

```
n + O(t) = n + O(t)
```
But since this is an operation we want to have, the data
structure has to take this into consideration.

Here an example of the addition of two asymptotic expressions, to
see what the poset should do:

```
B = n^2*t + n + O(1)
C = n*t^2 + O(n)
```
Steps in computing B + C:

1) calculate: B.poset union C.poset
This gives

```
poset(n^2*t, n, O(1), n*t^2, O(n)).
```

2) simplify: returns 

```
poset(n^2*t, n*t^2, O(n))
```
To achieve this, we have to search for what can be "absorbed" by the
O-term `O(n)`. These are exactly all the predecessors of `O(n)` (not only
the direct, but also the predecessors of the predecessors...)
Thus some kind of caching of predecessors is necessary, but "cache"
has to be updated when modifying the poset.

Note that this data structure does a preprocessing of its relations, which is definitely good for nonsmall instances. At the moment this class should provide an interface for the needed routines. A fine tuning (w.r.t. speed optimization for various sizes) can be done later (if the performance is too bad).

To conclude, the data structure needed in an asymptotic expression needs to deal with dynamic changes (mutability) and do some caching to provide efficient methods. And it needs to do more than a poset which is made mutable. In particular, it has to provide the methods for the above mentioned merging and absorbing.



---

archive/issue_comments_232927.json:
```json
{
    "body": "Replying to [comment:3 ncohen]:\n> A mutable poset class should be stored in `sage.combinat.posets`.\n\n\nThis class has nothing to do with combinatorics, therefore I am against `sage.combinat`. And it implements a data structure and we have `sage.data_structures`, so it seems the right place.",
    "created_at": "2015-02-02T17:44:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232927",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:3 ncohen]:
> A mutable poset class should be stored in `sage.combinat.posets`.


This class has nothing to do with combinatorics, therefore I am against `sage.combinat`. And it implements a data structure and we have `sage.data_structures`, so it seems the right place.



---

archive/issue_comments_232928.json:
```json
{
    "body": "> This class has nothing to do with combinatorics, therefore I am against `sage.combinat`. And it implements a data structure and we have `sage.data_structures`, so it seems the right place.\n\n\nGraphs are a data structure, they are in graphs/. Incidence Structures are data structure, and they are in combinat/designs. Matrices are a data structure, and they are in matrix/. Posets and Hasse Diagrams are a data structure, and they are in combinat/posets/.\n\nAlso, you wrote in your branch a 'todo note' to implement in your `MutablePoset` data structure that 20+ methods from the current Posets should be implemented for your new class: the proper way to do that would be to inherit them from posets.\n\nCould you also explain what \"shells\" are, and how they differ from the 'facade' boolean argument of Posets ?\n\nThanks,\n\nNathann",
    "created_at": "2015-02-02T19:02:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232928",
    "user": "https://github.com/nathanncohen"
}
```

> This class has nothing to do with combinatorics, therefore I am against `sage.combinat`. And it implements a data structure and we have `sage.data_structures`, so it seems the right place.


Graphs are a data structure, they are in graphs/. Incidence Structures are data structure, and they are in combinat/designs. Matrices are a data structure, and they are in matrix/. Posets and Hasse Diagrams are a data structure, and they are in combinat/posets/.

Also, you wrote in your branch a 'todo note' to implement in your `MutablePoset` data structure that 20+ methods from the current Posets should be implemented for your new class: the proper way to do that would be to inherit them from posets.

Could you also explain what "shells" are, and how they differ from the 'facade' boolean argument of Posets ?

Thanks,

Nathann



---

archive/issue_comments_232929.json:
```json
{
    "body": "Replying to [comment:8 ncohen]:\n> Also, you wrote in your branch a 'todo note' to implement in your `MutablePoset` data structure that 20+ methods from the current Posets should be implemented for your new class: the proper way to do that would be to inherit them from posets.\n\n\nA `FinitePoset` inherits from `Parent` and my understanding is that parents must be immutable.\nThus, IMHO, this mutable poset here should not inherit from `FinitePoset`.",
    "created_at": "2015-02-03T07:30:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232929",
    "user": "https://github.com/cheuberg"
}
```

Replying to [comment:8 ncohen]:
> Also, you wrote in your branch a 'todo note' to implement in your `MutablePoset` data structure that 20+ methods from the current Posets should be implemented for your new class: the proper way to do that would be to inherit them from posets.


A `FinitePoset` inherits from `Parent` and my understanding is that parents must be immutable.
Thus, IMHO, this mutable poset here should not inherit from `FinitePoset`.



---

archive/issue_comments_232930.json:
```json
{
    "body": "> A `FinitePoset` inherits from `Parent` and my understanding is that parents must be immutable.\n\n\nIndeed, but it may actually be time to change that. We are also having problem with this, because apparently the construction of `Parent/UniqueRepresentation` instances is known to be very slow, and you \"should not build too many of them at once\" or it will slow code down a lot.\n\nThat is what is already preventing us from implementing a proper iterator over all non-isomorphic posets of a given size: this operation creates too many parents and is the bottleneck in the computations.\n\nIf it seems that you are bothered by the same thing, it gives all the more reasons to make that change.\n\nNathann",
    "created_at": "2015-02-03T07:55:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232930",
    "user": "https://github.com/nathanncohen"
}
```

> A `FinitePoset` inherits from `Parent` and my understanding is that parents must be immutable.


Indeed, but it may actually be time to change that. We are also having problem with this, because apparently the construction of `Parent/UniqueRepresentation` instances is known to be very slow, and you "should not build too many of them at once" or it will slow code down a lot.

That is what is already preventing us from implementing a proper iterator over all non-isomorphic posets of a given size: this operation creates too many parents and is the bottleneck in the computations.

If it seems that you are bothered by the same thing, it gives all the more reasons to make that change.

Nathann



---

archive/issue_comments_232931.json:
```json
{
    "body": "Replying to [comment:8 ncohen]:\n> Could you also explain what \"shells\" are, and how they differ from the 'facade' boolean argument of Posets ?\n\n\nThere are similarities between shells and facades, but a facade is something in Sage that represent other things and again uses parents/elements (thus immutable). It has well-defined properties and there is even a category for facade sets.\nThe shells in the mutable poset are more like a container for the elements. Ideally a user of the poset does not need them at all (and only a few MutablePoset-methods use them). They are only used inside the poset-algorithms.\nAt one point I thought about making shells and the related methods private, but never did this...",
    "created_at": "2015-02-05T08:16:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232931",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:8 ncohen]:
> Could you also explain what "shells" are, and how they differ from the 'facade' boolean argument of Posets ?


There are similarities between shells and facades, but a facade is something in Sage that represent other things and again uses parents/elements (thus immutable). It has well-defined properties and there is even a category for facade sets.
The shells in the mutable poset are more like a container for the elements. Ideally a user of the poset does not need them at all (and only a few MutablePoset-methods use them). They are only used inside the poset-algorithms.
At one point I thought about making shells and the related methods private, but never did this...



---

archive/issue_comments_232932.json:
```json
{
    "body": "Replying to [comment:8 ncohen]:\n> Graphs are a data structure\n\nNo, graphs are mathematical objects. \"a binary symmetric matrix implemented using bitsets\" (which could be used for dense graphs) is a data structure.",
    "created_at": "2015-02-05T10:04:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232932",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:8 ncohen]:
> Graphs are a data structure

No, graphs are mathematical objects. "a binary symmetric matrix implemented using bitsets" (which could be used for dense graphs) is a data structure.



---

archive/issue_comments_232933.json:
```json
{
    "body": "> > Graphs are a data structure\n\n> No, graphs are mathematical objects.\n\nI was not thinking of a graph as it is defined in a book, but of Sage's graphs. I should have said \"the Graph class\" probably.\n\nNathann",
    "created_at": "2015-02-05T10:12:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232933",
    "user": "https://github.com/nathanncohen"
}
```

> > Graphs are a data structure

> No, graphs are mathematical objects.

I was not thinking of a graph as it is defined in a book, but of Sage's graphs. I should have said "the Graph class" probably.

Nathann



---

archive/issue_comments_232934.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2015-07-28T18:44:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232934",
    "user": "https://github.com/dkrenn"
}
```

Last 10 new commits:



---

archive/issue_comments_232935.json:
```json
{
    "body": "If `union()` does same thing as `disjoint_union()` in posets and in graphs, please change name accordingly. It seems unnecessary to have `INPUT`-part at all, if the function has no arguments at all.\n\nJust my two cents. I would give three, if I would have more time.",
    "created_at": "2015-07-28T20:30:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232935",
    "user": "https://github.com/jm58660"
}
```

If `union()` does same thing as `disjoint_union()` in posets and in graphs, please change name accordingly. It seems unnecessary to have `INPUT`-part at all, if the function has no arguments at all.

Just my two cents. I would give three, if I would have more time.



---

archive/issue_comments_232936.json:
```json
{
    "body": "Replying to [comment:15 jmantysalo]:\n> If `union()` does same thing as `disjoint_union()` in posets and in graphs, please change name accordingly.\n\n\nNo, it does not do the same. Union takes only one instance of equal elements, whereas disjoint_union makes each one of the equal elements distinct.\n\n> It seems unnecessary to have `INPUT`-part at all, if the function has no arguments at all.\n\n\nThe developer guide\n\n    http://doc.sagemath.org/html/en/developer/coding_basics.html#documentation-strings\n\nsays\n\n    An INPUT and an OUTPUT block describing the input/output of the function. This is not optional.\n\nTherefore skipping one of these blocks seems to be against the rules (and hopefully helps avoiding the confusion of a missing input block).\n\n> Just my two cents. I would give three, if I would have more time.\n\n\nMany thanks for all your cents.\n\nBest, Daniel",
    "created_at": "2015-07-29T05:56:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232936",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:15 jmantysalo]:
> If `union()` does same thing as `disjoint_union()` in posets and in graphs, please change name accordingly.


No, it does not do the same. Union takes only one instance of equal elements, whereas disjoint_union makes each one of the equal elements distinct.

> It seems unnecessary to have `INPUT`-part at all, if the function has no arguments at all.


The developer guide

    http://doc.sagemath.org/html/en/developer/coding_basics.html#documentation-strings

says

    An INPUT and an OUTPUT block describing the input/output of the function. This is not optional.

Therefore skipping one of these blocks seems to be against the rules (and hopefully helps avoiding the confusion of a missing input block).

> Just my two cents. I would give three, if I would have more time.


Many thanks for all your cents.

Best, Daniel



---

archive/issue_comments_232937.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-07-29T08:57:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232937",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_232938.json:
```json
{
    "body": "Replying to [comment:16 dkrenn]:\n> Replying to [comment:15 jmantysalo]:\n> > If `union()` does same thing as `disjoint_union()` in posets and in graphs - -\n\n\n> No, it does not do the same.\n\n\nOK.\n \n> > It seems unnecessary to have `INPUT`-part at all, if the function has no arguments at all.\n\n> \n> The developer guide says\n> \n>     An INPUT and an OUTPUT block describing the input/output of the function. This is not optional.\n\n\nTrue. But I don't think if it has been thinked that \"no input\" must be documented. Is it in other places? Or should this part of developer guide be changed?\n\nAnd should for example docstring of `.cardinality()` really contain `OUTPUT`-block saying that output type is sage's `Integer`?",
    "created_at": "2015-07-29T20:27:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232938",
    "user": "https://github.com/jm58660"
}
```

Replying to [comment:16 dkrenn]:
> Replying to [comment:15 jmantysalo]:
> > If `union()` does same thing as `disjoint_union()` in posets and in graphs - -


> No, it does not do the same.


OK.
 
> > It seems unnecessary to have `INPUT`-part at all, if the function has no arguments at all.

> 
> The developer guide says
> 
>     An INPUT and an OUTPUT block describing the input/output of the function. This is not optional.


True. But I don't think if it has been thinked that "no input" must be documented. Is it in other places? Or should this part of developer guide be changed?

And should for example docstring of `.cardinality()` really contain `OUTPUT`-block saying that output type is sage's `Integer`?



---

archive/issue_comments_232939.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-08-18T12:04:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232939",
    "user": "https://github.com/dkrenn"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_232940.json:
```json
{
    "body": "Replying to [comment:18 jmantysalo]:\n> > The developer guide says\n> > \n> >     An INPUT and an OUTPUT block describing the input/output of the function. This is not optional.\n\n> \n> True. But I don't think if it has been thinked that \"no input\" must be documented. Is it in other places? Or should this part of developer guide be changed?\n\n\nI would keep it. (At the moment) the developer guide says to include it and I find it very nice to have constistent docstrings starting with one-liner, INPUT, OUTPUT, more details, EXAMPLES, ...\n\n(And: there are other places.)\n\n> And should for example docstring of `.cardinality()` really contain `OUTPUT`-block saying that output type is sage's `Integer`?\n\n\nWhat do you suggest?",
    "created_at": "2015-08-18T12:10:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232940",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:18 jmantysalo]:
> > The developer guide says
> > 
> >     An INPUT and an OUTPUT block describing the input/output of the function. This is not optional.

> 
> True. But I don't think if it has been thinked that "no input" must be documented. Is it in other places? Or should this part of developer guide be changed?


I would keep it. (At the moment) the developer guide says to include it and I find it very nice to have constistent docstrings starting with one-liner, INPUT, OUTPUT, more details, EXAMPLES, ...

(And: there are other places.)

> And should for example docstring of `.cardinality()` really contain `OUTPUT`-block saying that output type is sage's `Integer`?


What do you suggest?



---

archive/issue_comments_232941.json:
```json
{
    "body": "Replying to [comment:20 dkrenn]:\n> Replying to [comment:18 jmantysalo]:\n> > > The developer guide says\n> > > \n> > >     An INPUT and an OUTPUT block describing the input/output of the function. This is not optional.\n\n> > \n> > True. But I don't think if it has been thinked that \"no input\" must be documented. Is it in other places? Or should this part of developer guide be changed?\n  \n> \n> I would keep it. (At the moment) the developer guide says to include it and I find it very nice to have constistent docstrings starting with one-liner, INPUT, OUTPUT, more details, EXAMPLES, ...\n\n\nThis is discussed at #19041. But don't let this stop coding -- Sage will propably never get finished so that questions like this would have The Final Answer.\n\n> > And should for example docstring of `.cardinality()` really contain `OUTPUT`-block saying that output type is sage's `Integer`?\n\n> \n> What do you suggest?\n\n\nEvery `cardinality()` should return `Integer`. For other integer-valued functions there were discussion about `int` vs. `Integer` without consensus.\n\nI don't know. For input it is explicitly said that the docstring can say \"x in integer\", not \"x must be `Integer` or `int`\". These are hard questions, as what is \"clear\" varies from one person to other.",
    "created_at": "2015-08-18T12:21:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232941",
    "user": "https://github.com/jm58660"
}
```

Replying to [comment:20 dkrenn]:
> Replying to [comment:18 jmantysalo]:
> > > The developer guide says
> > > 
> > >     An INPUT and an OUTPUT block describing the input/output of the function. This is not optional.

> > 
> > True. But I don't think if it has been thinked that "no input" must be documented. Is it in other places? Or should this part of developer guide be changed?
  
> 
> I would keep it. (At the moment) the developer guide says to include it and I find it very nice to have constistent docstrings starting with one-liner, INPUT, OUTPUT, more details, EXAMPLES, ...


This is discussed at #19041. But don't let this stop coding -- Sage will propably never get finished so that questions like this would have The Final Answer.

> > And should for example docstring of `.cardinality()` really contain `OUTPUT`-block saying that output type is sage's `Integer`?

> 
> What do you suggest?


Every `cardinality()` should return `Integer`. For other integer-valued functions there were discussion about `int` vs. `Integer` without consensus.

I don't know. For input it is explicitly said that the docstring can say "x in integer", not "x must be `Integer` or `int`". These are hard questions, as what is "clear" varies from one person to other.



---

archive/issue_comments_232942.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-08-28T14:11:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232942",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_232943.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2015-08-28T14:12:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232943",
    "user": "https://github.com/dkrenn"
}
```

Last 10 new commits:



---

archive/issue_comments_232944.json:
```json
{
    "body": "Changing component from misc to asymptotic expansions.",
    "created_at": "2015-09-15T17:27:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232944",
    "user": "https://github.com/dkrenn"
}
```

Changing component from misc to asymptotic expansions.



---

archive/issue_comments_232945.json:
```json
{
    "body": "Hello!\n\nI reviewed this ticket, and here are my comments:\n\n- `MutablePoset`, `MutablePosetShell`: derived from `object` vs. `SageObject`?\n- `is_null`, `is_oo`: is there some usecase for the `reverse` keyword? For `predecessor` and `successor`: this is clear, as it makes the code easier. However, I think that a `reverse`-keyword for `is_null` and `is_oo` is rather irritating.\n- doctests for `MutablePosetShell.le`: shouldn't doctests like `elem1 <= elem2` be marked as indirect?\n- `MutablePosetShell._copy_all_linked_`: 1st sentence should be a short description. Likewise for `MutablePosetShell._iter_depth_first_visit_` and `MutablePosetShell._iter_topological_visit_`.\n- sorted_set_by_tuple, is_MutablePoset: are these functions really necessary? Both are only used once within the whole file. The occurrence of `sorted_set_by_tuple` can be easily replaced by\n\n```\n[...].join(repr(e) for e in sortedshells if e in shell.successors(rev))\n```\nand the occurrence of `is_MutablePoset` can be replaced by a simple `isinstance`-call.\n- `MutablePoset.shells`: I do not understand the usecase of the `reverse` keyword. Can it be removed?\n- `MutablePoset.add`: I think that a comment (in the code) that roughly explains what the passage beginning with  `for reverse in (False, True):` does would be nice. It took me quite some time to understand and verify the functionality of this block.\n- `MutablePoset.discard`: why isn't this simply an alias of `MutablePoset.remove`? As `remove` has no return value, `discard` cannot have one either, if that was the intention.\n- Is there a particular reason for naming the parameters for all the set operations like `MutablePoset.union`, `MutablePoset.difference` etc. `left` and `right`, instead of `self` and `other`? IMHO, this disguises that the function can be called as `P.union(Q)`.\n- Regarding all set operations: currently, it is **not** clear from the documentation that all set operations are performed on the set of keys. This causes something like\n\n```\nsage: PR.<x> = ZZ[]\nsage: P = MutablePoset(key=lambda k: len(k.list()))\nsage: P.add(42*x)\nsage: P.add(21*x^2)\nsage: Q = MutablePoset(key=lambda k: len(k.list()))\nsage: Q.add(1111*x)\nsage: P, Q\n(poset(42*x, 21*x^2), poset(1111*x))\nsage: Q.is_subset(P)\nTrue\nsage: Q.union(P)\nposet(1111*x, 21*x^2)\n```\nand so on. In principle, I don't see this as a problem---however, I'd state this explicitly in each of these set operation functions. \n- `MutablePoset.mapped`: why is this function needed? Purely for semantical reasons? I'd move the doctests to `MutablePoset.copy`.\n- `MutablePosetShell._copy_all_linked_`: is the memoization using the `id` of the object a standard procedure? I thought about it, but I'm not entirely sure that this isn't a potential error source.\n\nSide note: the `MutablePoset` is the central data structure in our AsymptoticExpansions framework (cf. #17601). In this context, the functionality has been tested extensively--and some peculiarities (like the `map`-function etc.) are motivated by this application.\n\nAlso, I've made a few reviewer commits concerning the documentation; the branch is attached.\n\nAs soon as the points I've raised in the comments above are discussed, this would be a `positive_review` from my side.\n\nBenjamin\n\n---\nLast 10 new commits:",
    "created_at": "2015-09-19T17:10:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232945",
    "user": "https://github.com/behackl"
}
```

Hello!

I reviewed this ticket, and here are my comments:

- `MutablePoset`, `MutablePosetShell`: derived from `object` vs. `SageObject`?
- `is_null`, `is_oo`: is there some usecase for the `reverse` keyword? For `predecessor` and `successor`: this is clear, as it makes the code easier. However, I think that a `reverse`-keyword for `is_null` and `is_oo` is rather irritating.
- doctests for `MutablePosetShell.le`: shouldn't doctests like `elem1 <= elem2` be marked as indirect?
- `MutablePosetShell._copy_all_linked_`: 1st sentence should be a short description. Likewise for `MutablePosetShell._iter_depth_first_visit_` and `MutablePosetShell._iter_topological_visit_`.
- sorted_set_by_tuple, is_MutablePoset: are these functions really necessary? Both are only used once within the whole file. The occurrence of `sorted_set_by_tuple` can be easily replaced by

```
[...].join(repr(e) for e in sortedshells if e in shell.successors(rev))
```
and the occurrence of `is_MutablePoset` can be replaced by a simple `isinstance`-call.
- `MutablePoset.shells`: I do not understand the usecase of the `reverse` keyword. Can it be removed?
- `MutablePoset.add`: I think that a comment (in the code) that roughly explains what the passage beginning with  `for reverse in (False, True):` does would be nice. It took me quite some time to understand and verify the functionality of this block.
- `MutablePoset.discard`: why isn't this simply an alias of `MutablePoset.remove`? As `remove` has no return value, `discard` cannot have one either, if that was the intention.
- Is there a particular reason for naming the parameters for all the set operations like `MutablePoset.union`, `MutablePoset.difference` etc. `left` and `right`, instead of `self` and `other`? IMHO, this disguises that the function can be called as `P.union(Q)`.
- Regarding all set operations: currently, it is **not** clear from the documentation that all set operations are performed on the set of keys. This causes something like

```
sage: PR.<x> = ZZ[]
sage: P = MutablePoset(key=lambda k: len(k.list()))
sage: P.add(42*x)
sage: P.add(21*x^2)
sage: Q = MutablePoset(key=lambda k: len(k.list()))
sage: Q.add(1111*x)
sage: P, Q
(poset(42*x, 21*x^2), poset(1111*x))
sage: Q.is_subset(P)
True
sage: Q.union(P)
poset(1111*x, 21*x^2)
```
and so on. In principle, I don't see this as a problem---however, I'd state this explicitly in each of these set operation functions. 
- `MutablePoset.mapped`: why is this function needed? Purely for semantical reasons? I'd move the doctests to `MutablePoset.copy`.
- `MutablePosetShell._copy_all_linked_`: is the memoization using the `id` of the object a standard procedure? I thought about it, but I'm not entirely sure that this isn't a potential error source.

Side note: the `MutablePoset` is the central data structure in our AsymptoticExpansions framework (cf. #17601). In this context, the functionality has been tested extensively--and some peculiarities (like the `map`-function etc.) are motivated by this application.

Also, I've made a few reviewer commits concerning the documentation; the branch is attached.

As soon as the points I've raised in the comments above are discussed, this would be a `positive_review` from my side.

Benjamin

---
Last 10 new commits:



---

archive/issue_comments_232946.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-19T17:10:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232946",
    "user": "https://github.com/behackl"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_232947.json:
```json
{
    "body": "Benjamin, please put your name to reviewers-field. Otherwise Volker will reject this.",
    "created_at": "2015-09-19T19:05:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232947",
    "user": "https://github.com/jm58660"
}
```

Benjamin, please put your name to reviewers-field. Otherwise Volker will reject this.



---

archive/issue_comments_232948.json:
```json
{
    "body": "Thanks for the reminder, Jori!\n\nBenjamin",
    "created_at": "2015-09-19T19:13:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232948",
    "user": "https://github.com/behackl"
}
```

Thanks for the reminder, Jori!

Benjamin



---

archive/issue_comments_232949.json:
```json
{
    "body": "Replying to [comment:25 behackl]:\n> - `MutablePoset`, `MutablePosetShell`: derived from `object` vs. `SageObject`?\n\n\n`object`.\n\n> - `is_null`, `is_oo`: is there some usecase for the `reverse` keyword? For `predecessor` and `successor`: this is clear, as it makes the code easier. However, I think that a `reverse`-keyword for `is_null` and `is_oo` is rather irritating.\n\n\nKeyword deleted.\n\n> - doctests for `MutablePosetShell.le`: shouldn't doctests like `elem1 <= elem2` be marked as indirect?\n\n\nYes, I've marked them.\n\n> - `MutablePosetShell._copy_all_linked_`: 1st sentence should be a short description. Likewise for `MutablePosetShell._iter_depth_first_visit_` and `MutablePosetShell._iter_topological_visit_`.\n\n\nRewritten.\n\n> - sorted_set_by_tuple, is_MutablePoset: are these functions really necessary? Both are only used once within the whole file. The occurrence of `sorted_set_by_tuple` can be easily replaced by\n> \n> ```\n> [...].join(repr(e) for e in sortedshells if e in shell.successors(rev))\n> ```\n> and the occurrence of `is_MutablePoset` can be replaced by a simple `isinstance`-call.\n\n\n`sorted_set_by_tuple`: Deleted and replaced.\n`is_MutablePoset`: seems to be a standard convention to use it in Sage; see a lot of other modules.\n\n> - `MutablePoset.shells`: I do not understand the usecase of the `reverse` keyword. Can it be removed?\n\n\nI agree; deleted.\n\n> - `MutablePoset.add`: I think that a comment (in the code) that roughly explains what the passage beginning with  `for reverse in (False, True):` does would be nice. It took me quite some time to understand and verify the functionality of this block.\n\n\nI've added a comment.\n\n> - `MutablePoset.discard`: why isn't this simply an alias of `MutablePoset.remove`? As `remove` has no return value, `discard` cannot have one either, if that was the intention.\n\n\nSee Python's set (the same behavior there).\n\n> - Is there a particular reason for naming the parameters for all the set operations like `MutablePoset.union`, `MutablePoset.difference` etc. `left` and `right`, instead of `self` and `other`? IMHO, this disguises that the function can be called as `P.union(Q)`.\n\n\nChanged all to self/other.\n\n> - Regarding all set operations: currently, it is **not** clear from the documentation that all set operations are performed on the set of keys. This causes something like\n> \n> ```\n> sage: PR.<x> = ZZ[]\n> sage: P = MutablePoset(key=lambda k: len(k.list()))\n> sage: P.add(42*x)\n> sage: P.add(21*x^2)\n> sage: Q = MutablePoset(key=lambda k: len(k.list()))\n> sage: Q.add(1111*x)\n> sage: P, Q\n> (poset(42*x, 21*x^2), poset(1111*x))\n> sage: Q.is_subset(P)\n> True\n> sage: Q.union(P)\n> poset(1111*x, 21*x^2)\n> ```\n> and so on. In principle, I don't see this as a problem---however, I'd state this explicitly in each of these set operation functions.\n\n\nI've added a note in all these functions.\n\n> - `MutablePoset.mapped`: why is this function needed? Purely for semantical reasons? I'd move the doctests to `MutablePoset.copy`.\n\n\nIt is a shortcut for using copy with the mapping argument (since this is a non-standard argument for a copy method, including a separate method with an approriate name seems to be a good choice)\n\n> - `MutablePosetShell._copy_all_linked_`: is the memoization using the `id` of the object a standard procedure? I thought about it, but I'm not entirely sure that this isn't a potential error source.\n\n\nYes it is standard; see (all) deepcopy routines.\n\n> Also, I've made a few reviewer commits concerning the documentation; the branch is attached.\n\n\nCross-reviewed. Thanks.",
    "created_at": "2015-09-21T16:01:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232949",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:25 behackl]:
> - `MutablePoset`, `MutablePosetShell`: derived from `object` vs. `SageObject`?


`object`.

> - `is_null`, `is_oo`: is there some usecase for the `reverse` keyword? For `predecessor` and `successor`: this is clear, as it makes the code easier. However, I think that a `reverse`-keyword for `is_null` and `is_oo` is rather irritating.


Keyword deleted.

> - doctests for `MutablePosetShell.le`: shouldn't doctests like `elem1 <= elem2` be marked as indirect?


Yes, I've marked them.

> - `MutablePosetShell._copy_all_linked_`: 1st sentence should be a short description. Likewise for `MutablePosetShell._iter_depth_first_visit_` and `MutablePosetShell._iter_topological_visit_`.


Rewritten.

> - sorted_set_by_tuple, is_MutablePoset: are these functions really necessary? Both are only used once within the whole file. The occurrence of `sorted_set_by_tuple` can be easily replaced by
> 
> ```
> [...].join(repr(e) for e in sortedshells if e in shell.successors(rev))
> ```
> and the occurrence of `is_MutablePoset` can be replaced by a simple `isinstance`-call.


`sorted_set_by_tuple`: Deleted and replaced.
`is_MutablePoset`: seems to be a standard convention to use it in Sage; see a lot of other modules.

> - `MutablePoset.shells`: I do not understand the usecase of the `reverse` keyword. Can it be removed?


I agree; deleted.

> - `MutablePoset.add`: I think that a comment (in the code) that roughly explains what the passage beginning with  `for reverse in (False, True):` does would be nice. It took me quite some time to understand and verify the functionality of this block.


I've added a comment.

> - `MutablePoset.discard`: why isn't this simply an alias of `MutablePoset.remove`? As `remove` has no return value, `discard` cannot have one either, if that was the intention.


See Python's set (the same behavior there).

> - Is there a particular reason for naming the parameters for all the set operations like `MutablePoset.union`, `MutablePoset.difference` etc. `left` and `right`, instead of `self` and `other`? IMHO, this disguises that the function can be called as `P.union(Q)`.


Changed all to self/other.

> - Regarding all set operations: currently, it is **not** clear from the documentation that all set operations are performed on the set of keys. This causes something like
> 
> ```
> sage: PR.<x> = ZZ[]
> sage: P = MutablePoset(key=lambda k: len(k.list()))
> sage: P.add(42*x)
> sage: P.add(21*x^2)
> sage: Q = MutablePoset(key=lambda k: len(k.list()))
> sage: Q.add(1111*x)
> sage: P, Q
> (poset(42*x, 21*x^2), poset(1111*x))
> sage: Q.is_subset(P)
> True
> sage: Q.union(P)
> poset(1111*x, 21*x^2)
> ```
> and so on. In principle, I don't see this as a problem---however, I'd state this explicitly in each of these set operation functions.


I've added a note in all these functions.

> - `MutablePoset.mapped`: why is this function needed? Purely for semantical reasons? I'd move the doctests to `MutablePoset.copy`.


It is a shortcut for using copy with the mapping argument (since this is a non-standard argument for a copy method, including a separate method with an approriate name seems to be a good choice)

> - `MutablePosetShell._copy_all_linked_`: is the memoization using the `id` of the object a standard procedure? I thought about it, but I'm not entirely sure that this isn't a potential error source.


Yes it is standard; see (all) deepcopy routines.

> Also, I've made a few reviewer commits concerning the documentation; the branch is attached.


Cross-reviewed. Thanks.



---

archive/issue_comments_232950.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-21T16:03:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232950",
    "user": "https://github.com/dkrenn"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_232951.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2015-09-21T16:03:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232951",
    "user": "https://github.com/dkrenn"
}
```

Last 10 new commits:



---

archive/issue_comments_232952.json:
```json
{
    "body": "Hello Daniel,\n\nI cross-reviewed your changes and have one last open question:\n- Is there a particular reason for deriving this from `object` instead of `SageObject`? Because [the documentation of SageObject](http://doc.sagemath.org/html/en/reference/structure/sage/structure/sage_object.html) states that \"Every object that can end up being returned to the user should inherit from SageObject.\"\n\nOther than that, this is `positive_review` from my side; AFAIK [comment:9 cheuberg] also wanted to cross-review this ticket, so I'll not set this to `positive_review` yet.\n\nBenjamin",
    "created_at": "2015-09-21T17:53:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232952",
    "user": "https://github.com/behackl"
}
```

Hello Daniel,

I cross-reviewed your changes and have one last open question:
- Is there a particular reason for deriving this from `object` instead of `SageObject`? Because [the documentation of SageObject](http://doc.sagemath.org/html/en/reference/structure/sage/structure/sage_object.html) states that "Every object that can end up being returned to the user should inherit from SageObject."

Other than that, this is `positive_review` from my side; AFAIK [comment:9 cheuberg] also wanted to cross-review this ticket, so I'll not set this to `positive_review` yet.

Benjamin



---

archive/issue_comments_232953.json:
```json
{
    "body": "Replying to [comment:32 behackl]:\n> - Is there a particular reason for deriving this from `object` instead of `SageObject`? Because [the documentation of SageObject](http://doc.sagemath.org/html/en/reference/structure/sage/structure/sage_object.html) states that \"Every object that can end up being returned to the user should inherit from SageObject.\"\n\n\nOk, then `SageObject` it is :)",
    "created_at": "2015-09-22T10:59:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232953",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:32 behackl]:
> - Is there a particular reason for deriving this from `object` instead of `SageObject`? Because [the documentation of SageObject](http://doc.sagemath.org/html/en/reference/structure/sage/structure/sage_object.html) states that "Every object that can end up being returned to the user should inherit from SageObject."


Ok, then `SageObject` it is :)



---

archive/issue_comments_232954.json:
```json
{
    "body": "A short remark on this change of mind:\n\nWhen deriving these classes from `SageObject` instead of `object`, and merging this ticket into #19083 (the cleanup-ticket of our `AsymptoticRing`), doctests were failing because we call `A(poset)` with an `AsymptoticRing` `A` there, which causes some peculiarities in `_coerce_map_from_`.\n\nIn any case, we fixed these problems there, so this can be properly derived from `SageObject`.\n\nThis concludes my review; [comment:8 cheuberg] is in the process of reading the code. I'll leave setting this to `positive_review` to him.\n\nBenjamin\n\n---\nLast 10 new commits:",
    "created_at": "2015-09-22T11:34:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232954",
    "user": "https://github.com/behackl"
}
```

A short remark on this change of mind:

When deriving these classes from `SageObject` instead of `object`, and merging this ticket into #19083 (the cleanup-ticket of our `AsymptoticRing`), doctests were failing because we call `A(poset)` with an `AsymptoticRing` `A` there, which causes some peculiarities in `_coerce_map_from_`.

In any case, we fixed these problems there, so this can be properly derived from `SageObject`.

This concludes my review; [comment:8 cheuberg] is in the process of reading the code. I'll leave setting this to `positive_review` to him.

Benjamin

---
Last 10 new commits:



---

archive/issue_events_050641.json:
```json
{
    "actor": "https://github.com/cheuberg",
    "created_at": "2015-09-23T08:48:18Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "milestone": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17456#event-50641"
}
```



---

archive/issue_comments_232955.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-23T08:48:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232955",
    "user": "https://github.com/cheuberg"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_232956.json:
```json
{
    "body": "Replying to [comment:34 behackl]:\n> This concludes my review; [comment:8 cheuberg] is in the process of reading the code. I'll leave setting this to `positive_review` to him.\n\n\nI read the documentation and the code. I pushed a few reviewer commits. I have a number of rather minor issues with the documentation which I ask you to fix in order facilitate future maintainance of the code. In three instances, I propose alternative implementations, which might be more readable or slightly more efficient.\n\n1. Please add `.. seealso::` blocks between corresponding methods of shell and poset as well as between the accessor methods (keys, elements, shells)\n2. there is an empty \"Introduction\" section at the beginning of the module documentation, the next heading \"Example\" is on the same level.\n3. this module was written as part of the asymptotic expansion effort. In contrast to the asymptotic expansion, it does not have the \"experimental\" decorator. I'd feel more comfortable having it, at least until a larger portion of the asymptotic expansions have been merged.\n4. `MutablePoset.__init__` accepts a list of elements. This could be used in several doctests (in particular, in the set operations) as an abbreviation.\n5. `MutablePosetShell.__init__`: shall we check that `element is not None`? Otherwise, handling of special elements would probably be affected.\n6. `MutablePosetShell.key`: I do not understand the sentence \"The element is converted by the poset to the key\".\n7. `MutablePosetShell.key`: I am surprised that the key is not cached. I imagine that many comparisons will be needed in the lifetime of a `MutablePoset`, and in every case, the property key has to be resolved, which calls the property poset, which calls `get_key` of the poset.\n8. `MutablePosetShell.__repr__`: The note box in the docstring is surprising at this point: reading the source file from the top, this is the first point where the representation of the data is explained, after guessing it from `is_special`, `is_oo`, `is_null` above. I think that it would be better to document these conventions closer to the top, perhaps in the `__init__` method or perhaps only as a comment in the source code.\n9. `MutablePosetShell.__repr__`: The code replicates the behaviour of `is_null` and `is_oo`. As the `__repr__` method is hardly time critical, I'd prefer using `is_null` and `is_oo`, here and thus hiding the internal convention.\n10. `MutablePosetShell.le`: the note box could be simplified by suppressing implementation details and speaking about the special elements.\n21. `MutablePosetShell.le`: `right <= left`: neither `right` nor `left` are defined here.\n32. `MutablePosetShell.le`: the part `if other.element is None` could be simplified to `return not other.successors()` as `self` is already known not to be special here.\n43. `MutablePosetShell.le`: If this is time critical, `self._predecessors_` could be used instead of `self.predecessors()`.\n54. `MutablePosetShell.eq`: note box, see above.\n65. `MutablePosetShell.eq`: emphasize that elements with equal keys are considered equal? Currently, this information is somewhat hidden in the note box which at first glance only seems to explain handling of special elements.\n76. `MutablePosetShell._copy_all_linked_`: Short description: \"Return a copy of all shells\" does not correspond to the actual return value, which is only the copy of this shell.\n87. `MutablePosetShell._copy_all_linked_`: the interplay between this method and `MutablePoset._copy_shells_` is not well documented: in particular, `poset` in `_copy_all_linked_` is *only* used for setting the containing poset, but not for actual inserting into this poset.\n98. `MutablePosetShell._copy_all_linked_`: I do not understand why you test `oo == P.oo`: I think that `oo` is an element of the new poset `Q`. So `oo is Q.oo` would be more interesting? The current test demonstrates that the poset is not used in comparison, so that would rather belong to `.eq`?\n109. `MutablePosetShell._search_covers_`: what is the role of `self` in this method? It trivially influences the return value, but what else?\n20. `MutablePosetShell._search_covers_`: The explanation of the return value is unclear to me. Is the sentence \"Note that...\" meant to be a complete description? Does it change if `reverse` is set?\n21. `MutablePosetShell._search_covers_`: I think that the notions of \"upper cover\" and \"lower cover\" need a brief definition; I did not find them in Wikipedia and `sage.combinat.posets.posets.FinitePoset.upper_covers` defines the notion.\n22. `MutablePosetShell._search_covers_`: According to Wikipedia, a cover is what is called an upper cover here. This is in contrast to the default behaviour here.\n23. `MutablePosetShell._search_covers_`: what is the difference between this method and `.predecessors`? Is the shell necessarily an element of the poset? If not, then there should be a doctest covering this case.\n24. `MutablePosetShell.covers`: \"originate\" is somewhat foreign to the description of the poset.\n25. `MutablePosetShell.covers`: \"which are at most the given shell\": should that be \"which are less than the given shell\"?\n26. `MutablePosetShell.covers` see comments on `MutablePosetShell._search_covers_`.\n27. `MutablePosetShell.covers`: I think that the following would be an equivalent implementation of this method, which does not need a helper function with side effects.\n\n```\n        if self == shell:\n            return set()\n        covers = set().union(*(e.covers(shell, reverse)\n                               for e in self.successors(reverse)\n                               if e.le(shell, reverse)))\n        if covers:\n            return covers\n        else:\n            return set([self])\n```\n  (pushed as branch `u/cheuberg/asy/mutable-poset-cover`)\n28. `MutablePosetShell._iter_depth_first_visit_`: document the role of self in this method (only shells `>=` this shell are visited).\n29. `MutablePosetShell.iter_depth_first`: document the role of self in this method (only shells `>=` this shell are visited).\n30. `MutablePosetShell._iter_topological_visit_`: document the role of self in this method (only shells `<=` this shell are visited, emphasize the contrast to depth first.).\n31. `MutablePosetShell.iter_topological_first`: document the role of self in this method (only shells `<=` this shell are visited, emphasize the contrast to depth first.).\n32. `MutablePosetShell.iter_topological_sort`, last example: function `C` is defined, but not used.\n33. `MutablePosetShell.merge`: explain what merge is, in particular, that this is defined when constructing the poset.\n34. `MutablePosetShell.merge`: I am surprised that `check=True` leads to a silent failure instead of an exception and that `poset._merge_ is None` does not raise an exception. Document and test this behaviour?\n35. `MutablePosetShell.merge`: what is the difference between `poset.remove` and `poset.discard`?\n36. `MutablePosetShell.merge`: document that the merge function resulting in `None` leads to deletion of the element.\n37. `MutablePosetShell.merge`: document that the merge function must not change the position of the element in the poset.\n38. `MutablePoset.__init__`: Clarify the role of `key`: in particular, `key` does not only influence sorting, but that no two elements are allowed to have the same key.\n39. `MutablePoset.__len__`: Clarify that `null` and `oo` are not counted.\n40. `MutablePoset.shells_topological`: The sentence \"If this is None, no sorting according to the representation string occurs.\" is unclear to me, in particular the role of the representation string.\n41. `MutablePoset.keys_topological`: Due to the chosen key, some of the elements added to the poset are ignored. I do not know why this is demonstrated here.\n42. `MutablePoset.repr`: INPUT section is incomplete.\n43. `MutablePoset.repr_full`: INPUT section is incomplete.\n44. `MutablePoset.add`: the loop `for reverse in (False, True)` simplifies in the second iteration: as all pairs of elements `(s, l)` with `new` covering `s` and `l` covering `new` have already been broken up while `reverse=False`. Thus it might be more straightforward to do it only once, not using `reverse` at all and saving a few intersections:\n\n```\n        new._predecessors_ = self.null.covers(new, reverse=False)\n        new._successors_ = self.oo.covers(new, reverse=True)\n\n        for s in new.predecessors():\n            for l in s.successors().intersection(new.successors()):\n                l.predecessors().remove(s)\n                s.successors().remove(l)\n            s.successors().add(new)\n        for l in new.successors():\n            l.predecessors().add(new)\n```\n  (pushed as branch `u/cheuberg/asy/mutable-poset-add`)\n45. `MutablePoset.remove`: the loop over all (not necessarily direct) successors via the depth first search iterator seems to be rather inefficient, especially if the poset is large. I propose an alternative based on the order relation and not based on the data structure:\n\n```\n        for upper in shell.successors():\n            upper.predecessors().remove(shell)\n\n        for lower in shell.predecessors():\n            lower.successors().remove(shell)\n            for upper in shell.successors():\n                if not any(s <= upper \n                           for s in lower.successors()):\n                    lower.successors().add(upper)\n                    upper.predecessors().add(lower)\n```\n  (pushed as branch `u/cheuberg/asy/mutable-poset-remove`)\n46. `MutablePoset.remove`, `MutablePoset.discard`: add \"see also blocks\", but also an explanation of the difference between `discard` and `remove`. I guess that both methods are available due to some compatibility concern (in that case, please add a remark in the code or the docstring). Otherwise, I'd suggest removing `discard`, removing the parameter `raise_key_error` and let the user catch the exception.\n47. `MutablePoset.pop`: remove `key=lambda c: -c` from this example as it is not pertinent to `pop`.\n48. `MutablePoset.pop`: mention that special elements cannot be popped.\n49. `MutablePoset.pop`: IMHO you can remove the first four line (the `try:` block deleting `kwargs['include_special']`) because setting `kwargs['include_special'] = False` should result in the same result.\n50. `MutablePoset.union`: The doctest `P.union(P, Q, Q, P)` neither fits the description \"a poset\" or \"an iterable of future elements\".\n51. `MutablePoset.union`: the word \"union\" sounds symmetric, however, due to keys and merge functions, it might not be commutative. The note box is not helpful for me.\n52. `MutablePoset.union`: the TODO box from `union_update` also applies here.\n53. `MutablePoset.union_update`: why is the semantics of `other` different w.r.t `union`, but has the same description? It would seem more logical to me if `union` would simply call copy and then pass its argument to `update_union` and let the latter function sort out the iterators?\n54. `MutablePoset.difference` and `MutablePoset.difference_update`: see comments on `union` and `union_update`\n55. `MutablePoset.intersection` and `MutablePoset.intersection_update`: see comments on `union` and `union_update`\n56. `MutablePoset.intersection_update`: how can the `AttributeError` occur? After all, `self` is a `MutablePoset`, so the method `keys` will be available unless something very strange happens ...\n57. `MutablePoset.merge`: documentation of `reverse`: what is the default direction?\n58. `MutablePoset.merge`: add doctest for `RuntimeError`.\n59. `MutablePoset.merge`: document that `can_merge` is applied in the sense of the condition of depth first iteration, i.e., once `can_merge` fails, the successors are no longer tested. This is some kind of monotonicity condition on `can_merge`.\n60. `MutablePoset.merge`: it should be mentioned somewhere that this (at first sight strange) merge magic is motivated by asymptotic expansions.\n61. `MutablePoset.map`: IMHO the example does alter the keys, because the key was the identity map here.\n62. `MutablePoset.mapping`: does the map have to be key preserving as in the method `map`? Is this method actually needed, see also the recent discussion on inplace vs. non-inplace operations on sage-devel?\n  \n---\nNew commits:",
    "created_at": "2015-09-23T08:48:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232956",
    "user": "https://github.com/cheuberg"
}
```

Replying to [comment:34 behackl]:
> This concludes my review; [comment:8 cheuberg] is in the process of reading the code. I'll leave setting this to `positive_review` to him.


I read the documentation and the code. I pushed a few reviewer commits. I have a number of rather minor issues with the documentation which I ask you to fix in order facilitate future maintainance of the code. In three instances, I propose alternative implementations, which might be more readable or slightly more efficient.

1. Please add `.. seealso::` blocks between corresponding methods of shell and poset as well as between the accessor methods (keys, elements, shells)
2. there is an empty "Introduction" section at the beginning of the module documentation, the next heading "Example" is on the same level.
3. this module was written as part of the asymptotic expansion effort. In contrast to the asymptotic expansion, it does not have the "experimental" decorator. I'd feel more comfortable having it, at least until a larger portion of the asymptotic expansions have been merged.
4. `MutablePoset.__init__` accepts a list of elements. This could be used in several doctests (in particular, in the set operations) as an abbreviation.
5. `MutablePosetShell.__init__`: shall we check that `element is not None`? Otherwise, handling of special elements would probably be affected.
6. `MutablePosetShell.key`: I do not understand the sentence "The element is converted by the poset to the key".
7. `MutablePosetShell.key`: I am surprised that the key is not cached. I imagine that many comparisons will be needed in the lifetime of a `MutablePoset`, and in every case, the property key has to be resolved, which calls the property poset, which calls `get_key` of the poset.
8. `MutablePosetShell.__repr__`: The note box in the docstring is surprising at this point: reading the source file from the top, this is the first point where the representation of the data is explained, after guessing it from `is_special`, `is_oo`, `is_null` above. I think that it would be better to document these conventions closer to the top, perhaps in the `__init__` method or perhaps only as a comment in the source code.
9. `MutablePosetShell.__repr__`: The code replicates the behaviour of `is_null` and `is_oo`. As the `__repr__` method is hardly time critical, I'd prefer using `is_null` and `is_oo`, here and thus hiding the internal convention.
10. `MutablePosetShell.le`: the note box could be simplified by suppressing implementation details and speaking about the special elements.
21. `MutablePosetShell.le`: `right <= left`: neither `right` nor `left` are defined here.
32. `MutablePosetShell.le`: the part `if other.element is None` could be simplified to `return not other.successors()` as `self` is already known not to be special here.
43. `MutablePosetShell.le`: If this is time critical, `self._predecessors_` could be used instead of `self.predecessors()`.
54. `MutablePosetShell.eq`: note box, see above.
65. `MutablePosetShell.eq`: emphasize that elements with equal keys are considered equal? Currently, this information is somewhat hidden in the note box which at first glance only seems to explain handling of special elements.
76. `MutablePosetShell._copy_all_linked_`: Short description: "Return a copy of all shells" does not correspond to the actual return value, which is only the copy of this shell.
87. `MutablePosetShell._copy_all_linked_`: the interplay between this method and `MutablePoset._copy_shells_` is not well documented: in particular, `poset` in `_copy_all_linked_` is *only* used for setting the containing poset, but not for actual inserting into this poset.
98. `MutablePosetShell._copy_all_linked_`: I do not understand why you test `oo == P.oo`: I think that `oo` is an element of the new poset `Q`. So `oo is Q.oo` would be more interesting? The current test demonstrates that the poset is not used in comparison, so that would rather belong to `.eq`?
109. `MutablePosetShell._search_covers_`: what is the role of `self` in this method? It trivially influences the return value, but what else?
20. `MutablePosetShell._search_covers_`: The explanation of the return value is unclear to me. Is the sentence "Note that..." meant to be a complete description? Does it change if `reverse` is set?
21. `MutablePosetShell._search_covers_`: I think that the notions of "upper cover" and "lower cover" need a brief definition; I did not find them in Wikipedia and `sage.combinat.posets.posets.FinitePoset.upper_covers` defines the notion.
22. `MutablePosetShell._search_covers_`: According to Wikipedia, a cover is what is called an upper cover here. This is in contrast to the default behaviour here.
23. `MutablePosetShell._search_covers_`: what is the difference between this method and `.predecessors`? Is the shell necessarily an element of the poset? If not, then there should be a doctest covering this case.
24. `MutablePosetShell.covers`: "originate" is somewhat foreign to the description of the poset.
25. `MutablePosetShell.covers`: "which are at most the given shell": should that be "which are less than the given shell"?
26. `MutablePosetShell.covers` see comments on `MutablePosetShell._search_covers_`.
27. `MutablePosetShell.covers`: I think that the following would be an equivalent implementation of this method, which does not need a helper function with side effects.

```
        if self == shell:
            return set()
        covers = set().union(*(e.covers(shell, reverse)
                               for e in self.successors(reverse)
                               if e.le(shell, reverse)))
        if covers:
            return covers
        else:
            return set([self])
```
  (pushed as branch `u/cheuberg/asy/mutable-poset-cover`)
28. `MutablePosetShell._iter_depth_first_visit_`: document the role of self in this method (only shells `>=` this shell are visited).
29. `MutablePosetShell.iter_depth_first`: document the role of self in this method (only shells `>=` this shell are visited).
30. `MutablePosetShell._iter_topological_visit_`: document the role of self in this method (only shells `<=` this shell are visited, emphasize the contrast to depth first.).
31. `MutablePosetShell.iter_topological_first`: document the role of self in this method (only shells `<=` this shell are visited, emphasize the contrast to depth first.).
32. `MutablePosetShell.iter_topological_sort`, last example: function `C` is defined, but not used.
33. `MutablePosetShell.merge`: explain what merge is, in particular, that this is defined when constructing the poset.
34. `MutablePosetShell.merge`: I am surprised that `check=True` leads to a silent failure instead of an exception and that `poset._merge_ is None` does not raise an exception. Document and test this behaviour?
35. `MutablePosetShell.merge`: what is the difference between `poset.remove` and `poset.discard`?
36. `MutablePosetShell.merge`: document that the merge function resulting in `None` leads to deletion of the element.
37. `MutablePosetShell.merge`: document that the merge function must not change the position of the element in the poset.
38. `MutablePoset.__init__`: Clarify the role of `key`: in particular, `key` does not only influence sorting, but that no two elements are allowed to have the same key.
39. `MutablePoset.__len__`: Clarify that `null` and `oo` are not counted.
40. `MutablePoset.shells_topological`: The sentence "If this is None, no sorting according to the representation string occurs." is unclear to me, in particular the role of the representation string.
41. `MutablePoset.keys_topological`: Due to the chosen key, some of the elements added to the poset are ignored. I do not know why this is demonstrated here.
42. `MutablePoset.repr`: INPUT section is incomplete.
43. `MutablePoset.repr_full`: INPUT section is incomplete.
44. `MutablePoset.add`: the loop `for reverse in (False, True)` simplifies in the second iteration: as all pairs of elements `(s, l)` with `new` covering `s` and `l` covering `new` have already been broken up while `reverse=False`. Thus it might be more straightforward to do it only once, not using `reverse` at all and saving a few intersections:

```
        new._predecessors_ = self.null.covers(new, reverse=False)
        new._successors_ = self.oo.covers(new, reverse=True)

        for s in new.predecessors():
            for l in s.successors().intersection(new.successors()):
                l.predecessors().remove(s)
                s.successors().remove(l)
            s.successors().add(new)
        for l in new.successors():
            l.predecessors().add(new)
```
  (pushed as branch `u/cheuberg/asy/mutable-poset-add`)
45. `MutablePoset.remove`: the loop over all (not necessarily direct) successors via the depth first search iterator seems to be rather inefficient, especially if the poset is large. I propose an alternative based on the order relation and not based on the data structure:

```
        for upper in shell.successors():
            upper.predecessors().remove(shell)

        for lower in shell.predecessors():
            lower.successors().remove(shell)
            for upper in shell.successors():
                if not any(s <= upper 
                           for s in lower.successors()):
                    lower.successors().add(upper)
                    upper.predecessors().add(lower)
```
  (pushed as branch `u/cheuberg/asy/mutable-poset-remove`)
46. `MutablePoset.remove`, `MutablePoset.discard`: add "see also blocks", but also an explanation of the difference between `discard` and `remove`. I guess that both methods are available due to some compatibility concern (in that case, please add a remark in the code or the docstring). Otherwise, I'd suggest removing `discard`, removing the parameter `raise_key_error` and let the user catch the exception.
47. `MutablePoset.pop`: remove `key=lambda c: -c` from this example as it is not pertinent to `pop`.
48. `MutablePoset.pop`: mention that special elements cannot be popped.
49. `MutablePoset.pop`: IMHO you can remove the first four line (the `try:` block deleting `kwargs['include_special']`) because setting `kwargs['include_special'] = False` should result in the same result.
50. `MutablePoset.union`: The doctest `P.union(P, Q, Q, P)` neither fits the description "a poset" or "an iterable of future elements".
51. `MutablePoset.union`: the word "union" sounds symmetric, however, due to keys and merge functions, it might not be commutative. The note box is not helpful for me.
52. `MutablePoset.union`: the TODO box from `union_update` also applies here.
53. `MutablePoset.union_update`: why is the semantics of `other` different w.r.t `union`, but has the same description? It would seem more logical to me if `union` would simply call copy and then pass its argument to `update_union` and let the latter function sort out the iterators?
54. `MutablePoset.difference` and `MutablePoset.difference_update`: see comments on `union` and `union_update`
55. `MutablePoset.intersection` and `MutablePoset.intersection_update`: see comments on `union` and `union_update`
56. `MutablePoset.intersection_update`: how can the `AttributeError` occur? After all, `self` is a `MutablePoset`, so the method `keys` will be available unless something very strange happens ...
57. `MutablePoset.merge`: documentation of `reverse`: what is the default direction?
58. `MutablePoset.merge`: add doctest for `RuntimeError`.
59. `MutablePoset.merge`: document that `can_merge` is applied in the sense of the condition of depth first iteration, i.e., once `can_merge` fails, the successors are no longer tested. This is some kind of monotonicity condition on `can_merge`.
60. `MutablePoset.merge`: it should be mentioned somewhere that this (at first sight strange) merge magic is motivated by asymptotic expansions.
61. `MutablePoset.map`: IMHO the example does alter the keys, because the key was the identity map here.
62. `MutablePoset.mapping`: does the map have to be key preserving as in the method `map`? Is this method actually needed, see also the recent discussion on inplace vs. non-inplace operations on sage-devel?
  
---
New commits:



---

archive/issue_comments_232957.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2015-09-28T12:25:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232957",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_232958.json:
```json
{
    "body": "Replying to [comment:36 cheuberg]:\n> I read the documentation and the code. I pushed a few reviewer commits.\n\n\nCross-reviewed. One commit added.\n\n> I have a number of rather minor issues with the documentation which I ask you to fix in order facilitate future maintainance of the code. In three instances, I propose alternative implementations, which might be more readable or slightly more efficient.\n\n\nThanks; see my comments below.\n\n> 1. Please add `.. seealso::` blocks between corresponding methods of shell and poset as well as between the accessor methods (keys, elements, shells)\n\n\nDone.\n\n> 2. there is an empty \"Introduction\" section at the beginning of the module documentation, the next heading \"Example\" is on the same level.\n\n\nDeleted.\n\n> 3. this module was written as part of the asymptotic expansion effort. In contrast to the asymptotic expansion, it does not have the \"experimental\" decorator. I'd feel more comfortable having it, at least until a larger portion of the asymptotic expansions have been merged.\n\n\nActivated it; it seems (for some (to me) unknown reason) the warning appears now in every doctest and not only once in the file. Thus, deactivated it again; and I am for keeping it this way.\n\n> 4. `MutablePoset.__init__` accepts a list of elements. This could be used in several doctests (in particular, in the set operations) as an abbreviation.\n\n\nGood idea. Done.\n\n> 5. `MutablePosetShell.__init__`: shall we check that `element is not None`? Otherwise, handling of special elements would probably be affected.\n\n\nMutablePosetShell is typically used by the MutablePoset; and there, adding a `None`-element is forbidden (see :meth:`add`).\n\n> 6. `MutablePosetShell.key`: I do not understand the sentence \"The element is converted by the poset to the key\".\n\n\nRewritten.\n\n> 7. `MutablePosetShell.key`: I am surprised that the key is not cached. I imagine that many comparisons will be needed in the lifetime of a `MutablePoset`, and in every case, the property key has to be resolved, which calls the property poset, which calls `get_key` of the poset.\n\n\nNow it is cached (see also follow up ticket #19281).\n\n> 8. `MutablePosetShell.__repr__`: The note box in the docstring is surprising at this point: reading the source file from the top, this is the first point where the representation of the data is explained, after guessing it from `is_special`, `is_oo`, `is_null` above. I think that it would be better to document these conventions closer to the top, perhaps in the `__init__` method or perhaps only as a comment in the source code.\n\n\nAdded a note in the class description.\n\n> 9. `MutablePosetShell.__repr__`: The code replicates the behaviour of `is_null` and `is_oo`. As the `__repr__` method is hardly time critical, I'd prefer using `is_null` and `is_oo`, here and thus hiding the internal convention.\n\n\nRewritten.\n\n> 10. `MutablePosetShell.le`: the note box could be simplified by suppressing implementation details and speaking about the special elements.\n\n\nDone.\n\n> 11. `MutablePosetShell.le`: `right <= left`: neither `right` nor `left` are defined here.\n\n\nRewritten.\n\n> 12. `MutablePosetShell.le`: the part `if other.element is None` could be simplified to `return not other.successors()` as `self` is already known not to be special here.\n\n\nTrue; rewritten.\n\n> 13. `MutablePosetShell.le`: If this is time critical, `self._predecessors_` could be used instead of `self.predecessors()`.\n\n\nChanged.\n\n> 14. `MutablePosetShell.eq`: note box, see above.\n\n\nSimplified.\n\n> 15. `MutablePosetShell.eq`: emphasize that elements with equal keys are considered equal? Currently, this information is somewhat hidden in the note box which at first glance only seems to explain handling of special elements.\n\n\nRewritten note box.\n\n> 16. `MutablePosetShell._copy_all_linked_`: Short description: \"Return a copy of all shells\" does not correspond to the actual return value, which is only the copy of this shell.\n\n\nRewritten.\n\n> 17. `MutablePosetShell._copy_all_linked_`: the interplay between this method and `MutablePoset._copy_shells_` is not well documented: in particular, `poset` in `_copy_all_linked_` is *only* used for setting the containing poset, but not for actual inserting into this poset.\n\n\nExtended description of parameter `poset`.\n\n> 18. `MutablePosetShell._copy_all_linked_`: I do not understand why you test `oo == P.oo`: I think that `oo` is an element of the new poset `Q`.\n\n\n`oo == P.oo` tests that `Q.oo` is mapped to ``P.oo``.\n\n> So `oo is Q.oo` would be more interesting?\n\n\n`oo is Q.oo` is `False` since `oo` is not in `Q`, but just a copy of the `oo` in `P` with parent-poset `Q`. Inserting this into `Q` is done in `_copy_shells_`.\n\n> The current test demonstrates that the poset is not used in comparison, so that would rather belong to `.eq`?\n\n\nI do not understand what you mean (but it is already late...).\n\n> 19. `MutablePosetShell._search_covers_`: what is the role of `self` in this method? It trivially influences the return value, but what else?\n\n\n`_search_covers_` does not exist anymore (see 27).\n\n> 20. `MutablePosetShell._search_covers_`: The explanation of the return value is unclear to me. Is the sentence \"Note that...\" meant to be a complete description? Does it change if `reverse` is set?\n\n\n`_search_covers_` does not exist anymore (see 27).\n\n> 21. `MutablePosetShell._search_covers_`: I think that the notions of \"upper cover\" and \"lower cover\" need a brief definition; I did not find them in Wikipedia and `sage.combinat.posets.posets.FinitePoset.upper_covers` defines the notion.\n\n\n`_search_covers_` does not exist anymore (see 27). Incooperated in `covers`.\n\n> 22. `MutablePosetShell._search_covers_`: According to Wikipedia, a cover is what is called an upper cover here. This is in contrast to the default behaviour here.\n\n\n`_search_covers_` does not exist anymore (see 27).\n\n> 23. `MutablePosetShell._search_covers_`: what is the difference between this method and `.predecessors`? Is the shell necessarily an element of the poset? If not, then there should be a doctest covering this case.\n\n\n`_search_covers_` does not exist anymore (see 27). Incooperated in `covers`.\n\n> 24. `MutablePosetShell.covers`: \"originate\" is somewhat foreign to the description of the poset.\n\n\nRewritten.\n\n> 25. `MutablePosetShell.covers`: \"which are at most the given shell\": should that be \"which are less than the given shell\"?\n\n\nRewritten.\n\n> 26. `MutablePosetShell.covers` see comments on `MutablePosetShell._search_covers_`.\n\n\nRewritten.\n\n> 27. `MutablePosetShell.covers`: I think that the following would be an equivalent implementation of this method, which does not need a helper function with side effects.\n> \n> ```\n>         if self == shell:\n>             return set()\n>         covers = set().union(*(e.covers(shell, reverse)\n>                                for e in self.successors(reverse)\n>                                if e.le(shell, reverse)))\n>         if covers:\n>             return covers\n>         else:\n>             return set([self])\n> ```\n>   (pushed as branch `u/cheuberg/asy/mutable-poset-cover`)\n\n\nMerged and minor simplification.\n\n> 28. `MutablePosetShell._iter_depth_first_visit_`: document the role of self in this method (only shells `>=` this shell are visited).\n\n\nDocumented.\n\n> 29. `MutablePosetShell.iter_depth_first`: document the role of self in this method (only shells `>=` this shell are visited).\n\n\nDocumented.\n\n> 30. `MutablePosetShell._iter_topological_visit_`: document the role of self in this method (only shells `<=` this shell are visited, emphasize the contrast to depth first.).\n\n\nDocumented.\n\n> 31. `MutablePosetShell.iter_topological_first`: document the role of self in this method (only shells `<=` this shell are visited, emphasize the contrast to depth first.).\n\n\nDocumented.\n\n> 32. `MutablePosetShell.iter_topological_sort`, last example: function `C` is defined, but not used.\n\n\nDeleted.\n\n> 33. `MutablePosetShell.merge`: explain what merge is, in particular, that this is defined when constructing the poset.\n\n\nDocumented.\n\n> 34. `MutablePosetShell.merge`: I am surprised that `check=True` leads to a silent failure instead of an exception and that `poset._merge_ is None` does not raise an exception. Document and test this behaviour?\n\n\nBehavior changed.\n\n> 35. `MutablePosetShell.merge`: what is the difference between `poset.remove` and `poset.discard`?\n\n\nSee Python's set.\n\n> 36. `MutablePosetShell.merge`: document that the merge function resulting in `None` leads to deletion of the element.\n\n\nDone.\n\n> 37. `MutablePosetShell.merge`: document that the merge function must not change the position of the element in the poset.\n\n\nMentioned this more explicitly in docs\n\n> 38. `MutablePoset.__init__`: Clarify the role of `key`: in particular, `key` does not only influence sorting, but that no two elements are allowed to have the same key.\n\n\nDone.\n\n> 39. `MutablePoset.__len__`: Clarify that `null` and `oo` are not counted.\n\n\nDone.\n\n> 40. `MutablePoset.shells_topological`: The sentence \"If this is None, no sorting according to the representation string occurs.\" is unclear to me, in particular the role of the representation string.\n\n\nRewritten.\n\n> 41. `MutablePoset.keys_topological`: Due to the chosen key, some of the elements added to the poset are ignored. I do not know why this is demonstrated here.\n\n\nRemoved.\n\n> 42. `MutablePoset.repr`: INPUT section is incomplete.\n\n\nCompleted.\n\n> 43. `MutablePoset.repr_full`: INPUT section is incomplete.\n\n\nCompleted.\n\n> 44. `MutablePoset.add`: the loop `for reverse in (False, True)` simplifies in the second iteration: as all pairs of elements `(s, l)` with `new` covering `s` and `l` covering `new` have already been broken up while `reverse=False`. Thus it might be more straightforward to do it only once, not using `reverse` at all and saving a few intersections:\n> \n> ```\n>         new._predecessors_ = self.null.covers(new, reverse=False)\n>         new._successors_ = self.oo.covers(new, reverse=True)\n> \n>         for s in new.predecessors():\n>             for l in s.successors().intersection(new.successors()):\n>                 l.predecessors().remove(s)\n>                 s.successors().remove(l)\n>             s.successors().add(new)\n>         for l in new.successors():\n>             l.predecessors().add(new)\n> ```\n>   (pushed as branch `u/cheuberg/asy/mutable-poset-add`)\n\n\nMerged and cross-reviewed....ok.\n\n> 45. `MutablePoset.remove`: the loop over all (not necessarily direct) successors via the depth first search iterator seems to be rather inefficient, especially if the poset is large. I propose an alternative based on the order relation and not based on the data structure:\n> \n> ```\n>         for upper in shell.successors():\n>             upper.predecessors().remove(shell)\n> \n>         for lower in shell.predecessors():\n>             lower.successors().remove(shell)\n>             for upper in shell.successors():\n>                 if not any(s <= upper \n>                            for s in lower.successors()):\n>                     lower.successors().add(upper)\n>                     upper.predecessors().add(lower)\n> ```\n>   (pushed as branch `u/cheuberg/asy/mutable-poset-remove`)\n\n\nThis needs comparisons of the elements, but one of the main ideas of this data structure is that comparisions are only needed for inserting an element into the poset and none needed once it is inside. Thus I am for keeping the current solution. However, I am fine with introducing (now or at any point later) an algorithm option which makes it possible to select different removing algorithms depending on the situation.\n\n> 46. `MutablePoset.remove`, `MutablePoset.discard`: add \"see also blocks\", but also an explanation of the difference between `discard` and `remove`. I guess that both methods are available due to some compatibility concern (in that case, please add a remark in the code or the docstring). Otherwise, I'd suggest removing `discard`, removing the parameter `raise_key_error` and let the user catch the exception.\n\n\nPython's set has both, `remove` and `discard`. Thus this mutable poset should have it as well.\nNote-block added. Seealso added.\n\n> 47. `MutablePoset.pop`: remove `key=lambda c: -c` from this example as it is not pertinent to `pop`.\n\n\nDone.\n\n> 48. `MutablePoset.pop`: mention that special elements cannot be popped.\n\n\nDone.\n\n> 49. `MutablePoset.pop`: IMHO you can remove the first four line (the `try:` block deleting `kwargs['include_special']`) because setting `kwargs['include_special'] = False` should result in the same result.\n\n\nDeleted.\n\n> 50. `MutablePoset.union`: The doctest `P.union(P, Q, Q, P)` neither fits the description \"a poset\" or \"an iterable of future elements\".\n\n\nRewritten INPUT-block\n\n> 51. `MutablePoset.union`: the word \"union\" sounds symmetric, however, due to keys and merge functions, it might not be commutative. The note box is not helpful for me.\n\n\nNote added/changed.\n\n> 52. `MutablePoset.union`: the TODO box from `union_update` also applies here.\n\n\nCopied.\n\n> 53. `MutablePoset.union_update`: why is the semantics of `other` different w.r.t `union`, but has the same description? It would seem more logical to me if `union` would simply call copy and then pass its argument to `update_union` and let the latter function sort out the iterators?\n\n\nIndeed. Code rewritten.\n\n> 54. `MutablePoset.difference` and `MutablePoset.difference_update`: see comments on `union` and `union_update`\n\n\nDone.\n\n> 55. `MutablePoset.intersection` and `MutablePoset.intersection_update`: see comments on `union` and `union_update`\n\n\nDone.\n\n> 56. `MutablePoset.intersection_update`: how can the `AttributeError` occur? After all, `self` is a `MutablePoset`, so the method `keys` will be available unless something very strange happens ...\n\n\nTrue. Code simplified.\n\n> 57. `MutablePoset.merge`: documentation of `reverse`: what is the default direction?\n\n\nDocumented.\n\n> 58. `MutablePoset.merge`: add doctest for `RuntimeError`.\n\n\nAdded.\n\n> 59. `MutablePoset.merge`: document that `can_merge` is applied in the sense of the condition of depth first iteration, i.e., once `can_merge` fails, the successors are no longer tested. This is some kind of monotonicity condition on `can_merge`.\n\n\nAdded note.\n\n> 60. `MutablePoset.merge`: it should be mentioned somewhere that this (at first sight strange) merge magic is motivated by asymptotic expansions.\n\n\nMentioned.\n\n> 61. `MutablePoset.map`: IMHO the example does alter the keys, because the key was the identity map here.\n\n\nExample changed.\n\n> 62. `MutablePoset.mapping`: does the map have to be key preserving as in the method `map`? Is this method actually needed, see also the recent discussion on inplace vs. non-inplace operations on sage-devel?\n\n\nAdded a note on key-order preservation.\n\nI think having `MutablePoset.mapping` is useful (from a ui point of view) since one would not naturally thinks that the `copy` method has a parameter for applying a mapping function.",
    "created_at": "2015-09-28T12:26:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232958",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:36 cheuberg]:
> I read the documentation and the code. I pushed a few reviewer commits.


Cross-reviewed. One commit added.

> I have a number of rather minor issues with the documentation which I ask you to fix in order facilitate future maintainance of the code. In three instances, I propose alternative implementations, which might be more readable or slightly more efficient.


Thanks; see my comments below.

> 1. Please add `.. seealso::` blocks between corresponding methods of shell and poset as well as between the accessor methods (keys, elements, shells)


Done.

> 2. there is an empty "Introduction" section at the beginning of the module documentation, the next heading "Example" is on the same level.


Deleted.

> 3. this module was written as part of the asymptotic expansion effort. In contrast to the asymptotic expansion, it does not have the "experimental" decorator. I'd feel more comfortable having it, at least until a larger portion of the asymptotic expansions have been merged.


Activated it; it seems (for some (to me) unknown reason) the warning appears now in every doctest and not only once in the file. Thus, deactivated it again; and I am for keeping it this way.

> 4. `MutablePoset.__init__` accepts a list of elements. This could be used in several doctests (in particular, in the set operations) as an abbreviation.


Good idea. Done.

> 5. `MutablePosetShell.__init__`: shall we check that `element is not None`? Otherwise, handling of special elements would probably be affected.


MutablePosetShell is typically used by the MutablePoset; and there, adding a `None`-element is forbidden (see :meth:`add`).

> 6. `MutablePosetShell.key`: I do not understand the sentence "The element is converted by the poset to the key".


Rewritten.

> 7. `MutablePosetShell.key`: I am surprised that the key is not cached. I imagine that many comparisons will be needed in the lifetime of a `MutablePoset`, and in every case, the property key has to be resolved, which calls the property poset, which calls `get_key` of the poset.


Now it is cached (see also follow up ticket #19281).

> 8. `MutablePosetShell.__repr__`: The note box in the docstring is surprising at this point: reading the source file from the top, this is the first point where the representation of the data is explained, after guessing it from `is_special`, `is_oo`, `is_null` above. I think that it would be better to document these conventions closer to the top, perhaps in the `__init__` method or perhaps only as a comment in the source code.


Added a note in the class description.

> 9. `MutablePosetShell.__repr__`: The code replicates the behaviour of `is_null` and `is_oo`. As the `__repr__` method is hardly time critical, I'd prefer using `is_null` and `is_oo`, here and thus hiding the internal convention.


Rewritten.

> 10. `MutablePosetShell.le`: the note box could be simplified by suppressing implementation details and speaking about the special elements.


Done.

> 11. `MutablePosetShell.le`: `right <= left`: neither `right` nor `left` are defined here.


Rewritten.

> 12. `MutablePosetShell.le`: the part `if other.element is None` could be simplified to `return not other.successors()` as `self` is already known not to be special here.


True; rewritten.

> 13. `MutablePosetShell.le`: If this is time critical, `self._predecessors_` could be used instead of `self.predecessors()`.


Changed.

> 14. `MutablePosetShell.eq`: note box, see above.


Simplified.

> 15. `MutablePosetShell.eq`: emphasize that elements with equal keys are considered equal? Currently, this information is somewhat hidden in the note box which at first glance only seems to explain handling of special elements.


Rewritten note box.

> 16. `MutablePosetShell._copy_all_linked_`: Short description: "Return a copy of all shells" does not correspond to the actual return value, which is only the copy of this shell.


Rewritten.

> 17. `MutablePosetShell._copy_all_linked_`: the interplay between this method and `MutablePoset._copy_shells_` is not well documented: in particular, `poset` in `_copy_all_linked_` is *only* used for setting the containing poset, but not for actual inserting into this poset.


Extended description of parameter `poset`.

> 18. `MutablePosetShell._copy_all_linked_`: I do not understand why you test `oo == P.oo`: I think that `oo` is an element of the new poset `Q`.


`oo == P.oo` tests that `Q.oo` is mapped to ``P.oo``.

> So `oo is Q.oo` would be more interesting?


`oo is Q.oo` is `False` since `oo` is not in `Q`, but just a copy of the `oo` in `P` with parent-poset `Q`. Inserting this into `Q` is done in `_copy_shells_`.

> The current test demonstrates that the poset is not used in comparison, so that would rather belong to `.eq`?


I do not understand what you mean (but it is already late...).

> 19. `MutablePosetShell._search_covers_`: what is the role of `self` in this method? It trivially influences the return value, but what else?


`_search_covers_` does not exist anymore (see 27).

> 20. `MutablePosetShell._search_covers_`: The explanation of the return value is unclear to me. Is the sentence "Note that..." meant to be a complete description? Does it change if `reverse` is set?


`_search_covers_` does not exist anymore (see 27).

> 21. `MutablePosetShell._search_covers_`: I think that the notions of "upper cover" and "lower cover" need a brief definition; I did not find them in Wikipedia and `sage.combinat.posets.posets.FinitePoset.upper_covers` defines the notion.


`_search_covers_` does not exist anymore (see 27). Incooperated in `covers`.

> 22. `MutablePosetShell._search_covers_`: According to Wikipedia, a cover is what is called an upper cover here. This is in contrast to the default behaviour here.


`_search_covers_` does not exist anymore (see 27).

> 23. `MutablePosetShell._search_covers_`: what is the difference between this method and `.predecessors`? Is the shell necessarily an element of the poset? If not, then there should be a doctest covering this case.


`_search_covers_` does not exist anymore (see 27). Incooperated in `covers`.

> 24. `MutablePosetShell.covers`: "originate" is somewhat foreign to the description of the poset.


Rewritten.

> 25. `MutablePosetShell.covers`: "which are at most the given shell": should that be "which are less than the given shell"?


Rewritten.

> 26. `MutablePosetShell.covers` see comments on `MutablePosetShell._search_covers_`.


Rewritten.

> 27. `MutablePosetShell.covers`: I think that the following would be an equivalent implementation of this method, which does not need a helper function with side effects.
> 
> ```
>         if self == shell:
>             return set()
>         covers = set().union(*(e.covers(shell, reverse)
>                                for e in self.successors(reverse)
>                                if e.le(shell, reverse)))
>         if covers:
>             return covers
>         else:
>             return set([self])
> ```
>   (pushed as branch `u/cheuberg/asy/mutable-poset-cover`)


Merged and minor simplification.

> 28. `MutablePosetShell._iter_depth_first_visit_`: document the role of self in this method (only shells `>=` this shell are visited).


Documented.

> 29. `MutablePosetShell.iter_depth_first`: document the role of self in this method (only shells `>=` this shell are visited).


Documented.

> 30. `MutablePosetShell._iter_topological_visit_`: document the role of self in this method (only shells `<=` this shell are visited, emphasize the contrast to depth first.).


Documented.

> 31. `MutablePosetShell.iter_topological_first`: document the role of self in this method (only shells `<=` this shell are visited, emphasize the contrast to depth first.).


Documented.

> 32. `MutablePosetShell.iter_topological_sort`, last example: function `C` is defined, but not used.


Deleted.

> 33. `MutablePosetShell.merge`: explain what merge is, in particular, that this is defined when constructing the poset.


Documented.

> 34. `MutablePosetShell.merge`: I am surprised that `check=True` leads to a silent failure instead of an exception and that `poset._merge_ is None` does not raise an exception. Document and test this behaviour?


Behavior changed.

> 35. `MutablePosetShell.merge`: what is the difference between `poset.remove` and `poset.discard`?


See Python's set.

> 36. `MutablePosetShell.merge`: document that the merge function resulting in `None` leads to deletion of the element.


Done.

> 37. `MutablePosetShell.merge`: document that the merge function must not change the position of the element in the poset.


Mentioned this more explicitly in docs

> 38. `MutablePoset.__init__`: Clarify the role of `key`: in particular, `key` does not only influence sorting, but that no two elements are allowed to have the same key.


Done.

> 39. `MutablePoset.__len__`: Clarify that `null` and `oo` are not counted.


Done.

> 40. `MutablePoset.shells_topological`: The sentence "If this is None, no sorting according to the representation string occurs." is unclear to me, in particular the role of the representation string.


Rewritten.

> 41. `MutablePoset.keys_topological`: Due to the chosen key, some of the elements added to the poset are ignored. I do not know why this is demonstrated here.


Removed.

> 42. `MutablePoset.repr`: INPUT section is incomplete.


Completed.

> 43. `MutablePoset.repr_full`: INPUT section is incomplete.


Completed.

> 44. `MutablePoset.add`: the loop `for reverse in (False, True)` simplifies in the second iteration: as all pairs of elements `(s, l)` with `new` covering `s` and `l` covering `new` have already been broken up while `reverse=False`. Thus it might be more straightforward to do it only once, not using `reverse` at all and saving a few intersections:
> 
> ```
>         new._predecessors_ = self.null.covers(new, reverse=False)
>         new._successors_ = self.oo.covers(new, reverse=True)
> 
>         for s in new.predecessors():
>             for l in s.successors().intersection(new.successors()):
>                 l.predecessors().remove(s)
>                 s.successors().remove(l)
>             s.successors().add(new)
>         for l in new.successors():
>             l.predecessors().add(new)
> ```
>   (pushed as branch `u/cheuberg/asy/mutable-poset-add`)


Merged and cross-reviewed....ok.

> 45. `MutablePoset.remove`: the loop over all (not necessarily direct) successors via the depth first search iterator seems to be rather inefficient, especially if the poset is large. I propose an alternative based on the order relation and not based on the data structure:
> 
> ```
>         for upper in shell.successors():
>             upper.predecessors().remove(shell)
> 
>         for lower in shell.predecessors():
>             lower.successors().remove(shell)
>             for upper in shell.successors():
>                 if not any(s <= upper 
>                            for s in lower.successors()):
>                     lower.successors().add(upper)
>                     upper.predecessors().add(lower)
> ```
>   (pushed as branch `u/cheuberg/asy/mutable-poset-remove`)


This needs comparisons of the elements, but one of the main ideas of this data structure is that comparisions are only needed for inserting an element into the poset and none needed once it is inside. Thus I am for keeping the current solution. However, I am fine with introducing (now or at any point later) an algorithm option which makes it possible to select different removing algorithms depending on the situation.

> 46. `MutablePoset.remove`, `MutablePoset.discard`: add "see also blocks", but also an explanation of the difference between `discard` and `remove`. I guess that both methods are available due to some compatibility concern (in that case, please add a remark in the code or the docstring). Otherwise, I'd suggest removing `discard`, removing the parameter `raise_key_error` and let the user catch the exception.


Python's set has both, `remove` and `discard`. Thus this mutable poset should have it as well.
Note-block added. Seealso added.

> 47. `MutablePoset.pop`: remove `key=lambda c: -c` from this example as it is not pertinent to `pop`.


Done.

> 48. `MutablePoset.pop`: mention that special elements cannot be popped.


Done.

> 49. `MutablePoset.pop`: IMHO you can remove the first four line (the `try:` block deleting `kwargs['include_special']`) because setting `kwargs['include_special'] = False` should result in the same result.


Deleted.

> 50. `MutablePoset.union`: The doctest `P.union(P, Q, Q, P)` neither fits the description "a poset" or "an iterable of future elements".


Rewritten INPUT-block

> 51. `MutablePoset.union`: the word "union" sounds symmetric, however, due to keys and merge functions, it might not be commutative. The note box is not helpful for me.


Note added/changed.

> 52. `MutablePoset.union`: the TODO box from `union_update` also applies here.


Copied.

> 53. `MutablePoset.union_update`: why is the semantics of `other` different w.r.t `union`, but has the same description? It would seem more logical to me if `union` would simply call copy and then pass its argument to `update_union` and let the latter function sort out the iterators?


Indeed. Code rewritten.

> 54. `MutablePoset.difference` and `MutablePoset.difference_update`: see comments on `union` and `union_update`


Done.

> 55. `MutablePoset.intersection` and `MutablePoset.intersection_update`: see comments on `union` and `union_update`


Done.

> 56. `MutablePoset.intersection_update`: how can the `AttributeError` occur? After all, `self` is a `MutablePoset`, so the method `keys` will be available unless something very strange happens ...


True. Code simplified.

> 57. `MutablePoset.merge`: documentation of `reverse`: what is the default direction?


Documented.

> 58. `MutablePoset.merge`: add doctest for `RuntimeError`.


Added.

> 59. `MutablePoset.merge`: document that `can_merge` is applied in the sense of the condition of depth first iteration, i.e., once `can_merge` fails, the successors are no longer tested. This is some kind of monotonicity condition on `can_merge`.


Added note.

> 60. `MutablePoset.merge`: it should be mentioned somewhere that this (at first sight strange) merge magic is motivated by asymptotic expansions.


Mentioned.

> 61. `MutablePoset.map`: IMHO the example does alter the keys, because the key was the identity map here.


Example changed.

> 62. `MutablePoset.mapping`: does the map have to be key preserving as in the method `map`? Is this method actually needed, see also the recent discussion on inplace vs. non-inplace operations on sage-devel?


Added a note on key-order preservation.

I think having `MutablePoset.mapping` is useful (from a ui point of view) since one would not naturally thinks that the `copy` method has a parameter for applying a mapping function.



---

archive/issue_comments_232959.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-28T12:26:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232959",
    "user": "https://github.com/dkrenn"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_232960.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-28T16:02:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232960",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_232961.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-28T16:51:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232961",
    "user": "https://github.com/cheuberg"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_232962.json:
```json
{
    "body": "Thank you for your changes. I added three commits. See my remaining comments below.\n\nReplying to [comment:39 dkrenn]:\n> Replying to [comment:36 cheuberg]:\n> > 3. this module was written as part of the asymptotic expansion effort. In contrast to the asymptotic expansion, it does not have the \"experimental\" decorator. I'd feel more comfortable having it, at least until a larger portion of the asymptotic expansions have been merged.\n  \n> \n> Activated it; it seems (for some (to me) unknown reason) the warning appears now in every doctest and not only once in the file. Thus, deactivated it again; and I am for keeping it this way.\n\n\nok.\n\n> > 7. `MutablePosetShell.key`: I am surprised that the key is not cached. I imagine that many comparisons will be needed in the lifetime of a `MutablePoset`, and in every case, the property key has to be resolved, which calls the property poset, which calls `get_key` of the poset.\n  \n> \n> Now it is cached (see also follow up ticket #19281).\n\n\nI rather thought about calling `key` in `__init__` as I guess that the key will be needed at least once in the lifetime of every `MutablePosetShell`.\n\n\n> > 18. `MutablePosetShell._copy_all_linked_`: I do not understand why you test `oo == P.oo`: I think that `oo` is an element of the new poset `Q`.\n  \n> \n> `oo == P.oo` tests that `Q.oo` is mapped to ``P.oo``.\n\n\nwouldn't `oo.is_oo` do it without comparing shells of different posets, which might be confusing?\n\n> \n> > So `oo is Q.oo` would be more interesting?\n\n> \n> `oo is Q.oo` is `False` since `oo` is not in `Q`, but just a copy of the `oo` in `P` with parent-poset `Q`.\n\n\nthat would be good to test (and comment on).\n\n> Inserting this into `Q` is done in `_copy_shells_`.\n> \n> > The current test demonstrates that the poset is not used in comparison, so that would rather belong to `.eq`?\n\n> \n> I do not understand what you mean (but it is already late...).\n\n\nI mean that shells `e` and `f` might be equal even if they do belong to different posets; this might be an interesting doctest or example for equality.\n\n\n> > 22. `MutablePosetShell._search_covers_`: According to Wikipedia, a cover is what is called an upper cover here. This is in contrast to the default behaviour here.\n  \n> \n> `_search_covers_` does not exist anymore (see 27).\n\n\nThis does not solve the problem.\n\nWhat about renaming the method `covers` to `lower_covers` (and adapting the docstring slightly, removing \"upper \" from the one-sentence-description as well as from the definition?) For symmetry, a method `upper_covers` would be nice.\n\n\n> > 45. `MutablePoset.remove`: the loop over all (not necessarily direct) successors via the depth first search iterator seems to be rather inefficient, especially if the poset is large. I propose an alternative based on the order relation and not based on the data structure:\n> > \n> > ```\n> >         for upper in shell.successors():\n> >             upper.predecessors().remove(shell)\n> > \n> >         for lower in shell.predecessors():\n> >             lower.successors().remove(shell)\n> >             for upper in shell.successors():\n> >                 if not any(s <= upper \n> >                            for s in lower.successors()):\n> >                     lower.successors().add(upper)\n> >                     upper.predecessors().add(lower)\n> > ```\n> >   (pushed as branch `u/cheuberg/asy/mutable-poset-remove`)\n\n> \n> This needs comparisons of the elements, but one of the main ideas of this data structure is that comparisions are only needed for inserting an element into the poset and none needed once it is inside. Thus I am for keeping the current solution. However, I am fine with introducing (now or at any point later) an algorithm option which makes it possible to select different removing algorithms depending on the situation.\n\n\nThis should be discussed when more benchmarking results are available. I opened #19300 for that.\n\n> > 54. `MutablePoset.difference` and `MutablePoset.difference_update`: see comments on `union` and `union_update`\n  \n> \n> Done.\n\n\nremoved comment on non-commutativity because `difference` is non-commutative by definition.\n\n> \n> > 55. `MutablePoset.intersection` and `MutablePoset.intersection_update`: see comments on `union` and `union_update`\n  \n> \n> Done.\n\n\nRemove comment on non-commutativity? merge does not play a role here, and keys might be covered in the previous sentence?\n\n\n63. `MutablePoset.update_union`: \"Due to keys and a merge function... this operation might not be commutative\": This method is non-commutative by definition, as `self` is changed and `other` is not. So perhaps: \"`left.update_union(right)`\" and \"`right.update_union(left)` might result in different posets\"? The same for other `update_...` methods where non-commutativity might be surprising.",
    "created_at": "2015-09-28T16:51:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232962",
    "user": "https://github.com/cheuberg"
}
```

Thank you for your changes. I added three commits. See my remaining comments below.

Replying to [comment:39 dkrenn]:
> Replying to [comment:36 cheuberg]:
> > 3. this module was written as part of the asymptotic expansion effort. In contrast to the asymptotic expansion, it does not have the "experimental" decorator. I'd feel more comfortable having it, at least until a larger portion of the asymptotic expansions have been merged.
  
> 
> Activated it; it seems (for some (to me) unknown reason) the warning appears now in every doctest and not only once in the file. Thus, deactivated it again; and I am for keeping it this way.


ok.

> > 7. `MutablePosetShell.key`: I am surprised that the key is not cached. I imagine that many comparisons will be needed in the lifetime of a `MutablePoset`, and in every case, the property key has to be resolved, which calls the property poset, which calls `get_key` of the poset.
  
> 
> Now it is cached (see also follow up ticket #19281).


I rather thought about calling `key` in `__init__` as I guess that the key will be needed at least once in the lifetime of every `MutablePosetShell`.


> > 18. `MutablePosetShell._copy_all_linked_`: I do not understand why you test `oo == P.oo`: I think that `oo` is an element of the new poset `Q`.
  
> 
> `oo == P.oo` tests that `Q.oo` is mapped to ``P.oo``.


wouldn't `oo.is_oo` do it without comparing shells of different posets, which might be confusing?

> 
> > So `oo is Q.oo` would be more interesting?

> 
> `oo is Q.oo` is `False` since `oo` is not in `Q`, but just a copy of the `oo` in `P` with parent-poset `Q`.


that would be good to test (and comment on).

> Inserting this into `Q` is done in `_copy_shells_`.
> 
> > The current test demonstrates that the poset is not used in comparison, so that would rather belong to `.eq`?

> 
> I do not understand what you mean (but it is already late...).


I mean that shells `e` and `f` might be equal even if they do belong to different posets; this might be an interesting doctest or example for equality.


> > 22. `MutablePosetShell._search_covers_`: According to Wikipedia, a cover is what is called an upper cover here. This is in contrast to the default behaviour here.
  
> 
> `_search_covers_` does not exist anymore (see 27).


This does not solve the problem.

What about renaming the method `covers` to `lower_covers` (and adapting the docstring slightly, removing "upper " from the one-sentence-description as well as from the definition?) For symmetry, a method `upper_covers` would be nice.


> > 45. `MutablePoset.remove`: the loop over all (not necessarily direct) successors via the depth first search iterator seems to be rather inefficient, especially if the poset is large. I propose an alternative based on the order relation and not based on the data structure:
> > 
> > ```
> >         for upper in shell.successors():
> >             upper.predecessors().remove(shell)
> > 
> >         for lower in shell.predecessors():
> >             lower.successors().remove(shell)
> >             for upper in shell.successors():
> >                 if not any(s <= upper 
> >                            for s in lower.successors()):
> >                     lower.successors().add(upper)
> >                     upper.predecessors().add(lower)
> > ```
> >   (pushed as branch `u/cheuberg/asy/mutable-poset-remove`)

> 
> This needs comparisons of the elements, but one of the main ideas of this data structure is that comparisions are only needed for inserting an element into the poset and none needed once it is inside. Thus I am for keeping the current solution. However, I am fine with introducing (now or at any point later) an algorithm option which makes it possible to select different removing algorithms depending on the situation.


This should be discussed when more benchmarking results are available. I opened #19300 for that.

> > 54. `MutablePoset.difference` and `MutablePoset.difference_update`: see comments on `union` and `union_update`
  
> 
> Done.


removed comment on non-commutativity because `difference` is non-commutative by definition.

> 
> > 55. `MutablePoset.intersection` and `MutablePoset.intersection_update`: see comments on `union` and `union_update`
  
> 
> Done.


Remove comment on non-commutativity? merge does not play a role here, and keys might be covered in the previous sentence?


63. `MutablePoset.update_union`: "Due to keys and a merge function... this operation might not be commutative": This method is non-commutative by definition, as `self` is changed and `other` is not. So perhaps: "`left.update_union(right)`" and "`right.update_union(left)` might result in different posets"? The same for other `update_...` methods where non-commutativity might be surprising.



---

archive/issue_comments_232963.json:
```json
{
    "body": "Replying to [comment:43 cheuberg]:\n> Thank you for your changes. I added three commits. See my remaining comments below.\n\n\nCross-review...ok.\n\n> > > 7. `MutablePosetShell.key`: I am surprised that the key is not cached. I imagine that many comparisons will be needed in the lifetime of a `MutablePoset`, and in every case, the property key has to be resolved, which calls the property poset, which calls `get_key` of the poset.\n  \n> > \n> > Now it is cached (see also follow up ticket #19281).\n\n> \n> I rather thought about calling `key` in `__init__` as I guess that the key will be needed at least once in the lifetime of every `MutablePosetShell`.\n\n\nOh...yes, I agree; changed.\n\n> > > 18. `MutablePosetShell._copy_all_linked_`: I do not understand why you test `oo == P.oo`: I think that `oo` is an element of the new poset `Q`.\n  \n> > \n> > `oo == P.oo` tests that `Q.oo` is mapped to ``P.oo``.\n\n> \n> wouldn't `oo.is_oo` do it without comparing shells of different posets, which might be confusing?\n\n\nTrue. Changed.\n\n> > > So `oo is Q.oo` would be more interesting?\n\n> > \n> > `oo is Q.oo` is `False` since `oo` is not in `Q`, but just a copy of the `oo` in `P` with parent-poset `Q`.\n\n> \n> that would be good to test (and comment on).\n\n\nInserted.\n\n> > Inserting this into `Q` is done in `_copy_shells_`.\n> > \n> > > The current test demonstrates that the poset is not used in comparison, so that would rather belong to `.eq`?\n\n> > \n> > I do not understand what you mean (but it is already late...).\n\n> \n> I mean that shells `e` and `f` might be equal even if they do belong to different posets; this might be an interesting doctest or example for equality.\n\n\nNow I understand what you mean. Inserted a doctest there.\n\n> > > 22. `MutablePosetShell._search_covers_`: According to Wikipedia, a cover is what is called an upper cover here. This is in contrast to the default behaviour here.\n  \n> > \n> > `_search_covers_` does not exist anymore (see 27).\n\n> \n> This does not solve the problem.\n> \n> What about renaming the method `covers` to `lower_covers` (and adapting the docstring slightly, removing \"upper \" from the one-sentence-description as well as from the definition?) For symmetry, a method `upper_covers` would be nice.\n\n\nGood idea; changed and inserted `upper_covers`.\n\n> > > 55. `MutablePoset.intersection` and `MutablePoset.intersection_update`: see comments on `union` and `union_update`\n  \n> > \n> > Done.\n\n> \n> Remove comment on non-commutativity? merge does not play a role here, and keys might be covered in the previous sentence?\n\n\nRemoved.\n\n> 63. `MutablePoset.update_union`: \"Due to keys and a merge function... this operation might not be commutative\": This method is non-commutative by definition, as `self` is changed and `other` is not. So perhaps: \"`left.update_union(right)`\" and \"`right.update_union(left)` might result in different posets\"? The same for other `update_...` methods where non-commutativity might be surprising.\n\n\nChanged.\n\n---\nNew commits:",
    "created_at": "2015-09-29T07:24:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232963",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:43 cheuberg]:
> Thank you for your changes. I added three commits. See my remaining comments below.


Cross-review...ok.

> > > 7. `MutablePosetShell.key`: I am surprised that the key is not cached. I imagine that many comparisons will be needed in the lifetime of a `MutablePoset`, and in every case, the property key has to be resolved, which calls the property poset, which calls `get_key` of the poset.
  
> > 
> > Now it is cached (see also follow up ticket #19281).

> 
> I rather thought about calling `key` in `__init__` as I guess that the key will be needed at least once in the lifetime of every `MutablePosetShell`.


Oh...yes, I agree; changed.

> > > 18. `MutablePosetShell._copy_all_linked_`: I do not understand why you test `oo == P.oo`: I think that `oo` is an element of the new poset `Q`.
  
> > 
> > `oo == P.oo` tests that `Q.oo` is mapped to ``P.oo``.

> 
> wouldn't `oo.is_oo` do it without comparing shells of different posets, which might be confusing?


True. Changed.

> > > So `oo is Q.oo` would be more interesting?

> > 
> > `oo is Q.oo` is `False` since `oo` is not in `Q`, but just a copy of the `oo` in `P` with parent-poset `Q`.

> 
> that would be good to test (and comment on).


Inserted.

> > Inserting this into `Q` is done in `_copy_shells_`.
> > 
> > > The current test demonstrates that the poset is not used in comparison, so that would rather belong to `.eq`?

> > 
> > I do not understand what you mean (but it is already late...).

> 
> I mean that shells `e` and `f` might be equal even if they do belong to different posets; this might be an interesting doctest or example for equality.


Now I understand what you mean. Inserted a doctest there.

> > > 22. `MutablePosetShell._search_covers_`: According to Wikipedia, a cover is what is called an upper cover here. This is in contrast to the default behaviour here.
  
> > 
> > `_search_covers_` does not exist anymore (see 27).

> 
> This does not solve the problem.
> 
> What about renaming the method `covers` to `lower_covers` (and adapting the docstring slightly, removing "upper " from the one-sentence-description as well as from the definition?) For symmetry, a method `upper_covers` would be nice.


Good idea; changed and inserted `upper_covers`.

> > > 55. `MutablePoset.intersection` and `MutablePoset.intersection_update`: see comments on `union` and `union_update`
  
> > 
> > Done.

> 
> Remove comment on non-commutativity? merge does not play a role here, and keys might be covered in the previous sentence?


Removed.

> 63. `MutablePoset.update_union`: "Due to keys and a merge function... this operation might not be commutative": This method is non-commutative by definition, as `self` is changed and `other` is not. So perhaps: "`left.update_union(right)`" and "`right.update_union(left)` might result in different posets"? The same for other `update_...` methods where non-commutativity might be surprising.


Changed.

---
New commits:



---

archive/issue_comments_232964.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-29T07:24:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232964",
    "user": "https://github.com/dkrenn"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_232965.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-29T08:07:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232965",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_232966.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-09-29T08:10:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232966",
    "user": "https://github.com/cheuberg"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_232967.json:
```json
{
    "body": "Added three final reviewer commits.\n\nDoctests pass, documentation builds, documentation seems to be fine, code seems to be fine.",
    "created_at": "2015-09-29T08:10:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232967",
    "user": "https://github.com/cheuberg"
}
```

Added three final reviewer commits.

Doctests pass, documentation builds, documentation seems to be fine, code seems to be fine.



---

archive/issue_comments_232968.json:
```json
{
    "body": "Replying to [comment:49 cheuberg]:\n> Added three final reviewer commits.\n\n\nThanks; checked.\n\n> Doctests pass, documentation builds, documentation seems to be fine, code seems to be fine.\n\n\n:)",
    "created_at": "2015-09-29T08:14:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232968",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:49 cheuberg]:
> Added three final reviewer commits.


Thanks; checked.

> Doctests pass, documentation builds, documentation seems to be fine, code seems to be fine.


:)



---

archive/issue_events_050642.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-10-12T07:16:42Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17456#event-50642"
}
```



---

archive/issue_comments_232969.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-10-12T07:16:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17456",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17456#issuecomment-232969",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
