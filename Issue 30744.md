# Issue 30744: Annular Khovanov Homology of Braids

Issue created by migration from https://trac.sagemath.org/ticket/30981

Original creator: @Jaulers

Original creation time: 2020-11-30 09:09:13

CC:  mmarco

Implents annular Khovanov homology for braids.


```
sage: B = BraidGroup(2)
sage: b = B([1,1,1])
sage: b.annular_khovanov_homology()
{(9, 0): {3: Z},
 (7, 0): {2: 0, 3: C2},
 (1, -2): {0: Z},
 (3, 0): {0: Z, 1: 0, 2: 0, 3: 0},
 (5, 0): {1: Z, 2: Z, 3: 0},
 (5, 2): {0: Z}}
sage: annular_khovanov_homology(poincare_polynomial=True)
a^2*q^5 + q^9*t^3 + q^5*t^2 + q^5*t + q^3 + a^-2*q
```


It is computed very similarly as the implementation of Khovanov homology for links.



---

Comment by git created at 2020-11-30 09:11:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Jaulers created at 2020-11-30 09:17:02

This is my first contribution.

I added the ability to output the poincareé polynomial of the homology since the dictionary is often quite hard to read and it makes for a more compact output. However I'm not sure if this is the ideal place to implement it, maybe some more general solution for homologies would be better...

I'm also not sure where to put the additional needed imports for the needed modules. Should they be put at the front of the file or into each function, I've seen both in this file.


---

Comment by chapoton created at 2020-11-30 09:24:29

just a few trivial comments:

`.. NOTE::` should be in capital letters

`... == None` should be `... is None`

when iterating over dicts, you can remove the `.keys()` as this gives the same thing

add a reference to an article for the definition

do not insert too many empty lines


---

Comment by git created at 2020-11-30 09:59:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-11-30 10:12:27

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by chapoton created at 2020-11-30 10:37:50

annular_khovanov_homology has no doctests. every function should have doctests


---

Comment by chapoton created at 2020-11-30 10:38:41

do not use `IntegerRing()`, but rather ZZ


---

Comment by git created at 2020-11-30 16:06:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Jaulers created at 2020-11-30 16:11:41

Replying to [comment:7 chapoton]:
> do not use `IntegerRing()`, but rather ZZ

I've used `IntegerRing()` since this was used everywhere else in `braids.py`. (i.e. in `burau_matrix()`, `alexenader_polynomial()` etc.)

I thought using ZZ just for this method would be a bit inconsistent.


---

Comment by chapoton created at 2020-11-30 17:24:23

ok, right


---

Comment by chapoton created at 2020-12-01 13:22:41

patchbot says : 

```
src/sage/groups/braid.py:1213:9 local variable 'ncross' is assigned to but never used
```



---

Comment by git created at 2020-12-02 13:37:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-12-02 13:51:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Jaulers created at 2020-12-06 18:31:33

Changing status from new to needs_review.


---

Comment by @Jaulers created at 2021-01-09 11:32:18

After working with this a bit, I realized it is a bit impractical to only have a method for directly getting the homology group, as this gives little insight into the structure. It would probably be better to only have a method of returning the annular khovanov chain complex and then leave it up to the user to calculate homology. The the user can have access to all options in calculating homology.

I'll start working on that.


---

Comment by @Jaulers created at 2021-01-09 11:32:18

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2021-01-11 23:48:02

I would recommend having both, a method for the chain complex and a shortcut method for the homology.


---

Comment by @Jaulers created at 2021-01-12 15:58:30

Are you sure this is needed? Because computing homology from the complex would be as easy as just 

```
b.annular_khovanov_complex(ZZ,(qgrad,agrad)).homology()
```


Plus, using the homology method directly, the user can access all the parameters of the homology method directly, without needing to pass it through some wrapper function.


---

Comment by tscrim created at 2021-01-13 00:39:16

It is not needed, but it is useful to a more casual user. You can also modify the `homology` interface to be more tailored to the computation at hand.


---

Comment by git created at 2021-01-13 11:21:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Jaulers created at 2021-01-13 11:25:59

I've left in `annular_khovanov_homology()` now. You're right it is often handy to have that shortcut.

However I removed the poincarée polynomial option, I really don't think this is the right place to implement it.

Replying to [comment:18 tscrim]:
> It is not needed, but it is useful to a more casual user. You can also modify the `homology` interface to be more tailored to the computation at hand.

What do you mean by tailoring the `homology` interface?


---

Comment by tscrim created at 2021-01-14 05:46:03

Replying to [comment:20 gh-Jaulers]:
> Replying to [comment:18 tscrim]:
> > It is not needed, but it is useful to a more casual user. You can also modify the `homology` interface to be more tailored to the computation at hand.
> 
> What do you mean by tailoring the `homology` interface?

Essentially what you said above with having an option to compute the Poincaré polynomial. You can change the options and how those are handled to give a more specific experience specific to the case of links/knots.


---

Comment by @Jaulers created at 2021-01-18 09:26:59

Do you think it would be useful to have the option for the Poincaré polynomial?


---

Comment by tscrim created at 2021-01-18 09:31:55

I am not such an expert in knot theory, so I cannot really say. Although from a more naïve separation-of-concerns viewpoint, that would be better as a separate method as it is not the actual homology.


---

Comment by @Jaulers created at 2021-01-18 09:46:38

I personally used it mainly since it gave a nicer overview over the homology, but as I said, I also think it would be a weird place to implement it directly into the `annular_khovanov_homology()` method.

I also wouldn't implement some poincarée polynomial method, since that would only work for the format returned by this method. I think if the user desires such output, it is reasonably easy to write a function that does this.


---

Comment by @Jaulers created at 2021-01-18 09:47:04

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2021-01-18 09:59:34

Replying to [comment:24 gh-Jaulers]:
> I also wouldn't implement some poincarée polynomial method, since that would only work for the format returned by this method. I think if the user desires such output, it is reasonably easy to write a function that does this.

I don't understand what you mean by this. It would be perfectly fine for it to take the specific output of `annular_khovanov_homology()` or output it in a similar way. Anyways, if you don't think such an additional method is useful, then you don't have to implement it.

With the new commit, the patchbot is reporting the following doctest failures:

```
sage -t --long --random-seed=0 src/sage/groups/braid.py  # 3 doctests failed
```



---

Comment by git created at 2021-01-18 11:03:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Jaulers created at 2021-01-18 11:07:48

Replying to [comment:26 tscrim]:
> With the new commit, the patchbot is reporting the following doctest failures:
> {{{
> sage -t --long --random-seed=0 src/sage/groups/braid.py  # 3 doctests failed
> }}}

Oh yes, thank you. Once again the dictionary was out of order. Is there any simple way to get sage to print the dictionary in the right order, so one can write the doctests easier? For now I've always used `dict(sorted(d.items()))` but that doesn't work for nested dictionaries...


---

Comment by tscrim created at 2021-01-19 00:02:46

Replying to [comment:28 gh-Jaulers]:
> Replying to [comment:26 tscrim]:
> > With the new commit, the patchbot is reporting the following doctest failures:
> > {{{
> > sage -t --long --random-seed=0 src/sage/groups/braid.py  # 3 doctests failed
> > }}}
> 
> Oh yes, thank you. Once again the dictionary was out of order. Is there any simple way to get sage to print the dictionary in the right order, so one can write the doctests easier? For now I've always used `dict(sorted(d.items()))` but that doesn't work for nested dictionaries...

The output of dictionaries when run in Sage's doctests are sorted (by the keys IIRC), precisely to ensure consistency in the doctests. So when running something with things like a `dict`,  I just use `sage -t` and copy that output.

Although for this case, since you have `dict` of `dict`, you will likely have to manually convert it to the list of items and sort the items.

Also, typo `mad` -> `made`:

```
A tuple with the type of smoothing mad at each crossing.
```


```diff
-        """r
+        r"""
         Return the annular Khovanov homology of a closure of a braid.
 
         INPUT:
 
-        - ``qagrad`` -- tuple of quantum and annular grading for which to
-          compute the homology. If this is ``None`` (default), then
-          compute for all gradings.
+        - ``qagrad`` -- (optional) tuple of quantum and annular grading
+          for which to compute the homology
 
-        - ``ring`` -- (default: ``ZZ``) the coefficient ring.
+        - ``ring`` -- (default: ``ZZ``) the coefficient ring
 
         OUTPUT:
 
         If ``qagrad`` is ``None``, return a dictionary of homogies in all
         gradings indexed by grading. If qagrad is specified, return homology
         of that grading.
 
         .. NOTE::
+
             This is a simple wrapper around :meth:`annular_khovanov_complex`
             to compute homology from it.
```



---

Comment by git created at 2021-01-19 10:13:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by tscrim created at 2021-07-07 22:20:21

Changing keywords from "" to "knot, annular Khovanov, braid group".


---

Comment by tscrim created at 2021-07-07 22:20:21

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2021-07-07 22:20:21

Sorry for letting this drop off my radar. Thank you for the changes.


---

Comment by vbraun created at 2021-07-18 13:28:10

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2021-07-18 13:28:10

On 32-bit:

```
File "src/sage/groups/braid.py", line 1027, in sage.groups.braid.Braid._enhanced_states
Failed example:
    b._enhanced_states()
Expected:
    {(0,
      -2): {0: [((0, 0),
        {(frozenset({(0, 1), (1, 1)}), 1), (frozenset({(0, 3), (1, 3)}), 1)},
        set())]},
     (2,
      0): {0: [((0, 0),
        {(frozenset({(0, 3), (1, 3)}), 1)},
        {(frozenset({(0, 1), (1, 1)}), 1)}),
       ((0, 0),
        {(frozenset({(0, 1), (1, 1)}), 1)},
        {(frozenset({(0, 3), (1, 3)}), 1)})], 1: [((1, 0),
        {(frozenset({(0, 0), (0, 2), (1, 1), (1, 3)}), 0)},
        set()),
       ((0, 1),
        {(frozenset({(0, 1), (0, 3), (1, 0), (1, 2)}), 0)},
        set())], 2: [((1, 1), {(frozenset({(0, 2), (1, 0)}), 0),
         (frozenset({(0, 0), (1, 2)}), 0)}, set())]},
     (4,
      0): {1: [((1, 0), set(), {(frozenset({(0, 0), (0, 2), (1, 1), (1, 3)}), 0)}),
       ((0, 1),
        set(),
        {(frozenset({(0, 1), (0, 3), (1, 0), (1, 2)}), 0)})], 2: [((1,
         1), {(frozenset({(0, 2), (1, 0)}), 0)}, {(frozenset({(0, 0), (1, 2)}),
          0)}),
       ((1, 1),
        {(frozenset({(0, 0), (1, 2)}), 0)},
        {(frozenset({(0, 2), (1, 0)}), 0)})]},
     (4,
      2): {0: [((0, 0),
        set(),
        {(frozenset({(0, 1), (1, 1)}), 1), (frozenset({(0, 3), (1, 3)}), 1)})]},
     (6,
      0): {2: [((1, 1),
        set(),
        {(frozenset({(0, 2), (1, 0)}), 0), (frozenset({(0, 0), (1, 2)}), 0)})]}}
Got:
    {(0,
      -2): {0: [((0, 0),
        {(frozenset({(0, 1), (1, 1)}), 1), (frozenset({(0, 3), (1, 3)}), 1)},
        set())]},
     (2,
      0): {0: [((0, 0),
        {(frozenset({(0, 3), (1, 3)}), 1)},
        {(frozenset({(0, 1), (1, 1)}), 1)}),
       ((0, 0),
        {(frozenset({(0, 1), (1, 1)}), 1)},
        {(frozenset({(0, 3), (1, 3)}), 1)})], 1: [((1, 0),
        {(frozenset({(0, 0), (0, 2), (1, 1), (1, 3)}), 0)},
        set()),
       ((0, 1),
        {(frozenset({(0, 1), (0, 3), (1, 0), (1, 2)}), 0)},
        set())], 2: [((1, 1), {(frozenset({(0, 0), (1, 2)}), 0),
         (frozenset({(0, 2), (1, 0)}), 0)}, set())]},
     (4,
      0): {1: [((1, 0), set(), {(frozenset({(0, 0), (0, 2), (1, 1), (1, 3)}), 0)}),
       ((0, 1),
        set(),
        {(frozenset({(0, 1), (0, 3), (1, 0), (1, 2)}), 0)})], 2: [((1,
         1), {(frozenset({(0, 2), (1, 0)}), 0)}, {(frozenset({(0, 0), (1, 2)}),
          0)}),
       ((1, 1),
        {(frozenset({(0, 0), (1, 2)}), 0)},
        {(frozenset({(0, 2), (1, 0)}), 0)})]},
     (4,
      2): {0: [((0, 0),
        set(),
        {(frozenset({(0, 1), (1, 1)}), 1), (frozenset({(0, 3), (1, 3)}), 1)})]},
     (6,
      0): {2: [((1, 1),
        set(),
        {(frozenset({(0, 0), (1, 2)}), 0), (frozenset({(0, 2), (1, 0)}), 0)})]}}
**********************************************************************
1 item had failures:
   1 of   4 in sage.groups.braid.Braid._enhanced_states
    [350 tests, 1 failure, 2.23 s]
----------------------------------------------------------------------
sage -t --long --random-seed=0 src/sage/groups/braid.py  # 1 doctest failed
----------------------------------------------------------------------
```



---

Comment by @Jaulers created at 2021-07-22 11:32:33

Replying to [comment:33 vbraun]:
> On 32-bit:
> {{{
> [...]
> Expected:
> [...]
>         {(frozenset({(0, 2), (1, 0)}), 0), (frozenset({(0, 0), (1, 2)}), 0)})]}}
> Got:
> [...]
>         {(frozenset({(0, 0), (1, 2)}), 0), (frozenset({(0, 2), (1, 0)}), 0)})]}}
> **********************************************************************
> [...]
> }}}

Mhm, it seems the 32-bit version likes to choose a different ordering for the sets. Is there some difference in the versions how the ordering is chosen?


---

Comment by tscrim created at 2021-07-23 01:39:14

Here is a version of that test that just sorts all of the output.
----
New commits:


---

Comment by tscrim created at 2021-07-23 01:39:14

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2021-08-15 00:35:02

Green patchbot. Can someone quickly check my last changes? They are just a trivial ordering update and the only thing we need to go back to a positive review.


---

Comment by chapoton created at 2021-08-18 18:28:56

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2021-08-18 18:28:56

ok, let it be


---

Comment by vbraun created at 2021-08-29 09:37:48

Resolution: fixed
