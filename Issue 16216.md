# Issue 16216: Cythonize quiver paths

archive/issues_016216.json:
```json
{
    "body": "CC:  @nthiery @nathanncohen stumpc5 @saliola\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/16453\n\n",
    "created_at": "2014-06-07T08:47:55Z",
    "labels": [
        "component: please change"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Cythonize quiver paths",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16216",
    "user": "https://github.com/simon-king-jena"
}
```
CC:  @nthiery @nathanncohen stumpc5 @saliola



Issue created by migration from https://trac.sagemath.org/ticket/16453





---

archive/issue_comments_211449.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2014-06-07T08:55:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211449",
    "user": "https://github.com/simon-king-jena"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_211450.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to algebra.",
    "created_at": "2014-06-07T08:55:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211450",
    "user": "https://github.com/simon-king-jena"
}
```

Changing component from PLEASE CHANGE to algebra.



---

archive/issue_comments_211451.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2014-06-07T08:58:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211451",
    "user": "https://github.com/simon-king-jena"
}
```

Last 10 new commits:



---

archive/issue_comments_211452.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-09T17:27:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211452",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211453.json:
```json
{
    "body": "I have provided a cythoned version of quiver paths (i.e., elements of path semigroups), based on the bounded integer sequences of #15820. All tests pass, so, needs review.\n\nI didn't do timings yet. And hopefully it is ok that I slightly changed the syntax to create a path:\n\n```\n   old                       new\nQ((1,1))                  Q([(1,1)])\nQ([(1,2,'a'), (2,3,'b')]  Q(['a','b'])  # old syntax still works\nQ((1,2,'a'))              Q([(1,2,'a')]) or Q('a')\n```\n",
    "created_at": "2014-06-09T17:37:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211453",
    "user": "https://github.com/simon-king-jena"
}
```

I have provided a cythoned version of quiver paths (i.e., elements of path semigroups), based on the bounded integer sequences of #15820. All tests pass, so, needs review.

I didn't do timings yet. And hopefully it is ok that I slightly changed the syntax to create a path:

```
   old                       new
Q((1,1))                  Q([(1,1)])
Q([(1,2,'a'), (2,3,'b')]  Q(['a','b'])  # old syntax still works
Q((1,2,'a'))              Q([(1,2,'a')]) or Q('a')
```




---

archive/issue_comments_211454.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-06-09T17:37:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211454",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_211455.json:
```json
{
    "body": "I think I should also provide something like a gcd for paths. This is likely to be implemented as a function in sage.misc.bounded_integer_sequences computing the largest overlap between two sequences S1, S2, i.e.: `largest_overlap(S1,S2)` is the smallest number `i` such that S2 starts with `S1[i:]`. This is something that will obviously be relevant when implementing Gr\u00f6bner bases for path algebras.",
    "created_at": "2014-06-11T10:04:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211455",
    "user": "https://github.com/simon-king-jena"
}
```

I think I should also provide something like a gcd for paths. This is likely to be implemented as a function in sage.misc.bounded_integer_sequences computing the largest overlap between two sequences S1, S2, i.e.: `largest_overlap(S1,S2)` is the smallest number `i` such that S2 starts with `S1[i:]`. This is something that will obviously be relevant when implementing Gröbner bases for path algebras.



---

archive/issue_comments_211456.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-11T15:22:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211456",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211457.json:
```json
{
    "body": "The \"largest overlap\" was implemented in the latest commit of #15820. Here, I use it for \"greatest common divisor\" of paths P1, P2. This returns a triple C1, G, C2, so that G is of maximal length with the property `P1=C1*G` and `P2=G*C2`. Still needing review...",
    "created_at": "2014-06-11T15:25:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211457",
    "user": "https://github.com/simon-king-jena"
}
```

The "largest overlap" was implemented in the latest commit of #15820. Here, I use it for "greatest common divisor" of paths P1, P2. This returns a triple C1, G, C2, so that G is of maximal length with the property `P1=C1*G` and `P2=G*C2`. Still needing review...



---

archive/issue_comments_211458.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-20T14:11:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211458",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211459.json:
```json
{
    "body": "In follow-up tickets, I will probably need to cimport quiver paths. Hence, I added a Cython header.",
    "created_at": "2014-06-20T14:13:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211459",
    "user": "https://github.com/simon-king-jena"
}
```

In follow-up tickets, I will probably need to cimport quiver paths. Hence, I added a Cython header.



---

archive/issue_comments_211460.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2014-07-22T11:49:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211460",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_211461.json:
```json
{
    "body": "In the outspoken expectation that nobody except myself has used the branch from this ticket, I took the liberty to rebase it on top of the latest fix at #15820. So, this is a forced push.\n\nI suppose it still needs review.",
    "created_at": "2014-07-22T11:50:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211461",
    "user": "https://github.com/simon-king-jena"
}
```

In the outspoken expectation that nobody except myself has used the branch from this ticket, I took the liberty to rebase it on top of the latest fix at #15820. So, this is a forced push.

I suppose it still needs review.



---

archive/issue_comments_211462.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-09-04T15:27:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211462",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211463.json:
```json
{
    "body": "Wow. This will be quite some work. By simply merging the new commits and doing the appropriate changes to cope with the changed API of \"bounded integer sequences\", I get some crashes and failures.",
    "created_at": "2014-09-04T16:25:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211463",
    "user": "https://github.com/simon-king-jena"
}
```

Wow. This will be quite some work. By simply merging the new commits and doing the appropriate changes to cope with the changed API of "bounded integer sequences", I get some crashes and failures.



---

archive/issue_comments_211464.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-04T22:16:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211464",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211465.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-09-04T22:17:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211465",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211466.json:
```json
{
    "body": "After all, it was easy to cope with the changes of #15820. All tests pass, needs review!!",
    "created_at": "2014-09-04T22:17:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211466",
    "user": "https://github.com/simon-king-jena"
}
```

After all, it was easy to cope with the changes of #15820. All tests pass, needs review!!



---

archive/issue_comments_211467.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-15T14:41:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211467",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211468.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-15T14:44:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211468",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211469.json:
```json
{
    "body": "I added a new feature: Counting of paths (in terms of generating functions), for arbitrary quivers. Needs review...\n----\nNew commits:",
    "created_at": "2014-09-15T14:45:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211469",
    "user": "https://github.com/simon-king-jena"
}
```

I added a new feature: Counting of paths (in terms of generating functions), for arbitrary quivers. Needs review...
----
New commits:



---

archive/issue_comments_211470.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-15T14:55:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211470",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211471.json:
```json
{
    "body": "How can I obtain the letter `\u00e9` in `Poincar\u00e9` in the docs? I thought that `\\\\'e` would work---isn't latex used for typesetting? Apart from this minor detail, I think the code is fine.\n----\nNew commits:",
    "created_at": "2014-09-15T14:57:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211471",
    "user": "https://github.com/simon-king-jena"
}
```

How can I obtain the letter `é` in `Poincaré` in the docs? I thought that `\\'e` would work---isn't latex used for typesetting? Apart from this minor detail, I think the code is fine.
----
New commits:



---

archive/issue_comments_211472.json:
```json
{
    "body": "Replying to [comment:23 SimonKing]:\n> How can I obtain the letter `\u00e9` in `Poincar\u00e9` in the docs? I thought that `\\\\'e` would work---isn't latex used for typesetting? \n\nYes, but only for typesetting math stuff. I would just insert the character directly in unicode, and add the usual header to the file:\n\n```\n## -*- encoding: utf-8 -*-\n```\n",
    "created_at": "2014-09-15T15:17:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211472",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:23 SimonKing]:
> How can I obtain the letter `é` in `Poincaré` in the docs? I thought that `\\'e` would work---isn't latex used for typesetting? 

Yes, but only for typesetting math stuff. I would just insert the character directly in unicode, and add the usual header to the file:

```
## -*- encoding: utf-8 -*-
```




---

archive/issue_comments_211473.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-15T20:00:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211473",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211474.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-09-16T10:37:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211474",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211475.json:
```json
{
    "body": "Needs work. I just found the following totally wrong answer of `poincare_series()`:\n\n```\nsage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()\nsage: S.inject_variables()\nDefining e_0, e_1, e_2, a, b, c, d, e, f\nsage: S.poincare_series((e*b, b*f, f*f, c*a, d*c, a*d, f*e, d*d*d*d, a*c*b*e, c*b*e*a*c, b*e*a*c*b))[0,0]\n(948568795032094272909893509191171341133987714380927500611236528192824358010355712*t^6 - 474284397516047136454946754595585670566993857190463750305618264096412179005177856*t^5 + 1422853192548141409364840263786757011700981571571391250916854792289236537015533568*t^4 - 1422853192548141409364840263786757011700981571571391250916854792289236537015533568*t^3 + 1897137590064188545819787018382342682267975428761855001222473056385648716020711424*t^2 - 948568795032094272909893509191171341133987714380927500611236528192824358010355712*t + 474284397516047136454946754595585670566993857190463750305618264096412179005177856)/(-474284397516047136454946754595585670566993857190463750305618264096412179005177856*t^11 + 1422853192548141409364840263786757011700981571571391250916854792289236537015533568*t^10 - 1897137590064188545819787018382342682267975428761855001222473056385648716020711424*t^9 + 3319990782612329955184627282169099693968957000333246252139327848674885253036244992*t^8 - 2371421987580235682274733772977928352834969285952318751528091320482060895025889280*t^7 + 1897137590064188545819787018382342682267975428761855001222473056385648716020711424*t^6 + 2371421987580235682274733772977928352834969285952318751528091320482060895025889280*t^5 - 2371421987580235682274733772977928352834969285952318751528091320482060895025889280*t^4 + 1422853192548141409364840263786757011700981571571391250916854792289236537015533568*t^3 + 948568795032094272909893509191171341133987714380927500611236528192824358010355712*t^2 - 948568795032094272909893509191171341133987714380927500611236528192824358010355712*t + 474284397516047136454946754595585670566993857190463750305618264096412179005177856)\n```\n\nThe correct answer would be a polynomil (what we have here is obtained from the principal 2-block of Mathieu group M11, which is finite). And the constant coefficient should just be 1 (since there is precisely one path of length zero from vertex 0 to vertex 0). I need to check the underlying maths, probably I got something wrong there.",
    "created_at": "2014-09-16T10:37:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211475",
    "user": "https://github.com/simon-king-jena"
}
```

Needs work. I just found the following totally wrong answer of `poincare_series()`:

```
sage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()
sage: S.inject_variables()
Defining e_0, e_1, e_2, a, b, c, d, e, f
sage: S.poincare_series((e*b, b*f, f*f, c*a, d*c, a*d, f*e, d*d*d*d, a*c*b*e, c*b*e*a*c, b*e*a*c*b))[0,0]
(948568795032094272909893509191171341133987714380927500611236528192824358010355712*t^6 - 474284397516047136454946754595585670566993857190463750305618264096412179005177856*t^5 + 1422853192548141409364840263786757011700981571571391250916854792289236537015533568*t^4 - 1422853192548141409364840263786757011700981571571391250916854792289236537015533568*t^3 + 1897137590064188545819787018382342682267975428761855001222473056385648716020711424*t^2 - 948568795032094272909893509191171341133987714380927500611236528192824358010355712*t + 474284397516047136454946754595585670566993857190463750305618264096412179005177856)/(-474284397516047136454946754595585670566993857190463750305618264096412179005177856*t^11 + 1422853192548141409364840263786757011700981571571391250916854792289236537015533568*t^10 - 1897137590064188545819787018382342682267975428761855001222473056385648716020711424*t^9 + 3319990782612329955184627282169099693968957000333246252139327848674885253036244992*t^8 - 2371421987580235682274733772977928352834969285952318751528091320482060895025889280*t^7 + 1897137590064188545819787018382342682267975428761855001222473056385648716020711424*t^6 + 2371421987580235682274733772977928352834969285952318751528091320482060895025889280*t^5 - 2371421987580235682274733772977928352834969285952318751528091320482060895025889280*t^4 + 1422853192548141409364840263786757011700981571571391250916854792289236537015533568*t^3 + 948568795032094272909893509191171341133987714380927500611236528192824358010355712*t^2 - 948568795032094272909893509191171341133987714380927500611236528192824358010355712*t + 474284397516047136454946754595585670566993857190463750305618264096412179005177856)
```

The correct answer would be a polynomil (what we have here is obtained from the principal 2-block of Mathieu group M11, which is finite). And the constant coefficient should just be 1 (since there is precisely one path of length zero from vertex 0 to vertex 0). I need to check the underlying maths, probably I got something wrong there.



---

archive/issue_comments_211476.json:
```json
{
    "body": "My counting formula is wrong, but in addition to that there seems to be a problem with quotient fields of rational polynomial rings. This shall be tracked in a different ticket, of course:\n\n```\nsage: P.<t> = QQ[]\nsage: p = 4/(-4*t)\nsage: p   # OK, fractions are not automatically reduced\n4/(-4*t)\nsage: p.reduce()\nsage: p   # What the heck...\n4/(-4*t)\nsage: p == -1/t   # At least sage gets this right\nTrue\n```\n",
    "created_at": "2014-09-16T12:45:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211476",
    "user": "https://github.com/simon-king-jena"
}
```

My counting formula is wrong, but in addition to that there seems to be a problem with quotient fields of rational polynomial rings. This shall be tracked in a different ticket, of course:

```
sage: P.<t> = QQ[]
sage: p = 4/(-4*t)
sage: p   # OK, fractions are not automatically reduced
4/(-4*t)
sage: p.reduce()
sage: p   # What the heck...
4/(-4*t)
sage: p == -1/t   # At least sage gets this right
True
```




---

archive/issue_comments_211477.json:
```json
{
    "body": "Replying to [comment:27 SimonKing]:\n> My counting formula is wrong, but in addition to that there seems to be a problem with quotient fields of rational polynomial rings. This shall be tracked in a different ticket, of course:\n> {{{\n> sage: P.<t> = QQ[]\n> sage: p = 4/(-4*t)\n> sage: p   # OK, fractions are not automatically reduced\n> 4/(-4*t)\n> sage: p.reduce()\n> sage: p   # What the heck...\n> 4/(-4*t)\n> sage: p == -1/t   # At least sage gets this right\n> True\n> }}}\n\nIt's not completely unreasonable: in a field, the gcd of two elements can be arguably always set to 1. This is not what Sage does, but that's presumably Singular's choice.\n\n```\n    sage: gcd(4/1, 4/1)\n    4\n```\n\n\nI don't know if it helps, but if you do the same calculation over ZZ, you get the desired result.",
    "created_at": "2014-09-16T14:19:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211477",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:27 SimonKing]:
> My counting formula is wrong, but in addition to that there seems to be a problem with quotient fields of rational polynomial rings. This shall be tracked in a different ticket, of course:
> {{{
> sage: P.<t> = QQ[]
> sage: p = 4/(-4*t)
> sage: p   # OK, fractions are not automatically reduced
> 4/(-4*t)
> sage: p.reduce()
> sage: p   # What the heck...
> 4/(-4*t)
> sage: p == -1/t   # At least sage gets this right
> True
> }}}

It's not completely unreasonable: in a field, the gcd of two elements can be arguably always set to 1. This is not what Sage does, but that's presumably Singular's choice.

```
    sage: gcd(4/1, 4/1)
    4
```


I don't know if it helps, but if you do the same calculation over ZZ, you get the desired result.



---

archive/issue_comments_211478.json:
```json
{
    "body": "Replying to [comment:28 nthiery]:\n> I don't know if it helps, but if you do the same calculation over ZZ, you get the desired result.\n\nIt helps to get a nicer normalisation. However, the main problem is that my formula is plain wrong.",
    "created_at": "2014-09-16T22:31:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211478",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:28 nthiery]:
> I don't know if it helps, but if you do the same calculation over ZZ, you get the desired result.

It helps to get a nicer normalisation. However, the main problem is that my formula is plain wrong.



---

archive/issue_comments_211479.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-28T14:29:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211479",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211480.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-09-28T14:35:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211480",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211481.json:
```json
{
    "body": "I gave up path counting. Hence, I preserved the counting of *all* paths (which is correctly implemented), but I removed the function that was supposed to count those paths which do not contain a sub-path out of a finite list. It is broken, and I currently don't know how to fix it. So, better get the working bits into Sage ASAP. Needs review.",
    "created_at": "2014-09-28T14:35:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211481",
    "user": "https://github.com/simon-king-jena"
}
```

I gave up path counting. Hence, I preserved the counting of *all* paths (which is correctly implemented), but I removed the function that was supposed to count those paths which do not contain a sub-path out of a finite list. It is broken, and I currently don't know how to fix it. So, better get the working bits into Sage ASAP. Needs review.



---

archive/issue_comments_211482.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-18T22:27:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211482",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211483.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-21T14:43:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211483",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211484.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-21T22:42:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211484",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211485.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2014-10-23T14:11:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211485",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_211486.json:
```json
{
    "body": "Note for the reviewer (if there is any...): The previous merges have all been needed because of changed interface or changed import locations. Hence, non-trivial merges.",
    "created_at": "2014-10-23T14:14:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211486",
    "user": "https://github.com/simon-king-jena"
}
```

Note for the reviewer (if there is any...): The previous merges have all been needed because of changed interface or changed import locations. Hence, non-trivial merges.



---

archive/issue_comments_211487.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2014-10-29T14:10:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211487",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_211488.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-20T11:18:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211488",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211489.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-11-20T11:47:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211489",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211490.json:
```json
{
    "body": "After resolving the merge conflict, some test of bounded integer sequences fails. Note that it works fine if one just merges `develop` into #15820. So, the problem has apparently been created here, and thus it should be fixed here.",
    "created_at": "2014-11-20T11:47:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211490",
    "user": "https://github.com/simon-king-jena"
}
```

After resolving the merge conflict, some test of bounded integer sequences fails. Note that it works fine if one just merges `develop` into #15820. So, the problem has apparently been created here, and thus it should be fixed here.



---

archive/issue_comments_211491.json:
```json
{
    "body": "The corner case\n\n```\n        sage: S = BoundedIntegerSequence(8,[])\n        sage: S\n        <>\n        sage: loads(dumps(S)) == S\n        True\n```\n\nfails.",
    "created_at": "2014-11-20T11:49:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211491",
    "user": "https://github.com/simon-king-jena"
}
```

The corner case

```
        sage: S = BoundedIntegerSequence(8,[])
        sage: S
        <>
        sage: loads(dumps(S)) == S
        True
```

fails.



---

archive/issue_comments_211492.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-20T11:53:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211492",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211493.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-11-20T11:56:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211493",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211494.json:
```json
{
    "body": "Fixed.",
    "created_at": "2014-11-20T11:56:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211494",
    "user": "https://github.com/simon-king-jena"
}
```

Fixed.



---

archive/issue_comments_211495.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2014-12-05T08:58:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211495",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_211496.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-12-06T14:05:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211496",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211497.json:
```json
{
    "body": "I really don't see how something can be reviewed if a dependency doesn't automatically merge. Thus, the new merge commit. Sorry for git fanatics.",
    "created_at": "2014-12-06T14:26:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211497",
    "user": "https://github.com/simon-king-jena"
}
```

I really don't see how something can be reviewed if a dependency doesn't automatically merge. Thus, the new merge commit. Sorry for git fanatics.



---

archive/issue_comments_211498.json:
```json
{
    "body": "Is this change needed?\n\n```diff\ndiff --git a/src/sage/data_structures/bounded_integer_sequences.pyx b/src/sage/data_structures/bounded_integer_sequences.pyx\nindex 0ff59d8..29868ff 100644\n--- a/src/sage/data_structures/bounded_integer_sequences.pyx\n+++ b/src/sage/data_structures/bounded_integer_sequences.pyx\n@@ -714,7 +714,7 @@ cdef class BoundedIntegerSequence:\n             True\n \n         \"\"\"\n-        return NewBISEQ, (bitset_pickle(self.data.data), self.data.itembitsize, self.data.length)\n+        return NewBISEQ, (bitset_pickle(self.data.data) if self.data.length>0 else (), self.data.itembitsize, self.data.length)\n \n     def __len__(self):\n         \"\"\"\n@@ -1357,7 +1357,7 @@ cpdef BoundedIntegerSequence NewBISEQ(tuple bitset_data, mp_bitcnt_t itembitsize\n     # bitset_unpickle assumes that out.data.data is initialised.\n     biseq_init(out.data, length, itembitsize)\n     sig_on()\n-    bitset_unpickle(out.data.data, bitset_data)\n+    if bitset_data: bitset_unpickle(out.data.data, bitset_data)\n     sig_off()\n     return out\n \n```\n",
    "created_at": "2014-12-06T14:55:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211498",
    "user": "https://github.com/jdemeyer"
}
```

Is this change needed?

```diff
diff --git a/src/sage/data_structures/bounded_integer_sequences.pyx b/src/sage/data_structures/bounded_integer_sequences.pyx
index 0ff59d8..29868ff 100644
--- a/src/sage/data_structures/bounded_integer_sequences.pyx
+++ b/src/sage/data_structures/bounded_integer_sequences.pyx
@@ -714,7 +714,7 @@ cdef class BoundedIntegerSequence:
             True
 
         """
-        return NewBISEQ, (bitset_pickle(self.data.data), self.data.itembitsize, self.data.length)
+        return NewBISEQ, (bitset_pickle(self.data.data) if self.data.length>0 else (), self.data.itembitsize, self.data.length)
 
     def __len__(self):
         """
@@ -1357,7 +1357,7 @@ cpdef BoundedIntegerSequence NewBISEQ(tuple bitset_data, mp_bitcnt_t itembitsize
     # bitset_unpickle assumes that out.data.data is initialised.
     biseq_init(out.data, length, itembitsize)
     sig_on()
-    bitset_unpickle(out.data.data, bitset_data)
+    if bitset_data: bitset_unpickle(out.data.data, bitset_data)
     sig_off()
     return out
 
```




---

archive/issue_comments_211499.json:
```json
{
    "body": "Why so many includes in `src/sage/quivers/paths.pxd`? You should try to limit the includes to what you really need. Otherwise you're adding unneeded dependencies leading to more and slower recompiles. You should add the following change (plus moving some includes which you need in the `.pyx` file to the `.pyx` file)\n\n\n```diff\ndiff --git a/src/sage/quivers/paths.pxd b/src/sage/quivers/paths.pxd\nindex fd187fc..da7e8fb 100644\n--- a/src/sage/quivers/paths.pxd\n+++ b/src/sage/quivers/paths.pxd\n@@ -1,16 +1,5 @@\n-from sage.structure.element cimport MonoidElement, Element\n-from sage.data_structures.bounded_integer_sequences cimport *\n-from sage.libs.gmp.types cimport *\n-from sage.libs.gmp.mpn cimport mpn_cmp\n-\n-include \"sage/ext/python.pxi\"\n-include \"sage/ext/cdefs.pxi\"\n-include \"sage/ext/stdsage.pxi\"\n-include \"sage/libs/ntl/decl.pxi\"\n-include \"sage/ext/interrupt.pxi\"\n-\n-cdef extern from \"Python.h\":\n-    bint PySlice_Check(PyObject* ob)\n+from sage.structure.element cimport MonoidElement\n+from sage.data_structures.bounded_integer_sequences cimport biseq_t\n \n cdef class QuiverPath(MonoidElement):\n     cdef biseq_t _path\n```\n",
    "created_at": "2014-12-06T15:04:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211499",
    "user": "https://github.com/jdemeyer"
}
```

Why so many includes in `src/sage/quivers/paths.pxd`? You should try to limit the includes to what you really need. Otherwise you're adding unneeded dependencies leading to more and slower recompiles. You should add the following change (plus moving some includes which you need in the `.pyx` file to the `.pyx` file)


```diff
diff --git a/src/sage/quivers/paths.pxd b/src/sage/quivers/paths.pxd
index fd187fc..da7e8fb 100644
--- a/src/sage/quivers/paths.pxd
+++ b/src/sage/quivers/paths.pxd
@@ -1,16 +1,5 @@
-from sage.structure.element cimport MonoidElement, Element
-from sage.data_structures.bounded_integer_sequences cimport *
-from sage.libs.gmp.types cimport *
-from sage.libs.gmp.mpn cimport mpn_cmp
-
-include "sage/ext/python.pxi"
-include "sage/ext/cdefs.pxi"
-include "sage/ext/stdsage.pxi"
-include "sage/libs/ntl/decl.pxi"
-include "sage/ext/interrupt.pxi"
-
-cdef extern from "Python.h":
-    bint PySlice_Check(PyObject* ob)
+from sage.structure.element cimport MonoidElement
+from sage.data_structures.bounded_integer_sequences cimport biseq_t
 
 cdef class QuiverPath(MonoidElement):
     cdef biseq_t _path
```




---

archive/issue_comments_211500.json:
```json
{
    "body": "Also recall that you can `cimport` the `PySlice` functions `from cpython.slice`.",
    "created_at": "2014-12-06T15:05:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211500",
    "user": "https://github.com/jdemeyer"
}
```

Also recall that you can `cimport` the `PySlice` functions `from cpython.slice`.



---

archive/issue_comments_211501.json:
```json
{
    "body": "I use mpn_cmp and I use several `biseq_*` functions. So, I need to cimport stuff. You are right about the gmp.types and ntl/decl. \n\nAlso I should probably use sig_on (around the raw bitset operations), so, better leave ext/interrupt in.\n\nBut I'll soon provide a commit that reduces the imports.",
    "created_at": "2014-12-06T16:12:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211501",
    "user": "https://github.com/simon-king-jena"
}
```

I use mpn_cmp and I use several `biseq_*` functions. So, I need to cimport stuff. You are right about the gmp.types and ntl/decl. 

Also I should probably use sig_on (around the raw bitset operations), so, better leave ext/interrupt in.

But I'll soon provide a commit that reduces the imports.



---

archive/issue_comments_211502.json:
```json
{
    "body": "Replying to [comment:49 SimonKing]:\n> I use mpn_cmp and I use several `biseq_*` functions. So, I need to cimport stuff.\nYes, in the `.pyx` file, not the `.pxd` file.",
    "created_at": "2014-12-06T16:14:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211502",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:49 SimonKing]:
> I use mpn_cmp and I use several `biseq_*` functions. So, I need to cimport stuff.
Yes, in the `.pyx` file, not the `.pxd` file.



---

archive/issue_comments_211503.json:
```json
{
    "body": "Replying to [comment:50 jdemeyer]:\n> Replying to [comment:49 SimonKing]:\n> > I use mpn_cmp and I use several `biseq_*` functions. So, I need to cimport stuff.\n> Yes, in the `.pyx` file, not the `.pxd` file.\n\nNot?? I thought that it is one of the jobs of the `.pxd` file to do cimports.",
    "created_at": "2014-12-06T16:37:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211503",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:50 jdemeyer]:
> Replying to [comment:49 SimonKing]:
> > I use mpn_cmp and I use several `biseq_*` functions. So, I need to cimport stuff.
> Yes, in the `.pyx` file, not the `.pxd` file.

Not?? I thought that it is one of the jobs of the `.pxd` file to do cimports.



---

archive/issue_comments_211504.json:
```json
{
    "body": "Replying to [comment:46 jdemeyer]:\n> Is this change needed?\n> {{{\n> #!diff\n> diff --git a/src/sage/data_structures/bounded_integer_sequences.pyx b/src/sage/data_structures/bounded_integer_sequences.pyx\n> index 0ff59d8..29868ff 100644\n> --- a/src/sage/data_structures/bounded_integer_sequences.pyx\n> +++ b/src/sage/data_structures/bounded_integer_sequences.pyx\n> `@``@` -714,7 +714,7 `@``@` cdef class BoundedIntegerSequence:\n>              True\n>  \n>          \"\"\"\n> -        return NewBISEQ, (bitset_pickle(self.data.data), self.data.itembitsize, self.data.length)\n> +        return NewBISEQ, (bitset_pickle(self.data.data) if self.data.length>0 else (), self.data.itembitsize, self.data.length)\n>  \n>      def __len__(self):\n>          \"\"\"\n> `@``@` -1357,7 +1357,7 `@``@` cpdef BoundedIntegerSequence NewBISEQ(tuple bitset_data, mp_bitcnt_t itembitsize\n>      # bitset_unpickle assumes that out.data.data is initialised.\n>      biseq_init(out.data, length, itembitsize)\n>      sig_on()\n> -    bitset_unpickle(out.data.data, bitset_data)\n> +    if bitset_data: bitset_unpickle(out.data.data, bitset_data)\n>      sig_off()\n>      return out\n>  \n> }}}\n\nAt one point it was needed, and I think I added a test catching it. Perhaps the underlying problem has now been fixed on the level of bounded integer sequences or even on the level of bitsets. I need to check...",
    "created_at": "2014-12-06T16:38:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211504",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:46 jdemeyer]:
> Is this change needed?
> {{{
> #!diff
> diff --git a/src/sage/data_structures/bounded_integer_sequences.pyx b/src/sage/data_structures/bounded_integer_sequences.pyx
> index 0ff59d8..29868ff 100644
> --- a/src/sage/data_structures/bounded_integer_sequences.pyx
> +++ b/src/sage/data_structures/bounded_integer_sequences.pyx
> `@``@` -714,7 +714,7 `@``@` cdef class BoundedIntegerSequence:
>              True
>  
>          """
> -        return NewBISEQ, (bitset_pickle(self.data.data), self.data.itembitsize, self.data.length)
> +        return NewBISEQ, (bitset_pickle(self.data.data) if self.data.length>0 else (), self.data.itembitsize, self.data.length)
>  
>      def __len__(self):
>          """
> `@``@` -1357,7 +1357,7 `@``@` cpdef BoundedIntegerSequence NewBISEQ(tuple bitset_data, mp_bitcnt_t itembitsize
>      # bitset_unpickle assumes that out.data.data is initialised.
>      biseq_init(out.data, length, itembitsize)
>      sig_on()
> -    bitset_unpickle(out.data.data, bitset_data)
> +    if bitset_data: bitset_unpickle(out.data.data, bitset_data)
>      sig_off()
>      return out
>  
> }}}

At one point it was needed, and I think I added a test catching it. Perhaps the underlying problem has now been fixed on the level of bounded integer sequences or even on the level of bitsets. I need to check...



---

archive/issue_comments_211505.json:
```json
{
    "body": "PS: If it *is* needed, then I guess it should be moved to #15820. However, this would probably mean to change git history, isn't it?",
    "created_at": "2014-12-06T16:40:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211505",
    "user": "https://github.com/simon-king-jena"
}
```

PS: If it *is* needed, then I guess it should be moved to #15820. However, this would probably mean to change git history, isn't it?



---

archive/issue_comments_211506.json:
```json
{
    "body": "Replying to [comment:51 SimonKing]:\n> I thought that it is one of the jobs of the `.pxd` file to do cimports.\nNo, think of `.pxd` file like C `.h` files: it is needed for *other* modules to cimport this module: if another module does `from sage.quivers.paths cimport *`, then Cython will use the `paths.pxd` to do this cimport.\n\nThat's also the reason why the `.pxd` files should be minimal: every module which cimports `sage.quivers.paths` will need to look at all the stuff you put in the `paths.pxd` file.",
    "created_at": "2014-12-06T16:45:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211506",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:51 SimonKing]:
> I thought that it is one of the jobs of the `.pxd` file to do cimports.
No, think of `.pxd` file like C `.h` files: it is needed for *other* modules to cimport this module: if another module does `from sage.quivers.paths cimport *`, then Cython will use the `paths.pxd` to do this cimport.

That's also the reason why the `.pxd` files should be minimal: every module which cimports `sage.quivers.paths` will need to look at all the stuff you put in the `paths.pxd` file.



---

archive/issue_comments_211507.json:
```json
{
    "body": "It turns out that the change to pickling of bounded integer sequences isn't needed. So, I'll remove it.",
    "created_at": "2014-12-06T16:45:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211507",
    "user": "https://github.com/simon-king-jena"
}
```

It turns out that the change to pickling of bounded integer sequences isn't needed. So, I'll remove it.



---

archive/issue_comments_211508.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-12-06T17:23:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211508",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211509.json:
```json
{
    "body": "Hope it's better now...",
    "created_at": "2014-12-06T17:24:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211509",
    "user": "https://github.com/simon-king-jena"
}
```

Hope it's better now...



---

archive/issue_comments_211510.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-12-06T17:25:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211510",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211511.json:
```json
{
    "body": "Currently, I encode paths as a sequence of integers, where each integer uniquely determines an arrow in the quiver: The integers are bounded from above by the number of oriented arrows of the quiver.\n\nThere would be an alternative, sparser encoding as a sequence of integers, if one additionally provides the starting point: Each integer uniquely determines an outgoing arrow at one given vertex. \n\nExample: Assume that the underlying graph is just a cycle formed by 8 edges, and we have one arrow in each direction for each edge. Let x be the starting vertex of arrow 1, and the consecutive arrows in an oriented circle are numbered 1,...,8, and in the opposite circle are numbered 9,...16. Then, to encode the cycle starting at x, we currently present it as `<1,2,3,4,5,6,7,8>` in one and `<9,10,11,12,13,14,15,16>` in the other orientation.\n\nBut with the alternative encoding, we observe that there is exactly two outgoing arrows at each vertex. One directed circle starting at x could just be encoded as `(x, <1,1,1,1,1,1,1,1>)` and the opposite direction as `(x, <2,2,2,2,2,2,2,2>)`.\n\nIn other words, the bounded integer sequence in the current implementation has bound 17, but in the alternative implementation only has bound 3. It require less memory and thus some arithmetic operations might be faster. Detection of a sub-path will be slower, since it involves more work than testing a sub-sequence of a bounded integer sequence.\n\nI am not sure what will be better for my application (computing Gr\u00f6bner bases does involve detection of sub-paths!).\n\nMy strategical question: Can I wait with the decision of what implementation to choose? Should it better be settled right away?\n\nActually, some operations (such as concatenation!) would stay exactly the same as they are now, and also note that currently I store start and end point of a path as cdef attributes of the path anyway. So, it may even be possible to have a parameter to choose the implementation at run time.\n\nWhat do you think of it?",
    "created_at": "2014-12-06T21:32:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211511",
    "user": "https://github.com/simon-king-jena"
}
```

Currently, I encode paths as a sequence of integers, where each integer uniquely determines an arrow in the quiver: The integers are bounded from above by the number of oriented arrows of the quiver.

There would be an alternative, sparser encoding as a sequence of integers, if one additionally provides the starting point: Each integer uniquely determines an outgoing arrow at one given vertex. 

Example: Assume that the underlying graph is just a cycle formed by 8 edges, and we have one arrow in each direction for each edge. Let x be the starting vertex of arrow 1, and the consecutive arrows in an oriented circle are numbered 1,...,8, and in the opposite circle are numbered 9,...16. Then, to encode the cycle starting at x, we currently present it as `<1,2,3,4,5,6,7,8>` in one and `<9,10,11,12,13,14,15,16>` in the other orientation.

But with the alternative encoding, we observe that there is exactly two outgoing arrows at each vertex. One directed circle starting at x could just be encoded as `(x, <1,1,1,1,1,1,1,1>)` and the opposite direction as `(x, <2,2,2,2,2,2,2,2>)`.

In other words, the bounded integer sequence in the current implementation has bound 17, but in the alternative implementation only has bound 3. It require less memory and thus some arithmetic operations might be faster. Detection of a sub-path will be slower, since it involves more work than testing a sub-sequence of a bounded integer sequence.

I am not sure what will be better for my application (computing Gröbner bases does involve detection of sub-paths!).

My strategical question: Can I wait with the decision of what implementation to choose? Should it better be settled right away?

Actually, some operations (such as concatenation!) would stay exactly the same as they are now, and also note that currently I store start and end point of a path as cdef attributes of the path anyway. So, it may even be possible to have a parameter to choose the implementation at run time.

What do you think of it?



---

archive/issue_comments_211512.json:
```json
{
    "body": "I wouldn't worry about the bounds of your integers, I would guess that fast operations are more important. But if you really care, you need to benchmark...",
    "created_at": "2014-12-06T21:50:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211512",
    "user": "https://github.com/jdemeyer"
}
```

I wouldn't worry about the bounds of your integers, I would guess that fast operations are more important. But if you really care, you need to benchmark...



---

archive/issue_comments_211513.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-12-08T15:50:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211513",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211514.json:
```json
{
    "body": "Replying to [comment:60 jdemeyer]:\n> I wouldn't worry about the bounds of your integers, I would guess that fast operations are more important.\n\nThe point is that the speed of most operations depends on the bound of the integers. And the bound of the integers depends on the encoding.\n\n> But if you really care, you need to benchmark...\n\nIn the latest commit, I allow to choose between two implementations. The choice happens when creating a path semigroup. Of course, having two implementations *in a single element class* is not optimal. I did it in this way in order to be able to do some benchmarks. Later, we should either pick a single implementation once and for all, or we should provide two distinct element classes for the two implementations.\n\nNext, I'll try to come up with meaningful benchmarks.",
    "created_at": "2014-12-08T15:55:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211514",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:60 jdemeyer]:
> I wouldn't worry about the bounds of your integers, I would guess that fast operations are more important.

The point is that the speed of most operations depends on the bound of the integers. And the bound of the integers depends on the encoding.

> But if you really care, you need to benchmark...

In the latest commit, I allow to choose between two implementations. The choice happens when creating a path semigroup. Of course, having two implementations *in a single element class* is not optimal. I did it in this way in order to be able to do some benchmarks. Later, we should either pick a single implementation once and for all, or we should provide two distinct element classes for the two implementations.

Next, I'll try to come up with meaningful benchmarks.



---

archive/issue_comments_211515.json:
```json
{
    "body": "In my applications, I will likely use paths as dictionary keys, I will multiply them, I will (for two-sided modules) test subpath containment or (for right modules) detect initial segments, and I will extract sub-paths.\n\nThe following benchmark may thus be representative for what is needed for two-sided modules:\n\n```\nsage: def test1(p1,p2):\n....:     D = {}\n....:     for i in range(1,100):\n....:         D[p2^i*p1*p2^i] = i\n....:     q = p2^10*p1*p2^50\n....:     for x in D.keys():\n....:         assert x.has_subpath(q) or D[x] < 50\n....:     q = p2*p1*p2^120\n....:     for x in D.keys():\n....:         assert q.has_initial_segment(x[(D[x]-1)*len(p2):])\n....:         \n```\n\nLet's apply this to the dense encoding:\n\n```\nsage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()\nsage: S.inject_variables()\nDefining e_0, e_1, e_2, a, b, c, d, e, f\nsage: p1 = a*d*c*b*f*e\nsage: p2 = b*e*a*c\nsage: %timeit test1(p1,p2)\n1 loops, best of 3: 420 ms per loop\n```\n\nAnd for the non-dense encoding:\n\n```\nsage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup(False)\nsage: S.inject_variables()\nDefining e_0, e_1, e_2, a, b, c, d, e, f\nsage: p1 = a*d*c*b*f*e\nsage: p2 = b*e*a*c\nsage: %timeit test1(p1,p2)\n100 loops, best of 3: 4.26 ms per loop\n```\n\n\nThe following benchmark hopefully addresses the tasks that are important in the case of right modules:\n\n```\nsage: def test2(p1,p2):\n....:     D = {}\n....:     for i in range(1,100):\n....:         D[p2^i*p1*p2^i] = i\n....:     q = p2^10*p1*p2^50\n....:     for x in D.keys():\n....:         assert D[x]<10 or (x[(D[x]-10)*len(p2):].has_initial_segment(q) or D[x]<50)\n....:         \n```\n\nIn the dense encoding:\n\n```\nsage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()\nsage: S.inject_variables()\nDefining e_0, e_1, e_2, a, b, c, d, e, f\nsage: p1 = a*d*c*b*f*e\nsage: p2 = b*e*a*c\nsage: %timeit test2(p1,p2)\n1 loops, best of 3: 306 ms per loop\n```\n\nVersus the non-dense:\n\n```\nsage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup(False)\nsage: S.inject_variables()\nDefining e_0, e_1, e_2, a, b, c, d, e, f\nsage: p1 = a*d*c*b*f*e\nsage: p2 = b*e*a*c\nsage: %timeit test2(p1,p2)\n100 loops, best of 3: 3.99 ms per loop\n```\n\n\nThe last benchmark shows that I should certainly avoid computing overlap (gcd) in the dense encoding:\n\n```\nsage: def test3(p1,p2):\n....:     D = {}\n....:     for i in range(1,100):\n....:         D[p2^i*p1*p2^i] = i\n....:     q = p2^10*p1*p2^50\n....:     for x in D.keys():\n....:         assert D[x]<10 or (x[(D[x]-10)*len(p2):].has_initial_segment(q) or D[x]<50)\n....:     q = p2*p1*p2^120\n....:     for x in D.keys():\n....:         assert all(q.gcd(x))\n....:         \n```\n\nThe dense encoding:\n\n```\nsage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()\nsage: S.inject_variables()\nDefining e_0, e_1, e_2, a, b, c, d, e, f\nsage: p1 = a*d*c*b*f*e\nsage: p2 = b*e*a*c\nsage: %timeit test3(p1,p2)\n1 loops, best of 3: 1.44 s per loop\n```\n\nThe non-dense encoding:\n\n```\nsage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup(False)\nsage: S.inject_variables()\nDefining e_0, e_1, e_2, a, b, c, d, e, f\nsage: p1 = a*d*c*b*f*e\nsage: p2 = b*e*a*c\nsage: %timeit test3(p1,p2)\n100 loops, best of 3: 9.31 ms per loop\n```\n\n\nLooks like the non-dense encoding beats the dense encoding in all tests. However, in the following test, the dense encoding is slightly faster:\n\n```\nsage: def test4(p1,p2):                                                          \n....:     D = {}\n....:     for i in range(1,100):\n....:         D[p2^i*p1*p2^i] = i\n....:     q = p2^10 \n....:     for x in D.keys():\n....:         assert x.has_initial_segment(q) or D[x]<10\n....:         \n```\n\nDense:\n\n```\nsage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()\nsage: S.inject_variables()\nDefining e_0, e_1, e_2, a, b, c, d, e, f\nsage: p1 = a*d*c*b*f*e\nsage: p2 = b*e*a*c\nsage: %timeit test4(p1,p2)\n1000 loops, best of 3: 1.47 ms per loop\n```\n\nNon-dense:\n\n```\nsage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup(False)\nsage: S.inject_variables()\nDefining e_0, e_1, e_2, a, b, c, d, e, f\nsage: p1 = a*d*c*b*f*e\nsage: p2 = b*e*a*c\nsage: %timeit test4(p1,p2)\n1000 loops, best of 3: 1.57 ms per loop\n```\n\n\n__Conclusion__\n\nIt seems to me that the dense encoding may be an interesting idea, but for most (if not all) applications is not better than the simpler non-dense encoding.\n\n__Question__\n\nShall I simply remove the dense implementation? Or should I turn it into a separate element class, so that a potential user may benefit from alternative implementations?",
    "created_at": "2014-12-08T22:37:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211515",
    "user": "https://github.com/simon-king-jena"
}
```

In my applications, I will likely use paths as dictionary keys, I will multiply them, I will (for two-sided modules) test subpath containment or (for right modules) detect initial segments, and I will extract sub-paths.

The following benchmark may thus be representative for what is needed for two-sided modules:

```
sage: def test1(p1,p2):
....:     D = {}
....:     for i in range(1,100):
....:         D[p2^i*p1*p2^i] = i
....:     q = p2^10*p1*p2^50
....:     for x in D.keys():
....:         assert x.has_subpath(q) or D[x] < 50
....:     q = p2*p1*p2^120
....:     for x in D.keys():
....:         assert q.has_initial_segment(x[(D[x]-1)*len(p2):])
....:         
```

Let's apply this to the dense encoding:

```
sage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()
sage: S.inject_variables()
Defining e_0, e_1, e_2, a, b, c, d, e, f
sage: p1 = a*d*c*b*f*e
sage: p2 = b*e*a*c
sage: %timeit test1(p1,p2)
1 loops, best of 3: 420 ms per loop
```

And for the non-dense encoding:

```
sage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup(False)
sage: S.inject_variables()
Defining e_0, e_1, e_2, a, b, c, d, e, f
sage: p1 = a*d*c*b*f*e
sage: p2 = b*e*a*c
sage: %timeit test1(p1,p2)
100 loops, best of 3: 4.26 ms per loop
```


The following benchmark hopefully addresses the tasks that are important in the case of right modules:

```
sage: def test2(p1,p2):
....:     D = {}
....:     for i in range(1,100):
....:         D[p2^i*p1*p2^i] = i
....:     q = p2^10*p1*p2^50
....:     for x in D.keys():
....:         assert D[x]<10 or (x[(D[x]-10)*len(p2):].has_initial_segment(q) or D[x]<50)
....:         
```

In the dense encoding:

```
sage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()
sage: S.inject_variables()
Defining e_0, e_1, e_2, a, b, c, d, e, f
sage: p1 = a*d*c*b*f*e
sage: p2 = b*e*a*c
sage: %timeit test2(p1,p2)
1 loops, best of 3: 306 ms per loop
```

Versus the non-dense:

```
sage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup(False)
sage: S.inject_variables()
Defining e_0, e_1, e_2, a, b, c, d, e, f
sage: p1 = a*d*c*b*f*e
sage: p2 = b*e*a*c
sage: %timeit test2(p1,p2)
100 loops, best of 3: 3.99 ms per loop
```


The last benchmark shows that I should certainly avoid computing overlap (gcd) in the dense encoding:

```
sage: def test3(p1,p2):
....:     D = {}
....:     for i in range(1,100):
....:         D[p2^i*p1*p2^i] = i
....:     q = p2^10*p1*p2^50
....:     for x in D.keys():
....:         assert D[x]<10 or (x[(D[x]-10)*len(p2):].has_initial_segment(q) or D[x]<50)
....:     q = p2*p1*p2^120
....:     for x in D.keys():
....:         assert all(q.gcd(x))
....:         
```

The dense encoding:

```
sage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()
sage: S.inject_variables()
Defining e_0, e_1, e_2, a, b, c, d, e, f
sage: p1 = a*d*c*b*f*e
sage: p2 = b*e*a*c
sage: %timeit test3(p1,p2)
1 loops, best of 3: 1.44 s per loop
```

The non-dense encoding:

```
sage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup(False)
sage: S.inject_variables()
Defining e_0, e_1, e_2, a, b, c, d, e, f
sage: p1 = a*d*c*b*f*e
sage: p2 = b*e*a*c
sage: %timeit test3(p1,p2)
100 loops, best of 3: 9.31 ms per loop
```


Looks like the non-dense encoding beats the dense encoding in all tests. However, in the following test, the dense encoding is slightly faster:

```
sage: def test4(p1,p2):                                                          
....:     D = {}
....:     for i in range(1,100):
....:         D[p2^i*p1*p2^i] = i
....:     q = p2^10 
....:     for x in D.keys():
....:         assert x.has_initial_segment(q) or D[x]<10
....:         
```

Dense:

```
sage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup()
sage: S.inject_variables()
Defining e_0, e_1, e_2, a, b, c, d, e, f
sage: p1 = a*d*c*b*f*e
sage: p2 = b*e*a*c
sage: %timeit test4(p1,p2)
1000 loops, best of 3: 1.47 ms per loop
```

Non-dense:

```
sage: S = DiGraph({0:{1:['a'], 2:['b']}, 1:{0:['c'], 1:['d']}, 2:{0:['e'],2:['f']}}).path_semigroup(False)
sage: S.inject_variables()
Defining e_0, e_1, e_2, a, b, c, d, e, f
sage: p1 = a*d*c*b*f*e
sage: p2 = b*e*a*c
sage: %timeit test4(p1,p2)
1000 loops, best of 3: 1.57 ms per loop
```


__Conclusion__

It seems to me that the dense encoding may be an interesting idea, but for most (if not all) applications is not better than the simpler non-dense encoding.

__Question__

Shall I simply remove the dense implementation? Or should I turn it into a separate element class, so that a potential user may benefit from alternative implementations?



---

archive/issue_comments_211516.json:
```json
{
    "body": "Replying to [comment:63 SimonKing]:\n> Shall I simply remove the dense implementation? Or should I turn it into a separate element class, so that a potential user may benefit from alternative implementations?\n\nIf I were you, I would keep just one implementation.",
    "created_at": "2014-12-09T09:17:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211516",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:63 SimonKing]:
> Shall I simply remove the dense implementation? Or should I turn it into a separate element class, so that a potential user may benefit from alternative implementations?

If I were you, I would keep just one implementation.



---

archive/issue_comments_211517.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-12-09T11:37:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211517",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211518.json:
```json
{
    "body": "Replying to [comment:64 jdemeyer]:\n> If I were you, I would keep just one implementation.\n\nDone!",
    "created_at": "2014-12-09T11:38:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211518",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:64 jdemeyer]:
> If I were you, I would keep just one implementation.

Done!



---

archive/issue_comments_211519.json:
```json
{
    "body": "One failing doctest here:\n\n```\nFile \"src/sage/quivers/paths.pyx\", line 773, in sage.quivers.paths.NewQuiverPath\nFailed example:\n    p.__reduce__()\nExpected:\n    (<...NewQuiverPath>,\n     (Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices,\n      1,\n      3,\n      (0, 4L, 1, 4, (4L,)),\n      2L,\n      2))\nGot:\n    (<built-in function NewQuiverPath>,\n     (Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices,\n      1,\n      3,\n      (0, 4L, 1, 8, (4L,)),\n      2L,\n      2))\n```\n",
    "created_at": "2014-12-26T19:36:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211519",
    "user": "https://github.com/fchapoton"
}
```

One failing doctest here:

```
File "src/sage/quivers/paths.pyx", line 773, in sage.quivers.paths.NewQuiverPath
Failed example:
    p.__reduce__()
Expected:
    (<...NewQuiverPath>,
     (Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices,
      1,
      3,
      (0, 4L, 1, 4, (4L,)),
      2L,
      2))
Got:
    (<built-in function NewQuiverPath>,
     (Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices,
      1,
      3,
      (0, 4L, 1, 8, (4L,)),
      2L,
      2))
```




---

archive/issue_comments_211520.json:
```json
{
    "body": "I have corrected the formatting in several places in the doc in the public/ticket/16453 branch.\n----\nNew commits:",
    "created_at": "2014-12-26T19:50:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211520",
    "user": "https://github.com/fchapoton"
}
```

I have corrected the formatting in several places in the doc in the public/ticket/16453 branch.
----
New commits:



---

archive/issue_comments_211521.json:
```json
{
    "body": "Replying to [comment:67 chapoton]:\n> One failing doctest here:\n> {{{\n> File \"src/sage/quivers/paths.pyx\", line 773, in sage.quivers.paths.NewQuiverPath\n> Failed example:\n>     p.__reduce__()\n> Expected:\n>     (<...NewQuiverPath>,\n>      (Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices,\n>       1,\n>       3,\n>       (0, 4L, 1, 4, (4L,)),\n>       2L,\n>       2))\n> Got:\n>     (<built-in function NewQuiverPath>,\n>      (Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices,\n>       1,\n>       3,\n>       (0, 4L, 1, 8, (4L,)),\n>       2L,\n>       2))\n> }}}\n\nDid I not correct that error?\n\nToo bad, it could be that I corrected it in #17435, since I had the impression I had introduced it there. Well, with mercurial we could now simply move the patch from there to here...\n\nThe explanation of above error is of course that I made the tests on a 32bit machine, but you have 64bit. Meanwhile, I have switched to 64bit too, and at that point I corrected the error (but on the wrong ticket, I am afraid).",
    "created_at": "2014-12-27T09:48:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211521",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:67 chapoton]:
> One failing doctest here:
> {{{
> File "src/sage/quivers/paths.pyx", line 773, in sage.quivers.paths.NewQuiverPath
> Failed example:
>     p.__reduce__()
> Expected:
>     (<...NewQuiverPath>,
>      (Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices,
>       1,
>       3,
>       (0, 4L, 1, 4, (4L,)),
>       2L,
>       2))
> Got:
>     (<built-in function NewQuiverPath>,
>      (Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices,
>       1,
>       3,
>       (0, 4L, 1, 8, (4L,)),
>       2L,
>       2))
> }}}

Did I not correct that error?

Too bad, it could be that I corrected it in #17435, since I had the impression I had introduced it there. Well, with mercurial we could now simply move the patch from there to here...

The explanation of above error is of course that I made the tests on a 32bit machine, but you have 64bit. Meanwhile, I have switched to 64bit too, and at that point I corrected the error (but on the wrong ticket, I am afraid).



---

archive/issue_comments_211522.json:
```json
{
    "body": "Replying to [comment:69 SimonKing]:\n> Well, with mercurial we could now simply move the patch from there to here...\n\n... whereas now we will most likely get a merge conflict if we fix the same error here.",
    "created_at": "2014-12-27T09:49:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211522",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:69 SimonKing]:
> Well, with mercurial we could now simply move the patch from there to here...

... whereas now we will most likely get a merge conflict if we fix the same error here.



---

archive/issue_comments_211523.json:
```json
{
    "body": "See commit 880801f at #17435.",
    "created_at": "2014-12-27T09:51:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211523",
    "user": "https://github.com/simon-king-jena"
}
```

See commit 880801f at #17435.



---

archive/issue_comments_211524.json:
```json
{
    "body": "In any case, `(0, 4L, 1, 4, (4L,))` from the doctest should simply become `(0, 4L, 1, ..., (4L,))` so that both the output for 64 and 32 bit will be accepted.",
    "created_at": "2014-12-27T09:52:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211524",
    "user": "https://github.com/simon-king-jena"
}
```

In any case, `(0, 4L, 1, 4, (4L,))` from the doctest should simply become `(0, 4L, 1, ..., (4L,))` so that both the output for 64 and 32 bit will be accepted.



---

archive/issue_comments_211525.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-12-27T12:45:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211525",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211526.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-12-27T12:56:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211526",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211527.json:
```json
{
    "body": "Thank you for fixing this!\n\nI hope I understand correctly that I should not merge it into #17435 now. I think I have put #17435 to \"needs work\" because of merge issues. But if it works as it is, then, according to Volker, I should simply leave it, and postpone merging until being requested by either the reviewer or the release manager.",
    "created_at": "2014-12-28T00:14:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211527",
    "user": "https://github.com/simon-king-jena"
}
```

Thank you for fixing this!

I hope I understand correctly that I should not merge it into #17435 now. I think I have put #17435 to "needs work" because of merge issues. But if it works as it is, then, according to Volker, I should simply leave it, and postpone merging until being requested by either the reviewer or the release manager.



---

archive/issue_comments_211528.json:
```json
{
    "body": "In these 3 cases, why don't you use the corresponding `biseq` functions?\n\n```\nreturn mpn_cmp(cself._path.data.bits, other._path.data.bits, cself._path.data.limbs)\n```\n\n\n\n```\ncdef mp_limb_t* p = self._path.data.bits\nfor i from self._path.data.limbs>i>=0:\n    h0 = h\n    h += deref(postinc(p))\n    if h<h0: # overflow\n        preinc(h)\n```\n\n\n\n```\nout._path.itembitsize = itembitsize\nout._path.mask_item = limb_lower_bits_up(itembitsize)\nout._path.length = length\nif length>0:\n    sig_on()\n    bitset_init(out._path.data, 1)\n    bitset_unpickle(out._path.data, bitset_data)\n    sig_off()\n```\n\n(and the corresponding `bitset_pickle()` of course)",
    "created_at": "2014-12-28T21:07:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211528",
    "user": "https://github.com/jdemeyer"
}
```

In these 3 cases, why don't you use the corresponding `biseq` functions?

```
return mpn_cmp(cself._path.data.bits, other._path.data.bits, cself._path.data.limbs)
```



```
cdef mp_limb_t* p = self._path.data.bits
for i from self._path.data.limbs>i>=0:
    h0 = h
    h += deref(postinc(p))
    if h<h0: # overflow
        preinc(h)
```



```
out._path.itembitsize = itembitsize
out._path.mask_item = limb_lower_bits_up(itembitsize)
out._path.length = length
if length>0:
    sig_on()
    bitset_init(out._path.data, 1)
    bitset_unpickle(out._path.data, bitset_data)
    sig_off()
```

(and the corresponding `bitset_pickle()` of course)



---

archive/issue_comments_211529.json:
```json
{
    "body": "And this isn't really wrong:\n\n```\nfor i from 0<=i<self._path.length:\n```\n\nbut it's better expressed as\n\n```\nfor i in range(self._path.length):\n```\n",
    "created_at": "2014-12-28T21:15:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211529",
    "user": "https://github.com/jdemeyer"
}
```

And this isn't really wrong:

```
for i from 0<=i<self._path.length:
```

but it's better expressed as

```
for i in range(self._path.length):
```




---

archive/issue_comments_211530.json:
```json
{
    "body": "And since `_start` and `_end` are C ints, you might as well replace\n\n```\ncdef mp_limb_t h = (hash(self._start)<<4)^hash(self._end)\n```\n\nby something like\n\n```\ncdef Py_hash_t h = self._start*(<Py_hash_t>1073807360) + self._end\n```\n\n(note that hashes should use `Py_hash_t` as type)",
    "created_at": "2014-12-28T21:24:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211530",
    "user": "https://github.com/jdemeyer"
}
```

And since `_start` and `_end` are C ints, you might as well replace

```
cdef mp_limb_t h = (hash(self._start)<<4)^hash(self._end)
```

by something like

```
cdef Py_hash_t h = self._start*(<Py_hash_t>1073807360) + self._end
```

(note that hashes should use `Py_hash_t` as type)



---

archive/issue_comments_211531.json:
```json
{
    "body": "Replying to [comment:79 jdemeyer]:\n> And since `_start` and `_end` are C ints, you might as well replace\n> {{{\n> cdef mp_limb_t h = (hash(self._start)<<4)^hash(self._end)\n> }}}\n> by something like\n> {{{\n> cdef Py_hash_t h = self._start*(<Py_hash_t>1073807360) + self._end\n> }}}\n> (note that hashes should use `Py_hash_t` as type)\n\nNever heard of `Py_hash_t` before---I thought the hash is just a `long`. I guess you are right that the multiplication with a large number yields a better hash (by mixing the data) than a simple shift.",
    "created_at": "2014-12-29T01:32:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211531",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:79 jdemeyer]:
> And since `_start` and `_end` are C ints, you might as well replace
> {{{
> cdef mp_limb_t h = (hash(self._start)<<4)^hash(self._end)
> }}}
> by something like
> {{{
> cdef Py_hash_t h = self._start*(<Py_hash_t>1073807360) + self._end
> }}}
> (note that hashes should use `Py_hash_t` as type)

Never heard of `Py_hash_t` before---I thought the hash is just a `long`. I guess you are right that the multiplication with a large number yields a better hash (by mixing the data) than a simple shift.



---

archive/issue_comments_211532.json:
```json
{
    "body": "Replying to [comment:76 jdemeyer]:\n> In these 3 cases, why don't you use the corresponding `biseq` functions?\n> {{{\n> return mpn_cmp(cself._path.data.bits, other._path.data.bits, cself._path.data.limbs)\n> }}}\n\nThere is no dedicated comparison function for `biseq_t`. The comparison of `BoundedIntegerSequence` would first check the type of the given arguments (needed, since coercion is not involved), then compare the bounds of the two integer sequences, and finally call `bitset_cmp` (which mainly does `mpn_cmp`). But here, we already know (by coercion) that the two paths belong to the same semigroup, thus, have the same type and bound.\n\n> {{{\n> cdef mp_limb_t* p = self._path.data.bits\n> for i from self._path.data.limbs>i>=0:\n>     h0 = h\n>     h += deref(postinc(p))\n>     if h<h0: # overflow\n>         preinc(h)\n> }}}\n\nThat's for hash. Again, there is no dedicated hash function for `biseq_t`.\n\n> {{{\n> out._path.itembitsize = itembitsize\n> out._path.mask_item = limb_lower_bits_up(itembitsize)\n> out._path.length = length\n> if length>0:\n>     sig_on()\n>     bitset_init(out._path.data, 1)\n>     bitset_unpickle(out._path.data, bitset_data)\n>     sig_off()\n> }}}\n> (and the corresponding `bitset_pickle()` of course)\n\nPickling is defined for `BoundedIntegerSequence`, not for `biseq_t`.\n\nOr are you saying I *should* implement those functions on the level of `biseq_t`?",
    "created_at": "2014-12-29T01:44:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211532",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:76 jdemeyer]:
> In these 3 cases, why don't you use the corresponding `biseq` functions?
> {{{
> return mpn_cmp(cself._path.data.bits, other._path.data.bits, cself._path.data.limbs)
> }}}

There is no dedicated comparison function for `biseq_t`. The comparison of `BoundedIntegerSequence` would first check the type of the given arguments (needed, since coercion is not involved), then compare the bounds of the two integer sequences, and finally call `bitset_cmp` (which mainly does `mpn_cmp`). But here, we already know (by coercion) that the two paths belong to the same semigroup, thus, have the same type and bound.

> {{{
> cdef mp_limb_t* p = self._path.data.bits
> for i from self._path.data.limbs>i>=0:
>     h0 = h
>     h += deref(postinc(p))
>     if h<h0: # overflow
>         preinc(h)
> }}}

That's for hash. Again, there is no dedicated hash function for `biseq_t`.

> {{{
> out._path.itembitsize = itembitsize
> out._path.mask_item = limb_lower_bits_up(itembitsize)
> out._path.length = length
> if length>0:
>     sig_on()
>     bitset_init(out._path.data, 1)
>     bitset_unpickle(out._path.data, bitset_data)
>     sig_off()
> }}}
> (and the corresponding `bitset_pickle()` of course)

Pickling is defined for `BoundedIntegerSequence`, not for `biseq_t`.

Or are you saying I *should* implement those functions on the level of `biseq_t`?



---

archive/issue_comments_211533.json:
```json
{
    "body": "Replying to [comment:80 SimonKing]:\n> Never heard of `Py_hash_t` before---I thought the hash is just a `long`.\nThat's very likely true, but a `mp_limb_t` *isn't* a `long`, so the type needs fixing anyway. And using `Py_hash_t` is explicit, it's clear that you're computing a hash.",
    "created_at": "2014-12-29T21:26:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211533",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:80 SimonKing]:
> Never heard of `Py_hash_t` before---I thought the hash is just a `long`.
That's very likely true, but a `mp_limb_t` *isn't* a `long`, so the type needs fixing anyway. And using `Py_hash_t` is explicit, it's clear that you're computing a hash.



---

archive/issue_comments_211534.json:
```json
{
    "body": "Replying to [comment:81 SimonKing]:\n> Or are you saying I *should* implement those functions on the level of `biseq_t`?\nI never noticed that these functions aren't defined for `biseq_t`, but the answer is obviously: yes, they should be implemented on the level of `biseq_t` (in a different ticket).",
    "created_at": "2014-12-29T21:28:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211534",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:81 SimonKing]:
> Or are you saying I *should* implement those functions on the level of `biseq_t`?
I never noticed that these functions aren't defined for `biseq_t`, but the answer is obviously: yes, they should be implemented on the level of `biseq_t` (in a different ticket).



---

archive/issue_comments_211535.json:
```json
{
    "body": "Let me also mention that I do not intend to fully review this ticket, I only checked some technicalities and stuff related to #15820.",
    "created_at": "2014-12-29T21:28:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211535",
    "user": "https://github.com/jdemeyer"
}
```

Let me also mention that I do not intend to fully review this ticket, I only checked some technicalities and stuff related to #15820.



---

archive/issue_comments_211536.json:
```json
{
    "body": "Replying to [comment:83 jdemeyer]:\n> Replying to [comment:81 SimonKing]:\n> > Or are you saying I *should* implement those functions on the level of `biseq_t`?\n> I never noticed that these functions aren't defined for `biseq_t`, but the answer is obviously: yes, they should be implemented on the level of `biseq_t` (in a different ticket).\n\n... which would become a dependency for this ticket, right?",
    "created_at": "2014-12-29T21:41:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211536",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:83 jdemeyer]:
> Replying to [comment:81 SimonKing]:
> > Or are you saying I *should* implement those functions on the level of `biseq_t`?
> I never noticed that these functions aren't defined for `biseq_t`, but the answer is obviously: yes, they should be implemented on the level of `biseq_t` (in a different ticket).

... which would become a dependency for this ticket, right?



---

archive/issue_comments_211537.json:
```json
{
    "body": "I created #17564 for the additional biseq functions.",
    "created_at": "2014-12-30T09:20:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211537",
    "user": "https://github.com/simon-king-jena"
}
```

I created #17564 for the additional biseq functions.



---

archive/issue_comments_211538.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-12-30T09:20:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211538",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211539.json:
```json
{
    "body": "Recently I was told that I use too many merge commits.\n\nSo, question: Shall I rebase and force-push the branch here? Shall I merge the branch from #17564 into the branch here? What else?",
    "created_at": "2014-12-30T09:26:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211539",
    "user": "https://github.com/simon-king-jena"
}
```

Recently I was told that I use too many merge commits.

So, question: Shall I rebase and force-push the branch here? Shall I merge the branch from #17564 into the branch here? What else?



---

archive/issue_comments_211540.json:
```json
{
    "body": "I'm not going to discuss about the git stuff...\n\n(but personally: I would `merge --squash` this branch on top of #17564)",
    "created_at": "2014-12-30T10:19:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211540",
    "user": "https://github.com/jdemeyer"
}
```

I'm not going to discuss about the git stuff...

(but personally: I would `merge --squash` this branch on top of #17564)



---

archive/issue_comments_211541.json:
```json
{
    "body": "Replying to [comment:88 jdemeyer]:\n> I'm not going to discuss about the git stuff...\n> \n> (but personally: I would `merge --squash` this branch on top of #17564)\n\nSince I tend to get things wrong in git, I need more details.\n\nDo I understand correctly that you suggest to take all the commits from here, squash them into one commit, and force-push here. Thus:\n\n```\ngit checkout -b new_branch_for_here branch_17564\ngit merge --squash branch_from_here\ngit commit\ngit trac push --forced --ticket=16453\n```\n\n(or however a forced push is done).\n\nI am not sure that that's what I want. If I understood correctly what Nathann said, he as a reviewer prefers to have a sequence of commits each addressing a single feature, and ideally there should be no merge commits and no commits that simply revert the effect of previous mistaken commits. If Nathann reads it: Would this be what you'd like to get?\n\nSo, perhaps\n\n```\ngit checkout branch_from_here\ngit rebase -i branch_17564\n```\n\nfollowed by a forced push would be better, since then I can interactively choose which commits from here to squash and which to preserve.\n\nAnyway, I'd agree to force-push, even though #17435 is based on this ticket. Probably I am the only one who is actively using these branches.",
    "created_at": "2014-12-30T11:15:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211541",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:88 jdemeyer]:
> I'm not going to discuss about the git stuff...
> 
> (but personally: I would `merge --squash` this branch on top of #17564)

Since I tend to get things wrong in git, I need more details.

Do I understand correctly that you suggest to take all the commits from here, squash them into one commit, and force-push here. Thus:

```
git checkout -b new_branch_for_here branch_17564
git merge --squash branch_from_here
git commit
git trac push --forced --ticket=16453
```

(or however a forced push is done).

I am not sure that that's what I want. If I understood correctly what Nathann said, he as a reviewer prefers to have a sequence of commits each addressing a single feature, and ideally there should be no merge commits and no commits that simply revert the effect of previous mistaken commits. If Nathann reads it: Would this be what you'd like to get?

So, perhaps

```
git checkout branch_from_here
git rebase -i branch_17564
```

followed by a forced push would be better, since then I can interactively choose which commits from here to squash and which to preserve.

Anyway, I'd agree to force-push, even though #17435 is based on this ticket. Probably I am the only one who is actively using these branches.



---

archive/issue_comments_211542.json:
```json
{
    "body": "Replying to [comment:89 SimonKing]:\n> {{{\n> git checkout -b new_branch_for_here branch_17564\n> git merge --squash branch_from_here\n> git commit\n> git trac push --forced --ticket=16453\n> }}}\n> (or however a forced push is done).\n> \n> I am not sure that that's what I want. If I understood correctly what Nathann said, he as a reviewer prefers to have a sequence of commits each addressing a single feature, ...\n\nOn the other hand, I don't see how this could be naturally split into features. We have a relatively straight forward cython implementation of paths on top of bounded integer sequences, and we apply the new paths in `path_semigroup`. So, I guess a single commit should be easy enough to review.",
    "created_at": "2014-12-30T17:46:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211542",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:89 SimonKing]:
> {{{
> git checkout -b new_branch_for_here branch_17564
> git merge --squash branch_from_here
> git commit
> git trac push --forced --ticket=16453
> }}}
> (or however a forced push is done).
> 
> I am not sure that that's what I want. If I understood correctly what Nathann said, he as a reviewer prefers to have a sequence of commits each addressing a single feature, ...

On the other hand, I don't see how this could be naturally split into features. We have a relatively straight forward cython implementation of paths on top of bounded integer sequences, and we apply the new paths in `path_semigroup`. So, I guess a single commit should be easy enough to review.



---

archive/issue_comments_211543.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2014-12-30T18:56:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211543",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_211544.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-12-30T19:01:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211544",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211545.json:
```json
{
    "body": "I have rebased the branch on top of #17564, squashing the old commits into two commits (one for the Cython implementation, the other for applying the Cython implementation in Python modules).\n\nIt is a forced push, but I guess the new commit history is a lot clearer (and hopefully easier to review `;-)`!) than the old, and I also guess that nobody but me has used the branch, or was about to give a full review to the old branch.",
    "created_at": "2014-12-30T19:01:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211545",
    "user": "https://github.com/simon-king-jena"
}
```

I have rebased the branch on top of #17564, squashing the old commits into two commits (one for the Cython implementation, the other for applying the Cython implementation in Python modules).

It is a forced push, but I guess the new commit history is a lot clearer (and hopefully easier to review `;-)`!) than the old, and I also guess that nobody but me has used the branch, or was about to give a full review to the old branch.



---

archive/issue_comments_211546.json:
```json
{
    "body": "Hello Simon,\n\nThese paths have more applications than quivers (e.g. [train-tracks for free group automorphisms](https://github.com/coulbois/sage-train-track)). Could you move it from `src.sage.quivers` to `sage.graphs`? And also remove the name 'quivers' from there.. why not `GraphPaths`? Actually, for train track automorphisms one needs the groupoid of paths (that is authorize to take edges in reversed direction). As far as I understand, it is different from yours. Do you have an idea for a compatible terminology?\n\nVincent",
    "created_at": "2015-01-19T18:27:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211546",
    "user": "https://github.com/videlec"
}
```

Hello Simon,

These paths have more applications than quivers (e.g. [train-tracks for free group automorphisms](https://github.com/coulbois/sage-train-track)). Could you move it from `src.sage.quivers` to `sage.graphs`? And also remove the name 'quivers' from there.. why not `GraphPaths`? Actually, for train track automorphisms one needs the groupoid of paths (that is authorize to take edges in reversed direction). As far as I understand, it is different from yours. Do you have an idea for a compatible terminology?

Vincent



---

archive/issue_comments_211547.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-01-19T18:27:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211547",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_211548.json:
```json
{
    "body": "Hi Vincent,\n\nReplying to [comment:93 vdelecroix]:\n> These paths have more applications than quivers (e.g. [train-tracks for free group automorphisms](https://github.com/coulbois/sage-train-track)). Could you move it from `src.sage.quivers` to `sage.graphs`?\n\n`sage.graphs` is quite large already, that's why I created the new module `sage.quivers`, for everything that implements representation theoretic aspects of directed multigraphs.\n\nI could imagine to use cythoned path algebra elements (see #17435) to provide a better implementation of free associative algebras, but a potential application is no reason to move the code, IMHO.\n\nDo you really need oriented paths for train tracks? Or do you rather need sequences of integers to implement train tracks? If the integers are subject to a global bound, then see `sage.data_structures.bounded_integer_sequences`.\n\n> And also remove the name 'quivers' from there.. why not `GraphPaths`?\n\nMost people understand \"graph\" as a non-directed graph. But we are talking here about objects for which orientation is absolutely essential. The original Python code for quivers and their representation had to make a difference between two different notions of paths in a graph, one being a sequence of vertices, the other being a sequence of edges. `QuiverPaths` is about paths as sequences of *directed* edges.\n\nWhen developing the current Python code for quiver representations, there was some discussion about terminology. \"Quiver\" is a well-established mathematical notion, so, good to use. It is the same as multi-digraph, but is a shorter word. It seems that the decision was to use \"`DiGraph`\" in Sage to denote the mere directed graph, whereas one uses \"`Quiver`\" when one considers the directed graph as an algebraic object.\n\nWhile it may be acceptable to replace the word \"Quiver\" by \"`DiGraph`\", it can certainly not be replaced by the word \"Graph\". Hence, changing `QuiverPath` into `GraphPath` would be misleading. I am against that change.\n\n> Actually, for train track automorphisms one needs the groupoid of paths (that is authorize to take edges in reversed direction). As far as I understand, it is different from yours. Do you have an idea for a compatible terminology?\n\nWell, the current terminology for the algebraic object formed by the oriented paths in a multi-digraph subject to concatenation is \"path semigroup\", and thus the terminology for your groupoid of invertible paths would naturally be \"path groupoid\", isn't it?",
    "created_at": "2015-01-19T19:17:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211548",
    "user": "https://github.com/simon-king-jena"
}
```

Hi Vincent,

Replying to [comment:93 vdelecroix]:
> These paths have more applications than quivers (e.g. [train-tracks for free group automorphisms](https://github.com/coulbois/sage-train-track)). Could you move it from `src.sage.quivers` to `sage.graphs`?

`sage.graphs` is quite large already, that's why I created the new module `sage.quivers`, for everything that implements representation theoretic aspects of directed multigraphs.

I could imagine to use cythoned path algebra elements (see #17435) to provide a better implementation of free associative algebras, but a potential application is no reason to move the code, IMHO.

Do you really need oriented paths for train tracks? Or do you rather need sequences of integers to implement train tracks? If the integers are subject to a global bound, then see `sage.data_structures.bounded_integer_sequences`.

> And also remove the name 'quivers' from there.. why not `GraphPaths`?

Most people understand "graph" as a non-directed graph. But we are talking here about objects for which orientation is absolutely essential. The original Python code for quivers and their representation had to make a difference between two different notions of paths in a graph, one being a sequence of vertices, the other being a sequence of edges. `QuiverPaths` is about paths as sequences of *directed* edges.

When developing the current Python code for quiver representations, there was some discussion about terminology. "Quiver" is a well-established mathematical notion, so, good to use. It is the same as multi-digraph, but is a shorter word. It seems that the decision was to use "`DiGraph`" in Sage to denote the mere directed graph, whereas one uses "`Quiver`" when one considers the directed graph as an algebraic object.

While it may be acceptable to replace the word "Quiver" by "`DiGraph`", it can certainly not be replaced by the word "Graph". Hence, changing `QuiverPath` into `GraphPath` would be misleading. I am against that change.

> Actually, for train track automorphisms one needs the groupoid of paths (that is authorize to take edges in reversed direction). As far as I understand, it is different from yours. Do you have an idea for a compatible terminology?

Well, the current terminology for the algebraic object formed by the oriented paths in a multi-digraph subject to concatenation is "path semigroup", and thus the terminology for your groupoid of invertible paths would naturally be "path groupoid", isn't it?



---

archive/issue_comments_211549.json:
```json
{
    "body": "Hi again,\n\nReplying to [comment:94 SimonKing]:\n> Replying to [comment:93 vdelecroix]:\n> > These paths have more applications than quivers (e.g. [train-tracks for free group automorphisms](https://github.com/coulbois/sage-train-track)). Could you move it from `src.sage.quivers` to `sage.graphs`?\n> \n> `sage.graphs` is quite large already, that's why I created the new module `sage.quivers`, for everything that implements representation theoretic aspects of directed multigraphs.\n> \n> I could imagine to use cythonized path algebra elements (see #17435) to provide a better implementation of free associative algebras, but a potential application is no reason to move the code, IMHO.\n> \n> Do you really need oriented paths for train tracks? Or do you rather need sequences of integers to implement train tracks? If the integers are subject to a global bound, then see `sage.data_structures.bounded_integer_sequences`.\n\nYes, I really mean oriented paths. And also (di)graph maps, that is function that maps edges to paths. These are not at all quiver morphisms as they are defined in wikipedia.\n\n> > And also remove the name 'quivers' from there.. why not `GraphPaths`?\n> \n> Most people understand \"graph\" as a non-directed graph. But we are talking here about objects for which orientation is absolutely essential. The original Python code for quivers and their representation had to make a difference between two different notions of paths in a graph, one being a sequence of vertices, the other being a sequence of edges. `QuiverPaths` is about paths as sequences of *directed* edges.\n\nThen `DiGraphPaths`? If you say `Quiver` in a talk on Geometric Group Theory to talk about train-track, I bet that the public would be quite surprised. \n\n> When developing the current Python code for quiver representations, there was some discussion about terminology. \"Quiver\" is a well-established mathematical notion, so, good to use. It is the same as multi-digraph, but is a shorter word. It seems that the decision was to use \"`DiGraph`\" in Sage to denote the mere directed graph, whereas one uses \"`Quiver`\" when one considers the directed graph as an algebraic object.\n\nI see. But Quiver for me already denotes representation theory (you should agree with me since you said \"`sage.quiver` for everything that implements representation theoretic aspects of directed multigraphs\" and Wikipedia as well).\n\n> While it may be acceptable to replace the word \"Quiver\" by \"`DiGraph`\", it can certainly not be replaced by the word \"Graph\". Hence, changing `QuiverPath` into `GraphPath` would be misleading. I am against that change.\n\nAll right, I understand. But `DiGraphPath`? My concern is that if Thierry did not mentioned to me your previous ticket about sequences of bounded integers I would never have found it.\n\n> > Actually, for train track automorphisms one needs the groupoid of paths (that is authorize to take edges in reversed direction). As far as I understand, it is different from yours. Do you have an idea for a compatible terminology?\n> \n> Well, the current terminology for the algebraic object formed by the oriented paths in a multi-digraph subject to concatenation is \"path semigroup\", and thus the terminology for your groupoid of invertible paths would naturally be \"path groupoid\", isn't it?\n\nIt is. But I do not want to have it in `src.sage.quivers` and it would be logical to have it close to implementation of the path semigroup (and they will surely share some of their features).\n\nI would be happy to finish the review of this ticket, but I want it to be a starting point for the path groupoid as well.\n\nVincent",
    "created_at": "2015-01-19T19:47:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211549",
    "user": "https://github.com/videlec"
}
```

Hi again,

Replying to [comment:94 SimonKing]:
> Replying to [comment:93 vdelecroix]:
> > These paths have more applications than quivers (e.g. [train-tracks for free group automorphisms](https://github.com/coulbois/sage-train-track)). Could you move it from `src.sage.quivers` to `sage.graphs`?
> 
> `sage.graphs` is quite large already, that's why I created the new module `sage.quivers`, for everything that implements representation theoretic aspects of directed multigraphs.
> 
> I could imagine to use cythonized path algebra elements (see #17435) to provide a better implementation of free associative algebras, but a potential application is no reason to move the code, IMHO.
> 
> Do you really need oriented paths for train tracks? Or do you rather need sequences of integers to implement train tracks? If the integers are subject to a global bound, then see `sage.data_structures.bounded_integer_sequences`.

Yes, I really mean oriented paths. And also (di)graph maps, that is function that maps edges to paths. These are not at all quiver morphisms as they are defined in wikipedia.

> > And also remove the name 'quivers' from there.. why not `GraphPaths`?
> 
> Most people understand "graph" as a non-directed graph. But we are talking here about objects for which orientation is absolutely essential. The original Python code for quivers and their representation had to make a difference between two different notions of paths in a graph, one being a sequence of vertices, the other being a sequence of edges. `QuiverPaths` is about paths as sequences of *directed* edges.

Then `DiGraphPaths`? If you say `Quiver` in a talk on Geometric Group Theory to talk about train-track, I bet that the public would be quite surprised. 

> When developing the current Python code for quiver representations, there was some discussion about terminology. "Quiver" is a well-established mathematical notion, so, good to use. It is the same as multi-digraph, but is a shorter word. It seems that the decision was to use "`DiGraph`" in Sage to denote the mere directed graph, whereas one uses "`Quiver`" when one considers the directed graph as an algebraic object.

I see. But Quiver for me already denotes representation theory (you should agree with me since you said "`sage.quiver` for everything that implements representation theoretic aspects of directed multigraphs" and Wikipedia as well).

> While it may be acceptable to replace the word "Quiver" by "`DiGraph`", it can certainly not be replaced by the word "Graph". Hence, changing `QuiverPath` into `GraphPath` would be misleading. I am against that change.

All right, I understand. But `DiGraphPath`? My concern is that if Thierry did not mentioned to me your previous ticket about sequences of bounded integers I would never have found it.

> > Actually, for train track automorphisms one needs the groupoid of paths (that is authorize to take edges in reversed direction). As far as I understand, it is different from yours. Do you have an idea for a compatible terminology?
> 
> Well, the current terminology for the algebraic object formed by the oriented paths in a multi-digraph subject to concatenation is "path semigroup", and thus the terminology for your groupoid of invertible paths would naturally be "path groupoid", isn't it?

It is. But I do not want to have it in `src.sage.quivers` and it would be logical to have it close to implementation of the path semigroup (and they will surely share some of their features).

I would be happy to finish the review of this ticket, but I want it to be a starting point for the path groupoid as well.

Vincent



---

archive/issue_comments_211550.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2015-03-27T15:57:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211550",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_211551.json:
```json
{
    "body": "back to **needs review**, so that the patchbot can have a look",
    "created_at": "2015-03-27T15:57:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211551",
    "user": "https://github.com/fchapoton"
}
```

back to **needs review**, so that the patchbot can have a look



---

archive/issue_comments_211552.json:
```json
{
    "body": "coverage is not 100%, see patchbot report",
    "created_at": "2015-03-30T08:01:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211552",
    "user": "https://github.com/fchapoton"
}
```

coverage is not 100%, see patchbot report



---

archive/issue_comments_211553.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-03-30T08:01:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211553",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211554.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-03-31T10:09:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211554",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211555.json:
```json
{
    "body": "I don't know why \"git trac push\" didn't work. Anyway, \"git push\" did work, and I am updating the \"commit\" field manually.\n\nI added a doctest for the lazy attribute `_nb_arrows` of path semigroups. I don't think one should not add a doctest for `QuiverPaths.__cmp__`: As usual for Cythonised element classes, one has to copy the `__cmp__` from `sage.structure.element`, because of technical reasons. The actual comparison is done in `_cmp_c_impl`, which *is* doctested.\n\nBut perhaps it makes sense to remove the phrase\n\n```\n        As usual in Sage, the ``__cmp__`` method of a Python sub-class of\n        :class:`sage.structure.element.Element` can assume that both arguments\n        belong to the same parent.\n```\n\nfrom the documentation of `_cmp_c_impl`, since after all it is not a Python sub-class any longer. Will do this next.\n----\nNew commits:",
    "created_at": "2015-03-31T10:09:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211555",
    "user": "https://github.com/simon-king-jena"
}
```

I don't know why "git trac push" didn't work. Anyway, "git push" did work, and I am updating the "commit" field manually.

I added a doctest for the lazy attribute `_nb_arrows` of path semigroups. I don't think one should not add a doctest for `QuiverPaths.__cmp__`: As usual for Cythonised element classes, one has to copy the `__cmp__` from `sage.structure.element`, because of technical reasons. The actual comparison is done in `_cmp_c_impl`, which *is* doctested.

But perhaps it makes sense to remove the phrase

```
        As usual in Sage, the ``__cmp__`` method of a Python sub-class of
        :class:`sage.structure.element.Element` can assume that both arguments
        belong to the same parent.
```

from the documentation of `_cmp_c_impl`, since after all it is not a Python sub-class any longer. Will do this next.
----
New commits:



---

archive/issue_comments_211556.json:
```json
{
    "body": "Gosh, I HATE the flaky trac! Why has my manual update of the commit field been automatically reverted, so that the doctest fix isn't visible? Anyway, I will first remove the `_cmp_c_impl` comment and then try to push again.",
    "created_at": "2015-03-31T10:11:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211556",
    "user": "https://github.com/simon-king-jena"
}
```

Gosh, I HATE the flaky trac! Why has my manual update of the commit field been automatically reverted, so that the doctest fix isn't visible? Anyway, I will first remove the `_cmp_c_impl` comment and then try to push again.



---

archive/issue_comments_211557.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-03-31T10:14:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211557",
    "user": "https://github.com/simon-king-jena"
}
```

New commits:



---

archive/issue_comments_211558.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-03-31T10:15:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211558",
    "user": "https://github.com/simon-king-jena"
}
```

New commits:



---

archive/issue_comments_211559.json:
```json
{
    "body": "I tried to manually set the commit field to `b39b21d486dc28651b1c65536e2f6d43121b4135`, but it didn't work. I give up.",
    "created_at": "2015-03-31T10:15:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211559",
    "user": "https://github.com/simon-king-jena"
}
```

I tried to manually set the commit field to `b39b21d486dc28651b1c65536e2f6d43121b4135`, but it didn't work. I give up.



---

archive/issue_comments_211560.json:
```json
{
    "body": "Trying to change the status at the same time as the commit field. See if it works...\n----\nNew commits:",
    "created_at": "2015-03-31T10:23:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211560",
    "user": "https://github.com/simon-king-jena"
}
```

Trying to change the status at the same time as the commit field. See if it works...
----
New commits:



---

archive/issue_comments_211561.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-03-31T10:23:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211561",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211562.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-03-31T10:23:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211562",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211563.json:
```json
{
    "body": "Nope.",
    "created_at": "2015-03-31T10:23:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211563",
    "user": "https://github.com/simon-king-jena"
}
```

Nope.



---

archive/issue_comments_211564.json:
```json
{
    "body": "I still don't know why \"git trac push\" didn't push to the attached branch. But, as it turns out, \"git push\" did not push to the public branch attached to the ticket, but to a different remote branch. So, I am attaching the different branch now. Hopefully it works...",
    "created_at": "2015-03-31T20:03:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211564",
    "user": "https://github.com/simon-king-jena"
}
```

I still don't know why "git trac push" didn't push to the attached branch. But, as it turns out, "git push" did not push to the public branch attached to the ticket, but to a different remote branch. So, I am attaching the different branch now. Hopefully it works...



---

archive/issue_comments_211565.json:
```json
{
    "body": "One way to push on a given remote branch is\n\n```\ngit push trac HEAD:NAME_OF_THE_REMOTE_BRANCH\n```\n\n(where `trac` might have to be replaced with the name you give to the remote git server). Otherwise, there are default in `%SAGE_SRC/.git/config` for the `git push` command. You can also edit with some git command.\n\nVincent",
    "created_at": "2015-03-31T20:06:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211565",
    "user": "https://github.com/videlec"
}
```

One way to push on a given remote branch is

```
git push trac HEAD:NAME_OF_THE_REMOTE_BRANCH
```

(where `trac` might have to be replaced with the name you give to the remote git server). Otherwise, there are default in `%SAGE_SRC/.git/config` for the `git push` command. You can also edit with some git command.

Vincent



---

archive/issue_comments_211566.json:
```json
{
    "body": "WTF??? Can it be that my local branch was different from the remote (public) branch that has been attached? I don't see the former commits.",
    "created_at": "2015-03-31T20:07:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211566",
    "user": "https://github.com/simon-king-jena"
}
```

WTF??? Can it be that my local branch was different from the remote (public) branch that has been attached? I don't see the former commits.



---

archive/issue_comments_211567.json:
```json
{
    "body": "I just tested: The old and the new branch are totally different. The old branch was based on 6.5.beta4, the new is based on 6.5.beta0.\n\nWhat shall I do? I guess I restore the old (public) branch, since it is based on a more recent beta, and will then move the latest two commits of the new branch on top of the old branch. Wouldn't have happened with mercurial, I suppose.",
    "created_at": "2015-03-31T20:13:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211567",
    "user": "https://github.com/simon-king-jena"
}
```

I just tested: The old and the new branch are totally different. The old branch was based on 6.5.beta4, the new is based on 6.5.beta0.

What shall I do? I guess I restore the old (public) branch, since it is based on a more recent beta, and will then move the latest two commits of the new branch on top of the old branch. Wouldn't have happened with mercurial, I suppose.



---

archive/issue_comments_211568.json:
```json
{
    "body": "Probably, at some point in the past, I have moved this ticket from the `u/SimonKing` branch to the public branch, after cleaning everything by rebasing what I had before. Wouldn't have been needed with mercurial either, I suppose.\n\nAnyway. The branch at `u/SimonKing` was a mess, because of work done in one series of commits that was reverted in other commits. The `public` branch is nicer, and is what should be reviewed...",
    "created_at": "2015-03-31T20:20:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211568",
    "user": "https://github.com/simon-king-jena"
}
```

Probably, at some point in the past, I have moved this ticket from the `u/SimonKing` branch to the public branch, after cleaning everything by rebasing what I had before. Wouldn't have been needed with mercurial either, I suppose.

Anyway. The branch at `u/SimonKing` was a mess, because of work done in one series of commits that was reverted in other commits. The `public` branch is nicer, and is what should be reviewed...



---

archive/issue_comments_211569.json:
```json
{
    "body": "This needs to be rebased, presumably because of Trac #17890\n\nI have tried to do that and it did build, but some comparison tests were failing.",
    "created_at": "2015-05-07T08:54:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211569",
    "user": "https://github.com/fchapoton"
}
```

This needs to be rebased, presumably because of Trac #17890

I have tried to do that and it did build, but some comparison tests were failing.



---

archive/issue_comments_211570.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-05-07T08:54:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211570",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211571.json:
```json
{
    "body": "Hello,\n\n0. I still would be very happy to have a class `GraphPaths` that would avoid quiver terminology. Though, I can factor out what I need for train-tracks later on.\n\n1. Why `deg` instead of `degree`? And why not making aliases\n\n```\ndegree = __len__\nlength = __len__\n```\n\n That would avoid duplication of the documentation.\n\n2. For the slices, it is much faster to use `PySlice_GetIndicesEx` (see e.g. `sage.combinat.words.word_char`)\n\n3. Please add a definition for `gcd`\n\n4. In `sage.combinat.words` we used `has_prefix` instead of `has_initial_segment`. It would be cool to keep a uniform terminology if it is not too bad from the quiver terminology point of view.\n\n5. `PY_NEW(X)` -> `X.__new__`\n\n6. Are you sure you need to initialize the `_path.length` to `0` in `__cinit__`?\n\n7. Why would you need the function `NewQuiverPath` that essentially duplicates the `_new_`. Note that most parents implement `_new_X`. Moreover, because you can use `type.__new__` I would rather remove your method `_new_`.\n\nVincent",
    "created_at": "2015-05-13T13:17:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211571",
    "user": "https://github.com/videlec"
}
```

Hello,

0. I still would be very happy to have a class `GraphPaths` that would avoid quiver terminology. Though, I can factor out what I need for train-tracks later on.

1. Why `deg` instead of `degree`? And why not making aliases

```
degree = __len__
length = __len__
```

 That would avoid duplication of the documentation.

2. For the slices, it is much faster to use `PySlice_GetIndicesEx` (see e.g. `sage.combinat.words.word_char`)

3. Please add a definition for `gcd`

4. In `sage.combinat.words` we used `has_prefix` instead of `has_initial_segment`. It would be cool to keep a uniform terminology if it is not too bad from the quiver terminology point of view.

5. `PY_NEW(X)` -> `X.__new__`

6. Are you sure you need to initialize the `_path.length` to `0` in `__cinit__`?

7. Why would you need the function `NewQuiverPath` that essentially duplicates the `_new_`. Note that most parents implement `_new_X`. Moreover, because you can use `type.__new__` I would rather remove your method `_new_`.

Vincent



---

archive/issue_comments_211572.json:
```json
{
    "body": "Hi!\n\nReplying to [comment:111 vdelecroix]:\n> 0. I still would be very happy to have a class `GraphPaths` that would avoid quiver terminology. Though, I can factor out what I need for train-tracks later on.\n\nI would somehow prefer to keep it there. After all, it was created with applications on quivers in mind.\n\n> 1. Why `deg` instead of `degree`?\n\nI think I was used to \"deg\" from a different CAS. Since it is `degree()` for polynomials, and since generally we seem to avoid abbreviations in method names, I agree this should be changed.\n\n> And why not making aliases\n> {{{\n> degree = __len__\n> length = __len__\n> }}}\n>  That would avoid duplication of the documentation.\n\nGood idea!\n\n> 2. For the slices, it is much faster to use `PySlice_GetIndicesEx` (see e.g. `sage.combinat.words.word_char`)\n\nThanks for the hint!\n\n> 4. In `sage.combinat.words` we used `has_prefix` instead of `has_initial_segment`. It would be cool to keep a uniform terminology if it is not too bad from the quiver terminology point of view.\n\nThere is no particular reason for choosing \"has_initial_segment\". So, a uniform terminology seems possible here.\n\n> 5. `PY_NEW(X)` -> `X.__new__`\n\nOK, I heard that meanwhile the speed is the same.\n\n> 6. Are you sure you need to initialize the `_path.length` to `0` in `__cinit__`?\n\nI am sure that I did it for a reason (i.e., something crashed when not setting the length to zero in `__cinit__`), but I don't recall. Let's try if it works...\n\n> 7. Why would you need the function `NewQuiverPath` that essentially duplicates the `_new_`. Note that most parents implement `_new_X`. Moreover, because you can use `type.__new__` I would rather remove your method `_new_`.\n\nOK, that somehow makes sense. I don't think I can provide `_new_X` on the parent, since I need to take care of cdef stuff (the parent isn't in a cython file), but replacing `QuiverPath._new_` by `NewQuiverPath` should be possible.\n\nAnd of course I should take care of merging...",
    "created_at": "2015-05-13T13:48:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211572",
    "user": "https://github.com/simon-king-jena"
}
```

Hi!

Replying to [comment:111 vdelecroix]:
> 0. I still would be very happy to have a class `GraphPaths` that would avoid quiver terminology. Though, I can factor out what I need for train-tracks later on.

I would somehow prefer to keep it there. After all, it was created with applications on quivers in mind.

> 1. Why `deg` instead of `degree`?

I think I was used to "deg" from a different CAS. Since it is `degree()` for polynomials, and since generally we seem to avoid abbreviations in method names, I agree this should be changed.

> And why not making aliases
> {{{
> degree = __len__
> length = __len__
> }}}
>  That would avoid duplication of the documentation.

Good idea!

> 2. For the slices, it is much faster to use `PySlice_GetIndicesEx` (see e.g. `sage.combinat.words.word_char`)

Thanks for the hint!

> 4. In `sage.combinat.words` we used `has_prefix` instead of `has_initial_segment`. It would be cool to keep a uniform terminology if it is not too bad from the quiver terminology point of view.

There is no particular reason for choosing "has_initial_segment". So, a uniform terminology seems possible here.

> 5. `PY_NEW(X)` -> `X.__new__`

OK, I heard that meanwhile the speed is the same.

> 6. Are you sure you need to initialize the `_path.length` to `0` in `__cinit__`?

I am sure that I did it for a reason (i.e., something crashed when not setting the length to zero in `__cinit__`), but I don't recall. Let's try if it works...

> 7. Why would you need the function `NewQuiverPath` that essentially duplicates the `_new_`. Note that most parents implement `_new_X`. Moreover, because you can use `type.__new__` I would rather remove your method `_new_`.

OK, that somehow makes sense. I don't think I can provide `_new_X` on the parent, since I need to take care of cdef stuff (the parent isn't in a cython file), but replacing `QuiverPath._new_` by `NewQuiverPath` should be possible.

And of course I should take care of merging...



---

archive/issue_comments_211573.json:
```json
{
    "body": "Replying to [comment:112 SimonKing]:\n> > 7. Why would you need the function `NewQuiverPath` that essentially duplicates the `_new_`. Note that most parents implement `_new_X`. Moreover, because you can use `type.__new__` I would rather remove your method `_new_`.\n> \n> OK, that somehow makes sense. I don't think I can provide `_new_X` on the parent, since I need to take care of cdef stuff (the parent isn't in a cython file), but replacing `QuiverPath._new_` by `NewQuiverPath` should be possible.\n\nOTOH, when having a quiver path `p`, I find it simpler to write `p._new_(s,e)` instead of `NewQuiverPath(p._parent,s,e, None)`.",
    "created_at": "2015-05-13T19:56:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211573",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:112 SimonKing]:
> > 7. Why would you need the function `NewQuiverPath` that essentially duplicates the `_new_`. Note that most parents implement `_new_X`. Moreover, because you can use `type.__new__` I would rather remove your method `_new_`.
> 
> OK, that somehow makes sense. I don't think I can provide `_new_X` on the parent, since I need to take care of cdef stuff (the parent isn't in a cython file), but replacing `QuiverPath._new_` by `NewQuiverPath` should be possible.

OTOH, when having a quiver path `p`, I find it simpler to write `p._new_(s,e)` instead of `NewQuiverPath(p._parent,s,e, None)`.



---

archive/issue_comments_211574.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-13T20:18:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211574",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211575.json:
```json
{
    "body": "I have merged, so that all tests in src/sage/quivers pass. Next I'll address your comments.\n----\nNew commits:\n----\nNew commits:",
    "created_at": "2015-05-13T20:19:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211575",
    "user": "https://github.com/simon-king-jena"
}
```

I have merged, so that all tests in src/sage/quivers pass. Next I'll address your comments.
----
New commits:
----
New commits:



---

archive/issue_comments_211576.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-13T20:38:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211576",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211577.json:
```json
{
    "body": "Replying to [comment:111 vdelecroix]:\n> 1. Why `deg` instead of `degree`? And why not making aliases\n> {{{\n> degree = __len__\n> length = __len__\n> }}}\n>  That would avoid duplication of the documentation.\n\nDone\n \n> 2. For the slices, it is much faster to use `PySlice_GetIndicesEx` (see e.g. `sage.combinat.words.word_char`)\n\nDone\n\n> 3. Please add a definition for `gcd`\n\nOops, I just notice I forgot this...\n\n> 4. In `sage.combinat.words` we used `has_prefix` instead of `has_initial_segment`. It would be cool to keep a uniform terminology if it is not too bad from the quiver terminology point of view.\n\nDone.\n\n> 5. `PY_NEW(X)` -> `X.__new__`\n\n`QuiverPath.__new__` should do the job.\n\n> 6. Are you sure you need to initialize the `_path.length` to `0` in `__cinit__`?\n\nI removed it, and the tests still pass.\n\n> 7. Why would you need the function `NewQuiverPath` that essentially duplicates the `_new_`. Note that most parents implement `_new_X`. Moreover, because you can use `type.__new__` I would rather remove your method `_new_`.\n\nI kept `_new_`, since I find such functions practical (and I think there are other examples of elements having a `_new_` method to create a new element with the same parent).",
    "created_at": "2015-05-13T20:41:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211577",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:111 vdelecroix]:
> 1. Why `deg` instead of `degree`? And why not making aliases
> {{{
> degree = __len__
> length = __len__
> }}}
>  That would avoid duplication of the documentation.

Done
 
> 2. For the slices, it is much faster to use `PySlice_GetIndicesEx` (see e.g. `sage.combinat.words.word_char`)

Done

> 3. Please add a definition for `gcd`

Oops, I just notice I forgot this...

> 4. In `sage.combinat.words` we used `has_prefix` instead of `has_initial_segment`. It would be cool to keep a uniform terminology if it is not too bad from the quiver terminology point of view.

Done.

> 5. `PY_NEW(X)` -> `X.__new__`

`QuiverPath.__new__` should do the job.

> 6. Are you sure you need to initialize the `_path.length` to `0` in `__cinit__`?

I removed it, and the tests still pass.

> 7. Why would you need the function `NewQuiverPath` that essentially duplicates the `_new_`. Note that most parents implement `_new_X`. Moreover, because you can use `type.__new__` I would rather remove your method `_new_`.

I kept `_new_`, since I find such functions practical (and I think there are other examples of elements having a `_new_` method to create a new element with the same parent).



---

archive/issue_comments_211578.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-13T20:44:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211578",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211579.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-05-13T20:44:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211579",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211580.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-05-13T20:44:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211580",
    "user": "https://github.com/simon-king-jena"
}
```

New commits:



---

archive/issue_comments_211581.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-05-15T17:29:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211581",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211582.json:
```json
{
    "body": "8. This is not properly cythonized\n\n```\ncdef int a,b,c\n...\nc = cmp(a,b)\n```\n\n  What you obtain is: creation of a Python int to store `a`, of a Python int to store `b`, comparison invoking Python comparison, cast back the result to an int... the best solution would be to modify Cython. But in the meantine you can do something smarter\n\n   And this is even worse\n\n```\nc = cmp((cself._start,cself._end), (other._start,other._end))\n```\n\n   since you are building tuples.\n\n9. Could you replace the older style `for i from a <= i < b` with `for i in range(a,b)`?\n\n10. There is no need to declare `cdef object C`.\n\n21. In the reverse you are calling the constructor. It will be much faster to call `QuiverPath.__new__` and you use some C operation on bitseq to reverse the path.\n\n32. I maintain that the quiver terminology is bad ;-)\n\n```\nsage: G = DiGraph()\nsage: G.add_edge(0,0,'a')\nsage: M = G.path_semigroup()\nsage: M.an_element()\ne_0\nsage: type(_)   # WTF?\n<type 'sage.quivers.paths.QuiverPath'>\n```\n\n\nVincent",
    "created_at": "2015-05-15T17:29:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211582",
    "user": "https://github.com/videlec"
}
```

8. This is not properly cythonized

```
cdef int a,b,c
...
c = cmp(a,b)
```

  What you obtain is: creation of a Python int to store `a`, of a Python int to store `b`, comparison invoking Python comparison, cast back the result to an int... the best solution would be to modify Cython. But in the meantine you can do something smarter

   And this is even worse

```
c = cmp((cself._start,cself._end), (other._start,other._end))
```

   since you are building tuples.

9. Could you replace the older style `for i from a <= i < b` with `for i in range(a,b)`?

10. There is no need to declare `cdef object C`.

21. In the reverse you are calling the constructor. It will be much faster to call `QuiverPath.__new__` and you use some C operation on bitseq to reverse the path.

32. I maintain that the quiver terminology is bad ;-)

```
sage: G = DiGraph()
sage: G.add_edge(0,0,'a')
sage: M = G.path_semigroup()
sage: M.an_element()
e_0
sage: type(_)   # WTF?
<type 'sage.quivers.paths.QuiverPath'>
```


Vincent



---

archive/issue_comments_211583.json:
```json
{
    "body": "Here is a timing for comparison. First, as it is now:\n\n```\nsage: D = DiGraph({0:{0:['x','y','z']}}).path_semigroup()\nsage: L = sum([list(D.iter_paths_by_length_and_startpoint(i,0)) for i in range(5)], [])\nsage: def test(L):\n....:     for a in L:\n....:         for b in L:\n....:             cmp(a,b)\n....:             \nsage: %timeit test(L)\n100 loops, best of 3: 9.65 ms per loop\n```\n\n\nAnd with an attempt to replace \"cmp\" with \"if\" clauses:\n\n```\nsage: %timeit test(L)\n100 loops, best of 3: 5.79 ms per loop\n```\n\nThus, it helps. I thought cython would be \"clever\" when dealing with cmp.",
    "created_at": "2015-05-15T21:35:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211583",
    "user": "https://github.com/simon-king-jena"
}
```

Here is a timing for comparison. First, as it is now:

```
sage: D = DiGraph({0:{0:['x','y','z']}}).path_semigroup()
sage: L = sum([list(D.iter_paths_by_length_and_startpoint(i,0)) for i in range(5)], [])
sage: def test(L):
....:     for a in L:
....:         for b in L:
....:             cmp(a,b)
....:             
sage: %timeit test(L)
100 loops, best of 3: 9.65 ms per loop
```


And with an attempt to replace "cmp" with "if" clauses:

```
sage: %timeit test(L)
100 loops, best of 3: 5.79 ms per loop
```

Thus, it helps. I thought cython would be "clever" when dealing with cmp.



---

archive/issue_comments_211584.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-15T21:58:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211584",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211585.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-05-15T22:08:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211585",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211586.json:
```json
{
    "body": "Replying to [comment:120 vdelecroix]:\n> 8. This is not properly cythonized\n\nI replaced cmp by boring \"if\" clauses. It is faster, according to my previous comment.\n \n> 9. Could you replace the older style `for i from a <= i < b` with `for i in range(a,b)`?\n> \n> 10. There is no need to declare `cdef object C`.\n\nDone and done.\n\n> 11. In the reverse you are calling the constructor. It will be much faster to call `QuiverPath.__new__` and you use some C operation on bitseq to reverse the path.\n\nHere is a comparison. The old code:\n\n```\nsage: D = DiGraph({0:{0:['x','y','z']}}).path_semigroup()\nsage: L = sum([list(D.iter_paths_by_length_and_startpoint(i,0)) for i in range(5)], [])\nsage: %timeit [p.reverse() for p in L]\n10 loops, best of 3: 44.3 ms per loop\n```\n\nThe new code:\n\n```\nsage: %timeit [p.reverse() for p in L]\n10 loops, best of 3: 44 ms per loop\n```\n\n\nHmmm. It didn't really improve. Perhaps you have a better idea to make it faster?\n\nBest regards,\n\nSimon",
    "created_at": "2015-05-15T22:08:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211586",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:120 vdelecroix]:
> 8. This is not properly cythonized

I replaced cmp by boring "if" clauses. It is faster, according to my previous comment.
 
> 9. Could you replace the older style `for i from a <= i < b` with `for i in range(a,b)`?
> 
> 10. There is no need to declare `cdef object C`.

Done and done.

> 11. In the reverse you are calling the constructor. It will be much faster to call `QuiverPath.__new__` and you use some C operation on bitseq to reverse the path.

Here is a comparison. The old code:

```
sage: D = DiGraph({0:{0:['x','y','z']}}).path_semigroup()
sage: L = sum([list(D.iter_paths_by_length_and_startpoint(i,0)) for i in range(5)], [])
sage: %timeit [p.reverse() for p in L]
10 loops, best of 3: 44.3 ms per loop
```

The new code:

```
sage: %timeit [p.reverse() for p in L]
10 loops, best of 3: 44 ms per loop
```


Hmmm. It didn't really improve. Perhaps you have a better idea to make it faster?

Best regards,

Simon



---

archive/issue_comments_211587.json:
```json
{
    "body": "Replying to [comment:123 SimonKing]:\n> Replying to [comment:120 vdelecroix]:\n> > 8. This is not properly cythonized\n> \n> I replaced cmp by boring \"if\" clauses. It is faster, according to my previous comment.\n\nMe too. I just run cython on a `cmp(a,b)` and just found out the crazy piece of code I get! I will see whether I can provide a fix on the Cython side.\n\nFor the sake of this ticket, you might factor:\n\n```\ncdef inline int c_int_cmp(int a, int b):\n   return (a > b) - (a < b)\n```\n\nand then\n\n```\ncdef int c\nc = c_int_cmp(other._path.length, cself._path.length)\nif c: return c\nc = c_int_cmp(cself._start, other._start)\nif c: return c\nc = c_int_cmp(cself._end, other._end)\nif c: return c\n...\n```\n\n  that way when Cython is up to date with `cmp` you can just replace `c_int_cmp -> cmp`.\n\n> > 11. In the reverse you are calling the constructor. It will be much faster to call `QuiverPath.__new__` and you use some C operation on bitseq to reverse the path.\n> \n> Here is a comparison. The old code:\n\nI guess this is because of the line\n\n```\nQ = self._parent.reverse()\n```\n\nI will do some profiling.\n\nBest\nVincent",
    "created_at": "2015-05-16T08:29:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211587",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:123 SimonKing]:
> Replying to [comment:120 vdelecroix]:
> > 8. This is not properly cythonized
> 
> I replaced cmp by boring "if" clauses. It is faster, according to my previous comment.

Me too. I just run cython on a `cmp(a,b)` and just found out the crazy piece of code I get! I will see whether I can provide a fix on the Cython side.

For the sake of this ticket, you might factor:

```
cdef inline int c_int_cmp(int a, int b):
   return (a > b) - (a < b)
```

and then

```
cdef int c
c = c_int_cmp(other._path.length, cself._path.length)
if c: return c
c = c_int_cmp(cself._start, other._start)
if c: return c
c = c_int_cmp(cself._end, other._end)
if c: return c
...
```

  that way when Cython is up to date with `cmp` you can just replace `c_int_cmp -> cmp`.

> > 11. In the reverse you are calling the constructor. It will be much faster to call `QuiverPath.__new__` and you use some C operation on bitseq to reverse the path.
> 
> Here is a comparison. The old code:

I guess this is because of the line

```
Q = self._parent.reverse()
```

I will do some profiling.

Best
Vincent



---

archive/issue_comments_211588.json:
```json
{
    "body": "Indeed. Adding ``@`cached_method` to `PathSemigroup.reverse` I got a great speedup. With\n\n```\nsage: G = DiGraph(loops=True)\nsage: G.add_edge(1,1,'a')\nsage: G.add_edge(1,2,'b')\nsage: G.add_edge(2,1,'c')\nsage: P = G.path_semigroup()\nsage: e1,e2,a,b,c=P.gens()\nsage: p = a*b*c*b*c*a*a\n```\n\n\nthen without cache\n\n```\nsage: timeit(\"p.reverse()\", number=1000)\n1000 loops, best of 3: 179 \u00b5s per loop\n```\n\nand with cache\n\n```\nsage: timeit(\"p.reverse()\", number=1000)\n1000 loops, best of 3: 1 \u00b5s per loop\n```\n\n\nIs it worth it? Actually it would be nicer for `P.reverse().reverse() is P` to be true. Possible hack\n\n```\n@cached_method\ndef reverse(self):\n    p = self._quiver.reverse().path_semigroup()\n    p.reverse.set_cache(self)\n    return p\n```\n\n\nVincent",
    "created_at": "2015-05-16T09:52:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211588",
    "user": "https://github.com/videlec"
}
```

Indeed. Adding ``@`cached_method` to `PathSemigroup.reverse` I got a great speedup. With

```
sage: G = DiGraph(loops=True)
sage: G.add_edge(1,1,'a')
sage: G.add_edge(1,2,'b')
sage: G.add_edge(2,1,'c')
sage: P = G.path_semigroup()
sage: e1,e2,a,b,c=P.gens()
sage: p = a*b*c*b*c*a*a
```


then without cache

```
sage: timeit("p.reverse()", number=1000)
1000 loops, best of 3: 179 µs per loop
```

and with cache

```
sage: timeit("p.reverse()", number=1000)
1000 loops, best of 3: 1 µs per loop
```


Is it worth it? Actually it would be nicer for `P.reverse().reverse() is P` to be true. Possible hack

```
@cached_method
def reverse(self):
    p = self._quiver.reverse().path_semigroup()
    p.reverse.set_cache(self)
    return p
```


Vincent



---

archive/issue_comments_211589.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-05-16T09:54:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211589",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211590.json:
```json
{
    "body": "Replying to [comment:125 vdelecroix]:\n> Indeed. Adding ``@`cached_method` to `PathSemigroup.reverse` I got a great speedup.\n\nNo surprise. Obviously that's the bottle neck.\n\n> Is it worth it?\n\nI am surprised that it isn't cached_method yet. Clearly, creating the reverse of the quiver of a path semigroup should be done only once.\n\n> Actually it would be nicer for `P.reverse().reverse() is P` to be true.\n\nWhat is P here? If P is a path semigroup, I agree that `P.reverse().reverse()` should be identical with P. But if P is a path, I would disagree.\n\n> Possible hack\n> {{{\n> `@`cached_method\n> def reverse(self):\n>     p = self._quiver.reverse().path_semigroup()\n>     p.reverse.set_cache(self)\n>     return p\n> }}}\n\nIs that really needed? I thought that `UniqueRepresentation` did the job. So, using a `cached_method` would not be needed to ensure uniqueness, but would speed-up things.\n\nI'll test.",
    "created_at": "2015-05-16T21:06:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211590",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:125 vdelecroix]:
> Indeed. Adding ``@`cached_method` to `PathSemigroup.reverse` I got a great speedup.

No surprise. Obviously that's the bottle neck.

> Is it worth it?

I am surprised that it isn't cached_method yet. Clearly, creating the reverse of the quiver of a path semigroup should be done only once.

> Actually it would be nicer for `P.reverse().reverse() is P` to be true.

What is P here? If P is a path semigroup, I agree that `P.reverse().reverse()` should be identical with P. But if P is a path, I would disagree.

> Possible hack
> {{{
> `@`cached_method
> def reverse(self):
>     p = self._quiver.reverse().path_semigroup()
>     p.reverse.set_cache(self)
>     return p
> }}}

Is that really needed? I thought that `UniqueRepresentation` did the job. So, using a `cached_method` would not be needed to ensure uniqueness, but would speed-up things.

I'll test.



---

archive/issue_comments_211591.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-16T21:12:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211591",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211592.json:
```json
{
    "body": "Indeed. With the current code, we already have \n\n```\nsage: D = DiGraph({0:{1:['x','y','z']}, 1:{0:['a','b','c']}}).path_semigroup()\nsage: D.reverse().reverse() is D\nTrue\n```\n\nTiming:\n\n```\nsage: %timeit D.reverse().reverse()\n1000 loops, best of 3: 806 \u00b5s per loop\n```\n\n\nBut with a cached method, we get\n\n```\nsage: D = DiGraph({0:{1:['x','y','z']}, 1:{0:['a','b','c']}}).path_semigroup()\nsage: D.reverse().reverse() is D\nTrue\nsage: %timeit D.reverse().reverse()\nThe slowest run took 16.68 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 243 ns per loop\n```\n\n\nI'd be against having `p.reverse().reverse() is p` for a *path* p.\n----\nNew commits:",
    "created_at": "2015-05-16T21:13:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211592",
    "user": "https://github.com/simon-king-jena"
}
```

Indeed. With the current code, we already have 

```
sage: D = DiGraph({0:{1:['x','y','z']}, 1:{0:['a','b','c']}}).path_semigroup()
sage: D.reverse().reverse() is D
True
```

Timing:

```
sage: %timeit D.reverse().reverse()
1000 loops, best of 3: 806 µs per loop
```


But with a cached method, we get

```
sage: D = DiGraph({0:{1:['x','y','z']}, 1:{0:['a','b','c']}}).path_semigroup()
sage: D.reverse().reverse() is D
True
sage: %timeit D.reverse().reverse()
The slowest run took 16.68 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 243 ns per loop
```


I'd be against having `p.reverse().reverse() is p` for a *path* p.
----
New commits:



---

archive/issue_comments_211593.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-05-16T21:13:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211593",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211594.json:
```json
{
    "body": "Hi Simon,\n\n12. Trailing whitespaces in the last line of the docstring of `has_prefix`. And also one in `_cmp_`.\n\n23. In `__getitem__` you are building the whole list of edges of the unerlying graph but uses only at most two! I also guess that in the particular case that you are building a path starting from the same vertex there is no need to build this list.\n\n34. Still in `__getitem__`, what about supporting `-1` for the slices, i.e. `path[::-1]` would return the reverse? You can put that on the wish list, but this is how words behave\n\n```\nsage: w = Word(\"abbaaca\")\nsage: w[::-1]\nword: acaabba\nsage: w[4:1:-1]\nword: aab\n```\n\n  and by the way `reverse` is called `reversal` there\n\n```\nsage: w.reversal()\nword: acaabba\n```\n\n\n15. Still with terminology, there are two different notions of *subword* and *factors*:\n   - the *factors* of `aba` are ``, `a`, `b`, `ab`, `ba` and `aba`,\n   - `aa` is a *subword* of `aba` but not a *factor*.\n\n   But I guess that `subpath` is clear enough.\n\n26. Could you make `_cmp_`, `_repr_`, `__getitem__`, `__mod__`, `__iter__`, `_mul_` appear in the documentation (using the sphinx directive `automethod`)? `__len__` is ok since it has aliases.\n\n37. Could you avoid mentioning `self` in the method descriptions? You can replace by `this path`.\n\n48. The convention for `__nonzero__` is different from words where the empty word is considered zero. What do you think?\n\n59. There is no need to duplicate the `INPUT/OUTPUT` in the class docstring and the `__init__`. Accessing the help on the class with `?` you are getting both. And I found strange to have an `OUTPUT` section here.\n\n20. (independent of this ticket) The category is set to semigroup but would rather be semigroupoid... this is a partial operation! In particular the `TestSuite` failed on any non-trivial graphs because it tries to multiply `None` with paths. Though I like the convention of returning `None` if multiplication is not defined.\n\nVincent",
    "created_at": "2015-05-17T10:43:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211594",
    "user": "https://github.com/videlec"
}
```

Hi Simon,

12. Trailing whitespaces in the last line of the docstring of `has_prefix`. And also one in `_cmp_`.

23. In `__getitem__` you are building the whole list of edges of the unerlying graph but uses only at most two! I also guess that in the particular case that you are building a path starting from the same vertex there is no need to build this list.

34. Still in `__getitem__`, what about supporting `-1` for the slices, i.e. `path[::-1]` would return the reverse? You can put that on the wish list, but this is how words behave

```
sage: w = Word("abbaaca")
sage: w[::-1]
word: acaabba
sage: w[4:1:-1]
word: aab
```

  and by the way `reverse` is called `reversal` there

```
sage: w.reversal()
word: acaabba
```


15. Still with terminology, there are two different notions of *subword* and *factors*:
   - the *factors* of `aba` are ``, `a`, `b`, `ab`, `ba` and `aba`,
   - `aa` is a *subword* of `aba` but not a *factor*.

   But I guess that `subpath` is clear enough.

26. Could you make `_cmp_`, `_repr_`, `__getitem__`, `__mod__`, `__iter__`, `_mul_` appear in the documentation (using the sphinx directive `automethod`)? `__len__` is ok since it has aliases.

37. Could you avoid mentioning `self` in the method descriptions? You can replace by `this path`.

48. The convention for `__nonzero__` is different from words where the empty word is considered zero. What do you think?

59. There is no need to duplicate the `INPUT/OUTPUT` in the class docstring and the `__init__`. Accessing the help on the class with `?` you are getting both. And I found strange to have an `OUTPUT` section here.

20. (independent of this ticket) The category is set to semigroup but would rather be semigroupoid... this is a partial operation! In particular the `TestSuite` failed on any non-trivial graphs because it tries to multiply `None` with paths. Though I like the convention of returning `None` if multiplication is not defined.

Vincent



---

archive/issue_comments_211595.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-05-17T10:43:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211595",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_211596.json:
```json
{
    "body": "Hi Vincent,\n\nI just found that I need to revert my previous changes in the `reverse()` (soon to become `reversal()`) method: I can not simply revert the underlying bounded integer sequence, since in the reversed quiver the edge numbering won't match.\n\nThe big question is whether it is possible to create a reverse quiver so that the numbering DOES match...\n\nWhat I write below refers to a commit that I can't publish, because of the problem with \"reverse()\". But perhaps you can already comment...\n\nReplying to [comment:130 vdelecroix]:\n> 12. Trailing whitespaces in the last line of the docstring of `has_prefix`. And also one in `_cmp_`.\n\nDone.\n \n> 13. In `__getitem__` you are building the whole list of edges of the unerlying graph but uses only at most two!\n\nI know the INDEX of two edges in the list of all edges of the underlying graph, and I need to find out the start resp. end point of the two edges. Please tell me how to get the two edges (and ask for there start/end points) without having to pick them from the list of all edges.\n\n> I also guess that in the particular case that you are building a path starting from the same vertex there is no need to build this list.\n\nI think the only case in which there is no need to find out the start/end points of two edges (given by indices) in the graph is the case of `p[:]` (which returns `p`). I made this a special case, but other than that I don't see how to avoid the list of all edges (unless there is a cached TUPLE of edges of the graph, so that there is no need to re-create a list each time the list of edges is requested).\n\nHmmm, perhaps it makes sense to store the tuple of edges in the path semigroup! What do you think?\n\n> 14. Still in `__getitem__`, what about supporting `-1` for the slices, i.e. `path[::-1]` would return the reverse?\n\nOK, good idea.\n\n> 15. Still with terminology, there are two different notions of *subword* and *factors*:\n>  - the *factors* of `aba` are ``, `a`, `b`, `ab`, `ba` and `aba`,\n>  - `aa` is a *subword* of `aba` but not a *factor*.\n\nWho says that? I would never say that `aa` is a subword of `aba`.\n\n> 16. Could you make `_cmp_`, `_repr_`, `__getitem__`, `__mod__`, `__iter__`, `_mul_` appear in the documentation (using the sphinx directive `automethod`)? `__len__` is ok since it has aliases.\n\nIt is not very common to include magic Python methods (or their SageMath equivalents) into the docs. For good or bad.\n \n> 17. Could you avoid mentioning `self` in the method descriptions? You can replace by `this path`.\n\nI tried to. In one case, where `self` appears in an equation, I left it in.\n\n> 18. The convention for `__nonzero__` is different from words where the empty word is considered zero. What do you think?\n\nI guess you may be right. But I hope it won't create a problem in path algebras. If it does, then I should take care of it there, though.\n\n> 19. There is no need to duplicate the `INPUT/OUTPUT` in the class docstring and the `__init__`. Accessing the help on the class with `?` you are getting both. And I found strange to have an `OUTPUT` section here.\n\nOK. I hope it is fine to remove it from the class and keep it in `__init__`.\n\n> 20. (independent of this ticket) The category is set to semigroup but would rather be semigroupoid... this is a partial operation!\n\nIndeed, but I think we have no semigroupoid yet.\n\n> Though I like the convention of returning `None` if multiplication is not defined.\n\nI don't like that convention, but I think it is a well-established convention in the category/coercion world.",
    "created_at": "2015-05-17T11:32:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211596",
    "user": "https://github.com/simon-king-jena"
}
```

Hi Vincent,

I just found that I need to revert my previous changes in the `reverse()` (soon to become `reversal()`) method: I can not simply revert the underlying bounded integer sequence, since in the reversed quiver the edge numbering won't match.

The big question is whether it is possible to create a reverse quiver so that the numbering DOES match...

What I write below refers to a commit that I can't publish, because of the problem with "reverse()". But perhaps you can already comment...

Replying to [comment:130 vdelecroix]:
> 12. Trailing whitespaces in the last line of the docstring of `has_prefix`. And also one in `_cmp_`.

Done.
 
> 13. In `__getitem__` you are building the whole list of edges of the unerlying graph but uses only at most two!

I know the INDEX of two edges in the list of all edges of the underlying graph, and I need to find out the start resp. end point of the two edges. Please tell me how to get the two edges (and ask for there start/end points) without having to pick them from the list of all edges.

> I also guess that in the particular case that you are building a path starting from the same vertex there is no need to build this list.

I think the only case in which there is no need to find out the start/end points of two edges (given by indices) in the graph is the case of `p[:]` (which returns `p`). I made this a special case, but other than that I don't see how to avoid the list of all edges (unless there is a cached TUPLE of edges of the graph, so that there is no need to re-create a list each time the list of edges is requested).

Hmmm, perhaps it makes sense to store the tuple of edges in the path semigroup! What do you think?

> 14. Still in `__getitem__`, what about supporting `-1` for the slices, i.e. `path[::-1]` would return the reverse?

OK, good idea.

> 15. Still with terminology, there are two different notions of *subword* and *factors*:
>  - the *factors* of `aba` are ``, `a`, `b`, `ab`, `ba` and `aba`,
>  - `aa` is a *subword* of `aba` but not a *factor*.

Who says that? I would never say that `aa` is a subword of `aba`.

> 16. Could you make `_cmp_`, `_repr_`, `__getitem__`, `__mod__`, `__iter__`, `_mul_` appear in the documentation (using the sphinx directive `automethod`)? `__len__` is ok since it has aliases.

It is not very common to include magic Python methods (or their SageMath equivalents) into the docs. For good or bad.
 
> 17. Could you avoid mentioning `self` in the method descriptions? You can replace by `this path`.

I tried to. In one case, where `self` appears in an equation, I left it in.

> 18. The convention for `__nonzero__` is different from words where the empty word is considered zero. What do you think?

I guess you may be right. But I hope it won't create a problem in path algebras. If it does, then I should take care of it there, though.

> 19. There is no need to duplicate the `INPUT/OUTPUT` in the class docstring and the `__init__`. Accessing the help on the class with `?` you are getting both. And I found strange to have an `OUTPUT` section here.

OK. I hope it is fine to remove it from the class and keep it in `__init__`.

> 20. (independent of this ticket) The category is set to semigroup but would rather be semigroupoid... this is a partial operation!

Indeed, but I think we have no semigroupoid yet.

> Though I like the convention of returning `None` if multiplication is not defined.

I don't like that convention, but I think it is a well-established convention in the category/coercion world.



---

archive/issue_comments_211597.json:
```json
{
    "body": "Replying to [comment:131 SimonKing]:\n> The big question is whether it is possible to create a reverse quiver so that the numbering DOES match\n>\n> ...\n> \n> Hmmm, perhaps it makes sense to store the tuple of edges in the path semigroup! What do you think?\n\nThe problem with \"reverse\" is that graphs sort the edges first by start- and endpoint and then by label. However, for my code, it makes more sense to just sort by labels (which are supposed to be unique). So, I could address both issues by storing a sorted list of edges and edge labels in the path semigroup.",
    "created_at": "2015-05-17T13:39:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211597",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:131 SimonKing]:
> The big question is whether it is possible to create a reverse quiver so that the numbering DOES match
>
> ...
> 
> Hmmm, perhaps it makes sense to store the tuple of edges in the path semigroup! What do you think?

The problem with "reverse" is that graphs sort the edges first by start- and endpoint and then by label. However, for my code, it makes more sense to just sort by labels (which are supposed to be unique). So, I could address both issues by storing a sorted list of edges and edge labels in the path semigroup.



---

archive/issue_comments_211598.json:
```json
{
    "body": "Replying to [comment:131 SimonKing]:\n> Hi Vincent,\n> \n> I just found that I need to revert my previous changes in the `reverse()` (soon to become `reversal()`) method: I can not simply revert the underlying bounded integer sequence, since in the reversed quiver the edge numbering won't match.\n> \n> The big question is whether it is possible to create a reverse quiver so that the numbering DOES match...\n\nI see... one way is to keep in the `PathSemigroup`:\n- the list of edges\n- a dictionary `edge -> index`\nIn order to ensure canonicity, you can just sort the list with respect to the labels. The problem is that in the constructor you check uniqueness but not sortability and that might be an issue! Do you mind if the labels are asked to have a total order? As a first approximation you can check that they all have the same type being one of: `int`, `float`, `Integer`, `Rational`, `str`, ... (and possibly add a keyword `assume_total_order`).\n\nThis is basically what you did propose but you need to check that the set of labels is indeed sortable!\n\n> Replying to [comment:130 vdelecroix]:\n> > 13. In `__getitem__` you are building the whole list of edges of the unerlying graph but uses only at most two!\n> \n> I know the INDEX of two edges in the list of all edges of the underlying graph, and I need to find out the start resp. end point of the two edges. Please tell me how to get the two edges (and ask for there start/end points) without having to pick them from the list of all edges.\n> \n> > I also guess that in the particular case that you are building a path starting from the same vertex there is no need to build this list.\n> \n> I think the only case in which there is no need to find out the start/end points of two edges (given by indices) in the graph is the case of `p[:]` (which returns `p`). I made this a special case, but other than that I don't see how to avoid the list of all edges (unless there is a cached TUPLE of edges of the graph, so that there is no need to re-create a list each time the list of edges is requested).\n> \n> Hmmm, perhaps it makes sense to store the tuple of edges in the path semigroup! What do you think?\n\nWould make sense if moreover it helps to ensure compatibility with the reverse!\n\n> > 15. Still with terminology, there are two different notions of *subword* and *factors*:\n> >  - the *factors* of `aba` are ``, `a`, `b`, `ab`, `ba` and `aba`,\n> >  - `aa` is a *subword* of `aba` but not a *factor*.\n> \n> Who says that? I would never say that `aa` is a subword of `aba`.\n\nSage does\n\n```\nsage: Word(\"aa\").is_subword_of(Word(\"aba\"))\nTrue\n```\n\nAnd in Lothaire book \"combinatorics on words\"\n\n```\nA word v in A^* is said to be a subword of x in A^* if \n\n    v = a_1 a_2 ... a_n\n\nand there exists y_0, y_1, ..., y_n in A^* such that\n\n   x = y_0 a_1 y_1 a_2 ... a_n y_n\n\nTherefore v is a subword of is it is a sub-sequence of x.\n```\n\n \n> > 18. The convention for `__nonzero__` is different from words where the empty word is considered zero. What do you think?\n> \n> I guess you may be right. But I hope it won't create a problem in path algebras. If it does, then I should take care of it there, though.\n\nI do not know. If you look at the category of groups for instance, there is an implementation of `__nonzero__` in elements as `return False`. So I was more asking what do you think instead of asking you to change anything.",
    "created_at": "2015-05-17T13:41:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211598",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:131 SimonKing]:
> Hi Vincent,
> 
> I just found that I need to revert my previous changes in the `reverse()` (soon to become `reversal()`) method: I can not simply revert the underlying bounded integer sequence, since in the reversed quiver the edge numbering won't match.
> 
> The big question is whether it is possible to create a reverse quiver so that the numbering DOES match...

I see... one way is to keep in the `PathSemigroup`:
- the list of edges
- a dictionary `edge -> index`
In order to ensure canonicity, you can just sort the list with respect to the labels. The problem is that in the constructor you check uniqueness but not sortability and that might be an issue! Do you mind if the labels are asked to have a total order? As a first approximation you can check that they all have the same type being one of: `int`, `float`, `Integer`, `Rational`, `str`, ... (and possibly add a keyword `assume_total_order`).

This is basically what you did propose but you need to check that the set of labels is indeed sortable!

> Replying to [comment:130 vdelecroix]:
> > 13. In `__getitem__` you are building the whole list of edges of the unerlying graph but uses only at most two!
> 
> I know the INDEX of two edges in the list of all edges of the underlying graph, and I need to find out the start resp. end point of the two edges. Please tell me how to get the two edges (and ask for there start/end points) without having to pick them from the list of all edges.
> 
> > I also guess that in the particular case that you are building a path starting from the same vertex there is no need to build this list.
> 
> I think the only case in which there is no need to find out the start/end points of two edges (given by indices) in the graph is the case of `p[:]` (which returns `p`). I made this a special case, but other than that I don't see how to avoid the list of all edges (unless there is a cached TUPLE of edges of the graph, so that there is no need to re-create a list each time the list of edges is requested).
> 
> Hmmm, perhaps it makes sense to store the tuple of edges in the path semigroup! What do you think?

Would make sense if moreover it helps to ensure compatibility with the reverse!

> > 15. Still with terminology, there are two different notions of *subword* and *factors*:
> >  - the *factors* of `aba` are ``, `a`, `b`, `ab`, `ba` and `aba`,
> >  - `aa` is a *subword* of `aba` but not a *factor*.
> 
> Who says that? I would never say that `aa` is a subword of `aba`.

Sage does

```
sage: Word("aa").is_subword_of(Word("aba"))
True
```

And in Lothaire book "combinatorics on words"

```
A word v in A^* is said to be a subword of x in A^* if 

    v = a_1 a_2 ... a_n

and there exists y_0, y_1, ..., y_n in A^* such that

   x = y_0 a_1 y_1 a_2 ... a_n y_n

Therefore v is a subword of is it is a sub-sequence of x.
```

 
> > 18. The convention for `__nonzero__` is different from words where the empty word is considered zero. What do you think?
> 
> I guess you may be right. But I hope it won't create a problem in path algebras. If it does, then I should take care of it there, though.

I do not know. If you look at the category of groups for instance, there is an implementation of `__nonzero__` in elements as `return False`. So I was more asking what do you think instead of asking you to change anything.



---

archive/issue_comments_211599.json:
```json
{
    "body": "Replying to [comment:133 vdelecroix]:\n> In order to ensure canonicity, you can just sort the list with respect to the labels. The problem is that in the constructor you check uniqueness but not sortability and that might be an issue! Do you mind if the labels are asked to have a total order? As a first approximation you can check that they all have the same type being one of: `int`, `float`, `Integer`, `Rational`, `str`, ... (and possibly add a keyword `assume_total_order`).\n\nI do check that all vertex labels are integers and all edge labels are strings.\n\n\n> This is basically what you did propose but you need to check that the set of labels is indeed sortable!\n\nWell, I just sort them...\n \n> Sage does\n> {{{\n> sage: Word(\"aa\").is_subword_of(Word(\"aba\"))\n> True\n> }}}\n\nUnbelievable. Both from algebraic and linguistic point of view I would say that Sage's answer is wrong.\n\n> And in Lothaire book \"combinatorics on words\"\n> {{{\n> A word v in A^* is said to be a subword of x in A^* if \n> \n>     v = a_1 a_2 ... a_n\n> \n> and there exists y_0, y_1, ..., y_n in A^* such that\n> \n>    x = y_0 a_1 y_1 a_2 ... a_n y_n\n> \n> Therefore v is a subword of is it is a sub-sequence of x.\n> }}}\n\nNice notion, but nothing that I would call a subword or sub-sequence.",
    "created_at": "2015-05-17T14:15:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211599",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:133 vdelecroix]:
> In order to ensure canonicity, you can just sort the list with respect to the labels. The problem is that in the constructor you check uniqueness but not sortability and that might be an issue! Do you mind if the labels are asked to have a total order? As a first approximation you can check that they all have the same type being one of: `int`, `float`, `Integer`, `Rational`, `str`, ... (and possibly add a keyword `assume_total_order`).

I do check that all vertex labels are integers and all edge labels are strings.


> This is basically what you did propose but you need to check that the set of labels is indeed sortable!

Well, I just sort them...
 
> Sage does
> {{{
> sage: Word("aa").is_subword_of(Word("aba"))
> True
> }}}

Unbelievable. Both from algebraic and linguistic point of view I would say that Sage's answer is wrong.

> And in Lothaire book "combinatorics on words"
> {{{
> A word v in A^* is said to be a subword of x in A^* if 
> 
>     v = a_1 a_2 ... a_n
> 
> and there exists y_0, y_1, ..., y_n in A^* such that
> 
>    x = y_0 a_1 y_1 a_2 ... a_n y_n
> 
> Therefore v is a subword of is it is a sub-sequence of x.
> }}}

Nice notion, but nothing that I would call a subword or sub-sequence.



---

archive/issue_comments_211600.json:
```json
{
    "body": "Replying to [comment:134 SimonKing]:\n> Nice notion, but nothing that I would call a subword or sub-sequence.\n\nSorry, I have to correct myself.\n\nI do call it a sub-sequence (in calculus, one has statements such as \"x is a cumulation point of a sequence if and only if there is a sub-sequence converging to x\"), but I would not call it a sub-word. Python seems to agree:\n\n```\nsage: 'aa' in 'abac'\nFalse\nsage: 'ba' in 'abac'\nTrue\n```\n\n\nAnd in the case of paths, it is *not* true that a sub-sequence of arrows gives rise to a path (in a path, the end/starting points of consecutive arrows must match). So, for sub-paths, it simply makes no sense to adopt the notion of a sub-word that Sage unfortunately uses.",
    "created_at": "2015-05-17T14:24:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211600",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:134 SimonKing]:
> Nice notion, but nothing that I would call a subword or sub-sequence.

Sorry, I have to correct myself.

I do call it a sub-sequence (in calculus, one has statements such as "x is a cumulation point of a sequence if and only if there is a sub-sequence converging to x"), but I would not call it a sub-word. Python seems to agree:

```
sage: 'aa' in 'abac'
False
sage: 'ba' in 'abac'
True
```


And in the case of paths, it is *not* true that a sub-sequence of arrows gives rise to a path (in a path, the end/starting points of consecutive arrows must match). So, for sub-paths, it simply makes no sense to adopt the notion of a sub-word that Sage unfortunately uses.



---

archive/issue_comments_211601.json:
```json
{
    "body": "Replying to [comment:135 SimonKing]:\n> Replying to [comment:134 SimonKing]:\n> > Nice notion, but nothing that I would call a subword or sub-sequence.\n> \n> Sorry, I have to correct myself.\n> Python seems to agree:\n> {{{\n> sage: 'aa' in 'abac'\n> False\n> sage: 'ba' in 'abac'\n> True\n> }}}\n\nHere I do not like so much Python convention because you might not want consider 'contains' as an equivalent of 'factor'. For words, we did adopt the convetion that 'contains' means that the letter is contained in. Just like for lists, tuples\n\n```\nsage: [0, 1] in [0, 1, 2]\nFalse\nsage: 0 in [0, 1, 2]\nTrue\n```\n\n\n> And in the case of paths, it is *not* true that a sub-sequence of arrows gives rise to a path (in a path, the end/starting points of consecutive arrows must match). So, for sub-paths, it simply makes no sense to adopt the notion of a sub-word that Sage unfortunately uses.\n\nThat's why I said there is no ambiguity for paths ;-)",
    "created_at": "2015-05-17T14:30:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211601",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:135 SimonKing]:
> Replying to [comment:134 SimonKing]:
> > Nice notion, but nothing that I would call a subword or sub-sequence.
> 
> Sorry, I have to correct myself.
> Python seems to agree:
> {{{
> sage: 'aa' in 'abac'
> False
> sage: 'ba' in 'abac'
> True
> }}}

Here I do not like so much Python convention because you might not want consider 'contains' as an equivalent of 'factor'. For words, we did adopt the convetion that 'contains' means that the letter is contained in. Just like for lists, tuples

```
sage: [0, 1] in [0, 1, 2]
False
sage: 0 in [0, 1, 2]
True
```


> And in the case of paths, it is *not* true that a sub-sequence of arrows gives rise to a path (in a path, the end/starting points of consecutive arrows must match). So, for sub-paths, it simply makes no sense to adopt the notion of a sub-word that Sage unfortunately uses.

That's why I said there is no ambiguity for paths ;-)



---

archive/issue_comments_211602.json:
```json
{
    "body": "For the record: The changes discussed in the previous comments seem mostly harmless. But in fact, they break most of the tests, for reasons that are currently a mystery for me.",
    "created_at": "2015-05-17T15:58:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211602",
    "user": "https://github.com/simon-king-jena"
}
```

For the record: The changes discussed in the previous comments seem mostly harmless. But in fact, they break most of the tests, for reasons that are currently a mystery for me.



---

archive/issue_comments_211603.json:
```json
{
    "body": "*All* of the errors are caused by the change of `__nonzero__`.",
    "created_at": "2015-05-17T16:11:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211603",
    "user": "https://github.com/simon-king-jena"
}
```

*All* of the errors are caused by the change of `__nonzero__`.



---

archive/issue_comments_211604.json:
```json
{
    "body": "Replying to [comment:138 SimonKing]:\n> *All* of the errors are caused by the change of `__nonzero__`.\n\n... but it was possible to cope with it. So, soon I can push my changes...",
    "created_at": "2015-05-17T16:25:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211604",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:138 SimonKing]:
> *All* of the errors are caused by the change of `__nonzero__`.

... but it was possible to cope with it. So, soon I can push my changes...



---

archive/issue_comments_211605.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-17T16:28:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211605",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211606.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-17T16:42:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211606",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211607.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-05-17T16:50:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211607",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_211608.json:
```json
{
    "body": "I think the two preceding commits address your concerns. In detail:\n\nReplying to [comment:130 vdelecroix]:\n> 12. Trailing whitespaces in the last line of the docstring of `has_prefix`. And also one in `_cmp_`.\n\nFixed.\n \n> 13. In `__getitem__` you are building the whole list of edges of the unerlying graph but uses only at most two! I also guess that in the particular case that you are building a path starting from the same vertex there is no need to build this list.\n\nFixed, by storing a tuple of sorted edge labels and sorted edges.\n\n> 14. Still in `__getitem__`, what about supporting `-1` for the slices, i.e. `path[::-1]` would return the reverse? You can put that on the wish list, but this is how words behave\n> {{{\n> sage: w = Word(\"abbaaca\")\n> sage: w[::-1]\n> word: acaabba\n> sage: w[4:1:-1]\n> word: aab\n> }}}\n\nDone.\n\n>   and by the way `reverse` is called `reversal` there\n> {{{\n> sage: w.reversal()\n> word: acaabba\n> }}}\n\nI changed \"reverse\" to \"reversal\".\n \n> 15. Still with terminology, there are two different notions of *subword* and *factors*:\n>  - the *factors* of `aba` are ``, `a`, `b`, `ab`, `ba` and `aba`,\n>  - `aa` is a *subword* of `aba` but not a *factor*.\n\nSee previous discussion.\n\n> 16. Could you make `_cmp_`, `_repr_`, `__getitem__`, `__mod__`, `__iter__`, `_mul_` appear in the documentation (using the sphinx directive `automethod`)? `__len__` is ok since it has aliases.\n\nNot done yet. If you think that magic methods should belong to the reference manual: Can you give me a pointer how to do so? I am not in all cases (e.g., `_repr_`) convinced that the docstrings do belong to the reference manual.\n \n> 17. Could you avoid mentioning `self` in the method descriptions? You can replace by `this path`.\n\nDone, with exception of one equation.\n\n> 18. The convention for `__nonzero__` is different from words where the empty word is considered zero. What do you think?\n\nDone, which involved changes in other places.\n\n> 19. There is no need to duplicate the `INPUT/OUTPUT` in the class docstring and the `__init__`. Accessing the help on the class with `?` you are getting both. And I found strange to have an `OUTPUT` section here.\n\nOUTPUT is removed and INPUT is now only in the `__init__` docstring.",
    "created_at": "2015-05-17T16:50:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211608",
    "user": "https://github.com/simon-king-jena"
}
```

I think the two preceding commits address your concerns. In detail:

Replying to [comment:130 vdelecroix]:
> 12. Trailing whitespaces in the last line of the docstring of `has_prefix`. And also one in `_cmp_`.

Fixed.
 
> 13. In `__getitem__` you are building the whole list of edges of the unerlying graph but uses only at most two! I also guess that in the particular case that you are building a path starting from the same vertex there is no need to build this list.

Fixed, by storing a tuple of sorted edge labels and sorted edges.

> 14. Still in `__getitem__`, what about supporting `-1` for the slices, i.e. `path[::-1]` would return the reverse? You can put that on the wish list, but this is how words behave
> {{{
> sage: w = Word("abbaaca")
> sage: w[::-1]
> word: acaabba
> sage: w[4:1:-1]
> word: aab
> }}}

Done.

>   and by the way `reverse` is called `reversal` there
> {{{
> sage: w.reversal()
> word: acaabba
> }}}

I changed "reverse" to "reversal".
 
> 15. Still with terminology, there are two different notions of *subword* and *factors*:
>  - the *factors* of `aba` are ``, `a`, `b`, `ab`, `ba` and `aba`,
>  - `aa` is a *subword* of `aba` but not a *factor*.

See previous discussion.

> 16. Could you make `_cmp_`, `_repr_`, `__getitem__`, `__mod__`, `__iter__`, `_mul_` appear in the documentation (using the sphinx directive `automethod`)? `__len__` is ok since it has aliases.

Not done yet. If you think that magic methods should belong to the reference manual: Can you give me a pointer how to do so? I am not in all cases (e.g., `_repr_`) convinced that the docstrings do belong to the reference manual.
 
> 17. Could you avoid mentioning `self` in the method descriptions? You can replace by `this path`.

Done, with exception of one equation.

> 18. The convention for `__nonzero__` is different from words where the empty word is considered zero. What do you think?

Done, which involved changes in other places.

> 19. There is no need to duplicate the `INPUT/OUTPUT` in the class docstring and the `__init__`. Accessing the help on the class with `?` you are getting both. And I found strange to have an `OUTPUT` section here.

OUTPUT is removed and INPUT is now only in the `__init__` docstring.



---

archive/issue_comments_211609.json:
```json
{
    "body": "PS: Here is an improved timing, that probably is due to 1. caching the path semigroup of the reverse quiver and 2. storing the sorted edges and edge labels as attributes of path semigroups:\n\n```\nsage: D = DiGraph({0:{0:['x','y','z']}}).path_semigroup()\nsage: L = sum([list(D.iter_paths_by_length_and_startpoint(i,0)) for i in range(5)], [])\nsage: %timeit [p.reversal() for p in L]\nThe slowest run took 8.48 times longer than the fastest. This could mean that an intermediate result is being cached \n10000 loops, best of 3: 94.5 \u00b5s per loop\nsage: %timeit [p.reversal() for p in L]\n10000 loops, best of 3: 95.7 \u00b5s per loop\n```\n\nBefore, it was about 44 ms (not \u00b5s).",
    "created_at": "2015-05-17T16:57:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211609",
    "user": "https://github.com/simon-king-jena"
}
```

PS: Here is an improved timing, that probably is due to 1. caching the path semigroup of the reverse quiver and 2. storing the sorted edges and edge labels as attributes of path semigroups:

```
sage: D = DiGraph({0:{0:['x','y','z']}}).path_semigroup()
sage: L = sum([list(D.iter_paths_by_length_and_startpoint(i,0)) for i in range(5)], [])
sage: %timeit [p.reversal() for p in L]
The slowest run took 8.48 times longer than the fastest. This could mean that an intermediate result is being cached 
10000 loops, best of 3: 94.5 µs per loop
sage: %timeit [p.reversal() for p in L]
10000 loops, best of 3: 95.7 µs per loop
```

Before, it was about 44 ms (not µs).



---

archive/issue_comments_211610.json:
```json
{
    "body": "Another timing, for getitem:\n\n```\nsage: Q = DiGraph({1:{2:['a']}, 2:{3:['b']}, 3:{4:['c'], 1:['d']}}).path_semigroup()\nsage: p = Q([(1, 2, 'a'), (2, 3, 'b'), (3, 1, 'd'), (1, 2, 'a'), (2, 3, 'b'), (3, 4, 'c')])\nsage: %timeit p[3]\nThe slowest run took 23.67 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 1.23 \u00b5s per loop\nsage: %timeit p[3]\nThe slowest run took 21.02 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 1.24 \u00b5s per loop\nsage: %timeit p[1:4]\nThe slowest run took 35.55 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 1.1 \u00b5s per loop\nsage: %timeit p[1:4]\nThe slowest run took 20.14 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 1.1 \u00b5s per loop\n```\n\nRemoving the last two commits, getitem is much slower:\n\n```\nsage: Q = DiGraph({1:{2:['a']}, 2:{3:['b']}, 3:{4:['c'], 1:['d']}}).path_semigroup()\nsage: p = Q([(1, 2, 'a'), (2, 3, 'b'), (3, 1, 'd'), (1, 2, 'a'), (2, 3, 'b'), (3, 4, 'c')])\nsage: %timeit p[3]\nThe slowest run took 4.54 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 13.6 \u00b5s per loop\nsage: %timeit p[3]\nThe slowest run took 4.32 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 13.7 \u00b5s per loop\nsage: %timeit p[1:4]\nThe slowest run took 4.52 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 13 \u00b5s per loop\nsage: %timeit p[1:4]\nThe slowest run took 4.42 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 13.1 \u00b5s per loop\n```\n\n\nI suppose the reason for the improvement is, again, avoiding to recreate the list of edges of the quiver.",
    "created_at": "2015-05-17T17:03:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211610",
    "user": "https://github.com/simon-king-jena"
}
```

Another timing, for getitem:

```
sage: Q = DiGraph({1:{2:['a']}, 2:{3:['b']}, 3:{4:['c'], 1:['d']}}).path_semigroup()
sage: p = Q([(1, 2, 'a'), (2, 3, 'b'), (3, 1, 'd'), (1, 2, 'a'), (2, 3, 'b'), (3, 4, 'c')])
sage: %timeit p[3]
The slowest run took 23.67 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.23 µs per loop
sage: %timeit p[3]
The slowest run took 21.02 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.24 µs per loop
sage: %timeit p[1:4]
The slowest run took 35.55 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.1 µs per loop
sage: %timeit p[1:4]
The slowest run took 20.14 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.1 µs per loop
```

Removing the last two commits, getitem is much slower:

```
sage: Q = DiGraph({1:{2:['a']}, 2:{3:['b']}, 3:{4:['c'], 1:['d']}}).path_semigroup()
sage: p = Q([(1, 2, 'a'), (2, 3, 'b'), (3, 1, 'd'), (1, 2, 'a'), (2, 3, 'b'), (3, 4, 'c')])
sage: %timeit p[3]
The slowest run took 4.54 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 13.6 µs per loop
sage: %timeit p[3]
The slowest run took 4.32 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 13.7 µs per loop
sage: %timeit p[1:4]
The slowest run took 4.52 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 13 µs per loop
sage: %timeit p[1:4]
The slowest run took 4.42 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 13.1 µs per loop
```


I suppose the reason for the improvement is, again, avoiding to recreate the list of edges of the quiver.



---

archive/issue_comments_211611.json:
```json
{
    "body": "According to the plugin, I forgot to add tests for one function in `paths.pyx`. But which one?\n\nIt seems to be `__cmp__`, but that's in fact tested in `_cmp_`.",
    "created_at": "2015-05-17T23:49:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211611",
    "user": "https://github.com/simon-king-jena"
}
```

According to the plugin, I forgot to add tests for one function in `paths.pyx`. But which one?

It seems to be `__cmp__`, but that's in fact tested in `_cmp_`.



---

archive/issue_comments_211612.json:
```json
{
    "body": "\n```\ndef __cmp__(self, other):\n    r\"\"\"\n    TESTS::\n\n        sage: print \"this is tested in _cmp_\"  # indirect doctest\n        this is tested in _cmp_\n    \"\"\"\n```\n\n\nMore seriously, you can try to compare an empty path with the integer 1 here.\n\nVincent",
    "created_at": "2015-05-18T07:32:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211612",
    "user": "https://github.com/videlec"
}
```


```
def __cmp__(self, other):
    r"""
    TESTS::

        sage: print "this is tested in _cmp_"  # indirect doctest
        this is tested in _cmp_
    """
```


More seriously, you can try to compare an empty path with the integer 1 here.

Vincent



---

archive/issue_comments_211613.json:
```json
{
    "body": "And I just noticed that you have an unused variable `cdef tuple arrow` in the constructor of paths.",
    "created_at": "2015-05-18T07:34:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211613",
    "user": "https://github.com/videlec"
}
```

And I just noticed that you have an unused variable `cdef tuple arrow` in the constructor of paths.



---

archive/issue_comments_211614.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-18T09:07:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211614",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_211615.json:
```json
{
    "body": "Replying to [comment:147 vdelecroix]:\n> And I just noticed that you have an unused variable `cdef tuple arrow` in the constructor of paths.\n\nI removed that line and added a test for `__cmp__` (sorry, I forgot to add \"indirect doctest\").",
    "created_at": "2015-05-18T09:08:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211615",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:147 vdelecroix]:
> And I just noticed that you have an unused variable `cdef tuple arrow` in the constructor of paths.

I removed that line and added a test for `__cmp__` (sorry, I forgot to add "indirect doctest").



---

archive/issue_comments_211616.json:
```json
{
    "body": "Replying to [comment:149 SimonKing]:\n> I removed that line and added a test for `__cmp__` (sorry, I forgot to add \"indirect doctest\").\n\nNice! The coverage script is clever enough to find that comparison *is* tested:\n\n```\n> ./sage --coverage src/sage/quivers/\n------------------------------------------------------------------------\nNo functions in src/sage/quivers/__init__.py\n------------------------------------------------------------------------\nSCORE src/sage/quivers/algebra.py: 100.0% (19 of 19)\n------------------------------------------------------------------------\nSCORE src/sage/quivers/homspace.py: 100.0% (16 of 16)\n------------------------------------------------------------------------\nSCORE src/sage/quivers/morphism.py: 100.0% (34 of 34)\n------------------------------------------------------------------------\nSCORE src/sage/quivers/path_semigroup.py: 100.0% (27 of 27)\n------------------------------------------------------------------------\nSCORE src/sage/quivers/paths.pyx: 100.0% (19 of 19)\n------------------------------------------------------------------------\nSCORE src/sage/quivers/representation.py: 100.0% (57 of 57)\n------------------------------------------------------------------------\n```\n",
    "created_at": "2015-05-18T09:10:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211616",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:149 SimonKing]:
> I removed that line and added a test for `__cmp__` (sorry, I forgot to add "indirect doctest").

Nice! The coverage script is clever enough to find that comparison *is* tested:

```
> ./sage --coverage src/sage/quivers/
------------------------------------------------------------------------
No functions in src/sage/quivers/__init__.py
------------------------------------------------------------------------
SCORE src/sage/quivers/algebra.py: 100.0% (19 of 19)
------------------------------------------------------------------------
SCORE src/sage/quivers/homspace.py: 100.0% (16 of 16)
------------------------------------------------------------------------
SCORE src/sage/quivers/morphism.py: 100.0% (34 of 34)
------------------------------------------------------------------------
SCORE src/sage/quivers/path_semigroup.py: 100.0% (27 of 27)
------------------------------------------------------------------------
SCORE src/sage/quivers/paths.pyx: 100.0% (19 of 19)
------------------------------------------------------------------------
SCORE src/sage/quivers/representation.py: 100.0% (57 of 57)
------------------------------------------------------------------------
```




---

archive/issue_comments_211617.json:
```json
{
    "body": "Hello Simon,\n\n21. I propose a commit to simplify the `check` in element construction. It removes the argument from the `QuiverPath` and move all the code to check inside ` PathSemigroup`. In doing so I removed the ability to initialize a path from\n\n```\n[(1,1), (1,2,'a'), (2,2)]\n```\n\n  Tell me what you think.\n\n22. Are you intensively using the iteration over paths? If so, note that it can be much much faster.\n\nVincent\n----\nNew commits:",
    "created_at": "2015-05-24T11:28:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211617",
    "user": "https://github.com/videlec"
}
```

Hello Simon,

21. I propose a commit to simplify the `check` in element construction. It removes the argument from the `QuiverPath` and move all the code to check inside ` PathSemigroup`. In doing so I removed the ability to initialize a path from

```
[(1,1), (1,2,'a'), (2,2)]
```

  Tell me what you think.

22. Are you intensively using the iteration over paths? If so, note that it can be much much faster.

Vincent
----
New commits:



---

archive/issue_comments_211618.json:
```json
{
    "body": "Replying to [comment:151 vdelecroix]:\n> 21. I propose a commit to simplify the `check` in element construction. It removes the argument from the `QuiverPath` and move all the code to check inside ` PathSemigroup`.\n\nI think that's rather reasonable.\n\n> In doing so I removed the ability to initialize a path from\n> {{{\n> [(1,1), (1,2,'a'), (2,2)]\n> }}}\n>   Tell me what you think.\n\nIn my applications, I would never represent a path in that way. So, it's fine for me.\n\n> 22. Are you intensively using the iteration over paths?\n\nNo.\n\n> If so, note that it can be much much faster.\n\nHow? I don't use iteration so much, but other people might do.",
    "created_at": "2015-05-25T15:03:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211618",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:151 vdelecroix]:
> 21. I propose a commit to simplify the `check` in element construction. It removes the argument from the `QuiverPath` and move all the code to check inside ` PathSemigroup`.

I think that's rather reasonable.

> In doing so I removed the ability to initialize a path from
> {{{
> [(1,1), (1,2,'a'), (2,2)]
> }}}
>   Tell me what you think.

In my applications, I would never represent a path in that way. So, it's fine for me.

> 22. Are you intensively using the iteration over paths?

No.

> If so, note that it can be much much faster.

How? I don't use iteration so much, but other people might do.



---

archive/issue_comments_211619.json:
```json
{
    "body": "Replying to [comment:152 SimonKing]:\n> > 22. Are you intensively using the iteration over paths?\n> \n> No.\n> \n> > If so, note that it can be much much faster.\n> \n> How? I don't use iteration so much, but other people might do.\n\n- no recursion, this is a simple depth first search in the tree of all paths\n- initialize all paths of length 1 as `QuiverPath`s, put them in a dictionary `s -> path of length 1 with label s` or `i -> list of edges starting from i` (I would use the second form). Then use concatenation to build larger paths from smaller ones.\n- maintain the list of prefix used\n\nDo you want it to be done in this ticket?\n\nVincent",
    "created_at": "2015-05-25T19:20:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211619",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:152 SimonKing]:
> > 22. Are you intensively using the iteration over paths?
> 
> No.
> 
> > If so, note that it can be much much faster.
> 
> How? I don't use iteration so much, but other people might do.

- no recursion, this is a simple depth first search in the tree of all paths
- initialize all paths of length 1 as `QuiverPath`s, put them in a dictionary `s -> path of length 1 with label s` or `i -> list of edges starting from i` (I would use the second form). Then use concatenation to build larger paths from smaller ones.
- maintain the list of prefix used

Do you want it to be done in this ticket?

Vincent



---

archive/issue_comments_211620.json:
```json
{
    "body": "Replying to [comment:153 vdelecroix]:\n> Do you want it to be done in this ticket?\n\nThe purpose of this ticket is to obtain a speed-up by using Cython code based on bounded integer sequences. Hence, obtaining a speed-up by using a better algorithm should perhaps better be done on a separate ticket.",
    "created_at": "2015-05-25T20:27:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211620",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:153 vdelecroix]:
> Do you want it to be done in this ticket?

The purpose of this ticket is to obtain a speed-up by using Cython code based on bounded integer sequences. Hence, obtaining a speed-up by using a better algorithm should perhaps better be done on a separate ticket.



---

archive/issue_comments_211621.json:
```json
{
    "body": "I am done with the review of your commits.\n\nIf you are ok with `\u200b3c4c54a` then you can set to positive review.\n\nVincent",
    "created_at": "2015-05-25T20:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211621",
    "user": "https://github.com/videlec"
}
```

I am done with the review of your commits.

If you are ok with `​3c4c54a` then you can set to positive review.

Vincent



---

archive/issue_comments_211622.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-05-25T20:47:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211622",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_211623.json:
```json
{
    "body": "Replying to [comment:155 vdelecroix]:\n> I am done with the review of your commits.\n> \n> If you are ok with `\u200b3c4c54a` then you can set to positive review.\n\nI am! And the patchbot confirms that tests pass.\n\nJust to cross-verify: The patchbot complains that the branch introduces a non-ascii character (in \"Poincar\u00e9\"). Since I use the encoding utf-8 in the file, the documentation should build fine. So, do you agree that the non-ascii character is not a problem?",
    "created_at": "2015-05-25T20:47:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211623",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:155 vdelecroix]:
> I am done with the review of your commits.
> 
> If you are ok with `​3c4c54a` then you can set to positive review.

I am! And the patchbot confirms that tests pass.

Just to cross-verify: The patchbot complains that the branch introduces a non-ascii character (in "Poincaré"). Since I use the encoding utf-8 in the file, the documentation should build fine. So, do you agree that the non-ascii character is not a problem?



---

archive/issue_comments_211624.json:
```json
{
    "body": "According to [PEP 0263](https://www.python.org/dev/peps/pep-0263/) this is not the proper way to declare encoding. Should be one of\n\n```\n# coding=<encoding name>\n# -*- coding: <encoding name> -*-\n# vim: set fileencoding=<encoding name> :\n```\n\n(i.e. it uses `coding` and not `encoding`).\n\nOn the other hand, the unicode plugin of the patchbot is broken I think.",
    "created_at": "2015-05-25T21:02:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211624",
    "user": "https://github.com/videlec"
}
```

According to [PEP 0263](https://www.python.org/dev/peps/pep-0263/) this is not the proper way to declare encoding. Should be one of

```
# coding=<encoding name>
# -*- coding: <encoding name> -*-
# vim: set fileencoding=<encoding name> :
```

(i.e. it uses `coding` and not `encoding`).

On the other hand, the unicode plugin of the patchbot is broken I think.



---

archive/issue_comments_211625.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-05-25T22:49:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211625",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_015756.json:
```json
{
    "actor": "@vbraun",
    "created_at": "2015-05-25T22:49:47Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16216#event-15756"
}
```



---

archive/issue_comments_211626.json:
```json
{
    "body": "In `__mod__(self, other)`, is there any particular reason why you want to support `other = None`?",
    "created_at": "2016-01-22T10:35:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211626",
    "user": "https://github.com/jdemeyer"
}
```

In `__mod__(self, other)`, is there any particular reason why you want to support `other = None`?



---

archive/issue_comments_211627.json:
```json
{
    "body": "If you don't object, I will remove support for `self % None` in #269.",
    "created_at": "2016-01-22T11:07:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211627",
    "user": "https://github.com/jdemeyer"
}
```

If you don't object, I will remove support for `self % None` in #269.



---

archive/issue_comments_211628.json:
```json
{
    "body": "Replying to [comment:160 jdemeyer]:\n> If you don't object, I will remove support for `self % None` in #269.\n\nI don't recall whether I need \"a%None\" for anything. So, I guess it can be dropped.",
    "created_at": "2016-01-22T14:21:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16216",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16216#issuecomment-211628",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:160 jdemeyer]:
> If you don't object, I will remove support for `self % None` in #269.

I don't recall whether I need "a%None" for anything. So, I guess it can be dropped.
