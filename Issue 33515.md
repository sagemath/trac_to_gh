# Issue 33515: Implement solid angle measure for two-dimensional cones

Issue created by migration from https://trac.sagemath.org/ticket/33752

Original creator: @allisonfitisone

Original creation time: 2022-04-25 01:23:21

CC:  yzh mkoeppe

Keywords: solid angle

Implement the solid angle measure (the plane angle) of a two-dimensional cone, using the dot-product (trigonometry) formula. When the cone is not simplicial, it is decomposed into simplicial cones.

For example, the solid angle of the upper half plane (generated by three rays, hence not simplicial) `solid_angle_2d([[1,0],[0,1],[-1,0]])` is 1/2.


---

Comment by mkoeppe created at 2022-04-25 02:39:18

The only non-simplicial cones in 2d are the non-pointed cones, i.e., cones that contain a nontrivial subspace. So the answer is either 0, 1/2, or 1; no triangulation is needed.


---

Comment by yzh created at 2022-04-26 19:55:36

Merged in #33656.


---

Comment by git created at 2022-05-06 15:23:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-12 17:17:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by yzh created at 2022-05-12 17:28:47

When `P.is_exact() or isinstance(P, sage.rings.abc.SymbolicRing)`, the return type should be `SymbolicConstantsSubring` element


---

Comment by git created at 2022-05-17 12:47:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-17 19:27:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-19 19:34:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @allisonfitisone created at 2022-05-19 19:36:24

Changing status from new to needs_review.


---

Comment by git created at 2022-08-25 15:49:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-25 16:24:35


```
+                    var('a b')
+                    eqn = (-a * v[0][0] - b * v[k][0] - v[j][0] == 0,
+                           -a * v[0][1] - b * v[k][1] - v[j][1] == 0,
+                           a >= 0,
+                           b >= 0)
+                    if solve(eqn, (a, b)):
```

Best not to use the general symbolics facility (`var`, `solve`) for linear algebra


---

Comment by mkoeppe created at 2022-08-25 16:26:03

Functions that looks like this:

```
+        matrices = []
+        for simplex in triangulation:
+            matrices.append(matrix(A[i] for i in simplex if i != origin))
+        return matrices
```

... are best rewritten as generators. https://realpython.com/introduction-to-python-generators/#understanding-generators


---

Comment by mkoeppe created at 2022-08-25 16:28:18


```
+    This example shows that the cone in `\RR^4` spanned by the rows of ``A``
+    (which is input as a list of lists) is actually a halfspace of affine
+    dimension `2`. The triangulation dissects it into three 2-d subcones::
+
+        sage: A_in = [[-3,0,5,0],[0,0,1,0],[-4,0,0,0],[-1,0,0,0],[0,0,-4,0]]
+        sage: simplicial_subcones_decomposition(A_in)
+        [
+        [-3  0  5  0]  [-3  0  5  0]  [-4  0  0  0]
+        [ 0  0  1  0], [-4  0  0  0], [ 0  0 -4  0]
+        ]
```

This decomposition looks correct, but I don't think this is the best way of computing the solid angle - as I explained in comment:1.


---

Comment by mkoeppe created at 2022-08-25 16:31:27

All of this can be replaced by just using `Polyhedron(rays=A.rows())`. To see whether it is at least a halfplane, check `lines()`


---

Comment by @allisonfitisone created at 2022-08-30 19:31:43

When using `Polyhedron(rays=A.rows())`, we can't do computations over SR (see below). Any suggestions for a workaround?

```
sage: A = matrix([[sqrt(2),0],[0,1]])
sage: solid_angle_2d(A)
ValueError: no default backend for computations with Symbolic Ring
```


Replying to [comment:17 mkoeppe]:
> All of this can be replaced by just using `Polyhedron(rays=A.rows())`. To see whether it is at least a halfplane, check `lines()`


---

Comment by mkoeppe created at 2022-08-30 19:35:47

If you only need algebraic numbers, you can use `A = matrix(AA, [[sqrt(2),0],[0,1]])`


---

Comment by yzh created at 2022-08-30 20:02:10

Right, if the input is of type AA, then Polyhedron can deal with it, and the output is also of type AA. The question is, what if the input is just `A = matrix([[sqrt(2),0],[0,1]])`? Would it be better to avoid Polyhedron and just use more elementary operations like rank?
Replying to [comment:19 mkoeppe]:
> If you only need algebraic numbers, you can use `A = matrix(AA, [[sqrt(2),0],[0,1]])`


---

Comment by mkoeppe created at 2022-08-30 20:11:51

Replying to [comment:20 yzh]:
> Right, if the input is of type AA, then Polyhedron can deal with it, and the output is also of type AA. The question is, what if the input is just `A = matrix([[sqrt(2),0],[0,1]])`? 

Well, you can try to convert it to a matrix space over `AA`, and if that fails, just raise an error.

> Would it be better to avoid Polyhedron and just use more elementary operations like rank?

Do you have an application for non-algebraic irrational input?

If yes, then yes, one would have to either avoid Polyhedron or extend Polyhedron so it can handle well-behaved symbolic elements. After all, this error:

```
sage: Polyhedron(vertices=[[1], [sqrt(2)]], base_ring=SR, backend='field')
ValueError: the 'field' backend for polyhedron cannot be used with non-exact fields
```

is artificial - it's there to protect users from weird stuff that can happen.

If no, then maybe this generality is not worth working on?


---

Comment by yzh created at 2022-08-30 21:26:16

You are right, I don't have an application where the input is non-algebraic irrationals. 

I agree that symbolics facility (`var` and `solve`) should be avoid.

However, I thought that checking the special cases of half space and whole space is straightforward enough, which make the use of Polyhedron and the conversion to AA seem overkill. It's just some if else statements, and with that, the input `A = matrix([[sqrt(2),0],[0,1]])` can work. In my option, it's unusual to input `matrix(AA, [[sqrt(2),0],[0,1]])`. 

Also, if we convert the inputs matrix to over AA, what would be the right type of the output? Do we always have AA as output type, never the Symbolic ring or Symbolic Constants Subring?


---

Comment by mkoeppe created at 2022-08-30 21:41:58

Replying to [comment:22 yzh]:
> Also, if we convert the inputs matrix to over AA, what would be the right type of the output? Do we always have AA as output type, never the Symbolic ring or Symbolic Constants Subring?

Yes, it would make sense to convert it back to the ring where it came from if AA is used internally. (That's how we do this for the `Polyhedron(backend='normaliz')`, by the way.)


---

Comment by git created at 2022-09-01 20:11:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by yzh created at 2022-09-02 01:42:48

Do you mean to use `number_field_elements_from_algebraics` from `sage.rings.qqbar`?
I still don't see how to convert `AA(sqrt(2))` (interval AA number) back to `sqrt(2)` as output, if the input was in the symbolic ring.

Replying to [comment:23 mkoeppe]:
> Replying to [comment:22 yzh]:
> > Also, if we convert the inputs matrix to over AA, what would be the right type of the output? Do we always have AA as output type, never the Symbolic ring or Symbolic Constants Subring?
> 
> Yes, it would make sense to convert it back to the ring where it came from if AA is used internally. (That's how we do this for the `Polyhedron(backend='normaliz')`, by the way.)


---

Comment by mkoeppe created at 2022-09-02 01:47:51

First check if `Polyhedron(..., backend='normaliz')` is able to handle the kinds of numbers you'd like to handle and gives back SR elements.


---

Comment by yzh created at 2022-09-02 02:01:44

Sure, using `backend='normaliz'` solves most cases. The problem is that this is an optional backend. Do we really want to use an optional package that most users don't install to deal with something so elementary -- 2 very special cases in 2D?

Replying to [comment:26 mkoeppe]:
> First check if `Polyhedron(..., backend='normaliz')` is able to handle the kinds of numbers you'd like to handle and gives back SR elements.


---

Comment by mkoeppe created at 2022-09-02 02:03:43

Your code would still work without normaliz for rational input.


---

Comment by yzh created at 2022-09-02 02:09:03

Yes, that's right. As it's quite usual to have sqrt(2), sqrt(3) in rays (45°, 60°), I think the code should work for these cases regardless of having normaliz or not.

Replying to [comment:28 mkoeppe]:
> Your code would still work without normaliz for rational input.


---

Comment by mkoeppe created at 2022-09-02 02:12:45

I think some more thought on the use cases is needed. Where do your irrational inputs come from? If you already have angles, there's no need to recompute them


---

Comment by mkoeppe created at 2022-09-02 02:14:30

Replying to [comment:27 yzh]:
> Sure, using `backend='normaliz'` solves most cases. 

I mean I know that it can deal with `sqrt(2)`. Have you checked other cases? What are "most", are there exceptions that are motivated by an application?


---

Comment by yzh created at 2022-09-02 02:24:01

I don't really have use cases in 2D, 2D angles are trivial...

It feels weird that if a Calculus student wants to compute the angle between ray (1, 0) and ray (0, sqrt(3)), they must have normaliz installed. 

My thought is not to use Polyhedron in 2d, but just check for the two special cases.

Alternatively, we can use `P = Polyhedron(rays=A.rows(), base_ring=AA)` which doesn't call normaliz. But then, I don't know how to convert the AA result back to symbolic.


---

Comment by mkoeppe created at 2022-09-02 02:26:47

Replying to [comment:32 yzh]:
> Alternatively, we can use `P = Polyhedron(rays=A.rows(), base_ring=AA)` which doesn't call normaliz. But then, I don't know how to convert the AA result back to symbolic.

You're missing that the conversion code that is in our Normaliz backend does not need Normaliz. We are using it to communicate with Normaliz.


---

Comment by yzh created at 2022-09-02 02:28:52

I know that "conversion code that is in our Normaliz backend does not need Normaliz."
But how does it help with 2d solid angle? 

> Replying to [comment:32 yzh]:
> > Alternatively, we can use `P = Polyhedron(rays=A.rows(), base_ring=AA)` which doesn't call normaliz. But then, I don't know how to convert the AA result back to symbolic.
> 
> You're missing that the conversion code that is in our Normaliz backend does not need Normaliz. We are using it to communicate with Normaliz.


---

Comment by mkoeppe created at 2022-09-02 02:30:15

See #34479


---

Comment by yzh created at 2022-09-02 02:34:53

I agree with #34479. That ticket will become more useful when we write code for solid angle computation in higher dimension. In 2d, it is like shooting butterfly with rifles :P, but why not...
