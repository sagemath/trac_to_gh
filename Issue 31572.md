# Issue 31572: WeilPolynomials segfault with squarefree=True

Issue created by migration from https://trac.sagemath.org/ticket/31809

Original creator: edgarcosta

Original creation time: 2021-05-11 01:46:04

CC:  kedlaya roed

```
sage: from sage.rings.polynomial.weil.weil_polynomials import WeilPolynomials
sage: foo = list(WeilPolynomials(12, 3, lead=(1,0,9,2,46), squarefree=False))
sage: bar = list(WeilPolynomials(12, 3, lead=(1,0,9,2,46), squarefree=True))
Exception (fmpz_divexact_si). Division by zero.
------------------------------------------------------------------------
(no backtrace available)
------------------------------------------------------------------------
Unhandled SIGABRT: An abort() occurred.
This probably occurred because a *compiled* module has a bug
in it and is not properly wrapped with sig_on(), sig_off().
Python will now terminate.
------------------------------------------------------------------------
/Applications/sage-dev/src/bin/sage-python: line 2:  2188 Abort trap: 6           sage -python "$`@`"
```

For a full core dump see: https://gist.github.com/edgarcosta/ef611a40bee98da46bcac50781324620 (comes from another machine)


---

Comment by edgarcosta created at 2021-05-11 19:08:08

I think the issue is this block


```
    if (!force_squarefree && _fmpz_vec_is_zero(f0, n)) return(1);

    /* If we miss any one sign change, we cannot have enough. */
    if (fmpz_sgn(f0+n-1) != sgn0_l) return(0);

    if (n==1) return(1); /* If f0 is a scalar, it is nonzero and we win. */

    /* Extract content from f0; in practice, this seems to do better than
       an explicit subresultant computation. */
    _fmpz_vec_content(c, f0, n);
    _fmpz_vec_scalar_divexact_fmpz(f0, f0, n, c);
```

ref: https://github.com/sagemath/sage/blob/develop/src/sage/rings/polynomial/weil/power_sums.c#L77-L87

because  `force_squarefree = True` we don't run `return (1)`, but then in the last line we try to divide by the content of that vector which is 0.


---

Comment by kedlaya created at 2021-05-12 01:30:59

I think this is a problem with sanitizing input: the line

```
    if (fmpz_sgn(f0+n-1) != sgn0_l) return(0);
```

is supposed to rule out the zero polynomial, but that fails if the initial polynomial is somehow specified with leading zeroes. 

I'm not sure how that never came up before, but it's easy enough to fix by adjusting `n` at the outset. Patch to follow shortly.


---

Comment by kedlaya created at 2021-05-12 01:39:22

New commits:


---

Comment by kedlaya created at 2021-05-12 01:39:22

Changing status from new to needs_review.


---

Comment by roed created at 2021-05-12 02:19:39

Looks good to me once tests pass.


---

Comment by edgarcosta created at 2021-05-12 12:37:43

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-06-19 20:57:33

Resolution: fixed
