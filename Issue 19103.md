# Issue 19103: Better interface for hadamard_matrix

archive/issues_019103.json:
```json
{
    "body": "CC:  knsam dimpase vdelecroix\n\nThis branch improves the interface of hadamard_matrix.\n\n- It adds it in `matrix.<tab>`\n- It checks the returned results ('check' flag)\n- It can test for the existence of a construction in Sage (useful for SRG code)\n\nNathann\n\nIssue created by migration from https://trac.sagemath.org/ticket/19340\n\n",
    "created_at": "2015-10-03T16:06:16Z",
    "labels": [
        "combinatorial designs",
        "major",
        "enhancement"
    ],
    "title": "Better interface for hadamard_matrix",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19103",
    "user": "ncohen"
}
```
CC:  knsam dimpase vdelecroix

This branch improves the interface of hadamard_matrix.

- It adds it in `matrix.<tab>`
- It checks the returned results ('check' flag)
- It can test for the existence of a construction in Sage (useful for SRG code)

Nathann

Issue created by migration from https://trac.sagemath.org/ticket/19340





---

archive/issue_comments_262156.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-10-03T16:09:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262156",
    "user": "ncohen"
}
```

New commits:



---

archive/issue_comments_262157.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-10-03T16:09:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262157",
    "user": "ncohen"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_262158.json:
```json
{
    "body": "IMHO `hadamard_matrix()` should accept options, such as `RSHCD` and `skew` (the latter not implemented yet). (A skew-Hadamard matrix is a Hadamard matrix of the form `H=S+I`, with `S.T==-S` and `I` the identity matrix; I have some half-written patch for them...)\n\nAs well, `is_hadamard_matrix()` ought to check for `RSHCD`-ness and `skew`-ness.",
    "created_at": "2015-10-03T16:20:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262158",
    "user": "dimpase"
}
```

IMHO `hadamard_matrix()` should accept options, such as `RSHCD` and `skew` (the latter not implemented yet). (A skew-Hadamard matrix is a Hadamard matrix of the form `H=S+I`, with `S.T==-S` and `I` the identity matrix; I have some half-written patch for them...)

As well, `is_hadamard_matrix()` ought to check for `RSHCD`-ness and `skew`-ness.



---

archive/issue_comments_262159.json:
```json
{
    "body": "> IMHO `hadamard_matrix()` should accept options, such as `RSHCD` and `skew` (the latter not implemented yet).\n\nHMmmmm.. I don't know for 'skew', but 'rshcd' sounds very very specific to have in such a general function. Having a function of its own in a submodule sounds sufficient to me, for the moment.\n\n> As well, `is_hadamard_matrix()` ought to check for `RSHCD`-ness and `skew`-ness.\n\nI don't know... The rshcd function already tests the rshcd-specific property anyway.\n\nNathann",
    "created_at": "2015-10-03T16:24:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262159",
    "user": "ncohen"
}
```

> IMHO `hadamard_matrix()` should accept options, such as `RSHCD` and `skew` (the latter not implemented yet).

HMmmmm.. I don't know for 'skew', but 'rshcd' sounds very very specific to have in such a general function. Having a function of its own in a submodule sounds sufficient to me, for the moment.

> As well, `is_hadamard_matrix()` ought to check for `RSHCD`-ness and `skew`-ness.

I don't know... The rshcd function already tests the rshcd-specific property anyway.

Nathann



---

archive/issue_comments_262160.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-03T16:28:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262160",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_262161.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-10-03T16:48:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262161",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_262162.json:
```json
{
    "body": "You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.\n\nChecking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds), and unit testing should provide reasonable certainty that the algorithm is correct. Flint's test suite already checks for every size up to 300 that fmpz_mat_hadamard either constructs a correct Hadamard matrix or reports that the size is unsupported.",
    "created_at": "2015-10-03T18:34:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262162",
    "user": "fredrik.johansson"
}
```

You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.

Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds), and unit testing should provide reasonable certainty that the algorithm is correct. Flint's test suite already checks for every size up to 300 that fmpz_mat_hadamard either constructs a correct Hadamard matrix or reports that the size is unsupported.



---

archive/issue_comments_262163.json:
```json
{
    "body": "> You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.\n\nHow easily can I call them on a Sage matrix?\n\n> Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds), and unit testing should provide reasonable certainty that the algorithm is correct.\n\nSorry to disappoint, but I have thousands of line behind me (in combinat/designs/) that implement old combinatorial designs from lost papers. I know the value of this kind of testing.\n\n> Flint's test suite already checks for every size up to 300 that fmpz_mat_hadamard either constructs a correct Hadamard matrix or reports that the size is unsupported.\n\nAre you saying that flint can be easily accessed from Sage *and* that it contains a database of hadamard matrices? If so, I woulld be glad to call it from the general constructor of hadamard matrices in Sage.\n\nNathann",
    "created_at": "2015-10-03T18:43:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262163",
    "user": "ncohen"
}
```

> You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.

How easily can I call them on a Sage matrix?

> Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds), and unit testing should provide reasonable certainty that the algorithm is correct.

Sorry to disappoint, but I have thousands of line behind me (in combinat/designs/) that implement old combinatorial designs from lost papers. I know the value of this kind of testing.

> Flint's test suite already checks for every size up to 300 that fmpz_mat_hadamard either constructs a correct Hadamard matrix or reports that the size is unsupported.

Are you saying that flint can be easily accessed from Sage *and* that it contains a database of hadamard matrices? If so, I woulld be glad to call it from the general constructor of hadamard matrices in Sage.

Nathann



---

archive/issue_comments_262164.json:
```json
{
    "body": "Replying to [comment:7 ncohen]:\n> > You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.\n> \n> How easily can I call them on a Sage matrix?\n\nIt should be enough (untested) to add the following declarations in libs/flint/fmpz_mat.pxd\n\n\n```\n    int fmpz_mat_hadamard(fmpz_mat_t A)\n    int fmpz_mat_is_hadamard(const fmpz_mat_t A)\n```\n\n\nand the following methods in matrix/matrix_integer_dense.pyx\n\n\n```\n    def _hadamard(self):\n        # in-place, returns whether successful\n        return fmpz_mat_hadamard(self._matrix)\n\n    def is_hadamard(self):\n        return fmpz_mat_is_hadamard(self._matrix)\n```\n\n\nThen you can do something like this in hadamard_matrix()\n\n\n```\n    if not(n % 4 == 0) and (n > 2):\n        raise ValueError\n    mat = Matrix(ZZ, n, n)\n    if mat._hadamard():\n        return mat\n    else:\n        # use database here\n        raise ValueError\n```\n\n\n> > Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds), and unit testing should provide reasonable certainty that the algorithm is correct.\n> \n> Sorry to disappoint, but I have thousands of line behind me (in combinat/designs/) that implement old combinatorial designs from lost papers. I know the value of this kind of testing.\n\nYou may well be right about combinatorial designs in general. But, having written the flint code, and considering that it implements a fairly simple algorithm, when it's already exhaustively tested up to size 300, I think it's highly unlikely to give an incorrect matrix for larger sizes. So I can't agree with slowing it down many orders of magnitude by default.\n\n> > Flint's test suite already checks for every size up to 300 that fmpz_mat_hadamard either constructs a correct Hadamard matrix or reports that the size is unsupported.\n> \n> Are you saying that flint can be easily accessed from Sage *and* that it contains a database of hadamard matrices? If so, I woulld be glad to call it from the general constructor of hadamard matrices in Sage.\n\nIt doesn't have a database; it uses the Paley construction. As noted above, you can easily use a fallback database/algorithm if it fails.\n\nBTW, fmpz_mat_hadamard succeeds for every multiple of 4 below 92; current code for the Paley construction in Sage doesn't succeed to construct a size 20 Hadamard matrix.",
    "created_at": "2015-10-03T19:20:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262164",
    "user": "fredrik.johansson"
}
```

Replying to [comment:7 ncohen]:
> > You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.
> 
> How easily can I call them on a Sage matrix?

It should be enough (untested) to add the following declarations in libs/flint/fmpz_mat.pxd


```
    int fmpz_mat_hadamard(fmpz_mat_t A)
    int fmpz_mat_is_hadamard(const fmpz_mat_t A)
```


and the following methods in matrix/matrix_integer_dense.pyx


```
    def _hadamard(self):
        # in-place, returns whether successful
        return fmpz_mat_hadamard(self._matrix)

    def is_hadamard(self):
        return fmpz_mat_is_hadamard(self._matrix)
```


Then you can do something like this in hadamard_matrix()


```
    if not(n % 4 == 0) and (n > 2):
        raise ValueError
    mat = Matrix(ZZ, n, n)
    if mat._hadamard():
        return mat
    else:
        # use database here
        raise ValueError
```


> > Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds), and unit testing should provide reasonable certainty that the algorithm is correct.
> 
> Sorry to disappoint, but I have thousands of line behind me (in combinat/designs/) that implement old combinatorial designs from lost papers. I know the value of this kind of testing.

You may well be right about combinatorial designs in general. But, having written the flint code, and considering that it implements a fairly simple algorithm, when it's already exhaustively tested up to size 300, I think it's highly unlikely to give an incorrect matrix for larger sizes. So I can't agree with slowing it down many orders of magnitude by default.

> > Flint's test suite already checks for every size up to 300 that fmpz_mat_hadamard either constructs a correct Hadamard matrix or reports that the size is unsupported.
> 
> Are you saying that flint can be easily accessed from Sage *and* that it contains a database of hadamard matrices? If so, I woulld be glad to call it from the general constructor of hadamard matrices in Sage.

It doesn't have a database; it uses the Paley construction. As noted above, you can easily use a fallback database/algorithm if it fails.

BTW, fmpz_mat_hadamard succeeds for every multiple of 4 below 92; current code for the Paley construction in Sage doesn't succeed to construct a size 20 Hadamard matrix.



---

archive/issue_comments_262165.json:
```json
{
    "body": "> It should be enough (untested) to add the following declarations in libs/flint/fmpz_mat.pxd\n\nHMmmm.. I don't feel much at ease with adding matrix code, sorry. Especially if it is only implemented for a specific data structure and such.\n\n> You may well be right about combinatorial designs in general. But, having written the flint code, and considering that it implements a fairly simple algorithm, when it's already exhaustively tested up to size 300, I think it's highly unlikely to give an incorrect matrix for larger sizes. So I can't agree with slowing it down many orders of magnitude by default.\n\nUnless you do intend to use this code, couldn't you trust the opinion of those who do and develop it?\n\nI know how many hours, night and weeks I wasted because of a typo in data or in code. You wouldn't mind slowing by \"several orders of magnitude\" a function like `.__repr__` because it is never a critical. Do you generate Hadamard matrices intensively? Furthermore you can disable the check with 'check=False'. Please don't turn this ticket into a war just because of a check you can disable, which saved my skin innumerable times in similar code. It's not worth it. I know it, and I need the flag. Besides, checking the constructions is already the default for all other design constructions.\n\n> It doesn't have a database; it uses the Paley construction. As noted above, you can easily use a fallback database/algorithm if it fails.\n\nMore constructions of hadamard matrices may come. Others may be pure data. Other may be recursive constructions on both.\n\n> BTW, fmpz_mat_hadamard succeeds for every multiple of 4 below 92; current code for the Paley construction in Sage doesn't succeed to construct a size 20 Hadamard matrix.\n\nThen there must be another bug somewhere. This code clearly needs some testing.\n\nNathann",
    "created_at": "2015-10-03T19:45:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262165",
    "user": "ncohen"
}
```

> It should be enough (untested) to add the following declarations in libs/flint/fmpz_mat.pxd

HMmmm.. I don't feel much at ease with adding matrix code, sorry. Especially if it is only implemented for a specific data structure and such.

> You may well be right about combinatorial designs in general. But, having written the flint code, and considering that it implements a fairly simple algorithm, when it's already exhaustively tested up to size 300, I think it's highly unlikely to give an incorrect matrix for larger sizes. So I can't agree with slowing it down many orders of magnitude by default.

Unless you do intend to use this code, couldn't you trust the opinion of those who do and develop it?

I know how many hours, night and weeks I wasted because of a typo in data or in code. You wouldn't mind slowing by "several orders of magnitude" a function like `.__repr__` because it is never a critical. Do you generate Hadamard matrices intensively? Furthermore you can disable the check with 'check=False'. Please don't turn this ticket into a war just because of a check you can disable, which saved my skin innumerable times in similar code. It's not worth it. I know it, and I need the flag. Besides, checking the constructions is already the default for all other design constructions.

> It doesn't have a database; it uses the Paley construction. As noted above, you can easily use a fallback database/algorithm if it fails.

More constructions of hadamard matrices may come. Others may be pure data. Other may be recursive constructions on both.

> BTW, fmpz_mat_hadamard succeeds for every multiple of 4 below 92; current code for the Paley construction in Sage doesn't succeed to construct a size 20 Hadamard matrix.

Then there must be another bug somewhere. This code clearly needs some testing.

Nathann



---

archive/issue_comments_262166.json:
```json
{
    "body": "> > BTW, fmpz_mat_hadamard succeeds for every multiple of 4 below 92; current code for the Paley construction in Sage doesn't succeed to construct a size 20 Hadamard matrix.\n\nTwo updates:\n\n1) With this branch, Sage can build a matrix for n=20. It's one of the bugs I fixed\n2) There is no Paley construction for 52 on [1]. Either you get the data somewhere else or there is something wrong in that code.\n\nNathann\n\n[1] http://neilsloane.com/hadamard/",
    "created_at": "2015-10-03T20:02:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262166",
    "user": "ncohen"
}
```

> > BTW, fmpz_mat_hadamard succeeds for every multiple of 4 below 92; current code for the Paley construction in Sage doesn't succeed to construct a size 20 Hadamard matrix.

Two updates:

1) With this branch, Sage can build a matrix for n=20. It's one of the bugs I fixed
2) There is no Paley construction for 52 on [1]. Either you get the data somewhere else or there is something wrong in that code.

Nathann

[1] http://neilsloane.com/hadamard/



---

archive/issue_comments_262167.json:
```json
{
    "body": "`52 = 2 * (5^2 + 1)` is covered by the \"type 2\" Paley construction.\n\nThe list you linked to is evidently incomplete.",
    "created_at": "2015-10-03T20:14:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262167",
    "user": "fredrik.johansson"
}
```

`52 = 2 * (5^2 + 1)` is covered by the "type 2" Paley construction.

The list you linked to is evidently incomplete.



---

archive/issue_comments_262168.json:
```json
{
    "body": "Then that's another bug of the current code:\n\n\n```\nsage: hadamard_matrix_paleyII(52)\n...\nValueError: The order 52 is not covered by the Paley type II construction.\n```\n",
    "created_at": "2015-10-03T20:16:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262168",
    "user": "ncohen"
}
```

Then that's another bug of the current code:


```
sage: hadamard_matrix_paleyII(52)
...
ValueError: The order 52 is not covered by the Paley type II construction.
```




---

archive/issue_comments_262169.json:
```json
{
    "body": "Well, it's up to you whether you want to fix the broken code or just insert a few lines to call the code in flint that is faster and known to work :-)",
    "created_at": "2015-10-03T20:18:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262169",
    "user": "fredrik.johansson"
}
```

Well, it's up to you whether you want to fix the broken code or just insert a few lines to call the code in flint that is faster and known to work :-)



---

archive/issue_comments_262170.json:
```json
{
    "body": "> Well, it's up to you whether you want to fix the broken code or just insert a few lines to call the code in flint that is faster and known to work :-)\n\nThank you very much. Then I will do something else. I am trying to improve the database of strongly regular graphs and I don't want to interrupt that to write interface code.\n\nNathann",
    "created_at": "2015-10-03T20:19:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262170",
    "user": "ncohen"
}
```

> Well, it's up to you whether you want to fix the broken code or just insert a few lines to call the code in flint that is faster and known to work :-)

Thank you very much. Then I will do something else. I am trying to improve the database of strongly regular graphs and I don't want to interrupt that to write interface code.

Nathann



---

archive/issue_comments_262171.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-10-03T22:05:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262171",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_262172.json:
```json
{
    "body": "Hello,\n\nThanks Frederik for your suggestion (and your work in flint!). I pushed a branch at `u/vdelecroix/19340` with one commit which creates a function `hadamard_matrix_flint`. It could be called from the current `hadamard_matrix` code. It is faster. It is useful to have several implementations to check (as it was pointed out on a concrete example by Frederik)...\n\nVincent",
    "created_at": "2015-10-04T01:10:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262172",
    "user": "vdelecroix"
}
```

Hello,

Thanks Frederik for your suggestion (and your work in flint!). I pushed a branch at `u/vdelecroix/19340` with one commit which creates a function `hadamard_matrix_flint`. It could be called from the current `hadamard_matrix` code. It is faster. It is useful to have several implementations to check (as it was pointed out on a concrete example by Frederik)...

Vincent



---

archive/issue_comments_262173.json:
```json
{
    "body": "Yo,\n\n> It is useful to have several implementations to check (as it was pointed out on a concrete example by Frederik)...\n\nIndeed. Please do that in #19341, though.\n\nNathann",
    "created_at": "2015-10-04T05:41:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262173",
    "user": "ncohen"
}
```

Yo,

> It is useful to have several implementations to check (as it was pointed out on a concrete example by Frederik)...

Indeed. Please do that in #19341, though.

Nathann



---

archive/issue_comments_262174.json:
```json
{
    "body": "Replying to [comment:6 fredrik.johansson]:\n> You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.\n> \n> Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds),\n\nIMHO it says that your fmpz_mat_is_hadamard is far from optimal.\nIndeed, you neither need to take the transpose nor to do full matrix multiplication.\n\nAs you fisrt check that the matrix is +/-1, you don't need to check that the diagonal entries of HH.T are all n.\nSo you only need to do scalar products of n(n-1)/2 rows...\n\n(I understand that Hadamard matrices in FLINT don't do any serious job, they are there for testing or so; if one was after real speed there, you'd be using BLAS...)",
    "created_at": "2015-10-04T17:08:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262174",
    "user": "dimpase"
}
```

Replying to [comment:6 fredrik.johansson]:
> You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.
> 
> Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds),

IMHO it says that your fmpz_mat_is_hadamard is far from optimal.
Indeed, you neither need to take the transpose nor to do full matrix multiplication.

As you fisrt check that the matrix is +/-1, you don't need to check that the diagonal entries of HH.T are all n.
So you only need to do scalar products of n(n-1)/2 rows...

(I understand that Hadamard matrices in FLINT don't do any serious job, they are there for testing or so; if one was after real speed there, you'd be using BLAS...)



---

archive/issue_comments_262175.json:
```json
{
    "body": "Replying to [comment:18 dimpase]:\n> Replying to [comment:6 fredrik.johansson]:\n> > You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.\n> > \n> > Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds),\n> \n> IMHO it says that your fmpz_mat_is_hadamard is far from optimal.\n> Indeed, you neither need to take the transpose nor to do full matrix multiplication.\n> \n> As you fisrt check that the matrix is +/-1, you don't need to check that the diagonal entries of HH.T are all n.\n> So you only need to do scalar products of n(n-1)/2 rows...\n\nI didn't follow this. Are you saying that you can do the test in `O(n^2)` instead of `O(n^omega)`?\n\n> (I understand that Hadamard matrices in FLINT don't do any serious job, they are there for testing or so; if one was after real speed there, you'd be using BLAS...)",
    "created_at": "2015-10-04T17:22:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262175",
    "user": "fredrik.johansson"
}
```

Replying to [comment:18 dimpase]:
> Replying to [comment:6 fredrik.johansson]:
> > You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.
> > 
> > Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds),
> 
> IMHO it says that your fmpz_mat_is_hadamard is far from optimal.
> Indeed, you neither need to take the transpose nor to do full matrix multiplication.
> 
> As you fisrt check that the matrix is +/-1, you don't need to check that the diagonal entries of HH.T are all n.
> So you only need to do scalar products of n(n-1)/2 rows...

I didn't follow this. Are you saying that you can do the test in `O(n^2)` instead of `O(n^omega)`?

> (I understand that Hadamard matrices in FLINT don't do any serious job, they are there for testing or so; if one was after real speed there, you'd be using BLAS...)



---

archive/issue_comments_262176.json:
```json
{
    "body": "Replying to [comment:19 fredrik.johansson]:\n> Replying to [comment:18 dimpase]:\n> > Replying to [comment:6 fredrik.johansson]:\n> > > You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.\n> > > \n> > > Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds),\n> > \n> > IMHO it says that your fmpz_mat_is_hadamard is far from optimal.\n> > Indeed, you neither need to take the transpose nor to do full matrix multiplication.\n> > \n> > As you fisrt check that the matrix is +/-1, you don't need to check that the diagonal entries of HH.T are all n.\n> > So you only need to do scalar products of n(n-1)/2 rows...\n> \n> I didn't follow this. Are you saying that you can do the test in `O(n^2)` instead of `O(n^omega)`?\n\nNo, I am not saying that you can do the scalar product of two matrix rows in constant time. :-)\n\nBut at least you can replace\n\n```\n   for (i = 0; i < n && result; i++)\n        for (j = 0; j < n && result; j++)\n            result = (*fmpz_mat_entry(C, i, j) == n * (i == j));\n\n```\n\nwith\n\n```\n   for (i = 0; i < n && result; i++)\n        for (j = i+1; j < n && result; j++)\n            result = (*fmpz_mat_entry(C, i, j) == 0);\n```\n\n\nanother possible optimisation would be to have a dedicated function for matrix multiplication with the symmetric result (for `HH^T` is symmetric; other possible use would be to compute product of commuting symmetric matrices).",
    "created_at": "2015-10-04T17:39:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262176",
    "user": "dimpase"
}
```

Replying to [comment:19 fredrik.johansson]:
> Replying to [comment:18 dimpase]:
> > Replying to [comment:6 fredrik.johansson]:
> > > You might consider using the flint functions fmpz_mat_hadamard and fmpz_mat_is_hadamard, which should be faster.
> > > 
> > > Checking by default seems kind of useless since this is much slower than generating the matrix (generating a size 1000 Hadamard matrix takes 0.01 seconds and checking it takes 0.5 seconds),
> > 
> > IMHO it says that your fmpz_mat_is_hadamard is far from optimal.
> > Indeed, you neither need to take the transpose nor to do full matrix multiplication.
> > 
> > As you fisrt check that the matrix is +/-1, you don't need to check that the diagonal entries of HH.T are all n.
> > So you only need to do scalar products of n(n-1)/2 rows...
> 
> I didn't follow this. Are you saying that you can do the test in `O(n^2)` instead of `O(n^omega)`?

No, I am not saying that you can do the scalar product of two matrix rows in constant time. :-)

But at least you can replace

```
   for (i = 0; i < n && result; i++)
        for (j = 0; j < n && result; j++)
            result = (*fmpz_mat_entry(C, i, j) == n * (i == j));

```

with

```
   for (i = 0; i < n && result; i++)
        for (j = i+1; j < n && result; j++)
            result = (*fmpz_mat_entry(C, i, j) == 0);
```


another possible optimisation would be to have a dedicated function for matrix multiplication with the symmetric result (for `HH^T` is symmetric; other possible use would be to compute product of commuting symmetric matrices).



---

archive/issue_comments_262177.json:
```json
{
    "body": "That part of the tests amounts to approximately 0.000% of the total running time.\n\nIn any case, a constant factor anywhere in the code doesn't fundamentally change the imbalance between testing and generating, as you suggested above.\n\nThe reason testing is far slower is not a factor 2 inefficiency (or even a factor 6 or whatever from not using BLAS) in the matrix multiplication, but the fact that constructing a Hadamard matrix is only  `O(n^2)` while testing is `O(n^omega)`.",
    "created_at": "2015-10-04T17:58:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262177",
    "user": "fredrik.johansson"
}
```

That part of the tests amounts to approximately 0.000% of the total running time.

In any case, a constant factor anywhere in the code doesn't fundamentally change the imbalance between testing and generating, as you suggested above.

The reason testing is far slower is not a factor 2 inefficiency (or even a factor 6 or whatever from not using BLAS) in the matrix multiplication, but the fact that constructing a Hadamard matrix is only  `O(n^2)` while testing is `O(n^omega)`.



---

archive/issue_comments_262178.json:
```json
{
    "body": "Replying to [comment:21 fredrik.johansson]:\n> That part of the tests amounts to approximately 0.000% of the total running time.\n> \n> In any case, a constant factor anywhere in the code doesn't fundamentally change the imbalance between testing and generating, as you suggested above. \n\nas you imagine, I didn't profile this change. Still, it removes `O(n^2)` multiplications and comparisons. If you prefer to keep them in your code, it is up to you.\n\n> \n> The reason testing is far slower is not a factor 2 inefficiency (or even a factor 6 or whatever from not using BLAS) in the matrix multiplication, but the fact that constructing a Hadamard matrix is only  `O(n^2)` while testing is `O(n^omega)`.\n\nOn a good BLAS, the speed-up is a function of the number of cores available... Then, as we know, the devil is in the constants; if matrices were optimised for the task at hand, you would only have started to notice on 10000x10000 matrices, not on 1000x1000.\n\nAnyhow, this is an academic discussion.",
    "created_at": "2015-10-05T15:20:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262178",
    "user": "dimpase"
}
```

Replying to [comment:21 fredrik.johansson]:
> That part of the tests amounts to approximately 0.000% of the total running time.
> 
> In any case, a constant factor anywhere in the code doesn't fundamentally change the imbalance between testing and generating, as you suggested above. 

as you imagine, I didn't profile this change. Still, it removes `O(n^2)` multiplications and comparisons. If you prefer to keep them in your code, it is up to you.

> 
> The reason testing is far slower is not a factor 2 inefficiency (or even a factor 6 or whatever from not using BLAS) in the matrix multiplication, but the fact that constructing a Hadamard matrix is only  `O(n^2)` while testing is `O(n^omega)`.

On a good BLAS, the speed-up is a function of the number of cores available... Then, as we know, the devil is in the constants; if matrices were optimised for the task at hand, you would only have started to notice on 10000x10000 matrices, not on 1000x1000.

Anyhow, this is an academic discussion.



---

archive/issue_comments_262179.json:
```json
{
    "body": "`Hadamard matrix, i.e. has its first row/column filles with +1.`\n\nshould be `filled`",
    "created_at": "2015-10-05T18:15:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262179",
    "user": "dimpase"
}
```

`Hadamard matrix, i.e. has its first row/column filles with +1.`

should be `filled`



---

archive/issue_comments_262180.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-05T18:18:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262180",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_262181.json:
```json
{
    "body": "my problem with this patch that it uses `is_prime` instead of `is_prime_power` to build Paley matrices. While the present implementation of Paley matrices needs primes, it's entirely unnecessary. Should I add a patch that fixes this here?\n(or else, surely it's not a big deal to process errors from Paley constructions here rather than limit their inputs...)",
    "created_at": "2015-10-14T17:33:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262181",
    "user": "dimpase"
}
```

my problem with this patch that it uses `is_prime` instead of `is_prime_power` to build Paley matrices. While the present implementation of Paley matrices needs primes, it's entirely unnecessary. Should I add a patch that fixes this here?
(or else, surely it's not a big deal to process errors from Paley constructions here rather than limit their inputs...)



---

archive/issue_comments_262182.json:
```json
{
    "body": "see #19341.",
    "created_at": "2015-10-14T17:35:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262182",
    "user": "ncohen"
}
```

see #19341.



---

archive/issue_comments_262183.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-10-14T17:43:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262183",
    "user": "dimpase"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_262184.json:
```json
{
    "body": "Replying to [comment:26 ncohen]:\n> see #19341.\nOK!",
    "created_at": "2015-10-14T17:43:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262184",
    "user": "dimpase"
}
```

Replying to [comment:26 ncohen]:
> see #19341.
OK!



---

archive/issue_comments_262185.json:
```json
{
    "body": "Thanks,\n\nNathann\n\nP.S.: What about the... You know... Reviewer field?",
    "created_at": "2015-10-14T17:49:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262185",
    "user": "ncohen"
}
```

Thanks,

Nathann

P.S.: What about the... You know... Reviewer field?



---

archive/issue_comments_262186.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-10-16T08:22:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19103#issuecomment-262186",
    "user": "vbraun"
}
```

Resolution: fixed
