# Issue 15063: Weyl and Clifford Algebras

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2013-10-16 23:16:37

Assignee: tscrim

CC:  darij sage-combinat

Initial implementations of Weyl and Clifford algebras.


---

Comment by tscrim created at 2013-10-16 23:18:29

Changing status from new to needs_review.


---

Attachment


---

Comment by aschilling created at 2013-11-05 23:12:51

New commits:


---

Attachment

The patch I've posted contains a couple corrections and comments. Sorry for being this slow; the cold isn't very beneficial for my concentration.

EDIT: The commit list below has nothing to do with my post; it seems that trac automatically appends it to whatever post is made first after the commits. Anyway, for everyone who is not at Davis: The git commits on this ticket are a sandbox for people merging git; the true work is being done in the hg patches. I'm very positive this one is going to be reviewed way before we move over to git.
----
New commits:


---

Comment by tscrim created at 2013-11-08 20:27:15

New commits:


---

Comment by git created at 2013-11-08 20:32:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2013-11-08 22:52:46

Changing keywords from "" to "days54".


---

Comment by git created at 2013-11-30 05:39:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2013-11-30 07:56:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2013-12-03 01:47:43

Is there an established class for bilinear forms (not necessarily symmetric!) on free modules? I'd need one to get anywhere towards the Clifford-exterior iso.

The `scalar` function as it stands is rather useless, since on the exterior algebra it just returns the product of the constant coefficients of `self` and `other`. What should be made (I can do that) is the lift of a bilinear (not quadratic) form on `V` to the exterior algebra of `V` (using the Gram matrix). But that requires bilinear forms, too, so I'd love to hear whether they exist before doing any changes.


---

Comment by git created at 2013-12-03 03:52:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2013-12-03 04:56:48

Replying to [comment:16 darij]:
> Is there an established class for bilinear forms (not necessarily symmetric!) on free modules? I'd need one to get anywhere towards the Clifford-exterior iso.

I don't think so. I think this is usually worked (hacked) around using dedicated methods.

> The `scalar` function as it stands is rather useless, since on the exterior algebra it just returns the product of the constant coefficients of `self` and `other`. What should be made (I can do that) is the lift of a bilinear (not quadratic) form on `V` to the exterior algebra of `V` (using the Gram matrix). But that requires bilinear forms, too, so I'd love to hear whether they exist before doing any changes.

I'd just have a function `Element.scalar(other)` (or some other name) which projects down `self` and `other` to the exterior algebra and does the computation there via some (predefined) `scalar()` method.


---

Comment by darij created at 2013-12-06 04:14:27

Do you think it makes sense to add a `BilinearForm` class in analogy to `QuadraticForm`, or should I just use matrices to represent bilinear forms?


---

Comment by nthiery created at 2013-12-10 09:24:05

It depends what feature about bilinear forms you need for now. If it's just about computing it on some elements, I would stick for now with implementing appropriate "scalar" methods. Granted, it's a bit rudimentary. In the long run we want to have proper multivariate morphisms, with support from the coercion model. See #8900 and http://trac.sagemath.org/wiki/CategoriesRoadMap.

Cheers,
                                       Nicolas


---

Comment by darij created at 2013-12-10 16:41:57

What I want is to change the `WeylAlgebra` class to depend upon a space with a bilinear form, not on a polynomial ring. So the bilinear form will be a parameter. Still OK if it is a matrix or should I rather have an extra class?


---

Comment by tscrim created at 2013-12-10 16:51:41

Replying to [comment:21 darij]:
> What I want is to change the `WeylAlgebra` class to depend upon a space with a bilinear form, not on a polynomial ring. So the bilinear form will be a parameter. Still OK if it is a matrix or should I rather have an extra class?

I think a matrix would be best for now (although I would like to keep the polynomial ring version).

Thanks,

Travis


---

Comment by darij created at 2013-12-10 17:02:01

Will be a matrix then.

Yeah, I'm not going to deprecate your Weyl algebra; I *might* end up renaming it, though. Thing is, the Weyl algebra of an antisymmetric bilinear form is the most correct analogue of the Clifford algebra known to me (there might be better ones, though) -- far closer than the Weyl algebra of a polynomial ring (which is just the Weyl algebra of the usual antisymmetric form which is

```
0 1
-1 0
```

as a block matrix.


---

Comment by tscrim created at 2013-12-10 20:19:26

I'm okay with renaming the class, but I'd like to keep the global entry point the same. In other words, I'd like to create it via `WeylAlgebra(QQ, 4)`, where the absence of the bilinear form says to use the polynomial representation, or perhaps with a keyword such as `polynomial=True`. Thanks.


---

Comment by git created at 2014-02-04 01:42:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-03-26 00:11:21

There is a stupid `__repr__` bug I've no idea how to fix.

```
sage: A = CliffordAlgebra(QuadraticForm(QQ, 3, [1,0,-1,3,-4,5]))
sage: A.basis()
Finite family {(0, 1): e0*e1, (1, 2): ee2, (0,): e0, (1,): e1, (0, 1, 2): e0*ee2, (2,): e2, (): 1, (0, 2): e0*e2}
```

See the `ee2`? It's an `e1*e2`, which the `__repr__` routine seems to simplify to `ee2` because `1*` can be omitted, right? One way to deal with it would be to not use the multiplication signs; what do you think about that?

(Also, the doctests of `lift_isometry` are wrong -- could you compute them by hand and re-insert them? Thank you.)

EDIT: Oh, I see, the bug is in `repr_from_monomials` of `weyl_algebra.py`, not in some big free-module module.


---

Comment by git created at 2014-03-30 19:53:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-03-30 22:25:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-03-31 02:03:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-03-31 02:32:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-03-31 02:37:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-03-31 03:27:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-03-31 03:56:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-03-31 04:35:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-03-31 04:35:52

OK, enough for today. I've left you a question in the latest commit.

Also, what exactly does this do?

```
        E = super(ExteriorAlgebra, cls).__classcall__(cls, R, names)
```

I thought it would classcall ``cls`` as a ``CliffordAlgebra``, but then shouldn't it give it a quadratic form?
----
New commits:


---

Comment by git created at 2014-03-31 16:15:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-03-31 16:17:25

I've added a cohomology part as well, but there's still some tweaks left to do.

That passes to the `__classcall__` (not `__classcall_private__`) of the class `CliffordAlgebra`, which just ends up constructing the object.


---

Comment by darij created at 2014-03-31 16:28:51

Yes, but wouldn't that method require passing it a quadratic form? Or am I confusing it with `__init__`?


---

Comment by darij created at 2014-03-31 16:40:55

Loads of doctests fail currently. Is this a WIP or have you changed some class names without changing references to them?

Also, I feel like more info is needed on what `s_coeff` represents and how it should be given.


---

Comment by tscrim created at 2014-03-31 21:32:49

You're confusing it with `__init__()`.

It's currently a WIP. I had to push from my home computer and was in a slight rush to get out the door. I'll add some more info on `s_coeff` too.


---

Comment by tscrim created at 2014-03-31 22:57:43

Found a bug with the hashing of `Family`: I could get equal families with unequal hashes. This stems from the fact that `keys()` from (python) dicts aren't necessarily sorted. I'm almost done, but not quite yet.


---

Comment by git created at 2014-03-31 22:57:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-03-31 22:58:49

Ack, #16026 somehow as gotten in there. I'll fix it later.


---

Comment by darij created at 2014-03-31 23:04:11

Oh, so `__classcall__` just serves to typecast the object into the right class?

I'll continue looking at the code tomorrow, as today I barely have any time left. I'm done looking at the Clifford algebra classes, and I'll look at the Exterior algebra classes once you're done implementing homology; so the next step is likely to be the general Weyl algebra. If I'll have any troubles with the OOP (I imagine there might be issues with making differential Weyl algebras inherit from Weyl algebras), I'll let you know.


---

Comment by tscrim created at 2014-04-01 00:44:51

Well, to parse the input into a standard form and then create the object using those standardized inputs (or sometimes to emulate a factory).

It's done. The only thing left is some documentation and to make the exterior algebra more functor-like, and I should get that done tonight.


---

Comment by git created at 2014-04-01 17:50:04

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2014-04-01 17:50:49

Okay, fixed. I'm also done making changes.


---

Comment by darij created at 2014-04-02 03:04:15

Any idea what to do about this?

```
sage: Q = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
sage: Qp = QuadraticForm(Integers(3), 3, [1,2,3,4,5,6])
sage: Cl = CliffordAlgebra(Q)
sage: Clp = CliffordAlgebra(Qp)
sage: a = Cl.basis()[(1,2)]
sage: a
e1*e2
sage: Clp(a) # so far so good
e1*e2
sage: Clp(3*a) # but now
0*e1*e2
sage: Clp(3*a) == 0 # not good!
False
```

I wouldn't be surprised if other covariant functors had the same bug...


---

Comment by git created at 2014-04-02 03:05:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-04-02 03:16:35

It's coming from the fact that terms with coefficients of 0 aren't always being removed (like they should be). So it's something with the module morphisms, either that it's how we construct the module morphisms or in `_element_constructor_`.


---

Comment by jhpalmieri created at 2014-04-02 05:24:51

Random comments and questions:

Note that when you're using `CombinatorialFreeModule`, you shouldn't need both `_repr_term` and `_repr_` for elements: just use `_repr_term`. You should also delete the `_latex_` method for elements.

For the function `repr_from_monomials`, I wonder if `repr_lincomb` (defined in `sage.misc.latex`) does kind of the same thing?

By the way, can you compute the centers of any of these algebras? If so, having a method which returns it would be very nice.


---

Comment by tscrim created at 2014-04-02 06:31:40

Replying to [comment:52 jhpalmieri]:
> Note that when you're using `CombinatorialFreeModule`, you shouldn't need both `_repr_term` and `_repr_` for elements: just use `_repr_term`. You should also delete the `_latex_` method for elements.

If I didn't override `_repr_`, it wouldn't redirect to `repr_from_monomials` (it goes to `repr_lincomb`).

> For the function `repr_from_monomials`, I wonder if `repr_lincomb` (defined in `sage.misc.latex`) does kind of the same thing?

As I recall, `repr_lincomb` doesn't have as nice of printing (IMO) as `repr_from_monomials` with regard to spacing with the base ring being a polynomial ring.

> By the way, can you compute the centers of any of these algebras? If so, having a method which returns it would be very nice.

A counter question, do you want the honest center or the supercenter of the Clifford/exterior algebra?

For the honest center, it should be trivial (given there is an even and odd element) since given an odd `x` and even `y`, we have `xy = -yx + LOT`. The exterior algebra is supercommutative, so its supercenter is the entire algebra. For general Clifford algebras, my first thought is it would correspond to rows of 0 in the quadratic form, but IDK off the top of my head for certain.

Edit - IDK off the top of my head either for the Weyl algebra. Darij, do you know what the (super)centers are to any of these?


---

Comment by darij created at 2014-04-02 06:35:53

This is actually more complicated than you think (and I have made lots of mistakes when working with these centers). See http://math.stackexchange.com/questions/129183/center-of-clifford-algebra-depending-on-the-parity-of-dim-v . I'd say let's wait until we have finite-dimensional algebras in Sage (or do we already?), since the center is *not* usually spanned by a subset of the standard basis.


---

Comment by tscrim created at 2014-04-02 06:40:08

Arbitrary finite (dimensional) algebras given by multiplication tables were done in #12141.


---

Comment by darij created at 2014-04-02 06:52:29

Oh; what I meant was algebras without a pre-chosen basis. There is no good canonical choice for a basis of the center of the Clifford algebra, unless the vector space comes with an *orthogonal* basis.


---

Comment by tscrim created at 2014-04-02 06:58:43

I think a part of #15916 would be something to that effect.


---

Comment by jhpalmieri created at 2014-04-02 16:58:40

Replying to [comment:53 tscrim]:
> Replying to [comment:52 jhpalmieri]:

> > For the function `repr_from_monomials`, I wonder if `repr_lincomb` (defined in `sage.misc.latex`) does kind of the same thing?
> 
> As I recall, `repr_lincomb` doesn't have as nice of printing (IMO) as `repr_from_monomials` with regard to spacing with the base ring being a polynomial ring.

It seems like it would be better to fix `repr_lincomb` than to add new code which reproduces a lot of its functionality. How should a user decide which of these to use, if they're both available? But maybe I'm missing something.

> > By the way, can you compute the centers of any of these algebras? If so, having a method which returns it would be very nice.
> 
> A counter question, do you want the honest center or the supercenter of the Clifford/exterior algebra?

I meant the honest center. For exterior algebras, this is easy: it's the evenly graded part. For Clifford algebras, these are finite dimensional, so what happens if you try to solve the linear algebra problem (find all solutions to `[x,-]=0` for all generators `x`)? You could try to do the same with the supercenter.


---

Comment by tscrim created at 2014-04-02 19:56:21

Replying to [comment:58 jhpalmieri]:
> It seems like it would be better to fix `repr_lincomb` than to add new code which reproduces a lot of its functionality. How should a user decide which of these to use, if they're both available? But maybe I'm missing something.

I haven't checked to see how many doctests would need to be fixed, but I was worried it was a lot. I'll look into it.

> I meant the honest center. For exterior algebras, this is easy: it's the evenly graded part. For Clifford algebras, these are finite dimensional, so what happens if you try to solve the linear algebra problem (find all solutions to `[x,-]=0` for all generators `x`)? You could try to do the same with the supercenter.

Ack, you're right. I really shouldn't try to do math in my head late at night. I'll work the centers into this ticket as well.


---

Comment by git created at 2014-04-04 03:49:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-04 06:27:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-04 06:27:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-04-04 06:32:29

Sorry for my slowness. I just fixed a bug in which the on_basis part of the lift_morphism morphism was using the domain instead of the codomain as parent. Don't you find it weird that it worked before? I do. The on_basis function would throw an IndexError whenever called on a nonempty sequence, but for some reason the module morphism worked. Maybe cython methods thwart exceptions? I can't explain this in any other way. (The cython method here is `dict_linear_combination` in `sage/combinat/dict_addition.pyx`. It is called by the `linear_combination` method. Now that I have changed the `linear_combination` call to a `_from_dict` one, the wrong parent wouldn't work anymore.)


---

Comment by git created at 2014-04-05 18:28:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-04-05 18:29:19

Travis, which definition of the interior product are you using? I'm asking because there are probably several (at the very least, there is a right-left issue, and there is the question which is the multiplier and which is the multiplied).


---

Comment by darij created at 2014-04-05 19:50:31

Also, are you fine with my edits to the `CliffordAlgebra` and `CliffordAlgebraElement` classes? If so, I could clone them to make Weyl algebras (the general case).


---

Comment by tscrim created at 2014-04-06 01:30:03

I think you should do:

- `if self.base_ring() is R:` in `_element_constructor_` instead of the `==`.
- Move the unshuffle out into `combinat/combinat.py` since it is a general (low-level) operation.
- Is using the `remove_zeros` option the fastest, as opposed to doing the `!= R.zero()` check (which probably should be pulled out?)

Otherwise your changes look good. For the interior product, I'm using the definition I gave (the other one should be equivalent to the first one...) with `\alpha` as `x`.

PS - John, I'm still working on the centers.


---

Comment by darij created at 2014-04-06 02:02:12

Is this a reasonable speed test?

```
sage: R = PolynomialRing(QQ, 'x')
sage: Q = QuadraticForm(R, 3, [1,2,3,4,5,6])
sage: Cl.<x,y,z> = CliffordAlgebra(Q)
sage: d = {(0,1): R.gens()[0], (1,2): R.zero(), (0,2): R.one()}
sage: %timeit Cl._from_dict(d, remove_zeros=True)
100000 loops, best of 3: 5.32 µs per loop
sage: l = (((0,1), R.gens()[0]), ((1,2), R.zero()), ((0,2), R.one()))
sage: %timeit Cl._from_dict({m: k for (m, k) in l if k != 0})
10000 loops, best of 3: 23.8 µs per loop
sage: %timeit Cl.sum_of_terms(l, distinct=True)
100000 loops, best of 3: 7.36 µs per loop
```

(I've misnamed the variables but this shouldn't matter...)

Where should the unshuffle go?


---

Comment by darij created at 2014-04-06 02:41:22

Ooooh, now I see the definition of the internal product that you gave. I was looking at the wrong docstring.


---

Comment by tscrim created at 2014-04-06 03:40:06

Replying to [comment:67 tscrim]:
> ... into `combinat/combinat.py`

We should probably have `internal_product_on_basis` reference `Element.internal_product`.


---

Comment by git created at 2014-04-06 05:31:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-06 05:33:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-04-06 05:35:13

I have done some improvements on the interior product. But I still need to reiterate my question: How is the interior product defined? You define it only when one of the two factors (the "smaller" one) is a single vector; but the method is defined for any two wedges. You seem to be reading the factor left-to-right, but a point can be made for the opposite convention. If you can give a reference, that's fine -- just please let's not leave this undocumented.

Should I generally use identity to compare base rings? I thought equality was more robust, or can we assume parents to be UniqueRepresentation?...

Sorry for ongoing lameness; I got some kind of cold again and my QSym paper is not progressing :/


---

Comment by git created at 2014-04-06 06:06:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-06 06:27:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-04-06 06:28:08

Also, an explanation of how exactly the `s_coeff` dictionary is being parsed would be nice (e.g. what happens if I set both its `(1,2)` and its `(2,1)` values?).


---

Comment by tscrim created at 2014-04-07 19:48:29

Sorry for the delays on this; been doing some math and construction. I'll add some doc to the interior product which will hopefully make everything clear. Same for the `s_coeff`.

I think it's better to do by identity. It's faster for UR base rings (or so I've been told and I'd be surprised if it wasn't), and if it's equal but not identical, I think we should change it to make sure its parent is identically the base ring.

Hope you feel better Darij.


---

Comment by darij created at 2014-04-08 00:45:50

Thank you. As long as the identity check doesn't cause bugs (rather than just slowness) when the rings are non-identical but equal, it's all fine (and does make more sense than equality, probably). I'll come back to reviewing once `s_coeff` is documented.

What centers are you going to add? Exterior algebra or also the Clifford algebra? Regular center or supercenter or both? How are you planning to deal with the cases where the basis of the center is not part of the basis of the algebra?


---

Comment by tscrim created at 2014-04-08 02:56:30

Replying to [comment:78 darij]:
> What centers are you going to add? Exterior algebra or also the Clifford algebra? Regular center or supercenter or both? How are you planning to deal with the cases where the basis of the center is not part of the basis of the algebra?

Both Clifford and special case the exterior algebra, and I'm going to (try to do) both regular center and the supercenter. It reduces down to a linear algebra problem, and I was just going to return the elements which are a basis for the center (since there's currently no good framework for subalgebras).


---

Comment by darij created at 2014-04-08 02:57:15

Ah, very nice!


---

Comment by git created at 2014-04-09 00:30:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-04-09 00:33:14

Centers, supercenters, and documentation added. Back to you Darij.


---

Comment by git created at 2014-04-09 00:35:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-09 19:04:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-04-09 21:15:29

Thanks for the docs! I'll look into them (currently I'm recompiling Sage, for the third time within 2 days). Is it really your intention to denote the supercommutator by `[x, y\}`?

The `Classification_of_Clifford_algebras#Pseudoscalar` wikipedia link is misformatted.


---

Comment by git created at 2014-04-10 06:07:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-04-10 06:09:28

Yes, that is my intention. It's notation from my algebra teacher and it comes from a combo of the commutator and anticommutator notations.

I've also fixed the link formatting.


---

Comment by git created at 2014-04-10 06:29:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-10 06:39:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-10 06:55:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-11 02:27:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-11 03:09:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-04-11 03:10:38

While I'm not yet done with clifford_algebra.py, could you perhaps improve the doc of the `expand_derivative` method in `weyl_algebras.py`? It looks mysterious to me (and is it really supposed to change the dictionary `d` while iterating through it?). Thank you!

EDIT: Also, what do you think of renaming `(super)center` as `(super)center_basis`, for the off chance that Sage will eventually be expressive enough to define actual subalgebras?


---

Comment by git created at 2014-04-11 23:09:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-11 23:14:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-04-11 23:15:19

I've added some more to the doc. Also I iterate over the items of `d` (which is a list created when the for loop is first called), so it's safe for me to do that iteration. I've also changed the `(super)center()` to `(super)center_basis()` since that will make it easier to deprecate these once subalgebras are properly implemented.


---

Comment by git created at 2014-04-15 01:55:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-15 02:16:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-23 04:47:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-24 00:30:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-24 01:23:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-24 03:00:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-04-25 16:01:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-05-07 23:56:48

Thanks for catching my stupid mistake in the supercommutator doctests!

The reason why I said "exactly one" rather than "only one" is this:


```
sage: w = E.boundary({(0,1): 0, (1,2): 0, (2,0): 0})
sage: w2 = E.boundary({(0,1): 0, (1,2): 0})
sage: w == w2
False
```


Is this an issue? Is `w2` still functional?

Sorry for my renewed slowdown; the good news is that semester isn't going to go on forever.


---

Comment by git created at 2014-05-07 23:57:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-05-08 00:30:45

Replying to [comment:105 darij]:
> The reason why I said "exactly one" rather than "only one" is this:
> {{{
> sage: w = E.boundary({(0,1): 0, (1,2): 0, (2,0): 0})
> sage: w2 = E.boundary({(0,1): 0, (1,2): 0})
> sage: w == w2
> False
> }}}
> 
> Is this an issue? Is `w2` still functional?

It's more of an abuse and lack of good normalization (i.e. the 0's should be removed from UR supercall).


---

Comment by git created at 2014-05-12 23:09:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-05-12 23:10:02

Fixed:

```
sage: E.<x,y,z> = ExteriorAlgebra(QQ)
sage: w = E.boundary({(0,1): 0, (1,2): 0, (2,0): 0})
sage: w2 = E.boundary({(0,1): 0, (1,2): 0})
sage: w == w2
True
```



---

Comment by git created at 2014-06-25 16:53:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-07-02 16:47:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-07-19 23:41:38

Red again. (Not that I have time to review it these days, but I just noticed when trying to move the branches over to a new install.)


---

Comment by git created at 2014-07-21 17:08:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-07-21 17:09:02

Hmmm...I didn't get any merge conflicts...


---

Comment by darij created at 2014-07-21 17:10:38

Ah, thanks. I think git's automerge is smarter than what the trac server does...


---

Comment by git created at 2014-07-28 23:38:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-07-28 23:41:46

Sorry, I think my merge is wrong; or why am I getting this:

```
Traceback (most recent call last):
  File "/home/darij/sage-6.3.beta6/src/bin/sage-runtests", line 87, in <module>
    err = DC.run()
  File "/home/darij/sage-6.3.beta6/local/lib/python2.7/site-packages/sage/doctest/control.py", line 904, in run
    self.run_doctests()
  File "/home/darij/sage-6.3.beta6/local/lib/python2.7/site-packages/sage/doctest/control.py", line 674, in run_doctests
    self.dispatcher = DocTestDispatcher(self)
  File "/home/darij/sage-6.3.beta6/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1335, in __init__
    init_sage()
  File "/home/darij/sage-6.3.beta6/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 95, in init_sage
    import sage.all_cmdline
  File "/home/darij/sage-6.3.beta6/local/lib/python2.7/site-packages/sage/all_cmdline.py", line 18, in <module>
    from sage.all import *
  File "/home/darij/sage-6.3.beta6/local/lib/python2.7/site-packages/sage/all.py", line 134, in <module>
    from sage.combinat.all   import *
  File "/home/darij/sage-6.3.beta6/local/lib/python2.7/site-packages/sage/combinat/all.py", line 1, in <module>
    from combinat import bell_number, catalan_number, euler_number, fibonacci, \
ImportError: cannot import name permutations_iterator
```


Also, do you happen to remember what parts I have reviewed? I reviewed clifford_algebra.py once, but I'm not sure whether it was the latest version.


---

Comment by git created at 2014-07-29 20:21:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-07-29 20:23:00

OK, fixed (this was a stupid conflict from one of the previous merges).


---

Comment by git created at 2014-07-29 21:01:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-07-29 21:26:17

IIRC, you've reviewed the current version of `clifford_algebra.py` and `SubsetsSorted`. You had mentioned you wanted to do a bit of a rewrite of `WeylAlgebra` to include more general definitions, but IDK if you reviewed the current implementation.


---

Comment by darij created at 2014-10-03 14:49:47

Why does the branch look like it nukes permutation.py?
http://git.sagemath.org/sage.git/diff/?id=d3aba3ff1bcfb9acc035013fb7f794de57c8f09e


---

Comment by git created at 2014-10-03 15:01:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-10-03 15:02:10

Replying to [comment:123 darij]:
> Why does the branch look like it nukes permutation.py?
> http://git.sagemath.org/sage.git/diff/?id=d3aba3ff1bcfb9acc035013fb7f794de57c8f09e

It's a trac issue (likely due to a merge (to be) done `permutation.py`). Here's what I got when I pulled the branch:

```
From trac.sagemath.org:sage
 * branch            public/algebras/weyl_clifford-15300 -> FETCH_HEAD
Auto-merging src/sage/combinat/permutation.py
Merge made by the 'recursive' strategy.
 src/doc/en/reference/algebras/index.rst |    4 +
 src/sage/algebras/all.py                |    4 +
 src/sage/algebras/clifford_algebra.py   | 2575 +++++++++++++++++++++++++++++++
 src/sage/algebras/weyl_algebra.py       |  548 +++++++
 src/sage/combinat/all.py                |    4 +-
 src/sage/combinat/combinat.py           |  202 ++-
 src/sage/combinat/descent_algebra.py    |   11 +-
 src/sage/combinat/permutation.py        |    8 +-
 src/sage/combinat/subset.py             |  201 ++-
 9 files changed, 3456 insertions(+), 101 deletions(-)
 create mode 100644 src/sage/algebras/clifford_algebra.py
 create mode 100644 src/sage/algebras/weyl_algebra.py
```

I've push a rebased branch which takes care of that. Are you getting back to finishing the review here?


---

Comment by darij created at 2014-10-03 15:03:19

I can't say that yet, but I guess I'll know by the end of this week. I'm just finished with procrastinated work I was to do this summer...


---

Comment by tscrim created at 2014-10-03 15:26:42

Replying to [comment:126 darij]:
> I can't say that yet, but I guess I'll know by the end of this week. I'm just finished with procrastinated work I was to do this summer...

I know that feeling. Don't worry too much as there isn't a big rush on this. Also I might have #17096 ready before this (most of the code just needs to be factored out of #15484 and graded algebras).


---

Comment by darij created at 2014-10-03 20:46:03

Thanks for the merge, by the way!

So am I seeing it right that the purpose of `expand_derivative` is to commute a (monomial) differential operator past a polynomial?


---

Comment by git created at 2014-10-10 05:42:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-10-10 05:44:05

Sorry, I fear I won't have the time for this until November :(

Please ask on sage-devel for someone to review the rest of weyl_algebra.py (I have reviewed repr_from_monomials, though I can't guarantee it was the newest version). The general Weyl algebra can then go into a separate ticket, although it might require reverse-incompatible changes to the differential one (I hope it won't).

PS. Why does `__monomial` work on a DifferentialAlgebraElement in the sourcecode but not in the Sage console? Is this some cython hackery?


---

Comment by jhpalmieri created at 2014-10-10 19:13:00

I might be able to finish the review, but I'm not sure. Meanwhile, a few questions and comments:

- should there be a `weyl_algebra` (or similarly named) method for polynomial rings, so this could be found by tab completion once you had a polynomial ring `R`?
- should it be possible to do `W.<dx0, dx1, ...> = DifferentialWeylAlgebra(R)`?

Some links are broken in clifford_algebra.py:

```diff
diff --git a/src/sage/algebras/clifford_algebra.py b/src/sage/algebras/clifford_algebra.py
index 7670255..15a305d 100644
--- a/src/sage/algebras/clifford_algebra.py
+++ b/src/sage/algebras/clifford_algebra.py
`@``@` -899,7 +899,7 `@``@` class CliffordAlgebra(CombinatorialFreeModule):
 
         REFERENCES:
 
-        - :wikipedia:`Classification_of_Clifford_algebras#Pseudoscalar`
+        - :wikipedia:`Classification_of_Clifford_algebras#Unit_pseudoscalar`
         """
         d = self._quadratic_form.dim()
         return self.element_class(self, {tuple(range(d)): self.base_ring().one()})
`@``@` -1113,7 +1113,7 `@``@` class CliffordAlgebra(CombinatorialFreeModule):
 
         .. SEEALSO::
 
-            :meth:`supercenter`,
+            :meth:`supercenter_basis`,
             http://math.stackexchange.com/questions/129183/center-of-clifford-algebra-depending-on-the-parity-of-d
 
         .. TODO::
`@``@` -1203,7 +1203,7 `@``@` class CliffordAlgebra(CombinatorialFreeModule):
 
         .. SEEALSO::
 
-            :meth:`center`,
+            :meth:`center_basis`,
             http://math.stackexchange.com/questions/129183/center-of-clifford-algebra-depending-on-the-parity-of-d
 
         .. TODO::
```



---

Comment by jhpalmieri created at 2014-10-10 20:07:20

A few more comments: the documentation for `expand_derivative` could use a little work. The sum in the displayed math is over which monomials? What is `c_{\alpha}(X)`?

I think you could also add more to the documentation for the `DifferentialWeylAlgebra` class: all you really have now is a link to a wikipedia article. At least mention the generators and relations. Your documentation for `CliffordAlgebra` is very nice, in contrast.

I'm wondering about the generators for a Weyl algebra. I think I expect `gen` (and `gens` and `ngens`) to return the algebra generators, so if we start with a polynomial algebra on one generator `x`, we should get both `x` and `dx`, not just `dx`. I can see that it would be useful to have a method returning just `dx` as a generator, but maybe that method should be called something else. Alternatively, the `gen` method could just return `dx`, but it should be clearly documented, explaining that it doesn't return all of the algebra generators; to get those, you should do `algebra_generators` instead (which at the moment is available via tab-completion but is not implemented). The method `ngens` should be changed accordingly.

I guess you could be viewing the Weyl algebra as an algebra over the polynomial ring, but isn't it usual, if you have an algebra `A` over a ring `R`, to assume that `R` is central in `A`? The Weyl algebra is an iterated Ore extension over the polynomial ring on `n` generators, adding in one `dx` at a time, but even so, the first two places I look (Wikipedia, and McConnell & Robson's _Noncommutative Noetherian Rings_) describe such a Weyl algebra as having `2n` generators, the original polynomial generators and the `dx`'s. So I would discourage your current use of `gen`, `gens`, and `ngens`.


---

Comment by darij created at 2014-10-10 20:50:45

Agreeing with jhpalmieri on the generators. In particular, ngens should give 2n as opposed to n (or else the generalization to arbitrary skew forms will have a non-integer number of generators). I am also highly against non-central algebras being encoded as algebras.

As for `expand_derivative`, if I remember correctly it commutes a differential operator past a polynomial in the Weyl algebra; but I have never actually checked what it really does.

In other news, the failing doctests of the buildbot have nothing to do with this patch. When did Sage become so fickle?


---

Comment by tscrim created at 2014-10-12 14:48:58

I'm making these changes now (it's somewhat of a rewrite of the Weyl algebra, so it might take a day or so).


---

Comment by git created at 2014-10-13 08:04:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-10-13 08:08:20

Okay, I've rewritten `WeylAlgebra` to be over the base ring of the polynomial ring and I've done the other reviewer changes. Back to you John.

The `__monomial` gets name mangled because of the 2 underscores by python. Sage hasn't become so fickle, so much as numerical imprecision/noise on different machines can be hard to foresee (or something like that). I think the tolerance for the noise has been slightly increased and the buildbots need updating, but IDK for sure right now.


---

Comment by darij created at 2014-10-13 13:36:26

I didn't take a real look at this, but there are some issues here:


```
+ - It's a simple ring that is not a matrix ring over a division ring.
+ - It's a non-commutative domain.
+ - For `n = `, it's a quotient of the universal enveloping algebra of the
+ Heisenberg algebra.
+ - Has no finite-dimensional representations in characteristic zero.
```

The "simple" part holds when R is a field. The "non-commutative domain" works only if R is an integral domain. In the third line, what is n ? (I think it is always a quotient of U(Heisenberg_n).


---

Comment by darij created at 2014-10-13 14:51:27

Actually, the simplicity of the Weyl algebra requires R to be a field of characteristic 0. If R is a field of positive characteristic p, then the Weyl algebra acts on `R[x]/(x^p)`, and the kernel of the action is a nonzero proper ideal of the Weyl algebra.


---

Comment by git created at 2014-10-14 02:31:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-10-14 02:32:38

Fixed.


---

Comment by jhpalmieri created at 2014-10-20 23:36:46

When do I need to do `dx,dy,dz = sorted(W.differentials(), key=str)` vs. `dx,dy,dz = W.differentials()`? There are examples of both sorts; is the second version ever safe? I've seen in my own testing that the `variables` method can return its elements in a random order, not necessarily alphabetical. Will the same happen with `differentials` or `algebra_generators`? It's nice that `W.inject_variables()` works well; maybe that should be advertised, or at least used in some examples.

When does `_coerce_map_from_` return a map and not just True or False? Please add more explanation and an example.

A few small changes:

```diff
diff --git a/src/sage/algebras/weyl_algebra.py b/src/sage/algebras/weyl_algebra.py
index 22300d9..8c256a0 100644
--- a/src/sage/algebras/weyl_algebra.py
+++ b/src/sage/algebras/weyl_algebra.py
`@``@` -502,7 +502,7 `@``@` class DifferentialWeylAlgebra(Algebra, UniqueRepresentation):
 
     - ``R`` -- a (polynomial) ring
     - ``names`` -- (default: ``None``) if ``None`` and ``R`` is a
-      polynomial ring, then consider the variable names corrspond to
+      polynomial ring, then the variable names correspond to
       those of ``R``; otherwise if ``names`` is specified, then ``R``
       is the base ring
 
`@``@` -577,7 +577,7 `@``@` class DifferentialWeylAlgebra(Algebra, UniqueRepresentation):
 
     def _element_constructor_(self, x):
         """
-        Construct and element of ``self`` from ``x``.
+        Construct an element of ``self`` from ``x``.
 
         EXAMPLES::
 
```



---

Comment by tscrim created at 2014-10-21 04:31:06

Replying to [comment:141 jhpalmieri]:
> When do I need to do `dx,dy,dz = sorted(W.differentials(), key=str)` vs. `dx,dy,dz = W.differentials()`? There are examples of both sorts; is the second version ever safe? I've seen in my own testing that the `variables` method can return its elements in a random order, not necessarily alphabetical. Will the same happen with `differentials` or `algebra_generators`? It's nice that `W.inject_variables()` works well; maybe that should be advertised, or at least used in some examples.

The question is do we want to return a `Family` indexed by the variable names, which makes it act like a `dict` and have some specified order of output, or act like a list where the ordered of the output is the order of the input.

There's actually somewhat of mismatch and that `algebra_generators` should match the behavior of `variables` and `differentials`. The reason why `inject_variables` works is because of a specified order of `gens`, not `algebra_generators` (which would also be tweaked accordingly).

I'm bias towards making the outputs being indexed since it carries more information. However I do agree with adding examples demonstrating `inject_variables` and other similar constructions. Your thoughts?

> When does `_coerce_map_from_` return a map and not just True or False? Please add more explanation and an example.

This is the design of the function, and if it returns `True`, then `coerce_map_from` creates a map using `_element_constructor_`. There are times when it's easier/better-design to implement a custom morphism (like for a module with basis using `module_morphism`).


---

Comment by jhpalmieri created at 2014-10-21 18:20:28

Replying to [comment:142 tscrim]:
> Replying to [comment:141 jhpalmieri]:
> > When do I need to do `dx,dy,dz = sorted(W.differentials(), key=str)` vs. `dx,dy,dz = W.differentials()`? There are examples of both sorts; is the second version ever safe? I've seen in my own testing that the `variables` method can return its elements in a random order, not necessarily alphabetical. Will the same happen with `differentials` or `algebra_generators`? It's nice that `W.inject_variables()` works well; maybe that should be advertised, or at least used in some examples.
> 
> The question is do we want to return a `Family` indexed by the variable names, which makes it act like a `dict` and have some specified order of output, or act like a list where the ordered of the output is the order of the input.

I don't object to your design choice. My question was maybe more practical: is it ever safe to do `dx,dy,dz=W.differentials()`, or should they always be sorted? If it's not really safe, then there shouldn't be examples like that in the documentation.

> I'm bias towards making the outputs being indexed since it carries more information. However I do agree with adding examples demonstrating `inject_variables` and other similar constructions. Your thoughts?

I think adding some examples using `inject_variables` would be useful. I think you could add them to the class-level docstring for `DifferentialWeylAlgebra` and/or to the `weyl_algebra` methods for polynomial rings (pointing out that the result of `inject_variables` is that the variables will now be in the Weyl algebra, not the polynomial ring).

> > When does `_coerce_map_from_` return a map and not just True or False? Please add more explanation and an example.
> 
> This is the design of the function, and if it returns `True`, then `coerce_map_from` creates a map using `_element_constructor_`. There are times when it's easier/better-design to implement a custom morphism (like for a module with basis using `module_morphism`).

The docstring basically says, "if A, then return either X or Y, and otherwise return Z". A natural question is, when does it return X and when Y? Presumably it's not a coin flip. I'd like the documentation and the examples to explain this. Or do I never need to know this, things are just taken care of in the background? Then the documentation should say so.


---

Comment by tscrim created at 2014-10-22 00:19:29

Replying to [comment:143 jhpalmieri]:
> I don't object to your design choice. My question was maybe more practical: is it ever safe to do `dx,dy,dz=W.differentials()`, or should they always be sorted? If it's not really safe, then there shouldn't be examples like that in the documentation.

I'm starting to question my consistency in the design, so I will take another pass over things. Anyways, it's as safe as the ordering of `d.keys()` where `d` is a python `dict`...so not really. I'll make the necessary changes.

> I think adding some examples using `inject_variables` would be useful. I think you could add them to the class-level docstring for `DifferentialWeylAlgebra` and/or to the `weyl_algebra` methods for polynomial rings (pointing out that the result of `inject_variables` is that the variables will now be in the Weyl algebra, not the polynomial ring).

Will do.

> The docstring basically says, "if A, then return either X or Y, and otherwise return Z". A natural question is, when does it return X and when Y? Presumably it's not a coin flip. I'd like the documentation and the examples to explain this. Or do I never need to know this, things are just taken care of in the background? Then the documentation should say so.

As mentioned, this is the (abridged) specifications of the method, but I see your point. I will reword this.

Changes will be done in a little bit.


---

Comment by darij created at 2014-10-22 00:31:57

Is this a standard situation in Sage that the order of the `gens` of an algebra/group/whatever cannot be trusted? This sounds like another reason to rewrite that method, and deserves its meta-ticket.


---

Comment by tscrim created at 2014-10-22 01:02:58

Replying to [comment:145 darij]:
> Is this a standard situation in Sage that the order of the `gens` of an algebra/group/whatever cannot be trusted? This sounds like another reason to rewrite that method, and deserves its meta-ticket.

It's not the order of `gens` (which by specs return a tuple), but instead that of `algebra_generators` (or similar) that returns a `Family` (by specs) which takes a `dict` as input. So the question becomes do we care about the ordering of the algebra generators? For me, the answer is no except for what's needed by `inject_variables`, but this is handled by `gens`.

Now it is possible to construct the data with a fixed input order by `Family(index_set, function)`, and I wouldn't be too opposed to doing things this way. It gives a slight code smell to me, but it would probably be less surprising to a user...?

Thoughts?


---

Comment by darij created at 2014-10-22 01:06:52

I think we should strive to have `algebra_generators` behave as `gens` should behave, as we are going to deprecate the latter in favor of the former one day. Or am I getting you wrong?


---

Comment by tscrim created at 2014-10-22 01:13:44

Replying to [comment:147 darij]:
> I think we should strive to have `algebra_generators` behave as `gens` should behave, as we are going to deprecate the latter in favor of the former one day. Or am I getting you wrong?

I think on that day, we should change the mechanism of `inject_variables` and the `R.<x,y,z>` syntax to retrieve the generators by their name. Also if we make `algebra_generators` return a `Family` which acts like a tuple, then we distance ourselves somewhat from what the infinite cases behave like-.


---

Comment by jhpalmieri created at 2014-10-22 18:08:30

I'm curious, where does it say that `algebra_generators` should return a `Family`?

I suppose in parallel with `algebra_generators` and `gens`, we could have `variables` and `vars`, returning a `Family` and a `tuple` respectively, and also `differentials` and `diffs`. Or something like that. Those names are not very evocative, so this does not seem ideal. 

I feel that users will frequently want to do things like `dx, dy, dz = W.differentials()`, so we should have an obvious method which returns a sorted tuple. Maybe the method returning a family could be private (`W._differentials()`) or have a name like `W.differentials_as_family()`?


---

Comment by git created at 2014-10-22 19:29:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-10-22 19:32:07

As per discussion, the result of `variables` and `differentials` returns sorted families based upon the ordering of the variable names. I also made it so that `algebra_generators` of the Clifford algebra returns a (similarly sorted) family. Furthermore I fixed the coercion (well...really a conversion) issue for modular images for Weyl algebras as was done for Clifford algebras.


---

Comment by jhpalmieri created at 2014-10-22 23:33:50

The warning in clifford_algebra.py has some typos:

```
The Clifford is not graded, but instead filtred.
```

should be

```
The Clifford algebra is not graded, but instead filtered.
```

Otherwise, I'm happy with it.


---

Comment by git created at 2014-10-23 03:00:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-10-23 03:01:50

Fixed. So I believe everything has been reviewed at this point and means this is a positive review?


---

Comment by jhpalmieri created at 2014-10-23 03:17:50

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2014-10-23 03:23:28

Thank you both!


---

Comment by git created at 2014-10-23 14:46:55

Changing status from positive_review to needs_review.


---

Comment by git created at 2014-10-23 14:46:55

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by darij created at 2014-10-23 14:56:23

Thanks from me, too, John and Travis! Care to review one final piece of code? I have added the lifted bilinear form on the exterior algebra.

TODO list for further patches:

WEYL:

- Weyl algebras in general. This will be mostly copypasting the structure of the Clifford algebra class.

- Differential Weyl algebra as a particular case of a Weyl algebra (I think the matrix is the block matrix \\ (0 -I \\ I 0) \\ here). Is this best achieved by having DifferentialWeylAlgebra inherit from WeylAlgebra, or better by coercions from one to the other? (I hope it's the former.)

CLIFFORD:

- The canonical isomorphism between a Clifford algebra and an exterior algebra induced by a bilinear (! not quadratic !) form. This isomorphism, and its inverse, are particular cases of a common construction (Bourbaki's "Algèbre IX", §9, no. 2-3; Ricardo Baeza's "Quadratic Forms over Semilocal Rings", Lecture Notes in Mathematics 655, Springer 1978): If f and g are two bilinear forms on a module V, and if F and G are their corresponding quadratic forms (so F(x) = f(x, x) and G(x) = g(x, x)), then there is a canonical isomorphism from Cl(V, F) to Cl(V, F + G), which however depends on g and not just on G.

- Use this Clifford-exterior isomorphism to define constant coefficients and scalar products on Clifford algebras. This will depend on a bilinear form.

- Check if the scalar product on the Clifford algebra allows a faster way to compute the lifted bilinear form on the exterior algebra.


---

Comment by vbraun created at 2014-10-23 15:23:04

Changing status from needs_review to needs_work.


---

Comment by vbraun created at 2014-10-23 15:23:04


```
sage -t --long --warn-long 38.2 src/sage/combinat/descent_algebra.py
git log**********************************************************************
File "src/sage/combinat/descent_algebra.py", line 292, in sage.combinat.descent_algebra.DescentAlgebra.D.to_B_basis
Failed example:
    map(B, D.basis()) # indirect doctest
Expected:
    [B[4],
     B[1, 3] - B[4],
     B[2, 2] - B[4],
     B[1, 1, 2] - B[1, 3] - B[2, 2] + B[4],
     B[3, 1] - B[4],
     B[1, 2, 1] - B[1, 3] - B[3, 1] + B[4],
     B[2, 1, 1] - B[2, 2] - B[3, 1] + B[4],
     B[1, 1, 1, 1] - B[1, 1, 2] - B[1, 2, 1] + B[1, 3]
      - B[2, 1, 1] + B[2, 2] + B[3, 1] - B[4]]
Got:
    [B[4],
     B[1, 3] - B[4],
     B[2, 2] - B[4],
     B[3, 1] - B[4],
     B[1, 1, 2] - B[1, 3] - B[2, 2] + B[4],
     B[1, 2, 1] - B[1, 3] - B[3, 1] + B[4],
     B[2, 1, 1] - B[2, 2] - B[3, 1] + B[4],
     B[1, 1, 1, 1] - B[1, 1, 2] - B[1, 2, 1] + B[1, 3] - B[2, 1, 1] + B[2, 2] + B[3, 1] - B[4]]
 **********************************************************************
1 item had failures:
   1 of   5 in sage.combinat.descent_algebra.DescentAlgebra.D.to_B_basis
```



---

Comment by git created at 2014-10-23 15:30:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-10-23 15:33:17

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2014-10-23 15:33:17

I made some tweaks to the `lifted_bilinear_form`. Most importantly I made it return a `PoorManMap` so the repr is nicer, and I changed the doc. I also fixed the doctest Volker noted.


---

Comment by tscrim created at 2014-10-23 15:47:05

Darij could you check my changes (and add a space to that last line in that `descent_algebra.py` doctest since all my cython files are recompiling currently)?


---

Comment by darij created at 2014-10-23 15:56:52

Done and done. I had to change the domain of the PoorManMap, though, and I don't like the result very much.


---

Comment by git created at 2014-10-23 15:57:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-10-23 16:11:16

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2014-10-23 16:11:16

Ah yea. Duh. Thanks.


---

Comment by vbraun created at 2014-10-24 10:14:33

Resolution: fixed
