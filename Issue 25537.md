# Issue 25537: nondeterministic sorting

archive/issues_025537.json:
```json
{
    "body": "Keywords: sorting of tuples and lists\n\nWhile looking for an error, I noted that the built-in \"list.sort\" function\nbehaves erratically. Here is an example which carries out the same operation twice.\n\n```\nlu = [(((2, 3, 5, 6, 8), (2, 3, 8)), [1, 0, 1, 0, 0]), (((2, 3, 5, 6, 8), (2,\n8)), [1, 0, 0, 1, 0]), (((2, 3, 5, 6, 8), (8,)), [1, 0, 0, 0, 1]), (((2,\n3, 6, 8), (2, 3, 8)), [0, 1, 1, 0, 0]), (((2, 3, 6, 8), (2, 8)), [0, 1,\n0, 1, 0]), (((2, 3, 6, 8), (8,)), [0, 1, 0, 0, 1]), ((2, 3, 8), [0, 0,\n2, 0, 0]), ((2, 8), [0, 0, 0, 2, 0]), ((8,), [0, 0, 0, 0, 2])]\n\npulist = lu[-3:]\nfor i in lu[:-3]:\n    pulist.append(i)\npulist.sort()\n\nprint \"pulist sorted\\n\",pulist\n\nlu = [(((2, 3, 5, 6, 8), (2, 3, 8)), [1, 0, 1, 0, 0]), (((2, 3, 5, 6, 8), (2,\n8)), [1, 0, 0, 1, 0]), (((2, 3, 5, 6, 8), (8,)), [1, 0, 0, 0, 1]), (((2,\n3, 6, 8), (2, 3, 8)), [0, 1, 1, 0, 0]), (((2, 3, 6, 8), (2, 8)), [0, 1,\n0, 1, 0]), (((2, 3, 6, 8), (8,)), [0, 1, 0, 0, 1]), ((2, 3, 8), [0, 0,\n2, 0, 0]), ((2, 8), [0, 0, 0, 2, 0]), ((8,), [0, 0, 0, 0, 2])]\n\npulist = lu[-3:]\nfor i in lu[:-3]:\n    pulist.append(i)\npulist.sort()\n\nprint \"pulist sorted again\\n\",pulist\n```\n\nIf I open a new worksheet and enter the above in a block, the result comes out as follows.\n\n```\npulist sorted\n[((2, 3, 8), [0, 0, 2, 0, 0]), ((2, 8), [0, 0, 0, 2, 0]), ((8,), [0, 0,\n0, 0, 2]), (((2, 3, 5, 6, 8), (2, 3, 8)), [1, 0, 1, 0, 0]), (((2, 3, 5,\n6, 8), (2, 8)), [1, 0, 0, 1, 0]), (((2, 3, 5, 6, 8), (8,)), [1, 0, 0, 0,\n1]), (((2, 3, 6, 8), (2, 3, 8)), [0, 1, 1, 0, 0]), (((2, 3, 6, 8), (2,\n8)), [0, 1, 0, 1, 0]), (((2, 3, 6, 8), (8,)), [0, 1, 0, 0, 1])]\npulist sorted again\n[(((2, 3, 5, 6, 8), (2, 3, 8)), [1, 0, 1, 0, 0]), (((2, 3, 5, 6, 8), (2,\n8)), [1, 0, 0, 1, 0]), (((2, 3, 5, 6, 8), (8,)), [1, 0, 0, 0, 1]), (((2,\n3, 6, 8), (2, 3, 8)), [0, 1, 1, 0, 0]), (((2, 3, 6, 8), (2, 8)), [0, 1,\n0, 1, 0]), (((2, 3, 6, 8), (8,)), [0, 1, 0, 0, 1]), ((2, 3, 8), [0, 0,\n2, 0, 0]), ((2, 8), [0, 0, 0, 2, 0]), ((8,), [0, 0, 0, 0, 2])]\n```\n\nHowever, it is not deterministic. If I hit \"evaluate\" repeatedly, it gives sometimes the same result for the two repetitions.\nWhen I run it in python2, or when I run sage from a script, the (correct) result is the first one.\n\nThe python2 specification says:\n  Objects of different types, except different numeric types and different\n  string types, ... are ordered consistently but arbitrarily (so that sorting   \n  a heterogeneous array yields a consistent result).\n\n  CPython implementation detail: Objects of different types except numbers\n  are ordered by their type names; ...\n\nFor me it was important to have *any* ordering whatever, but it\nshould be ordered consistently. This error might be very annoying.\n(As a workaround, I will convert the \"tuples\" etc. to strings.)\n\n(python3 does not allow comparison between an integer and a tuple).\n\nI am attaching the notebook.\nI am using The Sage Notebook, Version 8.3.beta5\n\nIssue created by migration from https://trac.sagemath.org/ticket/25774\n\n",
    "created_at": "2018-07-04T23:34:25Z",
    "labels": [
        "cython",
        "critical",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "nondeterministic sorting",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25537",
    "user": "@guenterrote"
}
```
Keywords: sorting of tuples and lists

While looking for an error, I noted that the built-in "list.sort" function
behaves erratically. Here is an example which carries out the same operation twice.

```
lu = [(((2, 3, 5, 6, 8), (2, 3, 8)), [1, 0, 1, 0, 0]), (((2, 3, 5, 6, 8), (2,
8)), [1, 0, 0, 1, 0]), (((2, 3, 5, 6, 8), (8,)), [1, 0, 0, 0, 1]), (((2,
3, 6, 8), (2, 3, 8)), [0, 1, 1, 0, 0]), (((2, 3, 6, 8), (2, 8)), [0, 1,
0, 1, 0]), (((2, 3, 6, 8), (8,)), [0, 1, 0, 0, 1]), ((2, 3, 8), [0, 0,
2, 0, 0]), ((2, 8), [0, 0, 0, 2, 0]), ((8,), [0, 0, 0, 0, 2])]

pulist = lu[-3:]
for i in lu[:-3]:
    pulist.append(i)
pulist.sort()

print "pulist sorted\n",pulist

lu = [(((2, 3, 5, 6, 8), (2, 3, 8)), [1, 0, 1, 0, 0]), (((2, 3, 5, 6, 8), (2,
8)), [1, 0, 0, 1, 0]), (((2, 3, 5, 6, 8), (8,)), [1, 0, 0, 0, 1]), (((2,
3, 6, 8), (2, 3, 8)), [0, 1, 1, 0, 0]), (((2, 3, 6, 8), (2, 8)), [0, 1,
0, 1, 0]), (((2, 3, 6, 8), (8,)), [0, 1, 0, 0, 1]), ((2, 3, 8), [0, 0,
2, 0, 0]), ((2, 8), [0, 0, 0, 2, 0]), ((8,), [0, 0, 0, 0, 2])]

pulist = lu[-3:]
for i in lu[:-3]:
    pulist.append(i)
pulist.sort()

print "pulist sorted again\n",pulist
```

If I open a new worksheet and enter the above in a block, the result comes out as follows.

```
pulist sorted
[((2, 3, 8), [0, 0, 2, 0, 0]), ((2, 8), [0, 0, 0, 2, 0]), ((8,), [0, 0,
0, 0, 2]), (((2, 3, 5, 6, 8), (2, 3, 8)), [1, 0, 1, 0, 0]), (((2, 3, 5,
6, 8), (2, 8)), [1, 0, 0, 1, 0]), (((2, 3, 5, 6, 8), (8,)), [1, 0, 0, 0,
1]), (((2, 3, 6, 8), (2, 3, 8)), [0, 1, 1, 0, 0]), (((2, 3, 6, 8), (2,
8)), [0, 1, 0, 1, 0]), (((2, 3, 6, 8), (8,)), [0, 1, 0, 0, 1])]
pulist sorted again
[(((2, 3, 5, 6, 8), (2, 3, 8)), [1, 0, 1, 0, 0]), (((2, 3, 5, 6, 8), (2,
8)), [1, 0, 0, 1, 0]), (((2, 3, 5, 6, 8), (8,)), [1, 0, 0, 0, 1]), (((2,
3, 6, 8), (2, 3, 8)), [0, 1, 1, 0, 0]), (((2, 3, 6, 8), (2, 8)), [0, 1,
0, 1, 0]), (((2, 3, 6, 8), (8,)), [0, 1, 0, 0, 1]), ((2, 3, 8), [0, 0,
2, 0, 0]), ((2, 8), [0, 0, 0, 2, 0]), ((8,), [0, 0, 0, 0, 2])]
```

However, it is not deterministic. If I hit "evaluate" repeatedly, it gives sometimes the same result for the two repetitions.
When I run it in python2, or when I run sage from a script, the (correct) result is the first one.

The python2 specification says:
  Objects of different types, except different numeric types and different
  string types, ... are ordered consistently but arbitrarily (so that sorting   
  a heterogeneous array yields a consistent result).

  CPython implementation detail: Objects of different types except numbers
  are ordered by their type names; ...

For me it was important to have *any* ordering whatever, but it
should be ordered consistently. This error might be very annoying.
(As a workaround, I will convert the "tuples" etc. to strings.)

(python3 does not allow comparison between an integer and a tuple).

I am attaching the notebook.
I am using The Sage Notebook, Version 8.3.beta5

Issue created by migration from https://trac.sagemath.org/ticket/25774





---

archive/issue_comments_360064.json:
```json
{
    "body": "Attachment [weird-sort.sws](tarball://root/attachments/some-uuid/ticket25774/weird-sort.sws) by @guenterrote created at 2018-07-04 23:34:53\n\nsaved worksheet",
    "created_at": "2018-07-04T23:34:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25537",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25537#issuecomment-360064",
    "user": "@guenterrote"
}
```

Attachment [weird-sort.sws](tarball://root/attachments/some-uuid/ticket25774/weird-sort.sws) by @guenterrote created at 2018-07-04 23:34:53

saved worksheet



---

archive/issue_comments_360065.json:
```json
{
    "body": "This is not a bug.\n\nYou're trying to compare numbers and tuples. Effectively something like `1 < (2,3)`. In Python 3, this is actually an error. Sage makes no guarantees about this kind of sorting. If you really want to apply the Python 2 convention that you quoted, you should use Python integers instead of Sage integers.",
    "created_at": "2018-07-05T09:14:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25537",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25537#issuecomment-360065",
    "user": "@jdemeyer"
}
```

This is not a bug.

You're trying to compare numbers and tuples. Effectively something like `1 < (2,3)`. In Python 3, this is actually an error. Sage makes no guarantees about this kind of sorting. If you really want to apply the Python 2 convention that you quoted, you should use Python integers instead of Sage integers.



---

archive/issue_comments_360066.json:
```json
{
    "body": "Resolution: wontfix",
    "created_at": "2018-07-05T09:14:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25537",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25537#issuecomment-360066",
    "user": "@jdemeyer"
}
```

Resolution: wontfix



---

archive/issue_comments_360067.json:
```json
{
    "body": "If sage make no guarantees it would be much better to **disable the comparison operations**\nfor sage-integers when the result makes no sense. rather than let unwary users\nrun into a trap. (The ___le___ etc. methods would have to be adapted so that they raise an exception, like in python3.)\n\nIs it documented somewhere that sage makes no guarantees about this kind of sorting?\nsage.rings.integer.Integer?\nThe Python2 convention that I cited would imply that even sage-integers should be \"ordered consistently but arbitrarily\" when compared to other objects.\n\n(Let me explain the background.\nIn my application, I generated some object (a polyhedral subdivision) whose\nvertices are naturally described by some combinatorial \"code\" (tuples of various\nnesting depth).\nI needed to process the vertices in SOME consistent order, no matter which.\n(in order to obtain matching triangulations on he boundaries between different cells).\nThe permissive comparison conventions of python2 were very handy for this purpose.\nI trusted my results for some time, until some more elaborate tests revealed that\nthe objects that I was creating were malformed.)",
    "created_at": "2018-07-05T09:49:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25537",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25537#issuecomment-360067",
    "user": "@guenterrote"
}
```

If sage make no guarantees it would be much better to **disable the comparison operations**
for sage-integers when the result makes no sense. rather than let unwary users
run into a trap. (The ___le___ etc. methods would have to be adapted so that they raise an exception, like in python3.)

Is it documented somewhere that sage makes no guarantees about this kind of sorting?
sage.rings.integer.Integer?
The Python2 convention that I cited would imply that even sage-integers should be "ordered consistently but arbitrarily" when compared to other objects.

(Let me explain the background.
In my application, I generated some object (a polyhedral subdivision) whose
vertices are naturally described by some combinatorial "code" (tuples of various
nesting depth).
I needed to process the vertices in SOME consistent order, no matter which.
(in order to obtain matching triangulations on he boundaries between different cells).
The permissive comparison conventions of python2 were very handy for this purpose.
I trusted my results for some time, until some more elaborate tests revealed that
the objects that I was creating were malformed.)



---

archive/issue_comments_360068.json:
```json
{
    "body": "Changing priority from critical to major.",
    "created_at": "2018-07-05T09:51:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25537",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25537#issuecomment-360068",
    "user": "@guenterrote"
}
```

Changing priority from critical to major.



---

archive/issue_comments_360069.json:
```json
{
    "body": "Changing type from defect to enhancement.",
    "created_at": "2018-07-05T09:51:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25537",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25537#issuecomment-360069",
    "user": "@guenterrote"
}
```

Changing type from defect to enhancement.



---

archive/issue_comments_360070.json:
```json
{
    "body": "Replying to [comment:4 guenterrote]:\n> If sage make no guarantees it would be much better to **disable the comparison operations**\n> for sage-integers when the result makes no sense.\n\nIndeed. That's the goal of #22029.",
    "created_at": "2018-07-05T09:54:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25537",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25537#issuecomment-360070",
    "user": "@jdemeyer"
}
```

Replying to [comment:4 guenterrote]:
> If sage make no guarantees it would be much better to **disable the comparison operations**
> for sage-integers when the result makes no sense.

Indeed. That's the goal of #22029.



---

archive/issue_comments_360071.json:
```json
{
    "body": "Resolution changed from wontfix to duplicate",
    "created_at": "2018-07-05T09:54:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25537",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25537#issuecomment-360071",
    "user": "@jdemeyer"
}
```

Resolution changed from wontfix to duplicate
