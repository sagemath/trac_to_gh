# Issue 22124: Bug in creation of SetPartition

Issue created by migration from https://trac.sagemath.org/ticket/22361

Original creator: mantepse

Original creation time: 2017-02-12 14:05:13

CC:  sage-combinat tscrim darij alauve zabrocki

So far, I've no idea what's wrong.  Here is the code, it produces an assertion error:

```
sage: n=3
sage: d = {pi: pi.descents(from_zero=False) for pi in Permutations(n)}
sage: C = [[pi for pi in d if d[pi]==des] for des in d.values()]
sage: SetPartition(C)
```



---

Comment by jmantysalo created at 2017-02-12 14:14:17

Your `C` is unhashable. Compare `SetPartition([[(1,2),(3,4)],[(5,6)]]` and `SetPartition([[[1,2],[3,4]],[This is the Trac macro *5,6* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#5,6-macro)])`; tuples are immutable, lists are mutable.

Anyways, the error message should be better.


---

Comment by mantepse created at 2017-02-12 14:37:06

Actually, I made a worse mistake.  `C` contains duplicate elements...

Can I close this ticket?


---

Comment by jmantysalo created at 2017-02-12 15:03:00

Replying to [comment:2 mantepse]:

> Can I close this ticket?

Change milestone to sage-invalid/duplicate/wontfix and put to needs review -state. I can then mark as positive review.

But I think you found a kind of bug. Why was the error message like what you get?


---

Comment by mantepse created at 2017-02-12 16:17:58

Changing priority from major to minor.


---

Comment by jmantysalo created at 2017-02-12 18:52:10

Travis knows more about how to correct this.


---

Comment by tscrim created at 2017-02-12 19:03:42

The problem is in how `SetPartition(foo)` works. It assumes that `foo` corresponds to an element in `SetPartitions()`, which is the disjoint union of all set partitions of `[n]`. I would make the `__classcall_private__` actually try somewhat to construct the correct set of set partitions. Another problem is that the constructor is not quite permissive enough when constructing the elements (or at least is trying enough to convert it to the correct datatypes).


---

Comment by mantepse created at 2017-02-12 19:33:00

Minor correction: since `SetPartition([[pi] for pi in Permutations(3)])` works, I think that `SetPartitions` is what it promises to be.

Thus, I think the difficulty is rather to have `check` do something more fine grained than `self in self.parent()`.

If I understand correctly, `self in self.parent()` is shorthand for `self.parent().__contains__(self)` which does all the right checks, but only returns `True` or `False`.

So, the quick fix is to copy all these checks into `check`.  However, this is duplication of code.


---

Comment by tscrim created at 2017-02-12 19:44:08

Very strong -1.

The check is not the problem. The main problem that generates this error is the allowable data structures to construct elements:

```
sage: SetPartition(set(map(Set, C)))
{{[1, 2, 3]}, {[1, 3, 2], [2, 3, 1]}, {[2, 1, 3], [3, 1, 2]}, {[3, 2, 1]}}
```

The `__contains__` fails (as it should) because a list is not a set.

However, there is another potential issue with the containment check not being strict enough because the set partition corresponding to, e.g., `C` is not in the enumerated set. I'm okay with `SetPartitions()` being a generic parent, but it is technically wrong that `set(map(Set, C)) in SetPartitions()`. Fixing this means we need to be more specific about the parent that `SetPartition.__classcall_private__` constructs.

Edit - +1 to changing to raising `ValueError`.


---

Comment by mantepse created at 2017-02-13 15:24:29

Sorry, I do not understand.  Are you saying that `set(map(Set, C)) in SetPartitions()` should return `False`?

If so, then `SetPartitions.__contains__` should be as simple as `isinstance(x, SetPartition)`, no?


---

Comment by tscrim created at 2017-02-13 15:30:36

Replying to [comment:11 mantepse]:
> Sorry, I do not understand.  Are you saying that `set(map(Set, C)) in SetPartitions()` should return `False`?

I would say yes. However, that is a problem for another ticket since the fix is much more in-depth than what we should be doing on this ticket.

> If so, then `SetPartitions.__contains__` should be as simple as `isinstance(x, SetPartition)`, no?

No! That would completely circumvent the checks.


---

Comment by git created at 2017-02-13 15:37:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-02-13 15:41:05

Travis, I simply removed `SetPartitions.__contains__` and this seems to work.  Could you please let me know what you think is going wrong now?

(concerning `SetPartitions` and `SetPartition` only, I didn't touch the rest right now.)


---

Comment by tscrim created at 2017-02-13 15:49:55

Replying to [comment:14 mantepse]:
> Travis, I simply removed `SetPartitions.__contains__` and this seems to work.  Could you please let me know what you think is going wrong now?

That defaults back to `Parent.__contains__`, which simply checks to see that the input can construct an element of itself. Hence, no check is actually performed. This is going in the wrong direction. I should have time to actually fix this today.


---

Comment by mantepse created at 2017-02-13 16:01:37

Travis, I would like to understand (and there is no rush):

I moved the check into `SetPartition.check`.  So, the check is performed when "untrusted" code creates a set partition.

Why is this going in the wrong direction?


---

Comment by tscrim created at 2017-02-13 16:14:54

Replying to [comment:16 mantepse]:
> Travis, I would like to understand (and there is no rush):
> 
> I moved the check into `SetPartition.check`.  So, the check is performed when "untrusted" code creates a set partition.
> 
> Why is this going in the wrong direction?

Sorry, I forgot that you moved that into the `check` function. However, this now has `__contains__` construct an element and then perform the check, the first of which is relatively slow and also requires extra function calls. It also means that subclasses cannot strictly override the `__contains__` behavior (should they want to).


---

Comment by tscrim created at 2017-02-13 16:16:17

Also, thinking about it (i.e. not by testing), it should allow one to create set partitions that are not in the correct parent, such as `{{1}}` could be an element of `SetPartitions(2)`.


---

Comment by mantepse created at 2017-02-13 16:24:10

Where is `check` perform a `__contains__`? 


```
sage: SetPartition([[1]]) in SetPartitions(2)
False
```

because that check is performed in the various `__contains__` methods of the subclasses.  More precisely, if you want to have, for example, Set partitions of a fixed set `S`, you'd implement `__contains__` there, which would check that the union of the parts of the argument is the given set.


---

Comment by tscrim created at 2017-02-13 16:30:56

As I suspected, with your branch, I can do:

```
sage: P2 = SetPartitions(2)
sage: P2([[1]])
{{1}}
sage: P2([[1]]) in P2
False
```

in contrast to the current behavior, which raises an error.


---

Comment by tscrim created at 2017-02-13 16:31:50

No, it is the other way around. If you are checking a containment, then it creates an element and performs `check`. IMO, the check of `__contains__` should be as fast as possible.


---

Comment by tscrim created at 2017-02-13 17:26:54

Here's a branch where your approach could not work by optimizing the `__contains__` and a few other things. At least it would not work without pushing all of containment checking to `check()`, which would necessitate subclassing the element class as well.

I think this is a situation of we can't have our cake and eat it too. If we want a more refined error message, then we need to duplicate some of the code in `check()`. :/ Although since it is not a big block of code, I wouldn't strictly object.
----
New commits:


---

Comment by mantepse created at 2017-02-13 18:52:16

OK, I made a mistake (`check` would need to be implemented in all subclasses, too).  Anyway, I'm back to try to understand how all this works.  Here is what I thought.  Could you please point out precisely where I'm wrong?

1) `x in SetPartitions(17)` should simply check whether the parent is correct.  That is, `__contains__` should *not* be overwritten.

2) For each kind of set partition, we need to implement `check`, which should throw an error, if the argument is not good.  To make this work, `check` should actually be implemented in the parent class.  Is this impossible or undesirable?


---

Comment by tscrim created at 2017-02-13 23:35:22

Replying to [comment:23 mantepse]:
> OK, I made a mistake (`check` would need to be implemented in all subclasses, too).  Anyway, I'm back to try to understand how all this works.  Here is what I thought.  Could you please point out precisely where I'm wrong?
> 
> 1) `x in SetPartitions(17)` should simply check whether the parent is correct.  That is, `__contains__` should *not* be overwritten.

This is not true. If the parent of `x` is not `S = SetPartitions(17)`, then it tries `x == S(x)` (which could involve an additional coercion attempt for the `==`). In fact, I am advocating that `__contains__` _should_ be overwritten.

> 2) For each kind of set partition, we need to implement `check`, which should throw an error, if the argument is not good.  To make this work, `check` should actually be implemented in the parent class.  Is this impossible or undesirable?

No, we would need to implement `check` in each element class for the respective parents, which means a new element class for each parent. This is the first thing that we want to avoid. The second is that it makes `__contains__` much slower (relatively) because it has to construct a new element (which then has to be destroyed because it is transient no matter what). I don't think a (slightly) more detailed error message is worth this.


---

Comment by git created at 2018-04-11 18:46:30

Branch pushed to git repo; I updated commit sha1. New commits:
