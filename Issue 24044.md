# Issue 24044: Fix comparison of RingHomomorphisms

Issue created by migration from https://trac.sagemath.org/ticket/24281

Original creator: jdemeyer

Original creation time: 2017-11-26 08:38:12

CC:  tscrim

Often, the same morphism can be created as different Python classes. For example, these are two versions of the identity map on `QQ`:

```
sage: H = End(QQ)
sage: f = H.identity()
sage: g = H(1)
sage: type(f)
<type 'sage.categories.morphism.IdentityMorphism'>
sage: type(g)
<type 'sage.rings.morphism.RingHomomorphism_im_gens'>
```

The problem is that these may not compare equal:

```
sage: g == f
False
sage: f == g
True
```



---

Comment by jdemeyer created at 2017-11-27 14:52:37

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-11-27 14:52:37

New commits:


---

Comment by git created at 2017-11-27 15:57:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-11-27 16:09:56

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2017-11-28 00:04:09

I think having the checks that the (co)domains matched was a good first check because that should be very quick (generally, a comparison of `id`s). Moreover, with your code, you can get equality of morphisms when there is a coercion from one codomain into the other that results in equal elements.

```
sage: D = ZZ['x']
sage: C1 = ZZ['x']
sage: C2 = QQ['x']
sage: phi = D.morphism(C1.gens())
sage: psi = D.morphism(C2.gens())
sage: Morphism._richcmp_(psi, phi, 2)  # 2 == Py_EQ
True
```

However, we do not want these to be equal as we then have an isomorphism equal to a non-surjective map. A more minimal example that directly uses the `Morphism._richcmp_`:

```
sage: IZZ = Hom(ZZ,ZZ).natural_map()
sage: IQQ = Hom(QQ,QQ).natural_map()
sage: IZZ._richcmp_(IQQ, 2)
True
```

(Although I do not understand why `==` is returning `False` in both of these cases.)

Also, why did you remove the `_richcmp_` for `MatrixMorphism`? I know that might generally involve more comparisons, but it still should require less CPU cycles because you do not have to apply the morphisms. Although the same comment about equal (co)domains definitely still applies (and is a current bug).


---

Comment by git created at 2017-11-28 08:44:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-11-28 08:45:16

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2017-11-28 08:47:58

Oh, wait, the reason why we do not need to check the (co)domains match is because by the time we get to `_richcmp_`, we had to have coerced into the same parent. So the (co)domains must match at that point.


---

Comment by jdemeyer created at 2017-11-28 08:49:01

Replying to [comment:10 tscrim]:
> Oh, wait, the reason why we do not need to check the (co)domains match is because by the time we get to `_richcmp_`, we had to have coerced into the same parent. So the (co)domains must match at that point.

Exactly. I was going to write you a longer reply, but you figured it out :-)


---

Comment by jdemeyer created at 2017-11-28 08:49:22

Replying to [comment:7 tscrim]:
> {{{
> sage: D = ZZ['x']
> sage: C1 = ZZ['x']
> sage: C2 = QQ['x']
> sage: phi = D.morphism(C1.gens())
> sage: psi = D.morphism(C2.gens())
> sage: Morphism._richcmp_(psi, phi, 2)  # 2 == Py_EQ
> True
> }}}

What is `D.morphism()` by the way? I get `AttributeError: 'PolynomialRing_integral_domain_with_category' object has no attribute 'morphism'`


---

Comment by jdemeyer created at 2017-11-28 08:51:09

Replying to [comment:7 tscrim]:
> Also, why did you remove the `_richcmp_` for `MatrixMorphism`?

My initial thought was that for directional comparisons (`<`, `<=`, `>`, `>=`), the code would give a different result from `Morphism._richcmp_`. So I restored the original code but only for `==` and `!=`.


---

Comment by jdemeyer created at 2017-11-28 08:53:12

Replying to [comment:10 tscrim]:
> Oh, wait, the reason why we do not need to check the (co)domains match is because by the time we get to `_richcmp_`, we had to have coerced into the same parent. So the (co)domains must match at that point.

Interestingly, morphisms are a good example in Sage of `Element` classes where one `Parent` allows many different `Element` classes. And we clearly didn't deal properly with that.


---

Comment by tscrim created at 2017-11-28 08:54:21

Replying to [comment:12 jdemeyer]:
> Replying to [comment:7 tscrim]:
> > {{{
> > sage: D = ZZ['x']
> > sage: C1 = ZZ['x']
> > sage: C2 = QQ['x']
> > sage: phi = D.morphism(C1.gens())
> > sage: psi = D.morphism(C2.gens())
> > sage: Morphism._richcmp_(psi, phi, 2)  # 2 == Py_EQ
> > True
> > }}}
> 
> What is `D.morphism()` by the way? I get `AttributeError: 'PolynomialRing_integral_domain_with_category' object has no attribute 'morphism'`

Sorry, I thought I had copied the code I actually used there. That was pseudocode I wrote while waiting for Sage to recompile. It was suppose to be `phi = Hom(D,C1)(C1.gens())`.


---

Comment by tscrim created at 2017-11-28 09:01:24

Replying to [comment:14 jdemeyer]:
> Replying to [comment:10 tscrim]:
> > Oh, wait, the reason why we do not need to check the (co)domains match is because by the time we get to `_richcmp_`, we had to have coerced into the same parent. So the (co)domains must match at that point.
> 
> Interestingly, morphisms are a good example in Sage of `Element` classes where one `Parent` allows many different `Element` classes. And we clearly didn't deal properly with that.

This is currently the biggest example of that general shortcoming and should be addressed at some point. Although I guess in some ways with how we do things with extension classes, it works, but I am fairly certain we loose stuff from the categories when using Python classes.


---

Comment by tscrim created at 2017-11-28 09:09:08

Replying to [comment:13 jdemeyer]:
> Replying to [comment:7 tscrim]:
> > Also, why did you remove the `_richcmp_` for `MatrixMorphism`?
> 
> My initial thought was that for directional comparisons (`<`, `<=`, `>`, `>=`), the code would give a different result from `Morphism._richcmp_`. So I restored the original code but only for `==` and `!=`.

I see.

The earlier error is making me think a bit more about using `gens` in the general morphism code. I don't think this suffers from the same problem as #15381. Yet, we probably want to return a `NotImplemented` when `gens` is not defined (maybe also catching if it raises some [reasonable] error?).


---

Comment by jdemeyer created at 2017-11-28 09:19:08

Replying to [comment:17 tscrim]:
> The earlier error is making me think a bit more about using `gens` in the general morphism code. I don't think this suffers from the same problem as #15381.

I think it does in the sense that I did not fix #15381 or #17768.

> Yet, we probably want to return a `NotImplemented` when `gens` is not defined

Not sure about that. I like explicit errors, such as an `AttributeError` when there is no `gens()`.


---

Comment by tscrim created at 2017-11-28 12:33:58

Replying to [comment:18 jdemeyer]:
> Replying to [comment:17 tscrim]:
> > The earlier error is making me think a bit more about using `gens` in the general morphism code. I don't think this suffers from the same problem as #15381.
> 
> I think it does in the sense that I did not fix #15381 or #17768.

Since it makes the problem no worse than before, we can just let it be.

> > Yet, we probably want to return a `NotImplemented` when `gens` is not defined
> 
> Not sure about that. I like explicit errors, such as an `AttributeError` when there is no `gens()`.

I guess we have a little more freedom with raising errors than `__contains__` (which should never raise an error). However, because of the type of error and how generic this code it suppose to be, I feel such an error strongly suggests that parent classes should implement `gens` in contrast to `*_generators` and having the appropriate category redirect from `gens` or perhaps where it is not a natural construct (say a combinatorial set). I guess since this is post-coercion, having it raise an error is saying something about the implementation of either the underlying object or their morphisms and you don't have any more fragile code by comparing a `X - > Y` and `X' -> Y` morphism, where `X` and `X'` might be in completely different categories. So I guess it is okay.

The only other thing I would like is a doctest for `_richcmp_`, preferably one that was incorrect before and now succeeds and the `QQ` vs `ZZ` example with something like

```
While this compares by generators (which can use coercion), the coercion model
is first invoked to guarantee that domains must match in order to have the
same parent for the morphisms::

    sage: phi = Hom(ZZ,ZZ).natural_map()
    sage: psi = Hom(QQ,QQ).natural_map(
    sage: Morphism._richcmp_(phi, psi, 2)
    True
    sage: phi == psi
    False
```



---

Comment by jdemeyer created at 2017-11-28 12:38:28

Replying to [comment:19 tscrim]:
> {{{
> While this compares by generators (which can use coercion), the coercion model
> is first invoked to guarantee that domains must match in order to have the
> same parent for the morphisms::
> 
>     sage: phi = Hom(ZZ,ZZ).natural_map()
>     sage: psi = Hom(QQ,QQ).natural_map()
>     sage: Morphism._richcmp_(phi, psi, 2)
>     True
> }}}

That is a horrible test because you should really _never_ do that (`_richcmp_` with different parents). Why should I add it?


---

Comment by tscrim created at 2017-11-28 12:46:22

Replying to [comment:20 jdemeyer]:
> Replying to [comment:19 tscrim]:
> > {{{
> > While this compares by generators (which can use coercion), the coercion model
> > is first invoked to guarantee that domains must match in order to have the
> > same parent for the morphisms::
> > 
> >     sage: phi = Hom(ZZ,ZZ).natural_map()
> >     sage: psi = Hom(QQ,QQ).natural_map()
> >     sage: Morphism._richcmp_(phi, psi, 2)
> >     True
> > }}}
> 
> That is a horrible test because you should really _never_ do that (`_richcmp_` with different parents). Why should I add it?

Yea, right, duh. However, we should document it somewhere that we are (strongly) assuming that the parents, and hence the (co)domains are the same because of the coercion involved.


---

Comment by jdemeyer created at 2017-11-28 15:49:39

Replying to [comment:19 tscrim]:
> However, because of the type of error and how generic this code it suppose to be, I feel such an error strongly suggests that parent classes should implement `gens` in contrast to `*_generators` and having the appropriate category redirect from `gens` or perhaps where it is not a natural construct (say a combinatorial set). I guess since this is post-coercion, having it raise an error is saying something about the implementation of either the underlying object or their morphisms and you don't have any more fragile code by comparing a `X - > Y` and `X' -> Y` morphism, where `X` and `X'` might be in completely different categories. So I guess it is okay.

I don't quite understand what you are trying to say here...

I agree that `gens()` might not be ideal, but that is really an issue for #15381.


---

Comment by git created at 2017-11-28 15:59:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-11-28 16:11:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-11-28 16:13:19

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2017-11-29 08:07:05

Replying to [comment:22 jdemeyer]:
> Replying to [comment:19 tscrim]:
> > However, because of the type of error and how generic this code it suppose to be, I feel such an error strongly suggests that parent classes should implement `gens` in contrast to `*_generators` and having the appropriate category redirect from `gens` or perhaps where it is not a natural construct (say a combinatorial set). I guess since this is post-coercion, having it raise an error is saying something about the implementation of either the underlying object or their morphisms and you don't have any more fragile code by comparing a `X - > Y` and `X' -> Y` morphism, where `X` and `X'` might be in completely different categories. So I guess it is okay.
> 
> I don't quite understand what you are trying to say here...

Yea, that was perhaps a bit too short and poorly written. There are two things:

1. A category that does not have a natural notation of `gens` such as `EnumeratedSets()`. Then morphisms in that category should override the `_richcmp_` because more information is necessary (it would normally have to provide it anyways).

  The problem I have with having it raise an `AttributeError` on `gens` is that it suggests that the user should implement a `gens` rather than give an (overriding) implementation of `_richcmp_`. So I feel that it sends the wrong message in these cases.

  Also, mostly just to note, this will be a behavior change that might result in code breaking in the wild.

2. Suppose you have `f: X -> Y` and `g: X' -> Y`, where the category of `X` is, e.g., `Algebras(ZZ)` and `X'` is `Modules(ZZ)` with `X'` being `X` under the forgetful functor. However, because this would happen post-coercion (assuming smart enough homsets and coercion code), the object `X` should become `X'` and so `gens` would be the basis rather than the algebra generators.

  Although I do not think our coercion and functor code is smart enough to handle this sort of situation right now anyways. The thought I had is that it really used the algebra generators of `X` to do the comparison, which may result in wrong answers because `g` is not an algebra morphism but matches on the algebra generators.

Does that clarify things?

> I agree that `gens()` might not be ideal, but that is really an issue for #15381.

I'm not completely sure that #15381 is relevant for not using `gens`, but your changes are no worse than before too. So this is not a blocker for a positive review.


---

Comment by tscrim created at 2017-11-29 08:08:20

I feel that we should just remove the init test for `RingMap`. I think it was just there to give 100% doctest coverage, and it is not a useful test.


---

Comment by jdemeyer created at 2017-11-29 08:14:42

Replying to [comment:26 tscrim]:
>   Also, mostly just to note, this will be a behavior change that might result in code breaking in the wild.

Fixing bugs changes behaviour...


---

Comment by tscrim created at 2017-11-29 08:21:29

Replying to [comment:28 jdemeyer]:
> Replying to [comment:26 tscrim]:
> >   Also, mostly just to note, this will be a behavior change that might result in code breaking in the wild.
> 
> Fixing bugs changes behaviour...

I do not consider this to be a bug. Yet, I don't think it is a spacebar-esqe in the sense there might be someone who is relying on this behavior in a non-horrifying way. However, raising an error in this case will not be a blocker from me either.


---

Comment by jdemeyer created at 2017-11-29 14:09:08

Replying to [comment:26 tscrim]:
> The problem I have with having it raise an `AttributeError` on `gens` is that it suggests that the user should implement a `gens` rather than give an (overriding) implementation of `_richcmp_`. So I feel that it sends the wrong message in these cases.

OK, I changed this to raise `NotImplementedError`. Returning `NotImplemented` seems inappropriate here because the `_richcmp_` method does understand what is asked and it knows that it cannot compute the result.

> 2. Suppose you have `f: X -> Y` and `g: X' -> Y`, where the category of `X` is, e.g., `Algebras(ZZ)` and `X'` is `Modules(ZZ)` with `X'` being `X` under the forgetful functor. However, because this would happen post-coercion (assuming smart enough homsets and coercion code), the object `X` should become `X'` and so `gens` would be the basis rather than the algebra generators.

It shouldn't be a problem if there are _more_ gens. Comparing algebra morphisms using the module generators is safe (but possibly inefficient).


---

Comment by jdemeyer created at 2017-11-29 14:09:33

Replying to [comment:27 tscrim]:
> I feel that we should just remove the init test for `RingMap`. I think it was just there to give 100% doctest coverage, and it is not a useful test.

I added a test of the `parent()`. That makes the example do at least something non-trivial.


---

Comment by git created at 2017-11-29 14:09:58

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2017-11-30 01:07:01

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2017-11-30 01:07:01

Replying to [comment:30 jdemeyer]:
> Replying to [comment:26 tscrim]:
> > The problem I have with having it raise an `AttributeError` on `gens` is that it suggests that the user should implement a `gens` rather than give an (overriding) implementation of `_richcmp_`. So I feel that it sends the wrong message in these cases.
> 
> OK, I changed this to raise `NotImplementedError`. Returning `NotImplemented` seems inappropriate here because the `_richcmp_` method does understand what is asked and it knows that it cannot compute the result.

Thank you.

Everything else LGTM. Positive review.


---

Comment by vbraun created at 2017-12-13 17:37:55

Resolution: fixed
