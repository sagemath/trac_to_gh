# Issue 13803: When computing determinant over GF(p), don't lift to ZZ

Issue created by migration from Trac.

Original creator: jdemeyer

Original creation time: 2013-01-24 17:15:19

Assignee: jason, was

It seems we compute determinants over `GF(p)` by lifting the matrix to `ZZ`.  This is a stupid idea.


---

Comment by jdemeyer created at 2013-01-24 20:50:42

Changing status from new to needs_review.


---

Comment by slabbe created at 2013-01-25 11:50:12

Does there exist a possible doctest for this ticket? There is no doctest added in the patch.


---

Comment by jdemeyer created at 2013-01-25 12:16:36

Replying to [comment:2 slabbe]:
> There is no doctest added in the patch.
There are already doctests computing determinants over `GF(p)`, so I don't see why we should add a new one.


---

Comment by slabbe created at 2013-01-25 14:04:23

Well, I was also asking this to help me do the review. But I will look again at the example in the original sage-devel post.


---

Comment by Bouillaguet created at 2013-01-26 11:39:09

Changing status from needs_review to positive_review.


---

Comment by Bouillaguet created at 2013-01-26 11:39:09

There is a convincing improvement : 

```
sage: M = random_matrix( Integers( next_prime( factorial(10) ) ), 400 )
sage: time M.det()
Time: CPU 0.04 s, Wall: 0.03 s
```

versus :

```
sage: M = random_matrix( Integers( next_prime( factorial(10) ) + 1), 400 )
sage: time M.det()
Time: CPU 4.65 s, Wall: 3.99 s
```


Positive review !


---

Comment by Bouillaguet created at 2013-01-26 19:18:19

Changing status from positive_review to needs_work.


---

Comment by Bouillaguet created at 2013-01-26 19:18:19

There are cases where the patch is in fact a huge regression !

I ran the following test : 

```
sage: sage: for i in range(1,6):
    M = random_matrix( Integers(p), 75*i )
    time d = M.det()
```

with ``p = next_prime( factorial(20) )`` and ``sage: p = next_prime( factorial(21) )``

Before patch:

```
# 20!
Time: CPU 0.10 s, Wall: 0.10 s
Time: CPU 0.56 s, Wall: 0.55 s
Time: CPU 1.56 s, Wall: 1.51 s
Time: CPU 3.62 s, Wall: 3.10 s
Time: CPU 6.46 s, Wall: 5.26 s

# 21!
Time: CPU 0.17 s, Wall: 0.17 s
Time: CPU 0.61 s, Wall: 0.59 s
Time: CPU 1.72 s, Wall: 1.67 s
Time: CPU 3.92 s, Wall: 3.36 s
Time: CPU 6.85 s, Wall: 5.63 s
```


After patch:

```
# 20!
Time: CPU 0.11 s, Wall: 0.11 s
Time: CPU 0.51 s, Wall: 0.51 s
Time: CPU 1.17 s, Wall: 1.17 s
Time: CPU 2.15 s, Wall: 2.15 s
Time: CPU 3.43 s, Wall: 3.43 s            # this is cool

# 21!
Time: CPU 0.17 s, Wall: 0.17 s
Time: CPU 0.65 s, Wall: 0.65 s
Time: CPU 1.77 s, Wall: 1.77 s
Time: CPU 4.06 s, Wall: 4.06 s
Time: CPU 36.89 s, Wall: 36.89 s        # problem here
```



---

Comment by Bouillaguet created at 2013-01-26 19:41:03

The threshold is very clearly at ``2^64``. This is with the patch: 

```
sage: p = next_prime(2^64-60)
sage: M = random_matrix( Integers(p), 75*5 )
sage: M2 = matrix(ZZ, M)

sage: time d = M.det()
Time: CPU 3.49 s, Wall: 3.49 s      # PARI prime case is faster
sage: time d = M2.det()
Time: CPU 6.29 s, Wall: 5.09 s


sage: p = next_prime(2^64)
sage: M = random_matrix( Integers(p), 75*5 )
sage: M2 = matrix(ZZ, M)

sage: time d = M.det()
Time: CPU 8.83 s, Wall: 8.83 s       # PARI prime case is slower
sage: time d = M2.det()
Time: CPU 6.77 s, Wall: 5.52 s
```



---

Comment by jdemeyer created at 2013-01-26 21:42:40

Perhaps only use PARI for moduli up to the machine word size?


---

Comment by Bouillaguet created at 2013-01-27 08:11:17

sounds reasonable, but I don't have a 32-bit machine under my hand to test this.


---

Comment by slabbe created at 2013-01-29 10:55:09

with OSX 10.5.8, 32-bit, sage-5.6.rc0 + 14007_matrix_modp.patch :


```
sage: p = next_prime(2^32-60)              
sage: p < 2^32                             
True                                       
sage: M = random_matrix(Integers(p), 75*5) 
sage: M2 = matrix(ZZ, M)                   
sage: time d = M.det()                     
Time: CPU 7.49 s, Wall: 7.53 s             
sage: time d = M2.det()                    
Time: CPU 9.55 s, Wall: 9.49 s   

sage: p = next_prime(2^32)                 
sage: M = random_matrix(Integers(p), 75*5) 
sage: M2 = matrix(ZZ, M)                   
sage: time d = M.det()                     
Time: CPU 14.15 s, Wall: 14.59 s           
sage: time d = M2.det()                    
Time: CPU 9.81 s, Wall: 9.72 s             

sage: p = next_prime(2^64-60)                
sage: M = random_matrix(Integers(p), 75*5)   
sage: M2 = matrix(ZZ, M)        
sage: time d = M.det()                       
Time: CPU 15.82 s, Wall: 16.08 s             
sage: time d = M2.det()                     
Time: CPU 14.91 s, Wall: 15.72 s  

sage: p = next_prime(2^64)                 
sage: M = random_matrix(Integers(p), 75*5) 
sage: M2 = matrix(ZZ, M)     
sage: time d = M.det()                     
Time: CPU 18.14 s, Wall: 18.23 s           
sage: time d = M2.det()                    
Time: CPU 14.59 s, Wall: 14.63 s           
```



---

Comment by Bouillaguet created at 2013-01-29 11:49:19

Sounds good. I don't know how to detect the word size inside sage (?). It amazes me that moving from "less than 64 bits" to "more than 64 bits" actually speeds up the process instead of slowing it down in the integer case...

I also checked that the corresponding PARI routine (`Flm_det_sp_OK` in `src/basemath/linalg1.c`) does not require the characteristic of the ring to be prime. The same procedure in PARI deals with determinants in ZZ/6ZZ and ZZ/11ZZ. So, in theory, we could use PARI for all kinds of `IntegerMod(...)`, with a clear benefit when p is small enough to fit in a machine word. I tried to get rid of the prime limitation but failed with an error I did not understand... Jeroen, could you try?

Also, note that the PARI implementation is rather naÃ¯ve : is performs a simple gaussian elimination (no strassen, no fancy stuff). A longer-term objective would be to let FFLAS do this.

Also, another longer-term objective would ben when the modulus is too large, to use the chinese reminder theorem to work only modulo small primes (this can also be done  modulo the integers). But this would require PARI to handle the non-prime cases.


---

Comment by jdemeyer created at 2013-01-29 12:22:03

Replying to [comment:11 Bouillaguet]:
> I also checked that the corresponding PARI routine (`Flm_det_sp_OK` in `src/basemath/linalg1.c`) does not require the characteristic of the ring to be prime. The same procedure in PARI deals with determinants in ZZ/6ZZ and ZZ/11ZZ.
PARI does require that the characteristic is prime, or at least that it won't encounter non-invertible elements:

```
gp> matdet([2,1,0;2,3,0;0,0,1]*Mod(1,4))
  ***   at top-level: matdet([2,1,0;2,3,0;
  ***                 ^--------------------
  *** matdet: impossible inverse modulo: Mod(2, 4).
```


> Another longer-term objective would ben when the modulus is too large, to use the chinese reminder theorem to work only modulo small primes
This is what newer versions of PARI do.


---

Comment by Bouillaguet created at 2013-01-29 13:54:46

Fine. This looks like a serious bug in PARI, because the determinant still exists even though this specific algorithm cannot compute it...

So : modify the patch so that it chooses the threshold to call PARI according to the length of the machine word, and we're good to go.


---

Comment by jdemeyer created at 2013-01-29 13:56:36

Replying to [comment:13 Bouillaguet]:
> This looks like a serious bug in PARI
That's not a bug, it's just something which hasn't been implemented (yet).


---

Comment by jdemeyer created at 2013-01-29 14:19:05

I get different timings, the patch always seems to help.

I used the script

```
def dettest(k):
    print "Testing", k
    for s in [50,75..300]:
        M = random_matrix(k, s)
        print "Size%4i"%s,
        time d = M.det()

dettest(Integers(2432902008176640029))
dettest(Integers(51090942171709440031))
```


Without patch:

```
Testing Ring of integers modulo 2432902008176640029
Size  50 Time: CPU 1.43 s, Wall: 1.43 s
Size  75 Time: CPU 0.28 s, Wall: 0.43 s
Size 100 Time: CPU 0.33 s, Wall: 0.33 s
Size 125 Time: CPU 0.51 s, Wall: 0.51 s
Size 150 Time: CPU 0.88 s, Wall: 0.88 s
Size 175 Time: CPU 1.17 s, Wall: 1.17 s
Size 200 Time: CPU 1.64 s, Wall: 1.64 s
Size 225 Time: CPU 2.19 s, Wall: 2.19 s
Size 250 Time: CPU 2.90 s, Wall: 2.91 s
Size 275 Time: CPU 3.82 s, Wall: 3.83 s
Size 300 Time: CPU 4.50 s, Wall: 4.50 s
Testing Ring of integers modulo 51090942171709440031
Size  50 Time: CPU 1.53 s, Wall: 1.53 s
Size  75 Time: CPU 0.18 s, Wall: 0.18 s
Size 100 Time: CPU 0.34 s, Wall: 0.34 s
Size 125 Time: CPU 0.54 s, Wall: 0.53 s
Size 150 Time: CPU 0.88 s, Wall: 0.88 s
Size 175 Time: CPU 1.28 s, Wall: 1.28 s
Size 200 Time: CPU 1.71 s, Wall: 1.72 s
Size 225 Time: CPU 2.29 s, Wall: 2.33 s
Size 250 Time: CPU 2.99 s, Wall: 3.00 s
Size 275 Time: CPU 3.83 s, Wall: 3.84 s
Size 300 Time: CPU 4.67 s, Wall: 4.67 s
```


With patch:

```
Testing Ring of integers modulo 2432902008176640029
Size  50 Time: CPU 0.09 s, Wall: 0.09 s
Size  75 Time: CPU 0.20 s, Wall: 0.20 s
Size 100 Time: CPU 0.36 s, Wall: 0.36 s
Size 125 Time: CPU 0.58 s, Wall: 0.61 s
Size 150 Time: CPU 0.92 s, Wall: 0.92 s
Size 175 Time: CPU 1.26 s, Wall: 1.26 s
Size 200 Time: CPU 1.64 s, Wall: 1.64 s
Size 225 Time: CPU 2.06 s, Wall: 2.05 s
Size 250 Time: CPU 2.62 s, Wall: 2.62 s
Size 275 Time: CPU 3.19 s, Wall: 3.19 s
Size 300 Time: CPU 3.73 s, Wall: 3.73 s
Testing Ring of integers modulo 51090942171709440031
Size  50 Time: CPU 0.10 s, Wall: 0.10 s
Size  75 Time: CPU 0.32 s, Wall: 0.32 s
Size 100 Time: CPU 0.47 s, Wall: 0.47 s
Size 125 Time: CPU 0.86 s, Wall: 0.86 s
Size 150 Time: CPU 1.29 s, Wall: 1.29 s
Size 175 Time: CPU 1.82 s, Wall: 1.82 s
Size 200 Time: CPU 2.46 s, Wall: 2.46 s
Size 225 Time: CPU 3.34 s, Wall: 3.36 s
Size 250 Time: CPU 4.48 s, Wall: 4.48 s
Size 275 Time: CPU 5.85 s, Wall: 5.85 s
Size 300 Time: CPU 7.71 s, Wall: 7.72 s
```


This seems to suggest that improvements are needed in the integer `determinant()` function.


---

Comment by Bouillaguet created at 2013-01-29 14:31:06

Replying to [comment:15 jdemeyer]:
> I get different timings, the patch always seems to help.

What I understand from your timings is that (apparently) over the larger ring (where the modulus does not fit on 64 bits), things are slower with the patch.

> This seems to suggest that improvements are needed in the integer `determinant()` function.

Agreed, on another ticket?


---

Comment by jdemeyer created at 2013-01-29 14:45:15

Replying to [comment:16 Bouillaguet]:
> Agreed, on another ticket?
#14032 perhaps?


---

Comment by jdemeyer created at 2013-01-30 13:21:57

Changing priority from blocker to critical.


---

Comment by jdemeyer created at 2013-01-30 15:09:54

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2013-01-30 15:09:54

In the end I found a lot of various inefficiencies, so the patch is quite a bit larger than initially.  However, both over `ZZ` and over `GF(p)`, determinants should be faster with this patch.


---

Comment by jdemeyer created at 2013-01-30 15:16:48

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2013-01-30 15:38:56

Changing status from needs_work to needs_review.


---

Comment by nbruin created at 2013-01-30 17:03:40

Echelonization of matrices over the rationals could use some similar love. See #13925.


---

Attachment


---

Comment by Bouillaguet created at 2013-02-01 21:50:15

What is this thing about sage/schemes/elliptic_curves/ell_point.py ? Is it actually supposed to be here ?


---

Comment by jdemeyer created at 2013-02-02 10:36:53

Replying to [comment:25 Bouillaguet]:
> Is it actually supposed to be here ?
Yes.  Because of the changed implementation of the `_pari_()` method of integermods, that exposed #11868.


---

Comment by Bouillaguet created at 2013-02-02 10:43:30

Changing status from needs_review to positive_review.


---

Comment by Bouillaguet created at 2013-02-02 10:43:30

Let's roll


---

Comment by jdemeyer created at 2013-02-05 08:21:12

Resolution: fixed
