# Issue 16957: Minimal bindings for optional arb package; RealIntervalFieldElement.psi

Issue created by migration from Trac.

Original creator: cheuberg

Original creation time: 2014-10-22 06:48:01

CC:  alina fredrik.johansson ktkohl skropf jdemeyer mmezzarobba

Keywords: arb, digamma function, real interval field

In #16747, the optional arb package is proposed for inclusion in sage. That ticket did not have any python bindings for the library.

In the present ticket, rather minimal bindings are provided.

As a proof of concept, the digamma function of a `RealIntervalFieldElement` is implemented by converting it to an `Arb`, computing the digamma function via the arb library, and converting the result back.

In its present minimal form, this is not part of the sage coercion world.


---

Comment by cheuberg created at 2014-10-22 06:48:11

Changing status from new to needs_review.


---

Comment by fredrik.johansson created at 2014-10-22 07:41:51

This probably does not matter as long as the bindings are not part of the sage coercion world, but I suppose then you'd want to handle precision in a similar way to `RealField`, `RealIntervalField` etc. where it is an attribute of the parent (maybe with a `RealBallField` type?).


---

Comment by fredrik.johansson created at 2014-10-22 07:52:05

Sage should arguably have a `RealBallField` and `ComplexBallField` with concrete implementations `RealBallField_arb` and `ComplexBallField_arb` (it would be useful to provide alternative implementations, for example to provide actual circular complex balls).

Anyway, I took a quick look at the code, and it seems fine to me.


---

Comment by cheuberg created at 2014-10-22 08:13:50

The question is how the relation to `RealIntervalField` and `ComplexIntervalField` should be.


---

Comment by git created at 2014-10-25 06:21:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-10-25 08:30:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2014-10-25 08:37:05

As a follow-up, minimal bindings for the `acb` type (complex balls) are provided in #17218.


---

Comment by fredrik.johansson created at 2014-10-28 13:35:25

The code looks ok to me. A small detail is that precision must be >= 2, not just positive (this is required by `RealField` et al too).


---

Comment by git created at 2014-10-28 18:38:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-10-28 18:41:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2014-10-28 19:23:19

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2014-10-28 19:23:19

Please don't use `is_package_installed()`. That's extremely slow, you don't want to call it every time.


---

Comment by jdemeyer created at 2014-10-28 19:26:03

I disagree with
> In its present minimal form, this is not part of the sage coercion world.

You should have a `Parent` from the start, adding it afterwards is only going to make things more difficult.


---

Comment by jdemeyer created at 2014-10-28 19:27:49

And `Arb` should probably be renamed to `RealBallElement`.


---

Comment by cheuberg created at 2014-10-30 15:19:52

Replying to [comment:12 jdemeyer]:
> Please don't use `is_package_installed()`. That's extremely slow, you don't want to call it every time.

What alternative do you recommend? Calling `is_package_installed()` once and storing the result in a module global variable? Or just `try`ing to call the arb code and catching the exception?

Concerning renaming `Arb` to `RealBallElement`: `real_mpfi` aka `RealIntervalFieldElement`  and `arb` have some similarities in their goals; the implementation is different, there might be more functions in the `arb` library, and there are the corresponding functions for complex balls. Do we want to stress the difference between `RealBallElement` and `RealIntervalFieldElement`? Or would `RealBallElement` be some kind of special case of `RealIntervalFieldElement`.

I'll try to implement a parent, but it will take some time. The parent would then be `RealBallField`; what about `RealBallFieldElement` for the current `Arb`?


---

Comment by jdemeyer created at 2014-10-30 16:21:21

Replying to [comment:15 cheuberg]:
> What alternative do you recommend?
Try the import and catch `ImportError`. Would that work?


---

Comment by fredrik.johansson created at 2014-10-30 16:21:47

You could possibly make it so that one can choose between two different implementations of `RealIntervalField` and `ComplexIntervalField`, just like one can choose between:

`PolynomialRing(ZZ, implementation='NTL')`

`PolynomialRing(ZZ, implementation='FLINT')`

So you might look up how those are implemented. I don't have an opinion on whether this is better than what you're doing right now.


---

Comment by jdemeyer created at 2014-10-30 16:26:35

Replying to [comment:15 cheuberg]:
> Do we want to stress the difference between `RealBallElement` and `RealIntervalFieldElement`?
Yes, I would do that. The implementations are also quite different.

> I'll try to implement a parent, but it will take some time. The parent would then be `RealBallField`; what about `RealBallFieldElement` for the current `Arb`?
I slightly prefer the shorter name `RealBallElement` (like `RealDoubleElement`), but I can live with `RealBallFieldElement`.


---

Comment by git created at 2014-10-31 19:17:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2014-10-31 19:18:56

Replying to [comment:16 jdemeyer]:
> Try the import and catch `ImportError`. Would that work?
Yes, it works, thanks.


---

Comment by cheuberg created at 2014-10-31 19:20:57

Replying to [comment:18 jdemeyer]:
> I slightly prefer the shorter name `RealBallElement` (like `RealDoubleElement`), but I can live with `RealBallFieldElement`.

As we apparently do not have a systematic naming scheme here, I renamed it to the shorter `RealBallElement`, as suggested.


---

Comment by git created at 2014-11-21 15:15:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2014-11-21 15:18:56

Changing status from needs_work to needs_review.


---

Comment by cheuberg created at 2014-11-21 15:18:56

Replying to [comment:13 jdemeyer]:
> I disagree with
> > In its present minimal form, this is not part of the sage coercion world.
> 
> You should have a `Parent` from the start, adding it afterwards is only going to make things more difficult.

I have implemented a parent `RealBallField`.


---

Comment by cheuberg created at 2014-11-21 15:21:10

trac's automerge fails for unknown reasons; I have successfully tried to merge this branch with `6.5.beta0`.


---

Comment by fredrik.johansson created at 2014-11-22 18:10:08

The radius could just be printed with 3-5 digits (it is never a high precision number).


---

Comment by fredrik.johansson created at 2014-11-22 18:12:37

In fact, the case could be made for printing in the same format as `RealIntervalField`.


---

Comment by cheuberg created at 2014-11-23 06:41:56

Replying to [comment:27 fredrik.johansson]:
> In fact, the case could be made for printing in the same format as `RealIntervalField`.
[comment:18 jdemeyer] was in favor of making a clear distinction between `RealIntervalField` and `RealBallField`. Therefore, I chose to implement the `_repr_` method of a `RealBallElement` to look different from that of a `RealIntervalFieldElement` and close to the `arb_printd` method.

Of course, doing it the `RealIntervalFieldElement` way would be easy, because conversion to a `RealIntervalFieldElement` is already implemented, so we could simply delegate the task.

Jeroen, do you have a comment on this?


---

Comment by git created at 2014-11-24 15:04:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2014-11-24 15:07:52

The changes in #17267 were incompatible with this ticket. Thus, I merged 6.5.beta1 (containing #17267) and adapted the code.

I used this occasion to change to minor other issues.


---

Comment by git created at 2014-11-24 15:11:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmezzarobba created at 2014-12-16 14:51:32

A few random remarks (I would be interested in working more on this, but unfortunately I don't expect to have time to do it before a few weeks):
* Why call the element class `RealBallElement` and not just `RealBall`? to me the former sounds more like a point _in_ a real ball, not the ball itself...
* Does the parent class really need to be a Cython class?
* I'd rename the `RealIntervalFieldElement` method to something like `interval`, or perhaps `_interval` since in the long run it should be accessible through coercion/conversion to `RealIntervalField` (which is currently broken in several ways, but that's another story).
* I'm not sure if setting up coercion maps from real interval fields is a good idea. It's probably sound from the mathematical point of view, but I seem to remember that bidirectional coercions are at least discouraged, and when computing, say, the sum of an interval and a ball, I'd tend to expect the result to be an interval. Or perhaps this should depend on the precisions of the arguments...?


---

Comment by git created at 2014-12-16 16:03:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-12-16 18:37:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2014-12-16 18:47:12

Replying to [comment:32 mmezzarobba]:
> * Why call the element class `RealBallElement` and not just `RealBall`? to me the former sounds more like a point _in_ a real ball, not the ball itself...

renamed.

> * Does the parent class really need to be a Cython class?

What are the disadvantages if it is a Cython class?

While working on #17222, I found that I spent most of the time in many, many calls of `ComplexIntervalField.__call__`. Therefore, I wanted `RealBallField` to be a Cython class in order to save any bit of performance possible.

> * I'm not sure if setting up coercion maps from real interval fields is a good idea. It's probably sound from the mathematical point of view, but I seem to remember that bidirectional coercions are at least discouraged, and when computing, say, the sum of an interval and a ball, I'd tend to expect the result to be an interval. Or perhaps this should depend on the precisions of the arguments...?

I do not understand your last comment on the precisions of the arguments. 

Apart from that, do you have an opinion on how the output of the balls should look like? See comments [comment:27 27] and [comment:28 28].


---

Comment by cheuberg created at 2015-01-29 18:09:00

Changing status from needs_review to needs_work.


---

Comment by cheuberg created at 2015-01-29 18:09:00

As Arb 2.5 has a function `arb_get_str`, this should be used for the output. So, we should upgrade to 2.5 (#17688).


---

Comment by git created at 2015-02-08 09:13:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2015-02-08 09:19:39

Changing status from needs_work to needs_review.


---

Comment by cheuberg created at 2015-02-08 09:19:39

Replying to [comment:32 mmezzarobba]:
> * I'm not sure if setting up coercion maps from real interval fields is a good idea. It's probably sound from the mathematical point of view, but I seem to remember that bidirectional coercions are at least discouraged, and when computing, say, the sum of an interval and a ball, I'd tend to expect the result to be an interval. Or perhaps this should depend on the precisions of the arguments...?

This coercion is now removed. So we do not coerce from anywhere at the moment. Coercions may be added later as needed.

Furthermore, we use arb's `arb_get_str` method for `_repr_` now.


---

Comment by mmezzarobba created at 2015-02-08 10:14:05

Replying to [comment:35 cheuberg]:
> > * Does the parent class really need to be a Cython class?
> 
> What are the disadvantages if it is a Cython class?

I don't know exactly `:-)`. I think Nicolas Thiéry used to say that sticking to Python for parents when possible was better, perhaps because of the tricks the category framework plays. But if there is a performance reason for using Cython, I'm all for it!

I will try to have a closer look at this ticket in the next few days if I have time... but no guarantees at all!


---

Comment by mmezzarobba created at 2015-02-11 17:14:09

Replying to [comment:39 mmezzarobba]:
> > > * Does the parent class really need to be a Cython class?
> > 
> > What are the disadvantages if it is a Cython class?
> 
>[...] But if there is a performance reason for using Cython, I'm all for it!

In view of the answers to my recent questions on sage-devel (`<mbdlc7$bjo$2`@`ger.gmane.org>` and its thread), I guess we should indeed try moving to a Python class (still compiled by Cython) and see if, for example, just making the element constructor a Cython function suffices to solve your problem. (I can probably do that if you want.)

I have another general design question. In arb, there is no precision attached to a number or a ball, precisions are parameters of arithmetic operations. Hence, to some extent, it would make sense to have a single real ball field with no precision parameter. Except of course that we need at least a default precision for operations like coercion from exact rings and arithmetic on exact balls. (For operations with inexact balls, another, less flexible option would be to choose the default precision based on the input radii.) So I guess the model you have in mind is that the parent provides the precision parameter of arb functions, but otherwise all `RealBallField`s can have elements balls with any radius and any midpoint "precision". Is that correct?

Finally, it is clear that I am not confortable enough with the issues involved to provide a good review by myself. I'd be happy to continue reviewing the ticket nonetheless, but it would be nice if someone more experienced could "review my review". (Jeroen, would you be willing to do that?)


---

Comment by mmezzarobba created at 2015-02-11 19:57:14

Incidentally, with the current (non-`cpdef`, going through `RIF`, etc., so this probably doesn't mean much) `_element_constructor_`, a call to `RBF(42)` even from Cython takes slightly _less_ time with a Python version of the parent class...


---

Comment by mmezzarobba created at 2015-02-11 21:01:13

I made a few changes and pushed them to `u/mmezzarobba/arb`. Please tell me what you think. Jeroen, if you are reading this, your comments are also more than welcome.


---

Comment by git created at 2015-02-12 07:40:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2015-02-12 07:46:20

Replying to [comment:42 mmezzarobba]:
> I made a few changes and pushed them to `u/mmezzarobba/arb`. Please tell me what you think.

I added up two one-line patches and pushed it on the ticket.

From the discussion on sage-devel, I also remember the recommendation to have the parent in a different `.py` file. If I understand the reasoning correctly, this seems to be preferred in order to avoid circular C imports.

Now, the behaviour is that the precision is stored in the Python parent. If we end up needing the precision frequently in arithmetic operations, that might turn out to be a bottleneck.


---

Comment by cheuberg created at 2015-02-12 07:51:45

Replying to [comment:40 mmezzarobba]:
> Replying to [comment:39 mmezzarobba]:
> > > > * Does the parent class really need to be a Cython class?
> > > 
> > > What are the disadvantages if it is a Cython class?
> > 
> >[...] But if there is a performance reason for using Cython, I'm all for it!
> 
> In view of the answers to my recent questions on sage-devel (`<mbdlc7$bjo$2`@`ger.gmane.org>` and its thread), I guess we should indeed try moving to a Python class (still compiled by Cython) and see if, for example, just making the element constructor a Cython function suffices to solve your problem. (I can probably do that if you want.)

Thanks for doing it.

I now believe that my performance problems in #17222 with `ComplexIntervalField` might be caused by the fact that in `ComplexIntervalField`, the `call` function is overridden in Python.

> 
> I have another general design question. In arb, there is no precision attached to a number or a ball, precisions are parameters of arithmetic operations. Hence, to some extent, it would make sense to have a single real ball field with no precision parameter. Except of course that we need at least a default precision for operations like coercion from exact rings and arithmetic on exact balls. (For operations with inexact balls, another, less flexible option would be to choose the default precision based on the input radii.) So I guess the model you have in mind is that the parent provides the precision parameter of arb functions, but otherwise all `RealBallField`s can have elements balls with any radius and any midpoint "precision". Is that correct?

Yes.


---

Comment by mmezzarobba created at 2015-02-12 08:41:01

Replying to [comment:44 cheuberg]:
> From the discussion on sage-devel, I also remember the recommendation to have the parent in a different `.py` file. If I understand the reasoning correctly, this seems to be preferred in order to avoid circular C imports.

And/or to keep the parent interpreted (which has some benefits in terms of debugging, build time...), I guess? But I think we really want a compiled parent in the present case, even if it remains a Python class, so it doesn't matter, does it?

> Now, the behaviour is that the precision is stored in the Python parent. If we end up needing the precision frequently in arithmetic operations, that might turn out to be a bottleneck.

Yes, that was my concern as well. But let's see, and if that's the case, we can always turn the parent back to a Cython class (or possibly keep a copy of the precision in the elements?). I will introduce a function to access the precision of an element so that we can go back to a Cython parent without changing every reference to the precision.


---

Comment by cheuberg created at 2015-02-12 11:03:40

Replying to [comment:46 mmezzarobba]:
> 
> > Now, the behaviour is that the precision is stored in the Python parent. If we end up needing the precision frequently in arithmetic operations, that might turn out to be a bottleneck.
> 
> Yes, that was my concern as well. But let's see, and if that's the case, we can always turn the parent back to a Cython class (or possibly keep a copy of the precision in the elements?).

ok.

> I will introduce a function to access the precision of an element so that we can go back to a Cython parent without changing every reference to the precision.

Thank you.


---

Comment by mmezzarobba created at 2015-02-12 13:19:00

Another question: is there a reason to declare `precision` as unsigned in your code? The precision parameter of arb (and mpfr) functions is signed.


---

Comment by cheuberg created at 2015-02-12 14:53:08

Not really. I cannot imagine what a negative precision should be, but if it is signed in arb and mpfr, then let's be signed too.


---

Comment by fredrik.johansson created at 2015-02-12 17:36:40

Signed integers are used because of the problems mixing signed and unsigned types in C, and precisions above LONG_MAX would not work anyway. In fact there is a limit somewhat smaller than MPFR_PREC_MAX above which things will start breaking. For a sanity check in the parent constructor, something like LONG_MAX / 16 should be fine (this is a bit conservative, but there's currently no macro in arb that gives a firm bound).


---

Comment by mmezzarobba created at 2015-02-12 17:53:27

Replying to [comment:45 cheuberg]:
> > I have another general design question. In arb, there is no precision attached to a number or a ball, precisions are parameters of arithmetic operations. Hence, to some extent, it would make sense to have a single real ball field with no precision parameter. Except of course that we need at least a default precision for operations like coercion from exact rings and arithmetic on exact balls. (For operations with inexact balls, another, less flexible option would be to choose the default precision based on the input radii.) So I guess the model you have in mind is that the parent provides the precision parameter of arb functions, but otherwise all `RealBallField`s can have elements balls with any radius and any midpoint "precision". Is that correct?
> 
> Yes.

Ok, thanks. And do you think operations on balls should take a precision argument (defaulting to the parent's precision)? Or is the ability to change the parent enough?

In other words, assuming `b` is a `RealBall` resulting from a 100-bit operation, and thus living in `RBF(100)`, which commands among the following do you think should work to compute the exponential of `b` with 53 bits of precision:
* `RealBallField(53)(b).exp()` (yes by the discussion I am quoting, I guess),
* `b.change_prec(53).exp()` (a possible shortcut for the above),
* `b.exp(prec=53)` (that's my question)?
(All three would yield a result in `RBF(53)`.)

Depending on that, I wonder if we shouldn't revert the commit where I changed "precision" to "default precision" in the messages.


---

Comment by fredrik.johansson created at 2015-02-12 18:01:15

I think precision should be handled identically for all versions of real and complex fields (from Sage's point of view, it doesn't really matter whether the precision is part of the underlying C structures).


---

Comment by cheuberg created at 2015-02-13 07:15:05

Replying to [comment:51 mmezzarobba]:
> Replying to [comment:45 cheuberg]:
> > > I have another general design question. In arb, there is no precision attached to a number or a ball, precisions are parameters of arithmetic operations. Hence, to some extent, it would make sense to have a single real ball field with no precision parameter. Except of course that we need at least a default precision for operations like coercion from exact rings and arithmetic on exact balls. (For operations with inexact balls, another, less flexible option would be to choose the default precision based on the input radii.) So I guess the model you have in mind is that the parent provides the precision parameter of arb functions, but otherwise all `RealBallField`s can have elements balls with any radius and any midpoint "precision". Is that correct?
> > 
> > Yes.
> 
> Ok, thanks. And do you think operations on balls should take a precision argument (defaulting to the parent's precision)? Or is the ability to change the parent enough?

IMHO, changing the parent is enough.

> 
> In other words, assuming `b` is a `RealBall` resulting from a 100-bit operation, and thus living in `RBF(100)`, which commands among the following do you think should work to compute the exponential of `b` with 53 bits of precision:
> * `RealBallField(53)(b).exp()` (yes by the discussion I am quoting, I guess),

yes, but not yet implemented.

I think that `RealBallField(53)(b)` would not actually _change_ anything in `b` except for changing the parent.

> * `b.change_prec(53).exp()` (a possible shortcut for the above),

I do not think that this is needed: we'd have to find the correct parent, after all.

> * `b.exp(prec=53)` (that's my question)?

I do not think that this is necessary.

> (All three would yield a result in `RBF(53)`.)
> 
> Depending on that, I wonder if we shouldn't revert the commit where I changed "precision" to "default precision" in the messages.

The [Arb documentation](http://fredrikj.net/arb/arb.html) says "The precision parameter [...] roughly indicates the precision to which calculations on the midpoint are carried out".

Later on, it is also mentioned that "For more complex operations, the precision parameter indicates a minimum working precision".

So "default precision" is not really correct, because the user is not allowed to change the default precision. So perhaps "working precision" would be more correct, or simply "precision".


---

Comment by cheuberg created at 2015-02-13 07:16:05

Replying to [comment:52 fredrik.johansson]:
> I think precision should be handled identically for all versions of real and complex fields (from Sage's point of view, it doesn't really matter whether the precision is part of the underlying C structures).

IMHO, that is a valid point.


---

Comment by mmezzarobba created at 2015-02-14 21:42:28

Replying to [comment:54 cheuberg]:
> Replying to [comment:52 fredrik.johansson]:
> > I think precision should be handled identically for all versions of real and complex fields (from Sage's point of view, it doesn't really matter whether the precision is part of the underlying C structures).
> 
> IMHO, that is a valid point.

Ok, I think we all agree. Thanks for your input!

So I made a few more changes as promised. As far as I am concerned I'd be happy to set the ticket to positive review, but (i) at the very least someone should review my commits, and (ii) it would be great if someone with more experience on writing (efficient) parent could check that we are not doing anything that will prove awfully wrong later on.

And (as a way to reassure myself regarding this last point `;-)`) I started implementing some basic arithmetic (edit: and more...) on `RealBall`s. See `u/mmezzarobba/arb`. But that's for another ticket, unless you feel like reviewing the first few commits here.
----
New commits:


---

Comment by mmezzarobba created at 2015-02-15 13:44:48

Follow-up: #17786.


---

Comment by cheuberg created at 2015-02-16 07:13:51

Replying to [comment:56 mmezzarobba]:
> Follow-up: #11786.
The follow-up is actually #17786.

I'd propose to move `is_zero` and `is_nonzero` from #17786 to this ticket in order to avoid a change of behaviour later on. Similarly, I think that rich comparison and equality checking should be implemented here.


---

Comment by mmezzarobba created at 2015-02-16 07:26:45

Replying to [comment:57 cheuberg]:
> The follow-up is actually #17786.

Oops, thanks. I will edit my other post to avoid any confusion.

> I'd propose to move `is_zero` and `is_nonzero` from #17786 to this ticket in order to avoid a change of behaviour later on. Similarly, I think that rich comparison and equality checking should be implemented here.

Fine with me. Feel free to do it if you want, I will again be a bit busy in the next days.


---

Comment by git created at 2015-02-16 08:08:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2015-02-16 08:14:49

Replying to [comment:55 mmezzarobba]:
> So I made a few more changes as promised.
Thank you.

> As far as I am concerned I'd be happy to set the ticket to positive review, but (i) at the very least someone should review my commits,

I cross-reviewed your commits, they look good to me, doctests pass. For a test, I included `real_arb` into the documentation, documentation built fine.

Furthermore, I removed `fmpr.pxd` because it is no longer needed and deprecated in arb.

I'll take care of `is_zero`, `is_nonzero`, `__richcmp__`.


---

Comment by cheuberg created at 2015-02-16 08:14:49

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-02-16 11:25:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2015-02-16 11:30:52

The semantics of `!=` differ from those of real intervals: A ball is considered non-zero if it does not contain `0`.

So, `!=` is not `not ==`.

I prefer this for two reasons:

- We are wrapping `arb` here, and `arb` has this convention (`is_nonzero`).
- `__richcmp__` allows independent implementations for `==` and `!=`; I take this as a hint.

Furthermore, the semantics of `==` are different from real intervals: If `a is b`, then `a==b`, independently of whether they are exact or not. Otherwise, `a==b` can only hold if `a` and `b` are exact.


---

Comment by cheuberg created at 2015-02-16 11:31:17

Changing status from needs_work to needs_review.


---

Comment by mmezzarobba created at 2015-02-16 15:35:17

Replying to [comment:63 cheuberg]:
> The semantics of `!=` differ from those of real intervals: A ball is considered non-zero if it does not contain `0`.
> 
> So, `!=` is not `not ==`.

Hmm, if I read correctly, that's also how comparisons of `RealIntervalFieldElement`s work. Can you please be more specific about the difference you're seeing? For me the only difference is that, in the case of `RealIntervalFieldElement`s, `__nonzero__` is not consistent with `!= 0`.

> I prefer this for two reasons:
> 
> - We are wrapping `arb` here, and `arb` has this convention (`is_nonzero`).

(I don't understand what you mean here, but I don't think it matters.)

> - `__richcmp__` allows independent implementations for `==` and `!=`; I take this as a hint.

Yes, I agree. Unfortunately, this convention (having `True` mean true and `False` mean false or don't know, basically) is not observed consistently in sage. Besides, I am very unconfortable with comparisons in sage in general, mostly due to the fact that they try to apply coercions, which leads to all sorts of problems when different parents use different semantics... So I guess I'd be in favor of having methods that _duplicate_ the behavior of comparisons but only work for balls, in order not to risk mixing balls with other object types by mistake!

> Furthermore, the semantics of `==` are different from real intervals: If `a is b`, then `a==b`, independently of whether they are exact or not.

I don't know what to think about that. That's consistent with the semantics of arb functions, and up to now I have sticked to the convention in the bindings I wrote. But I fear this will lead to unexpected behaviors and inconsistencies wrt the rest of sage, and I really believe we should think it through more carefully before committing to the arb semantics.


---

Comment by cheuberg created at 2015-02-16 16:57:02

Replying to [comment:65 mmezzarobba]:
> Replying to [comment:63 cheuberg]:
> > The semantics of `!=` differ from those of real intervals: A ball is considered non-zero if it does not contain `0`.
> > 
> > So, `!=` is not `not ==`.
> 
> Hmm, if I read correctly, that's also how comparisons of `RealIntervalFieldElement`s work. Can you please be more specific about the difference you're seeing? For me the only difference is that, in the case of `RealIntervalFieldElement`s, `__nonzero__` is not consistent with `!= 0`.


I hope that the following examples make my impression of the current behaviour clear.


```
sage: a = RIF(-1, 1)
sage: from sage.rings.real_arb import RealBallField
sage: RBF = RealBallField()
sage: b = RBF(a)
sage: a.__nonzero__()
True
sage: b.__nonzero__()
False
sage: bool(a)
True
sage: bool(b)
False
sage: a == 0
False
sage: b == 0
False
sage: a != 0
False
sage: b != 0
False
```


> > - `__richcmp__` allows independent implementations for `==` and `!=`; I take this as a hint.
> 
> Yes, I agree. Unfortunately, this convention (having `True` mean true and `False` mean false or don't know, basically) is not observed consistently in sage. Besides, I am very unconfortable with comparisons in sage in general, mostly due to the fact that they try to apply coercions, which leads to all sorts of problems when different parents use different semantics... So I guess I'd be in favor of having methods that _duplicate_ the behavior of comparisons but only work for balls, in order not to risk mixing balls with other object types by mistake!

In commit 5e41fcb, prior to my implementation of comparison, I obtain

```
sage: b < RIF(-3)
True
```

on my system because, sadly, sage reverts to comparing types if it cannot compare elements.

So if I understand you correctly, you'd be in favor of having methods `RealBall.lt` and leave the original methods untouched? I fear that a user may then mistakenly use the above example and get "surprising" results.

Perhaps we could overwrite `__richcmp__` in such a way that, if no coercions to balls are available, a `NotImplementedError` is raised?

> > Furthermore, the semantics of `==` are different from real intervals: If `a is b`, then `a==b`, independently of whether they are exact or not.
> 
> I don't know what to think about that. That's consistent with the semantics of arb functions, and up to now I have sticked to the convention in the bindings I wrote. But I fear this will lead to unexpected behaviors and inconsistencies wrt the rest of sage, and I really believe we should think it through more carefully before committing to the arb semantics.

I do not understand what you mean. In my understanding, having the implication that identical objects are mathematically equal, should not lead to unexpected behavior within the rest of sage. 

For me, the behavior of `RealIntervalFieldElement`

```
sage: a = RIF(-1, 1)
sage: from sage.rings.real_arb import RealBallField
sage: RBF = RealBallField()
sage: b = RBF(a)
sage: a == a
False
sage: b == b
True
```

is _very_ unexpected. After all, equality is usually assumed to be reflexive.


---

Comment by mmezzarobba created at 2015-02-18 15:02:53

Replying to [comment:66 cheuberg]:
> Replying to [comment:65 mmezzarobba]:
> > Replying to [comment:63 cheuberg]:
> > > The semantics of `!=` differ from those of real intervals: A ball is considered non-zero if it does not contain `0`.
> > > 
> > > So, `!=` is not `not ==`.
> > 
> > Hmm, if I read correctly, that's also how comparisons of `RealIntervalFieldElement`s work. Can you please be more specific about the difference you're seeing? For me the only difference is that, in the case of `RealIntervalFieldElement`s, `__nonzero__` is not consistent with `!= 0`.
> 
> 
> I hope that the following examples make my impression of the current behaviour clear.
> 
> {{{
> sage: a = RIF(-1, 1)
> sage: from sage.rings.real_arb import RealBallField
> sage: RBF = RealBallField()
> sage: b = RBF(a)
> sage: a.__nonzero__()
> True
> sage: b.__nonzero__()
> False
> sage: bool(a)
> True
> sage: bool(b)
> False
> sage: a == 0
> False
> sage: b == 0
> False
> sage: a != 0
> False
> sage: b != 0
> False
> }}}

So I think we agree: `==` and `!=` behave the same way for intervals and balls (with your implementation), except for the case of `x == y` when `x is y`. However, `__nonzero__` behaves differently. (And, to be clear: I believe that your choice is the more sensible one, but I don't like the inconsistency.) Is that correct?

> So if I understand you correctly, you'd be in favor of having methods `RealBall.lt` and leave the original methods untouched? I fear that a user may then mistakenly use the above example and get "surprising" results.

No, I guess I wasn't clear, sorry. Imho the fact that comparisons of sage objects (or at least of sage Elements) can fall back to comparing types at all is dreadful. I was saying (as an aside, not as a remark on your code) that I would be tempted to implement safer comparison methods in addition to your implementation of Python comparisons (and with the same semantics in the case where we compare balls to balls) because Sage comparisons are dangerous in general.

> Perhaps we could overwrite `__richcmp__` in such a way that, if no coercions to balls are available, a `NotImplementedError` is raised?

I don't know if it is possible, and I doubt it is a good idea to circumvent the coercion system even if it can lead to problems.

> I do not understand what you mean. In my understanding, having the implication that identical objects are mathematically equal, should not lead to unexpected behavior within the rest of sage. 

Forget it, I think I convinced myself that it was ok—as long as a ball is understood as representing a single real number, of course. (And never as a subset of the real line whose image by a given function needs to be bounded, say.)

> For me, the behavior of `RealIntervalFieldElement`
> {{{
> sage: a = RIF(-1, 1)
> sage: from sage.rings.real_arb import RealBallField
> sage: RBF = RealBallField()
> sage: b = RBF(a)
> sage: a == a
> False
> sage: b == b
> True
> }}}
> is _very_ unexpected.

I wouldn't say that: after all, it does not hold true that for all x, y in [-1,1], x=y...

> After all, equality is usually assumed to be reflexive.

Yes, but that argument would be (almost) equally valid in the case of `RBF(foo) == RBF(foo)`, and I don't think we want that to hold if `RBF(foo)` is not a point ball!

(I will be offline for a few days. If anyone would like to take over the review, please feel free.)


---

Comment by cheuberg created at 2015-02-19 07:16:17

Replying to [comment:67 mmezzarobba]:
> So I think we agree: `==` and `!=` behave the same way for intervals and balls (with your implementation), except for the case of `x == y` when `x is y`. However, `__nonzero__` behaves differently. (And, to be clear: I believe that your choice is the more sensible one, but I don't like the inconsistency.) Is that correct?

This is correct.


---

Comment by cheuberg created at 2015-02-19 07:18:32

(Replying in several chunks due to trac timeouts when I try to reply in one go, sorry).

Replying to [comment:67 mmezzarobba]:
> No, I guess I wasn't clear, sorry. Imho the fact that comparisons of sage objects (or at least of sage Elements) can fall back to comparing types at all is dreadful.

I agree.

> I was saying (as an aside, not as a remark on your code) that I would be tempted to implement safer comparison methods in addition to your implementation of Python comparisons (and with the same semantics in the case where we compare balls to balls) because Sage comparisons are dangerous in general.

We can always do that later because it would not change behaviour.


> > Perhaps we could overwrite `__richcmp__` in such a way that, if no coercions to balls are available, a `NotImplementedError` is raised?
> 
> I don't know if it is possible, and I doubt it is a good idea to circumvent the coercion system even if it can lead to problems.

So let's forget this idea.


---

Comment by cheuberg created at 2015-02-19 07:21:30

Replying to [comment:67 mmezzarobba]:
> > I do not understand what you mean. In my understanding, having the implication that identical objects are mathematically equal, should not lead to unexpected behavior within the rest of sage. 
> 
> Forget it, I think I convinced myself that it was ok—as long as a ball is understood as representing a single real number, of course. (And never as a subset of the real line whose image by a given function needs to be bounded, say.)

I do not understand your point. If `M` is a subset of the real line (represented by a ball) and `f` is a function, I still believe that `f(M)` can be computed by `RealBall`.

> I wouldn't say that: after all, it does not hold true that for all x, y in [-1,1], x=y...
> 
> > After all, equality is usually assumed to be reflexive.
> 
> Yes, but that argument would be (almost) equally valid in the case of `RBF(foo) == RBF(foo)`, and I don't think we want that to hold if `RBF(foo)` is not a point ball!

No, I do not want that.

For reference, I quote here from the [Arb manual](http://fredrikj.net/arb/issues.html):

"Identical pointers are understood to give permission for algebraic simplification. This assumption is made to improve performance. For example, the call `arb_mul(z, x, x, prec)` sets `z` to a ball enclosing the set `{t^2 : t ∈ x}` and not the (generally larger) set `{tu : t ∈ x, u ∈ x}`."


---

Comment by mmezzarobba created at 2015-02-19 07:46:27

Replying to [comment:69 cheuberg]:
> > I was saying (as an aside, not as a remark on your code) that I would be tempted to implement safer comparison methods in addition to your implementation of Python comparisons (and with the same semantics in the case where we compare balls to balls) because Sage comparisons are dangerous in general.
> 
> We can always do that later because it would not change behaviour.

Yes.


---

Comment by mmezzarobba created at 2015-02-19 09:50:02

Changing status from needs_review to positive_review.


---

Comment by mmezzarobba created at 2015-02-19 09:50:02

So despite what I said about being offline for a few days, I could have a look at your last changes before disappearing.

Replying to [comment:70 cheuberg]:
> > Forget it, I think I convinced myself that it was ok—as long as a ball is understood as representing a single real number, of course. (And never as a subset of the real line whose image by a given function needs to be bounded, say.)
> 
> I do not understand your point. If `M` is a subset of the real line (represented by a ball) and `f` is a function, I still believe that `f(M)` can be computed by `RealBall`.

Ok, that was very badly expressed once again. Sorry about that, I'm trying to do too many things at once `:-(`. 

All I was trying to say essentially is that if your think of balls as ranges, not approximate reals, then code like

```
def f(x, y): return x-y
def range(f, *args): return f(*args)
unit_ball = RBF(0, rad=1)
range(f, unit_ball, unit_ball)
```

looks correct, while it violates the rule about aliasing in arb that you quoted. I guess one could come up with more subtle examples with `cached_function`s or additional layers of abstraction.

A few more quick comments:
* I think we will need `fmpr` again later on to implement `rad()`;
* `_an_element_` can be inherited, but perhaps this requires some of the coercion & category stuff I implemented on the other ticket, I don't remember;
(so several of your last changes will probably be reverted in the follow-up ticket)
* we should add a note about aliasing similar to that which you quoted to the python package's documentation too;
* `arb_to_mpfi` will probably crash sage if the ball's endpoints are not representable within the exponent range of MPFR FP numbers (but it is close to impossible to construct such balls at this point), use `sig_on()` or `sig_str()` (without `_do_sig`) to prevent that;
* I personally find `return (lst is rt) or (arb_is_exact(...) and ... and ...)` more readable than your implementation of equality, but that's a matter of taste.

None of the above is really urgent or important and the current state of the code looks good to me, so I'm setting the ticket to positive review to avoid delaying it too much. But please feel free to make changes here if you want, and then I'll try to review them when I come back.


---

Comment by cheuberg created at 2015-02-19 10:15:14

Replying to [comment:72 mmezzarobba]:
> So despite what I said about being offline for a few days, I could have a look at your last changes before disappearing.

Thank you.

> * we should add a note about aliasing similar to that which you quoted to the python package's documentation too;
> * `arb_to_mpfi` will probably crash sage if the ball's endpoints are not representable within the exponent range of MPFR FP numbers (but it is close to impossible to construct such balls at this point), use `sig_on()` or `sig_str()` (without `_do_sig`) to prevent that;
> * I personally find `return (lst is rt) or (arb_is_exact(...) and ... and ...)` more readable than your implementation of equality, but that's a matter of taste.
> 
> None of the above is really urgent or important and the current state of the code looks good to me, so I'm setting the ticket to positive review to avoid delaying it too much. But please feel free to make changes here if you want, and then I'll try to review them when I come back.

While I think that your points above are valid, I do not want to make changes here any more.
I'll try to do that in a separate ticket. Moreover, I plan to adapt the `ComplexBalls` (#17218) to the structure implemented here.


---

Comment by fredrik.johansson created at 2015-02-19 10:15:47

Replying to [comment:72 mmezzarobba]:
> A few more quick comments:
> * I think we will need `fmpr` again later on to implement `rad()`;

Anything `fmpr` can be done with `arf` module.

> * `arb_to_mpfi` will probably crash sage if the ball's endpoints are not representable within the exponent range of MPFR FP numbers (but it is close to impossible to construct such balls at this point), use `sig_on()` or `sig_str()` (without `_do_sig`) to prevent that;

Yes, unfortunately I haven't added any code yet to underflow or overflow gracefully when converting to MPFR. When developing, I deliberately wanted this to crash rather than fail silently.

I should probably fix `arb_get_interval_mpfr` to set the endpoint to `+/- 2^MPFR_MIN_EXP` on underflow and `+/- inf` on overflow.

Rather than changing `arf_get_mpfr`, I might add a separate `arf_get_mpfr_overflow` that behaves as if you had computed an out-of-range value within MPFR (setting MPFR overflow flags and so on).


---

Comment by mmezzarobba created at 2015-02-19 10:22:18

Replying to [comment:73 cheuberg]:
> While I think that your points above are valid, I do not want to make changes here any more.
> I'll try to do that in a separate ticket. Moreover, I plan to adapt the `ComplexBalls` (#17218) to the structure implemented here.

Great, thanks for your work on these bindings! I'll do what I can to help.


---

Comment by mmezzarobba created at 2015-02-19 10:26:24

Replying to [comment:74 fredrik.johansson]:
> Replying to [comment:72 mmezzarobba]:
> > A few more quick comments:
> > * I think we will need `fmpr` again later on to implement `rad()`;
> 
> Anything `fmpr` can be done with `arf` module.

What should we do to convert a `mag_t` to an `mpfr_t`? Using `mag_get_fmpr`looked like the simplest method.


---

Comment by fredrik.johansson created at 2015-02-19 10:29:08

Replying to [comment:76 mmezzarobba]:
> Replying to [comment:74 fredrik.johansson]:
> > Replying to [comment:72 mmezzarobba]:
> > > A few more quick comments:
> > > * I think we will need `fmpr` again later on to implement `rad()`;
> > 
> > Anything `fmpr` can be done with `arf` module.
> 
> What should we do to convert a `mag_t` to an `mpfr_t`? Using `mag_get_fmpr`looked like the simplest method.

`arf_set_mag`, so-called because the `arf` module depends on the `mag` module and not vice versa.


---

Comment by mmezzarobba created at 2015-02-19 10:30:59

Replying to [comment:77 fredrik.johansson]:
> `arf_set_mag`, so-called because the `arf` module depends on the `mag` module and not vice versa.

Ok, I missed that function, thanks!


---

Comment by mmezzarobba created at 2015-02-19 10:33:03

Another question that we may want to think about is whether and how to expose exact (by which I mean `ARF_PREC_EXACT`) operations. They would be useful to me, but perhaps being able to use them directly from cython is enough.


---

Comment by fredrik.johansson created at 2015-02-19 10:46:23

`ARF_PREC_EXACT` is something of a hack, and not really safe in general. If your numbers are too large, you get undefined behavior.


---

Comment by cheuberg created at 2015-02-19 16:52:21

Replying to [comment:72 mmezzarobba]:
> * we should add a note about aliasing similar to that which you quoted to the python package's documentation too;

This is now #17809.

> * `arb_to_mpfi` will probably crash sage if the ball's endpoints are not representable within the exponent range of MPFR FP numbers (but it is close to impossible to construct such balls at this point), use `sig_on()` or `sig_str()` (without `_do_sig`) to prevent that;

It was hard to provoke this with available functions, but it did crash sage. This is now #17811.

> * I personally find `return (lst is rt) or (arb_is_exact(...) and ... and ...)` more readable than your implementation of equality, but that's a matter of taste.

This is #17810.


---

Comment by vbraun created at 2015-02-21 12:40:39

Resolution: fixed
