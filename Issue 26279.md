# Issue 26279: Wrong sig_on_count in libgap

Issue created by migration from Trac.

Original creator: SimonKing

Original creation time: 2018-10-21 09:09:25

Keywords: libgap sig_on_count

When running doctests in my applications of libgap, sig_on_count reveals problems.

Indeed, in `src/sage/libs/gap/*`, one often sees constructions like the following:

```python
        try:
            sig_on()
            result = libGAP_EQ(self.value, c_other.value)
            sig_off()
        except RuntimeError as msg:
            raise ValueError('libGAP: cannot compare equality: '+str(msg))
        finally:
            libgap_exit()
...
        try:
            libgap_enter()
            sig_on()
            result = libGAP_SUM(self.value, (<GapElement>right).value)
            sig_off()
        except RuntimeError as msg:
            libGAP_ClearError()
            raise ValueError('libGAP: '+str(msg))
        finally:
            libgap_exit()
...
```

So, sig_off() is only called when no error is raised. But in my applications, I am in fact catching errors raised by libgap. So, maybe it is no surprise that the sig_on/sig_off count got wrong.

Proposed fix: move the sig_off() call to the "finally" clause, directly before libgap_exit()


---

Comment by jdemeyer created at 2018-10-21 09:36:21

Replying to [ticket:26516 SimonKing]:
> Proposed fix: move the sig_off() call to the "finally" clause, directly before libgap_exit()

No, that `finally` is meant for `libgap_exit`. So you need a nested `try`/`finally`:

```
try:
    sig_on()
    try:
        ...
    finally:
        sig_off
finally:
    libgap_exit()
```

or something like that.


---

Comment by jdemeyer created at 2018-10-21 09:38:32

Replying to [ticket:26516 SimonKing]:
> But in my applications, I am in fact catching errors raised by libgap.

Can you elaborate on what you mean with that? As far as I know, libgap is a C library, so how could it raise Python exceptions?


---

Comment by SimonKing created at 2018-10-21 09:48:39

Replying to [comment:3 jdemeyer]:
> Replying to [ticket:26516 SimonKing]:
> > But in my applications, I am in fact catching errors raised by libgap.
> 
> Can you elaborate on what you mean with that? As far as I know, libgap is a C library, so how could it raise Python exceptions?

Right. I use "libgap" synonymous to SageMath's libgap wrapper.

Anyway, I am doing things like this:

```
    try:
        G = G.MinimalGeneratingSet().Group()
    except (RuntimeError, ValueError):
        G = G.SmallGeneratingSet().Group()
```

For some of my groups, the attempt to compute a minimal generating set fails, and if I understand correctly, the libgap wrapper would call sig_on(), then kindly ask libgap to compute the minimal generating set, and when this fails would not call sig_off() before raising a Python error.

EDIT: I tested and found that _this_ is not giving a sig_on_count() failure. But I am now going through the actual tests of my applications and will hopefully be able to create a minimal example.


---

Comment by jdemeyer created at 2018-10-21 10:43:26

Replying to [comment:4 SimonKing]:
> if I understand correctly, the libgap wrapper would call sig_on(), then kindly ask libgap to compute the minimal generating set, and when this fails would not call sig_off() before raising a Python error.

No, the code that you posted in this ticket is correct in that sense. Libgap error handling in Sage uses `sig_error()` (see `error_handler` in `src/sage/libs/gap/util.pyx`). For that, there must _not_ be a `sig_off()` call.

> But I am now going through the actual tests of my applications and will hopefully be able to create a minimal example.

Please do.


---

Comment by SimonKing created at 2018-10-21 10:57:49

Replying to [comment:5 jdemeyer]:
> Replying to [comment:4 SimonKing]:
> > if I understand correctly, the libgap wrapper would call sig_on(), then kindly ask libgap to compute the minimal generating set, and when this fails would not call sig_off() before raising a Python error.
> 
> No, the code that you posted in this ticket is correct in that sense. Libgap error handling in Sage uses `sig_error()` (see `error_handler` in `src/sage/libs/gap/util.pyx`). For that, there must _not_ be a `sig_off()` call.

I see. In that case, my original assessment was very likely wrong. I have moved my cohomology programs from using gap-via-pexpect to using gap-via-libgap, and so it seemed very likely to me that the problem came from that move, even more so when it seemed to me that sig_off() was forgotten in basically all try-except-finally clauses in sage/libs/gap/*.

Currently, my smallest example triggering sig_on_count to complain is an example in which another library results in an error in an example that previously worked. So, very likely the wrong sig_on/off count comes from there, not from libgap.


---

Comment by SimonKing created at 2018-10-21 11:34:19

Replying to [comment:6 SimonKing]:
> Currently, my smallest example triggering sig_on_count to complain is an example in which another library results in an error in an example that previously worked. So, very likely the wrong sig_on/off count comes from there, not from libgap.

Actually it seems that the problem rather lies in the SharedMeatAxe wrapper, not in the libgap wrapper. Namely, when wrapped libmtx functions are called, they are encapsulated into sig_on/sig_off, but the wrapper also translates propagated C errors into Python errors. So, presumable when such error is raised, sig_off ought to be called.

Question on the way to proceed:
- Change the topic of this ticket from libgap wrapper to libmtx wrapper?
- Resolve this ticket as "invalid/won't fix" and open a new ticket addressing the libmtx wrapper?


---

Comment by SimonKing created at 2018-10-21 13:27:02

Technical question about sig_on/sig_off, sig_check, and sig_error.

Assume that in the error handler of the libmtx wrapper I call sig_error, similar to what is done in the case of libgap. Would it be needed to henceforth only use sig_on/sig_off, but not sig_check? Namely, when calling sig_error, it is required that sig_on has been called before.

And if that's really the case, then maybe it would be good to know about the use cases of the different sig_* functions. So far, I thought it is like this:
- Use sig_on/sig_off arount a library call that potentially takes a long time.
- Use sig_check when there is a tight loop involving library calls, as that's faster than sig_on/sig_off.
- I didn't know at all about sig_error.

So, is it really the case that I have to accept the slow-down that comes from being forced to use sig_on/off instead of sig_check?

In any case, I realised that I need to go through matrix_gfpn_dense, as there are many library calls that are in fact not wrapped into sig_on/off pairs.


---

Comment by jdemeyer created at 2018-10-21 16:05:59

Replying to [comment:8 SimonKing]:
> Technical question about sig_on/sig_off, sig_check, and sig_error.
> 
> Assume that in the error handler of the libmtx wrapper I call sig_error, similar to what is done in the case of libgap. Would it be needed to henceforth only use sig_on/sig_off, but not sig_check? Namely, when calling sig_error, it is required that sig_on has been called before.

Absolutely.

> And if that's really the case, then maybe it would be good to know about the use cases of the different sig_* functions. So far, I thought it is like this:
> - Use sig_on/sig_off arount a library call that potentially takes a long time.
> - Use sig_check when there is a tight loop involving library calls, as that's faster than sig_on/sig_off.

That's more or less correct.

> - I didn't know at all about sig_error.

`sig_error` is quite specialized to handle errors from a C library in a callback. But for SharedMeatAxe, this doesn't seem to be needed since it has a way to deal with errors already.

Conclusion: the best solution is probably to wrap errors from SharedMeatAxe as

```
sig_on()
try:
    # MeatAxe call which might raise a Python exception
finally:
    sig_off()
```



---

Comment by jdemeyer created at 2018-10-21 16:07:42

Replying to [comment:8 SimonKing]:
> - Use sig_check when there is a tight loop involving library calls, as that's faster than sig_on/sig_off.

Actually, a more important reason is not so much that it's faster but safer too. `sig_on()`/`sig_off()` is really "use this only when you really know what you are doing" while `sig_check()` is pretty foolproof.


---

Comment by SimonKing created at 2018-10-21 16:56:16

I suppose changing title and description means I should use *this* ticket to fix the libmtx wrapper, rather than create a new ticket.

Replying to [comment:9 jdemeyer]:
> `sig_error` is quite specialized to handle errors from a C library in a callback. But for SharedMeatAxe, this doesn't seem to be needed since it has a way to deal with errors already.

In SharedMeatAxe, in contrast to MeatAxe, I am consequently propagating error values, so that a program calling a library function can take proper action when an error occurs. MeatAxe does make it possible to have a custom error handler, which I am using here of course.

Maybe I am misunderstanding the role of sig_*. Namely, the library functions have an error return value, and Cython knows about it (it is declared in the .pxd files). So, a Python error is raised regardless whether sig_on/sig_off is involved or not.

Is it correct that the only added bonus of using sig_on/sig_off is that the user can interrupt with ctrl-c?


---

Comment by jdemeyer created at 2018-10-21 17:10:21

Replying to [comment:11 SimonKing]:
> Is it correct that the only added bonus of using sig_on/sig_off is that the user can interrupt with ctrl-c?

Yes.


---

Comment by SimonKing created at 2018-10-21 17:12:57

Replying to [comment:12 jdemeyer]:
> Replying to [comment:11 SimonKing]:
> > Is it correct that the only added bonus of using sig_on/sig_off is that the user can interrupt with ctrl-c?
> 
> Yes.

OK, in that case I should use

```
sig_on()
try:
    <library call>
finally:
    sig_off()
```

only for functions that potentially run long enough so that it makes sense for them being interruptible.


---

Comment by SimonKing created at 2018-10-21 17:28:47

Is it ok if Python stuff happens between sig_on and sig_off, such as

```python
        try:
            mat = MatAlloc(self.Data.Field, self._nrows, right._ncols)
            MatMulStrassen(mat, self.Data, right.Data)
            return new_mtx(mat, self)
        finally:
            sig_off()
```

?

Or should, in particular, return statements happen _after_ the `finally: sig_off()'?


---

Comment by jdemeyer created at 2018-10-21 18:29:22

Replying to [comment:14 SimonKing]:
> Is it ok if Python stuff happens between sig_on and sig_off

You should try hard to avoid that as it's unsafe.

> Or should, in particular, return statements happen _after_ the `finally: sig_off()'?

There is nothing in particular about `return` statements. There just shouldn't be any kind of Python object manipulation (especially no creation of new Python objects).


---

Comment by SimonKing created at 2018-10-21 19:07:21

Replying to [comment:15 jdemeyer]:
> Replying to [comment:14 SimonKing]:
> > Is it ok if Python stuff happens between sig_on and sig_off
> 
> You should try hard to avoid that as it's unsafe.
> 
> > Or should, in particular, return statements happen _after_ the `finally: sig_off()'?
> 
> There is nothing in particular about `return` statements. There just shouldn't be any kind of Python object manipulation (especially no creation of new Python objects).

Good, then I guess the following is bad, as `new_mtx` creates a python object (namely: a !Matrix_gfpn_dense):

```python
        sig_on()
        try:
            mat = MatAlloc(self.Data.Field, self.Data.Nor+other.Data.Nor, self.Data.Noc)
            memcpy(mat.Data, self.Data.Data, FfCurrentRowSize*self.Data.Nor)
            memcpy(MatGetPtr(mat, self.Data.Nor), other.Data.Data, FfCurrentRowSize*other.Data.Nor)
            return new_mtx(mat, self)
        finally:
            sig_off()
```



---

Comment by SimonKing created at 2018-10-21 21:06:06

Changing status from new to needs_review.


---

Comment by SimonKing created at 2018-10-21 21:06:06

I am sorry that I cannot provide a new test, but I think the code is a bit safer now.
----
New commits:


---

Comment by jdemeyer created at 2018-10-24 09:34:47

I assume that you actually tested this? No patchbot with meataxe has tested this so far.


---

Comment by jdemeyer created at 2018-10-24 09:45:53

It would be safer to do `self._converter.field_to_int` calls outside of `sig_on`, as that involves Python calls.

While looking at that code, I also noticed a potential bug: #26546


---

Comment by jdemeyer created at 2018-10-24 09:46:05

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2018-10-24 09:55:06

I suggest to base this on top of #26546


---

Comment by git created at 2018-11-03 11:38:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2018-11-03 11:56:39

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2018-11-03 11:56:39

While merging with #26546 I had to resolve a couple of conflicts. Now all tests pass, I think that the usage of sig_on/sig_off is safer, and thus it is ready for review.


---

Comment by jdemeyer created at 2018-11-05 08:44:10

I'd rather review this after the dependency has actually been merged. Feel free to remind me when that happens.


---

Comment by dimpase created at 2018-12-30 16:19:07

on this branch with installed meataxe, and #22626 and #26856, merged all the tests pass.


---

Comment by SimonKing created at 2018-12-30 16:57:19

Replying to [comment:25 jdemeyer]:
> I'd rather review this after the dependency has actually been merged. Feel free to remind me when that happens.

Replying to [comment:26 dimpase]:
> on this branch with installed meataxe, and #22626 and #26856, merged all the tests pass. 

Is that the reminder? `;-)`


---

Comment by jdemeyer created at 2018-12-30 20:53:47

Rebased to 8.6.beta0 and put back this comment (assuming that it was removed by accident)

```diff
-            # Inverting a singular matrix causes MatInverse to raise a
-            # ZeroDivisionError (see sage_meataxe_error_handler).
-            # So we need to support exceptions here.
```

----
New commits:


---

Comment by jdemeyer created at 2019-01-06 08:27:01

Changing status from needs_review to positive_review.


---

Comment by embray created at 2019-01-15 18:16:10

Retarging tickets optimistically to the next milestone.  If you are responsible for this ticket (either its reporter or owner) and don't believe you are likely to complete this ticket before the next release (8.7) please retarget this ticket's milestone to sage-pending or sage-wishlist.


---

Comment by vbraun created at 2019-01-23 14:17:59

Resolution: fixed
