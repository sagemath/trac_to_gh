# Issue 16959: Clarify assumptions on bitset operations

Issue created by migration from https://trac.sagemath.org/ticket/17196

Original creator: jdemeyer

Original creation time: 2014-10-22 13:12:30

CC:  ncohen

Most bitset operations state something like

```
    We assume the two sets have the same size.  Otherwise, the
    behavior of this function is undefined and the function may
    segfault.
```


However, in fact many of these requirements can be relaxed.


---

Comment by SimonKing created at 2014-10-22 18:08:32

Is it ready for a review?
----
New commits:


---

Comment by SimonKing created at 2014-10-22 18:43:21

Something I'd like to see is the _empty_ bitset. The fact that the size of a bitset must be positive caused me some headache at #15820, where I need bounded integer sequences of length zero. And I think it is not a good solution to fake-use bitsets of size 1 if the actual size is zero.


---

Comment by SimonKing created at 2014-10-22 18:44:20

Besides, while we are at it: Shouldn't it be moved to `sage.data_structures`?


---

Comment by SimonKing created at 2014-10-22 19:14:12

For the record: I am trying the move to sage.data_structures right now (hope we are not having a race condition in our commits...)


---

Comment by SimonKing created at 2014-10-22 21:05:34

The commit that I pushed moves bitsets to the new data_structures folder. I am running tests now. So far it works well...
----
New commits:


---

Comment by SimonKing created at 2014-10-22 21:14:28

What I try to do next: Empty bitsets.

Question: Should one perhaps create different functions `bitset_init_copy(res,src)` vs. `bitset_realloc_copy(res,src)`, where in the first it is assumed that `res` is not initialised, whereas the second function will override previous contents of `res`? And similar for other functions such as shift?


---

Comment by SimonKing created at 2014-10-22 23:32:20

How clever are compilers?

The question is related to idioms like `n % GMP_LIMB_BITS`.

`GMP_LIMB_BITS` is a power of two, and it is known at compile time. Hence, `n % GMP_LIMB_BITS` does not involve a generally very expensive `%`-operation, but boils down to a simple `&`.

Will compilers automatically use this optimization? If not, then I think we should introduce an integer constant `mod_mp_bits_per_limb` (see #15820), so that `n % GMP_LIMB_BITS == n & mp_bits_per_limb`. If yes, then I guess one can also avoid `n >> index_shift`, and use `n//GMP_LIMB_BITS` instead.


---

Comment by SimonKing created at 2014-10-22 23:38:30

One place or another (i.e., here or #15820), we will have to deal with the corner case of size zero. The reason: "A common requirement for all functions is that each source area needs at least one limb. No size argument may be zero." See [GMP low level functions](https://gmplib.org/manual/Low_002dlevel-Functions.html). I suggest we deal with it _here_.


---

Comment by SimonKing created at 2014-10-23 06:53:25

It seems that compilers are clever. On my 32-bit laptop:

```
sage: cython("""
....: cpdef unsigned int f1(unsigned int size):
....:     return (size -1)/(8*sizeof(unsigned int)) +1
....: cpdef unsigned int f2(unsigned int size):
....:     return ((size -1)>>5)+1
""")
sage: f1(89)
3L
sage: f2(89)
3L
sage: %timeit f1(89)
1000000 loops, best of 3: 376 ns per loop
sage: %timeit f2(89)
1000000 loops, best of 3: 371 ns per loop
sage: %timeit f1(89)
1000000 loops, best of 3: 377 ns per loop
sage: %timeit f2(89)
1000000 loops, best of 3: 375 ns per loop
sage: %timeit f1(189)
1000000 loops, best of 3: 377 ns per loop
sage: %timeit f2(189)
1000000 loops, best of 3: 382 ns per loop
```


```
sage: cython("""
....: cdef unsigned int bpl = 32
....: cdef unsigned int modbpl = 31
....: cpdef unsigned int f1(unsigned int size):
....:     return size%bpl
....: cpdef unsigned int f2(unsigned int size):
....:     return size&modbpl
....: """)
sage: f1(89)
25L
sage: f2(89)
25L
sage: %timeit f1(89)
1000000 loops, best of 3: 380 ns per loop
sage: %timeit f2(89)
1000000 loops, best of 3: 375 ns per loop
sage: %timeit f1(189)
1000000 loops, best of 3: 382 ns per loop
sage: %timeit f2(189)
1000000 loops, best of 3: 375 ns per loop
```

So, not really a difference...


---

Comment by jdemeyer created at 2014-10-23 07:01:43

Replying to [comment:12 SimonKing]:
> I suggest we deal with it _here_.
I would actually suggest the opposite. Keep assuming that bitsets have size > 0 and implement empty biseqs using bitsets of size 1. I think this will be the simplest.

Why do you think this is a bad idea?


---

Comment by SimonKing created at 2014-10-23 07:07:38

Replying to [comment:14 jdemeyer]:
> Replying to [comment:12 SimonKing]:
> > I suggest we deal with it _here_.
> I would actually suggest the opposite. Keep assuming that bitsets have size > 0 and implement empty biseqs using bitsets of size 1. I think this will be the simplest.
> 
> Why do you think this is a bad idea?

Since I suppose people would think that the empty set should be available as a bitset.


---

Comment by SimonKing created at 2014-10-23 07:13:05

Anyway, if you think that there should be no empty bitset and if you agree that it should be moved to sage.data_structures.bitset, then it needs review, since all tests pass and the doc correctly appears in sage.data_structures.


---

Comment by SimonKing created at 2014-10-23 07:13:05

Changing status from new to needs_review.


---

Comment by ncohen created at 2014-10-23 08:49:03

About moving that to structure... If you want to move bitsets from misc to structure and so make this 'structure' folder mean "data structure", could you also move the other data structure files from misc there ? I looked at the list and it seems that only `binary_tree.*` and `binary_matrix.*` are there.

Nathann


---

Comment by jdemeyer created at 2014-10-23 08:53:02

Replying to [comment:19 ncohen]:
> About moving that to structure... If you want to move bitsets from misc to structure and so make this 'structure' folder mean "data structure", could you also move the other data structure files from misc there ?
It's not `structure`, it's `data_structures`. And moving other things should be not on this ticket.


---

Comment by ncohen created at 2014-10-23 08:58:10

Oh.

So we will have two folders named `structure/`, `data_structure/`, and data structure code in both `data_structure/` and `misc/`.

Cool.

Nathan


---

Comment by jdemeyer created at 2014-10-23 09:13:19

Replying to [comment:21 ncohen]:
> data structure code in both `data_structure/` and `misc/`.
and in `structure/` and in `matroids/` and in `combinat/` and probably other places...


---

Comment by jdemeyer created at 2014-10-23 09:31:13

New commits:


---

Comment by SimonKing created at 2014-10-23 09:57:36

Replying to [comment:22 jdemeyer]:
> Replying to [comment:21 ncohen]:
> > data structure code in both `data_structure/` and `misc/`.
> and in `structure/` and in `matroids/` and in `combinat/` and probably other places...

Nathann, if I understand correctly, the plan is to eventually move
- all sage-specific data structures (e.g.,, those that only make sense within Sage's coercion framework) to `structure`, 
- all data structures that make sense without Sage and are not tied to a specific mathematical topic (bitsets, bitmatrices, bounded integer sequences, the dictionaries that are currently defined in `sage.structure.coerce_dict`) to `data_structures`

and then `misc` should be reserved to miscellaneous _mathematical_ topics (I think this is the definition according to the docs).


---

Comment by SimonKing created at 2014-10-23 10:00:32

Replying to [comment:22 jdemeyer]:
> Replying to [comment:21 ncohen]:
> > data structure code in both `data_structure/` and `misc/`.
> and in `structure/` and in `matroids/` and in `combinat/` and probably other places...

PS: Of course there will be data structure code in many places, for example in `sage.matrices`. This is because such data structures are designed for a specific mathematical purpose (e.g., implementing matrix algebras).


---

Comment by ncohen created at 2014-10-23 10:00:46

Yo !

> Nathann, if I understand correctly, the plan is to eventually move
> - all sage-specific data structures (e.g.,, those that only make sense within Sage's coercion framework) to `structure`, 
> - all data structures that make sense without Sage and are not tied to a specific mathematical topic (bitsets, bitmatrices, bounded integer sequences, the dictionaries that are currently defined in `sage.structure.coerce_dict`) to `data_structures`
> 
> and then `misc` should be reserved to miscellaneous _mathematical_ topics (I think this is the definition according to the docs).

I understand. I merely mentionned that by only moving bitsets here the code would be in a weird state where only bitsets are in the new folder while others are still scattered.

It also feels weird to have a directory named "structure" and one named "data structures". Do you have any idea of how "structure" could be renamed ?

Nathann


---

Comment by jdemeyer created at 2014-10-23 10:08:18

Replying to [comment:27 ncohen]:
> It also feels weird to have a directory named "structure" and one named "data structures". Do you have any idea of how "structure" could be renamed ?
I wouldn't rename `structure` because it will cause too much trouble. It contains very fundamental modules, with lots of code depending on it. Fixing the Sage library itself is not so hard, but the annoying part is all the tickets which currently sit on Trac and import stuff from `structure`.


---

Comment by jdemeyer created at 2014-10-23 10:33:19

Replying to [comment:11 SimonKing]:
> How clever are compilers?
> 
> The question is related to idioms like `n % GMP_LIMB_BITS`.
> 
> `GMP_LIMB_BITS` is a power of two, and it is known at compile time. Hence, `n % GMP_LIMB_BITS` does not involve a generally very expensive `%`-operation, but boils down to a simple `&`.
> 
> Will compilers automatically use this optimization?
Yes, they should. It's an obvious easy optimization.


---

Comment by ncohen created at 2014-10-23 11:01:27

> > It also feels weird to have a directory named "structure" and one named "data structures". Do you have any idea of how "structure" could be renamed ?
> I wouldn't rename `structure` because it will cause too much trouble. It contains very fundamental modules, with lots of code depending on it. Fixing the Sage library itself is not so hard, but the annoying part is all the tickets which currently sit on Trac and import stuff from `structure`.

Come on, since when do we have to be compatible with the patches in `needs_review`/`needs_work` ?

Nathann


---

Comment by SimonKing created at 2014-10-24 10:22:01

For the record: I like the changes introduced by Jeroen, and it seems to work well in #15820. Hence, I give a positive review to the part of the code that I didn't author.


---

Comment by jdemeyer created at 2014-10-27 07:59:34

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-10-27 16:02:26

Resolution: fixed
