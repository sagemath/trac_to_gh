# Issue 24616: substitution into polynomials over SR broken

Issue created by migration from Trac.

Original creator: dimpase

Original creation time: 2018-02-27 09:58:07

CC:  rws mmezzarobba


```
sage: R.<r>=SR[]
sage: R
Univariate Polynomial Ring in r over Symbolic Ring
sage: p=r^2-1
sage: p(1)
Exception RuntimeError: 'maximum recursion depth exceeded while calling a Python object' in <type 'exceptions.RuntimeError'> ignored
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
<ipython-input-44-4c09f14dea4d> in <module>()
----> 1 p(Integer(1))

/home/dima/Sage/sage-dev/local/lib/python2.7/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.__call__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:9535)()
    787         elif hasattr(a, "_evaluate_polynomial"):
    788             try:
--> 789                 return a._evaluate_polynomial(pol)
    790             except NotImplementedError:
    791                 pass

/home/dima/Sage/sage-dev/local/lib/python2.7/site-packages/sage/symbolic/expression.pyx in sage.symbolic.expression.Expression._evaluate_polynomial (build/cythonized/sage/symbolic/expression.cpp:45786)()
   7458         cdef Expression zero
   7459         try:
-> 7460             return new_Expression_from_pyobject(self._parent, pol(self.pyobject()))
   7461         except TypeError:
   7462             zero = self._parent.zero()

... last 2 frames repeated, from the frame below ...

/home/dima/Sage/sage-dev/local/lib/python2.7/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.__call__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:9535)()
    787         elif hasattr(a, "_evaluate_polynomial"):
    788             try:
--> 789                 return a._evaluate_polynomial(pol)
    790             except NotImplementedError:
    791                 pass

RuntimeError: maximum recursion depth exceeded while calling a Python object
```


see also sage-support [here](https://groups.google.com/d/msg/sage-support/pcp_Mh65Fvk/U6Qhy_dpAgAJ)


---

Comment by rws created at 2018-02-27 15:14:12

`p.__call__` calls `SR(1)._evaluate_polynomial`:

```
        /* "sage/rings/polynomial/polynomial_element.pyx":790
 *         elif hasattr(a, "_evaluate_polynomial"):
 *             try:
 *                 return a._evaluate_polynomial(pol)             # <<<<<<<<<<<<<<
 *             except NotImplementedError:
 *                 pass
 */
```

and `SR(1)._evaluate_polynomial` calls `p(SR(1))`:

```
  /* "sage/symbolic/expression.pyx":7459
 *         """
 *         cdef Expression zero
 *         try:             # <<<<<<<<<<<<<<
 *             return new_Expression_from_pyobject(self._parent, pol(self.pyobject()))
 *         except TypeError:
 */
```



---

Comment by rws created at 2018-02-27 15:17:50

The changes came here:

```
commit 03e86910b66e18bc652b918a1ad8e2892ac04004
Author: Marc Mezzarobba <marc`@`mezzarobba.net>
Date:   Wed Jan 11 12:18:50 2017 +0100

    speed up generic Polynomial.__call__()
```



---

Comment by rws created at 2018-02-27 15:19:12

Changing component from symbolics to commutative algebra.


---

Comment by rws created at 2018-02-27 15:50:23

Maybe instead of `pol(self.pyobject())` `parent(pol)(self.pyobject())` was meant?


---

Comment by git created at 2018-02-27 16:17:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2018-02-27 16:19:53

Changing status from new to needs_review.


---

Comment by rws created at 2018-02-27 16:19:53

This also fixes doctests that were wrong IMHO.

Finally, I still see a half-second delay when doing the first `R.<r>=SR[]; (r^2-1)(1)`.


---

Comment by dimpase created at 2018-02-27 18:04:50

Replying to [comment:7 rws]:

> Finally, I still see a half-second delay when doing the first `R.<r>=SR[]; (r^2-1)(1)`.
Something big is getting loaded, perhaps Maxima?


---

Comment by jdemeyer created at 2018-02-27 19:36:22

Polynomials over `SR` really make no sense in the first place.


---

Comment by rws created at 2018-02-28 07:01:12

Replying to [comment:9 jdemeyer]:
> Polynomials over `SR` really make no sense in the first place.

`charpoly` of a symbolic matrix should return a symbolic polynomial?


---

Comment by mmezzarobba created at 2018-02-28 09:46:40

Replying to [comment:2 rws]:
> The changes came here:
> {{{
> commit 03e86910b66e18bc652b918a1ad8e2892ac04004
> Author: Marc Mezzarobba <marc`@`mezzarobba.net>
> Date:   Wed Jan 11 12:18:50 2017 +0100
> 
>     speed up generic Polynomial.__call__()
> }}}

Yes and no: this commit (and, perhaps more importantly, 84d6a1b874c) mainly reorganize the code, without changing its semantics much...

Replying to [comment:4 rws]:
> Maybe instead of `pol(self.pyobject())` `parent(pol)(self.pyobject())` was meant?

...But I doubt that. Wouldn't something like (not tested)


```
if pol.parent() is not SR:
    try:
        return new_Expression_from_pyobject(self._parent, pol(self.pyobject()))
    except TypeError:
        pass
zero = self._parent.zero()
return zero.add(*(pol[i]*self**i for i in xrange(pol.degree() + 1)))
```


make more sense?

Replying to [comment:7 rws]:
> This also fixes doctests that were wrong IMHO.

While I have no strong opinion about

```
             sage: f(pi)
-            1.00000000000000*pi^2 - 2.00000000000000
-
+            7.86960440108936
```

I really don't see why you would want this:

```
             sage: SR(0.1)._evaluate_polynomial(pol)
-            0.123400000000000
+            617/5000
```



---

Comment by mmezzarobba created at 2018-02-28 09:48:16

Replying to [comment:9 jdemeyer]:
> Polynomials over `SR` really make no sense in the first place.

Why? I agree with Ralf here, characteristic polynomials of symbolic matrices are a good example.


---

Comment by rws created at 2018-02-28 09:53:23

Replying to [comment:11 mmezzarobba]:
> I really don't see why you would want this:
> {{{
>              sage: SR(0.1)._evaluate_polynomial(pol)
> -            0.123400000000000
> +            617/5000
> }}}

Because `pol` is a `QQ[]` and `QQ(0.1)` is `1/10` of course.

Replying to [comment:12 mmezzarobba]:
> Replying to [comment:9 jdemeyer]:
> > Polynomials over `SR` really make no sense in the first place.
> 
> Why? I agree with Ralf here, characteristic polynomials of symbolic matrices are a good example.

Don't misunderstand me, my comment was not a rethorical question. I'm ready to change what's returned from charpoly() to an expression.


---

Comment by rws created at 2018-02-28 09:54:58

Replying to [comment:11 mmezzarobba]:
> make more sense?

Please go ahead.


---

Comment by dimpase created at 2018-02-28 10:41:56

Replying to [comment:13 rws]:
> Replying to [comment:11 mmezzarobba]:
> > I really don't see why you would want this:
> > {{{
> >              sage: SR(0.1)._evaluate_polynomial(pol)
> > -            0.123400000000000
> > +            617/5000
> > }}}
> 
> Because `pol` is a `QQ[]` and `QQ(0.1)` is `1/10` of course.
> 
> Replying to [comment:12 mmezzarobba]:
> > Replying to [comment:9 jdemeyer]:
> > > Polynomials over `SR` really make no sense in the first place.
> > 
> > Why? I agree with Ralf here, characteristic polynomials of symbolic matrices are a good example.
> 
> Don't misunderstand me, my comment was not a rethorical question. I'm ready to change what's returned from charpoly() to an expression.

I would not try to force this onto the user - this conversion is easy.

I also do not understand why having polynomials over `SR` makes no sense; well, it might be so in an ideal world where `SR` can seamlessly discover polynomial structures in expressions and operate accordingly, but this is not the case I think.


---

Comment by mmezzarobba created at 2018-03-06 16:29:11

Replying to [comment:13 rws]:
> Replying to [comment:11 mmezzarobba]:
> > I really don't see why you would want this:
> > {{{
> >              sage: SR(0.1)._evaluate_polynomial(pol)
> > -            0.123400000000000
> > +            617/5000
> > }}}
> 
> Because `pol` is a `QQ[]` and `QQ(0.1)` is `1/10` of course.

I think I don't understand what you mean, sorry. First, `QQ(0.1)` is 1/10, but there is no coercion from `RR` to `QQ` so this doesn't mean anything, and `(0.1).exact_rational()` is `3602879701896397/36028797018963968`. Second, even 0.1 “was” 1/10 in some stronger sense, I don't see why polynomial evaluation would want to convert the argument to the polynomial's base ring (outside symbolics, `Polynomial.__call__()` returns an element of the pushout of the base ring and the evaluation point, which does the right thing in every(?) case).


---

Comment by vdelecroix created at 2018-03-10 15:45:16

Replying to [comment:16 mmezzarobba]:
> Replying to [comment:13 rws]:
> > Replying to [comment:11 mmezzarobba]:
> > > I really don't see why you would want this:
> > > {{{
> > >              sage: SR(0.1)._evaluate_polynomial(pol)
> > > -            0.123400000000000
> > > +            617/5000
> > > }}}
> > 
> > Because `pol` is a `QQ[]` and `QQ(0.1)` is `1/10` of course.
> 
> I think I don't understand what you mean, sorry. First, `QQ(0.1)` is 1/10, but there is no coercion from `RR` to `QQ` so this doesn't mean anything, and `(0.1).exact_rational()` is `3602879701896397/36028797018963968`. Second, even 0.1 “was” 1/10 in some stronger sense, I don't see why polynomial evaluation would want to convert the argument to the polynomial's base ring (outside symbolics, `Polynomial.__call__()` returns an element of the pushout of the base ring and the evaluation point, which does the right thing in every(?) case).

I fully agree with Marc here (see laso the related discussion at #24939). If there is *any* floating point number in the polynomial, then the output can never be an exact number (including elements of QQ, AA, QQbar as well as exact constants such as pi, e, etc, arctan(2)).


---

Comment by rws created at 2018-03-10 15:51:24

Changing status from needs_review to needs_work.


---

Comment by rws created at 2018-03-10 15:51:24

I think who introduced the bug should also fix it.


---

Comment by mmezzarobba created at 2018-03-10 16:38:31

I have no idea who introduced the bug, but here is a possible fix that makes sense to me.


---

Comment by mmezzarobba created at 2018-03-10 16:38:31

Changing status from needs_work to needs_review.


---

Comment by git created at 2018-03-10 16:43:04

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-03-10 17:04:59

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by rws created at 2018-03-19 14:59:25

Changing status from needs_review to positive_review.


---

Comment by rws created at 2018-03-19 14:59:25

Thanks. It's looking fine and patchbot has only the test_jupyter fail.


---

Comment by vbraun created at 2018-03-21 06:18:42

Resolution: fixed
