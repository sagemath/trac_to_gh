# Issue 16094: Game Theory: Build capacity to solve matching games in to Sage.

Issue created by migration from Trac.

Original creator: vinceknight

Original creation time: 2014-05-12 08:20:55

Keywords: Game Theory, Matching Games,

Include class for matching games as well as implementations of the Gale-Shapley algorithm. 

Should be efficient to code in pure python/cython. Various methods to include possibility to give suitor/reviewer optimal matchings. Also, make use of graph plotting to represent game.

Possible extensions could include variations of matching games (indifference etc...).


---

Comment by ncohen created at 2014-05-12 08:28:52

(being curious)


---

Comment by kcrisman created at 2014-05-12 13:36:59

Putting to no listed component because truly non fits.  Also, author is really for actual author of any changes (which may well be vinceknight! but isn't yet).


---

Comment by kcrisman created at 2014-05-12 13:36:59

Changing component from relocation to PLEASE CHANGE.


---

Comment by vinceknight created at 2014-07-06 10:27:49

Changing component from PLEASE CHANGE to game theory.


---

Comment by vinceknight created at 2014-07-27 17:54:46

Changing status from new to needs_review.


---

Comment by vinceknight created at 2014-07-27 17:54:46

Last 10 new commits:


---

Comment by kcrisman created at 2014-08-27 19:22:54

Does this depend on #16466?  I'm not sure why it's showing a red branch (doesn't apply cleanly).


---

Comment by vinceknight created at 2014-08-27 21:02:15

Replying to [comment:7 kcrisman]:
> Does this depend on #16466?  I'm not sure why it's showing a red branch (doesn't apply cleanly).

Hi Karl, this ticket does not at all depend on #16466, the code in here is just a basic implementation of the Gale-Shapley algorithm. #16466 is for #16333, although in fact it's only for a specific optional algorithm in #16333 Not to sure what the red branch means?

This branch (#16331) is self contained (unless we messed up with something). 

(Freaky that you got back in touch today as I've just written a blog post trying to encourage reviewers for this particular ticket :)).

Please let me know if there's anything I can help with.


---

Comment by kcrisman created at 2014-08-28 18:04:21

I see the problem - this really seems to depend on #16333.  The code probably doesn't, but in your [work process](http://git.sagemath.org/sage.git/log/?h=e83553e295bc8748735571fd050086d8d59b7ab3&qt=range&q=79d9c2f794de47dce84582afb367ba7984d92e59..e83553e295bc8748735571fd050086d8d59b7ab3) I see lots of merging of that branch in.  So it's hard to view this and probably the branch for this stuff needs to be redone - in other words, 
> This branch (#16331) is self contained (unless we messed up with something).
you messed up with something.

Other random comments:
 * `_is_sovled` - really?
 * What is a `numer`?  I see other little typos like this around (`matchin`, `bi-partitie`, `reviewes`, etc.)
 * Less trivially, there are a lot of methods with no doctests, and some even without documentation (I'm looking at the mysterious `_Player` class, for instance).  Just because it's 'hidden' doesn't mean it isn't at least minimally tested.  Ideally, it's tested with lots of dumb-but-necessary corner cases like empty sets of players and such, but that is more work...
 * What happens if you add a suitor but not a reviewer?  Maybe those methods should be hidden or even in a different scope.


---

Comment by kcrisman created at 2014-08-28 18:05:05

That said, the concept is nice - not too much, but enough to be useful, allows strings and integers.


---

Comment by vinceknight created at 2014-08-28 21:17:27

Replying to [comment:9 kcrisman]:
> I see the problem - this really seems to depend on #16333.  The code probably doesn't, but in your [work process](http://git.sagemath.org/sage.git/log/?h=e83553e295bc8748735571fd050086d8d59b7ab3&qt=range&q=79d9c2f794de47dce84582afb367ba7984d92e59..e83553e295bc8748735571fd050086d8d59b7ab3) I see lots of merging of that branch in.  So it's hard to view this and probably the branch for this stuff needs to be redone - in other words, 
> > This branch (#16331) is self contained (unless we messed up with something).
> you messed up with something.
> 
> Other random comments:
>  * `_is_sovled` - really?
>  * What is a `numer`?  I see other little typos like this around (`matchin`, `bi-partitie`, `reviewes`, etc.)
>  * Less trivially, there are a lot of methods with no doctests, and some even without documentation (I'm looking at the mysterious `_Player` class, for instance).  Just because it's 'hidden' doesn't mean it isn't at least minimally tested.  Ideally, it's tested with lots of dumb-but-necessary corner cases like empty sets of players and such, but that is more work...
>  * What happens if you add a suitor but not a reviewer?  Maybe those methods should be hidden or even in a different scope.

Eeeesh some of those are embarrassing... As soon as I have a working machine I'll get going on them (probably next week). Not too sure what to do about the git branch issue, will figure it out though. I seem to remember asking someone what was the best way to handle this but we obviously didn't quite get it right... 

Thanks again!


---

Comment by vinceknight created at 2014-08-29 20:25:09

Hi Karl,

I've added a lot more docstrings (and incidentally more tests).

Re issue about the branch, I haven't changed anything. Here's the discussion we had on the sage-devel user group when we started working on #16333 after working on #16332 and we weren't too sure about the best way forward when working on a 'family' of tickets:

https://groups.google.com/forum/#!searchin/sage-devel/vincent$20knight/sage-devel/xfu9q8D7Rtc/Z6IkVgJ67ycJ

Would the simplest way forward to be to remove the code relevant to #16333 (but not the git history?)?

Not too sure what the best alternative is... Very happy to be told what to do.
----
Last 10 new commits:


---

Comment by kcrisman created at 2014-08-31 00:49:34

> Would the simplest way forward to be to remove the code relevant to #16333 (but not the git history?)?

I'm no git expert either, unfortunately.  With the patch-based system that would be very easy to deal with.  But right now I can't even view the branch on Trac!


---

Comment by tscrim created at 2014-08-31 01:25:42

Replying to [comment:13 vinceknight]:
> Re issue about the branch, I haven't changed anything. Here's the discussion we had on the sage-devel user group when we started working on #16333 after working on #16332 and we weren't too sure about the best way forward when working on a 'family' of tickets:
> 
> https://groups.google.com/forum/#!searchin/sage-devel/vincent$20knight/sage-devel/xfu9q8D7Rtc/Z6IkVgJ67ycJ
> 
> Would the simplest way forward to be to remove the code relevant to #16333 (but not the git history?)?

The easiest way to delete the code would be to delete the code (and commit the change). The log is there to show your workflow (because maybe you need some of that code for this ticket without #16333 [it's a hypothetical FYI]).

Also the branch field might be red even when the branch merges cleanly because the trac plugin can be more strict than git's merge (and there might be something related with #16332 being merged into `develop` *shrugs*).


---

Comment by git created at 2014-09-02 07:52:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-09-02 07:53:24

Replying to [comment:15 tscrim]:
> Replying to [comment:13 vinceknight]:
> > Re issue about the branch, I haven't changed anything. Here's the discussion we had on the sage-devel user group when we started working on #16333 after working on #16332 and we weren't too sure about the best way forward when working on a 'family' of tickets:
> > 
> > https://groups.google.com/forum/#!searchin/sage-devel/vincent$20knight/sage-devel/xfu9q8D7Rtc/Z6IkVgJ67ycJ
> > 
> > Would the simplest way forward to be to remove the code relevant to #16333 (but not the git history?)?
> 
> The easiest way to delete the code would be to delete the code (and commit the change). The log is there to show your workflow (because maybe you need some of that code for this ticket without #16333 [it's a hypothetical FYI]).

I've just deleted the code not relevant to this branch and committed. Not sure if this fixes the issue?


---

Comment by kcrisman created at 2014-09-03 13:16:45

> I've just deleted the code not relevant to this branch and committed. Not sure if this fixes the issue?
Sadly not.


---

Comment by vinceknight created at 2014-09-03 13:19:08

Replying to [comment:18 kcrisman]:
> > I've just deleted the code not relevant to this branch and committed. Not sure if this fixes the issue?
> Sadly not.

I'm not too sure I understand, if you pull this branch can you not see the code?


---

Comment by vdelecroix created at 2014-09-03 14:11:00

Please, have a look at http://git-scm.com/book/en/Git-Tools-Rewriting-History

It does not makes sense to cancel commits by adding another commit!!

EDIT: and you should not merge a beta release if there is no need to. There is a need only if there is a non-trivial conflict. Now there are 10+ commits in this ticket and there are completely screwed up by several merge of beta releases...

Vincent


---

Comment by vinceknight created at 2014-09-03 14:13:44

I don't think I was trying to cancel a commit.
I didn't want to lose/rewrite any of the history as I'm not entirely sure what is wrong and have no idea what is required to fix it.


---

Comment by vdelecroix created at 2014-09-03 14:18:31

Replying to [comment:21 vinceknight]:
> I don't think I was trying to cancel a commit.
> I didn't want to lose/rewrite any of the history as I'm not entirely sure what is wrong and have no idea what is required to fix it.

Start a new branch whose ends correspond to what you want. The reviewer does not care about your workflow. He only needs a clean view on what has changed! This is ideally done with *one* commit.

Then during the review process, you might have some remarks from the reviewer (maybe even a commit) and you might integrate it to the branch. You provide additional changes in that commit. And you go on until both the reviewer(s) and you agreed.

Vincent


---

Comment by vinceknight created at 2014-09-03 14:19:18

Replying to [comment:20 vdelecroix]:
> Please, have a look at http://git-scm.com/book/en/Git-Tools-Rewriting-History
> 
> It does not makes sense to cancel commits by adding another commit!!
> 
> EDIT: and you should not merge a beta release if there is no need to. There is a need only if there is a non-trivial conflict. Now there are 10+ commits in this ticket and there are completely screwed up by several merge of beta releases...

I have no idea how we did that. 
We very aware that this mess could happen and tried our best to ask around before starting this as to how to avoid it... Is the best way forward to just push the code from the HEAD of this branch on to a new branch? Would this require a new ticket on trac?

Very eager to follow whatever advice/guidance. Is it worth throwing this discussion on the discussion group?

> Vincent


---

Comment by vinceknight created at 2014-09-03 14:21:28

Replying to [comment:22 vdelecroix]:
> Replying to [comment:21 vinceknight]:
> > I don't think I was trying to cancel a commit.
> > I didn't want to lose/rewrite any of the history as I'm not entirely sure what is wrong and have no idea what is required to fix it.
> 
> Start a new branch whose ends correspond to what you want. The reviewer does not care about your workflow. He only needs a clean view on what has changed! This is ideally done with *one* commit.
> 
> Then during the review process, you might have some remarks from the reviewer (maybe even a commit) and you might integrate it to the branch. You provide additional changes in that commit. And you go on until both the reviewer(s) and you agreed.

Ok. To fix the situation now, do I need to create a new ticket to in effect overwrite this ticket or would a git push from a newly created branch do the trick?
> 
> Vincent


---

Comment by vdelecroix created at 2014-09-03 14:25:21

Replying to [comment:24 vinceknight]:
> Replying to [comment:22 vdelecroix]:
> > Replying to [comment:21 vinceknight]:
> > > I don't think I was trying to cancel a commit.
> > > I didn't want to lose/rewrite any of the history as I'm not entirely sure what is wrong and have no idea what is required to fix it.
> > 
> > Start a new branch whose ends correspond to what you want. The reviewer does not care about your workflow. He only needs a clean view on what has changed! This is ideally done with *one* commit.
> > 
> > Then during the review process, you might have some remarks from the reviewer (maybe even a commit) and you might integrate it to the branch. You provide additional changes in that commit. And you go on until both the reviewer(s) and you agreed.
> 
> Ok. To fix the situation now, do I need to create a new ticket to in effect overwrite this ticket or would a git push from a newly created branch do the trick?

No, no, no. Please, do not create any additional tickets. There is no need.

Git (where branch live) and trac (where tickets live) are two different things. You can create as many branches as you like, this is your space. But on trac it is one task for one ticket and it is public.

You should start a new git branch that would be a clean version of the one you proposed for that ticket. Then you should link the branch to this ticket (in the field "branch"). How do you use git? Through the "sage -devel" scripts? The "git trac" command? git and only git?

EDIT: a git push is fine if you provide the option "-f" (i.e. the remote git will forget about the previous position of the branch)

Vincent


---

Comment by vinceknight created at 2014-09-03 14:28:31

Replying to [comment:25 vdelecroix]:
> Replying to [comment:24 vinceknight]:
> > Replying to [comment:22 vdelecroix]:
> > > Replying to [comment:21 vinceknight]:
> > > > I don't think I was trying to cancel a commit.
> > > > I didn't want to lose/rewrite any of the history as I'm not entirely sure what is wrong and have no idea what is required to fix it.
> > > 
> > > Start a new branch whose ends correspond to what you want. The reviewer does not care about your workflow. He only needs a clean view on what has changed! This is ideally done with *one* commit.
> > > 
> > > Then during the review process, you might have some remarks from the reviewer (maybe even a commit) and you might integrate it to the branch. You provide additional changes in that commit. And you go on until both the reviewer(s) and you agreed.
> > 
> > Ok. To fix the situation now, do I need to create a new ticket to in effect overwrite this ticket or would a git push from a newly created branch do the trick?
> 
> No, no, no. Please, do not create any additional tickets. There is no need.

Cool, I didn't think so.
> 
> Git (where branch live) and trac (where tickets live) are two different things. You can create as many branches as you like, this is your space. But on trac it is one task for one ticket and it is public.
> 
> You should start a new git branch that would be a clean version of the one you proposed for that ticket. Then you should link the branch to this ticket (in the field "branch"). How do you use git? Through the "sage -devel" scripts? The "git trac" command? git and only git?

I use git trac.

So to summarise what I will/need to do:

1. checkout a 'clean' version from the Sage master branch
2. add in one commit the code relevant to this ticket (in effect a single python file)
3. push to this ticket

Is that right?

Thanks for the help, I think the main problem came from working on multiple (related) tickets in quick succession and branching from completed tickets instead of the master branch.
> 
> Vincent


---

Comment by vdelecroix created at 2014-09-03 14:32:16

Replying to [comment:26 vinceknight]:
> So to summarise what I will/need to do:
> 
> 1. checkout a 'clean' version from the Sage master branch

Nope. The best would be the last "develop" branch (which is sage.6.4.beta2)

> 2. add in one commit the code relevant to this ticket (in effect a single python file)

yes

> 3. push to this ticket

yes


> Thanks for the help, I think the main problem came from working on multiple (related) tickets in quick succession and branching from completed tickets instead of the master branch.

I agree this is always a mess. What I do is that I create a complete order on my tickets, i.e. ticket1 comes before ticket2, which comes before ticket3... Then I base ticket2 at the end of ticket1 and ticket3 and the end of ticket2. With the link I provided to rewrite history, it helps you to keep everything clean even if you have to do some rebase because of the reviews and/or some new beta release. Note that it might be helpful to the reviewer to add commit lines that looks like "ticket #XXX: change a doctest".

Vincent


---

Comment by vinceknight created at 2014-09-03 14:34:44

Thanks, I'll do that later this evening!


---

Comment by tscrim created at 2014-09-03 14:41:08

Replying to [comment:20 vdelecroix]:
> Please, have a look at http://git-scm.com/book/en/Git-Tools-Rewriting-History
> 
> It does not makes sense to cancel commits by adding another commit!!

Yes it does; it is good git workflow in order to see what has done. I strongly encourage it. It is bad to rewrite history in released branches that people might have pulled. This includes forced pushes (the `-f` option).

Again, the proper way to use git is to make more commits which revert changes!!
> 
> EDIT: and you should not merge a beta release if there is no need to. There is a need only if there is a non-trivial conflict. Now there are 10+ commits in this ticket and there are completely screwed up by several merge of beta releases...

There is, it's a PITA to rebuild sage when switching branches and the merge commits do not hurt anything. Look at the differences between the beta versions using `git diff`. There are also easy options to see the commits which are not in `develop` by

```
git log --no-merges ^develop <branch>
```

Quit thinking commits are like patches, they are not. Git workflow actually recommends lots of little logical commits (I'm actually somewhat bad about this).

In conclusion, this branch is fine (up to merge conflicts).


---

Comment by vinceknight created at 2014-09-03 14:44:09

> In conclusion, this branch is fine (up to merge conflicts).

So what should I do? (Happy to do anything)


---

Comment by vdelecroix created at 2014-09-03 14:55:51

Replying to [comment:29 tscrim]:
> Replying to [comment:20 vdelecroix]:
> > Please, have a look at http://git-scm.com/book/en/Git-Tools-Rewriting-History
> > 
> > It does not makes sense to cancel commits by adding another commit!!
> 
> Yes it does; it is good git workflow in order to see what has done. I strongly encourage it. It is bad to rewrite history in released branches that people might have pulled. This includes forced pushes (the `-f` option).

If somebody pulled it, he might have noticed that the history is dirty! My claim was about how people should write commits *before* submission to trac. You have the right to make a mistake and to change it. Nevertheless the branch has not disappeared from git so people are free to use it. If anybody has based his work on the last commit of a development branch without acknowledging the author it was just a stupid idea.

I mostly agree with [http://www.mail-archive.com/dri-devel`@`lists.sourceforge.net/msg39091.html](http://www.mail-archive.com/dri-devel`@`lists.sourceforge.net/msg39091.html) about clean history.

> Again, the proper way to use git is to make more commits which revert changes!!

No. The timeline of a ticket is most of the time the timeline of a commit (except very exceptional cases). Reverting changes can be done at home (and it is good to do it) but not on trac.

If I pull I really do not want to see

```
commit 1: make a change in toto.py
commit 2: make a change in foo.py
commit 3: cancel a change from commit 1
commit 4: cancel a change from commit 2
commit 5: redo some changes introduced from commit 3
...
```

perhaps you do, but personally I will not review a ticket with 10+ commits.

> > EDIT: and you should not merge a beta release if there is no need to. There is a need only if there is a non-trivial conflict. Now there are 10+ commits in this ticket and there are completely screwed up by several merge of beta releases...
> 
> There is, it's a PITA to rebuild sage when switching branches and the merge commits do not hurt anything. Look at the differences between the beta versions using `git diff`. There are also easy options to see the commits which are not in `develop` by
> {{{
> git log --no-merges ^develop
> }}}

I agree that it is a PITA. But, it is not because of git but because of the build system. There is nothing wrong during the review process to merge *locally* the branch you are reviewing into the develop branch.

> Quit thinking commits are like patches, they are not. Git workflow actually recommends lots of little logical commits (I'm actually somewhat bad about this).

I agree but they should reflect the logic of the code implemented and *not* the author workflow.

Vincent


---

Comment by kcrisman created at 2014-09-03 15:30:53

I want to say that in this case it _does_ make sense to have a lot of commits for two reasons:
 * Implementing from scratch this functionality, like for sage-matroid
 * Two different authors, and ideally one wants to keep their contributions clear
But again, my main concern is just that I am not git wizard enough to view the appropriate changes.  It sounds like one will want to start from (say) the latest beta release and add the relevant code here.  (That's good, because the original directory src/sage/game_theory/all.py is already in, I believe.)


---

Comment by vdelecroix created at 2014-09-03 15:40:22

Replying to [comment:32 kcrisman]:
> I want to say that in this case it _does_ make sense to have a lot of commits for two reasons:

I should not have complained by the number of commits but rather about the number of useless commits.

>  * Implementing from scratch this functionality, like for sage-matroid 

Sage-matroids was about 10K lines of code!

>  * Two different authors, and ideally one wants to keep their contributions clear

+1. To each commit is associated an author and we really do not want to fusion commits from different authors.

> But again, my main concern is just that I am not git wizard enough to view the appropriate changes.  It sounds like one will want to start from (say) the latest beta release and add the relevant code here.  (That's good, because the original directory src/sage/game_theory/all.py is already in, I believe.)

At least we end up to the same conclusion: the branch linked to a simple ticket should be simple enough to have a clear view on what have changed.

Vincent


---

Comment by ncohen created at 2014-09-03 15:41:17

> I want to say that in this case it _does_ make sense to have a lot of commits for two reasons:
>  * Implementing from scratch this functionality, like for sage-matroid
>  * Two different authors, and ideally one wants to keep their contributions clear

If I understand correctly what Vincent says, he means that the history of a git branch should be made to ease the reviewer's job.

The reviewer wants to check that everything does its job and is implemented correctly. It does not help if what is done in one commit is undone in the next. What can help him is when each commit has a clearly defined task and does it well. That way the branch is easier to review.

What you do on your own computer is your own affair, but when you push to a public branch linked to a ticket you are already 'sharing' code, and it is better if the code you share is meant to be read.


---

Comment by vinceknight created at 2014-09-03 16:16:27

Again: apologies for making this ticket so hard to review. I'm still unsure as to what I should do from here if anyone has any suggestions?


---

Comment by tscrim created at 2014-09-03 17:09:34

I know this will sound snarky/condescending, but I do honestly mean it. You should probably learn more git in order to be a better reviewer.

There is a good reason to merge the latest develop version, you never know what exactly has changed. Unless you're relying only on python (which I highly doubt is the case), you can get into subtle changes which can break your program (for example, output format was changed from a list into a tuple; I've been bitten by this).

For the most part I don't look at the commit history when reviewing a ticket, instead I look at the overall diff from develop/dependencies. Afterwards if additional changes are made, then it's commits, but I'd rather see the forest than tree by tree.

IMO, useless commits are ones which merge in individual unrelated tickets (for example, one on elliptic curves), or merge in commits from a dependency 1 by 1 which don't impact the current ticket.

From Vincent's example of undoing _all_ changes immediately and pushed to trac, then you can consider starting a new branch in those cases as there is nothing inbetween (and changing the branch field on the ticket). However if there are additional commits, you either might want to cherry-pick them in or just continue on. Sometimes you realize things are unneeded and having that in the history is a good note. Nevertheless partial commit revisions deserve their own commits. As Nathann said, it's the _code_ you want the reviewer to read, not the _history_. (Although when it comes to design decisions, especially if the author is not around, having the workflow in the history can give some insight.)

Again, commits are not the patches of Hg.

I'm happy to review of this ticket since I have no qualms about the current branch (although if Vince can merge in develop and push, I'd appreciate that).


---

Comment by vdelecroix created at 2014-09-03 17:30:23

Replying to [comment:36 tscrim]:
> I know this will sound snarky/condescending, but I do honestly mean it. You should probably learn more git in order to be a better reviewer.

You should also learn git to become a better contributor! The reviewer is doing a kind of sacrifice, so there is no way to discuss that the effort should be done from the contributor side (of course ignore that for first contributions).

> There is a good reason to merge the latest develop version, you never know what exactly has changed. Unless you're relying only on python (which I highly doubt is the case), you can get into subtle changes which can break your program (for example, output format was changed from a list into a tuple; I've been bitten by this).

Right. For me a doctest issue is also a merge conflict but not in the git sense. There are also a good reason to not do it: keep the history clean.

> For the most part I don't look at the commit history when reviewing a ticket, instead I look at the overall diff from develop/dependencies. Afterwards if additional changes are made, then it's commits, but I'd rather see the forest than tree by tree.

The history is good to help the reviewer understands what the modifications provided by a branch does. You are of course allowed to ignore that. I really think that I am a git person and you are the hg person if you work that way. A global diff can be really ugly even if the commits are very nice (just have a look at #16884).

> Again, commits are not the patches of Hg.

Hum, each commit is a diff and a patch is a diff. So technically speaking they are. Now, if you want to argue about the philosophy of what a commit should be and what a patch should be it has nothing to do with the softwares but how you use them... and you are free to use them the way you want!

By the way, I would like to stop that discussion on the ticket as it spoils the Game theory purpose of it!

Best, 
Vincent


---

Comment by kcrisman created at 2014-09-03 18:08:14

> > I know this will sound snarky/condescending, but I do honestly mean it. You should probably learn more git in order to be a better reviewer.
> 
> You should also learn git to become a better contributor! The reviewer is doing a kind of sacrifice, so there is no way to discuss that the effort should be done from the contributor side (of course ignore that for first contributions).

Naturally both are true, but there is also the point that, in this case, both reviewer and contributor have other duties than learning lots of git.
> By the way, I would like to stop that discussion on the ticket as it spoils the Game theory purpose of it!

Yes, probably true.  Anyway, Vince K., it looks like I will probably have to wait until next week to figure out how to do this without breaking something, sorry :( because I do want to look at it carefully.


---

Comment by git created at 2014-09-03 22:44:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-09-03 22:47:03

> I'm happy to review of this ticket since I have no qualms about the current branch (although if Vince can merge in develop and push, I'd appreciate that).

Thanks tscrim. I have just pushed a merged version.

Apologies all again for the confusion/mess. I'm going away for 4 days (no internet access) so won't be able to address anything directly but will do so on Monday.

Thank you all for your time looking at this.


---

Comment by kcrisman created at 2014-09-04 01:55:31

Green!  Still depends on #16333 I guess.  Have a great trip!


---

Comment by kcrisman created at 2014-09-04 18:37:23

I just typed in a truly jumbo list of detailed comments, and then Trac logged me out and I lost them all.  I'm not going to try again now.  Short version is that there are lots of small questions I have, three typos, and then the big one is whether all this infrastructure (like `_Player`) is really necessary to keep track of the info in question. 

Aargh.


---

Comment by kcrisman created at 2014-09-05 02:00:10

Ok, take two.  I will remember to Ctrl-C first this time.

----

Typos:
 * `extended Gale Shapley algorithm` should have a hyphen
 * `of in a population` has an extra word
 * possibly, `rank their preference` should be `preferences`?
 * `a stable matchin` should have a `g`.


---

Comment by kcrisman created at 2014-09-05 02:01:37

Further comment: all the below is more Python, and not mathematics.  I have not checked the actual G-S algorithm is correct, though I doubt that will take long to do.  But it won't happen this time.


---

Comment by kcrisman created at 2014-09-05 02:13:11

Comments I could reconstruct:
 * Should it be a game of 2n players or size n?  Is there a standard terminology?
 * Since the matching $M$ is bijective and the algorithm is not symmetric, should the solution really have each match twice?

```
        sage: m.solve()
        {'A': ['J'],
         'C': ['K'],
         'B': ['M'],
         'D': ['L'],
         'K': ['C'],
         'J': ['A'],
         'M': ['B'],
         'L': ['D']}
```

   maybe instead

```
        sage: m.solve()
        {'A': ['J'],
         'C': ['K'],
         'B': ['M'],
         'D': ['L'],
```

   and then it will be easy to tell if it's inverted...
 * `_repr_` really shouldn't have it possible to have something other than $2n$.  I'm not asking to check the `_is_complete` at that point, but at least they should be same number can be checked.
 * `latex` - I'm not sure this is standard notation. `4=\{(1, 0)\}`  equals sign?
 * in `game_to_dict` I just don't know whether one should have "undicted" the game in the first place.  It seems like a lot of trouble to redictify the game.  Maybe the data should be stored differently in any event.  Constructing a whole `_Player` for each player seems like a lot of overhead.  They have no external existence.
 * Is it possible for someone to access all the partners and pref and such in such a way as to mess with `_is_solved`?  It just seems odd that those things might be directly accessible.
 * I think another word than 'complete' is needed in checking completeness, because if `{3: (0, 2, 1)` was changed to `{3: (0, 2)` it would still raise the error but seem "complete" in some sense...
 * What if the automatically added suitor name is already in use?  (Say, we already have names `3, 'Fred'` and now want to automatically add a third one.)  I don't know the right answer here.
 * Any rationale for the autoprefs?
 * I wonder if `sol_dict` should be an attribute and not a method.  Especially since you're not really supposed to access it publicly.
 * And of course, if you REALLY want to use the `_Player` class, needs doctests :)


---

Comment by vinceknight created at 2014-09-08 07:13:52

Replying to [comment:45 kcrisman]:
> Comments I could reconstruct:
>  * Should it be a game of 2n players or size n?  Is there a standard terminology?
>  * Since the matching $M$ is bijective and the algorithm is not symmetric, should the solution really have each match twice?
> {{{
>         sage: m.solve()
>         {'A': ['J'],
>          'C': ['K'],
>          'B': ['M'],
>          'D': ['L'],
>          'K': ['C'],
>          'J': ['A'],
>          'M': ['B'],
>          'L': ['D']}
> }}}
>    maybe instead
> {{{
>         sage: m.solve()
>         {'A': ['J'],
>          'C': ['K'],
>          'B': ['M'],
>          'D': ['L'],
> }}}
>    and then it will be easy to tell if it's inverted...
>  * `_repr_` really shouldn't have it possible to have something other than $2n$.  I'm not asking to check the `_is_complete` at that point, but at least they should be same number can be checked.
>  * `latex` - I'm not sure this is standard notation. `4=\{(1, 0)\}`  equals sign?
>  * in `game_to_dict` I just don't know whether one should have "undicted" the game in the first place.  It seems like a lot of trouble to redictify the game.  Maybe the data should be stored differently in any event.  Constructing a whole `_Player` for each player seems like a lot of overhead.  They have no external existence.
>  * Is it possible for someone to access all the partners and pref and such in such a way as to mess with `_is_solved`?  It just seems odd that those things might be directly accessible.
>  * I think another word than 'complete' is needed in checking completeness, because if `{3: (0, 2, 1)` was changed to `{3: (0, 2)` it would still raise the error but seem "complete" in some sense...
>  * What if the automatically added suitor name is already in use?  (Say, we already have names `3, 'Fred'` and now want to automatically add a third one.)  I don't know the right answer here.
>  * Any rationale for the autoprefs?
>  * I wonder if `sol_dict` should be an attribute and not a method.  Especially since you're not really supposed to access it publicly.
>  * And of course, if you REALLY want to use the `_Player` class, needs doctests :)

Thanks Karl, will read through these carefully and work on them sometime this week.


---

Comment by git created at 2014-09-13 01:48:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-09-13 01:52:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-09-13 02:00:42

Replying to [comment:45 kcrisman]:
> Comments I could reconstruct:
>  * Should it be a game of 2n players or size n?  Is there a standard terminology?
>  * Since the matching $M$ is bijective and the algorithm is not symmetric, should the solution really have each match twice?
> {{{
>         sage: m.solve()
>         {'A': ['J'],
>          'C': ['K'],
>          'B': ['M'],
>          'D': ['L'],
>          'K': ['C'],
>          'J': ['A'],
>          'M': ['B'],
>          'L': ['D']}
> }}}
>    maybe instead
> {{{
>         sage: m.solve()
>         {'A': ['J'],
>          'C': ['K'],
>          'B': ['M'],
>          'D': ['L'],
> }}}
>    and then it will be easy to tell if it's inverted...

I have made this change but this has been done in conjunction with other changes: in particular `_sol_dict_` is now an attribute that includes the same dictionary as before (so that it can be used for the bi-partite graph method for example) but `solve` only returns the required output (as you suggest).

>  * `_repr_` really shouldn't have it possible to have something other than $2n$.  I'm not asking to check the `_is_complete` at that point, but at least they should be same number can be checked.
>  * `latex` - I'm not sure this is standard notation. `4=\{(1, 0)\}`  equals sign?

These both have been fixed.

>  * in `game_to_dict` I just don't know whether one should have "undicted" the game in the first place.  It seems like a lot of trouble to redictify the game.  Maybe the data should be stored differently in any event.  Constructing a whole `_Player` for each player seems like a lot of overhead.  They have no external existence.

The only reason to `undict` the game is because the players are not passed to the instance so no dictionary with player instances as keys was constructed until the `game_to_dict` method was called. This has now been changed: upon initialisation the input dictionaries are used to create new dictionaries with player instances as keys. 

The reason for keeping the player instance is that it allows for an easier and more readable coding of the algorithm itself (so I'm quite keen to keep it).

>  * Is it possible for someone to access all the partners and pref and such in such a way as to mess with `_is_solved`?  It just seems odd that those things might be directly accessible.

I actually think this is worth keeping as it could be possible that someone would want to access and change partners (I can't think of why but I can imagine that it would be a shame to take that possibility away).

>  * I think another word than 'complete' is needed in checking completeness, because if `{3: (0, 2, 1)` was changed to `{3: (0, 2)` it would still raise the error but seem "complete" in some sense...

I'm not sure I actually understand this one. `{3:(0,2)` would not be complete as `2` is not a valid player? Maybe I'm missing something. Very happy to change vocabulary.

>  * What if the automatically added suitor name is already in use?  (Say, we already have names `3, 'Fred'` and now want to automatically add a third one.)  I don't know the right answer here.

I have added an error for this.

>  * Any rationale for the autoprefs?

Not really... Do you think they should be something else?

>  * I wonder if `sol_dict` should be an attribute and not a method.  Especially since you're not really supposed to access it publicly.

Completely agree: done, see earlier comment re `solve`.

>  * And of course, if you REALLY want to use the `_Player` class, needs doctests :)

I think this has been done. Note that I need to import the `_Player` class in the tests themselves: I hope that's ok.

Thanks again for being so thorough: very much appreciated.


---

Comment by kcrisman created at 2014-09-16 14:11:22

Thanks for these changes.
> I have made this change but this has been done in conjunction with other changes: in particular `_sol_dict_` is now an attribute that includes the same dictionary as before (so that it can be used for the bi-partite graph method for example) but `solve` only returns the required output (as you suggest).
I'm glad we agree this is a somewhat better solution, and I think it simplifies the code in the long run as well.
> >  * I think another word than 'complete' is needed in checking completeness, because if `{3: (0, 2, 1)` was changed to `{3: (0, 2)` it would still raise the error but seem "complete" in some sense...
> 
> I'm not sure I actually understand this one. `{3:(0,2)` would not be complete as `2` is not a valid player? Maybe I'm missing something. Very happy to change vocabulary.
My point is that "(0,2,1)" is sort of "overcomplete", too many prefs, while "(0,2)" has the "right" number but the wrong guys.  But I don't know what the standard vocabulary is here, that was my main point.
> >  * Any rationale for the autoprefs?
> 
> Not really... Do you think they should be something else?
I think that at least they should be explained clearly so people know how to use them.
> >  * And of course, if you REALLY want to use the `_Player` class, needs doctests :)
> 
> I think this has been done. Note that I need to import the `_Player` class in the tests themselves: I hope that's ok.
Yes, that is standard practice in such cases.
> Thanks again for being so thorough: very much appreciated.
Not at all.


---

Comment by kcrisman created at 2014-09-16 14:14:07

I'm still not exactly sure what commit 0a8aea0 is doing and there is still all this gambit stuff in the commits I see... it would be really good to base only the changes for this ticket on whatever the latest beta is (which should already have cooperative games in it, right?) so that it's very obvious what is changing.  But maybe that's not possible.


---

Comment by kcrisman created at 2014-09-16 14:17:19

> I'm still not exactly sure what commit 0a8aea0 is doing and there is still all this gambit stuff in the commits I see... it would be really 
Oh, I see, there is `src/sage/gametheory` and `src/sage/game_theory`.  Ugh.


---

Comment by kcrisman created at 2014-09-16 14:34:17

> > >  * Any rationale for the autoprefs?
> > Not really... Do you think they should be something else?
> I think that at least they should be explained clearly so people know how to use them.
In fact, I can't really figure them out!  I guess instead of a tuple/list you just have a bunch of the number -1?  (Which isn't even a player?)  That does seem confusing.  Why bother?  It really does confuse me.  If people have to populate it anyway...
> > >  * And of course, if you REALLY want to use the `_Player` class, needs doctests :)
> > I think this has been done. Note that I need to import the `_Player` class in the tests themselves: I hope that's ok.
Ahem.  `__repr__` and `__eq__` still are missing doctests, as is the `solve` method.   Naturally, they don't have to be very exciting - do an edge case or copy one from elsewhere.  Ideally, they'd be slightly different or test some unusual case (e.g. empty game).


---

Comment by kcrisman created at 2014-09-16 15:16:48

Another possible (minor) point:

```
while len([s for s in suitors if s.partner is False]) != 0:
```

maybe it would be easier to use `not any()` for that instead of doing a couple comparisons?


---

Comment by kcrisman created at 2014-09-16 15:32:36

On the plus side, the algorithm is right, as expected!


---

Comment by vinceknight created at 2014-09-16 17:29:28

Thanks for all this Karl. I'm getting going on them now!


---

Comment by tscrim created at 2014-09-16 17:48:45

Replying to [comment:54 kcrisman]:
> Another possible (minor) point:
> {{{
> while len([s for s in suitors if s.partner is False]) != 0:
> }}}
> maybe it would be easier to use `not any()` for that instead of doing a couple comparisons?

Or an `all()`. This or `not any()` will be faster to fail because it will short circuit out, whereas building the list (which takes time too) will do the full iteration over all suitors.


---

Comment by git created at 2014-09-16 18:35:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-09-16 18:40:11

Thanks both, I've made the following changes:

- Gone with `not all` statement on point raised above (much tidier)
- Have added doctests to `__eq__`, `__repr__` and `solve` - I had (lazily) assumed that for smaller things and/or if there were a bunch of tests otherwise it was ok to omit. That was lazy and sloppy.
- I agree that the `-1` auto prefs was a bit confusing. I've simply removed them and now the autoprefs is simply an empty list.

With regards to `is_complete`, I don't think there's any standard term (as it simply isn't well defined). This leads me to suggest `is_well_defined` or `is_coherent`. I personally prefer `is_well_defined`. Does that sound ok?


---

Comment by tscrim created at 2014-09-16 19:07:48

Some notes on the recent commits. Please remove the list brackets in the `all` statement so it doesn't build the full list, so:

```
while not all(s.partner for s in suitors):
```

Note in these timings, there is a failure at the first entry:

```
sage: L = range(10000)
sage: %timeit all([x for x in L])
1000 loops, best of 3: 758 µs per loop
sage: %timeit all(x for x in L)
100000 loops, best of 3: 3.02 µs per loop
```


The added doctests are formatted wrong. The tests themselves need one more level of indentation and it shoulds be `TESTS::` (mainly 2 colons).


---

Comment by git created at 2014-09-16 19:52:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-09-16 19:54:28

Replying to [comment:60 tscrim]:
> Some notes on the recent commits. Please remove the list brackets in the `all` statement so it doesn't build the full list, so:
> {{{
> while not all(s.partner for s in suitors):
> }}}
> Note in these timings, there is a failure at the first entry:
> {{{
> sage: L = range(10000)
> sage: %timeit all([x for x in L])
> 1000 loops, best of 3: 758 µs per loop
> sage: %timeit all(x for x in L)
> 100000 loops, best of 3: 3.02 µs per loop
> }}}

Learn something new every day: thanks. Have updated.
> 
> The added doctests are formatted wrong. The tests themselves need one more level of indentation and it shoulds be `TESTS::` (mainly 2 colons).

Have made your suggested modifications.
Seem to be having issues building the docs though (this seems to be temperamental so might be something locally for me so going to go take a look at that now).


---

Comment by git created at 2014-09-16 20:42:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-09-16 21:17:42

You should revert the last change and instead remove the second colon from the `EXAMPLES::` since 2 colons tells sphinx to go into code/literal format. So things are like:

```
EXAMPLES::

    sage: into_doctests_directly()

Some text::

    sage: more_doctests()
```

or

```
EXAMPLES:

Some explanation::

    sage: a_doctest()

Some more details::

    sage: another_test()
```



---

Comment by git created at 2014-09-16 21:28:59

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vinceknight created at 2014-09-16 21:30:29

Replying to [comment:64 tscrim]:
> You should revert the last change and instead remove the second colon from the `EXAMPLES::` since 2 colons tells sphinx to go into code/literal format. So things are like:
> {{{
> EXAMPLES::
> 
>     sage: into_doctests_directly()
> 
> Some text::
> 
>     sage: more_doctests()
> }}}
> or
> {{{
> EXAMPLES:
> 
> Some explanation::
> 
>     sage: a_doctest()
> 
> Some more details::
> 
>     sage: another_test()
> }}}

Thanks Travis, that explanation is super appreciated, after reverting and changing I had to `push -f` hopefully that hasn't broken absolutely everything git wise...


---

Comment by tscrim created at 2014-09-20 17:48:48

Here's some more things that come from a more detailed look:

- You've created another folder for the game theory called `gametheory` whereas the existing folder `game_theory` should be used (also it is the better name IMO).
- Is gambit (#16466) necessary for this ticket?
- Never have mutable attributes public (with no leading underscore `_`, ex. `suitors` and `reviewers`). It's also good practice to not expose internal-use attributes.
- Bipartite is one word, so change `bi_partite` to `bipartite`.
- `_dict_game` doesn't have a doctest.
- For the `__eq__` method of `_Player`, I think you're better comparing `name`. In particular, this would guarantee hash correctness (if `x == y`, then we must have `hash(x) == hash(y)`).
- Remove the leading underscore of `_Player` so it gets included in the doc (at least, I think it won't get included as is), and it's the proper convention for classes. See the following note too.
- In the `all.py`, it's not good practice to import everything in a particular module (file) as it makes it harder to import things into the global namespace.
- In the `__init__.py`, you don't need to `import all` (usually these files are left blank).
- Make `_Player` inherit from `object` since new-style classes are recommended by python (or at least remove those parentheses). Same for `Coop_Game`.
- Rename `Coop_Game` to `CoopGame`; the latter is the proper naming convention for classes.
- Actually, more generally in your code you've mixed the python conventions: classes follow `CamelCase` and functions/attributes/variables use `underscore_names`.
- `cooperativegames.py` (which probably should be renamed as `cooperative_games.py` for easier reading) is lacking doctests. Actually, is this redundant from `game_theory/cooperative_game.py`?
- Doc formatting:

```
-``name`` - Can be a string or a number. If left blank will automatically
            generate an integer.
```

  should be

```
- ``name`` -- a string or a number; if left blank will automatically
  generate an integer
```

  Note the punctuation, spacing, and alignment. Also change `: ::` into `::` (this was noted by Karl on another ticket I believe).
- More on the docs, please make the short description into the affirmative (I think this is the right word). So `Raises` to `Raise`, `Constructs` to `Construct`, etc. It's a python convention.

I'll take another look once all of this is done.

A category-type question: Does it make sense to talk about the set of all games on a fixed set of players? If so, is there some notion of a morphism? I did some searching and came across [this article](http://www.pps.univ-paris-diderot.fr/~mh/catgames.pdf) describing a category for a particular class of games. So perhaps (on a future ticket) we reorganize everything into using the category framework. This is more food for thought.


---

Comment by git created at 2014-09-20 20:40:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-09-20 20:41:02

Replying to [comment:67 tscrim]:
> Here's some more things that come from a more detailed look:
>
> - You've created another folder for the game theory called `gametheory` whereas the existing folder `game_theory` should be used (also it is the better name IMO).

That shouldn't be there: have deleted.

> - Is gambit (#16466) necessary for this ticket?

No, this has nothing to do with #16466, is it looking like it does?

> - Never have mutable attributes public (with no leading underscore `_`, ex. `suitors` and `reviewers`). It's also good practice to not expose internal-use attributes.

I mentioned to Karl that at times it might be nice to be able to access these. Kind of like in lines 147 onwards of the docs: `sage: from itertools import permutations ...`. Happy to remove if you guys don't think that's a good idea.

> - Bipartite is one word, so change `bi_partite` to `bipartite`.

Easy fix: done.

> - `_dict_game` doesn't have a doctest.

Testing this was rather tricky as it was 'just something' that works in `__init__` so I've moved it to `__init__` which makes it easier to doc-test (I added another doc test there).

> - For the `__eq__` method of `_Player`, I think you're better comparing `name`. In particular, this would guarantee hash correctness (if `x == y`, then we must have `hash(x) == hash(y)`).

By using `.__repr__()` this allows us to test equality not only against another player instance but also against a name of player which is the values in the dictionaries... Changing this would require a re-write of the dictionary that holds the preferences... This isn't necessarily impossible but just checking if it's really necessary?

> - Remove the leading underscore of `_Player` so it gets included in the doc (at least, I think it won't get included as is), and it's the proper convention for classes. See the following note too.

Done, although just confirming that we want `Player` to appear in the docs? This is only meant to be used internally really.

> - In the `all.py`, it's not good practice to import everything in a particular module (file) as it makes it harder to import things into the global namespace.

This shouldn't be there. Maybe it was in `gametheory`...

> - In the `__init__.py`, you don't need to `import all` (usually these files are left blank).

Done.

> - Make `_Player` inherit from `object` since new-style classes are recommended by python (or at least remove those parentheses). Same for `Coop_Game`.

`Coop_Game` must have been in `gametheory`, have made `_Player` inherit from `SageObject`.

> - Rename `Coop_Game` to `CoopGame`; the latter is the proper naming convention for classes.

`Coop_Game` doesn't exist (anymore). (Or shouldn't if it does).

> - Actually, more generally in your code you've mixed the python conventions: classes follow `CamelCase` and functions/attributes/variables use `underscore_names`.

I believe to have caught these now.

> - `cooperativegames.py` (which probably should be renamed as `cooperative_games.py` for easier reading) is lacking doctests. Actually, is this redundant from `game_theory/cooperative_game.py`?

Yes it's redundant (have removed `gametheory`). Sorry...

> - Doc formatting:
> {{{
> -``name`` - Can be a string or a number. If left blank will automatically
>             generate an integer.
> }}}
>   should be
> {{{
> - ``name`` -- a string or a number; if left blank will automatically
>   generate an integer
> }}}

Done.

>   Note the punctuation, spacing, and alignment. Also change `: ::` into `::` (this was noted by Karl on another ticket I believe).

Done.

> - More on the docs, please make the short description into the affirmative (I think this is the right word). So `Raises` to `Raise`, `Constructs` to `Construct`, etc. It's a python convention.

I think I've caught all these.
>
> I'll take another look once all of this is done.
>
> A category-type question: Does it make sense to talk about the set of all games on a fixed set of players? If so, is there some notion of a morphism? I did some searching and came across [this article](http://www.pps.univ-paris-diderot.fr/~mh/catgames.pdf) describing a category for a particular class of games. So perhaps (on a future ticket) we reorganize everything into using the category framework. This is more food for thought.

Great question, probably not enough in my area of expertise to be able answer straight away but will think about it.


---

Comment by tscrim created at 2014-09-20 20:58:20

I asked about the gambit stuff because the spkg data is a part of the branch.

For the `__eq__` of `Player`, I would rewrite this as

```python
if isinstance(other, Player):
    return self.name == other.name
return self.name == other
```

This is faster in general if `name` is some "horrible" object with a (relatively) hard to compute `repr` but easy equality testing (most Sage parents fall into this category due to `EqualityById`). It should be on the same order of speed and is less fragile (I believe there are objects in Sage with the same string repr but different hashes).

The `import all` was in `gametheory` (although it is in the `game_theory/__init__.py` because I didn't check there when looking at the initial ticket).

It's probably overkill to have `Player` inherit from `SageObject`; just the python `object` should be sufficient.


---

Comment by git created at 2014-09-20 21:40:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-09-20 21:42:18

Replying to [comment:70 tscrim]:
> I asked about the gambit stuff because the spkg data is a part of the branch.

Oh no... Does this create a mess? Is the easiest thing for me to do to branch from `develop` and simply include the code?

> 
> For the `__eq__` of `Player`, I would rewrite this as
> {{{#!python
> if isinstance(other, Player):
>     return self.name == other.name
> return self.name == other
> }}}
> This is faster in general if `name` is some "horrible" object with a (relatively) hard to compute `repr` but easy equality testing (most Sage parents fall into this category due to `EqualityById`). It should be on the same order of speed and is less fragile (I believe there are objects in Sage with the same string repr but different hashes).

This is done now, it looks much nicer as well.

> 
> The `import all` was in `gametheory` (although it is in the `game_theory/__init__.py` because I didn't check there when looking at the initial ticket).

I don't believe it's in `game_theory/__init__.py` anymore...

> 
> It's probably overkill to have `Player` inherit from `SageObject`; just the python `object` should be sufficient.

Done. Thanks a lot again for taking the time and explaining all this to me. Really appreciated.


---

Comment by vinceknight created at 2014-09-20 22:22:20

Replying to [comment:72 vinceknight]:
> Replying to [comment:70 tscrim]:
> > I asked about the gambit stuff because the spkg data is a part of the branch.
> 
> Oh no... Does this create a mess? Is the easiest thing for me to do to branch from `develop` and simply include the code?

Or can I just find the 'spkg data' (not sure where that is as James was the one who put that together - but I'm sure I can figure it out) and remove it?


---

Comment by tscrim created at 2014-09-20 23:32:11

I'd just delete them and check (on a new temp branch) that once you merge in #16466, the spkg files are there (which I believe it should be okay from looking at the commit history).


---

Comment by git created at 2014-09-21 09:34:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-09-21 09:38:11

Replying to [comment:74 tscrim]:
> I'd just delete them and check (on a new temp branch) that once you merge in #16466, the spkg files are there (which I believe it should be okay from looking at the commit history).

Cool, thanks, I've deleted the files and pushed. Sadly when I merged #16466 into a temp branch I got some merge conflicts (saying that the files were deleted in one branch).

If things are 'ok' in this branch I'd be tempted to leave it as is and worry about #16466 which we should probably just re-branch from develop? If I'm misunderstanding a future mess that might appear please let me know and I can just 're-branch' from develop for #16331...


---

Comment by tscrim created at 2014-09-21 14:13:15

Replying to [comment:76 vinceknight]:
> Replying to [comment:74 tscrim]:
> > I'd just delete them and check (on a new temp branch) that once you merge in #16466, the spkg files are there (which I believe it should be okay from looking at the commit history).
> 
> Cool, thanks, I've deleted the files and pushed. Sadly when I merged #16466 into a temp branch I got some merge conflicts (saying that the files were deleted in one branch).
>
> If things are 'ok' in this branch I'd be tempted to leave it as is and worry about #16466 which we should probably just re-branch from develop? If I'm misunderstanding a future mess that might appear please let me know and I can just 're-branch' from develop for #16331...

Well, at least it doesn't do it silently. So if we forget about it, the merge will remind us (and the conflict is easy enough to handle). I'll make another look-through today.


---

Comment by tscrim created at 2014-09-22 19:42:40

I've made the following reviewer changes:

- Speed/memory improvements to `solve`.
- Output of `solve` doesn't wrap the players in a list.
- Input to `MatchingGame` can be 2 arguments.
- Added `__eq__` to `MatchingGame` so it pickles.
- Made `MatchingGame` unhashable because it's mutable.
- Made attributes of `MatchingGame` private. 
- Added a `suitors()` and `reviewers()` methods which return tuples.
- Changed input to `Player` because they were unused.
- Latex output.
- Doc formatting.

FYI - I also experimented with removing the `Player` class, but it didn't sit right with me.

I'm thinking we should rename `bipartite` to the more explicit `bipartite_graph`. Do you agree?

Karl, is there anything that you can see that needs to be addressed?
----
New commits:


---

Comment by kcrisman created at 2014-09-22 20:39:44

Not yet, but I have not had time to try anything in Sage out the last few days (travel).  I would definitely like to retain prerogative to try looking at the most recent branch from scratch again, to make sure I didn't miss anything and it works properly, as well as to look at Travis' changes.  I might be able to get to that closer to the end of the week.  But scanning most of the changes as described in the comments it seems good, other than the idea to put game theory in the category framework - that is really very far away from nearly 100% of game theorists' thoughts, I can assure you, and would be an unneeded step to take at this time.


---

Comment by git created at 2014-09-23 10:46:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-09-23 10:50:55

Replying to [comment:78 tscrim]:
> I've made the following reviewer changes:
> 
> - Speed/memory improvements to `solve`.
> - Output of `solve` doesn't wrap the players in a list.
> - Input to `MatchingGame` can be 2 arguments.
> - Added `__eq__` to `MatchingGame` so it pickles.
> - Made `MatchingGame` unhashable because it's mutable.
> - Made attributes of `MatchingGame` private. 
> - Added a `suitors()` and `reviewers()` methods which return tuples.
> - Changed input to `Player` because they were unused.
> - Latex output.
> - Doc formatting.

These all look awesome: thanks!
> 
> FYI - I also experimented with removing the `Player` class, but it didn't sit right with me.
> 
> I'm thinking we should rename `bipartite` to the more explicit `bipartite_graph`. Do you agree?

I went ahead and changed this as I thought it sounded way better.

Thanks a lot Travis (very much appreciated). Karl, thanks again for finding the time, please let me know if there's anything I can help with (I should be pushing to #16954 hopefully by end of tomorrow if not tonight).

(By the way I am completely confused as to how to push to trac using `git push trac...`I seem to try a bunch of combinations of `HEAD:u/[stuff]`, some times it doesn't go, sometimes it seems to push to something but who knows where and sometimes it gets here... I've read the docs on this multiple times but that doesn't seem to clarify things for me... Any tips? <- This is probably not a question for trac).


---

Comment by kcrisman created at 2014-10-24 16:30:11

I can't even see the whole diff now on the branch link.  Huh?  And the list of commits is not so useful because of the very fine granularity and the many dependencies.

Edit: http://git.sagemath.org/sage.git/log/src/sage/game_theory/matching_game.py?h=508d8193ea3d99dda90515bced36c8cd8e747224 seems to work best for this, and then https://github.com/sagemath/sagetrac-mirror/blob/master/src/sage/game_theory/matching_game.py?h=508d8193ea3d99dda90515bced36c8cd8e747224 for the actual file.


---

Comment by tscrim created at 2014-10-24 21:57:25

I also get the same thing.  However if you want to see the diff, assuming you merged with `develop`, is to run `git diff develop` in the branch or `git diff develop your/local/name_of_branch` in any branch. If you haven't merged with `develop`, you can replace that with `6.4.beta3` or whatever beta version this is currently based off of (maybe `6.4.beta4`?).

In related news, ah crap, I've forgotten about what's left to do on all of the game theory tickets...will need to re-read things...


---

Comment by kcrisman created at 2014-10-25 00:16:04

> In related news, ah crap, I've forgotten about what's left to do on all of the game theory tickets...will need to re-read things...
No, no, I'm on top of it today/next week.  Plus, I actually work in this area ;-)  You go do some Lie algebras or job applications or thesis or something!  Thanks for your definite help on getting this in shape, I've already looked at things and the branch is in pretty good shape, it's just a matter of checking the math and such now, no more crazy branch worries like before.


---

Comment by tscrim created at 2014-10-25 03:18:44

Replying to [comment:84 kcrisman]:
> No, no, I'm on top of it today/next week.  Plus, I actually work in this area ;-) You go do some Lie algebras or job applications or thesis or something!

Haha, thanks! I'm doing all of the above in fact (something = teaching).

> Thanks for your definite help on getting this in shape, I've already looked at things and the branch is in pretty good shape, it's just a matter of checking the math and such now, no more crazy branch worries like before.

Let me know if there's anything else I can do.


---

Comment by vinceknight created at 2014-10-25 17:07:54

Replying to [comment:85 tscrim]:
> Replying to [comment:84 kcrisman]:
> > No, no, I'm on top of it today/next week.  Plus, I actually work in this area ;-) You go do some Lie algebras or job applications or thesis or something!
> 
> Haha, thanks! I'm doing all of the above in fact (something = teaching).
> 
> > Thanks for your definite help on getting this in shape, I've already looked at things and the branch is in pretty good shape, it's just a matter of checking the math and such now, no more crazy branch worries like before.
> 
> Let me know if there's anything else I can do.

Thanks both for looking/helping etc... Apologies again for the mess we got it in. If there's anything I can do please let me know.


---

Comment by kcrisman created at 2014-10-27 16:15:54

More minor things.
* Confused here:

```
a bespoke creation of preferences
```

  Is this a Britishism I'm not aware of?
* I feel like `revr` shouldn't be the name of just reviewers in this example but then not in the init... unless that is to support something along the lines of `MatchinGame(suit, revr)`, as the code implies?  But then that should be doctested.

```

    def __init__(self, generator, revr=None):
        r"""
        Initialize a matching game and check the inputs.

        TESTS::

            sage: suit = {0: (3, 4), 1: (3, 4)}
            sage: revr = {3: (0, 1), 4: (1, 0)}
            sage: g = MatchingGame([suit, revr])
            sage: TestSuite(g).run()
```

  Indeed, all input methods should be mentioned fairly clearly somewhere at the top (maybe even an `INPUT` block?  Though this isn't a function... hmm) and you don't use this on in the huge useful top block either.  But in either case I am pretty sure that

```
TypeError("generator must be an integer or a pair of 2 dictionaries")
```

  is wrong or not tested. 
* I'll let you figure out what is wrong with this one.  I guarantee that with correct input no one will ever notice it, though!

```
        return 'A matching game with {} suitors and {} reviewers'.format(
                    len(self._reviewers), len(self._suitors))
```

* Really?

```
    def __eq__(self, other):
        return (isinstance(other, MatchingGame)
                and set(self._suitors) == set(other._suitors)
                and set(self._reviewers) == set(other._reviewers))
```

  But... what about the preferences?  Is it still the same game if they are different?  (Maybe Travis asked this at some point.)
* Has not, presumably.

```
Raise an error if the game has been solved yet.
```

* In `is_complete` I'd still really like some checks for preference tuples that are the "wrong size" somehow.  For instance, someone accidentally types in `(1,2,2,3)` instead of `(1,2,3)`.
* I'm still not quite happy with the `add_suitor` (presumably also reviewer) default.   I like that you now have the error check for the name being doubled, but I think that the _automatic_ addition of a suitor shouldn't raise this error.  If `name = len(self._suitors) + 1` raises that error, couldn't one just keep adding one until it works?  Sorry about asking this, but I just know we want to make this very user-friendly since most targeted users of this will not be as familiar with Sage or math programs...
* I think you need some examples where someone creates a game, and then all of a sudden realizes they need to add (say) a suitor and reviewer, or maybe they just do them by hand, but anyway where they need to add preferences one at a time.  You don't really have a method for this, just `Player.pref` the list of preferences.  That should have several good examples.
* Also, what if someone adds a player to a pre-existing game (well, two!) and then has to update *all* preferences to make it complete?  Is that possible or supported?  If not, how do we indicate this?

I hope that continuing to ask these questions is okay.  Really it is already quite good, but I just want it to be great since it came from GSOC and because this is such new stuff.


---

Comment by vinceknight created at 2014-10-27 16:22:24

Replying to [comment:87 kcrisman]:
> More minor things.
> * Confused here:
> {{{
> a bespoke creation of preferences
> }}}
>   Is this a Britishism I'm not aware of?
> * I feel like `revr` shouldn't be the name of just reviewers in this example but then not in the init... unless that is to support something along the lines of `MatchinGame(suit, revr)`, as the code implies?  But then that should be doctested.
> {{{
> 
>     def __init__(self, generator, revr=None):
>         r"""
>         Initialize a matching game and check the inputs.
> 
>         TESTS::
> 
>             sage: suit = {0: (3, 4), 1: (3, 4)}
>             sage: revr = {3: (0, 1), 4: (1, 0)}
>             sage: g = MatchingGame([suit, revr])
>             sage: TestSuite(g).run()
> }}}
>   Indeed, all input methods should be mentioned fairly clearly somewhere at the top (maybe even an `INPUT` block?  Though this isn't a function... hmm) and you don't use this on in the huge useful top block either.  But in either case I am pretty sure that
> {{{
> TypeError("generator must be an integer or a pair of 2 dictionaries")
> }}}
>   is wrong or not tested. 
> * I'll let you figure out what is wrong with this one.  I guarantee that with correct input no one will ever notice it, though!
> {{{
>         return 'A matching game with {} suitors and {} reviewers'.format(
>                     len(self._reviewers), len(self._suitors))
> }}}
> * Really?
> {{{
>     def __eq__(self, other):
>         return (isinstance(other, MatchingGame)
>                 and set(self._suitors) == set(other._suitors)
>                 and set(self._reviewers) == set(other._reviewers))
> }}}
>   But... what about the preferences?  Is it still the same game if they are different?  (Maybe Travis asked this at some point.)
> * Has not, presumably.
> {{{
> Raise an error if the game has been solved yet.
> }}}
> * In `is_complete` I'd still really like some checks for preference tuples that are the "wrong size" somehow.  For instance, someone accidentally types in `(1,2,2,3)` instead of `(1,2,3)`.
> * I'm still not quite happy with the `add_suitor` (presumably also reviewer) default.   I like that you now have the error check for the name being doubled, but I think that the _automatic_ addition of a suitor shouldn't raise this error.  If `name = len(self._suitors) + 1` raises that error, couldn't one just keep adding one until it works?  Sorry about asking this, but I just know we want to make this very user-friendly since most targeted users of this will not be as familiar with Sage or math programs...
> * I think you need some examples where someone creates a game, and then all of a sudden realizes they need to add (say) a suitor and reviewer, or maybe they just do them by hand, but anyway where they need to add preferences one at a time.  You don't really have a method for this, just `Player.pref` the list of preferences.  That should have several good examples.
> * Also, what if someone adds a player to a pre-existing game (well, two!) and then has to update *all* preferences to make it complete?  Is that possible or supported?  If not, how do we indicate this?
> 
> I hope that continuing to ask these questions is okay.  Really it is already quite good, but I just want it to be great since it came from GSOC and because this is such new stuff.

Please do continue to ask! The questions and review are very much appreciated. We want to get it as close to perfect as possible.

James and I will chat about it and get on it this week some time! Thanks :)


---

Comment by kcrisman created at 2014-10-28 01:06:02

Here is another thing to think about - `src/doc/en/reference/game_theory/index.rst`.


---

Comment by kcrisman created at 2014-10-28 14:04:30

Changing status from needs_review to needs_work.


---

Comment by jcampbell created at 2014-11-10 10:41:38

I've had a look at `index.rst` but I'm not sure what exactly it is you want us to change. Looking at `games/index.rst` or `graphs/index.rst` we seem to be following the same format. Could you please explain what it is you want us to change, thank you!


---

Comment by kcrisman created at 2014-11-10 13:19:32

> I've had a look at `index.rst` but I'm not sure what exactly it is you want us to change. Looking at `games/index.rst` or `graphs/index.rst` we seem to be following the same format. Could you please explain what it is you want us to change, thank you!
I think when I made that comment you didn't seem to have added this stuff to the reference manual, but looking at the changes now you have, so it's no longer relevant.


---

Comment by vinceknight created at 2014-11-15 20:14:19

Replying to [comment:87 kcrisman]:
> More minor things.
> * Confused here:
> {{{
> a bespoke creation of preferences
> }}}
>   Is this a Britishism I'm not aware of?

Have reworded and added more docs.

> * I feel like `revr` shouldn't be the name of just reviewers in this example but then not in the init... unless that is to support something along the lines of `MatchinGame(suit, revr)`, as the code implies?  But then that should be doctested.
> {{{
>
>     def __init__(self, generator, revr=None):
>         r"""
>         Initialize a matching game and check the inputs.
>
>         TESTS::
>
>             sage: suit = {0: (3, 4), 1: (3, 4)}
>             sage: revr = {3: (0, 1), 4: (1, 0)}
>             sage: g = MatchingGame([suit, revr])
>             sage: TestSuite(g).run()
> }}}
>   Indeed, all input methods should be mentioned fairly clearly somewhere at the top (maybe even an `INPUT` block?  Though this isn't a function... hmm) and you don't use this on in the huge useful top block either.  But in either case I am pretty sure that
> {{{
> TypeError("generator must be an integer or a pair of 2 dictionaries")
> }}}
>   is wrong or not tested.

Tests have been added now but I do think that we make use of this (apologies if I'm misunderstanding). This setup allows us to either pass a single number or a set of two dictionaries: both of these are used in the top block (although I've now added more) and are doctested?
I've added the INPUT block to the top matter.

I have a feeling that I'm misunderstanding you here: so I apologise.

> * I'll let you figure out what is wrong with this one.  I guarantee that with correct input no one will ever notice it, though!
> {{{
>         return 'A matching game with {} suitors and {} reviewers'.format(
>                     len(self._reviewers), len(self._suitors))
> }}}

This one actually took me a while to figure it out! Now fixed.

> * Really?
> {{{
>     def __eq__(self, other):
>         return (isinstance(other, MatchingGame)
>                 and set(self._suitors) == set(other._suitors)
>                 and set(self._reviewers) == set(other._reviewers))
> }}}
>   But... what about the preferences?  Is it still the same game if they are different?  (Maybe Travis asked this at some point.)

Looking at git blame this is something that Travis put in so I'm not too sure. Maybe this has something to do with the TestSuite, which I also don't know much about...
Sorry to bring you back in to the conversation Travis?

I've added in a test that currently fails when two games are created with reviewers and suitors with different preferences but won't change the code unless I'm missing something that Travis can clarify (it could just be easiest to remove the test if `__eq__` is in fact acting as it should. I'm happy to tweak the code if needed to make that test pass.

> * Has not, presumably.
> {{{
> Raise an error if the game has been solved yet.
> }}}

Fixed.

> * In `is_complete` I'd still really like some checks for preference tuples that are the "wrong size" somehow.  For instance, someone accidentally types in `(1,2,2,3)` instead of `(1,2,3)`.

We already have a check in there that ensures the size of both preference dictionaries are the same but I've now added one to check that you don't have any repetitions (for the particular case you've raised).
I've tried to think of other cases but perhaps I'm missing them.

> * I'm still not quite happy with the `add_suitor` (presumably also reviewer) default.   I like that you now have the error check for the name being doubled, but I think that the _automatic_ addition of a suitor shouldn't raise this error.  If `name = len(self._suitors) + 1` raises that error, couldn't one just keep adding one until it works?  Sorry about asking this, but I just know we want to make this very user-friendly since most targeted users of this will not be as familiar with Sage or math programs...

No need to apologise at all: appreciate the in depth review.
I have changed this so that the automatic addition of a suitor will find a name that's not already there.

> * I think you need some examples where someone creates a game, and then all of a sudden realizes they need to add (say) a suitor and reviewer, or maybe they just do them by hand, but anyway where they need to add preferences one at a time.  You don't really have a method for this, just `Player.pref` the list of preferences.  That should have several good examples.

There is one example of adding all the preferences one at a time in the front matter: it's around the `is one example where the preferences are simply the corresponding` place (line 157: is that what you mean?).
I'm adding another similar one re comment below but let me know if I've misunderstood.

> * Also, what if someone adds a player to a pre-existing game (well, two!) and then has to update *all* preferences to make it complete?  Is that possible or supported?  If not, how do we indicate this?

Have added a longer example showing this.
Note that current behaviour means that if you were to 'mix and match' then the preferences are all wiped so you'd need to update them (the example shows this).
The main reason for this is to ensure that no confusion occurs (less chance of user error).
I don't think that in practice this would happen to often as in practice if one has the preferences as dictionaries you would simply update the dictionaries and recreate a game.
----
New commits:


---

Comment by tscrim created at 2014-11-16 01:33:21

Don't remove the `__eq__`. If you do, you can create equal games (i.e., the same input data) but won't compare equal in Sage. In particular, if you do `loads(dumps(x)) == x` (pickling) for some game `x`, then it will return `False` because the default (python) `==` is by identity (place in memory).

Addendum - The comparison isn't sufficient. Actually, from a quick glance, it's the `Player` equality testing that is not sufficient and probably needs to compare the `Player.pref`'s.


---

Comment by vinceknight created at 2014-11-16 08:53:24

Replying to [comment:94 tscrim]:
> Don't remove the `__eq__`. If you do, you can create equal games (i.e., the same input data) but won't compare equal in Sage. In particular, if you do `loads(dumps(x)) == x` (pickling) for some game `x`, then it will return `False` because the default (python) `==` is by identity (place in memory).
> 
> Addendum - The comparison isn't sufficient. Actually, from a quick glance, it's the `Player` equality testing that is not sufficient and probably needs to compare the `Player.pref`'s.


Cool, never intended to remove `__eq__`, just needed to check that it wasn't coded the way it was for a reason. Was saying that I could remove the test that now doesn't pass but instead will now focus on fixing the code so that the test passes: will work on the `Player` equality: thanks!


---

Comment by kcrisman created at 2014-11-17 13:42:22

Most of these change look great.  I think you got too clever in the examples testing the fix of auto-creating names, though.

```
+            sage: suit = {0: (-1,  -2),
+            ....:         2: (-2, -2)}
+            sage: revr = {-1: (0, 1),
+            ....:         -2: (1, 0)}
...
+            sage: suit = {0: (-1,  -2),
+            ....:         1: (-2, -2)}
+            sage: revr = {-1: (0, 1),
+            ....:         -3: (1, 0)}
```

These preferences sometimes refer to nonexistent players, and sometimes repeat!

Otherwise probably the eq business is what remains.  Nice.


---

Comment by git created at 2014-11-17 17:56:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-11-17 18:05:12

Replying to [comment:96 kcrisman]:
> Most of these change look great.  I think you got too clever in the examples testing the fix of auto-creating names, though.
> {{{
> +            sage: suit = {0: (-1,  -2),
> +            ....:         2: (-2, -2)}
> +            sage: revr = {-1: (0, 1),
> +            ....:         -2: (1, 0)}
> ...
> +            sage: suit = {0: (-1,  -2),
> +            ....:         1: (-2, -2)}
> +            sage: revr = {-1: (0, 1),
> +            ....:         -3: (1, 0)}
> }}}
> These preferences sometimes refer to nonexistent players, and sometimes repeat!

Woops: fixed those (apologies for you needing to pick up my sloppiness... I'll blame the busy first term)
> 
> Otherwise probably the eq business is what remains.  Nice.

So I have fixed those: you'll note that I didn't put them in to the Player class. I tried at first but we use Player equality differently in the algorithm and this broke a few other things. I took a look at fixing those but:

A. it was simpler to move the fix to the game class.
B. after thinking about it for a while I think it make sense to have a player as something that could potentially have different preferences but still be unique (I might have just tried really hard to convince myself of this though). Perhaps further down the line we could look at players deviating strategies (for whatever reason) and seeing the effect that has... 

If anyone feels very very strongly about the equality of players needing to also pick up their preferences I could change that but it would require careful rewriting of the algorithm. Let me know what you guys think.


---

Comment by kcrisman created at 2014-11-17 18:27:57

Hmm, I don't feel terribly strongly about this per se, but if it causes things to be equal that shouldn't, that's a problem.  How is the `loads(dumps(x)) == x` holding up with this?  Maybe one needs to have a warning of player equality being only name equality in that function's doc, anyway.

As to the substantive change, I still am not happy.  For equality, you only check if the sets of players are the same

```
                and set(self._suitors) == set(other._suitors)
                and set(self._reviewers) == set(other._reviewers)
```

but not whether their ordering is the same, but then check for the order (implicitly) here.

```
+                and all(r1.pref == r2.pref for r1, r2 in
+                    zip(self._reviewers, other._reviewers))
+                and all(s1.pref == s2.pref for s1, s2 in
+                    zip(self._suitors, other._suitors)))
```

What about if the players are swapped?  Is it now a different game?  I don't know what the 'right' answer is but if the order matters, then it probably matters for the players too.  Plus it would end the comparison earlier - as soon as one `and` is `False`, it all is.


---

Comment by git created at 2014-11-17 19:33:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kcrisman created at 2014-11-18 03:08:03

Okay, needs doctest changes.  Some are easy - just adding the new Sage 6.4 doctest style for graphics.

```

Failed example:
    plot(g)
Expected nothing
Got:
    Graphics object consisting of 7 graphics primitives
```

Unfortunately, all the ones where the answer is a dictionary will have to be changed so that they are not platform-dependent.

```

Failed example:
    g.solve()
Expected:
    {0: 3, 1: 4}
Got:
    {1: 4, 0: 3}
```

Python dicts don't print in any given order.  :-(

Next, you have to fix some documentation looks.

```
./sage -docbuild reference/game_theory html
```

See this.

```diff
diff --git a/src/sage/game_theory/matching_game.py b/src/sage/game_theory/matching_game.py
index d5c2480..0ba47c5 100644
--- a/src/sage/game_theory/matching_game.py
+++ b/src/sage/game_theory/matching_game.py
`@``@` -72,7 +72,7 `@``@` class MatchingGame(SageObject):
     Two potential inputs are accepted (see below to see the effect of each):
 
     - ``reviewer/suitors_preferences`` -- a dictionary containing the
-    preferences of all players:
+      preferences of all players:
 
      * key - each reviewer/suitors
      * value - a tuple of suitors/reviewers
`@``@` -80,7 +80,7 `@``@` class MatchingGame(SageObject):
     OR:
 
     - ``integer`` -- an integer simply representing the number of reviewers
-    and suitors.
+      and suitors.
 
     To implement the above game in Sage::
 
`@``@` -299,8 +299,8 `@``@` class MatchingGame(SageObject):
         sage: g
         A matching game with 3 suitors and 3 reviewers
 
-     We have an empty set of preferences for a default named set of
-     preferences::
+    We have an empty set of preferences for a default named set of
+    preferences::
 
         sage: for s in g.suitors():
         ....:     s, s.pref
`@``@` -313,15 +313,15 `@``@` class MatchingGame(SageObject):
         (-2, [])
         (-3, [])
 
-     Before trying to solve such a game the algorithm will check if it is
-     complete or not::
+    Before trying to solve such a game the algorithm will check if it is
+    complete or not::
 
         sage: g.solve()
         Traceback (most recent call last):
         ...
         ValueError: suitor preferences are not complete
 
-    To be able to obtain the stable matching we must input the preferences:
+    To be able to obtain the stable matching we must input the preferences::
 
         sage: for s in g.suitors():
         ....:   s.pref = (-1, -2, -3)
`@``@` -714,7 +714,7 `@``@` class MatchingGame(SageObject):
             ValueError: a suitor with name "D" already exists
 

 
         If we add a suitor without passing a name then the name
-        of the suitor will not use one that is already chosen.
+        of the suitor will not use one that is already chosen::
 
             sage: suit = {0: (-1,  -2),
             ....:         2: (-2, -1)}
`@``@` -785,7 +785,7 `@``@` class MatchingGame(SageObject):
             ValueError: a reviewer with name "10" already exists
 
         If we add a reviewer without passing a name then the name
-        of the reviewer will not use one that is already chosen.
+        of the reviewer will not use one that is already chosen::
 
             sage: suit = {0: (-1,  -3),
             ....:         1: (-3, -1)}
```



---

Comment by vinceknight created at 2014-11-18 08:00:41

I've put off merging in to `develop` and rebuilding for long enough. Just doing that now. Will work on all of above as soon as that's done.


---

Comment by git created at 2014-11-18 12:32:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-11-18 12:33:23

I've addressed both those two issues now Karl:

- doctests all pass (they didn't after merging with `develop`)
- docs now build

Let me know if there's anything else :)


---

Comment by kcrisman created at 2014-11-18 14:02:49

Thanks, looks good.  However, I would not be AT ALL surprised if at least some people have problems with doctests with the ones which have dicts as output, for the reasons I just mentioned.  Like so:

```
sage: D = {1:2, 2:3} # possibly random order depending on hashing
sage: sorted(D.items()) # guaranteed
[(1, 2), (2, 3)]
```


See also #17362.


---

Comment by vinceknight created at 2014-11-18 14:12:43

Replying to [comment:105 kcrisman]:
> Thanks, looks good.  However, I would not be AT ALL surprised if at least some people have problems with doctests with the ones which have dicts as output, for the reasons I just mentioned.  Like so:
> {{{
> sage: D = {1:2, 2:3} # possibly random order depending on hashing
> sage: sorted(D.items()) # guaranteed
> [(1, 2), (2, 3)]
> }}}
> 
> See also #17362.

Ah! That's very helpful: so I should go back and changed the dictionary outputs to that? I'll do that today at some point.


---

Comment by vinceknight created at 2014-11-18 14:43:42

Replying to [comment:106 vinceknight]:
> Replying to [comment:105 kcrisman]:
> > Thanks, looks good.  However, I would not be AT ALL surprised if at least some people have problems with doctests with the ones which have dicts as output, for the reasons I just mentioned.  Like so:
> > {{{
> > sage: D = {1:2, 2:3} # possibly random order depending on hashing
> > sage: sorted(D.items()) # guaranteed
> > [(1, 2), (2, 3)]
> > }}}
> > 
> > See also #17362.
> 
> Ah! That's very helpful: so I should go back and changed the dictionary outputs to that? I'll do that today at some point.

Just reran the tests on my linux box and they all failed (fresh build of Sage from `develop`). Will rewrite all the dictionary tests.


---

Comment by tscrim created at 2014-11-18 16:31:00

Replying to [comment:99 kcrisman]:
> Hmm, I don't feel terribly strongly about this per se, but if it causes things to be equal that shouldn't, that's a problem.  How is the `loads(dumps(x)) == x` holding up with this?  Maybe one needs to have a warning of player equality being only name equality in that function's doc, anyway.

We need to define `==` on both players and games otherwise pickling won't construct an "equal" object (as far as python knows). While this is probably not a major thing as games and players are not hashable, I find it strange that I can create two games from the same input data that aren't equal. Also I agree that there needs to be a warning that player equality is based on name alone.


---

Comment by kcrisman created at 2014-11-18 16:40:26

> I find it strange that I can create two games from the same input data that aren't equal. 
Oh, can you?  I thought it was the other way around, that two games with unequal input data would be the same.

In any case, I think that is fixed in [this commit](http://git.sagemath.org/sage.git/commit/?id=7d5d52a738959ba8fde79a60d39eb0fed0156041), and players explained in [this one](http://git.sagemath.org/sage.git/commit/?id=8b049cea8efb051e59af76f3cda5c11e10fbe674) - you can check if you agree with me.


---

Comment by tscrim created at 2014-11-18 18:18:27

Replying to [comment:109 kcrisman]:
> Oh, can you?  I thought it was the other way around, that two games with unequal input data would be the same.

Well, that was a problem with my first implementation of `__eq__`. I was saying without a `__eq__`, then the pickling issue crops up.

> In any case, I think that is fixed in [this commit](http://git.sagemath.org/sage.git/commit/?id=7d5d52a738959ba8fde79a60d39eb0fed0156041), and players explained in [this one](http://git.sagemath.org/sage.git/commit/?id=8b049cea8efb051e59af76f3cda5c11e10fbe674) - you can check if you agree with me.

Currently if you add the suitors (or reviewers) in different order, but everything else is the same, they should compare as not equal (I can't test right now). This should be the same game. What I really worry about is that the iteration over the input dicts might end up being different for two equal but not identical dicts (perhaps depending upon how the dicts were constructed). Granted, the likelihood of this occurring is very small, so it's not a big deal.

I missed that in the `__eq__`, and it doesn't appear in the public documentation. I'd (very weakly) prefer something at the class level since the players can be viewed outside of the game.

Actually, in order to make the `Player` hashable, they must only compare equal by `name` (since we treat that part as immutable).

Perhaps I'm being too nitpicky.


---

Comment by vinceknight created at 2014-11-18 21:34:30

Replying to [comment:110 tscrim]:
> Replying to [comment:109 kcrisman]:
> > Oh, can you?  I thought it was the other way around, that two games with unequal input data would be the same.
> 
> Well, that was a problem with my first implementation of `__eq__`. I was saying without a `__eq__`, then the pickling issue crops up.
> 
> > In any case, I think that is fixed in [this commit](http://git.sagemath.org/sage.git/commit/?id=7d5d52a738959ba8fde79a60d39eb0fed0156041), and players explained in [this one](http://git.sagemath.org/sage.git/commit/?id=8b049cea8efb051e59af76f3cda5c11e10fbe674) - you can check if you agree with me.
> 
> Currently if you add the suitors (or reviewers) in different order, but everything else is the same, they should compare as not equal (I can't test right now). This should be the same game. What I really worry about is that the iteration over the input dicts might end up being different for two equal but not identical dicts (perhaps depending upon how the dicts were constructed). Granted, the likelihood of this occurring is very small, so it's not a big deal.

I've gone ahead and changed that so the equality of a game now does not require the players to be in the same order (you have to try pretty hard to get a game with players in a different order but I've added one to the docs).

> 
> I missed that in the `__eq__`, and it doesn't appear in the public documentation. I'd (very weakly) prefer something at the class level since the players can be viewed outside of the game.

Given that the `Player` class _can_ be accessed outside of the game but has no reason to actually be manipulated (in practice the average user will just be creating games from dictionaries I imagine) I'd rather keep this where it is so as to not overcomplicate the docs. Going back to accessibility as you mentioned previously Karl, I'd be worried that adding a lot of technical things about the underlying architecture could be a bit confusing... I think this specific thing would be more relevant to future contributors etc and not the day to day user... What do you guys think? 

> 
> Actually, in order to make the `Player` hashable, they must only compare equal by `name` (since we treat that part as immutable).
> 
Cool, on that note: I tried to implement Karl's fix for the dictionaries not being the same across systems. It started confusing me though as it wasn't working. I think I've figured out why: the Players (which are the keys in those dictionaries and not the strings of their names) did not have a 'sorting' method. I've now added this in (https://wiki.python.org/moin/HowTo/Sorting/).

I then thought that that had taken care of it and the dictionaries could stay as they are but I've just checked on my linux box and I'm incorrect so I'm going to work on that tomorrow. I will probably add in a test with a `# random` so as to describe what output would look like before going on to using the `sorted(D.items())` throughout. 

I've got some other stuff that needs doing so I'll go ahead and do that last part tomorrow. Just about to push everything until then now though.

> Perhaps I'm being too nitpicky.

Not at all, please let me know if you disagree :)


---

Comment by git created at 2014-11-18 21:35:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-11-18 21:39:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-11-18 21:48:01

Ok, I'm slightly confused.

I just tried the fix in f361765 on two machines:

- On my macbook: tests pass no problem.
- On my linux box:


```
File "src/sage/game_theory/matching_game.py", line 235, in sage.game_theory.matching_game.MatchingGame
Failed example:
    sorted(D.items())
Expected:
    [('Mercutio', 'Rosaline'), ('Romeo', 'Juliet'), (3, -3)]
Got:
    [(3, -3), ('Mercutio', 'Rosaline'), ('Romeo', 'Juliet')]
```


I then tried loop over keys of the dictionary (which should just be a sortable list (finger crossed?) and output the value of the dictionary for each.

So something like:


```
sage: D = g.solve(
sage: for key in sorted(D.keys()):
....:   key, D[key]
```


I've just tried that with similar (bad) results (fine on MacOS, no joy on Ubuntu):

    for key in sorted(D.keys()):
      key, D[key]
Expected:
    ('Mercutio', 'Rosaline')
    ('Romeo', 'Juliet')
    (3, -3)
Got:
    (3, -3)
    ('Mercutio', 'Rosaline')
    ('Romeo', 'Juliet')

(Just about to push that commit in case it's helpful)

This is obviously quite a particular case with player names being a mixture of numeric and string but still. At the moment I'm a bit baffled... I'm going to sleep on it...


---

Comment by git created at 2014-11-18 21:48:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-11-18 22:03:24

How about trying?

```
sorted(D.items(), key=lambda x: x[0]._name)
```



---

Comment by kcrisman created at 2014-11-19 03:22:12

> I will probably add in a test with a # random so as to describe what output would look like before going on to using the sorted(D.items()) throughout. 

Yes, that is just what you should do.

> sorted(D.items(), key=lambda x: x[0]._name)

If we have to resort to that to get Romeo with Juliet, something is terribly wrong in Verona.  But I think that [this SO question](http://stackoverflow.com/questions/5884066/hashing-a-python-dictionary) might be on the right track, as

> Using sorted(d.items()) isn't enough to get us a stable repr. Some of the values in d could be dictionaries too, and their keys will still come out in an arbitrary order.

And presumably the players are what is being sorted, not their _names_.  I'm not sure what a better solution will be but I really hope it can be something that is intelligible to those newcomers Vincent is mentioning.


---

Comment by tscrim created at 2014-11-19 04:15:28

I wouldn't mark them as `# random`, then the only thing that gets tested is that there is no error returned. If the doctest ordering can't be sorted uniformly, then I'd test specific properties. Although I thought we did something with our doctests involving dicts so that the output was sorted...?


---

Comment by git created at 2014-11-19 07:15:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-11-19 07:26:38

Replying to [comment:118 tscrim]:
> I wouldn't mark them as `# random`, then the only thing that gets tested is that there is no error returned. If the doctest ordering can't be sorted uniformly, then I'd test specific properties. Although I thought we did something with our doctests involving dicts so that the output was sorted...?

I was suggesting the `# random` not from the testing point of view but from a point of view of accessibility of new users viewing the docs and knowing what the output 'should almost certainly look like'. So I'm suggesting putting one of these at the top of the front matter saying something like 'Output of the solve method is a dictionary as shown (the order of this might differ on your machine)::'

I think there is something in the dicts that ensures that output is sorted. This seemed evident when I put in the relevant methods to be able to sort instances of `Players` but it looks like this one very particular example is enough to throw it off where my machine 1 sorted numerical variables before strings and my machine 2 the other way around.

My last commit 821898e I think is the best way to go with this. If the ordered output of a dictionary cannot be guaranteed, the output of a given key of that dictionary certainly can. So I suggest going through each element (manually) and viewing the output. 

So I've gone with:


```
sage: D = g.solve()
sage: D['Mercutio']
sage: 'Rosaline'
sage: D['Romeo']
'Juliet'
sage: D[3]
-3
```


I think that to ensure tests pass on all machines etc this only needs to be done for some of the dictionaries (where strings and numerical variables are mixed) as the dictionaries do seem to be sorted as far as I can see (please correct me if I'm talking nonsense). I don't think it's a big deal to do it for all of the tests though.

I think this has the advantage of being readable and accessible to those reading the docs who don't really know about lambda functions and other subtleties...

I've only done it for the one test (the one causing issues) but throughout the day (am chairing a Careers fair today) I might have some time to jump on the ol' laptop.


---

Comment by tscrim created at 2014-11-19 07:33:16

Perhaps you could use `sorted(d.items(), key=lambda x: repr(x[0])` for that particular case. I think (nearly) all users will know the order doesn't matter (if not, then perhaps in that case we teach them about basic python structures), but I might have been swallowed by the snake too long ago to see things clearly. `:P` Enjoy the career fair, I'm calling it a night and will come back to this tomorrow.


---

Comment by vinceknight created at 2014-11-19 13:48:06

Replying to [comment:121 tscrim]:
> Perhaps you could use `sorted(d.items(), key=lambda x: repr(x[0])` for that particular case. I think (nearly) all users will know the order doesn't matter (if not, then perhaps in that case we teach them about basic python structures), but I might have been swallowed by the snake too long ago to see things clearly. `:P` Enjoy the career fair, I'm calling it a night and will come back to this tomorrow.

That does work but I'd think that it's a bit of a mouthful for people who are just getting to know the snake (so perhaps coming to Sage just to use this aspect: I think I'm talking about a very small minority here but still). I'm happy to leave out the general example of a dictionary tough and just use each key as required. (I might be talking about a different 'particular case' than you were...)

Over the next couple of days (probably lying to myself and will do this sooner as it's more fun than other stuff I have to do) I'll re-write the tests so that they pass on my two machines. Once I push them up you guys can let me know what you think? Actually having things working on my side is probably a good starting point...

Thanks again for the time/help!


---

Comment by kcrisman created at 2014-11-19 13:51:03

I haven't looked at the comments since I last peeked in yet, but apparently you can go back to dictionary form for most of the doctests - see #16746, which Jeroen pointed me to.

However, for Mercutio et al. I'm not sure if this will help, looking into it.

Edit: 
> Although I thought we did something with our doctests involving dicts so that the output was sorted...?
>  as the dictionaries do seem to be sorted as far as I can see 

Yeah, that is what that is, I think.  Sorry for not having been aware of this.

> I think (nearly) all users will know the order doesn't matter
Umm, not even close.  Certainly not people new to programming, and likely not people coming from other languages.  This is actually a relatively subtle point.

That said, for this ONE doctest I think that just checking a few of the elements is fine, because the output style will have been shown in many other examples.  Good idea.


---

Comment by jdemeyer created at 2014-11-19 14:23:54

Suggestion:

```
sage: D = get_strange_dict_with_integers_and_strings()
sage: D == {'Mercutio': 'Rosaline', 'Romeo': 'Juliet', 3: -3}
True
```



---

Comment by kcrisman created at 2014-11-19 14:25:34

> Suggestion:
> {{{
> sage: D = get_strange_dict_with_integers_and_strings()
> sage: D == {'Mercutio': 'Rosaline', 'Romeo': 'Juliet', 3: -3}
> True
> }}}
This seems very useful, thanks!


---

Comment by git created at 2014-11-19 18:57:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-11-19 19:00:50

Ok so I've gone ahead and changed the test in the spots where we had strange dictionaries with a mixture of key types.
They now all pass on both my machines.

I haven't gone with jdemeyer's suggestion (very humbly and of course happy to change it). I felt that going through the keys individually was perhaps more helpful from the point of view of documentation (I agree that from the point of view of tests that the suggestion is better as it corresponds to a single test instead of 3). Let me know what you think.


---

Comment by kcrisman created at 2014-11-19 19:55:16


```
                 and all(r1.pref == r2.pref for r1, r2 in
                     zip(set(self._reviewers), set(other._reviewers)))
```

Doesn't _this_ rely ultimately on `set` ordering things as well?  (Which I don't thin it does.) I'm not trying to annoy - this is really a very minor point at this point, though should be resolved.  Anyway, everything else seems quite fine - currently running tests.


---

Comment by kcrisman created at 2014-11-19 20:27:14

Tests are fine, had an issue with docs building but that is probably unrelated.


---

Comment by kcrisman created at 2014-11-19 20:43:15

Amazingly, there is STILL one tiny doc thing.

```
        If we add a reviewer without passing a name then the name
        of the reviewer will not use one that is already chosen.
```

Needs two colons, like its partner about suitors.  I saw this before but somehow didn't put it in the diff in comment:101.


---

Comment by git created at 2014-11-20 14:58:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vinceknight created at 2014-11-20 15:01:09

Replying to [comment:128 kcrisman]:
> {{{
>                  and all(r1.pref == r2.pref for r1, r2 in
>                      zip(set(self._reviewers), set(other._reviewers)))
> }}}
> Doesn't _this_ rely ultimately on `set` ordering things as well?  (Which I don't thin it does.) I'm not trying to annoy - this is really a very minor point at this point, though should be resolved.  Anyway, everything else seems quite fine - currently running tests.

Not at all annoying: I think we want the same thing which is to get the best possible final version in to Sage - really appreciate everyone's time and effort :)

I did panic here for a bit but I think it's actually ok. The discrepancies in sorting do not happen on a single system: the differences are between two different systems so the way things are sorted on any given Sage session will be the same, right?

Ie I think this is not a problem when it comes to testing equality.

I've just pushed that semicolon change to docs. 

EDIT: Sorry: double colon.


---

Comment by kcrisman created at 2014-11-20 15:15:50

> > {{{
> >                  and all(r1.pref == r2.pref for r1, r2 in
> >                      zip(set(self._reviewers), set(other._reviewers)))
> > }}}
> > Doesn't _this_ rely ultimately on `set` ordering things as well?  (Which I don't thin it does.) I'm not trying to annoy - this is really a very minor point at this point, though should be resolved.  Anyway, everything else seems quite fine - currently running tests.
> I did panic here for a bit but I think it's actually ok. The discrepancies in sorting do not happen on a single system: the differences are between two different systems so the way things are sorted on any given Sage session will be the same, right?

What I meant was that when comparing preferences, it sort of assumes that the ordering of the reviewers in the two games will be the same, relative to their preferences. 

But I think this is okay, because you are only suggesting things be equal if the names are the same, so that e.g. suitors can be added in a different order, but you would only have the games be the same if the names and preferences for that name corresponded, not if the games are _isomorphic_.  Am I right?


---

Comment by vinceknight created at 2014-11-20 15:36:37

Replying to [comment:133 kcrisman]:
> > > {{{
> > >                  and all(r1.pref == r2.pref for r1, r2 in
> > >                      zip(set(self._reviewers), set(other._reviewers)))
> > > }}}
> > > Doesn't _this_ rely ultimately on `set` ordering things as well?  (Which I don't thin it does.) I'm not trying to annoy - this is really a very minor point at this point, though should be resolved.  Anyway, everything else seems quite fine - currently running tests.
> > I did panic here for a bit but I think it's actually ok. The discrepancies in sorting do not happen on a single system: the differences are between two different systems so the way things are sorted on any given Sage session will be the same, right?
> 
> What I meant was that when comparing preferences, it sort of assumes that the ordering of the reviewers in the two games will be the same, relative to their preferences. 
> 
> But I think this is okay, because you are only suggesting things be equal if the names are the same, so that e.g. suitors can be added in a different order, but you would only have the games be the same if the names and preferences for that name corresponded, not if the games are _isomorphic_.  Am I right?

Yeah that's correct (if I'm understanding correctly): the equality is based only on the names (which is because of the underling `sort`methods that the players now have).


---

Comment by kcrisman created at 2014-11-20 16:02:07

Changing status from needs_work to positive_review.


---

Comment by tscrim created at 2014-11-20 16:49:57

For future reference, Karl brings up a good distinction, `==` does not have to mean isomorphic, even for canonical isomorphisms (as often times in Sage, for example `QQ['x','y'] == QQ['y','x']` is `False`).


---

Comment by vbraun created at 2014-11-22 17:18:41

Resolution: fixed
