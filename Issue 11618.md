# Issue 11618: `sage --sh -c ...` shouldn't print [that many] messages

Issue created by migration from Trac.

Original creator: leif

Original creation time: 2011-09-11 15:26:48

CC:  iandrus

Keywords: subshell commands sage-sage environment batch mode stdout

Currently, we have

```sh
$ ./sage --sh -c "echo Hello"

Starting subshell with Sage environment variables set.
Be sure to exit when you are done and do not do anything
with other copies of Sage!

Bypassing shell configuration files ...

Hello
Exited Sage subshell.
$ 
```

which is IMHO odd.

And it's inconvenient if one wants to further process the output of some command run in a Sage subshell.

In `local/bin/sage-sage`, we have:

```sh
if [ "$1" = '-sh'  -o "$1" = '--sh' ]; then
    # AUTHORS:
    #   Carl Witty and William Stein: initial version
    #   Craig Citro: add options for not loading profile
    cd "$CUR"
    shift
    echo ""
    echo "Starting subshell with Sage environment variables set."
    echo "Be sure to exit when you are done and do not do anything"
    echo "with other copies of Sage!"
    echo ""
    SHELL_NAME=`basename $SHELL`
    echo "Bypassing shell configuration files ..."
    echo

    ...

    $SHELL_NAME $SHELL_OPTS "$`@`"

    status=$?
    echo "Exited Sage subshell."
    exit $status
fi
```


So I'd propose to change `sage-sage` to not print _any_ messages if the first argument to the subshell is `-c`.

Alternatively, all (or a reduced set of) messages should at least go to `stderr` instead of `stdout`, perhaps regardless of whether `-c` was specified or not.

In addition, if we dropped the "`Exited Sage subshell.`" (at least in the case of `-c`), we could (or should) also use

```sh
    exec $SHELL_NAME $SHELL_OPTS "$`@`"
```


(Actually, `exec` should be used in a couple of Sage commands which don't need any "post-processing", e.g. by `sage-sage`.)


---

Comment by jhpalmieri created at 2011-09-13 01:32:39

Here's a first attempt at a patch.  This also fixes some of incorrect prompts (taken from #10822 -- the patch there will need to be rebased on this one if this one gets done first).


---

Comment by jhpalmieri created at 2011-09-13 01:32:39

Changing status from new to needs_review.


---

Comment by jhpalmieri created at 2011-09-28 20:49:21

New patch rebased w.r.t. #11866.


---

Comment by leif created at 2011-09-28 21:10:41

Looks ok, but I cannot tell (or test right now) whether all prompts, and shell options regarding not executing rc files are correct.

The code testing for `-c` could be moved up, since everything else (in the `case ... esac`) is useless in this case .

Also, if `exec` returns, this means an error, so we could print some according message in this case (although _hopefully_<sup>TM</sup> the shell itself did).


---

Comment by jhpalmieri created at 2011-09-28 21:29:28

Replying to [comment:3 leif]:
> Looks ok, but I cannot tell (or test right now) whether all prompts, and shell options regarding not executing rc files are correct.

On my Mac, I was able to run "chsh" and then open up new terminal windows and run "sage -sh" to test the prompts.

> The code testing for `-c` could be moved up, since everything else (in the `case ... esac`) is useless in this case .

Well, if you're running "sage --sh CMD", it should matter whether you're running "bash" or "bash --norc", right?  The `case ... esac` stuff sets shell options like `--norc` in addition to the prompt, and I think we want this.

> Also, if `exec` returns, this means an error, so we could print some according message in this case (although _hopefully_<sup>TM</sup> the shell itself did).

So are you suggesting not checking the status at all? Like this:

```diff
diff --git a/sage-sage b/sage-sage
--- a/sage-sage
+++ b/sage-sage
`@``@` -518,8 +518,8 `@``@` PS1="SAGE_ROOT=${SAGE_ROOT}
     esac
     if [ "$1" = '-c' ]; then
        exec $SHELL_NAME $SHELL_OPTS "$`@`"
-       status=$?
-       exit $status
+       echo "An error seems to occurred." 1>&2
+       exit 1
     fi
     # -c is not the first option, so print informative messages...
     echo "" 1>&2
```

I could probably come up with a more cryptic message, though.


---

Comment by jhpalmieri created at 2011-09-28 21:30:42

s/to occurred/to have occurred/, obviously.


---

Comment by leif created at 2011-09-28 21:54:07

Replying to [comment:4 jhpalmieri]:
> Replying to [comment:3 leif]:
> > The code testing for `-c` could be moved up, since everything else (in the `case ... esac`) is useless in this case .
> 
> Well, if you're running "sage --sh CMD", it should matter whether you're running "bash" or "bash --norc", right?  The `case ... esac` stuff sets shell options like `--norc` in addition to the prompt, and I think we want this.

Any shell called with `-c` *must not* execute any rc files.




> > Also, if `exec` returns, this means an error, so we could print some according message in this case (although _hopefully_<sup>TM</sup> the shell itself did).
> 
> So are you suggesting not checking the status at all? Like this:

```diff
diff --git a/sage-sage b/sage-sage
--- a/sage-sage
+++ b/sage-sage
`@``@` -518,8 +518,8 `@``@` PS1="SAGE_ROOT=${SAGE_ROOT}
     esac
     if [ "$1" = '-c' ]; then
        exec $SHELL_NAME $SHELL_OPTS "$`@`"
-       status=$?
-       exit $status
+       echo "An error seems to occurred." 1>&2
+       exit 1
     fi
     # -c is not the first option, so print informative messages...
     echo "" 1>&2
```

> I could probably come up with a more cryptic message, though.

:)

I rather meant something like

```sh
    ...
    SHELL_NAME=`basename $SHELL`

    if [ "$1" = "-c" ]; then
        exec "$SHELL_NAME" "$`@`"
        # If 'exec' returns, an error occurred:
        status=$?
        echo >&2 "Fatal error: 'exec \"$SHELL_NAME\" \"$`@`\"' failed!"
        exit $status # Always non-zero, but return the code the shell gave.
    fi

    case $SHELL_NAME in
    ...
```





Btw., any reason to call `$SHELL_NAME` instead of `$SHELL`?

The latter would IMHO be correct.


---

Comment by jhpalmieri created at 2011-09-29 05:13:56

Here's a new patch.


---

Comment by jhpalmieri created at 2011-09-29 05:14:11

scripts repo


---

Attachment

Both `$SHELL` and `$SHELL_NAME` should in principle be quoted... ;-)


---

Comment by jhpalmieri created at 2011-09-29 05:25:08

Like this?

```diff
diff --git a/sage-sage b/sage-sage
--- a/sage-sage
+++ b/sage-sage
`@``@` -473,7 +473,7 `@``@` if [ "$1" = '-sh'  -o "$1" = '--sh' ]; t
     cd "$CUR"
     shift
     if [ "$1" = '-c' ]; then
-       exec $SHELL "$`@`"
+       exec "$SHELL" "$`@`"
         # If 'exec' returns, an error occurred:
         status=$?
         echo >&2 "Fatal error: 'exec \"$SHELL\" \"$`@`\"' failed!"
`@``@` -489,8 +489,8 `@``@` if [ "$1" = '-sh'  -o "$1" = '--sh' ]; t
     echo "" 1>&2
     # We must start a new shell with no .profile or .bashrc files
     # processed, so that we know our path is correct
-    SHELL_NAME=`basename $SHELL`
-    case $SHELL_NAME in
+    SHELL_NAME=`basename "$SHELL"`
+    case "$SHELL_NAME" in
         bash)
             SHELL_OPTS=" --norc"
             PS1="SAGE_ROOT=${SAGE_ROOT}\n(sage subshell) \h:\W \u\$ "
`@``@` -531,7 +531,7 `@``@` PS1="SAGE_ROOT=${SAGE_ROOT}
             echo >&2 "Aborting."
             exit 1
     esac
-    $SHELL $SHELL_OPTS "$`@`"
+    "$SHELL" $SHELL_OPTS "$`@`"
     status=$?
     echo "Exited Sage subshell." 1>&2
     exit $status
```

Let's make this v2 of the patch.


---

Attachment

scripts repo


---

Comment by leif created at 2011-09-29 05:41:23

Replying to [comment:9 jhpalmieri]:
> Like this?

Yep. As a MacOS user, you should be familiar with spaces in filenames... ;-)


---

Comment by jdemeyer created at 2011-10-31 12:10:20

I would prefer not to special-case `-c` and print the "informative" messages only when _no arguments_ are given.

Second, please get rid of the double-line prompt.  I find that so confusing.  No need to print `SAGE_ROOT` on every prompt (maybe print it once in the "informative" messages).


---

Comment by jdemeyer created at 2011-10-31 12:10:20

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2011-10-31 12:13:03

Third, now that you are working on this: it is absolutely wrong to assume that `/bin/sh` supports `--norc`.  I would not make any assumptions at all about which shell is `/bin/sh`, so I would set no options for `sh`.


---

Comment by leif created at 2011-10-31 20:35:12

Replying to [comment:11 jdemeyer]:
> I would prefer not to special-case `-c` and print the "informative" messages only when _no arguments_ are given.
> 
> Second, please get rid of the double-line prompt.  I find that so confusing.  No need to print `SAGE_ROOT` on every prompt (maybe print it once in the "informative" messages).

+N (N>=1)

I always found that annoying, but hesitated to change it since others might argue that it may be helpful to "less experienced users"<sup>TM</sup>.

(One reason I hardly ever use the Sage subshell... ;-) )


---

Comment by leif created at 2011-10-31 20:40:07

Replying to [comment:11 jdemeyer]:
> I would prefer not to special-case `-c` and print the "informative" messages only when _no arguments_ are given.

Well, other options could be passed such that the shell would still be interactive.

In that case, the "informative messages" should probably still get printed.


---

Comment by jhpalmieri created at 2011-10-31 21:13:10

I wouldn't mind shortening the prompt to one line, but I'd like to get more feedback, so I asked the question on sage-devel.

If it is shortened, should we do more to highlight that we're in a subshell?  The following shortens "(sage subshell)" to "(Sage)" and puts in reverse video.  We could use boldface if reverse video is too obnoxious.

```diff

diff --git a/sage-sage b/sage-sage
--- a/sage-sage
+++ b/sage-sage
`@``@` -490,10 +491,19 `@``@` if [ "$1" = '-sh'  -o "$1" = '--sh' ]; t
     # We must start a new shell with no .profile or .bashrc files
     # processed, so that we know our path is correct
     SHELL_NAME=`basename "$SHELL"`
+    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
+        color_prompt=yes
+    else
+        color_prompt=
+    fi
     case "$SHELL_NAME" in
         bash)
             SHELL_OPTS=" --norc"
-            PS1="SAGE_ROOT=${SAGE_ROOT}\n(sage subshell) \h:\W \u\$ "
+            if [ "$color_prompt" = yes ] ; then
+                PS1="\[$(tput rev)\](Sage)\[$(tput sgr0)\] \h:\W \u\$ "
+            else
+                PS1="(Sage) \h:\W \u\$ "
+            fi
             export PS1
             ;;
         csh)
`@``@` -504,14 +514,18 `@``@` if [ "$1" = '-sh'  -o "$1" = '--sh' ]; t
             ;;
         ksh)
             SHELL_OPTS=" -p"
-            PS1="SAGE_ROOT=${SAGE_ROOT}
-(sage subshell) `hostname -s`:\${PWD##*/} $USER$ "
+            if [ "$color_prompt" = yes ] ; then
+                PS1="\[$(tput rev)\](Sage)\[$(tput sgr0)\] `hostname -s`:\${PWD##*/} $USER$ "
+            else
+                PS1="(Sage) `hostname -s`:\${PWD##*/} $USER$ "
+            fi
             export PS1
             ;;
         sh)
-            SHELL_OPTS=" --norc"
-            PS1="SAGE_ROOT=${SAGE_ROOT}
-(sage subshell) `hostname -s`:\${PWD##*/} $USER$ "
+            # If sh is derived from bash, then the following is okay,
+            # but we shouldn't assume this.
+            #SHELL_OPTS=" --norc"
+            PS1="(Sage) `hostname -s`:\${PWD##*/} $USER$ "
             export PS1
             ;;
         tcsh)
`@``@` -521,8 +535,11 `@``@` if [ "$1" = '-sh'  -o "$1" = '--sh' ]; t
             SHELL_OPTS=" -f"
             ;;
         zsh)
```



---

Comment by jhpalmieri created at 2011-10-31 21:58:43

Simon King had the interesting suggestion of prepending e.g. "(sage-sh)" to the current prompt.  Can we access the current prompt?


---

Comment by jdemeyer created at 2011-10-31 22:29:13

Replying to [comment:16 jhpalmieri]:
> Simon King had the interesting suggestion of prepending e.g. "(sage-sh)" to the current prompt.  Can we access the current prompt?

Well, `$PS1` is the current prompt.  So you could do


```
export PS1="(sage-sh) $PS1"
```



---

Comment by jdemeyer created at 2011-10-31 22:32:22

Replying to [comment:14 leif]:
> Replying to [comment:11 jdemeyer]:
> > I would prefer not to special-case `-c` and print the "informative" messages only when _no arguments_ are given.
> 
> Well, other options could be passed such that the shell would still be interactive.

On the other hand, other options (e.g. the name of a script) could be passed such that the shell would _not_ be interactive.  I would say that any option passed qualifies as "advanced usage" meaning the user knows what he is doing and does not need "informative" messages.


---

Comment by jhpalmieri created at 2011-10-31 22:35:56

Replying to [comment:17 jdemeyer]:
> Well, `$PS1` is the current prompt.  So you could do

I tried that but it doesn't seem to work: $PS1 is not defined when running sage-sage: add a line `echo "current prompt is $PS1"` somewhere.


---

Comment by leif created at 2011-10-31 23:40:37

I don't like playing with "fancy" prompts.

If someone needs such, we could support `SAGE_SHELL_PROMPT` or whatever.

(Ceterum censeo we should support `~/.sagerc` [or `$DOT_SAGE/.sagerc` or both], or `~/.sageshrc`, for common environment settings etc., i.e., this should be a shell script which is sourced by `sage-env` if present.)


---

Comment by jhpalmieri created at 2011-11-01 20:38:31

Here is version 3 of the patch.  This implements Leif's idea about ./sage/.sagerc, in a simple-minded way.  It also checks for the environment variable `SAGE_SHPROMPT`.

My opinion is that the prompt for the Sage shell should indicate *very clearly* that this is a Sage shell, so the default in this patch is for it to start with "(sage-sh)" in reverse video.  If you don't like it, you can override it by setting `PS1` in .sagerc or by setting `SAGE_SHPROMPT` anywhere.

This also doesn't print any warning message or even set the prompt if `sage -sh` is followed by more arguments.  I'm not sure I'm happy about that, in particular the potential lack of a different prompt.


---

Comment by jhpalmieri created at 2011-11-01 20:38:31

Changing status from needs_work to needs_review.


---

Comment by jhpalmieri created at 2011-11-01 20:53:25

Okay, I changed it so it sets the prompt regardless of the number of arguments.


---

Attachment

scripts repo


---

Comment by jdemeyer created at 2012-02-26 09:26:51

Changing priority from minor to blocker.


---

Comment by jdemeyer created at 2012-03-09 20:51:17

I think adding a `sagerc` file warrants its own ticket: #12647.


---

Comment by jdemeyer created at 2012-03-09 20:53:14

Changing status from needs_review to needs_work.


---

Attachment


---

Comment by jdemeyer created at 2012-03-09 21:30:53

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2012-03-09 21:32:05

Reviewer patch needs review...


---

Comment by jdemeyer created at 2012-03-13 17:03:52

Adding a sagerc script (#12637) needs review.


---

Comment by jdemeyer created at 2012-03-13 17:04:25

I meant #12647.


---

Comment by jhpalmieri created at 2012-03-14 18:23:34

Changing status from needs_review to positive_review.


---

Comment by jhpalmieri created at 2012-03-14 18:23:34

This looks good to me.

Regarding the use of "exec", which was suggested by Leif, was in my version of the patch, and is in the current patch: if we want to be able to do something like `sage --norc -c ...` (as in #11932), then we want to be able to delete the temporary `DOTSAGE` directory after the Sage command finishes.  Using "exec" prevents this, doesn't it?  So unless I'm misunderstanding and there is a good way to clean things up after "exec CMD", we should be wary of overusing "exec" in the sage script.

Anyway, I'm willing to give this a positive review.


---

Comment by jdemeyer created at 2012-03-14 19:41:48

Replying to [comment:32 jhpalmieri]:
> Regarding the use of "exec", which was suggested by Leif, was in my version of the patch, and is in the current patch: if we want to be able to do something like `sage --norc -c ...` (as in #11932), then we want to be able to delete the temporary `DOTSAGE` directory after the Sage command finishes.  Using "exec" prevents this, doesn't it?
Using `exec` *here* doesn't prevent that.  It just means that we cannot implement `--norc` itself using `exec`, which is fine.

Example:
scriptA does

```
scriptB
cleanup
```


scriptB does

```
exec scriptC
cleanup2
```


The `exec` in `scriptB` doesn't prevent the `cleanup` in `scriptA`, it only prevents the `cleanup2` in `scriptB`.


---

Comment by jhpalmieri created at 2012-03-14 20:35:08

Right, but suppose we do something like this:

```
if [ "$1" = '--norc' -o "$1" = '--nodotsage' ]; then
    export DOT_SAGE=`mktemp -d ${TMPDIR:-/tmp}/dotsageXXXXXX`
    shift
    sage "$`@`"
    status=$?
    rm -rf "$DOT_SAGE"
    exit $status
fi
```

Then if you do `sage --norc --sh ...` (or any other option like `--sh` which uses `exec`), it will never reach the line `rm -rf "$DOT_SAGE"`.


---

Comment by jdemeyer created at 2012-03-14 20:40:04

Replying to [comment:34 jhpalmieri]:
> Then if you do `sage --norc --sh ...` (or any other option like `--sh` which uses `exec`), it will never reach the line `rm -rf "$DOT_SAGE"`.
That would be very surprising, are you sure about this?


---

Comment by jhpalmieri created at 2012-03-14 20:45:55

No, I'm not sure about this - it seems to work the way we want, and as described in [comment:33 your comment]. Never mind.


---

Comment by jdemeyer created at 2012-03-19 15:07:01

See #12698 for a sort-of follow-up.


---

Comment by jdemeyer created at 2012-03-21 22:05:42

Resolution: fixed
