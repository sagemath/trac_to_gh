# Issue 11607: python ints vs sage ints with respect to powers weirdness

archive/issues_011607.json:
```json
{
    "body": "Assignee: AlexGhitza\n\nCC:  rkirov simonking\n\n\n```\nprint type(int(3) + 3)\nprint type(int(3) * 3)\nprint type(3 ^ int(3))\nprint type(int(3) ^ 3)\n```\n\nfirst three are Sage Integers but last one is just a Python int.\nWorse still:\n\n```\nsage: int(3)^-3 \n0.037037037037037035 \nsage: type(int(3)^-3) \n<type 'float'> \nsage: int(3)^QQ(-3) \n1/27 \nsage: type(int(3)^QQ(-3)) \n<type 'sage.rings.rational.Rational'>\n```\n\nis very inconsistent.\n\nIssue created by migration from https://trac.sagemath.org/ticket/11779\n\n",
    "created_at": "2011-09-05T12:47:10Z",
    "labels": [
        "basic arithmetic",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-4.7.2",
    "title": "python ints vs sage ints with respect to powers weirdness",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11607",
    "user": "dimpase"
}
```
Assignee: AlexGhitza

CC:  rkirov simonking


```
print type(int(3) + 3)
print type(int(3) * 3)
print type(3 ^ int(3))
print type(int(3) ^ 3)
```

first three are Sage Integers but last one is just a Python int.
Worse still:

```
sage: int(3)^-3 
0.037037037037037035 
sage: type(int(3)^-3) 
<type 'float'> 
sage: int(3)^QQ(-3) 
1/27 
sage: type(int(3)^QQ(-3)) 
<type 'sage.rings.rational.Rational'>
```

is very inconsistent.

Issue created by migration from https://trac.sagemath.org/ticket/11779





---

archive/issue_comments_131038.json:
```json
{
    "body": "Attachment [trac_1779.patch](tarball://root/attachments/some-uuid/ticket11779/trac_1779.patch) by dimpase created at 2011-09-05 12:58:21",
    "created_at": "2011-09-05T12:58:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131038",
    "user": "dimpase"
}
```

Attachment [trac_1779.patch](tarball://root/attachments/some-uuid/ticket11779/trac_1779.patch) by dimpase created at 2011-09-05 12:58:21



---

archive/issue_comments_131039.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2011-09-05T12:58:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131039",
    "user": "dimpase"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_131040.json:
```json
{
    "body": "So what do you expect the result types to be?\n\nIMHO the fact that `3r^3` yields a Python `int` is pretty correct; with negative exponents the interpretation is less straightforward.\n\nI'd interpret `int(x)^(-any)` as `(int(1)/int(x))^(any)`, so the result should be `float` if `any` is positive.",
    "created_at": "2011-09-05T13:03:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131040",
    "user": "leif"
}
```

So what do you expect the result types to be?

IMHO the fact that `3r^3` yields a Python `int` is pretty correct; with negative exponents the interpretation is less straightforward.

I'd interpret `int(x)^(-any)` as `(int(1)/int(x))^(any)`, so the result should be `float` if `any` is positive.



---

archive/issue_comments_131041.json:
```json
{
    "body": "Replying to [comment:3 leif]:\n> So what do you expect the result types to be?\n> \n> IMHO the fact that `3r^3` yields a Python `int` is pretty correct; with negative exponents the interpretation is less straightforward.\n\nin all other operations (see the ticket description), \nthe Sage type takes the precedence over Python. I certainly don't mind `int(3)^int(3)` being int though.\nin fact, with the patch applied, the behaviour is as follows:\n\n```\nsage: type(int(3)^3)\n<type 'sage.rings.integer.Integer'>\nsage: type(int(3)^int(3))\n<type 'int'>\nsage: type(int(3)^int(-3))\n<type 'float'>\nsage: type(int(3)^-3)\n<type 'sage.rings.rational.Rational'> \n```\n\n\nthis is the behaviour that is much less confusing.",
    "created_at": "2011-09-05T13:48:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131041",
    "user": "dimpase"
}
```

Replying to [comment:3 leif]:
> So what do you expect the result types to be?
> 
> IMHO the fact that `3r^3` yields a Python `int` is pretty correct; with negative exponents the interpretation is less straightforward.

in all other operations (see the ticket description), 
the Sage type takes the precedence over Python. I certainly don't mind `int(3)^int(3)` being int though.
in fact, with the patch applied, the behaviour is as follows:

```
sage: type(int(3)^3)
<type 'sage.rings.integer.Integer'>
sage: type(int(3)^int(3))
<type 'int'>
sage: type(int(3)^int(-3))
<type 'float'>
sage: type(int(3)^-3)
<type 'sage.rings.rational.Rational'> 
```


this is the behaviour that is much less confusing.



---

archive/issue_comments_131042.json:
```json
{
    "body": "Replying to [comment:4 dimpase]:\n> Replying to [comment:3 leif]:\n> > So what do you expect the result types to be?\n> > \n> > IMHO the fact that `3r^3` yields a Python `int` is pretty correct; with negative exponents the interpretation is less straightforward.\n> \n> in all other operations (see the ticket description), \n> the Sage type takes the precedence over Python.\n\nExponentiation is different, i.e., the *type* of the exponent doesn't matter at all, only its value.\n\n\n\n\n> I certainly don't mind `int(3)^int(3)` being int though.\n\nWhy should one?\n\n\n\n\n> in fact, with the patch applied, the behaviour is as follows:\n\n```\n...\nsage: type(int(3)^3)\n<type 'sage.rings.integer.Integer'>\n...\n```\n\nwhich is simply wrong, because `3r^3` is `3r * 3r * 3r`, so the type of the result should be the *base's* type (unless the result is not an integer, in which case Python's rules should apply, leading to a `float` result.)\n\nThe following is equally wrong for the same reason. (**This** is a bug.)\n> \n\n```\nsage: type(int(3)^-3)\n<type 'sage.rings.rational.Rational'> \n```\n\n\n> this is the behaviour that is much less confusing.\n\nLess confusing to whom? Honestly, every school child should know the difference.\n\nOk, one could argue that `3r * 3` could be interpreted as `3r + 3r + 3r` as well (leading to result type `int` rather than `Integer`), but this would break commutativity.\n\n\nWorth a discussion on sage-devel... (quite curious of the opinions :P )",
    "created_at": "2011-09-05T14:17:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131042",
    "user": "leif"
}
```

Replying to [comment:4 dimpase]:
> Replying to [comment:3 leif]:
> > So what do you expect the result types to be?
> > 
> > IMHO the fact that `3r^3` yields a Python `int` is pretty correct; with negative exponents the interpretation is less straightforward.
> 
> in all other operations (see the ticket description), 
> the Sage type takes the precedence over Python.

Exponentiation is different, i.e., the *type* of the exponent doesn't matter at all, only its value.




> I certainly don't mind `int(3)^int(3)` being int though.

Why should one?




> in fact, with the patch applied, the behaviour is as follows:

```
...
sage: type(int(3)^3)
<type 'sage.rings.integer.Integer'>
...
```

which is simply wrong, because `3r^3` is `3r * 3r * 3r`, so the type of the result should be the *base's* type (unless the result is not an integer, in which case Python's rules should apply, leading to a `float` result.)

The following is equally wrong for the same reason. (**This** is a bug.)
> 

```
sage: type(int(3)^-3)
<type 'sage.rings.rational.Rational'> 
```


> this is the behaviour that is much less confusing.

Less confusing to whom? Honestly, every school child should know the difference.

Ok, one could argue that `3r * 3` could be interpreted as `3r + 3r + 3r` as well (leading to result type `int` rather than `Integer`), but this would break commutativity.


Worth a discussion on sage-devel... (quite curious of the opinions :P )



---

archive/issue_comments_131043.json:
```json
{
    "body": "Changing component from basic arithmetic to coercion.",
    "created_at": "2011-09-05T14:17:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131043",
    "user": "leif"
}
```

Changing component from basic arithmetic to coercion.



---

archive/issue_comments_131044.json:
```json
{
    "body": "Replying to [comment:5 leif]:\n> Replying to [comment:4 dimpase]:\n> > [...]\n> (**This** is a bug.)\n> > \n\n```\nsage: type(int(3)^-3)\n<type 'sage.rings.rational.Rational'> \n```\n\n\nI meant `type(int(3)^QQ(-3))` not being `float` is a bug (currently in Sage).\n\nWe furthermore currently have:\n\n```\nsage: type(int(3)^QQ(-3))\n<type 'sage.rings.rational.Rational'>\nsage: type(int(3)^ZZ(-3))\n<type 'float'>\n```\n\nwhich is obviously inconsistent, where IMHO the latter *is* correct, but not the former.\n\n(Nevertheless, I *know* mathematicians tend to care less about types... ;-) )",
    "created_at": "2011-09-05T14:33:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131044",
    "user": "leif"
}
```

Replying to [comment:5 leif]:
> Replying to [comment:4 dimpase]:
> > [...]
> (**This** is a bug.)
> > 

```
sage: type(int(3)^-3)
<type 'sage.rings.rational.Rational'> 
```


I meant `type(int(3)^QQ(-3))` not being `float` is a bug (currently in Sage).

We furthermore currently have:

```
sage: type(int(3)^QQ(-3))
<type 'sage.rings.rational.Rational'>
sage: type(int(3)^ZZ(-3))
<type 'float'>
```

which is obviously inconsistent, where IMHO the latter *is* correct, but not the former.

(Nevertheless, I *know* mathematicians tend to care less about types... ;-) )



---

archive/issue_comments_131045.json:
```json
{
    "body": "Also\n\n```\nsage: type(int(3)^RR(-3))\n<type 'sage.rings.real_mpfr.RealNumber'>\n```\n\nis wrong.\n\nWorse:\n\n```\nsage: type(int(3)^RR(3))\n<type 'sage.rings.real_mpfr.RealNumber'>\n```\n\nMuch worse:\n\n```\nsage: type(int(3)^CC(3))\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n\n/tmp/Sage/sage-4.7.2.alpha2/devel/sage-11778/<ipython console> in <module>()\n\n/tmp/Sage/sage-4.7.2.alpha2/local/lib/python2.6/site-packages/sage/rings/complex_number.so in sage.rings.complex_number.ComplexNumber.__pow__ (sage/rings/complex_number.c:6289)()\n\nAttributeError: 'int' object has no attribute 'log'\n```\n",
    "created_at": "2011-09-05T14:41:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131045",
    "user": "leif"
}
```

Also

```
sage: type(int(3)^RR(-3))
<type 'sage.rings.real_mpfr.RealNumber'>
```

is wrong.

Worse:

```
sage: type(int(3)^RR(3))
<type 'sage.rings.real_mpfr.RealNumber'>
```

Much worse:

```
sage: type(int(3)^CC(3))
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)

/tmp/Sage/sage-4.7.2.alpha2/devel/sage-11778/<ipython console> in <module>()

/tmp/Sage/sage-4.7.2.alpha2/local/lib/python2.6/site-packages/sage/rings/complex_number.so in sage.rings.complex_number.ComplexNumber.__pow__ (sage/rings/complex_number.c:6289)()

AttributeError: 'int' object has no attribute 'log'
```




---

archive/issue_comments_131046.json:
```json
{
    "body": "Replying to [comment:6 leif]:\n> (Nevertheless, I *know* mathematicians tend to care less about types... ;-) )\n\nActually, I'd guess that mathematicians tend to prefer Sage Integer over Python int, since they are sceptical about int overflow...",
    "created_at": "2011-09-05T14:43:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131046",
    "user": "SimonKing"
}
```

Replying to [comment:6 leif]:
> (Nevertheless, I *know* mathematicians tend to care less about types... ;-) )

Actually, I'd guess that mathematicians tend to prefer Sage Integer over Python int, since they are sceptical about int overflow...



---

archive/issue_comments_131047.json:
```json
{
    "body": "I agree with leif. I think any in \"int(3)^any\" should be converted to an integer n (or -n), and then int(3)^any equals int(3) multiplied n times with itself (or numerical inverse of int(3) multiplied n times with itself). Thus int(3)^any is of type float always. If any cannot be converted to an integer, then an exception should be raised.\n\nThus int(3)^3, int(3)^QQ(3), int(3)^ZZ(3), int(3)^CC(3) all results in Pythonic integer 27. int(3)^-3, int(3)^QQ(-3), int(3)^ZZ(-3), int(3)^CC(-3) all results in Pythonic float 0.037037037037037028. \n\nBy the way, I think there is nothing wrong with this\n\n```\nsage: p(x)=x^-3\nsage: p(int(3))\n1/27\n```\n\nbecause int(3) is converted to a Sage expression first. See\n\n```\nsage: q(x)=x\nsage: type(q(int(3)))\n<type 'sage.symbolic.expression.Expression'>\n```\n\n\nSo I think this ticket and the patch is misdirected.",
    "created_at": "2011-09-06T09:29:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131047",
    "user": "klee"
}
```

I agree with leif. I think any in "int(3)^any" should be converted to an integer n (or -n), and then int(3)^any equals int(3) multiplied n times with itself (or numerical inverse of int(3) multiplied n times with itself). Thus int(3)^any is of type float always. If any cannot be converted to an integer, then an exception should be raised.

Thus int(3)^3, int(3)^QQ(3), int(3)^ZZ(3), int(3)^CC(3) all results in Pythonic integer 27. int(3)^-3, int(3)^QQ(-3), int(3)^ZZ(-3), int(3)^CC(-3) all results in Pythonic float 0.037037037037037028. 

By the way, I think there is nothing wrong with this

```
sage: p(x)=x^-3
sage: p(int(3))
1/27
```

because int(3) is converted to a Sage expression first. See

```
sage: q(x)=x
sage: type(q(int(3)))
<type 'sage.symbolic.expression.Expression'>
```


So I think this ticket and the patch is misdirected.



---

archive/issue_comments_131048.json:
```json
{
    "body": "(Sorry for badly formated comment) I agree with leif. I think any in `int(3)^any` should be converted to an integer n (or -n), and then `int(3)^any` equals `int(3)` multiplied n times with itself (or numerical inverse of `int(3)` multiplied n times with itself). Thus `int(3)^any` is of type float always. If any cannot be converted to an integer, then an exception should be raised.\n\nThus `int(3)^3`, `int(3)^QQ(3)`, `int(3)^ZZ(3)`, `int(3)^CC(3)` all result in Pythonic integer `27`, and `int(3)^-3`, `int(3)^QQ(-3)`, `int(3)^ZZ(-3)`, `int(3)^CC(-3)` all result in Pythonic float `0.037037037037037028`.\n\nBy the way, I think there is nothing wrong with this\n\n```\nsage: p(x)=x^-3\nsage: p(int(3))\n1/27\n```\n\nbecause `int(3)` is converted to a Sage expression first. See\n\n```\nsage: q(x)=x\nsage: type(q(int(3)))\n<type 'sage.symbolic.expression.Expression'>\n```\n\nSo I think this ticket and the patch is misdirected.",
    "created_at": "2011-09-06T09:35:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131048",
    "user": "klee"
}
```

(Sorry for badly formated comment) I agree with leif. I think any in `int(3)^any` should be converted to an integer n (or -n), and then `int(3)^any` equals `int(3)` multiplied n times with itself (or numerical inverse of `int(3)` multiplied n times with itself). Thus `int(3)^any` is of type float always. If any cannot be converted to an integer, then an exception should be raised.

Thus `int(3)^3`, `int(3)^QQ(3)`, `int(3)^ZZ(3)`, `int(3)^CC(3)` all result in Pythonic integer `27`, and `int(3)^-3`, `int(3)^QQ(-3)`, `int(3)^ZZ(-3)`, `int(3)^CC(-3)` all result in Pythonic float `0.037037037037037028`.

By the way, I think there is nothing wrong with this

```
sage: p(x)=x^-3
sage: p(int(3))
1/27
```

because `int(3)` is converted to a Sage expression first. See

```
sage: q(x)=x
sage: type(q(int(3)))
<type 'sage.symbolic.expression.Expression'>
```

So I think this ticket and the patch is misdirected.



---

archive/issue_comments_131049.json:
```json
{
    "body": "Replying to [comment:14 klee]:\n> (Sorry for badly formated comment) I agree with leif. I think any in `int(3)^any` should be converted to an integer n (or -n), and then `int(3)^any` equals `int(3)` multiplied n times with itself (or numerical inverse of `int(3)` multiplied n times with itself). \n\nWhat do you mean by \"numerical inverse\", and why you think this is the right precedence for operations? Leif here gives arguments based on algebraic properties, so it should be, for algebraic consistency that he cares about so much, that `int(3)<sup>-3==int(1)/int(3)</sup>3`, but this is\nnot the case now, as Python 2 will convert 1/27 to 0.\n\nI advocate the rule that a binary operation involving a Sage integer and a Python int should always produce a Sage type, as this is the case with all the other binary operations. Do you like this?\n\nTo me, your and Leif's arguments read as \"I prefer the status quo to making Sage a more consistent system\".",
    "created_at": "2011-09-06T09:54:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131049",
    "user": "dimpase"
}
```

Replying to [comment:14 klee]:
> (Sorry for badly formated comment) I agree with leif. I think any in `int(3)^any` should be converted to an integer n (or -n), and then `int(3)^any` equals `int(3)` multiplied n times with itself (or numerical inverse of `int(3)` multiplied n times with itself). 

What do you mean by "numerical inverse", and why you think this is the right precedence for operations? Leif here gives arguments based on algebraic properties, so it should be, for algebraic consistency that he cares about so much, that `int(3)<sup>-3==int(1)/int(3)</sup>3`, but this is
not the case now, as Python 2 will convert 1/27 to 0.

I advocate the rule that a binary operation involving a Sage integer and a Python int should always produce a Sage type, as this is the case with all the other binary operations. Do you like this?

To me, your and Leif's arguments read as "I prefer the status quo to making Sage a more consistent system".



---

archive/issue_comments_131050.json:
```json
{
    "body": "Replying to [comment:15 dimpase]:\n> Leif here gives arguments based on algebraic properties, so it should be, for algebraic consistency that he cares about so much, that `int(3)<sup>-3==int(1)/int(3)</sup>3`, but this is\n> not the case now, as Python 2 will convert 1/27 to 0.\n\nWhat makes you think I meant Python's broken `/` operator on `int`s? As I said on sage-devel, the behaviour of that operator on `int`s is useless since there's explicit truncating integer division already, namely `//`.\n\n> I advocate the rule that a binary operation involving a Sage integer and a Python int should always produce a Sage type, as this is the case with all the other binary operations.\n\nThe notion of \"binary operations\" has no meaning in this context, as the desired behaviour w.r.t. result types should depend on the definition of the function, especially its commonly used signature, not its arity.\n\nFor exponentiation, the *type* of the exponent is irrelevant, only its *value* matters to deduce the type of the result of the operation, just like for shift operations (which of course aren't commutative either).\n\nOr would you say `type( value << shift )` should depend on the type of `shift`?\n\nThis might perhaps look \"consistent\" from a syntactical point of view, but simply isn't sound, i.e. doesn't make any sense in the semantic domain.  \n\n> To me, your and Leif's arguments read as \"I prefer the status quo to making Sage a more consistent system\".\n\nDefinitely not, since there are a lot of inconsistencies already which should IMHO be fixed, but not in the way you propose.",
    "created_at": "2011-09-06T10:41:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131050",
    "user": "leif"
}
```

Replying to [comment:15 dimpase]:
> Leif here gives arguments based on algebraic properties, so it should be, for algebraic consistency that he cares about so much, that `int(3)<sup>-3==int(1)/int(3)</sup>3`, but this is
> not the case now, as Python 2 will convert 1/27 to 0.

What makes you think I meant Python's broken `/` operator on `int`s? As I said on sage-devel, the behaviour of that operator on `int`s is useless since there's explicit truncating integer division already, namely `//`.

> I advocate the rule that a binary operation involving a Sage integer and a Python int should always produce a Sage type, as this is the case with all the other binary operations.

The notion of "binary operations" has no meaning in this context, as the desired behaviour w.r.t. result types should depend on the definition of the function, especially its commonly used signature, not its arity.

For exponentiation, the *type* of the exponent is irrelevant, only its *value* matters to deduce the type of the result of the operation, just like for shift operations (which of course aren't commutative either).

Or would you say `type( value << shift )` should depend on the type of `shift`?

This might perhaps look "consistent" from a syntactical point of view, but simply isn't sound, i.e. doesn't make any sense in the semantic domain.  

> To me, your and Leif's arguments read as "I prefer the status quo to making Sage a more consistent system".

Definitely not, since there are a lot of inconsistencies already which should IMHO be fixed, but not in the way you propose.



---

archive/issue_comments_131051.json:
```json
{
    "body": "Replying to [comment:16 leif]:\n> Replying to [comment:15 dimpase]:\n> > Leif here gives arguments based on algebraic properties, so it should be, for algebraic consistency that he cares about so much, that `int(3)<sup>-3==int(1)/int(3)</sup>3`, but this is\n> > not the case now, as Python 2 will convert 1/27 to 0.\n> \n> What makes you think I meant Python's broken `/` operator on `int`s? As I said on sage-devel, the behaviour of that operator on `int`s is useless since there's explicit truncating integer division already, namely `//`.\n> \n> > I advocate the rule that a binary operation involving a Sage integer and a Python int should always produce a Sage type, as this is the case with all the other binary operations.\n> \n> The notion of \"binary operations\" has no meaning in this context, as the desired behaviour w.r.t. result types should depend on the definition of the function, especially its commonly used signature, not its arity.\n\n\nwell, being an algebraist by training and active in this research area for over 20 years, I tend to think that I know how to distinguish a binary operation from something else. And in my (not so in this case) humble opinion I think that exponentiation is a binary operation in this case.\n \n> \n> For exponentiation, the *type* of the exponent is irrelevant, only its *value* matters to deduce the type of the result of the operation, just like for shift operations (which of course aren't commutative either).\n> \n> Or would you say `type( value << shift )` should depend on the type of `shift`?\n\nit can, potentially; e.g. when shifting is not understood in a narrow context of binary words.\n\n\n> \n> This might perhaps look \"consistent\" from a syntactical point of view, but simply isn't sound, i.e. doesn't make any sense in the semantic domain.  \n\nLook, I know an opinion on this issue of a lot of unhappy beginning users of Sage (the undergrads I currently teach), and they\nare dazed and confused by this inconsistency, among others. And I am merely trying to make Sage easier to use for them on this ticket.",
    "created_at": "2011-09-06T16:47:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131051",
    "user": "dimpase"
}
```

Replying to [comment:16 leif]:
> Replying to [comment:15 dimpase]:
> > Leif here gives arguments based on algebraic properties, so it should be, for algebraic consistency that he cares about so much, that `int(3)<sup>-3==int(1)/int(3)</sup>3`, but this is
> > not the case now, as Python 2 will convert 1/27 to 0.
> 
> What makes you think I meant Python's broken `/` operator on `int`s? As I said on sage-devel, the behaviour of that operator on `int`s is useless since there's explicit truncating integer division already, namely `//`.
> 
> > I advocate the rule that a binary operation involving a Sage integer and a Python int should always produce a Sage type, as this is the case with all the other binary operations.
> 
> The notion of "binary operations" has no meaning in this context, as the desired behaviour w.r.t. result types should depend on the definition of the function, especially its commonly used signature, not its arity.


well, being an algebraist by training and active in this research area for over 20 years, I tend to think that I know how to distinguish a binary operation from something else. And in my (not so in this case) humble opinion I think that exponentiation is a binary operation in this case.
 
> 
> For exponentiation, the *type* of the exponent is irrelevant, only its *value* matters to deduce the type of the result of the operation, just like for shift operations (which of course aren't commutative either).
> 
> Or would you say `type( value << shift )` should depend on the type of `shift`?

it can, potentially; e.g. when shifting is not understood in a narrow context of binary words.


> 
> This might perhaps look "consistent" from a syntactical point of view, but simply isn't sound, i.e. doesn't make any sense in the semantic domain.  

Look, I know an opinion on this issue of a lot of unhappy beginning users of Sage (the undergrads I currently teach), and they
are dazed and confused by this inconsistency, among others. And I am merely trying to make Sage easier to use for them on this ticket.



---

archive/issue_comments_131052.json:
```json
{
    "body": "Replying to [comment:17 dimpase]:\n> well, being an algebraist by training and active in this research area for over 20 years, I tend to think that I know how to distinguish a binary operation from something else. And in my (not so in this case) humble opinion I think that exponentiation is a binary operation in this case.\n\nThen you know that multiplication is a basic binary operation of a ring, but exponentiation is simply a notation involving two values, one from the ring, the other from integers. \n \n> Look, I know an opinion on this issue of a lot of unhappy beginning users of Sage (the undergrads I currently teach), and they\n> are dazed and confused by this inconsistency, among others. And I am merely trying to make Sage easier to use for them on this ticket.\n\nThe right direction for beginners is to let them know the difference between `int(3)` and `3` (Sage Integer) and that `3` behaves more mathematically than `int(3)` which suffers from numerical treatment.",
    "created_at": "2011-09-07T00:20:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131052",
    "user": "klee"
}
```

Replying to [comment:17 dimpase]:
> well, being an algebraist by training and active in this research area for over 20 years, I tend to think that I know how to distinguish a binary operation from something else. And in my (not so in this case) humble opinion I think that exponentiation is a binary operation in this case.

Then you know that multiplication is a basic binary operation of a ring, but exponentiation is simply a notation involving two values, one from the ring, the other from integers. 
 
> Look, I know an opinion on this issue of a lot of unhappy beginning users of Sage (the undergrads I currently teach), and they
> are dazed and confused by this inconsistency, among others. And I am merely trying to make Sage easier to use for them on this ticket.

The right direction for beginners is to let them know the difference between `int(3)` and `3` (Sage Integer) and that `3` behaves more mathematically than `int(3)` which suffers from numerical treatment.



---

archive/issue_comments_131053.json:
```json
{
    "body": "Replying to [comment:18 klee]:\n> Replying to [comment:17 dimpase]:\n> > well, being an algebraist by training and active in this research area for over 20 years, I tend to think that I know how to distinguish a binary operation from something else. And in my (not so in this case) humble opinion I think that exponentiation is a binary operation in this case.\n> \n> Then you know that multiplication is a basic binary operation of a ring, but exponentiation is simply a notation involving two values, one from the ring, the other from integers. \n\nEver heard about `exp()`? Exponentiation is a jolly good binary operation on positive real numbers.\n\n>  \n> > Look, I know an opinion on this issue of a lot of unhappy beginning users of Sage (the undergrads I currently teach), and they\n> > are dazed and confused by this inconsistency, among others. And I am merely trying to make Sage easier to use for them on this ticket.\n> \n> The right direction for beginners is to let them know the difference between `int(3)` and `3` (Sage Integer) and that `3` behaves more mathematically than `int(3)` which suffers from numerical treatment.   \n\nTry to convince a beginner that the inconsistencies that got this ticket started are OK, without saying that Sage has not made a good choice.",
    "created_at": "2011-09-07T01:38:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131053",
    "user": "dimpase"
}
```

Replying to [comment:18 klee]:
> Replying to [comment:17 dimpase]:
> > well, being an algebraist by training and active in this research area for over 20 years, I tend to think that I know how to distinguish a binary operation from something else. And in my (not so in this case) humble opinion I think that exponentiation is a binary operation in this case.
> 
> Then you know that multiplication is a basic binary operation of a ring, but exponentiation is simply a notation involving two values, one from the ring, the other from integers. 

Ever heard about `exp()`? Exponentiation is a jolly good binary operation on positive real numbers.

>  
> > Look, I know an opinion on this issue of a lot of unhappy beginning users of Sage (the undergrads I currently teach), and they
> > are dazed and confused by this inconsistency, among others. And I am merely trying to make Sage easier to use for them on this ticket.
> 
> The right direction for beginners is to let them know the difference between `int(3)` and `3` (Sage Integer) and that `3` behaves more mathematically than `int(3)` which suffers from numerical treatment.   

Try to convince a beginner that the inconsistencies that got this ticket started are OK, without saying that Sage has not made a good choice.



---

archive/issue_comments_131054.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2011-09-10T19:18:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131054",
    "user": "was"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_131055.json:
```json
{
    "body": "Can you also add a doctest that illustrates this:\n\n```\n   sage: type(int(3)^2)\n   ...Integer...\n```\n\n\nI'm in favor of this change.  It was always planned to add `__pow__` to the coercion model, and have Sage types be favored over Python types (just as the are for the other arithmetic operations), but nobody got around to it.  This patch doesn't make such a big sweeping change as adding `__pow__` to the coercion model, but it is a step in the right direction.",
    "created_at": "2011-09-10T19:18:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131055",
    "user": "was"
}
```

Can you also add a doctest that illustrates this:

```
   sage: type(int(3)^2)
   ...Integer...
```


I'm in favor of this change.  It was always planned to add `__pow__` to the coercion model, and have Sage types be favored over Python types (just as the are for the other arithmetic operations), but nobody got around to it.  This patch doesn't make such a big sweeping change as adding `__pow__` to the coercion model, but it is a step in the right direction.



---

archive/issue_comments_131056.json:
```json
{
    "body": "slightly more optimized version",
    "created_at": "2011-09-11T08:19:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131056",
    "user": "dimpase"
}
```

slightly more optimized version



---

archive/issue_comments_131057.json:
```json
{
    "body": "Attachment [trac_11779.patch](tarball://root/attachments/some-uuid/ticket11779/trac_11779.patch) by dimpase created at 2011-09-11 08:28:07\n\nReplying to [comment:20 was]:\n> Can you also add a doctest that illustrates this:\n\n```\n    sage: type(int(3)^2)\n    ...Integer...\n```\n\nDone. I have also added `type(int(3)^int(3))` doctest to show how to stick with 'int', if needed.",
    "created_at": "2011-09-11T08:28:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131057",
    "user": "dimpase"
}
```

Attachment [trac_11779.patch](tarball://root/attachments/some-uuid/ticket11779/trac_11779.patch) by dimpase created at 2011-09-11 08:28:07

Replying to [comment:20 was]:
> Can you also add a doctest that illustrates this:

```
    sage: type(int(3)^2)
    ...Integer...
```

Done. I have also added `type(int(3)^int(3))` doctest to show how to stick with 'int', if needed.



---

archive/issue_comments_131058.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2011-09-11T08:28:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131058",
    "user": "dimpase"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_131059.json:
```json
{
    "body": "Looks good to me.",
    "created_at": "2011-09-11T17:17:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131059",
    "user": "was"
}
```

Looks good to me.



---

archive/issue_comments_131060.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2011-09-11T17:17:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131060",
    "user": "was"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_131061.json:
```json
{
    "body": "Please don't put links to the **HTML version** of a patch into the description.\n\nTrac wiki mark-up is `[attachment:here_comes_the_filename]`.\n\n----\n\nWonder whether your undergrads will complain that `[1r][0]` (or `(1r,)[0]`) doesn't yield a Sage `Integer`...",
    "created_at": "2011-09-12T10:33:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131061",
    "user": "leif"
}
```

Please don't put links to the **HTML version** of a patch into the description.

Trac wiki mark-up is `[attachment:here_comes_the_filename]`.

----

Wonder whether your undergrads will complain that `[1r][0]` (or `(1r,)[0]`) doesn't yield a Sage `Integer`...



---

archive/issue_comments_131062.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2011-09-17T05:29:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11607",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11607#issuecomment-131062",
    "user": "leif"
}
```

Resolution: fixed
