# Issue 19821: LatticePosets: Add generated congruence

Issue created by migration from Trac.

Original creator: jmantysalo

Original creation time: 2016-02-15 18:02:16

CC:  kdilks

Add a function that computes congruence generated by lists of elements. For a pair of elements this is called principal congruence.

(Wait until #20057 to get nicer code.)


---

Comment by jmantysalo created at 2016-10-18 03:47:02

Draft of code done, waiting for some other tickets to close and doing some polishing.


---

Comment by mantepse created at 2016-10-18 05:18:13

I am very much looking forward to this!


---

Comment by jmantysalo created at 2016-10-18 05:49:13

Replying to [comment:2 mantepse]:
> I am very much looking forward to this!

Good! See https://sage.sis.uta.fi/home/pub/130/ for a "preview".

E: This can be optimized: Move `congruence()` to `hasse_diagram.py` and add an option to "add" a congruence, i.e. a parameter to give already computed congruence.


---

Comment by jmantysalo created at 2016-11-06 14:30:09

Status update: This is hard.

Well, not really hard to make it work, but hard to make it fast (and my draft version if fast but incorrect...). I have thinked this, and propably we need a list of upper and lower covers, and should delete those to avoid unnecessary re-computation.

Also there seems to be no published algorithms for this.


---

Comment by jmantysalo created at 2016-11-11 14:18:50

New commits:


---

Comment by jmantysalo created at 2016-11-11 14:18:50

Changing status from new to needs_review.


---

Comment by jmantysalo created at 2016-11-11 14:23:21

Ready for review. I am quite sure that there is still places for optimization. However, this is quite fast already. Should be tested well before we continue to #21861.


---

Comment by tscrim created at 2016-11-11 15:03:49

For speed, you might want to consider converting things into Cython code, but really it involves doing a bunch of profiling beforehand.

For the `INPUT:` block, you should format the inputs as:

```
- ``parts`` -- a list of lists; congruences to add
```

Also, you should add the reference to the master list and link to it with `[Foo42]_`.


---

Comment by jmantysalo created at 2016-11-11 19:51:33

It seems that actually this is fast enought, after meets and joins are computed. I did some tests, and for example principal congruences for all join-irreducibles (with their lower covers) on 1430-element Tamari lattice takes about 20 seconds on notebook, i.e. on not-compiled code.

I don't think that cythonizing can be done, as this needs `DisjointSet`s.

But now, does someone understand this code? If so, does it work?


---

Comment by git created at 2016-11-16 10:27:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-11-16 10:27:58

Replying to [comment:8 tscrim]:

> For the `INPUT:` block, you should format - - add the reference to the master list - -

Done.


---

Comment by tscrim created at 2016-11-16 15:38:19

You can have Cython import stuff and use Python objects such as `DisjointSet`. Since you're doing a fair bit of computation within the methods, there might be some benefit. Yet, if it is fast enough for your purposes, then you don't have to do anything more.

I don't think I can do anything with respect to the code itself at this moment in time. Martin?

Quick comment: your reference is poorly formatted. I recommend:

```
.. [DP1997] \B. A. Davey, H. A. Priestley,
            *Introduction to lattices and order*,
            Cambridge University Press, 1997.
```



---

Comment by git created at 2016-11-16 16:01:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-11-16 16:04:12

Replying to [comment:12 tscrim]:

> I don't think I can do anything with respect to the code itself at this moment in time. Martin?

You have already did very much for many kind of tickets. Thanks for those! Kind of turn for others to review my patches...

> Quick comment: your reference is poorly formatted. I recommend:

Good point, done.

> You can have Cython import stuff and use Python objects such as `DisjointSet`. Since you're doing a fair bit of computation within the methods, there might be some benefit. Yet, if it is fast enough for your purposes, then you don't have to do anything more.

OK. I guess this must be first made working, build something more on top of this and then see if we want to optimize or not.


---

Comment by mantepse created at 2016-11-16 18:05:23

Unfortunately, I won't have time until end of next week because of teaching duties.  I'm sorry about that.


---

Comment by jmantysalo created at 2016-11-16 19:15:50

Replying to [comment:15 mantepse]:
> Unfortunately, I won't have time until end of next week because of teaching duties.  I'm sorry about that.

There is not that horry, of course.

(It took 2200 years to prove that squaring the circle is impossible. To find someone who does not hurry, try someone doing mathematics. `:=)`)


---

Comment by git created at 2016-11-23 22:31:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2016-11-24 21:00:29

Hi Jori!

I just started playing with your code, and now tried the following:

```
[P for P in posets(r) if P.is_lattice() and all(len(set([len(b) for b in LatticePoset(P).congruence(p)]))==1 for p in SetPartitions(P))]
```

for r smaller than 8.  If I'm not mistaken, these should be precisely the uniform lattices, right?  (Very likely generated in the most stupid way possible :-)

I was a bit surprised to get so few of them: for r equal to 3,4,5 and 6 I get just one, for 7 I get four.  Does this match your experience - or is my code wrong?


---

Comment by mantepse created at 2016-11-24 21:25:57

For r=8 I get 17 uniform lattices...


---

Comment by jmantysalo created at 2016-11-25 05:48:59

Martin, to generate lattices please take this https://sage.sis.uta.fi/home/pub/133/ (or at least see `with_bounds()` of poset. I think that checking for being uniform can be made like


```
def uniform(self):
    ji = [(i, self.lower_covers(i)[0]) for i in self.join_irreducibles()]
    for x in Subsets(ji):
        if len(uniq([len(y) for y in self.congruence(x)])) > 1:
            return False
    return True
```


and I got the same results, except that for r=8 I got 15. Uniform lattices are rare.


---

Comment by jmantysalo created at 2016-11-25 05:49:54

Travis: Pros and cons of using `SetPartition` as output type of this? I would be kind of natural.


---

Comment by mantepse created at 2016-11-25 13:49:42


```
sage: r=6; l = [P.with_bounds() for P in posets(r) if P.with_bounds().is_lattice() and all(len(set([len(b) for b in LatticePoset(P.with_bounds()).congruence(p)]))==1 for p in SetPartitions(P
....: .with_bounds()))]; l

[Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements,
 Finite poset containing 8 elements]
sage: len(l)
17
```



---

Comment by mantepse created at 2016-11-25 13:56:37

Using your code, I get

```
r=6; m = [P.with_bounds() for P in posets(r) if P.with_bounds().is_lattice() and uniform(LatticePoset(P.with_bounds()))]; len(m)
15
```

Not sure what's wrong.


---

Comment by mantepse created at 2016-11-25 14:26:44

Jori, I'm confused.

I would have thought that the following two would yield the same result:

```
sage: L = LatticePoset(DiGraph('G?QO`@``@`?O`@`u??')); L
Finite lattice containing 8 elements
sage: L.congruence([(2, 1), (4, 6), (3, 6)])
[[6, 4, 3, 1, 2, 5], [0, 7]]
sage: L.congruence([(2, 1), (3, 4, 6)])
[This is the Trac macro *6, 4, 3, 1, 2, 5, 0, 7* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#6, 4, 3, 1, 2, 5, 0, 7-macro)
```


Martin


---

Comment by jmantysalo created at 2016-11-25 14:49:34

Replying to [comment:24 mantepse]:
> I would have thought that the following two would yield the same result:

They should. You found a bug. Thanks!


---

Comment by git created at 2016-11-25 20:17:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-11-25 20:44:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-11-25 20:45:09

Should work now, but haven't compiled yet.


---

Comment by mantepse created at 2016-11-25 22:33:49

I'm afraid you need to state what the "precompute part" does...


---

Comment by jmantysalo created at 2016-11-26 06:43:48

Replying to [comment:29 mantepse]:
> I'm afraid you need to state what the "precompute part" does...

1) Fill given blocks to convex sublattices, i.e. to intervals, 2) unify those blocks that have common element, and 3) go back to 1, if there was some change done during 2.

I am sure that there is a better way for this, but haven't invented it yet.

E: Think about `L = Posets.DivisorLattice(100000)` and `L.congruence([[4,10],[40,100]])`. It will 1) fill `[4, 10]` to `[2, 4, 10, 20]` and fill `[40, 100]` to `[20, 40, 100, 200]`, then 2) combine them to `[2, 4, 10, 20, 40, 100, 200]` and last 1) fill that to `[2, 4, 8, 10, 20, 40, 50, 100, 200]`. This kind of fill-combine -process can continue for several rounds.

Only after this we will use the quadrilateral argument, which is our "main compute part".


---

Comment by mantepse created at 2016-11-26 07:59:18

Is this the same as the smallest interval decomposition, such that each given block is part of an interval?

If so, this might be a separate method.


---

Comment by jmantysalo created at 2016-11-26 08:13:53

Replying to [comment:31 mantepse]:
> Is this the same as the smallest interval decomposition, such that each given block is part of an interval?
> 
> If so, this might be a separate method.

Never before heard "smallest interval decomposition", but yes, I think that this is it. Can be separated, but maybe later?


---

Comment by mantepse created at 2016-11-26 09:38:09

I thought I heard "interval decomposition" before, but I cannot find anything sensible right now.  Or is it "interval partition"?

Anyway, similar to "chain decomposition"...


---

Comment by jmantysalo created at 2016-11-26 13:44:47

Replying to [comment:34 mantepse]:
> I thought I heard "interval decomposition" before, but I cannot find anything sensible right now.  Or is it "interval partition"?
> 
> Anyway, similar to "chain decomposition"...

If this is wanted, I can later add that as a separate function.


---

Comment by git created at 2016-11-27 05:44:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-11-27 05:51:18

I thinked about this, and `SetPartition` feels clearly the right output type. It will also be good element type for congruence lattice.


---

Comment by kdilks created at 2016-11-28 01:08:07

Changing keywords from "" to "kdilks".


---

Comment by jmantysalo created at 2016-11-28 04:33:00

Changing keywords from "kdilks" to "".


---

Comment by jmantysalo created at 2016-12-15 08:38:36

Any progressa on reviewing this? Please ask if there is something I should clarify.


---

Comment by mantepse created at 2016-12-15 09:07:13

sorry for the delay, this week, I promise!


---

Comment by jmantysalo created at 2016-12-15 10:11:34

Replying to [comment:41 mantepse]:
> sorry for the delay, this week, I promise!

This is voluntary, and everyone has other life too, so no horry. But please ask if there is anything I can help.


---

Comment by mantepse created at 2016-12-20 09:48:46

Changing status from needs_review to positive_review.


---

Comment by mantepse created at 2016-12-20 09:48:46

Played around, checked some corner cases, found nothing to complain about.

Sorry for the huge delay.

Thank you for adding this!


---

Comment by jmantysalo created at 2016-12-20 10:06:32

Thanks! After rc1 (or 7.5 stable) I'll continue with others relating to this.


---

Comment by jmantysalo created at 2016-12-21 12:27:50

Forgot that 7.5 is in rc phase, so this will appear in 7.6.


---

Comment by vbraun created at 2017-01-18 20:40:00

Resolution: fixed
