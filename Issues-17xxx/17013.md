# Issue 17013: WordDatatype_char

archive/issues_016776.json:
```json
{
    "body": "Creation of a new class WordDatatype_char that has in backend an 'unsigned char *' and use it wherever possible. The implementation is much faster than anything else but is only available for alphabet contained in [0,255].\n\nCC:  @seblabbe\n\nKeywords: words\n\nReviewer: S\u00e9bastien Labb\u00e9, Jeroen Demeyer\n\nAuthor: Vincent Delecroix\n\nBranch: c00964da4655d7580277c3d4aba1e0a51b06b78e\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/17013\n\n",
    "closed_at": "2014-09-25T12:05:55Z",
    "created_at": "2014-09-20T15:17:18Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "WordDatatype_char",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17013",
    "user": "https://github.com/videlec"
}
```
Creation of a new class WordDatatype_char that has in backend an 'unsigned char *' and use it wherever possible. The implementation is much faster than anything else but is only available for alphabet contained in [0,255].

CC:  @seblabbe

Keywords: words

Reviewer: Sébastien Labbé, Jeroen Demeyer

Author: Vincent Delecroix

Branch: c00964da4655d7580277c3d4aba1e0a51b06b78e

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/17013





---

archive/issue_comments_236126.json:
```json
{
    "body": "<a id='comment:1'></a>New commits:",
    "created_at": "2014-09-20T15:35:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236126",
    "user": "https://github.com/videlec"
}
```

<a id='comment:1'></a>New commits:



---

archive/issue_comments_236127.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-09-20T15:35:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236127",
    "user": "https://github.com/videlec"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_236128.json:
```json
{
    "body": "<a id='comment:2'></a>New commits:",
    "created_at": "2014-09-20T18:53:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236128",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:2'></a>New commits:



---

archive/issue_comments_236129.json:
```json
{
    "body": "<a id='comment:3'></a>If Vincent agrees with my changes, then he can set this ticket to positive review.",
    "created_at": "2014-09-20T18:54:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236129",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:3'></a>If Vincent agrees with my changes, then he can set this ticket to positive review.



---

archive/issue_comments_236130.json:
```json
{
    "body": "<a id='comment:4'></a>Here is one benchmark.\n\nBEFORE::\n\n```\n    sage: w = Word([0,-1,2]*100, alphabet=[0,-1,2])\n    sage: type(w)\n    <class 'sage.combinat.words.word.FiniteWord_list'>\n    sage: %timeit w.is_square_free()\n    1000 loops, best of 3: 417 \u00b5s per loop\n```\n\nAFTER::\n\n```\n    sage: w = Word([0,1,2]*100, alphabet=[0,1,2])\n    sage: type(w)\n    <class 'sage.combinat.words.word.FiniteWord_char'>\n    sage: %timeit w.is_square_free()\n    100000 loops, best of 3: 6.29 \u00b5s per loop\n```\n\nWe should also add here some benchmark about equality test and also `__getitem__`.",
    "created_at": "2014-09-20T18:57:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236130",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:4'></a>Here is one benchmark.

BEFORE::

```
    sage: w = Word([0,-1,2]*100, alphabet=[0,-1,2])
    sage: type(w)
    <class 'sage.combinat.words.word.FiniteWord_list'>
    sage: %timeit w.is_square_free()
    1000 loops, best of 3: 417 µs per loop
```

AFTER::

```
    sage: w = Word([0,1,2]*100, alphabet=[0,1,2])
    sage: type(w)
    <class 'sage.combinat.words.word.FiniteWord_char'>
    sage: %timeit w.is_square_free()
    100000 loops, best of 3: 6.29 µs per loop
```

We should also add here some benchmark about equality test and also `__getitem__`.



---

archive/issue_comments_236131.json:
```json
{
    "body": "<a id='comment:5'></a>Replying to [comment:4 slabbe]:\n> We should also add here some benchmark about equality test and also `__getitem__`.\n\n\nEDIT: the timings were edited because there were not about `FiniteWord_str` but `FiniteWord_list`...\n\nCompetitions between:\n- Python string\n- `FiniteWord_str`\n- `FiniteWord_char`\n\n```\nsage: W1 = Words('abc')\nsage: W2 = Words([0,1,2])\nsage: w1 = W1(''.join(choice('abc') for _ in range(1000)))\nsage: w2 = W2([choice([0,1,2]) for _ in range(1000])\nsage: s = str(w1)\n```\nthen on slices\n\n```\nsage: timeit(\"for i in range(1000): u = w1[:i]\")\n25 loops, best of 3: 25.3 ms per loop\nsage: timeit(\"for i in range(1000): u = w2[:i]\")\n625 loops, best of 3: 237 \u00b5s per loop\nsage: timeit(\"for i in range(1000): u = s[:i]\")\n625 loops, best of 3: 129 \u00b5s per loop\n```\nand on equality\n\n```\nsage: timeit(\"w1 == w1\")\n625 loops, best of 3: 365 ns per loop\nsage: timeit(\"w2 == w2\")\n625 loops, best of 3: 187 ns per loop\nsage: timeit(\"s == s\")\n625 loops, best of 3: 86.6 ns per loop\n```\nSo Python strings are still ahead, but its much less ridiculous.\n\nVincent",
    "created_at": "2014-09-20T21:38:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236131",
    "user": "https://github.com/videlec"
}
```

<a id='comment:5'></a>Replying to [comment:4 slabbe]:
> We should also add here some benchmark about equality test and also `__getitem__`.


EDIT: the timings were edited because there were not about `FiniteWord_str` but `FiniteWord_list`...

Competitions between:
- Python string
- `FiniteWord_str`
- `FiniteWord_char`

```
sage: W1 = Words('abc')
sage: W2 = Words([0,1,2])
sage: w1 = W1(''.join(choice('abc') for _ in range(1000)))
sage: w2 = W2([choice([0,1,2]) for _ in range(1000])
sage: s = str(w1)
```
then on slices

```
sage: timeit("for i in range(1000): u = w1[:i]")
25 loops, best of 3: 25.3 ms per loop
sage: timeit("for i in range(1000): u = w2[:i]")
625 loops, best of 3: 237 µs per loop
sage: timeit("for i in range(1000): u = s[:i]")
625 loops, best of 3: 129 µs per loop
```
and on equality

```
sage: timeit("w1 == w1")
625 loops, best of 3: 365 ns per loop
sage: timeit("w2 == w2")
625 loops, best of 3: 187 ns per loop
sage: timeit("s == s")
625 loops, best of 3: 86.6 ns per loop
```
So Python strings are still ahead, but its much less ridiculous.

Vincent



---

archive/issue_comments_236132.json:
```json
{
    "body": "<a id='comment:6'></a>Replying to [comment:3 slabbe]:\n> If Vincent agrees with my changes, then he can set this ticket to positive review.\n\n\nI am! Thanks for the review.\n\nVincent",
    "created_at": "2014-09-20T21:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236132",
    "user": "https://github.com/videlec"
}
```

<a id='comment:6'></a>Replying to [comment:3 slabbe]:
> If Vincent agrees with my changes, then he can set this ticket to positive review.


I am! Thanks for the review.

Vincent



---

archive/issue_comments_236133.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-09-20T21:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236133",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_236134.json:
```json
{
    "body": "<a id='comment:7'></a>> Competitions between:\n> - Python string\n> - `FiniteWord_str`\n> - `FiniteWord_char`\n\n\nI believe you do not have `FiniteWord_str` in the competition...\n\n```\nsage: type(w1)                                     \n<class 'sage.combinat.words.word.FiniteWord_list'> \n```",
    "created_at": "2014-09-20T21:44:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236134",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:7'></a>> Competitions between:
> - Python string
> - `FiniteWord_str`
> - `FiniteWord_char`


I believe you do not have `FiniteWord_str` in the competition...

```
sage: type(w1)                                     
<class 'sage.combinat.words.word.FiniteWord_list'> 
```



---

archive/issue_comments_236135.json:
```json
{
    "body": "<a id='comment:8'></a>Instead of (note that you already have defined i as a `ssize_t`):\n\n```python\ncdef ssize_t i\nfor i in range(w._length-1, -1, -1):\n```\n\nMaybe the following is better and would allow to use `size_t` type?\n\n```python\ncdef size_t i\nfor i from w._length > i >= 0:\n```",
    "created_at": "2014-09-20T21:55:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236135",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:8'></a>Instead of (note that you already have defined i as a `ssize_t`):

```python
cdef ssize_t i
for i in range(w._length-1, -1, -1):
```

Maybe the following is better and would allow to use `size_t` type?

```python
cdef size_t i
for i from w._length > i >= 0:
```



---

archive/issue_comments_236136.json:
```json
{
    "body": "<a id='comment:9'></a>Replying to [comment:8 slabbe]:\n> Instead of (note that you already have defined i as a `ssize_t`):\n> \n> \n> ```\n> #!python\n> cdef ssize_t i\n> for i in range(w._length-1, -1, -1):\n> ```\n> \n> Maybe the following is better and would allow to use `size_t` type?\n> \n> \n> ```\n> #!python\n> cdef size_t i\n> for i from w._length > i >= 0:\n> ```\n\n\nNope, it does note change anything. And be careful, your second loop is infinite (a size_t is always >= 0).",
    "created_at": "2014-09-20T21:56:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236136",
    "user": "https://github.com/videlec"
}
```

<a id='comment:9'></a>Replying to [comment:8 slabbe]:
> Instead of (note that you already have defined i as a `ssize_t`):
> 
> 
> ```
> #!python
> cdef ssize_t i
> for i in range(w._length-1, -1, -1):
> ```
> 
> Maybe the following is better and would allow to use `size_t` type?
> 
> 
> ```
> #!python
> cdef size_t i
> for i from w._length > i >= 0:
> ```


Nope, it does note change anything. And be careful, your second loop is infinite (a size_t is always >= 0).



---

archive/issue_comments_236137.json:
```json
{
    "body": "<a id='comment:10'></a>Replying to [comment:7 slabbe]:\n> > Competitions between:\n> > - Python string\n> > - `FiniteWord_str`\n> > - `FiniteWord_char`\n\n> \n> I believe you do not have `FiniteWord_str` in the competition...\n> \n> \n> ```\n> sage: type(w1)                                     \n> <class 'sage.combinat.words.word.FiniteWord_list'> \n> ```\n\n\nOups... corrected. Does not change anything for slicing, but huge difference in equality.",
    "created_at": "2014-09-20T21:59:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236137",
    "user": "https://github.com/videlec"
}
```

<a id='comment:10'></a>Replying to [comment:7 slabbe]:
> > Competitions between:
> > - Python string
> > - `FiniteWord_str`
> > - `FiniteWord_char`

> 
> I believe you do not have `FiniteWord_str` in the competition...
> 
> 
> ```
> sage: type(w1)                                     
> <class 'sage.combinat.words.word.FiniteWord_list'> 
> ```


Oups... corrected. Does not change anything for slicing, but huge difference in equality.



---

archive/issue_comments_236138.json:
```json
{
    "body": "<a id='comment:11'></a>Great, so I am ok with this ticket. Positive review as already set!\n\nS\u00e9bastien",
    "created_at": "2014-09-20T22:04:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236138",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:11'></a>Great, so I am ok with this ticket. Positive review as already set!

Sébastien



---

archive/issue_comments_236139.json:
```json
{
    "body": "<a id='comment:12'></a>This is absolutely not the right way to handle exceptions:\n\n```\nif PySlice_GetIndicesEx(...) < 0:\n    return\n```\nThe fact that it \"works\" is because IPython picks up the exception much later than you intended. Note the botched traceback:\n\n```\nsage: Words([0,1,2,3])([0,1,0,2,0,3,1,2,3])[slice(\"foo\")]\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nTypeError: slice indices must be integers or None or have an __index__ method\n```\nThe right way is to declare your function as `except -1` and let Cython do the right thing. See http://docs.cython.org/src/userguide/language_basics.html#error-return-values",
    "created_at": "2014-09-24T15:34:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236139",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:12'></a>This is absolutely not the right way to handle exceptions:

```
if PySlice_GetIndicesEx(...) < 0:
    return
```
The fact that it "works" is because IPython picks up the exception much later than you intended. Note the botched traceback:

```
sage: Words([0,1,2,3])([0,1,0,2,0,3,1,2,3])[slice("foo")]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
TypeError: slice indices must be integers or None or have an __index__ method
```
The right way is to declare your function as `except -1` and let Cython do the right thing. See http://docs.cython.org/src/userguide/language_basics.html#error-return-values



---

archive/issue_comments_236140.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2014-09-24T15:34:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236140",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_236141.json:
```json
{
    "body": "<a id='comment:13'></a>See [https://github.com/cython/cython/commit/543c33c4a1fdf105c3173a0950297ce4f7550ece](https://github.com/cython/cython/commit/543c33c4a1fdf105c3173a0950297ce4f7550ece) for how such a declaration would look like.\n\nIf you feel like it, add that patch to the Cython package and then you can do\n\n```\nfrom cpython.slice cimport *\n```\ninstead of manually declaring the `PySlice_` functions.",
    "created_at": "2014-09-24T16:00:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236141",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:13'></a>See [https://github.com/cython/cython/commit/543c33c4a1fdf105c3173a0950297ce4f7550ece](https://github.com/cython/cython/commit/543c33c4a1fdf105c3173a0950297ce4f7550ece) for how such a declaration would look like.

If you feel like it, add that patch to the Cython package and then you can do

```
from cpython.slice cimport *
```
instead of manually declaring the `PySlice_` functions.



---

archive/issue_comments_236142.json:
```json
{
    "body": "<a id='comment:14'></a>Hi Jeroen,\n\nAs you noticed, the commit in cython is 3 days old... and the reason is because I asked on the [cython-users list](https://groups.google.com/forum/#!topic/cython-users/2G-QguqmgKk). Patching is much more work than the declaration (see the last commit):\n\n```\ncdef extern from \"Python.h\":\n    int PySlice_GetIndicesEx(...) except -1\n```\n\nVincent",
    "created_at": "2014-09-24T16:13:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236142",
    "user": "https://github.com/videlec"
}
```

<a id='comment:14'></a>Hi Jeroen,

As you noticed, the commit in cython is 3 days old... and the reason is because I asked on the [cython-users list](https://groups.google.com/forum/#!topic/cython-users/2G-QguqmgKk). Patching is much more work than the declaration (see the last commit):

```
cdef extern from "Python.h":
    int PySlice_GetIndicesEx(...) except -1
```

Vincent



---

archive/issue_comments_236143.json:
```json
{
    "body": "<a id='comment:15'></a>New commits:",
    "created_at": "2014-09-24T16:19:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236143",
    "user": "https://github.com/videlec"
}
```

<a id='comment:15'></a>New commits:



---

archive/issue_comments_236144.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-09-24T16:19:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236144",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_236145.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-09-24T16:45:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236145",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_236146.json:
```json
{
    "body": "<a id='comment:17'></a>Thanks!",
    "created_at": "2014-09-24T16:55:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236146",
    "user": "https://github.com/videlec"
}
```

<a id='comment:17'></a>Thanks!



---

archive/issue_comments_236147.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-09-25T12:05:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236147",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_049535.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-09-25T12:05:55Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17013#event-49535"
}
```



---

archive/issue_comments_236148.json:
```json
{
    "body": "<a id='comment:19'></a>Note that #15820 seems to address similar applications, but more general (without restriction to alphabets of length 255). In preliminary versions of bounded integer sequences, I experimented with `char*` as underlying data structure, but found that using GMP long integers with the shift operations provided by GMP was faster.",
    "created_at": "2014-12-13T23:24:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236148",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'></a>Note that #15820 seems to address similar applications, but more general (without restriction to alphabets of length 255). In preliminary versions of bounded integer sequences, I experimented with `char*` as underlying data structure, but found that using GMP long integers with the shift operations provided by GMP was faster.



---

archive/issue_comments_236149.json:
```json
{
    "body": "<a id='comment:20'></a>You should really compare the speed of the operations here with those from #15820. What I dislike about this ticket here is that it just talks about `WordDatatype_char` which doesn't mean anything to me: I never noticed that you were implementing sequences of integers in the interval [0,255].\n\nOn #15820, I insisted that the approach would be as general as possible. Of course, Simon King (the author) had a particular application in mind, but the code in #15820 never refers to that application, it is very general.",
    "created_at": "2014-12-14T08:32:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236149",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:20'></a>You should really compare the speed of the operations here with those from #15820. What I dislike about this ticket here is that it just talks about `WordDatatype_char` which doesn't mean anything to me: I never noticed that you were implementing sequences of integers in the interval [0,255].

On #15820, I insisted that the approach would be as general as possible. Of course, Simon King (the author) had a particular application in mind, but the code in #15820 never refers to that application, it is very general.



---

archive/issue_comments_236150.json:
```json
{
    "body": "<a id='comment:21'></a>Hello,\n\nThe thing is that having a complicated datatype with letters not aligned with computer words also has disadvantages. Namely:\n1. code less readable\n2. might be slower if not carefully done (you can not use `memcmp`, `memcpy` from `strings.h`)\nAnd implementing more involved algorithms (pattern matchings, counting subsequences, etc) might be painful.\n\nNevertheless, I would be happy to give it a try and do proper benchmarkings. There will be no problem to remove the data structure here if #15820 is just better.\n\nVincent",
    "created_at": "2014-12-14T09:14:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236150",
    "user": "https://github.com/videlec"
}
```

<a id='comment:21'></a>Hello,

The thing is that having a complicated datatype with letters not aligned with computer words also has disadvantages. Namely:
1. code less readable
2. might be slower if not carefully done (you can not use `memcmp`, `memcpy` from `strings.h`)
And implementing more involved algorithms (pattern matchings, counting subsequences, etc) might be painful.

Nevertheless, I would be happy to give it a try and do proper benchmarkings. There will be no problem to remove the data structure here if #15820 is just better.

Vincent



---

archive/issue_comments_236151.json:
```json
{
    "body": "<a id='comment:22'></a>Replying to [comment:21 vdelecroix]:\n> The thing is that having a complicated datatype with letters not aligned with computer words also has disadvantages. Namely:\n> 1. code less readable\n\n\nTrue for the underlying boilerplate functions. Not necessarily true for higher level code.\n\n\n> 2. might be slower if not carefully done (you can not use `memcmp`, `memcpy` from `strings.h`)\n\n\nWhy can one not use `memcmp` and `memcpy`? Respectively, what's wrong with using `mpn_cmp` and similar functions?\n\n> And implementing more involved algorithms (pattern matchings, counting subsequences, etc) might be painful.\n\n\nIndeed, detection of subsequences (which is also implemented in #15820) is a bit more complicated than it would be with `char*`. Detection of subsequences is one of the operations I care about. Admittedly, with my application to right modules over path algebras in mind, I care more about testing whether a sequence *starts* with a given subsequence than whether it just *contains* the subsequence.",
    "created_at": "2014-12-14T10:05:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236151",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:22'></a>Replying to [comment:21 vdelecroix]:
> The thing is that having a complicated datatype with letters not aligned with computer words also has disadvantages. Namely:
> 1. code less readable


True for the underlying boilerplate functions. Not necessarily true for higher level code.


> 2. might be slower if not carefully done (you can not use `memcmp`, `memcpy` from `strings.h`)


Why can one not use `memcmp` and `memcpy`? Respectively, what's wrong with using `mpn_cmp` and similar functions?

> And implementing more involved algorithms (pattern matchings, counting subsequences, etc) might be painful.


Indeed, detection of subsequences (which is also implemented in #15820) is a bit more complicated than it would be with `char*`. Detection of subsequences is one of the operations I care about. Admittedly, with my application to right modules over path algebras in mind, I care more about testing whether a sequence *starts* with a given subsequence than whether it just *contains* the subsequence.



---

archive/issue_comments_236152.json:
```json
{
    "body": "<a id='comment:23'></a>Of course, bounded integer sequences have one disadvantage for your applications: you can not prescribe an alphabet. Each bounded integer sequences is formed by integers between 0 and a prescribed bound.\n\nAnyway, here are some timings:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: w_s = Word([9,2,0,1,5,3,10,15,1,14,8,3]*100, alphabet=range(16))\nsage: type(w_s)\n<class 'sage.combinat.words.word.FiniteWord_char'>\nsage: w_l = Word([9,2,0,1,5,3,10,15,1,14,8,3]*100)\nsage: type(w_l)\n<class 'sage.combinat.words.word.FiniteWord_list'>\nsage: w_t = Word((9,2,0,1,5,3,10,15,1,14,8,3)*100)\nsage: type(w_t)\n<class 'sage.combinat.words.word.FiniteWord_tuple'>\nsage: w_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,8,3]*100)\nsage: w2_s = Word([9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8], alphabet=range(16))\nsage: w2_l = Word([9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8])\nsage: w2_t = Word((9,2,0,1,5,3,10,15,1,14,8,3)*99+(9,2,0,1,5,3,10,15,1,14,3,8))\nsage: w2_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8])\nsage: list(w_s)==list(w_l)==list(w_t)==list(w_b)\nTrue\nsage: list(w2_s)==list(w2_l)==list(w2_t)==list(w2_b)\nTrue\n```\n\nComparison:\n\n```\nsage: %timeit w_s==w2_s\n100000 loops, best of 3: 2.57 \u00b5s per loop\nsage: %timeit w_l==w2_l\n10000 loops, best of 3: 57.8 \u00b5s per loop\nsage: %timeit w_t==w2_t\n10000 loops, best of 3: 56 \u00b5s per loop\nsage: %timeit w_b==w2_b\n1000000 loops, best of 3: 537 ns per loop\n```\n\nHash, which is not (yet?) cached for bounded integer sequences:\n\n```\nsage: %timeit hash(w_s)\n10000000 loops, best of 3: 137 ns per loop\nsage: %timeit hash(w_l)\n10000000 loops, best of 3: 138 ns per loop\nsage: %timeit hash(w_t)\n10000000 loops, best of 3: 137 ns per loop\nsage: %timeit hash(w_b)\n1000000 loops, best of 3: 246 ns per loop\n```\n\nConcatenation:\n\n```\nsage: list(w_s+w2_s)==list(w_l+w2_l)==list(w_t+w2_t)==list(w_b+w2_b)\nTrue\nsage: %timeit w_s+w2_s\n1000 loops, best of 3: 336 \u00b5s per loop\nsage: %timeit w_l+w2_l\n10000 loops, best of 3: 31.1 \u00b5s per loop\nsage: %timeit w_t+w2_t\n10000 loops, best of 3: 31.7 \u00b5s per loop\nsage: %timeit w_b+w2_b\n1000000 loops, best of 3: 1.05 \u00b5s per loop\n```\n\nSubsequence containment:\n\n```\nsage: sub_s = Word([9,2,0,1,5,3,10,15,1,14,3,8], alphabet=range(16))\nsage: sub_l = Word([9,2,0,1,5,3,10,15,1,14,3,8])\nsage: sub_t = Word((9,2,0,1,5,3,10,15,1,14,3,8))\nsage: sub_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,3,8])\nsage: W_s = w2_s+w_s\nsage: W_l = w2_l+w_l\nsage: W_t = w2_t+w_t\nsage: W_b = w2_b+w_b\nsage: sub_s.is_subword_of(W_s)\nTrue\nsage: sub_b in W_b\nTrue\nsage: %timeit sub_s.is_subword_of(W_s)\n10000 loops, best of 3: 21.3 \u00b5s per loop\nsage: %timeit sub_l.is_subword_of(W_l)\n100000 loops, best of 3: 10.9 \u00b5s per loop\nsage: %timeit sub_t.is_subword_of(W_t)\n100000 loops, best of 3: 10.7 \u00b5s per loop\nsage: %timeit sub_b in W_b\n100000 loops, best of 3: 10.8 \u00b5s per loop\n```\n\nSo, using a compressed data format (where many letters are squeezed into one machine word) is not bad for the operations above.",
    "created_at": "2014-12-14T10:31:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236152",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:23'></a>Of course, bounded integer sequences have one disadvantage for your applications: you can not prescribe an alphabet. Each bounded integer sequences is formed by integers between 0 and a prescribed bound.

Anyway, here are some timings:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: w_s = Word([9,2,0,1,5,3,10,15,1,14,8,3]*100, alphabet=range(16))
sage: type(w_s)
<class 'sage.combinat.words.word.FiniteWord_char'>
sage: w_l = Word([9,2,0,1,5,3,10,15,1,14,8,3]*100)
sage: type(w_l)
<class 'sage.combinat.words.word.FiniteWord_list'>
sage: w_t = Word((9,2,0,1,5,3,10,15,1,14,8,3)*100)
sage: type(w_t)
<class 'sage.combinat.words.word.FiniteWord_tuple'>
sage: w_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,8,3]*100)
sage: w2_s = Word([9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8], alphabet=range(16))
sage: w2_l = Word([9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8])
sage: w2_t = Word((9,2,0,1,5,3,10,15,1,14,8,3)*99+(9,2,0,1,5,3,10,15,1,14,3,8))
sage: w2_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,8,3]*99+[9,2,0,1,5,3,10,15,1,14,3,8])
sage: list(w_s)==list(w_l)==list(w_t)==list(w_b)
True
sage: list(w2_s)==list(w2_l)==list(w2_t)==list(w2_b)
True
```

Comparison:

```
sage: %timeit w_s==w2_s
100000 loops, best of 3: 2.57 µs per loop
sage: %timeit w_l==w2_l
10000 loops, best of 3: 57.8 µs per loop
sage: %timeit w_t==w2_t
10000 loops, best of 3: 56 µs per loop
sage: %timeit w_b==w2_b
1000000 loops, best of 3: 537 ns per loop
```

Hash, which is not (yet?) cached for bounded integer sequences:

```
sage: %timeit hash(w_s)
10000000 loops, best of 3: 137 ns per loop
sage: %timeit hash(w_l)
10000000 loops, best of 3: 138 ns per loop
sage: %timeit hash(w_t)
10000000 loops, best of 3: 137 ns per loop
sage: %timeit hash(w_b)
1000000 loops, best of 3: 246 ns per loop
```

Concatenation:

```
sage: list(w_s+w2_s)==list(w_l+w2_l)==list(w_t+w2_t)==list(w_b+w2_b)
True
sage: %timeit w_s+w2_s
1000 loops, best of 3: 336 µs per loop
sage: %timeit w_l+w2_l
10000 loops, best of 3: 31.1 µs per loop
sage: %timeit w_t+w2_t
10000 loops, best of 3: 31.7 µs per loop
sage: %timeit w_b+w2_b
1000000 loops, best of 3: 1.05 µs per loop
```

Subsequence containment:

```
sage: sub_s = Word([9,2,0,1,5,3,10,15,1,14,3,8], alphabet=range(16))
sage: sub_l = Word([9,2,0,1,5,3,10,15,1,14,3,8])
sage: sub_t = Word((9,2,0,1,5,3,10,15,1,14,3,8))
sage: sub_b = BoundedIntegerSequence(16, [9,2,0,1,5,3,10,15,1,14,3,8])
sage: W_s = w2_s+w_s
sage: W_l = w2_l+w_l
sage: W_t = w2_t+w_t
sage: W_b = w2_b+w_b
sage: sub_s.is_subword_of(W_s)
True
sage: sub_b in W_b
True
sage: %timeit sub_s.is_subword_of(W_s)
10000 loops, best of 3: 21.3 µs per loop
sage: %timeit sub_l.is_subword_of(W_l)
100000 loops, best of 3: 10.9 µs per loop
sage: %timeit sub_t.is_subword_of(W_t)
100000 loops, best of 3: 10.7 µs per loop
sage: %timeit sub_b in W_b
100000 loops, best of 3: 10.8 µs per loop
```

So, using a compressed data format (where many letters are squeezed into one machine word) is not bad for the operations above.



---

archive/issue_comments_236153.json:
```json
{
    "body": "<a id='comment:24'></a>I forgot slicing:\n\n```\nsage: list(w_s[30:70]) == list(w_b[30:70])\nTrue\nsage: %timeit x=w_s[30:70]\n1000000 loops, best of 3: 1.02 \u00b5s per loop\nsage: %timeit x=w_l[30:70]\n10000 loops, best of 3: 20.6 \u00b5s per loop\nsage: %timeit x=w_t[30:70]\n10000 loops, best of 3: 21 \u00b5s per loop\nsage: %timeit x=w_b[30:70]\n1000000 loops, best of 3: 1.14 \u00b5s per loop\nsage: list(w_s[30:70:2]) == list(w_b[30:70:2])\nTrue\nsage: %timeit x=w_s[30:70:2]\n100000 loops, best of 3: 2.65 \u00b5s per loop\nsage: %timeit x=w_l[30:70:2]\n100000 loops, best of 3: 13.3 \u00b5s per loop\nsage: %timeit x=w_t[30:70:2]\n100000 loops, best of 3: 14.4 \u00b5s per loop\nsage: %timeit x=w_b[30:70:2]\n1000000 loops, best of 3: 1.63 \u00b5s per loop\n```",
    "created_at": "2014-12-14T10:33:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17013",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17013#issuecomment-236153",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:24'></a>I forgot slicing:

```
sage: list(w_s[30:70]) == list(w_b[30:70])
True
sage: %timeit x=w_s[30:70]
1000000 loops, best of 3: 1.02 µs per loop
sage: %timeit x=w_l[30:70]
10000 loops, best of 3: 20.6 µs per loop
sage: %timeit x=w_t[30:70]
10000 loops, best of 3: 21 µs per loop
sage: %timeit x=w_b[30:70]
1000000 loops, best of 3: 1.14 µs per loop
sage: list(w_s[30:70:2]) == list(w_b[30:70:2])
True
sage: %timeit x=w_s[30:70:2]
100000 loops, best of 3: 2.65 µs per loop
sage: %timeit x=w_l[30:70:2]
100000 loops, best of 3: 13.3 µs per loop
sage: %timeit x=w_t[30:70:2]
100000 loops, best of 3: 14.4 µs per loop
sage: %timeit x=w_b[30:70:2]
1000000 loops, best of 3: 1.63 µs per loop
```
