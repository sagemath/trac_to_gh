# Issue 17984: fix Parent.__contains__

archive/issues_017747.json:
```json
{
    "assignees": [],
    "body": "In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.\n\nThis way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC were needed. As you can see from the discussion this was not wanted.\n\nOf course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n\nIn order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n\nPreviously this ticket proposed that:\n...dedicated `__contains__` methods for both rings are needed.\n\n\nDepends on #19040\n\nCC:  tmonteil\n\nAuthor: **Ralf Stephan**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/17984_\n\n",
    "created_at": "2015-03-18T09:59:31Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/component%3A%20basic%20arithmetic",
        "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "fix Parent.__contains__",
    "type": "issue",
    "updated_at": "2022-12-29T01:33:44Z",
    "url": "https://github.com/sagemath/sage/issues/17984",
    "user": "https://github.com/rwst"
}
```
In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.

This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC were needed. As you can see from the discussion this was not wanted.

Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.

In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.

Previously this ticket proposed that:
...dedicated `__contains__` methods for both rings are needed.


Depends on #19040

CC:  tmonteil

Author: **Ralf Stephan**

_Issue created by migration from https://trac.sagemath.org/ticket/17984_





---

archive/issue_events_229587.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T09:59:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20basic%20arithmetic",
    "label_color": "0000ff",
    "label_name": "component: basic arithmetic",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229587"
}
```



---

archive/issue_events_229588.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T09:59:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229588"
}
```



---

archive/issue_events_229589.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T09:59:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229589"
}
```



---

archive/issue_comments_246965.json:
```json
{
    "body": "Branch: **[u/rws/17984](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984)**",
    "created_at": "2015-03-18T10:01:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246965",
    "user": "https://github.com/rwst"
}
```

Branch: **[u/rws/17984](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984)**



---

archive/issue_events_229590.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T10:01:42Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229590"
}
```



---

archive/issue_comments_246966.json:
```json
{
    "body": "Commit: **[39ab5b2](https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6)**",
    "created_at": "2015-03-18T10:01:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246966",
    "user": "https://github.com/rwst"
}
```

Commit: **[39ab5b2](https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6)**



---

archive/issue_comments_246967.json:
```json
{
    "body": "<a id='comment:2'>Comment 2:</a>\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6\">39ab5b2</a></td><td><code>17984: Dedicated RR.__contains__() and CC.__contains__()</code></td></tr></table>\n",
    "created_at": "2015-03-18T10:01:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246967",
    "user": "https://github.com/rwst"
}
```

<a id='comment:2'>Comment 2:</a>
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6">39ab5b2</a></td><td><code>17984: Dedicated RR.__contains__() and CC.__contains__()</code></td></tr></table>




---

archive/issue_comments_246968.json:
```json
{
    "body": "Author: **Ralf Stephan**",
    "created_at": "2015-03-18T10:01:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246968",
    "user": "https://github.com/rwst"
}
```

Author: **Ralf Stephan**



---

archive/issue_comments_246969.json:
```json
{
    "body": "Replying to [ticket:17984 rws]:\n> In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`\n\nCan you clarify this please?",
    "created_at": "2015-03-18T13:11:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246969",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [ticket:17984 rws]:
> In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`

Can you clarify this please?



---

archive/issue_comments_246970.json:
```json
{
    "body": "<a id='comment:4'>Comment 4:</a>\n\n```\nsage: RealField(10)(1/3) in RR\nTrue\nsage: RealField(10)(1/3) in CC\nFalse\n```",
    "created_at": "2015-03-18T13:13:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246970",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'>Comment 4:</a>

```
sage: RealField(10)(1/3) in RR
True
sage: RealField(10)(1/3) in CC
False
```



---

archive/issue_events_229591.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-03-18T13:13:55Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229591"
}
```



---

archive/issue_events_229592.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-03-18T13:13:55Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229592"
}
```



---

archive/issue_comments_246971.json:
```json
{
    "body": "<a id='comment:5'>Comment 5:</a>\nWhy this???\n\n```\nsage: [1,2,3] in CC\nTrue\n```",
    "created_at": "2015-03-18T13:14:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246971",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'>Comment 5:</a>
Why this???

```
sage: [1,2,3] in CC
True
```



---

archive/issue_comments_246972.json:
```json
{
    "body": "<a id='comment:6'>Comment 6:</a>\nI also think this is wrong:\n\n```\nsage: NaN in RR\nTrue\n```",
    "created_at": "2015-03-18T13:14:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246972",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:6'>Comment 6:</a>
I also think this is wrong:

```
sage: NaN in RR
True
```



---

archive/issue_comments_246973.json:
```json
{
    "body": "<a id='comment:7'>Comment 7:</a>\nAlso please explain why you use `ComplexField()` in the code for `RR`.",
    "created_at": "2015-03-18T13:19:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246973",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'>Comment 7:</a>
Also please explain why you use `ComplexField()` in the code for `RR`.



---

archive/issue_comments_246974.json:
```json
{
    "body": "<a id='comment:8'>Comment 8:</a>\nReplying to [@jdemeyer](#comment%3A3):\n> Replying to [ticket:17984 rws]:\n> > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`\n\n> \n> Can you clarify this please?\n\nSee comment 28 of #12967.",
    "created_at": "2015-03-18T14:40:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246974",
    "user": "https://github.com/rwst"
}
```

<a id='comment:8'>Comment 8:</a>
Replying to [@jdemeyer](#comment%3A3):
> Replying to [ticket:17984 rws]:
> > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`

> 
> Can you clarify this please?

See comment 28 of #12967.



---

archive/issue_comments_246975.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,3 @@\n-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.\n+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`(See comment 28 of #12967). In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.\n \n Moreover, until now Maxima is used for this which is slow and completely unnecessary.\n``````\n",
    "created_at": "2015-03-18T14:40:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246975",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,3 @@
-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.
+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`(See comment 28 of #12967). In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.
 
 Moreover, until now Maxima is used for this which is slow and completely unnecessary.
``````




---

archive/issue_comments_246976.json:
```json
{
    "body": "<a id='comment:9'>Comment 9:</a>\nReplying to [@jdemeyer](#comment%3A4):\n> \n> ```\n> sage: RealField(10)(1/3) in RR\n> True\n> sage: RealField(10)(1/3) in CC\n> False\n> ```\n\nClever. But before I fix this: What about the doctests? Do you think that any of them gives a wrong result? Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?",
    "created_at": "2015-03-18T15:05:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246976",
    "user": "https://github.com/rwst"
}
```

<a id='comment:9'>Comment 9:</a>
Replying to [@jdemeyer](#comment%3A4):
> 
> ```
> sage: RealField(10)(1/3) in RR
> True
> sage: RealField(10)(1/3) in CC
> False
> ```

Clever. But before I fix this: What about the doctests? Do you think that any of them gives a wrong result? Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?



---

archive/issue_comments_246977.json:
```json
{
    "body": "<a id='comment:10'>Comment 10:</a>\nReplying to [@jdemeyer](#comment%3A6):\n> I also think this is wrong:\n> \n> ```\n> sage: NaN in RR\n> True\n> ```\n\nIf so, then I think this is wrong, too:\n\n```\nsage: RR(NaN)\nNaN\nsage: type(_)\n<type 'sage.rings.real_mpfr.RealNumber'>\n```",
    "created_at": "2015-03-18T15:25:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246977",
    "user": "https://github.com/rwst"
}
```

<a id='comment:10'>Comment 10:</a>
Replying to [@jdemeyer](#comment%3A6):
> I also think this is wrong:
> 
> ```
> sage: NaN in RR
> True
> ```

If so, then I think this is wrong, too:

```
sage: RR(NaN)
NaN
sage: type(_)
<type 'sage.rings.real_mpfr.RealNumber'>
```



---

archive/issue_comments_246978.json:
```json
{
    "body": "Changed commit from **[39ab5b2](https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6)** to **[a22a6e4](https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4)**",
    "created_at": "2015-03-18T16:27:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246978",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[39ab5b2](https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6)** to **[a22a6e4](https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4)**



---

archive/issue_comments_246979.json:
```json
{
    "body": "<a id='comment:11'>Comment 11:</a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4\">a22a6e4</a></td><td><code>17984: description in docstring; fixes and doctests</code></td></tr></table>\n",
    "created_at": "2015-03-18T16:27:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246979",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:11'>Comment 11:</a>
Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4">a22a6e4</a></td><td><code>17984: description in docstring; fixes and doctests</code></td></tr></table>




---

archive/issue_events_229593.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T16:29:12Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229593"
}
```



---

archive/issue_events_229594.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T16:29:12Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229594"
}
```



---

archive/issue_comments_246980.json:
```json
{
    "body": "<a id='comment:13'>Comment 13:</a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e\">544450e</a></td><td><code>17984: fix typo in doctest</code></td></tr></table>\n",
    "created_at": "2015-03-18T16:34:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246980",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:13'>Comment 13:</a>
Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e">544450e</a></td><td><code>17984: fix typo in doctest</code></td></tr></table>




---

archive/issue_comments_246981.json:
```json
{
    "body": "Changed commit from **[a22a6e4](https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4)** to **[544450e](https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e)**",
    "created_at": "2015-03-18T16:34:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246981",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[a22a6e4](https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4)** to **[544450e](https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e)**



---

archive/issue_comments_246982.json:
```json
{
    "body": "<a id='comment:14'>Comment 14:</a>\nReplying to [@rwst](#comment%3A9):\n> Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?\n\nYes, I think precision should be ignored for `contains`, therefore don't use `numerical_approx()` but a conversion like `RR(foo)` or `CC(foo)`.",
    "created_at": "2015-03-18T16:43:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246982",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:14'>Comment 14:</a>
Replying to [@rwst](#comment%3A9):
> Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?

Yes, I think precision should be ignored for `contains`, therefore don't use `numerical_approx()` but a conversion like `RR(foo)` or `CC(foo)`.



---

archive/issue_comments_246983.json:
```json
{
    "body": "<a id='comment:15'>Comment 15:</a>\nReplying to [@rwst](#comment%3A10):\n> If so, then I think this is wrong, too:\n> \n> ```\n> sage: RR(NaN)\n> NaN\n> sage: type(_)\n> <type 'sage.rings.real_mpfr.RealNumber'>\n> ```\n\nI don't think the above is wrong, it is possible to represent `NaN` by a `RealNumber`, but that doesn't mean that `NaN` can be considered as element of `RR`.",
    "created_at": "2015-03-18T16:45:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246983",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:15'>Comment 15:</a>
Replying to [@rwst](#comment%3A10):
> If so, then I think this is wrong, too:
> 
> ```
> sage: RR(NaN)
> NaN
> sage: type(_)
> <type 'sage.rings.real_mpfr.RealNumber'>
> ```

I don't think the above is wrong, it is possible to represent `NaN` by a `RealNumber`, but that doesn't mean that `NaN` can be considered as element of `RR`.



---

archive/issue_comments_246984.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,3 @@\n-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`(See comment 28 of #12967). In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.\n+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable dedicated `__contains__` methods for both rings are needed.\n \n Moreover, until now Maxima is used for this which is slow and completely unnecessary.\n``````\n",
    "created_at": "2015-03-18T17:31:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246984",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,3 @@
-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`(See comment 28 of #12967). In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.
+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable dedicated `__contains__` methods for both rings are needed.
 
 Moreover, until now Maxima is used for this which is slow and completely unnecessary.
``````




---

archive/issue_comments_246985.json:
```json
{
    "body": "<a id='comment:16'>Comment 16:</a>\nReplying to [@rwst](#comment%3A8):\n> Replying to [@jdemeyer](#comment%3A3):\n> > Replying to [ticket:17984 rws]:\n> > > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`\n\n> > \n> > Can you clarify this please?\n\n> \n> See comment 28 of #12967.\n\nAh, seems I was chasing ghosts there. Nevertheless the ticket makes sense because of the unreliability of the construction `bool(item==self(item))` for determining elementship.",
    "created_at": "2015-03-18T17:31:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246985",
    "user": "https://github.com/rwst"
}
```

<a id='comment:16'>Comment 16:</a>
Replying to [@rwst](#comment%3A8):
> Replying to [@jdemeyer](#comment%3A3):
> > Replying to [ticket:17984 rws]:
> > > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`

> > 
> > Can you clarify this please?

> 
> See comment 28 of #12967.

Ah, seems I was chasing ghosts there. Nevertheless the ticket makes sense because of the unreliability of the construction `bool(item==self(item))` for determining elementship.



---

archive/issue_comments_246986.json:
```json
{
    "body": "<a id='comment:17'>Comment 17:</a>\nI'm still pondering if this doctest is wrong:\n\n```\n            sage: pi in RIF # there is no element of RIF equal to pi\n            False\n```",
    "created_at": "2015-03-19T07:33:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246986",
    "user": "https://github.com/rwst"
}
```

<a id='comment:17'>Comment 17:</a>
I'm still pondering if this doctest is wrong:

```
            sage: pi in RIF # there is no element of RIF equal to pi
            False
```



---

archive/issue_comments_246987.json:
```json
{
    "body": "<a id='comment:18'>Comment 18:</a>\nReplying to [@rwst](#comment%3A17):\n> I'm still pondering if this doctest is wrong:\n> \n> ```\n>             sage: pi in RIF # there is no element of RIF equal to pi\n>             False\n> ```\n\nThe answer `False` seems correct to me.  The only numbers that can be represented exactly in `RIF` (i.e. as intervals of length 0) are elements of **Z**[1/2].",
    "created_at": "2015-03-19T09:55:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246987",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:18'>Comment 18:</a>
Replying to [@rwst](#comment%3A17):
> I'm still pondering if this doctest is wrong:
> 
> ```
>             sage: pi in RIF # there is no element of RIF equal to pi
>             False
> ```

The answer `False` seems correct to me.  The only numbers that can be represented exactly in `RIF` (i.e. as intervals of length 0) are elements of **Z**[1/2].



---

archive/issue_comments_246988.json:
```json
{
    "body": "<a id='comment:19'>Comment 19:</a>\nComments 35-44 of #12967 deal with this issue. Apologies for splitting this up.",
    "created_at": "2015-03-19T14:19:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246988",
    "user": "https://github.com/rwst"
}
```

<a id='comment:19'>Comment 19:</a>
Comments 35-44 of #12967 deal with this issue. Apologies for splitting this up.



---

archive/issue_comments_246989.json:
```json
{
    "body": "<a id='comment:20'>Comment 20:</a>\nI guess the first basic question is how to resolve the following inconsistency:\n\n```\nsage: bool(RR(pi) == pi)\nTrue\nsage: bool(RR(sqrt(2)) == sqrt(2))\nFalse\n```\nThe second basic question is, if we agree on what the correct result is, is this also the result that `x in RR` should return?\n\nPersonally I would answer the second question with \"yes\", if only for consistency; there is undoubtedly a lot of code using `x in P` that expects this behaviour, and it would be very inconvenient to change this just for `P = RR` and `P = CC` because of what users intuitively expect when typing `x in RR`.\n\nThe first question is harder.  One could argue that `bool(RR(pi) == pi)` should indeed return `True` because the two numbers become equal when converting to the lowest common precision (just as is done when comparing elements of two instances of `RealField` with different precision).  On the other hand, this is dangerous due to rounding errors:\n\n```\nsage: def t(x): return bool(RR(x) == x)\nsage: t(sqrt(2))\nFalse\nsage: t(sqrt(3))\nFalse\nsage: t(sqrt(3) - sqrt(2))\nTrue\n```\nHence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.  Unfortunately this moves `RR` a bit further away from the mathematical field **R** than it already is, but I guess that is better than pretending that `RR` is a general-purpose model for **R**.",
    "created_at": "2015-03-19T14:41:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246989",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:20'>Comment 20:</a>
I guess the first basic question is how to resolve the following inconsistency:

```
sage: bool(RR(pi) == pi)
True
sage: bool(RR(sqrt(2)) == sqrt(2))
False
```
The second basic question is, if we agree on what the correct result is, is this also the result that `x in RR` should return?

Personally I would answer the second question with "yes", if only for consistency; there is undoubtedly a lot of code using `x in P` that expects this behaviour, and it would be very inconvenient to change this just for `P = RR` and `P = CC` because of what users intuitively expect when typing `x in RR`.

The first question is harder.  One could argue that `bool(RR(pi) == pi)` should indeed return `True` because the two numbers become equal when converting to the lowest common precision (just as is done when comparing elements of two instances of `RealField` with different precision).  On the other hand, this is dangerous due to rounding errors:

```
sage: def t(x): return bool(RR(x) == x)
sage: t(sqrt(2))
False
sage: t(sqrt(3))
False
sage: t(sqrt(3) - sqrt(2))
True
```
Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.  Unfortunately this moves `RR` a bit further away from the mathematical field **R** than it already is, but I guess that is better than pretending that `RR` is a general-purpose model for **R**.



---

archive/issue_comments_246990.json:
```json
{
    "body": "<a id='comment:21'>Comment 21:</a>\nReplying to [@pjbruin](#comment%3A20):\n> I guess the first basic question is how to resolve the following inconsistency:\n> \n> ```\n> sage: bool(RR(pi) == pi)\n> True\n> sage: bool(RR(sqrt(2)) == sqrt(2))\n> False\n> ```\n\n>...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. \n\nAnd inexact elements compare the precision? And this condition would be the same for other inexact fields?\n\nThis looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship. So we again have special code, though it's special for inexact fields and it's not necessary to write it for every class.",
    "created_at": "2015-03-20T10:12:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246990",
    "user": "https://github.com/rwst"
}
```

<a id='comment:21'>Comment 21:</a>
Replying to [@pjbruin](#comment%3A20):
> I guess the first basic question is how to resolve the following inconsistency:
> 
> ```
> sage: bool(RR(pi) == pi)
> True
> sage: bool(RR(sqrt(2)) == sqrt(2))
> False
> ```

>...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. 

And inexact elements compare the precision? And this condition would be the same for other inexact fields?

This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship. So we again have special code, though it's special for inexact fields and it's not necessary to write it for every class.



---

archive/issue_comments_246991.json:
```json
{
    "body": "<a id='comment:22'>Comment 22:</a>\nReplying to [@rwst](#comment%3A21):\n> Replying to [@pjbruin](#comment%3A20):\n> > I guess the first basic question is how to resolve the following inconsistency:\n> > \n> > ```\n> > sage: bool(RR(pi) == pi)\n> > True\n> > sage: bool(RR(sqrt(2)) == sqrt(2))\n> > False\n> > ```\n\n> >...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. \n\n> And inexact elements compare the precision? And this condition would be the same for other inexact fields?\n\nI didn't say anytyhing about the case where `x` is an element of an inexact ring.  Currently (I think), if `x.parent() == RealField(m)`, then `x in RealField(n)` will return `True` regardless of `m` and `n`.  This could be changed of course, but that would break the general \"philosophy\" that Sage has been following so far (elements are compared in the ring with the lowest precision).\n> This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship.\n\nI don't understand this; the fact that `x` can be converted into `RR` does not imply that it is an element of `RR`.  The element `RR(x)` is just some candidate for \"the element of `RR` that is equal to `x`\", but we don't yet know if `x` and `RR(x)` are indeed equal in a meaningful way.  I guess you are talking about the case where `x.parent() is SR`.  Doesn't `bool(RR(x) == x)` then compare two elements of `SR`, one being the original `x` and the other being the result of converting to `RR` and back?  These can still be compared in a non-trivial way.",
    "created_at": "2015-03-20T10:57:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246991",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:22'>Comment 22:</a>
Replying to [@rwst](#comment%3A21):
> Replying to [@pjbruin](#comment%3A20):
> > I guess the first basic question is how to resolve the following inconsistency:
> > 
> > ```
> > sage: bool(RR(pi) == pi)
> > True
> > sage: bool(RR(sqrt(2)) == sqrt(2))
> > False
> > ```

> >...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. 

> And inexact elements compare the precision? And this condition would be the same for other inexact fields?

I didn't say anytyhing about the case where `x` is an element of an inexact ring.  Currently (I think), if `x.parent() == RealField(m)`, then `x in RealField(n)` will return `True` regardless of `m` and `n`.  This could be changed of course, but that would break the general "philosophy" that Sage has been following so far (elements are compared in the ring with the lowest precision).
> This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship.

I don't understand this; the fact that `x` can be converted into `RR` does not imply that it is an element of `RR`.  The element `RR(x)` is just some candidate for "the element of `RR` that is equal to `x`", but we don't yet know if `x` and `RR(x)` are indeed equal in a meaningful way.  I guess you are talking about the case where `x.parent() is SR`.  Doesn't `bool(RR(x) == x)` then compare two elements of `SR`, one being the original `x` and the other being the result of converting to `RR` and back?  These can still be compared in a non-trivial way.



---

archive/issue_comments_246992.json:
```json
{
    "body": "<a id='comment:23'>Comment 23:</a>\nNever mind. My mistake was to think that I needed `RR` to check your condition, but I can just check if `RR(x)` has finite precision.",
    "created_at": "2015-03-20T13:50:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246992",
    "user": "https://github.com/rwst"
}
```

<a id='comment:23'>Comment 23:</a>
Never mind. My mistake was to think that I needed `RR` to check your condition, but I can just check if `RR(x)` has finite precision.



---

archive/issue_comments_246993.json:
```json
{
    "body": "<a id='comment:24'>Comment 24:</a>\nReplying to [@pjbruin](#comment%3A20):\n> Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.\n\nCan you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.\n\nSo, either no integers and rationals are `in RR`, or `RR` elements must carry an exact flag that is set to `False` when an operation with an inexact element is performed, or, most probably, I'm missing something about how to spot elements with exact representation in `RR/CC`. I cannot imagine you would mean `1` is exactly representable in `RR` because `1 == RR(1)`, since that would obviously be circular with your definition.",
    "created_at": "2015-03-21T07:25:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246993",
    "user": "https://github.com/rwst"
}
```

<a id='comment:24'>Comment 24:</a>
Replying to [@pjbruin](#comment%3A20):
> Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.

Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.

So, either no integers and rationals are `in RR`, or `RR` elements must carry an exact flag that is set to `False` when an operation with an inexact element is performed, or, most probably, I'm missing something about how to spot elements with exact representation in `RR/CC`. I cannot imagine you would mean `1` is exactly representable in `RR` because `1 == RR(1)`, since that would obviously be circular with your definition.



---

archive/issue_comments_246994.json:
```json
{
    "body": "<a id='comment:25'>Comment 25:</a>\nReplying to [@rwst](#comment%3A24):\n> Replying to [@pjbruin](#comment%3A20):\n> > Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.\n\n> Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.\n\nElements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.\n\nDifferent people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.  The interpretation \"an element of `RR` is a real number with some error\" is just interpretation.  One could say that what is inexact about `RR` are not the elements themselves, but the operations; rounding has to take place because this subset is not closed under the usual operations.\n\nA related `sage-devel` discussion: https://groups.google.com/forum/#!topic/sage-devel/1gPkeL_X5dw",
    "created_at": "2015-03-21T07:57:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246994",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:25'>Comment 25:</a>
Replying to [@rwst](#comment%3A24):
> Replying to [@pjbruin](#comment%3A20):
> > Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.

> Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.

Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.

Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.  The interpretation "an element of `RR` is a real number with some error" is just interpretation.  One could say that what is inexact about `RR` are not the elements themselves, but the operations; rounding has to take place because this subset is not closed under the usual operations.

A related `sage-devel` discussion: https://groups.google.com/forum/#!topic/sage-devel/1gPkeL_X5dw



---

archive/issue_comments_246995.json:
```json
{
    "body": "<a id='comment:26'>Comment 26:</a>\nReplying to [@pjbruin](#comment%3A25):\n> Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.\n\nSo this would be similar (equal?) to what was recently said about `RIF` in https://groups.google.com/d/topic/sage-devel/9MHkb4cUUHM/discussion\n\n> Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.\n\nSo, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.",
    "created_at": "2015-03-21T08:52:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246995",
    "user": "https://github.com/rwst"
}
```

<a id='comment:26'>Comment 26:</a>
Replying to [@pjbruin](#comment%3A25):
> Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.

So this would be similar (equal?) to what was recently said about `RIF` in https://groups.google.com/d/topic/sage-devel/9MHkb4cUUHM/discussion

> Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.

So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.



---

archive/issue_comments_246996.json:
```json
{
    "body": "<a id='comment:27'>Comment 27:</a>\n> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.\n\nNote that at the moment `1/5 == RR(1/5)`.",
    "created_at": "2015-03-21T09:01:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246996",
    "user": "https://github.com/rwst"
}
```

<a id='comment:27'>Comment 27:</a>
> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.

Note that at the moment `1/5 == RR(1/5)`.



---

archive/issue_comments_246997.json:
```json
{
    "body": "<a id='comment:28'>Comment 28:</a>\nReplying to [@rwst](#comment%3A26):\n> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.\n\nAh okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.",
    "created_at": "2015-03-21T09:53:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246997",
    "user": "https://github.com/rwst"
}
```

<a id='comment:28'>Comment 28:</a>
Replying to [@rwst](#comment%3A26):
> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.

Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.



---

archive/issue_comments_246998.json:
```json
{
    "body": "<a id='comment:29'>Comment 29:</a>\nReplying to [@rwst](#comment%3A28):\n> Replying to [@rwst](#comment%3A26):\n> > So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.\n\n> Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.\n\nThis method makes sense in `RIF` but not in `RR`: a number is exact in `RIF` if the associated interval is a singleton. This is very different from the proposition of having a method `RR.is_exactly_representable(...)`.\n\nI do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field\n\n``` \nsage: RR.is_field()\nTrue\nsage: RR in Fields()\nTrue\n```\n\nVincent",
    "created_at": "2015-03-21T10:01:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246998",
    "user": "https://github.com/videlec"
}
```

<a id='comment:29'>Comment 29:</a>
Replying to [@rwst](#comment%3A28):
> Replying to [@rwst](#comment%3A26):
> > So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.

> Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.

This method makes sense in `RIF` but not in `RR`: a number is exact in `RIF` if the associated interval is a singleton. This is very different from the proposition of having a method `RR.is_exactly_representable(...)`.

I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field

``` 
sage: RR.is_field()
True
sage: RR in Fields()
True
```

Vincent



---

archive/issue_events_229595.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-21T14:04:58Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229595"
}
```



---

archive/issue_events_229596.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-21T14:04:58Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229596"
}
```



---

archive/issue_comments_246999.json:
```json
{
    "body": "<a id='comment:30'>Comment 30:</a>\nReplying to [@videlec](#comment%3A29):\n> I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field\n\nWhat would be consequences of removing it from the set (apart from documentation issues)?",
    "created_at": "2015-03-21T14:04:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-246999",
    "user": "https://github.com/rwst"
}
```

<a id='comment:30'>Comment 30:</a>
Replying to [@videlec](#comment%3A29):
> I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field

What would be consequences of removing it from the set (apart from documentation issues)?



---

archive/issue_comments_247000.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,6 @@\n-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable dedicated `__contains__` methods for both rings are needed.\n+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n+\n+Previously this ticket proposed that:\n+...dedicated `__contains__` methods for both rings are needed.\n \n Moreover, until now Maxima is used for this which is slow and completely unnecessary.\n``````\n",
    "created_at": "2015-03-21T14:04:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247000",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,6 @@
-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable dedicated `__contains__` methods for both rings are needed.
+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.
+
+Previously this ticket proposed that:
+...dedicated `__contains__` methods for both rings are needed.
 
 Moreover, until now Maxima is used for this which is slow and completely unnecessary.
``````




---

archive/issue_events_229597.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-21T14:04:58Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "title_is": "fix Parent.__contains__",
    "title_was": "Dedicated RR.__contains__() and CC.__contains__()",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229597"
}
```



---

archive/issue_comments_247001.json:
```json
{
    "body": "<a id='comment:31'>Comment 31:</a>\nPing?",
    "created_at": "2015-05-24T16:03:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247001",
    "user": "https://github.com/rwst"
}
```

<a id='comment:31'>Comment 31:</a>
Ping?



---

archive/issue_events_229598.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229598"
}
```



---

archive/issue_events_229599.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229599"
}
```



---

archive/issue_events_229600.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "milestone_number": null,
    "milestone_title": "sage-6.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229600"
}
```



---

archive/issue_events_229601.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "milestone_number": null,
    "milestone_title": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229601"
}
```



---

archive/issue_events_229602.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229602"
}
```



---

archive/issue_events_229603.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229603"
}
```



---

archive/issue_comments_247002.json:
```json
{
    "body": "<a id='comment:32'>Comment 32:</a>\nThis issue has come up again with working on #19040. This is intolerable. I will have to have a new attempt at this, maybe I understand the arguments better now.",
    "created_at": "2015-09-20T13:47:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247002",
    "user": "https://github.com/rwst"
}
```

<a id='comment:32'>Comment 32:</a>
This issue has come up again with working on #19040. This is intolerable. I will have to have a new attempt at this, maybe I understand the arguments better now.



---

archive/issue_comments_247003.json:
```json
{
    "body": "Changed branch from **[u/rws/17984](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984)** to **[u/rws/17984-1](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984-1)**",
    "created_at": "2015-09-20T15:46:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247003",
    "user": "https://github.com/rwst"
}
```

Changed branch from **[u/rws/17984](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984)** to **[u/rws/17984-1](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984-1)**



---

archive/issue_comments_247004.json:
```json
{
    "body": "Dependencies: **#19040**",
    "created_at": "2015-09-20T15:48:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247004",
    "user": "https://github.com/rwst"
}
```

Dependencies: **#19040**



---

archive/issue_comments_247005.json:
```json
{
    "body": "<a id='comment:34'>Comment 34:</a>\nThe solution is quite simple with #19040 (which is no completely here yet).\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f\">1edc690</a></td><td><code>17984: simplify contains, dependent on 19040</code></td></tr></table>\n",
    "created_at": "2015-09-20T15:48:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247005",
    "user": "https://github.com/rwst"
}
```

<a id='comment:34'>Comment 34:</a>
The solution is quite simple with #19040 (which is no completely here yet).

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f">1edc690</a></td><td><code>17984: simplify contains, dependent on 19040</code></td></tr></table>




---

archive/issue_comments_247006.json:
```json
{
    "body": "Changed commit from **[544450e](https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e)** to **[1edc690](https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f)**",
    "created_at": "2015-09-20T15:48:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247006",
    "user": "https://github.com/rwst"
}
```

Changed commit from **[544450e](https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e)** to **[1edc690](https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f)**



---

archive/issue_comments_247007.json:
```json
{
    "body": "Changed commit from **[1edc690](https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f)** to none",
    "created_at": "2015-09-21T13:48:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247007",
    "user": "https://github.com/rwst"
}
```

Changed commit from **[1edc690](https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f)** to none



---

archive/issue_comments_247008.json:
```json
{
    "body": "Changed branch from **[u/rws/17984-1](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984-1)** to none",
    "created_at": "2015-09-21T13:48:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247008",
    "user": "https://github.com/rwst"
}
```

Changed branch from **[u/rws/17984-1](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984-1)** to none



---

archive/issue_comments_247009.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,9 @@\n-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.\n+\n+Of course, as soon as we want to get rid of Maxima this must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n+\n+In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n \n Previously this ticket proposed that:\n ...dedicated `__contains__` methods for both rings are needed.\n \n-Moreover, until now Maxima is used for this which is slow and completely unnecessary.\n``````\n",
    "created_at": "2015-09-21T13:48:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247009",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,9 @@
-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.
+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.
+
+Of course, as soon as we want to get rid of Maxima this must be simulated, because there is no way to test containment in these inexact rings in a generic way.
+
+In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.
 
 Previously this ticket proposed that:
 ...dedicated `__contains__` methods for both rings are needed.
 
-Moreover, until now Maxima is used for this which is slow and completely unnecessary.
``````




---

archive/issue_comments_247010.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,8 @@\n In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.\n \n-Of course, as soon as we want to get rid of Maxima this must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n+This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC weren needed. As you can see from the discussion this was not wanted.\n+\n+Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n \n In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n \n``````\n",
    "created_at": "2016-03-10T15:50:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247010",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,8 @@
 In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.
 
-Of course, as soon as we want to get rid of Maxima this must be simulated, because there is no way to test containment in these inexact rings in a generic way.
+This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC weren needed. As you can see from the discussion this was not wanted.
+
+Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.
 
 In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.
 
``````




---

archive/issue_comments_247011.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,6 @@\n In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.\n \n-This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC weren needed. As you can see from the discussion this was not wanted.\n+This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC were needed. As you can see from the discussion this was not wanted.\n \n Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n \n``````\n",
    "created_at": "2016-03-10T15:51:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247011",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,6 @@
 In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.
 
-This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC weren needed. As you can see from the discussion this was not wanted.
+This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC were needed. As you can see from the discussion this was not wanted.
 
 Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.
 
``````




---

archive/issue_comments_247012.json:
```json
{
    "body": "<a id='comment:38'>Comment 38:</a>\nUnexpectedly it looks like we get a much more correct fix whenever we'll have #24456.",
    "created_at": "2018-01-15T08:36:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-247012",
    "user": "https://github.com/rwst"
}
```

<a id='comment:38'>Comment 38:</a>
Unexpectedly it looks like we get a much more correct fix whenever we'll have #24456.



---

archive/issue_events_229604.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-12-29T01:33:44Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "milestone_number": null,
    "milestone_title": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-229604"
}
```
