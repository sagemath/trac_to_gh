# Issue 17984: fix Parent.__contains__

archive/issues_017747.json:
```json
{
    "assignees": [],
    "body": "In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.\n\nThis way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC were needed. As you can see from the discussion this was not wanted.\n\nOf course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n\nIn order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n\nPreviously this ticket proposed that:\n...dedicated `__contains__` methods for both rings are needed.\n\n\nDepends on #19040\n\nCC:  @sagetrac-tmonteil\n\nComponent: **basic arithmetic**\n\nAuthor: **Ralf Stephan**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/17984_\n\n",
    "created_at": "2015-03-18T09:59:31Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20basic%20arithmetic",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "fix Parent.__contains__",
    "type": "issue",
    "updated_at": "2022-12-29T01:33:44Z",
    "url": "https://github.com/sagemath/sage/issues/17984",
    "user": "https://github.com/rwst"
}
```
In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.

This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC were needed. As you can see from the discussion this was not wanted.

Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.

In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.

Previously this ticket proposed that:
...dedicated `__contains__` methods for both rings are needed.


Depends on #19040

CC:  @sagetrac-tmonteil

Component: **basic arithmetic**

Author: **Ralf Stephan**

_Issue created by migration from https://trac.sagemath.org/ticket/17984_





---

archive/issue_events_253543.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T09:59:31Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "milestone_number": null,
    "milestone_title": "sage-6.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253543"
}
```



---

archive/issue_events_253544.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T09:59:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20basic%20arithmetic",
    "label_color": "0000ff",
    "label_name": "c: basic arithmetic",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253544"
}
```



---

archive/issue_events_253545.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T09:59:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253545"
}
```



---

archive/issue_events_253546.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T09:59:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253546"
}
```



---

archive/issue_comments_244396.json:
```json
{
    "body": "Branch: **[u/rws/17984](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984)**",
    "created_at": "2015-03-18T10:01:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244396",
    "user": "https://github.com/rwst"
}
```

Branch: **[u/rws/17984](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984)**



---

archive/issue_events_253547.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T10:01:42Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253547"
}
```



---

archive/issue_comments_244397.json:
```json
{
    "body": "Commit: **[`39ab5b2`](https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6)**",
    "created_at": "2015-03-18T10:01:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244397",
    "user": "https://github.com/rwst"
}
```

Commit: **[`39ab5b2`](https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6)**



---

archive/issue_comments_244398.json:
```json
{
    "body": "<div id=\"comment:2\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6\"><code>39ab5b2</code></a></td><td><code>17984: Dedicated RR.__contains__() and CC.__contains__()</code></td></tr></table>\n",
    "created_at": "2015-03-18T10:01:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244398",
    "user": "https://github.com/rwst"
}
```

<div id="comment:2"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6"><code>39ab5b2</code></a></td><td><code>17984: Dedicated RR.__contains__() and CC.__contains__()</code></td></tr></table>




---

archive/issue_comments_244399.json:
```json
{
    "body": "Author: **Ralf Stephan**",
    "created_at": "2015-03-18T10:01:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244399",
    "user": "https://github.com/rwst"
}
```

Author: **Ralf Stephan**



---

archive/issue_comments_244400.json:
```json
{
    "body": "Replying to [ticket:17984 rws]:\n> In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`\n\nCan you clarify this please?",
    "created_at": "2015-03-18T13:11:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244400",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [ticket:17984 rws]:
> In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`

Can you clarify this please?



---

archive/issue_comments_244401.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\n\n```\nsage: RealField(10)(1/3) in RR\nTrue\nsage: RealField(10)(1/3) in CC\nFalse\n```",
    "created_at": "2015-03-18T13:13:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244401",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:4" align="right">comment:4</div>


```
sage: RealField(10)(1/3) in RR
True
sage: RealField(10)(1/3) in CC
False
```



---

archive/issue_events_253548.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-03-18T13:13:55Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253548"
}
```



---

archive/issue_events_253549.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-03-18T13:13:55Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253549"
}
```



---

archive/issue_comments_244402.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nWhy this???\n\n```\nsage: [1,2,3] in CC\nTrue\n```",
    "created_at": "2015-03-18T13:14:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244402",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:5" align="right">comment:5</div>

Why this???

```
sage: [1,2,3] in CC
True
```



---

archive/issue_comments_244403.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nI also think this is wrong:\n\n```\nsage: NaN in RR\nTrue\n```",
    "created_at": "2015-03-18T13:14:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244403",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:6" align="right">comment:6</div>

I also think this is wrong:

```
sage: NaN in RR
True
```



---

archive/issue_comments_244404.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nAlso please explain why you use `ComplexField()` in the code for `RR`.",
    "created_at": "2015-03-18T13:19:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244404",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:7" align="right">comment:7</div>

Also please explain why you use `ComplexField()` in the code for `RR`.



---

archive/issue_comments_244405.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nReplying to [@jdemeyer](#comment%3A3):\n> Replying to [ticket:17984 rws]:\n> > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`\n\n> \n> Can you clarify this please?\n\nSee comment 28 of #12967.",
    "created_at": "2015-03-18T14:40:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244405",
    "user": "https://github.com/rwst"
}
```

<div id="comment:8" align="right">comment:8</div>

Replying to [@jdemeyer](#comment%3A3):
> Replying to [ticket:17984 rws]:
> > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`

> 
> Can you clarify this please?

See comment 28 of #12967.



---

archive/issue_comments_244406.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,3 @@\n-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.\n+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`(See comment 28 of #12967). In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.\n \n Moreover, until now Maxima is used for this which is slow and completely unnecessary.\n``````\n",
    "created_at": "2015-03-18T14:40:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244406",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,3 @@
-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.
+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`(See comment 28 of #12967). In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.
 
 Moreover, until now Maxima is used for this which is slow and completely unnecessary.
``````




---

archive/issue_comments_244407.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nReplying to [@jdemeyer](#comment%3A4):\n> \n> ```\n> sage: RealField(10)(1/3) in RR\n> True\n> sage: RealField(10)(1/3) in CC\n> False\n> ```\n\nClever. But before I fix this: What about the doctests? Do you think that any of them gives a wrong result? Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?",
    "created_at": "2015-03-18T15:05:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244407",
    "user": "https://github.com/rwst"
}
```

<div id="comment:9" align="right">comment:9</div>

Replying to [@jdemeyer](#comment%3A4):
> 
> ```
> sage: RealField(10)(1/3) in RR
> True
> sage: RealField(10)(1/3) in CC
> False
> ```

Clever. But before I fix this: What about the doctests? Do you think that any of them gives a wrong result? Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?



---

archive/issue_comments_244408.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nReplying to [@jdemeyer](#comment%3A6):\n> I also think this is wrong:\n> \n> ```\n> sage: NaN in RR\n> True\n> ```\n\nIf so, then I think this is wrong, too:\n\n```\nsage: RR(NaN)\nNaN\nsage: type(_)\n<type 'sage.rings.real_mpfr.RealNumber'>\n```",
    "created_at": "2015-03-18T15:25:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244408",
    "user": "https://github.com/rwst"
}
```

<div id="comment:10" align="right">comment:10</div>

Replying to [@jdemeyer](#comment%3A6):
> I also think this is wrong:
> 
> ```
> sage: NaN in RR
> True
> ```

If so, then I think this is wrong, too:

```
sage: RR(NaN)
NaN
sage: type(_)
<type 'sage.rings.real_mpfr.RealNumber'>
```



---

archive/issue_comments_244409.json:
```json
{
    "body": "Changed commit from **[`39ab5b2`](https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6)** to **[`a22a6e4`](https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4)**",
    "created_at": "2015-03-18T16:27:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244409",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`39ab5b2`](https://github.com/sagemath/sagetrac-mirror/commit/39ab5b2a9f6057e08a7aced6f58daa2de3c4cbe6)** to **[`a22a6e4`](https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4)**



---

archive/issue_comments_244410.json:
```json
{
    "body": "<div id=\"comment:11\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4\"><code>a22a6e4</code></a></td><td><code>17984: description in docstring; fixes and doctests</code></td></tr></table>\n",
    "created_at": "2015-03-18T16:27:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244410",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:11"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4"><code>a22a6e4</code></a></td><td><code>17984: description in docstring; fixes and doctests</code></td></tr></table>




---

archive/issue_events_253550.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T16:29:12Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253550"
}
```



---

archive/issue_events_253551.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-18T16:29:12Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253551"
}
```



---

archive/issue_comments_244411.json:
```json
{
    "body": "<div id=\"comment:13\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e\"><code>544450e</code></a></td><td><code>17984: fix typo in doctest</code></td></tr></table>\n",
    "created_at": "2015-03-18T16:34:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244411",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:13"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e"><code>544450e</code></a></td><td><code>17984: fix typo in doctest</code></td></tr></table>




---

archive/issue_comments_244412.json:
```json
{
    "body": "Changed commit from **[`a22a6e4`](https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4)** to **[`544450e`](https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e)**",
    "created_at": "2015-03-18T16:34:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244412",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`a22a6e4`](https://github.com/sagemath/sagetrac-mirror/commit/a22a6e47dabea2b8b4c42ee7e21b0a8777a8dba4)** to **[`544450e`](https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e)**



---

archive/issue_comments_244413.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nReplying to [@rwst](#comment%3A9):\n> Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?\n\nYes, I think precision should be ignored for `contains`, therefore don't use `numerical_approx()` but a conversion like `RR(foo)` or `CC(foo)`.",
    "created_at": "2015-03-18T16:43:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244413",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:14" align="right">comment:14</div>

Replying to [@rwst](#comment%3A9):
> Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?

Yes, I think precision should be ignored for `contains`, therefore don't use `numerical_approx()` but a conversion like `RR(foo)` or `CC(foo)`.



---

archive/issue_comments_244414.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nReplying to [@rwst](#comment%3A10):\n> If so, then I think this is wrong, too:\n> \n> ```\n> sage: RR(NaN)\n> NaN\n> sage: type(_)\n> <type 'sage.rings.real_mpfr.RealNumber'>\n> ```\n\nI don't think the above is wrong, it is possible to represent `NaN` by a `RealNumber`, but that doesn't mean that `NaN` can be considered as element of `RR`.",
    "created_at": "2015-03-18T16:45:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244414",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:15" align="right">comment:15</div>

Replying to [@rwst](#comment%3A10):
> If so, then I think this is wrong, too:
> 
> ```
> sage: RR(NaN)
> NaN
> sage: type(_)
> <type 'sage.rings.real_mpfr.RealNumber'>
> ```

I don't think the above is wrong, it is possible to represent `NaN` by a `RealNumber`, but that doesn't mean that `NaN` can be considered as element of `RR`.



---

archive/issue_comments_244415.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,3 @@\n-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`(See comment 28 of #12967). In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.\n+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable dedicated `__contains__` methods for both rings are needed.\n \n Moreover, until now Maxima is used for this which is slow and completely unnecessary.\n``````\n",
    "created_at": "2015-03-18T17:31:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244415",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,3 @@
-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`(See comment 28 of #12967). In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.
+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable dedicated `__contains__` methods for both rings are needed.
 
 Moreover, until now Maxima is used for this which is slow and completely unnecessary.
``````




---

archive/issue_comments_244416.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nReplying to [@rwst](#comment%3A8):\n> Replying to [@jdemeyer](#comment%3A3):\n> > Replying to [ticket:17984 rws]:\n> > > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`\n\n> > \n> > Can you clarify this please?\n\n> \n> See comment 28 of #12967.\n\nAh, seems I was chasing ghosts there. Nevertheless the ticket makes sense because of the unreliability of the construction `bool(item==self(item))` for determining elementship.",
    "created_at": "2015-03-18T17:31:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244416",
    "user": "https://github.com/rwst"
}
```

<div id="comment:16" align="right">comment:16</div>

Replying to [@rwst](#comment%3A8):
> Replying to [@jdemeyer](#comment%3A3):
> > Replying to [ticket:17984 rws]:
> > > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`

> > 
> > Can you clarify this please?

> 
> See comment 28 of #12967.

Ah, seems I was chasing ghosts there. Nevertheless the ticket makes sense because of the unreliability of the construction `bool(item==self(item))` for determining elementship.



---

archive/issue_comments_244417.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nI'm still pondering if this doctest is wrong:\n\n```\n            sage: pi in RIF # there is no element of RIF equal to pi\n            False\n```",
    "created_at": "2015-03-19T07:33:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244417",
    "user": "https://github.com/rwst"
}
```

<div id="comment:17" align="right">comment:17</div>

I'm still pondering if this doctest is wrong:

```
            sage: pi in RIF # there is no element of RIF equal to pi
            False
```



---

archive/issue_comments_244418.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nReplying to [@rwst](#comment%3A17):\n> I'm still pondering if this doctest is wrong:\n> \n> ```\n>             sage: pi in RIF # there is no element of RIF equal to pi\n>             False\n> ```\n\nThe answer `False` seems correct to me.  The only numbers that can be represented exactly in `RIF` (i.e. as intervals of length 0) are elements of **Z**[1/2].",
    "created_at": "2015-03-19T09:55:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244418",
    "user": "https://github.com/pjbruin"
}
```

<div id="comment:18" align="right">comment:18</div>

Replying to [@rwst](#comment%3A17):
> I'm still pondering if this doctest is wrong:
> 
> ```
>             sage: pi in RIF # there is no element of RIF equal to pi
>             False
> ```

The answer `False` seems correct to me.  The only numbers that can be represented exactly in `RIF` (i.e. as intervals of length 0) are elements of **Z**[1/2].



---

archive/issue_comments_244419.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nComments 35-44 of #12967 deal with this issue. Apologies for splitting this up.",
    "created_at": "2015-03-19T14:19:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244419",
    "user": "https://github.com/rwst"
}
```

<div id="comment:19" align="right">comment:19</div>

Comments 35-44 of #12967 deal with this issue. Apologies for splitting this up.



---

archive/issue_comments_244420.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nI guess the first basic question is how to resolve the following inconsistency:\n\n```\nsage: bool(RR(pi) == pi)\nTrue\nsage: bool(RR(sqrt(2)) == sqrt(2))\nFalse\n```\nThe second basic question is, if we agree on what the correct result is, is this also the result that `x in RR` should return?\n\nPersonally I would answer the second question with \"yes\", if only for consistency; there is undoubtedly a lot of code using `x in P` that expects this behaviour, and it would be very inconvenient to change this just for `P = RR` and `P = CC` because of what users intuitively expect when typing `x in RR`.\n\nThe first question is harder.  One could argue that `bool(RR(pi) == pi)` should indeed return `True` because the two numbers become equal when converting to the lowest common precision (just as is done when comparing elements of two instances of `RealField` with different precision).  On the other hand, this is dangerous due to rounding errors:\n\n```\nsage: def t(x): return bool(RR(x) == x)\nsage: t(sqrt(2))\nFalse\nsage: t(sqrt(3))\nFalse\nsage: t(sqrt(3) - sqrt(2))\nTrue\n```\nHence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.  Unfortunately this moves `RR` a bit further away from the mathematical field **R** than it already is, but I guess that is better than pretending that `RR` is a general-purpose model for **R**.",
    "created_at": "2015-03-19T14:41:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244420",
    "user": "https://github.com/pjbruin"
}
```

<div id="comment:20" align="right">comment:20</div>

I guess the first basic question is how to resolve the following inconsistency:

```
sage: bool(RR(pi) == pi)
True
sage: bool(RR(sqrt(2)) == sqrt(2))
False
```
The second basic question is, if we agree on what the correct result is, is this also the result that `x in RR` should return?

Personally I would answer the second question with "yes", if only for consistency; there is undoubtedly a lot of code using `x in P` that expects this behaviour, and it would be very inconvenient to change this just for `P = RR` and `P = CC` because of what users intuitively expect when typing `x in RR`.

The first question is harder.  One could argue that `bool(RR(pi) == pi)` should indeed return `True` because the two numbers become equal when converting to the lowest common precision (just as is done when comparing elements of two instances of `RealField` with different precision).  On the other hand, this is dangerous due to rounding errors:

```
sage: def t(x): return bool(RR(x) == x)
sage: t(sqrt(2))
False
sage: t(sqrt(3))
False
sage: t(sqrt(3) - sqrt(2))
True
```
Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.  Unfortunately this moves `RR` a bit further away from the mathematical field **R** than it already is, but I guess that is better than pretending that `RR` is a general-purpose model for **R**.



---

archive/issue_comments_244421.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nReplying to [@pjbruin](#comment%3A20):\n> I guess the first basic question is how to resolve the following inconsistency:\n> \n> ```\n> sage: bool(RR(pi) == pi)\n> True\n> sage: bool(RR(sqrt(2)) == sqrt(2))\n> False\n> ```\n\n>...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. \n\nAnd inexact elements compare the precision? And this condition would be the same for other inexact fields?\n\nThis looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship. So we again have special code, though it's special for inexact fields and it's not necessary to write it for every class.",
    "created_at": "2015-03-20T10:12:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244421",
    "user": "https://github.com/rwst"
}
```

<div id="comment:21" align="right">comment:21</div>

Replying to [@pjbruin](#comment%3A20):
> I guess the first basic question is how to resolve the following inconsistency:
> 
> ```
> sage: bool(RR(pi) == pi)
> True
> sage: bool(RR(sqrt(2)) == sqrt(2))
> False
> ```

>...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. 

And inexact elements compare the precision? And this condition would be the same for other inexact fields?

This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship. So we again have special code, though it's special for inexact fields and it's not necessary to write it for every class.



---

archive/issue_comments_244422.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nReplying to [@rwst](#comment%3A21):\n> Replying to [@pjbruin](#comment%3A20):\n> > I guess the first basic question is how to resolve the following inconsistency:\n> > \n> > ```\n> > sage: bool(RR(pi) == pi)\n> > True\n> > sage: bool(RR(sqrt(2)) == sqrt(2))\n> > False\n> > ```\n\n> >...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. \n\n> And inexact elements compare the precision? And this condition would be the same for other inexact fields?\n\nI didn't say anytyhing about the case where `x` is an element of an inexact ring.  Currently (I think), if `x.parent() == RealField(m)`, then `x in RealField(n)` will return `True` regardless of `m` and `n`.  This could be changed of course, but that would break the general \"philosophy\" that Sage has been following so far (elements are compared in the ring with the lowest precision).\n> This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship.\n\nI don't understand this; the fact that `x` can be converted into `RR` does not imply that it is an element of `RR`.  The element `RR(x)` is just some candidate for \"the element of `RR` that is equal to `x`\", but we don't yet know if `x` and `RR(x)` are indeed equal in a meaningful way.  I guess you are talking about the case where `x.parent() is SR`.  Doesn't `bool(RR(x) == x)` then compare two elements of `SR`, one being the original `x` and the other being the result of converting to `RR` and back?  These can still be compared in a non-trivial way.",
    "created_at": "2015-03-20T10:57:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244422",
    "user": "https://github.com/pjbruin"
}
```

<div id="comment:22" align="right">comment:22</div>

Replying to [@rwst](#comment%3A21):
> Replying to [@pjbruin](#comment%3A20):
> > I guess the first basic question is how to resolve the following inconsistency:
> > 
> > ```
> > sage: bool(RR(pi) == pi)
> > True
> > sage: bool(RR(sqrt(2)) == sqrt(2))
> > False
> > ```

> >...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. 

> And inexact elements compare the precision? And this condition would be the same for other inexact fields?

I didn't say anytyhing about the case where `x` is an element of an inexact ring.  Currently (I think), if `x.parent() == RealField(m)`, then `x in RealField(n)` will return `True` regardless of `m` and `n`.  This could be changed of course, but that would break the general "philosophy" that Sage has been following so far (elements are compared in the ring with the lowest precision).
> This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship.

I don't understand this; the fact that `x` can be converted into `RR` does not imply that it is an element of `RR`.  The element `RR(x)` is just some candidate for "the element of `RR` that is equal to `x`", but we don't yet know if `x` and `RR(x)` are indeed equal in a meaningful way.  I guess you are talking about the case where `x.parent() is SR`.  Doesn't `bool(RR(x) == x)` then compare two elements of `SR`, one being the original `x` and the other being the result of converting to `RR` and back?  These can still be compared in a non-trivial way.



---

archive/issue_comments_244423.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nNever mind. My mistake was to think that I needed `RR` to check your condition, but I can just check if `RR(x)` has finite precision.",
    "created_at": "2015-03-20T13:50:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244423",
    "user": "https://github.com/rwst"
}
```

<div id="comment:23" align="right">comment:23</div>

Never mind. My mistake was to think that I needed `RR` to check your condition, but I can just check if `RR(x)` has finite precision.



---

archive/issue_comments_244424.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nReplying to [@pjbruin](#comment%3A20):\n> Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.\n\nCan you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.\n\nSo, either no integers and rationals are `in RR`, or `RR` elements must carry an exact flag that is set to `False` when an operation with an inexact element is performed, or, most probably, I'm missing something about how to spot elements with exact representation in `RR/CC`. I cannot imagine you would mean `1` is exactly representable in `RR` because `1 == RR(1)`, since that would obviously be circular with your definition.",
    "created_at": "2015-03-21T07:25:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244424",
    "user": "https://github.com/rwst"
}
```

<div id="comment:24" align="right">comment:24</div>

Replying to [@pjbruin](#comment%3A20):
> Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.

Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.

So, either no integers and rationals are `in RR`, or `RR` elements must carry an exact flag that is set to `False` when an operation with an inexact element is performed, or, most probably, I'm missing something about how to spot elements with exact representation in `RR/CC`. I cannot imagine you would mean `1` is exactly representable in `RR` because `1 == RR(1)`, since that would obviously be circular with your definition.



---

archive/issue_comments_244425.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nReplying to [@rwst](#comment%3A24):\n> Replying to [@pjbruin](#comment%3A20):\n> > Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.\n\n> Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.\n\nElements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.\n\nDifferent people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.  The interpretation \"an element of `RR` is a real number with some error\" is just interpretation.  One could say that what is inexact about `RR` are not the elements themselves, but the operations; rounding has to take place because this subset is not closed under the usual operations.\n\nA related `sage-devel` discussion: https://groups.google.com/forum/#!topic/sage-devel/1gPkeL_X5dw",
    "created_at": "2015-03-21T07:57:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244425",
    "user": "https://github.com/pjbruin"
}
```

<div id="comment:25" align="right">comment:25</div>

Replying to [@rwst](#comment%3A24):
> Replying to [@pjbruin](#comment%3A20):
> > Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.

> Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.

Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.

Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.  The interpretation "an element of `RR` is a real number with some error" is just interpretation.  One could say that what is inexact about `RR` are not the elements themselves, but the operations; rounding has to take place because this subset is not closed under the usual operations.

A related `sage-devel` discussion: https://groups.google.com/forum/#!topic/sage-devel/1gPkeL_X5dw



---

archive/issue_comments_244426.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nReplying to [@pjbruin](#comment%3A25):\n> Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.\n\nSo this would be similar (equal?) to what was recently said about `RIF` in https://groups.google.com/d/topic/sage-devel/9MHkb4cUUHM/discussion\n\n> Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.\n\nSo, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.",
    "created_at": "2015-03-21T08:52:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244426",
    "user": "https://github.com/rwst"
}
```

<div id="comment:26" align="right">comment:26</div>

Replying to [@pjbruin](#comment%3A25):
> Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.

So this would be similar (equal?) to what was recently said about `RIF` in https://groups.google.com/d/topic/sage-devel/9MHkb4cUUHM/discussion

> Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.

So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.



---

archive/issue_comments_244427.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\n> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.\n\nNote that at the moment `1/5 == RR(1/5)`.",
    "created_at": "2015-03-21T09:01:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244427",
    "user": "https://github.com/rwst"
}
```

<div id="comment:27" align="right">comment:27</div>

> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.

Note that at the moment `1/5 == RR(1/5)`.



---

archive/issue_comments_244428.json:
```json
{
    "body": "<div id=\"comment:28\" align=\"right\">comment:28</div>\n\nReplying to [@rwst](#comment%3A26):\n> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.\n\nAh okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.",
    "created_at": "2015-03-21T09:53:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244428",
    "user": "https://github.com/rwst"
}
```

<div id="comment:28" align="right">comment:28</div>

Replying to [@rwst](#comment%3A26):
> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.

Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.



---

archive/issue_comments_244429.json:
```json
{
    "body": "<div id=\"comment:29\" align=\"right\">comment:29</div>\n\nReplying to [@rwst](#comment%3A28):\n> Replying to [@rwst](#comment%3A26):\n> > So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.\n\n> Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.\n\nThis method makes sense in `RIF` but not in `RR`: a number is exact in `RIF` if the associated interval is a singleton. This is very different from the proposition of having a method `RR.is_exactly_representable(...)`.\n\nI do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field\n\n``` \nsage: RR.is_field()\nTrue\nsage: RR in Fields()\nTrue\n```\n\nVincent",
    "created_at": "2015-03-21T10:01:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244429",
    "user": "https://github.com/videlec"
}
```

<div id="comment:29" align="right">comment:29</div>

Replying to [@rwst](#comment%3A28):
> Replying to [@rwst](#comment%3A26):
> > So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.

> Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.

This method makes sense in `RIF` but not in `RR`: a number is exact in `RIF` if the associated interval is a singleton. This is very different from the proposition of having a method `RR.is_exactly_representable(...)`.

I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field

``` 
sage: RR.is_field()
True
sage: RR in Fields()
True
```

Vincent



---

archive/issue_events_253552.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-21T14:04:58Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253552"
}
```



---

archive/issue_events_253553.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-21T14:04:58Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253553"
}
```



---

archive/issue_comments_244430.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nReplying to [@videlec](#comment%3A29):\n> I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field\n\nWhat would be consequences of removing it from the set (apart from documentation issues)?",
    "created_at": "2015-03-21T14:04:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244430",
    "user": "https://github.com/rwst"
}
```

<div id="comment:30" align="right">comment:30</div>

Replying to [@videlec](#comment%3A29):
> I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field

What would be consequences of removing it from the set (apart from documentation issues)?



---

archive/issue_comments_244431.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,6 @@\n-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable dedicated `__contains__` methods for both rings are needed.\n+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n+\n+Previously this ticket proposed that:\n+...dedicated `__contains__` methods for both rings are needed.\n \n Moreover, until now Maxima is used for this which is slow and completely unnecessary.\n``````\n",
    "created_at": "2015-03-21T14:04:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244431",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,6 @@
-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable dedicated `__contains__` methods for both rings are needed.
+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.
+
+Previously this ticket proposed that:
+...dedicated `__contains__` methods for both rings are needed.
 
 Moreover, until now Maxima is used for this which is slow and completely unnecessary.
``````




---

archive/issue_events_253554.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-21T14:04:58Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "title_is": "fix Parent.__contains__",
    "title_was": "Dedicated RR.__contains__() and CC.__contains__()",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253554"
}
```



---

archive/issue_comments_244432.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">comment:31</div>\n\nPing?",
    "created_at": "2015-05-24T16:03:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244432",
    "user": "https://github.com/rwst"
}
```

<div id="comment:31" align="right">comment:31</div>

Ping?



---

archive/issue_events_253555.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253555"
}
```



---

archive/issue_events_253556.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253556"
}
```



---

archive/issue_events_253557.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "milestone_number": null,
    "milestone_title": "sage-6.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253557"
}
```



---

archive/issue_events_253558.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "milestone_number": null,
    "milestone_title": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253558"
}
```



---

archive/issue_events_253559.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253559"
}
```



---

archive/issue_events_253560.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253560"
}
```



---

archive/issue_comments_244433.json:
```json
{
    "body": "<div id=\"comment:32\" align=\"right\">comment:32</div>\n\nThis issue has come up again with working on #19040. This is intolerable. I will have to have a new attempt at this, maybe I understand the arguments better now.",
    "created_at": "2015-09-20T13:47:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244433",
    "user": "https://github.com/rwst"
}
```

<div id="comment:32" align="right">comment:32</div>

This issue has come up again with working on #19040. This is intolerable. I will have to have a new attempt at this, maybe I understand the arguments better now.



---

archive/issue_comments_244434.json:
```json
{
    "body": "Changed branch from **[u/rws/17984](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984)** to **[u/rws/17984-1](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984-1)**",
    "created_at": "2015-09-20T15:46:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244434",
    "user": "https://github.com/rwst"
}
```

Changed branch from **[u/rws/17984](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984)** to **[u/rws/17984-1](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984-1)**



---

archive/issue_comments_244435.json:
```json
{
    "body": "Dependencies: **#19040**",
    "created_at": "2015-09-20T15:48:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244435",
    "user": "https://github.com/rwst"
}
```

Dependencies: **#19040**



---

archive/issue_comments_244436.json:
```json
{
    "body": "<div id=\"comment:34\" align=\"right\">comment:34</div>\n\nThe solution is quite simple with #19040 (which is no completely here yet).\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f\"><code>1edc690</code></a></td><td><code>17984: simplify contains, dependent on 19040</code></td></tr></table>\n",
    "created_at": "2015-09-20T15:48:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244436",
    "user": "https://github.com/rwst"
}
```

<div id="comment:34" align="right">comment:34</div>

The solution is quite simple with #19040 (which is no completely here yet).

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f"><code>1edc690</code></a></td><td><code>17984: simplify contains, dependent on 19040</code></td></tr></table>




---

archive/issue_comments_244437.json:
```json
{
    "body": "Changed commit from **[`544450e`](https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e)** to **[`1edc690`](https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f)**",
    "created_at": "2015-09-20T15:48:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244437",
    "user": "https://github.com/rwst"
}
```

Changed commit from **[`544450e`](https://github.com/sagemath/sagetrac-mirror/commit/544450ea18ed2778953141bab8feced61237556e)** to **[`1edc690`](https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f)**



---

archive/issue_comments_244438.json:
```json
{
    "body": "Changed commit from **[`1edc690`](https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f)** to none",
    "created_at": "2015-09-21T13:48:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244438",
    "user": "https://github.com/rwst"
}
```

Changed commit from **[`1edc690`](https://github.com/sagemath/sagetrac-mirror/commit/1edc690b908207926a9e1e68a60672fb78a6503f)** to none



---

archive/issue_comments_244439.json:
```json
{
    "body": "Changed branch from **[u/rws/17984-1](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984-1)** to none",
    "created_at": "2015-09-21T13:48:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244439",
    "user": "https://github.com/rwst"
}
```

Changed branch from **[u/rws/17984-1](https://github.com/sagemath/sagetrac-mirror/tree/u/rws/17984-1)** to none



---

archive/issue_comments_244440.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,9 @@\n-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.\n+\n+Of course, as soon as we want to get rid of Maxima this must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n+\n+In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n \n Previously this ticket proposed that:\n ...dedicated `__contains__` methods for both rings are needed.\n \n-Moreover, until now Maxima is used for this which is slow and completely unnecessary.\n``````\n",
    "created_at": "2015-09-21T13:48:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244440",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,9 @@
-In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.
+In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.
+
+Of course, as soon as we want to get rid of Maxima this must be simulated, because there is no way to test containment in these inexact rings in a generic way.
+
+In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.
 
 Previously this ticket proposed that:
 ...dedicated `__contains__` methods for both rings are needed.
 
-Moreover, until now Maxima is used for this which is slow and completely unnecessary.
``````




---

archive/issue_comments_244441.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,8 @@\n In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.\n \n-Of course, as soon as we want to get rid of Maxima this must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n+This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC weren needed. As you can see from the discussion this was not wanted.\n+\n+Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n \n In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.\n \n``````\n",
    "created_at": "2016-03-10T15:50:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244441",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,8 @@
 In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.
 
-Of course, as soon as we want to get rid of Maxima this must be simulated, because there is no way to test containment in these inexact rings in a generic way.
+This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC weren needed. As you can see from the discussion this was not wanted.
+
+Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.
 
 In order to make it more reliable the way we treat inclusion in inexact rings needs to be reconsidered.
 
``````




---

archive/issue_comments_244442.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,6 @@\n In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.\n \n-This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC weren needed. As you can see from the discussion this was not wanted.\n+This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC were needed. As you can see from the discussion this was not wanted.\n \n Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.\n \n``````\n",
    "created_at": "2016-03-10T15:51:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244442",
    "user": "https://github.com/rwst"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,6 @@
 In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on the construction `bool(item==self(item))` to get the right result for, e.g. `sqrt(3) in RR/CC` but `bool(RR/CC(sqrt(3))==sqrt(3))` being `False` a trick was applied by the author that makes the function always return `True`. This trick uses the fact that Maxima doesn't know about the rings and will raise an exception, which is then caught.
 
-This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC weren needed. As you can see from the discussion this was not wanted.
+This way of programming strikes me as very wrong and previously I supported the notion that dedicated `__contains__` methods for both RR/CC were needed. As you can see from the discussion this was not wanted.
 
 Of course, as soon as we want to get rid of Maxima this odd behaviour must be simulated, because there is no way to test containment in these inexact rings in a generic way.
 
``````




---

archive/issue_comments_244443.json:
```json
{
    "body": "<div id=\"comment:38\" align=\"right\">comment:38</div>\n\nUnexpectedly it looks like we get a much more correct fix whenever we'll have #24456.",
    "created_at": "2018-01-15T08:36:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17984#issuecomment-244443",
    "user": "https://github.com/rwst"
}
```

<div id="comment:38" align="right">comment:38</div>

Unexpectedly it looks like we get a much more correct fix whenever we'll have #24456.



---

archive/issue_events_253561.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-12-29T01:33:44Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/17984",
    "milestone_number": null,
    "milestone_title": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17984#event-253561"
}
```
