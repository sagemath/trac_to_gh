# Issue 17360: memory leak in FiniteDimensionalAlgebra

archive/issues_017123.json:
```json
{
    "body": "CC:  simonking @nthiery jpflori\n\nThe following code shows a memory leak:\n\n```\nimport gc\nfrom collections import Counter\ngc.collect()\n\npre={id(a) for a in gc.get_objects()}\n\nfor p in prime_range(20000):\n        A = FiniteDimensionalAlgebra(GF(p), [Matrix(GF(p),[[1, 0], [0, 1]]), Matrix(GF(p),[[0, 1], [0, 0]])]) \n    \ngc.collect()\n\npost=Counter(str(type(a)) for a in gc.get_objects() if id(a) not in pre)\npost\n```\n(the content of \"post\" shows that all finite fields and a lot of categories are still in memory). The cause is simple: the category is still a parametrized one by default. The fix, therefore, is simple.\n\nIssue created by migration from https://trac.sagemath.org/ticket/17360\n\n",
    "created_at": "2014-11-18T00:49:51Z",
    "labels": [
        "component: memleak",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.5",
    "title": "memory leak in FiniteDimensionalAlgebra",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17360",
    "user": "https://github.com/nbruin"
}
```
CC:  simonking @nthiery jpflori

The following code shows a memory leak:

```
import gc
from collections import Counter
gc.collect()

pre={id(a) for a in gc.get_objects()}

for p in prime_range(20000):
        A = FiniteDimensionalAlgebra(GF(p), [Matrix(GF(p),[[1, 0], [0, 1]]), Matrix(GF(p),[[0, 1], [0, 0]])]) 
    
gc.collect()

post=Counter(str(type(a)) for a in gc.get_objects() if id(a) not in pre)
post
```
(the content of "post" shows that all finite fields and a lot of categories are still in memory). The cause is simple: the category is still a parametrized one by default. The fix, therefore, is simple.

Issue created by migration from https://trac.sagemath.org/ticket/17360





---

archive/issue_comments_227328.json:
```json
{
    "body": "Indeed, with the branch attached things are fine (and run a lot faster too, because there's not the overhead of creating all those categories every time).\n\nIncidentally, running the command with\n\n```\n        A = FiniteDimensionalAlgebra(GF(p), [Matrix([[1, 0], [0, 1]]), Matrix([[0, 1], [0, 0]])]) \n```\ngoes horribly wrong again, because of the little pearl in `matrix_space.py`:\n\n```\n   def change_ring(self, R):\n        try:\n            return self.__change_ring[R]\n        except AttributeError:\n            self.__change_ring = {}\n        except KeyError:\n            pass\n        M = MatrixSpace(R, self.__nrows, self.__ncols, self.__is_sparse)\n        self.__change_ring[R] = M\n        return M\n```\nwhich conveniently undoes all the effort of the rest of the coercion framework to avoid strong references. Note that simply changing the dict to weakly keyed won't help: the matrix spaces will hold a reference to the base ring anyway. Having it weak on both key and value would work, but now we're just replicating the UniqueRepresentation caching. Is that necessary?\n\n---\nNew commits:",
    "created_at": "2014-11-18T00:58:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227328",
    "user": "https://github.com/nbruin"
}
```

Indeed, with the branch attached things are fine (and run a lot faster too, because there's not the overhead of creating all those categories every time).

Incidentally, running the command with

```
        A = FiniteDimensionalAlgebra(GF(p), [Matrix([[1, 0], [0, 1]]), Matrix([[0, 1], [0, 0]])]) 
```
goes horribly wrong again, because of the little pearl in `matrix_space.py`:

```
   def change_ring(self, R):
        try:
            return self.__change_ring[R]
        except AttributeError:
            self.__change_ring = {}
        except KeyError:
            pass
        M = MatrixSpace(R, self.__nrows, self.__ncols, self.__is_sparse)
        self.__change_ring[R] = M
        return M
```
which conveniently undoes all the effort of the rest of the coercion framework to avoid strong references. Note that simply changing the dict to weakly keyed won't help: the matrix spaces will hold a reference to the base ring anyway. Having it weak on both key and value would work, but now we're just replicating the UniqueRepresentation caching. Is that necessary?

---
New commits:



---

archive/issue_comments_227329.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to memleak.",
    "created_at": "2014-11-18T00:58:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227329",
    "user": "https://github.com/nbruin"
}
```

Changing component from PLEASE CHANGE to memleak.



---

archive/issue_comments_227330.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-18T01:04:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227330",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_227331.json:
```json
{
    "body": "OK! some initial timing gives me with the old code:\n\n```\nsage: M=matrix(ZZ,2,2,[1,0,0,1])\nsage: k=GF(3)\nsage: %timeit M.change_ring(k)\n10000 loops, best of 3: 111 \u00b5s per loop\n```\nand after removing the custom cache:\n\n```\nsage: %timeit M.change_ring(k)\n10000 loops, best of 3: 112 \u00b5s per loop\n```\nso I think there is no difference (we did improve UniqueRepresentation a lot), and removing the cache makes the example work fine.\n\nThere are plenty of other parent inits that set a base-ring referencing category by default, by the way. Any ideas on how to conveniently detect these?",
    "created_at": "2014-11-18T01:08:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227331",
    "user": "https://github.com/nbruin"
}
```

OK! some initial timing gives me with the old code:

```
sage: M=matrix(ZZ,2,2,[1,0,0,1])
sage: k=GF(3)
sage: %timeit M.change_ring(k)
10000 loops, best of 3: 111 µs per loop
```
and after removing the custom cache:

```
sage: %timeit M.change_ring(k)
10000 loops, best of 3: 112 µs per loop
```
so I think there is no difference (we did improve UniqueRepresentation a lot), and removing the cache makes the example work fine.

There are plenty of other parent inits that set a base-ring referencing category by default, by the way. Any ideas on how to conveniently detect these?



---

archive/issue_comments_227332.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to defect.",
    "created_at": "2014-11-18T01:26:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227332",
    "user": "https://github.com/nbruin"
}
```

Changing type from PLEASE CHANGE to defect.



---

archive/issue_comments_227333.json:
```json
{
    "body": "Do you also want to fix this for other algebras (except Weyl and Clifford, I'll do that in #17096 since I'm editing that part of those files anyways)?",
    "created_at": "2014-11-18T03:35:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227333",
    "user": "https://github.com/tscrim"
}
```

Do you also want to fix this for other algebras (except Weyl and Clifford, I'll do that in #17096 since I'm editing that part of those files anyways)?



---

archive/issue_comments_227334.json:
```json
{
    "body": "Replying to [comment:6 tscrim]:\n> Do you also want to fix this for other algebras \n\nI would like that it gets fixed (because the pervasive leaking has repeatedly prevented me from using sage on problems of interesting scale); I'm not particularly keen on doing it myself, since I don't have a particularly good idea about how to do that efficiently.\n\n> (except Weyl and Clifford, I'll do that in #17096 since I'm editing that part of those files anyways)?\n\n\nThanks!",
    "created_at": "2014-11-18T17:21:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227334",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:6 tscrim]:
> Do you also want to fix this for other algebras 

I would like that it gets fixed (because the pervasive leaking has repeatedly prevented me from using sage on problems of interesting scale); I'm not particularly keen on doing it myself, since I don't have a particularly good idea about how to do that efficiently.

> (except Weyl and Clifford, I'll do that in #17096 since I'm editing that part of those files anyways)?


Thanks!



---

archive/issue_comments_227335.json:
```json
{
    "body": "OK, now I'm confused. If I do\n\n```\nimport gc\nfrom collections import Counter\ngc.collect()\n\npre={id(a) for a in gc.get_objects()}\n\nfor p in prime_range(20000):\n    C=VectorSpaces(GF(p))\n\ngc.collect()\n\npost=Counter(str(type(a)) for a in gc.get_objects() if id(a) not in pre)\n[p for p in post.iteritems() if p[1] > 2000]\n```\nI get no hits (i.e, the category VectorSpaces seems to be collectible), but if I do the same with\n\n```\n    C=Algebras(GF(p))\n```\nI do end up with a lot of junk. What is it that makes Algebras not collectible?\n[There's also the performance component: making all these different VectorSpaces categories does take time too, so equipping a vector space object by default with a generic category that doesn't need to be created for every base ring is a good idea anyway, but it would be good to understand why VectorSpaces aren't immortal like Algebras are]\n\nOne obvious difference is that Algebras inherits from CategoryWithAxiom_over_base_ring . It may be that the axiom stuff ruins mortality? It definitely ruins performance:\n\n```\nsage: %time for p in prime_range(20000): C=Algebras(GF(p))\nCPU times: user 4.17 s, sys: 71 ms, total: 4.24 s\nWall time: 4.23 s\n```\nversus (in a fresh session, because the above creates the vector spaces anyway):\n\n```\nsage: %time for p in prime_range(20000): C=VectorSpaces(GF(p))\nCPU times: user 660 ms, sys: 14 ms, total: 674 ms\nWall time: 662 ms\n```\nBoth are noticeable, so should be avoided if possible, but the Algebras one is just VERY slow. It's not using that much memory so I have trouble attributing that just to overhead in allocating memory.",
    "created_at": "2014-11-18T19:28:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227335",
    "user": "https://github.com/nbruin"
}
```

OK, now I'm confused. If I do

```
import gc
from collections import Counter
gc.collect()

pre={id(a) for a in gc.get_objects()}

for p in prime_range(20000):
    C=VectorSpaces(GF(p))

gc.collect()

post=Counter(str(type(a)) for a in gc.get_objects() if id(a) not in pre)
[p for p in post.iteritems() if p[1] > 2000]
```
I get no hits (i.e, the category VectorSpaces seems to be collectible), but if I do the same with

```
    C=Algebras(GF(p))
```
I do end up with a lot of junk. What is it that makes Algebras not collectible?
[There's also the performance component: making all these different VectorSpaces categories does take time too, so equipping a vector space object by default with a generic category that doesn't need to be created for every base ring is a good idea anyway, but it would be good to understand why VectorSpaces aren't immortal like Algebras are]

One obvious difference is that Algebras inherits from CategoryWithAxiom_over_base_ring . It may be that the axiom stuff ruins mortality? It definitely ruins performance:

```
sage: %time for p in prime_range(20000): C=Algebras(GF(p))
CPU times: user 4.17 s, sys: 71 ms, total: 4.24 s
Wall time: 4.23 s
```
versus (in a fresh session, because the above creates the vector spaces anyway):

```
sage: %time for p in prime_range(20000): C=VectorSpaces(GF(p))
CPU times: user 660 ms, sys: 14 ms, total: 674 ms
Wall time: 662 ms
```
Both are noticeable, so should be avoided if possible, but the Algebras one is just VERY slow. It's not using that much memory so I have trouble attributing that just to overhead in allocating memory.



---

archive/issue_comments_227336.json:
```json
{
    "body": "`Algebras` is a subclass of `CategoryWithAxiom_over_base_ring` whereas `Modules` (and `VectorSpaces`) is a subclass of `Category_module`. I'm guessing that any subclass of `CategoryWithAxiom` gets nailed into memory because there is a link back to the list of axioms or the call to the strongly cached `axiom_of_nested_class`.",
    "created_at": "2014-11-18T19:38:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227336",
    "user": "https://github.com/tscrim"
}
```

`Algebras` is a subclass of `CategoryWithAxiom_over_base_ring` whereas `Modules` (and `VectorSpaces`) is a subclass of `Category_module`. I'm guessing that any subclass of `CategoryWithAxiom` gets nailed into memory because there is a link back to the list of axioms or the call to the strongly cached `axiom_of_nested_class`.



---

archive/issue_comments_227337.json:
```json
{
    "body": "Should we or did someone open a ticket to fix that (general) nasty memory leak caused by `WithAxiom`?",
    "created_at": "2014-12-23T15:30:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227337",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Should we or did someone open a ticket to fix that (general) nasty memory leak caused by `WithAxiom`?



---

archive/issue_comments_227338.json:
```json
{
    "body": "I'm thinking we should change this ticket to take care of the `CategoryWithAxiom` leak.\n\nI can get rid of the memory leak by removing the caching on `Category._with_axiom_as_tuple` and `Category._with_axiom` (although it takes a few passes of `gc.collect()` to get rid of the finite fields). However I believe this could lead to a slowdown in instantiating categories, and we have the workaround of the memory leak of `Algebras(Fields())`.\n\nSo perhaps what we can do is have the cached part should be at the class level (which should cover the heavy lifting and result in a large speedup in [Nils] creation because the construction won't be done for every new `Algebras` category) and the caching should return a class. Thoughts?",
    "created_at": "2014-12-23T18:28:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17360",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17360#issuecomment-227338",
    "user": "https://github.com/tscrim"
}
```

I'm thinking we should change this ticket to take care of the `CategoryWithAxiom` leak.

I can get rid of the memory leak by removing the caching on `Category._with_axiom_as_tuple` and `Category._with_axiom` (although it takes a few passes of `gc.collect()` to get rid of the finite fields). However I believe this could lead to a slowdown in instantiating categories, and we have the workaround of the memory leak of `Algebras(Fields())`.

So perhaps what we can do is have the cached part should be at the class level (which should cover the heavy lifting and result in a large speedup in [Nils] creation because the construction won't be done for every new `Algebras` category) and the caching should return a class. Thoughts?
