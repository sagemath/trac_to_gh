# Issue 17814: Make calling a cached method independent of source code inspection

archive/issues_017577.json:
```json
{
    "body": "If a pyx file in the sage library uses cached methods and then the source file is removed after compiling Sage, then accessing the cached methods in this file becomes impossible. Example: Move the file `src/sage/rings/finite_rings/finite_field_base.pyx` away. Then:\n\n```\nsage: K=GF(5)\nsage: K.factored_order\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-2-488672e9c19b> in <module>()\n----> 1 K.factored_order()\n\n/home/king/Sage/git/sage/src/sage/structure/parent.pyx in sage.structure.parent.Parent.__getattr__ (build/cythonized/sage/structure/parent.c:7863)()\n    838             return self.__cached_methods[name]\n    839         except KeyError:\n--> 840             attr = getattr_from_other_class(self, self._category.parent_class, name)\n    841             self.__cached_methods[name] = attr\n    842             return attr\n\n/home/king/Sage/git/sage/src/sage/structure/misc.pyx in sage.structure.misc.getattr_from_other_class (build/cythonized/sage/structure/misc.c:1582)()\n    249         dummy_error_message.cls = type(self)\n    250         dummy_error_message.name = name\n--> 251         raise dummy_attribute_error\n    252     try:\n    253         attribute = getattr(cls, name)\n\nAttributeError: 'FiniteField_prime_modn_with_category' object has no attribute 'factored_order'\n```\n\nThe same does work in attached pyx files, even after removing the temporary copy of the pyx file. Conjecture: The cached method's `__get__` method relies on source code inspection. That should of course not be the case. Source code inspection should only come in play if the user wants to see the source code or at least the doc string.\n\nI chose the component \"distribution\", since it was reported on sage-devel as something that happened on certain sage distributions that do not provide sage sources.\n\nIssue created by migration from https://trac.sagemath.org/ticket/17814\n\n",
    "closed_at": "2015-04-29T03:13:49Z",
    "created_at": "2015-02-20T07:05:10Z",
    "labels": [
        "component: distribution",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.6",
    "title": "Make calling a cached method independent of source code inspection",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17814",
    "user": "https://github.com/simon-king-jena"
}
```
If a pyx file in the sage library uses cached methods and then the source file is removed after compiling Sage, then accessing the cached methods in this file becomes impossible. Example: Move the file `src/sage/rings/finite_rings/finite_field_base.pyx` away. Then:

```
sage: K=GF(5)
sage: K.factored_order
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-2-488672e9c19b> in <module>()
----> 1 K.factored_order()

/home/king/Sage/git/sage/src/sage/structure/parent.pyx in sage.structure.parent.Parent.__getattr__ (build/cythonized/sage/structure/parent.c:7863)()
    838             return self.__cached_methods[name]
    839         except KeyError:
--> 840             attr = getattr_from_other_class(self, self._category.parent_class, name)
    841             self.__cached_methods[name] = attr
    842             return attr

/home/king/Sage/git/sage/src/sage/structure/misc.pyx in sage.structure.misc.getattr_from_other_class (build/cythonized/sage/structure/misc.c:1582)()
    249         dummy_error_message.cls = type(self)
    250         dummy_error_message.name = name
--> 251         raise dummy_attribute_error
    252     try:
    253         attribute = getattr(cls, name)

AttributeError: 'FiniteField_prime_modn_with_category' object has no attribute 'factored_order'
```

The same does work in attached pyx files, even after removing the temporary copy of the pyx file. Conjecture: The cached method's `__get__` method relies on source code inspection. That should of course not be the case. Source code inspection should only come in play if the user wants to see the source code or at least the doc string.

I chose the component "distribution", since it was reported on sage-devel as something that happened on certain sage distributions that do not provide sage sources.

Issue created by migration from https://trac.sagemath.org/ticket/17814





---

archive/issue_comments_234289.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to distribution.",
    "created_at": "2015-02-20T07:15:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234289",
    "user": "https://github.com/simon-king-jena"
}
```

Changing component from PLEASE CHANGE to distribution.



---

archive/issue_comments_234290.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to defect.",
    "created_at": "2015-02-20T07:15:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234290",
    "user": "https://github.com/simon-king-jena"
}
```

Changing type from PLEASE CHANGE to defect.



---

archive/issue_comments_234291.json:
```json
{
    "body": "Here one can see how introspection enters:\n\n```\nsage: K=GF(5)\nsage: C=type(K)\nsage: C.factored_order\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-4-d955bd892332> in <module>()\n----> 1 C.factored_order\n\n/home/king/Sage/git/sage/src/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedMethod.__get__ (build/cythonized/sage/misc/cachefunc.c:15452)()\n   2673         f = (<CachedFunction>self._cachedfunc).f\n   2674         if self.nargs==0:\n-> 2675             args, varargs, keywords, defaults = sage_getargspec(f)                                                                                                        \n   2676             if varargs is None and keywords is None and len(args)<=1:                                                                                                     \n   2677                 self.nargs = 1\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/misc/sageinspect.pyc in sage_getargspec(obj)\n   1394         except TypeError: # arg is not a code object\n   1395         # The above \"hopefully\" was wishful thinking:\n-> 1396             return inspect.ArgSpec(*_sage_getargspec_cython(sage_getsource(obj)))\n   1397             #return _sage_getargspec_from_ast(sage_getsource(obj))\n   1398     try:\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/misc/sageinspect.pyc in _sage_getargspec_cython(source)\n   1006 \n   1007     \"\"\"\n-> 1008     defpos = source.find('def ')\n   1009     assert defpos > -1, \"The given source does not contain 'def'\"\n   1010     s = source[defpos:].strip()\n\nAttributeError: 'NoneType' object has no attribute 'find'\n```\nSo: cached_method tries to determine the number of arguments. This is because there is a special implementation for functions with no argument (except `self`).\n\nIn other words, the wrong behaviour could be fixed by finding a way to get the number of arguments (or better the argspec) of a cython function without looking at its source code. I'll see if that's possible. So, the fix will likely be in `sage.misc.sageinspect`, not in `sage.misc.cachefunc`.",
    "created_at": "2015-02-20T10:09:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234291",
    "user": "https://github.com/simon-king-jena"
}
```

Here one can see how introspection enters:

```
sage: K=GF(5)
sage: C=type(K)
sage: C.factored_order
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-4-d955bd892332> in <module>()
----> 1 C.factored_order

/home/king/Sage/git/sage/src/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedMethod.__get__ (build/cythonized/sage/misc/cachefunc.c:15452)()
   2673         f = (<CachedFunction>self._cachedfunc).f
   2674         if self.nargs==0:
-> 2675             args, varargs, keywords, defaults = sage_getargspec(f)                                                                                                        
   2676             if varargs is None and keywords is None and len(args)<=1:                                                                                                     
   2677                 self.nargs = 1

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/misc/sageinspect.pyc in sage_getargspec(obj)
   1394         except TypeError: # arg is not a code object
   1395         # The above "hopefully" was wishful thinking:
-> 1396             return inspect.ArgSpec(*_sage_getargspec_cython(sage_getsource(obj)))
   1397             #return _sage_getargspec_from_ast(sage_getsource(obj))
   1398     try:

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/misc/sageinspect.pyc in _sage_getargspec_cython(source)
   1006 
   1007     """
-> 1008     defpos = source.find('def ')
   1009     assert defpos > -1, "The given source does not contain 'def'"
   1010     s = source[defpos:].strip()

AttributeError: 'NoneType' object has no attribute 'find'
```
So: cached_method tries to determine the number of arguments. This is because there is a special implementation for functions with no argument (except `self`).

In other words, the wrong behaviour could be fixed by finding a way to get the number of arguments (or better the argspec) of a cython function without looking at its source code. I'll see if that's possible. So, the fix will likely be in `sage.misc.sageinspect`, not in `sage.misc.cachefunc`.



---

archive/issue_comments_234292.json:
```json
{
    "body": "Fixing sageinspect won't be easy. I currently have absolutely no clue how to read off the number of arguments (or even the names of the arguments) of a function that is defined in a Cython file. Those functions don't seem to have any attributes holding useful information.\n\nHas someone else an idea? If not, then I don't see what we can do. We do want a special cached method implementation for methods without arguments, and thus we need to determine the number of arguments of the to-be-wrapped method. If that doesn't work without reading the sources, what could we possibly do?",
    "created_at": "2015-02-20T11:34:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234292",
    "user": "https://github.com/simon-king-jena"
}
```

Fixing sageinspect won't be easy. I currently have absolutely no clue how to read off the number of arguments (or even the names of the arguments) of a function that is defined in a Cython file. Those functions don't seem to have any attributes holding useful information.

Has someone else an idea? If not, then I don't see what we can do. We do want a special cached method implementation for methods without arguments, and thus we need to determine the number of arguments of the to-be-wrapped method. If that doesn't work without reading the sources, what could we possibly do?



---

archive/issue_comments_234293.json:
```json
{
    "body": "Replying to [comment:4 SimonKing]:\n> Fixing sageinspect won't be easy. I currently have absolutely no clue how to read off the number of arguments (or even the names of the arguments)\n\nDo you really require the number and names of arguments or do you only want to know whether a function takes any `*args` and/or `**kwds` at all (apart from the `self` argument)?\n\nTechnically, Python always uses `*args` and `**kwds` to pass arguments (except for some special methods like `__new__`). It's the Cython method implementation which interprets these `*args` and `**kwds`.",
    "created_at": "2015-02-20T12:10:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234293",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:4 SimonKing]:
> Fixing sageinspect won't be easy. I currently have absolutely no clue how to read off the number of arguments (or even the names of the arguments)

Do you really require the number and names of arguments or do you only want to know whether a function takes any `*args` and/or `**kwds` at all (apart from the `self` argument)?

Technically, Python always uses `*args` and `**kwds` to pass arguments (except for some special methods like `__new__`). It's the Cython method implementation which interprets these `*args` and `**kwds`.



---

archive/issue_comments_234294.json:
```json
{
    "body": "The question is also: if there is a method\n\n```\ndef f(self, arg=1)\n```\ndo we require that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` all use the same cache entry? If you don't require that, there might be a solution by working on the level of `*args` and `**kwds`.",
    "created_at": "2015-02-20T12:30:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234294",
    "user": "https://github.com/jdemeyer"
}
```

The question is also: if there is a method

```
def f(self, arg=1)
```
do we require that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` all use the same cache entry? If you don't require that, there might be a solution by working on the level of `*args` and `**kwds`.



---

archive/issue_comments_234295.json:
```json
{
    "body": "Replying to [comment:6 jdemeyer]:\n> The question is also: if there is a method\n> \n> ```\n> def f(self, arg=1)\n> ```\n> do we require that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` all use the same cache entry? If you don't require that, there might be a solution by working on the level of `*args` and `**kwds`.\n\n\nYes, we do require that. Equivalent inputs should result in identical output.\n\nThe problem occurs when the cached method is bound to an instance. At that point, we want to know if the method accepts *any* argument in addition to `self`. If it does, then a `CachedMethodCaller` is set as an attribute of the instance. If it does not, then a `CachedMethodCallerNoArgs` is bound to the method. If sage can't answer the question, then an `AttributeError` is raised. We don't need to know all argument names and all defaults, but we do need to know their number.",
    "created_at": "2015-02-20T13:24:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234295",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:6 jdemeyer]:
> The question is also: if there is a method
> 
> ```
> def f(self, arg=1)
> ```
> do we require that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` all use the same cache entry? If you don't require that, there might be a solution by working on the level of `*args` and `**kwds`.


Yes, we do require that. Equivalent inputs should result in identical output.

The problem occurs when the cached method is bound to an instance. At that point, we want to know if the method accepts *any* argument in addition to `self`. If it does, then a `CachedMethodCaller` is set as an attribute of the instance. If it does not, then a `CachedMethodCallerNoArgs` is bound to the method. If sage can't answer the question, then an `AttributeError` is raised. We don't need to know all argument names and all defaults, but we do need to know their number.



---

archive/issue_comments_234296.json:
```json
{
    "body": "The two statements below seem like a contraction: using the example above, if you want to ensure that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` use the same cache entry, you do need to know the names and defaults of the arguments.\n\nReplying to [comment:7 SimonKing]:\n> Yes, we do require that. Equivalent inputs should result in identical output.\n\n\n> We don't need to know all argument names and all defaults, but we do need to know their number.",
    "created_at": "2015-02-20T14:05:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234296",
    "user": "https://github.com/jdemeyer"
}
```

The two statements below seem like a contraction: using the example above, if you want to ensure that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` use the same cache entry, you do need to know the names and defaults of the arguments.

Replying to [comment:7 SimonKing]:
> Yes, we do require that. Equivalent inputs should result in identical output.


> We don't need to know all argument names and all defaults, but we do need to know their number.



---

archive/issue_comments_234297.json:
```json
{
    "body": "Replying to [comment:7 SimonKing]:\n> we want to know if the method accepts *any* argument in addition to `self`.\n\nThat's possible using the Python API function `PyCFunction_GetFlags`. When applied to a bound method, it returns the flags as defined in `https://docs.python.org/2/c-api/structures.html#c.PyMethodDef`",
    "created_at": "2015-02-20T14:07:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234297",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:7 SimonKing]:
> we want to know if the method accepts *any* argument in addition to `self`.

That's possible using the Python API function `PyCFunction_GetFlags`. When applied to a bound method, it returns the flags as defined in `https://docs.python.org/2/c-api/structures.html#c.PyMethodDef`



---

archive/issue_comments_234298.json:
```json
{
    "body": "Replying to [comment:8 jdemeyer]:\n> The two statements below seem like a contraction: using the example above, if you want to ensure that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` use the same cache entry, you do need to know the names and defaults of the arguments.\n\n\nFor *calling* the function, you of course need it (so, I admit that the title of this ticket is misleading). However, for determining whether it ought to be a `CachedMethodCaller` or a `CachedMethodCallerNoArgs`, it suffices to know a little less.\n\nAnd thank you for the link to `PyCFunction_GetFlags`. So, it seems that `sage.misc.sageinspect` should get a little addition `sage.misc.sage_inspect_cython` written in Cython that provides helpers for inspection of Cython methods.",
    "created_at": "2015-02-20T14:13:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234298",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:8 jdemeyer]:
> The two statements below seem like a contraction: using the example above, if you want to ensure that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` use the same cache entry, you do need to know the names and defaults of the arguments.


For *calling* the function, you of course need it (so, I admit that the title of this ticket is misleading). However, for determining whether it ought to be a `CachedMethodCaller` or a `CachedMethodCallerNoArgs`, it suffices to know a little less.

And thank you for the link to `PyCFunction_GetFlags`. So, it seems that `sage.misc.sageinspect` should get a little addition `sage.misc.sage_inspect_cython` written in Cython that provides helpers for inspection of Cython methods.



---

archive/issue_comments_234299.json:
```json
{
    "body": "Replying to [comment:10 SimonKing]:\n> For *calling* the function, you of course need it (so, I admit that the title of this ticket is misleading). However, for determining whether it ought to be a `CachedMethodCaller` or a `CachedMethodCallerNoArgs`, it suffices to know a little less.\n\nSure, but that doesn't solve the problem really (unless you want to fix the issue of this ticket only for methods taking no arguments). You still need to *call* the function eventually.",
    "created_at": "2015-02-20T14:18:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234299",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:10 SimonKing]:
> For *calling* the function, you of course need it (so, I admit that the title of this ticket is misleading). However, for determining whether it ought to be a `CachedMethodCaller` or a `CachedMethodCallerNoArgs`, it suffices to know a little less.

Sure, but that doesn't solve the problem really (unless you want to fix the issue of this ticket only for methods taking no arguments). You still need to *call* the function eventually.



---

archive/issue_comments_234300.json:
```json
{
    "body": "Replying to [comment:7 SimonKing]:\n> Replying to [comment:6 jdemeyer]:\n> > The question is also: if there is a method\n> > \n> > ```\n> > def f(self, arg=1)\n> > ```\n> > do we require that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` all use the same cache entry? If you don't require that, there might be a solution by working on the level of `*args` and `**kwds`.\n\n> \n> Yes, we do require that.\n\nIs that really so important? Does it happen a lot in practice that people or the Sage library call a function in different but equivalent ways?",
    "created_at": "2015-02-20T14:19:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234300",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:7 SimonKing]:
> Replying to [comment:6 jdemeyer]:
> > The question is also: if there is a method
> > 
> > ```
> > def f(self, arg=1)
> > ```
> > do we require that `obj.f()` and `obj.f(1)` and `obj.f(arg=1)` all use the same cache entry? If you don't require that, there might be a solution by working on the level of `*args` and `**kwds`.

> 
> Yes, we do require that.

Is that really so important? Does it happen a lot in practice that people or the Sage library call a function in different but equivalent ways?



---

archive/issue_comments_234301.json:
```json
{
    "body": "Replying to [comment:12 jdemeyer]:\n> Replying to [comment:7 SimonKing]:\n> > Yes, we do require that.\n\n> Is that really so important? Does it happen a lot in practice that people or the Sage library call a function in different but equivalent ways?\n\nI believe it is important, and I think it is specified somewhere in the docs of sage.misc.cachefunc. There are places where it is used for `UniqueRepresentation`. Indeed, if you have a unique parent that depends on arguments which (partially) have a default, then you simply don't know if the user will provide these arguments explicitly or implicitly. But when pickling/unpickling it, the arguments will be provided in a uniform way (always explicitly, if I recall correctly).\n\nHence, if we changed that, we would break uniqueness of `UniqueRepresentation` under pickling.",
    "created_at": "2015-02-20T14:26:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234301",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:12 jdemeyer]:
> Replying to [comment:7 SimonKing]:
> > Yes, we do require that.

> Is that really so important? Does it happen a lot in practice that people or the Sage library call a function in different but equivalent ways?

I believe it is important, and I think it is specified somewhere in the docs of sage.misc.cachefunc. There are places where it is used for `UniqueRepresentation`. Indeed, if you have a unique parent that depends on arguments which (partially) have a default, then you simply don't know if the user will provide these arguments explicitly or implicitly. But when pickling/unpickling it, the arguments will be provided in a uniform way (always explicitly, if I recall correctly).

Hence, if we changed that, we would break uniqueness of `UniqueRepresentation` under pickling.



---

archive/issue_comments_234302.json:
```json
{
    "body": "I see. This is important where the semantics of `cached_function` are really important.\n\nI always had in mind only the application of speeding up the function by not computing the same thing multiple times. For the latter application, you need to consider also the overhead of parsing `*args` and `**kwds` to compute the correct cache entry. Where speed is important, we might just use `*args` and `**kwds` instead.",
    "created_at": "2015-02-20T14:36:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234302",
    "user": "https://github.com/jdemeyer"
}
```

I see. This is important where the semantics of `cached_function` are really important.

I always had in mind only the application of speeding up the function by not computing the same thing multiple times. For the latter application, you need to consider also the overhead of parsing `*args` and `**kwds` to compute the correct cache entry. Where speed is important, we might just use `*args` and `**kwds` instead.



---

archive/issue_comments_234303.json:
```json
{
    "body": "Proposal: have 2 different implementations of `cached_function`:\n\n- one for *Python* methods, which works just like the current implementation.\n\n- one for *Cython* methods, which works on the level of `*args` and `**kwds`.",
    "created_at": "2015-02-20T14:47:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234303",
    "user": "https://github.com/jdemeyer"
}
```

Proposal: have 2 different implementations of `cached_function`:

- one for *Python* methods, which works just like the current implementation.

- one for *Cython* methods, which works on the level of `*args` and `**kwds`.



---

archive/issue_comments_234304.json:
```json
{
    "body": "This proposal would solve the issue on the ticket. Specializing for Cython, it might also be possible to speed-up things more.",
    "created_at": "2015-02-20T14:54:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234304",
    "user": "https://github.com/jdemeyer"
}
```

This proposal would solve the issue on the ticket. Specializing for Cython, it might also be possible to speed-up things more.



---

archive/issue_comments_234305.json:
```json
{
    "body": "Replying to [comment:10 SimonKing]:\n> And thank you for the link to `PyCFunction_GetFlags`. So, it seems that `sage.misc.sageinspect` should get a little addition `sage.misc.sage_inspect_cython` written in Cython that provides helpers for inspection of Cython methods.\n\n\nIt is puzzling. When I call `PyCFunction_GetFlags` on the function/method being wrapped, no crash occurs in that function. However, importing lazy_attribute then fails, and so Sage won't start. No idea how the two things (a function that gives me information on other functions without raising an error, and an import statement) could possibly interfere.",
    "created_at": "2015-02-21T09:31:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234305",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:10 SimonKing]:
> And thank you for the link to `PyCFunction_GetFlags`. So, it seems that `sage.misc.sageinspect` should get a little addition `sage.misc.sage_inspect_cython` written in Cython that provides helpers for inspection of Cython methods.


It is puzzling. When I call `PyCFunction_GetFlags` on the function/method being wrapped, no crash occurs in that function. However, importing lazy_attribute then fails, and so Sage won't start. No idea how the two things (a function that gives me information on other functions without raising an error, and an import statement) could possibly interfere.



---

archive/issue_comments_234306.json:
```json
{
    "body": "Replying to [comment:17 SimonKing]:\n> Replying to [comment:10 SimonKing]:\n> > And thank you for the link to `PyCFunction_GetFlags`. So, it seems that `sage.misc.sageinspect` should get a little addition `sage.misc.sage_inspect_cython` written in Cython that provides helpers for inspection of Cython methods.\n\n> \n> It is puzzling. When I call `PyCFunction_GetFlags` on the function/method being wrapped, no crash occurs in that function. However, importing lazy_attribute then fails, and so Sage won't start. No idea how the two things (a function that gives me information on other functions without raising an error, and an import statement) could possibly interfere.\n\nIt's hard to tell without seeing the code. Are you sure the `PyCFunction_GetFlags` call is what creates the problem and not for example a changed import or the mere fact of accessing obj.method?\n\nAnyway, I'm still very curious what you think about [comment:11] and [comment:15]",
    "created_at": "2015-02-21T10:44:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234306",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:17 SimonKing]:
> Replying to [comment:10 SimonKing]:
> > And thank you for the link to `PyCFunction_GetFlags`. So, it seems that `sage.misc.sageinspect` should get a little addition `sage.misc.sage_inspect_cython` written in Cython that provides helpers for inspection of Cython methods.

> 
> It is puzzling. When I call `PyCFunction_GetFlags` on the function/method being wrapped, no crash occurs in that function. However, importing lazy_attribute then fails, and so Sage won't start. No idea how the two things (a function that gives me information on other functions without raising an error, and an import statement) could possibly interfere.

It's hard to tell without seeing the code. Are you sure the `PyCFunction_GetFlags` call is what creates the problem and not for example a changed import or the mere fact of accessing obj.method?

Anyway, I'm still very curious what you think about [comment:11] and [comment:15]



---

archive/issue_comments_234307.json:
```json
{
    "body": "The proposal from comment:15 would of course solve the problem of the introspection that is needed to wrap a cython function in a cached method. However, it would mean that the specification of uniqueness would be violated for those cython functions for which the argument spectrum is not available.\n\nI'll try to show you a diff file shortly, so that you can see how calling `PyCFunction_GetFlags` makes the import of lazy_attribute fail. Currently, I am rebuilding Sage, so, it may take a while.",
    "created_at": "2015-02-21T11:35:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234307",
    "user": "https://github.com/simon-king-jena"
}
```

The proposal from comment:15 would of course solve the problem of the introspection that is needed to wrap a cython function in a cached method. However, it would mean that the specification of uniqueness would be violated for those cython functions for which the argument spectrum is not available.

I'll try to show you a diff file shortly, so that you can see how calling `PyCFunction_GetFlags` makes the import of lazy_attribute fail. Currently, I am rebuilding Sage, so, it may take a while.



---

archive/issue_comments_234308.json:
```json
{
    "body": "Replying to [comment:19 SimonKing]:\n> The proposal from comment:15 would of course solve the problem of the introspection that is needed to wrap a cython function in a cached method. However, it would mean that the specification of uniqueness would be violated for those cython functions for which the argument spectrum is not available.\n\nTrue, but I think the uniqueness is only important for certain very specific functions. In any case, if we want to solve this ticket, I think it's the only way to go.",
    "created_at": "2015-02-21T12:01:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234308",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:19 SimonKing]:
> The proposal from comment:15 would of course solve the problem of the introspection that is needed to wrap a cython function in a cached method. However, it would mean that the specification of uniqueness would be violated for those cython functions for which the argument spectrum is not available.

True, but I think the uniqueness is only important for certain very specific functions. In any case, if we want to solve this ticket, I think it's the only way to go.



---

archive/issue_comments_234309.json:
```json
{
    "body": "Try this:\n\n```diff\ndiff --git a/src/sage/misc/cachefunc.pyx b/src/sage/misc/cachefunc.pyx\nindex a4276b9..515c74a 100644\n--- a/src/sage/misc/cachefunc.pyx\n+++ b/src/sage/misc/cachefunc.pyx\n@@ -481,6 +481,12 @@ import sage.misc.weak_dict\n from sage.misc.weak_dict import WeakValueDictionary\n from sage.misc.decorators import decorator_keywords\n \n+from cpython cimport PyObject\n+\n+cdef extern from \"methodobject.h\":\n+    cdef int PyCFunction_GetFlags(PyObject *op)\n+\n+\n cdef frozenset special_method_names = frozenset(['__abs__', '__add__',\n             '__and__', '__call__', '__cmp__', '__coerce__', '__complex__', '__contains__', '__del__',\n             '__delattr__', '__delete__', '__delitem__', '__delslice__', '__dir__', '__div__',\n@@ -2672,6 +2678,7 @@ cdef class CachedMethod(object):\n         # we need to analyse the argspec\n         f = (<CachedFunction>self._cachedfunc).f\n         if self.nargs==0:\n+            bla = PyCFunction_GetFlags(<PyObject *>f)\n             args, varargs, keywords, defaults = sage_getargspec(f)\n             if varargs is None and keywords is None and len(args)<=1:\n                 self.nargs = 1\n```\nAccording to the crash report that I get, the error occurs in the line `args, varargs, keywords, defaults = sage_getargspec(f)`, thus, *after* `PyCFunction_GetFlags` has returned something.",
    "created_at": "2015-02-21T12:15:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234309",
    "user": "https://github.com/simon-king-jena"
}
```

Try this:

```diff
diff --git a/src/sage/misc/cachefunc.pyx b/src/sage/misc/cachefunc.pyx
index a4276b9..515c74a 100644
--- a/src/sage/misc/cachefunc.pyx
+++ b/src/sage/misc/cachefunc.pyx
@@ -481,6 +481,12 @@ import sage.misc.weak_dict
 from sage.misc.weak_dict import WeakValueDictionary
 from sage.misc.decorators import decorator_keywords
 
+from cpython cimport PyObject
+
+cdef extern from "methodobject.h":
+    cdef int PyCFunction_GetFlags(PyObject *op)
+
+
 cdef frozenset special_method_names = frozenset(['__abs__', '__add__',
             '__and__', '__call__', '__cmp__', '__coerce__', '__complex__', '__contains__', '__del__',
             '__delattr__', '__delete__', '__delitem__', '__delslice__', '__dir__', '__div__',
@@ -2672,6 +2678,7 @@ cdef class CachedMethod(object):
         # we need to analyse the argspec
         f = (<CachedFunction>self._cachedfunc).f
         if self.nargs==0:
+            bla = PyCFunction_GetFlags(<PyObject *>f)
             args, varargs, keywords, defaults = sage_getargspec(f)
             if varargs is None and keywords is None and len(args)<=1:
                 self.nargs = 1
```
According to the crash report that I get, the error occurs in the line `args, varargs, keywords, defaults = sage_getargspec(f)`, thus, *after* `PyCFunction_GetFlags` has returned something.



---

archive/issue_comments_234310.json:
```json
{
    "body": "Replace\n\n```\ncdef int PyCFunction_GetFlags(PyObject *op)\n```\nby\n\n```\ncdef int PyCFunction_GetFlags(object op) except -1\n```",
    "created_at": "2015-02-21T13:13:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234310",
    "user": "https://github.com/jdemeyer"
}
```

Replace

```
cdef int PyCFunction_GetFlags(PyObject *op)
```
by

```
cdef int PyCFunction_GetFlags(object op) except -1
```



---

archive/issue_comments_234311.json:
```json
{
    "body": "With the correct `except` declaration, there is an error if the argument is not a \"built-in\" (Cython) method:\n\n```\nSystemError: Objects/methodobject.c:64: bad argument to internal function\n```",
    "created_at": "2015-02-21T14:45:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234311",
    "user": "https://github.com/jdemeyer"
}
```

With the correct `except` declaration, there is an error if the argument is not a "built-in" (Cython) method:

```
SystemError: Objects/methodobject.c:64: bad argument to internal function
```



---

archive/issue_comments_234312.json:
```json
{
    "body": "Replying to [comment:23 jdemeyer]:\n> With the correct `except` declaration, there is an error if the argument is not a \"built-in\" (Cython) method:\n> \n> ```\n> SystemError: Objects/methodobject.c:64: bad argument to internal function\n> ```\n\n\nOK, we then have an error whose traceback points to calling the function.",
    "created_at": "2015-02-21T14:47:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234312",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:23 jdemeyer]:
> With the correct `except` declaration, there is an error if the argument is not a "built-in" (Cython) method:
> 
> ```
> SystemError: Objects/methodobject.c:64: bad argument to internal function
> ```


OK, we then have an error whose traceback points to calling the function.



---

archive/issue_comments_234313.json:
```json
{
    "body": "Apparently `PyCFunction_GetFlags` is the wrong tool (or we first need to extract the cfunction from the method), since always an error is raised.",
    "created_at": "2015-02-21T14:52:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234313",
    "user": "https://github.com/simon-king-jena"
}
```

Apparently `PyCFunction_GetFlags` is the wrong tool (or we first need to extract the cfunction from the method), since always an error is raised.



---

archive/issue_comments_234314.json:
```json
{
    "body": "Replying to [comment:25 SimonKing]:\n> Apparently `PyCFunction_GetFlags` is the wrong tool (or we first need to extract the cfunction from the method), since always an error is raised.\n\nIt is the *right* tool for **bound** **Cython** methods.",
    "created_at": "2015-02-21T17:54:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234314",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:25 SimonKing]:
> Apparently `PyCFunction_GetFlags` is the wrong tool (or we first need to extract the cfunction from the method), since always an error is raised.

It is the *right* tool for **bound** **Cython** methods.



---

archive/issue_comments_234315.json:
```json
{
    "body": "I am currently testing something else, but for example\n\n```\nsage: K = GF(5)\nsage: m = K.factored_unit_order\nsage: m\n<built-in method factored_unit_order of FiniteField_prime_modn_with_category object at 0x7f357853c1e0>\n```\nThis `m` object should be suitable as argument for `PyCFunction_GetFlags`.",
    "created_at": "2015-02-21T18:00:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234315",
    "user": "https://github.com/jdemeyer"
}
```

I am currently testing something else, but for example

```
sage: K = GF(5)
sage: m = K.factored_unit_order
sage: m
<built-in method factored_unit_order of FiniteField_prime_modn_with_category object at 0x7f357853c1e0>
```
This `m` object should be suitable as argument for `PyCFunction_GetFlags`.



---

archive/issue_comments_234316.json:
```json
{
    "body": "Replying to [comment:26 jdemeyer]:\n> Replying to [comment:25 SimonKing]:\n> > Apparently `PyCFunction_GetFlags` is the wrong tool (or we first need to extract the cfunction from the method), since always an error is raised.\n\n> It is the *right* tool for **bound** **Cython** methods.\n\nExactly. And what is wrapped by a cached method is *not* a bound method, but an unbound method (or even a function that is not a method at all?). Would it make sense to take the time to create a bound copy, after making sure that it is not a Python thingy?",
    "created_at": "2015-02-21T18:53:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234316",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:26 jdemeyer]:
> Replying to [comment:25 SimonKing]:
> > Apparently `PyCFunction_GetFlags` is the wrong tool (or we first need to extract the cfunction from the method), since always an error is raised.

> It is the *right* tool for **bound** **Cython** methods.

Exactly. And what is wrapped by a cached method is *not* a bound method, but an unbound method (or even a function that is not a method at all?). Would it make sense to take the time to create a bound copy, after making sure that it is not a Python thingy?



---

archive/issue_comments_234317.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-02-21T19:52:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234317",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_234318.json:
```json
{
    "body": "I have attached a branch. If you have a cached method without arguments in a cython file and remove the sources before starting sage, then both accessing and calling the method should work. If you have a cached method *with* arguments in a cython file and remove the sources before starting sage, then accessing the method works, but calling would still not work. Methods in Python files should not be affected.\n\nI don't know how to write a meaningful doctest for it (and also I didn't run the testsuite). Anyway, perhaps you can comment whether you think that it is a solution to the problem, or at least a step in the right direction.",
    "created_at": "2015-02-21T19:52:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234318",
    "user": "https://github.com/simon-king-jena"
}
```

I have attached a branch. If you have a cached method without arguments in a cython file and remove the sources before starting sage, then both accessing and calling the method should work. If you have a cached method *with* arguments in a cython file and remove the sources before starting sage, then accessing the method works, but calling would still not work. Methods in Python files should not be affected.

I don't know how to write a meaningful doctest for it (and also I didn't run the testsuite). Anyway, perhaps you can comment whether you think that it is a solution to the problem, or at least a step in the right direction.



---

archive/issue_comments_234319.json:
```json
{
    "body": "Why has the branch field automatically been deleted?",
    "created_at": "2015-02-21T19:53:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234319",
    "user": "https://github.com/simon-king-jena"
}
```

Why has the branch field automatically been deleted?



---

archive/issue_comments_234320.json:
```json
{
    "body": "Replying to [comment:30 SimonKing]:\n> Anyway, perhaps you can comment whether you think that it is a solution to the problem\n\nGiven that you want to call the method also, no I don't think it's a solution.\n\nPersonally, I still think that [comment:15] is the best solution (but I'm still open to other suggestions).",
    "created_at": "2015-02-21T21:52:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234320",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:30 SimonKing]:
> Anyway, perhaps you can comment whether you think that it is a solution to the problem

Given that you want to call the method also, no I don't think it's a solution.

Personally, I still think that [comment:15] is the best solution (but I'm still open to other suggestions).



---

archive/issue_comments_234321.json:
```json
{
    "body": "Replying to [comment:32 jdemeyer]:\n> Personally, I still think that [comment:15] is the best solution (but I'm still open to other suggestions).\n\n\nThis information is cheaply available when cython does its work, We could ask the cython devs if they would be willing to equip their function objects with attributes that play the role of `__code__.co_argcount`,  `__code__.co_flags` (to see if `*args` or `**kwds` is present), `__code__.varnames`, `func_defaults`.\n\nCython writes the code that splits up the `*args` and `**kwargs` that python calls at C-API get, and generates errors if it doesn't fit some internal pattern. For inspection and dynamical code, the required pattern information should really be made available.\n\nThey could either write it into the docstring (as they already do with source file information) or they could put some attributes on their cython function objects.\n\nExample:\n\n```\nsage: cython(\"\"\"def f(a,b=0): pass\"\"\")\nsage: f(a=1)\nsage: f(b=1)\nTypeError: f() takes at least 1 positional argument (0 given)\nsage: f(1,c=1)\nTypeError: f() got an unexpected keyword argument 'c'\n```\nI think it's quite reasonable if cython would make available what the number of positional arguments can be and which keyword arguments are accepted.",
    "created_at": "2015-02-22T08:51:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234321",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:32 jdemeyer]:
> Personally, I still think that [comment:15] is the best solution (but I'm still open to other suggestions).


This information is cheaply available when cython does its work, We could ask the cython devs if they would be willing to equip their function objects with attributes that play the role of `__code__.co_argcount`,  `__code__.co_flags` (to see if `*args` or `**kwds` is present), `__code__.varnames`, `func_defaults`.

Cython writes the code that splits up the `*args` and `**kwargs` that python calls at C-API get, and generates errors if it doesn't fit some internal pattern. For inspection and dynamical code, the required pattern information should really be made available.

They could either write it into the docstring (as they already do with source file information) or they could put some attributes on their cython function objects.

Example:

```
sage: cython("""def f(a,b=0): pass""")
sage: f(a=1)
sage: f(b=1)
TypeError: f() takes at least 1 positional argument (0 given)
sage: f(1,c=1)
TypeError: f() got an unexpected keyword argument 'c'
```
I think it's quite reasonable if cython would make available what the number of positional arguments can be and which keyword arguments are accepted.



---

archive/issue_comments_234322.json:
```json
{
    "body": "Replying to [comment:33 nbruin]:\n> Replying to [comment:32 jdemeyer]:\n> > Personally, I still think that [comment:15] is the best solution (but I'm still open to other suggestions).\n\n> \n> This information is cheaply available when cython does its work, We could ask the cython devs if they would be willing to equip their function objects with attributes that play the role of `__code__.co_argcount`,  `__code__.co_flags` (to see if `*args` or `**kwds` is present), `__code__.varnames`, `func_defaults`.\n\n\nIf I recall correctly, there is a compile option to do so.\n\nIn any case, I believe that for now we should proceed as follows:\n- Avoid source code inspection in the cached method's `__get__` (as done by the currently attached branch)\n- When creating the `ArgumentFixer`, we need to know the argspec. If it can not be determined, then no error should be raised. Instead, a generic argument fixer (or no argument fixer at all) shall be used, meaning that the argspec is assumed to be formed by `self`, `*args` and `**kwds`. This I can implement shortly, as soon as I have reinstalled ccache on my current Sage version (now it takes hours to switch branches `:-/`).\n- In the long run, ask the cython devs to provide functions that can access the relevant information.",
    "created_at": "2015-02-22T09:02:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234322",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:33 nbruin]:
> Replying to [comment:32 jdemeyer]:
> > Personally, I still think that [comment:15] is the best solution (but I'm still open to other suggestions).

> 
> This information is cheaply available when cython does its work, We could ask the cython devs if they would be willing to equip their function objects with attributes that play the role of `__code__.co_argcount`,  `__code__.co_flags` (to see if `*args` or `**kwds` is present), `__code__.varnames`, `func_defaults`.


If I recall correctly, there is a compile option to do so.

In any case, I believe that for now we should proceed as follows:
- Avoid source code inspection in the cached method's `__get__` (as done by the currently attached branch)
- When creating the `ArgumentFixer`, we need to know the argspec. If it can not be determined, then no error should be raised. Instead, a generic argument fixer (or no argument fixer at all) shall be used, meaning that the argspec is assumed to be formed by `self`, `*args` and `**kwds`. This I can implement shortly, as soon as I have reinstalled ccache on my current Sage version (now it takes hours to switch branches `:-/`).
- In the long run, ask the cython devs to provide functions that can access the relevant information.



---

archive/issue_comments_234323.json:
```json
{
    "body": "Replying to [comment:33 nbruin]:\n> They could either write it into the docstring (as they already do with source file information) or they could put some attributes on their cython function objects.\n\nI think the docstring is the only option: look at the fields of [PyMethodDef](https://docs.python.org/2/c-api/structures.html#c.PyMethodDef)\n\nEven then, I would propose to use just `*args` and `**kwds` for Cython methods, which will surely be faster than messing with the list of arguments. In the case where uniquess really matters for Cython methods, a wrapper could be added to fix the arguments.",
    "created_at": "2015-02-22T09:32:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234323",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:33 nbruin]:
> They could either write it into the docstring (as they already do with source file information) or they could put some attributes on their cython function objects.

I think the docstring is the only option: look at the fields of [PyMethodDef](https://docs.python.org/2/c-api/structures.html#c.PyMethodDef)

Even then, I would propose to use just `*args` and `**kwds` for Cython methods, which will surely be faster than messing with the list of arguments. In the case where uniquess really matters for Cython methods, a wrapper could be added to fix the arguments.



---

archive/issue_comments_234324.json:
```json
{
    "body": "Now I am totally puzzled. There are the Cython modules `sage.misc.function_mangling` and `sage.misc.cachefunc`, but they don't appear in `src/module_list.py`! So, why are they built at all? Is that a recent change? E.g.., is it not needed anymore to mention a `.pyx` file in `module_list.py` if it has no `.pxd` and no compile options?",
    "created_at": "2015-02-22T09:52:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234324",
    "user": "https://github.com/simon-king-jena"
}
```

Now I am totally puzzled. There are the Cython modules `sage.misc.function_mangling` and `sage.misc.cachefunc`, but they don't appear in `src/module_list.py`! So, why are they built at all? Is that a recent change? E.g.., is it not needed anymore to mention a `.pyx` file in `module_list.py` if it has no `.pxd` and no compile options?



---

archive/issue_comments_234325.json:
```json
{
    "body": "Replying to [comment:36 SimonKing]:\n> Now I am totally puzzled. There are the Cython modules `sage.misc.function_mangling` and `sage.misc.cachefunc`, but they don't appear in `src/module_list.py`! So, why are they built at all? Is that a recent change? E.g.., is it not needed anymore to mention a `.pyx` file in `module_list.py` if it has no `.pxd` and no compile options?\n\nSee #17767",
    "created_at": "2015-02-22T10:15:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234325",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:36 SimonKing]:
> Now I am totally puzzled. There are the Cython modules `sage.misc.function_mangling` and `sage.misc.cachefunc`, but they don't appear in `src/module_list.py`! So, why are they built at all? Is that a recent change? E.g.., is it not needed anymore to mention a `.pyx` file in `module_list.py` if it has no `.pxd` and no compile options?

See #17767



---

archive/issue_comments_234326.json:
```json
{
    "body": "Soon I will submit another commit. With it, I can do the following:\n\nI created a file `src/sage/misc/cache_test.pyx` and rebuilt Sage. In fact, the new pyx file got compiled even without mentioning it in `module_list.py`. Content of the file:\n\n```python\nfrom sage.misc.cachefunc import cached_method, cached_function\nfrom sage.structure.parent cimport Parent\n\n@cached_function\ndef bla(x,y,z=2):\n    return (x+y)*z\n\ncdef class Foo(Parent):\n    @cached_method\n    def bar(self, a,b, c=1):\n        return (a+b)*c\n```\nI started a Sage session and got:\n\n```\nsage: from sage.misc.cache_test import Foo, bla\nsage: bla(2,3,2) is bla(2,3,z=2)\nTrue\nsage: F = Foo()\nsage: F.bar(2,3,2) is F.bar(2,3,c=2)\nTrue\n```\nas expected.\n\nThen I left Sage, removed `src/sage/misc/cache_test.pyx`. Restarting (but not recompiling!) Sage, I now get:\n\n```\nsage: from sage.misc.cache_test import Foo, bla\nsage: bla(2,3,2) is bla(2,3,z=2)\nFalse\nsage: bla(2,3,2) == bla(2,3,z=2)\nTrue\nsage: F = Foo()\nsage: F.bar(2,3,2) is F.bar(2,3,c=2)\nFalse\nsage: F.bar(2,3,2) == F.bar(2,3,c=2)\nTrue\nsage: bla(2,3,2) is bla(2,3,2)\nTrue\nsage: F.bar(2,3,2) is F.bar(2,3,2)\nTrue\n```\nSo, the argument mangling fails, but at least one can call the wrapped functions and methods in the expected way, with a basic level of caching.\n\nNow the questions are: Would that be enough to declare the problem as \"fixed for now\"? And how to doctest it? Is it possible/reasonable to have a source file that is temporarily moved away by its own doctest?\n\nBranch will soon be updated.",
    "created_at": "2015-02-22T10:16:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234326",
    "user": "https://github.com/simon-king-jena"
}
```

Soon I will submit another commit. With it, I can do the following:

I created a file `src/sage/misc/cache_test.pyx` and rebuilt Sage. In fact, the new pyx file got compiled even without mentioning it in `module_list.py`. Content of the file:

```python
from sage.misc.cachefunc import cached_method, cached_function
from sage.structure.parent cimport Parent

@cached_function
def bla(x,y,z=2):
    return (x+y)*z

cdef class Foo(Parent):
    @cached_method
    def bar(self, a,b, c=1):
        return (a+b)*c
```
I started a Sage session and got:

```
sage: from sage.misc.cache_test import Foo, bla
sage: bla(2,3,2) is bla(2,3,z=2)
True
sage: F = Foo()
sage: F.bar(2,3,2) is F.bar(2,3,c=2)
True
```
as expected.

Then I left Sage, removed `src/sage/misc/cache_test.pyx`. Restarting (but not recompiling!) Sage, I now get:

```
sage: from sage.misc.cache_test import Foo, bla
sage: bla(2,3,2) is bla(2,3,z=2)
False
sage: bla(2,3,2) == bla(2,3,z=2)
True
sage: F = Foo()
sage: F.bar(2,3,2) is F.bar(2,3,c=2)
False
sage: F.bar(2,3,2) == F.bar(2,3,c=2)
True
sage: bla(2,3,2) is bla(2,3,2)
True
sage: F.bar(2,3,2) is F.bar(2,3,2)
True
```
So, the argument mangling fails, but at least one can call the wrapped functions and methods in the expected way, with a basic level of caching.

Now the questions are: Would that be enough to declare the problem as "fixed for now"? And how to doctest it? Is it possible/reasonable to have a source file that is temporarily moved away by its own doctest?

Branch will soon be updated.



---

archive/issue_comments_234327.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-02-22T10:21:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234327",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_234328.json:
```json
{
    "body": "Replying to [comment:37 jdemeyer]:\n> See #17767\n\n\nSpecial-casing for various modules? Ouch, I don't like that.",
    "created_at": "2015-02-22T10:22:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234328",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:37 jdemeyer]:
> See #17767


Special-casing for various modules? Ouch, I don't like that.



---

archive/issue_comments_234329.json:
```json
{
    "body": "If we need to access argument information on cython functions/methods, we might consider using\n\n```\ncython(\"\"\"\nimport cython\n@cython.binding(True)\ndef f(a,b=0): pass\n\ndef g(a,b=0): pass\n\ndef c(F,n_in):\n  cdef int n=n_in\n  for i in range(n):\n    F(1)\n\"\"\")\n```\nWith this we have\n\n```\nsage: f.func_defaults\n(0,)\nsage: f.__code__.co_varnames\n('a', 'b')\n```\nThere might be a penalty to pay, though:\n\n```\nsage: %time c(f,1000000000)\nCPU times: user 7.7 s, sys: 10 ms, total: 7.71 s\nWall time: 8.06 s\nsage: %time c(g,1000000000)\nCPU times: user 7.43 s, sys: 13 ms, total: 7.45 s\nWall time: 7.78 s\n```\nIf we can do away with source file inspection during startup (as would now happen for cython modules), we should see a significant improvement of startup time too! Finding line numbers in a text file is not a fast operation.",
    "created_at": "2015-02-22T18:58:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234329",
    "user": "https://github.com/nbruin"
}
```

If we need to access argument information on cython functions/methods, we might consider using

```
cython("""
import cython
@cython.binding(True)
def f(a,b=0): pass

def g(a,b=0): pass

def c(F,n_in):
  cdef int n=n_in
  for i in range(n):
    F(1)
""")
```
With this we have

```
sage: f.func_defaults
(0,)
sage: f.__code__.co_varnames
('a', 'b')
```
There might be a penalty to pay, though:

```
sage: %time c(f,1000000000)
CPU times: user 7.7 s, sys: 10 ms, total: 7.71 s
Wall time: 8.06 s
sage: %time c(g,1000000000)
CPU times: user 7.43 s, sys: 13 ms, total: 7.45 s
Wall time: 7.78 s
```
If we can do away with source file inspection during startup (as would now happen for cython modules), we should see a significant improvement of startup time too! Finding line numbers in a text file is not a fast operation.



---

archive/issue_comments_234330.json:
```json
{
    "body": "Replying to [comment:38 SimonKing]:\n> Is it possible/reasonable to have a source file that is temporarily moved away by its own doctest?\n\nCertainly not :-)",
    "created_at": "2015-02-22T19:33:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234330",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:38 SimonKing]:
> Is it possible/reasonable to have a source file that is temporarily moved away by its own doctest?

Certainly not :-)



---

archive/issue_comments_234331.json:
```json
{
    "body": "Replying to [comment:41 nbruin]:\n> If we need to access argument information on cython functions/methods, we might consider using\n> \n> ```\n> cython(\"\"\"\n> import cython\n> @cython.binding(True)\n> def f(a,b=0): pass\n> \n> def g(a,b=0): pass\n> \n> def c(F,n_in):\n>   cdef int n=n_in\n>   for i in range(n):\n>     F(1)\n> \"\"\")\n> ```\n\n\nI think this trick only works with module-level functions, not method (but I need to recheck).",
    "created_at": "2015-02-22T19:35:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234331",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:41 nbruin]:
> If we need to access argument information on cython functions/methods, we might consider using
> 
> ```
> cython("""
> import cython
> @cython.binding(True)
> def f(a,b=0): pass
> 
> def g(a,b=0): pass
> 
> def c(F,n_in):
>   cdef int n=n_in
>   for i in range(n):
>     F(1)
> """)
> ```


I think this trick only works with module-level functions, not method (but I need to recheck).



---

archive/issue_comments_234332.json:
```json
{
    "body": "Replying to [comment:42 jdemeyer]:\n> Replying to [comment:38 SimonKing]:\n> > Is it possible/reasonable to have a source file that is temporarily moved away by its own doctest?\n\n> Certainly not :-)\n\nWhy not? The test itself is obtained from a temporary copy of the file, if I recall correctly. One might think of writing a test that renames the original source file, then does the test, and moves the source file back. Of course, it will only work if the user has write permission.",
    "created_at": "2015-02-22T19:40:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234332",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:42 jdemeyer]:
> Replying to [comment:38 SimonKing]:
> > Is it possible/reasonable to have a source file that is temporarily moved away by its own doctest?

> Certainly not :-)

Why not? The test itself is obtained from a temporary copy of the file, if I recall correctly. One might think of writing a test that renames the original source file, then does the test, and moves the source file back. Of course, it will only work if the user has write permission.



---

archive/issue_comments_234333.json:
```json
{
    "body": "Replying to [comment:38 SimonKing]:\n> So, the argument mangling fails, but at least one can call the wrapped functions and methods in the expected way, with a basic level of caching.\n\n\nHonestly, I absolutely don't like it. It's much better if stuff obviously breaks (i.e. the current situation) instead of breaking in a very subtle way (some method relies on uniquess, which is not guaranteed if the source file is missing).\n\nIf this issue is fixed, it should be fixed in such a way that it doesn't matter at all whether the source file is present.",
    "created_at": "2015-02-22T19:45:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234333",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:38 SimonKing]:
> So, the argument mangling fails, but at least one can call the wrapped functions and methods in the expected way, with a basic level of caching.


Honestly, I absolutely don't like it. It's much better if stuff obviously breaks (i.e. the current situation) instead of breaking in a very subtle way (some method relies on uniquess, which is not guaranteed if the source file is missing).

If this issue is fixed, it should be fixed in such a way that it doesn't matter at all whether the source file is present.



---

archive/issue_comments_234334.json:
```json
{
    "body": "Replying to [comment:44 SimonKing]:\n> The test itself is obtained from a temporary copy of the file, if I recall correctly.\n\nThat's no longer true (but the test is read before it is executed, so that's not the issue).\n\n> One might think of writing a test that renames the original source file, then does the test, and moves the source file back. Of course, it will only work if the user has write permission.\n\nDoctests should never write anything below `SAGE_ROOT` and your proposal will break badly if the test is interrupted at the wrong moment (you could try something with `try`/`finally` but still it's dangerous). Also, you will get race conditions (imagine you're editing the file while the test is running).",
    "created_at": "2015-02-22T19:48:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234334",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:44 SimonKing]:
> The test itself is obtained from a temporary copy of the file, if I recall correctly.

That's no longer true (but the test is read before it is executed, so that's not the issue).

> One might think of writing a test that renames the original source file, then does the test, and moves the source file back. Of course, it will only work if the user has write permission.

Doctests should never write anything below `SAGE_ROOT` and your proposal will break badly if the test is interrupted at the wrong moment (you could try something with `try`/`finally` but still it's dangerous). Also, you will get race conditions (imagine you're editing the file while the test is running).



---

archive/issue_comments_234335.json:
```json
{
    "body": "Replying to [comment:43 jdemeyer]:\n> I think this trick only works with module-level functions, not method (but I need to recheck).\n\n\nIt does seem to work for `class` in cython, but sadly not for `cdef class`:\n\n```\ncython(\"\"\"\nmy_global=[]\ndef mydec(a):\n  global my_global\n  my_global.append(a)\n  return(a)\n\nimport cython\nclass A(object):\n  @mydec\n  @cython.binding(True)\n  def b(x,y=0):\n    pass\n\ncdef class B(object):\n  @mydec\n  @cython.binding(True)\n  def b(x,y=0):\n    pass\n\"\"\")\n```\n\n```\nsage: my_global\n[<cyfunction A.b at 0x7f1b0e947590>,\n <method 'b' of '_home_nbruin__sage_temp_art_17765_tmp_DC65IM_spyx_0.B' objects>]\n```\nThe first object does have the `func_*` attributes, but the second doesn't. Perhaps that is something that the cython devs can do something about.",
    "created_at": "2015-02-22T20:16:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234335",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:43 jdemeyer]:
> I think this trick only works with module-level functions, not method (but I need to recheck).


It does seem to work for `class` in cython, but sadly not for `cdef class`:

```
cython("""
my_global=[]
def mydec(a):
  global my_global
  my_global.append(a)
  return(a)

import cython
class A(object):
  @mydec
  @cython.binding(True)
  def b(x,y=0):
    pass

cdef class B(object):
  @mydec
  @cython.binding(True)
  def b(x,y=0):
    pass
""")
```

```
sage: my_global
[<cyfunction A.b at 0x7f1b0e947590>,
 <method 'b' of '_home_nbruin__sage_temp_art_17765_tmp_DC65IM_spyx_0.B' objects>]
```
The first object does have the `func_*` attributes, but the second doesn't. Perhaps that is something that the cython devs can do something about.



---

archive/issue_comments_234336.json:
```json
{
    "body": "Replying to [comment:47 nbruin]:\n> The first object does have the `func_*` attributes, but the second doesn't. Perhaps that is something that the cython devs can do something about.\n\nNot without a performance penalty. If you want the method to be a fast `PyCFunction`, you are limited in which attributes it has.",
    "created_at": "2015-02-22T20:26:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234336",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:47 nbruin]:
> The first object does have the `func_*` attributes, but the second doesn't. Perhaps that is something that the cython devs can do something about.

Not without a performance penalty. If you want the method to be a fast `PyCFunction`, you are limited in which attributes it has.



---

archive/issue_comments_234337.json:
```json
{
    "body": "In other words, I think it needs a *Python* patch first to add the hooks which then Cython could use.",
    "created_at": "2015-02-22T20:27:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234337",
    "user": "https://github.com/jdemeyer"
}
```

In other words, I think it needs a *Python* patch first to add the hooks which then Cython could use.



---

archive/issue_comments_234338.json:
```json
{
    "body": "Replying to [comment:49 jdemeyer]:\n> In other words, I think it needs a *Python* patch first to add the hooks which then Cython could use.\n\nwell ... I think the more reasonable solution is to write the signature in the docstring, which is available. That's what cython already does to make source location available.\n\nIt's unfortunate: all the required objects already exist in the cython code, there are just no hooks to attach them to.",
    "created_at": "2015-02-22T21:22:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234338",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:49 jdemeyer]:
> In other words, I think it needs a *Python* patch first to add the hooks which then Cython could use.

well ... I think the more reasonable solution is to write the signature in the docstring, which is available. That's what cython already does to make source location available.

It's unfortunate: all the required objects already exist in the cython code, there are just no hooks to attach them to.



---

archive/issue_comments_234339.json:
```json
{
    "body": "Replying to [comment:50 nbruin]:\n> It's unfortunate: all the required objects already exist in the cython code, there are just no hooks to attach them to.\n\n\nThat's why\u00a0I suggest to have a practical fix that works for now. Recall that the problem from the ticket description came from a report on sage-devel, where people actually work with flavours of Sage that come without the source code.\n\nI think that the current branch does not have a high danger of creating subtle caching problems. First of all, with the branch, a change in behaviour can only occur when we have a cached method-with-default-arguments-and/or-args/kwds of a cdef class whose source file is not available. Methods without arguments will be totally fine if the source file is gone (so, the branch does fix a problem).\n\nA change in behaviour would most likely be a problem where coercion is involved, i.e., in `UniqueRepresentation`. But there, we are safe, since (a) sub-classes of `UniqueRepresentation` must be Python classes anyway (and Python classes aren't affected by the bug), and (b) `UniqueRepresentation.__classcall__` has generic arguments `*args,**kwds`.\n\nIf you think that it is too dangerous to silently change behaviour rather than raise a straight forward error, we could instead raise a warning (only once, similar to deprecation warnings) when a cached method is called on a method whose argspec can't be determined.",
    "created_at": "2015-02-22T21:44:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234339",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:50 nbruin]:
> It's unfortunate: all the required objects already exist in the cython code, there are just no hooks to attach them to.


That's why I suggest to have a practical fix that works for now. Recall that the problem from the ticket description came from a report on sage-devel, where people actually work with flavours of Sage that come without the source code.

I think that the current branch does not have a high danger of creating subtle caching problems. First of all, with the branch, a change in behaviour can only occur when we have a cached method-with-default-arguments-and/or-args/kwds of a cdef class whose source file is not available. Methods without arguments will be totally fine if the source file is gone (so, the branch does fix a problem).

A change in behaviour would most likely be a problem where coercion is involved, i.e., in `UniqueRepresentation`. But there, we are safe, since (a) sub-classes of `UniqueRepresentation` must be Python classes anyway (and Python classes aren't affected by the bug), and (b) `UniqueRepresentation.__classcall__` has generic arguments `*args,**kwds`.

If you think that it is too dangerous to silently change behaviour rather than raise a straight forward error, we could instead raise a warning (only once, similar to deprecation warnings) when a cached method is called on a method whose argspec can't be determined.



---

archive/issue_comments_234340.json:
```json
{
    "body": "Replying to [comment:51 SimonKing]:\n> I think that the current branch does not have a high danger of creating subtle caching problems. First of all, with the branch, a change in behaviour can only occur when we have a cached method-with-default-arguments-and/or-args/kwds of a cdef class whose source file is not available. Methods without arguments will be totally fine if the source file is gone (so, the branch does fix a problem).\n\n\nI agree the danger is \"not high\" but it's not zero either. Subtle deviations like this are the source of incredibly difficult-to-replicate issues later on, because the reporter will of course forget to report that this is a sourceless distribution. (Perhaps it's not so bad: the bug will just be ignored because we can't replicate it)\n\nI'm not so sure a warning is an option: I'd expect that the first occurrence would be during system startup, so the warning might get lost.\n\nAnyway, I think the fact that we look at the source at all in order to figure out how to preprocess the arguments is a deficiency. I'd prefer if we can use this ticket to track the resolution of that, but if this issue is really urgent for some users, I guess we can merge something along the lines of what you propose.\n\nI expect that we'll find a cython-based solution, possibly docstring based. It might be a configure option to select if you want this extra data in your docstrings, but in sage we probably would, since we process the docstrings for display anyway.",
    "created_at": "2015-02-23T01:03:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234340",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:51 SimonKing]:
> I think that the current branch does not have a high danger of creating subtle caching problems. First of all, with the branch, a change in behaviour can only occur when we have a cached method-with-default-arguments-and/or-args/kwds of a cdef class whose source file is not available. Methods without arguments will be totally fine if the source file is gone (so, the branch does fix a problem).


I agree the danger is "not high" but it's not zero either. Subtle deviations like this are the source of incredibly difficult-to-replicate issues later on, because the reporter will of course forget to report that this is a sourceless distribution. (Perhaps it's not so bad: the bug will just be ignored because we can't replicate it)

I'm not so sure a warning is an option: I'd expect that the first occurrence would be during system startup, so the warning might get lost.

Anyway, I think the fact that we look at the source at all in order to figure out how to preprocess the arguments is a deficiency. I'd prefer if we can use this ticket to track the resolution of that, but if this issue is really urgent for some users, I guess we can merge something along the lines of what you propose.

I expect that we'll find a cython-based solution, possibly docstring based. It might be a configure option to select if you want this extra data in your docstrings, but in sage we probably would, since we process the docstrings for display anyway.



---

archive/issue_comments_234341.json:
```json
{
    "body": "Replying to [comment:51 SimonKing]:\n> I think that the current branch does not have a high danger of creating subtle caching problems. First of all, with the branch, a change in behaviour can only occur when we have a cached method-with-default-arguments-and/or-args/kwds of a cdef class whose source file is not available. Methods without arguments will be totally fine if the source file is gone (so, the branch does fix a problem).\n\nProposal [comment:15] also has that property.\n\n> A change in behaviour would most likely be a problem where coercion is involved, i.e., in `UniqueRepresentation`. But there, we are safe, since (a) sub-classes of `UniqueRepresentation` must be Python classes anyway (and Python classes aren't affected by the bug), and (b) `UniqueRepresentation.__classcall__` has generic arguments `*args,**kwds`.\n\nPython classes would be unaffected by proposal [comment:15].\n\n> If you think that it is too dangerous to silently change behaviour rather than raise a straight forward error, we could instead raise a warning (only once, similar to deprecation warnings) when a cached method is called on a method whose argspec can't be determined.\n\nI think we need to agree first on whether the uniquess property for Cython cached methods is important.\n\n1. If uniqueness is important, then it is indeed \"too dangerous to silently change behaviour\". ==> Go with the solution of Nils to somehow put the argspec information in the docstring and use that.\n\n2. If uniqueness is not important, then why bother reading the argspec anyway? ==> Proposal [comment:15]",
    "created_at": "2015-02-23T07:28:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234341",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:51 SimonKing]:
> I think that the current branch does not have a high danger of creating subtle caching problems. First of all, with the branch, a change in behaviour can only occur when we have a cached method-with-default-arguments-and/or-args/kwds of a cdef class whose source file is not available. Methods without arguments will be totally fine if the source file is gone (so, the branch does fix a problem).

Proposal [comment:15] also has that property.

> A change in behaviour would most likely be a problem where coercion is involved, i.e., in `UniqueRepresentation`. But there, we are safe, since (a) sub-classes of `UniqueRepresentation` must be Python classes anyway (and Python classes aren't affected by the bug), and (b) `UniqueRepresentation.__classcall__` has generic arguments `*args,**kwds`.

Python classes would be unaffected by proposal [comment:15].

> If you think that it is too dangerous to silently change behaviour rather than raise a straight forward error, we could instead raise a warning (only once, similar to deprecation warnings) when a cached method is called on a method whose argspec can't be determined.

I think we need to agree first on whether the uniquess property for Cython cached methods is important.

1. If uniqueness is important, then it is indeed "too dangerous to silently change behaviour". ==> Go with the solution of Nils to somehow put the argspec information in the docstring and use that.

2. If uniqueness is not important, then why bother reading the argspec anyway? ==> Proposal [comment:15]



---

archive/issue_comments_234342.json:
```json
{
    "body": "Can we perhaps instrument the caching machinery to log any cache hits that would have been misses if `*arg, **kwarg` would be processed into a cache key without transporting over keywords to positional parameters? Then we can see the extent of the problem.\n\nThe main one I expect there is from cases where people specify a default parameter, but with the default value, and that's a serious one:\n\n```\n@cached_function\ndef a(x,y=1)\n  return set([x,y])\n```\nThen `[a(1),a(1,1)]` should contain two identical sets, but only caching on `*arg` and `**kwarg` would return result in two non-identical sets, because the second would have an implicit keyword parameter `y` rather than a second positional parameter.\n\nI think this is potentially quite a serious issue, especially because in sage, much caching happens with the purpose of making things unique (but perhaps currently never in cython applications ...)",
    "created_at": "2015-02-23T16:33:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234342",
    "user": "https://github.com/nbruin"
}
```

Can we perhaps instrument the caching machinery to log any cache hits that would have been misses if `*arg, **kwarg` would be processed into a cache key without transporting over keywords to positional parameters? Then we can see the extent of the problem.

The main one I expect there is from cases where people specify a default parameter, but with the default value, and that's a serious one:

```
@cached_function
def a(x,y=1)
  return set([x,y])
```
Then `[a(1),a(1,1)]` should contain two identical sets, but only caching on `*arg` and `**kwarg` would return result in two non-identical sets, because the second would have an implicit keyword parameter `y` rather than a second positional parameter.

I think this is potentially quite a serious issue, especially because in sage, much caching happens with the purpose of making things unique (but perhaps currently never in cython applications ...)



---

archive/issue_comments_234343.json:
```json
{
    "body": "I think this `embedsignature=True` is what we need:\n\n```\nsage: cython(\"\"\"\n....: import cython\n....: cdef class A(object):\n....:   @cython.embedsignature(True)\n....:   def b(x,y=0): pass\n....: \"\"\")\nsage: print A.b.__doc__\nA.b(x, y=0)\nFile: _home_nbruin__sage_temp_art_5476_tmp_LOYsNA_spyx_0.pyx (starting at line 10)\n```\ni.e., if we ensure that we have `embedsignature=True` (probably globally throughout the library), then we just need to change how cython docstrings are used to accommodate for the fact that the first line is the signature. Then `sage_argspec` can just look in the docstring to see if it can find a signature there. No source inspection required anymore.",
    "created_at": "2015-02-24T08:01:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234343",
    "user": "https://github.com/nbruin"
}
```

I think this `embedsignature=True` is what we need:

```
sage: cython("""
....: import cython
....: cdef class A(object):
....:   @cython.embedsignature(True)
....:   def b(x,y=0): pass
....: """)
sage: print A.b.__doc__
A.b(x, y=0)
File: _home_nbruin__sage_temp_art_5476_tmp_LOYsNA_spyx_0.pyx (starting at line 10)
```
i.e., if we ensure that we have `embedsignature=True` (probably globally throughout the library), then we just need to change how cython docstrings are used to accommodate for the fact that the first line is the signature. Then `sage_argspec` can just look in the docstring to see if it can find a signature there. No source inspection required anymore.



---

archive/issue_comments_234344.json:
```json
{
    "body": "Replying to [comment:55 nbruin]:\n> {{{\n> sage: cython(\"\"\"\n> ....: import cython\n> ....: cdef class A(object):\n> ....:   `@`cython.embedsignature(True)\n> ....:   def b(x,y=0): pass\n> ....: \"\"\")\n> sage: print A.b.__doc__\n> A.b(x, y=0)\n> File: _home_nbruin__sage_temp_art_5476_tmp_LOYsNA_spyx_0.pyx (starting at line 10)\n> }}}\n\n\nCool! Would that option be easy to enable globally? If not, then I still think assuming a generic argspec and printing a warning (once for each affected cached method) would be better than nothing.",
    "created_at": "2015-02-24T09:18:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234344",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:55 nbruin]:
> {{{
> sage: cython("""
> ....: import cython
> ....: cdef class A(object):
> ....:   `@`cython.embedsignature(True)
> ....:   def b(x,y=0): pass
> ....: """)
> sage: print A.b.__doc__
> A.b(x, y=0)
> File: _home_nbruin__sage_temp_art_5476_tmp_LOYsNA_spyx_0.pyx (starting at line 10)
> }}}


Cool! Would that option be easy to enable globally? If not, then I still think assuming a generic argspec and printing a warning (once for each affected cached method) would be better than nothing.



---

archive/issue_comments_234345.json:
```json
{
    "body": "See #17847",
    "created_at": "2015-02-24T10:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234345",
    "user": "https://github.com/jdemeyer"
}
```

See #17847



---

archive/issue_comments_234346.json:
```json
{
    "body": "In other words: Because of Cython caching, we can not use the embedded argspec information, even if we could enable \"embedsignature(True)\" globally, and additionally, if \"embedsignature(True)\" was enabled globally, some valid Cython code wouldn't compile.",
    "created_at": "2015-02-24T11:56:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234346",
    "user": "https://github.com/simon-king-jena"
}
```

In other words: Because of Cython caching, we can not use the embedded argspec information, even if we could enable "embedsignature(True)" globally, and additionally, if "embedsignature(True)" was enabled globally, some valid Cython code wouldn't compile.



---

archive/issue_comments_234347.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-02-24T14:12:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234347",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_234348.json:
```json
{
    "body": "Replying to [comment:58 SimonKing]:\n> Because of Cython caching, we can not use the embedded argspec information\n\nThis is a one-off hitch. It just means that when we enable `embedsignature` globally, people should clear their cython cache (once).\n> even if we could enable \"embedsignature(True)\" globally\n\nWe can.\n\n> if \"embedsignature(True)\" was enabled globally, some valid Cython code wouldn't compile.\n\nbut it's easy to reformulate those cases.",
    "created_at": "2015-02-24T23:58:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234348",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:58 SimonKing]:
> Because of Cython caching, we can not use the embedded argspec information

This is a one-off hitch. It just means that when we enable `embedsignature` globally, people should clear their cython cache (once).
> even if we could enable "embedsignature(True)" globally

We can.

> if "embedsignature(True)" was enabled globally, some valid Cython code wouldn't compile.

but it's easy to reformulate those cases.



---

archive/issue_comments_234349.json:
```json
{
    "body": "Let me mention that #17847 is now in Sage, which makes this ticket feasible.",
    "created_at": "2015-04-16T08:12:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234349",
    "user": "https://github.com/jdemeyer"
}
```

Let me mention that #17847 is now in Sage, which makes this ticket feasible.



---

archive/issue_comments_234350.json:
```json
{
    "body": "Would it be ok to rebase this branch on top of the current develop branch (and then force-push)? Or would it be ok if I merged this branch into the current develop and start with it? Or merge the current develop into this branch? I still don't get what is considered best praxis.",
    "created_at": "2015-04-17T18:06:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234350",
    "user": "https://github.com/simon-king-jena"
}
```

Would it be ok to rebase this branch on top of the current develop branch (and then force-push)? Or would it be ok if I merged this branch into the current develop and start with it? Or merge the current develop into this branch? I still don't get what is considered best praxis.



---

archive/issue_comments_234351.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-18T13:50:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234351",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_234352.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-04-18T14:02:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234352",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_234353.json:
```json
{
    "body": "I am now using the embedded signatures (due to #17847) for introspection. I preserved the previous commits by merging the previous ticket branch into the current develop to get the new ticket branch; hopefully the correct procedure.\n\nIn order to demonstrate what is happening, I added a dummy method to a nested test class provided in sage.misc.nested_class. As it turns out, there has been a bug in the previous `sage_getargspec` that is now fixed. I suppose that the bug actually is in Cython:\n\n```\nsage: from sage.misc.nested_class import MainClass\nsage: print MainClass.NestedClass.NestedSubClass.dummy.func_defaults\nNone\n```\nActually the default is not None but is a tuple, which is correctly determined by the new version of `sage_getargspec`:\n\n```\nsage: sage_getargspec(MainClass.NestedClass.NestedSubClass.dummy)\nArgSpec(args=['self', 'x', 'r'], varargs='args', keywords='kwds', defaults=((1, 2, 3.4),))\n```\n\nMoreover, the above does not involve reading the source code. I wrote a new function that determines the argspec from the embedded signature, and strips the signature at the same time:\n\n```\nsage: print MainClass.NestedClass.NestedSubClass.dummy.__doc__\nNestedSubClass.dummy(self, x, *args, r=(1, 2, 3.4), **kwds)\nFile: sage/misc/nested_class.pyx (starting at line 314)\n\n                A dummy method to demonstrate the embedding of\n                method signature for nested classes.\n...\nsage: from sage.misc.sageinspect import _extract_embedded_signature\nsage: print _extract_embedded_signature(MainClass.NestedClass.NestedSubClass.dummy.__doc__, 'dummy')[0]\nFile: sage/misc/nested_class.pyx (starting at line 314)\n\n                A dummy method to demonstrate the embedding of\n                method signature for nested classes.\n...\nsage: _extract_embedded_signature(MainClass.NestedClass.NestedSubClass.dummy.__doc__, 'dummy')[1]\nArgSpec(args=['self', 'x', 'r'], varargs='args', keywords='kwds', defaults=((1, 2, 3.4),))\n```\n\nThe tests in sage.misc pass.",
    "created_at": "2015-04-18T14:02:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234353",
    "user": "https://github.com/simon-king-jena"
}
```

I am now using the embedded signatures (due to #17847) for introspection. I preserved the previous commits by merging the previous ticket branch into the current develop to get the new ticket branch; hopefully the correct procedure.

In order to demonstrate what is happening, I added a dummy method to a nested test class provided in sage.misc.nested_class. As it turns out, there has been a bug in the previous `sage_getargspec` that is now fixed. I suppose that the bug actually is in Cython:

```
sage: from sage.misc.nested_class import MainClass
sage: print MainClass.NestedClass.NestedSubClass.dummy.func_defaults
None
```
Actually the default is not None but is a tuple, which is correctly determined by the new version of `sage_getargspec`:

```
sage: sage_getargspec(MainClass.NestedClass.NestedSubClass.dummy)
ArgSpec(args=['self', 'x', 'r'], varargs='args', keywords='kwds', defaults=((1, 2, 3.4),))
```

Moreover, the above does not involve reading the source code. I wrote a new function that determines the argspec from the embedded signature, and strips the signature at the same time:

```
sage: print MainClass.NestedClass.NestedSubClass.dummy.__doc__
NestedSubClass.dummy(self, x, *args, r=(1, 2, 3.4), **kwds)
File: sage/misc/nested_class.pyx (starting at line 314)

                A dummy method to demonstrate the embedding of
                method signature for nested classes.
...
sage: from sage.misc.sageinspect import _extract_embedded_signature
sage: print _extract_embedded_signature(MainClass.NestedClass.NestedSubClass.dummy.__doc__, 'dummy')[0]
File: sage/misc/nested_class.pyx (starting at line 314)

                A dummy method to demonstrate the embedding of
                method signature for nested classes.
...
sage: _extract_embedded_signature(MainClass.NestedClass.NestedSubClass.dummy.__doc__, 'dummy')[1]
ArgSpec(args=['self', 'x', 'r'], varargs='args', keywords='kwds', defaults=((1, 2, 3.4),))
```

The tests in sage.misc pass.



---

archive/issue_comments_234354.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-18T21:45:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234354",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_234355.json:
```json
{
    "body": "On 6.7-beta2 I got \n\n```\nsage: K=GF(5)\nsage: K.factored_order\nCached version of <method 'factored_order' of\n'sage.rings.finite_rings.finite_field_base.FiniteField' objects>\n```",
    "created_at": "2015-04-24T21:58:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234355",
    "user": "https://github.com/videlec"
}
```

On 6.7-beta2 I got 

```
sage: K=GF(5)
sage: K.factored_order
Cached version of <method 'factored_order' of
'sage.rings.finite_rings.finite_field_base.FiniteField' objects>
```



---

archive/issue_comments_234356.json:
```json
{
    "body": "sorry already in [comment:27 comment:27]... could you update the description then?",
    "created_at": "2015-04-24T21:59:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234356",
    "user": "https://github.com/videlec"
}
```

sorry already in [comment:27 comment:27]... could you update the description then?



---

archive/issue_comments_234357.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-04-24T21:59:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234357",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_234358.json:
```json
{
    "body": "Replying to [comment:66 vdelecroix]:\n> On 6.7-beta2 I got \n> \n> ```\n> sage: K=GF(5)\n> sage: K.factored_order\n> Cached version of <method 'factored_order' of\n> 'sage.rings.finite_rings.finite_field_base.FiniteField' objects>\n> ```\n\n\nYou mean, you got it after removing `src/sage/rings/finite_rings/finite_field_base.pyx`? Then you say the problem is fixed.",
    "created_at": "2015-04-24T22:17:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234358",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:66 vdelecroix]:
> On 6.7-beta2 I got 
> 
> ```
> sage: K=GF(5)
> sage: K.factored_order
> Cached version of <method 'factored_order' of
> 'sage.rings.finite_rings.finite_field_base.FiniteField' objects>
> ```


You mean, you got it after removing `src/sage/rings/finite_rings/finite_field_base.pyx`? Then you say the problem is fixed.



---

archive/issue_comments_234359.json:
```json
{
    "body": "Replying to [comment:67 vdelecroix]:\n> sorry already in [comment:27 comment:27]... could you update the description then?\n\n\nI don't understand what info you need.",
    "created_at": "2015-04-24T22:17:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234359",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:67 vdelecroix]:
> sorry already in [comment:27 comment:27]... could you update the description then?


I don't understand what info you need.



---

archive/issue_comments_234360.json:
```json
{
    "body": "Replying to [comment:68 SimonKing]:\n> Replying to [comment:66 vdelecroix]:\n> > On 6.7-beta2 I got \n> > \n> > ```\n> > sage: K=GF(5)\n> > sage: K.factored_order\n> > Cached version of <method 'factored_order' of\n> > 'sage.rings.finite_rings.finite_field_base.FiniteField' objects>\n> > ```\n\n> \n> You mean, you got it after removing `src/sage/rings/finite_rings/finite_field_base.pyx`? Then you say the problem is fixed.\n\n\nNope. Just starting from a fresh sage-6.7.beta2.",
    "created_at": "2015-04-24T22:19:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234360",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:68 SimonKing]:
> Replying to [comment:66 vdelecroix]:
> > On 6.7-beta2 I got 
> > 
> > ```
> > sage: K=GF(5)
> > sage: K.factored_order
> > Cached version of <method 'factored_order' of
> > 'sage.rings.finite_rings.finite_field_base.FiniteField' objects>
> > ```

> 
> You mean, you got it after removing `src/sage/rings/finite_rings/finite_field_base.pyx`? Then you say the problem is fixed.


Nope. Just starting from a fresh sage-6.7.beta2.



---

archive/issue_comments_234361.json:
```json
{
    "body": "Replying to [comment:70 vdelecroix]:\n> Replying to [comment:68 SimonKing]:\n> > Replying to [comment:66 vdelecroix]:\n> > > On 6.7-beta2 I got \n> > > \n> > > ```\n> > > sage: K=GF(5)\n> > > sage: K.factored_order\n> > > Cached version of <method 'factored_order' of\n> > > 'sage.rings.finite_rings.finite_field_base.FiniteField' objects>\n> > > ```\n\n> > \n> > You mean, you got it after removing `src/sage/rings/finite_rings/finite_field_base.pyx`? Then you say the problem is fixed.\n\n> \n> Nope. Just starting from a fresh sage-6.7.beta2.\n\n\nMy mistake... I read too fast!!",
    "created_at": "2015-04-24T22:20:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234361",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:70 vdelecroix]:
> Replying to [comment:68 SimonKing]:
> > Replying to [comment:66 vdelecroix]:
> > > On 6.7-beta2 I got 
> > > 
> > > ```
> > > sage: K=GF(5)
> > > sage: K.factored_order
> > > Cached version of <method 'factored_order' of
> > > 'sage.rings.finite_rings.finite_field_base.FiniteField' objects>
> > > ```

> > 
> > You mean, you got it after removing `src/sage/rings/finite_rings/finite_field_base.pyx`? Then you say the problem is fixed.

> 
> Nope. Just starting from a fresh sage-6.7.beta2.


My mistake... I read too fast!!



---

archive/issue_comments_234362.json:
```json
{
    "body": "I still don't see what info was requested. Hence, I change it back to \"needs review\".",
    "created_at": "2015-04-28T13:45:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234362",
    "user": "https://github.com/simon-king-jena"
}
```

I still don't see what info was requested. Hence, I change it back to "needs review".



---

archive/issue_comments_234363.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2015-04-28T13:45:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234363",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_234364.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-04-29T01:03:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234364",
    "user": "https://github.com/vbraun"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_050858.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-04-29T03:13:49Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17814#event-50858"
}
```



---

archive/issue_comments_234365.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-04-29T03:13:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17814#issuecomment-234365",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
