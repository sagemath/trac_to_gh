# Issue 17958: implement declare_var, deprecate (None)var

archive/issues_017721.json:
```json
{
    "body": "Functions returning a value should not have side effects, `var` does. In #17447, comment 23 Nils Bruin proposed to separate both usages of `var` by introducing `declare_var`: this should behave exactly like `var` without return value, and `var` should not put the var handle in the `globals` list but should act like `SR.var`. If we want the following behaviour:\n1. `declare_var('x')` == `var('x')` as before but returning `None`\n2. `var('x')` prints deprecation message, returns variable as before; error after deprecation period\n3. `y = var('x')` as before (but without globals), NO deprecation message\nwe certainly need the preparser to recognize 2/3, and to replace (2) with `declare_var('x'); deprecation(...); x` and (3) with `y = SR.var('x')`. Secondly, there is a different docstring needed with `var` when compared with `declare_var`.\n\nThis and the same with functions is the most annoying problem for people doing calculus in Sage.\n\n* http://ask.sagemath.org/question/8145/difference-between-varx-and-xvarx/\n\n**CC:**  @nbruin @kcrisman\n\n**Status:** new\n\nIssue created by migration from https://trac.sagemath.org/ticket/17958\n\n",
    "created_at": "2015-03-14T15:48:07Z",
    "labels": [
        "component: symbolics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.6",
    "title": "implement declare_var, deprecate (None)var",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17958",
    "user": "https://github.com/rwst"
}
```
Functions returning a value should not have side effects, `var` does. In #17447, comment 23 Nils Bruin proposed to separate both usages of `var` by introducing `declare_var`: this should behave exactly like `var` without return value, and `var` should not put the var handle in the `globals` list but should act like `SR.var`. If we want the following behaviour:
1. `declare_var('x')` == `var('x')` as before but returning `None`
2. `var('x')` prints deprecation message, returns variable as before; error after deprecation period
3. `y = var('x')` as before (but without globals), NO deprecation message
we certainly need the preparser to recognize 2/3, and to replace (2) with `declare_var('x'); deprecation(...); x` and (3) with `y = SR.var('x')`. Secondly, there is a different docstring needed with `var` when compared with `declare_var`.

This and the same with functions is the most annoying problem for people doing calculus in Sage.

* http://ask.sagemath.org/question/8145/difference-between-varx-and-xvarx/

**CC:**  @nbruin @kcrisman

**Status:** new

Issue created by migration from https://trac.sagemath.org/ticket/17958





---

archive/issue_events_058343.json:
```json
{
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "rename": {
        "from": "implement declare_var",
        "to": "implement declare_var, deprecate (None)var"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17958#event-58343"
}
```



---

archive/issue_comments_295309.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,17 +1,12 @@\n-Functions returning a value should not have side effects, `var` does. In #17447, comment 23 Nils Bruin proposed to separate both usages of `var` by introducing `declare_var`: this should behave exactly like `var` without return value, i.e.\n-\n-```\n-sage: var('y')\n-y\n-sage: declare_var('y')\n-y\n-sage: y = declare_var('y')\n-sage: y\n-sage: type(y)\n-<type 'NoneType'>\n-```\n-Later, after all books are changed, `var` without return value should be phased out.\n+Functions returning a value should not have side effects, `var` does. In #17447, comment 23 Nils Bruin proposed to separate both usages of `var` by introducing `declare_var`: this should behave exactly like `var` without return value, and `var` should not put the var handle in the `globals` list but should act like `SR.var`. If we want the following behaviour:\n+1. `declare_var('x')` == `var('x')` as before but returning `None`\n+2. `var('x')` prints deprecation message, returns variable as before; error after deprecation period\n+3. `y = var('x')` as before (but without globals), NO deprecation message\n+we certainly need the preparser to recognize 2/3, and to replace (2) with `declare_var('x'); deprecation(...); x` and (3) with `y = SR.var('x')`. Secondly, there is a different docstring needed with `var` when compared with `declare_var`.\n \n This and the same with functions is the most annoying problem for people doing calculus in Sage.\n \n * http://ask.sagemath.org/question/8145/difference-between-varx-and-xvarx/\n+\n+Also #6559 deprecated the `ns` keyword 5 years ago, let's remove it from `var()`.\n+\n``````\n",
    "created_at": "2015-03-16T09:48:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295309",
    "user": "https://github.com/rwst"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,17 +1,12 @@
-Functions returning a value should not have side effects, `var` does. In #17447, comment 23 Nils Bruin proposed to separate both usages of `var` by introducing `declare_var`: this should behave exactly like `var` without return value, i.e.
-
-```
-sage: var('y')
-y
-sage: declare_var('y')
-y
-sage: y = declare_var('y')
-sage: y
-sage: type(y)
-<type 'NoneType'>
-```
-Later, after all books are changed, `var` without return value should be phased out.
+Functions returning a value should not have side effects, `var` does. In #17447, comment 23 Nils Bruin proposed to separate both usages of `var` by introducing `declare_var`: this should behave exactly like `var` without return value, and `var` should not put the var handle in the `globals` list but should act like `SR.var`. If we want the following behaviour:
+1. `declare_var('x')` == `var('x')` as before but returning `None`
+2. `var('x')` prints deprecation message, returns variable as before; error after deprecation period
+3. `y = var('x')` as before (but without globals), NO deprecation message
+we certainly need the preparser to recognize 2/3, and to replace (2) with `declare_var('x'); deprecation(...); x` and (3) with `y = SR.var('x')`. Secondly, there is a different docstring needed with `var` when compared with `declare_var`.
 
 This and the same with functions is the most annoying problem for people doing calculus in Sage.
 
 * http://ask.sagemath.org/question/8145/difference-between-varx-and-xvarx/
+
+Also #6559 deprecated the `ns` keyword 5 years ago, let's remove it from `var()`.
+
``````




---

archive/issue_comments_295310.json:
```json
{
    "body": "<a id='comment:3'></a>\nDoes sage really need a version of `var()` that touches the global namespace? Other similar functions like `polygen()` and `*.gen()` don't do it, except for a handful of constructors after `inject_on()`\u2014which I doubt anyone uses. And `y = var('y')` is clearer and shorter than `declare_var('y')`, though it would be nice if `y = var()` (or perhaps `<y> = var()`?) was preparsed to `y = SR.var('y')`.",
    "created_at": "2015-03-16T09:56:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295310",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:3'></a>
Does sage really need a version of `var()` that touches the global namespace? Other similar functions like `polygen()` and `*.gen()` don't do it, except for a handful of constructors after `inject_on()`—which I doubt anyone uses. And `y = var('y')` is clearer and shorter than `declare_var('y')`, though it would be nice if `y = var()` (or perhaps `<y> = var()`?) was preparsed to `y = SR.var('y')`.



---

archive/issue_comments_295311.json:
```json
{
    "body": "<a id='comment:4'></a>\nNot really need but:\n\n```\nsage -t src/sage/symbolic/expression.pyx  # 424 doctests failed\nsage -t src/sage/symbolic/assumptions.py  # 51 doctests failed\nsage -t src/sage/symbolic/callable.py  # 48 doctests failed\nsage -t src/sage/calculus/riemann.pyx  # 126 doctests failed\nsage -t src/sage/calculus/calculus.py  # 81 doctests failed\nsage -t src/sage/calculus/tests.py  # 29 doctests failed\nsage -t src/sage/calculus/wester.py  # 29 doctests failed\nsage -t src/doc/en/prep/Advanced-2DPlotting.rst  # 24 doctests failed\nsage -t src/doc/en/prep/Quickstarts/Multivariable-Calculus.rst  # 38 doctests failed\nsage -t src/doc/de/thematische_anleitungen/sage_gymnasium.rst  # 31 doctests failed\nsage -t src/sage/functions/piecewise.py  # 25 doctests failed\n```\nThat's those over 20 in `symbolic`,`calculus`,`doc`,`functions`.\n\nEDIT: grep for 'sage: var(' shows 338 hits in 67 files...",
    "created_at": "2015-03-16T10:08:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295311",
    "user": "https://github.com/rwst"
}
```

<a id='comment:4'></a>
Not really need but:

```
sage -t src/sage/symbolic/expression.pyx  # 424 doctests failed
sage -t src/sage/symbolic/assumptions.py  # 51 doctests failed
sage -t src/sage/symbolic/callable.py  # 48 doctests failed
sage -t src/sage/calculus/riemann.pyx  # 126 doctests failed
sage -t src/sage/calculus/calculus.py  # 81 doctests failed
sage -t src/sage/calculus/tests.py  # 29 doctests failed
sage -t src/sage/calculus/wester.py  # 29 doctests failed
sage -t src/doc/en/prep/Advanced-2DPlotting.rst  # 24 doctests failed
sage -t src/doc/en/prep/Quickstarts/Multivariable-Calculus.rst  # 38 doctests failed
sage -t src/doc/de/thematische_anleitungen/sage_gymnasium.rst  # 31 doctests failed
sage -t src/sage/functions/piecewise.py  # 25 doctests failed
```
That's those over 20 in `symbolic`,`calculus`,`doc`,`functions`.

EDIT: grep for 'sage: var(' shows 338 hits in 67 files...



---

archive/issue_comments_295312.json:
```json
{
    "body": "<a id='comment:5'></a>\nI should have looked sooner: the catch is, I removed the `globals` injection in `calculus/var.pyx:var()` and the variables get still injected. And indeed the same with `SR.var()`, so that has side effects too and is no cure for the matter.\n\nEDIT: Noo, that's wrong, it's the expression on the lhs that gets injected!\n\nI still have to find a case where injection of the variable itself matters.",
    "created_at": "2015-03-17T17:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295312",
    "user": "https://github.com/rwst"
}
```

<a id='comment:5'></a>
I should have looked sooner: the catch is, I removed the `globals` injection in `calculus/var.pyx:var()` and the variables get still injected. And indeed the same with `SR.var()`, so that has side effects too and is no cure for the matter.

EDIT: Noo, that's wrong, it's the expression on the lhs that gets injected!

I still have to find a case where injection of the variable itself matters.



---

archive/issue_comments_295313.json:
```json
{
    "body": "<a id='comment:6'></a>\nI think I don't understand what you mean:\n\n```\nsage: SR.var('xyz')\nxyz\nsage: xyz\n...\nNameError: name 'xyz' is not defined\n```",
    "created_at": "2015-03-17T17:40:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295313",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:6'></a>
I think I don't understand what you mean:

```
sage: SR.var('xyz')
xyz
sage: xyz
...
NameError: name 'xyz' is not defined
```



---

archive/issue_comments_295314.json:
```json
{
    "body": "<a id='comment:7'></a>\n> I still have to find a case where injection of the variable itself matters.\n\nSorry, I should say... where injection via `globals` in the `var` function makes a difference versus `ex = SR.var(...)`, where presumably `globals` is filled by iPython with the `ex`.",
    "created_at": "2015-03-18T06:31:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295314",
    "user": "https://github.com/rwst"
}
```

<a id='comment:7'></a>
> I still have to find a case where injection of the variable itself matters.

Sorry, I should say... where injection via `globals` in the `var` function makes a difference versus `ex = SR.var(...)`, where presumably `globals` is filled by iPython with the `ex`.



---

archive/issue_comments_295315.json:
```json
{
    "body": "<a id='comment:8'></a>\nThe name `var` by itself makes a lot of confusion. There are Python variables which are a very different concept. What about calling it `symbol` or `Symbol` as it is done in [sympy](http://www.sympy.org/en/index.html)?\n\nVincent",
    "created_at": "2015-03-26T08:05:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295315",
    "user": "https://github.com/videlec"
}
```

<a id='comment:8'></a>
The name `var` by itself makes a lot of confusion. There are Python variables which are a very different concept. What about calling it `symbol` or `Symbol` as it is done in [sympy](http://www.sympy.org/en/index.html)?

Vincent



---

archive/issue_comments_295316.json:
```json
{
    "body": "<a id='comment:9'></a>\nReplying to [vdelecroix](#comment%3A8):\n> The name `var` by itself makes a lot of confusion. There are Python variables which are a very different concept. What about calling it `symbol` or `Symbol` as it is done in [sympy](http://www.sympy.org/en/index.html)?\n\n\n+1\n\nEric.",
    "created_at": "2015-03-26T10:14:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295316",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:9'></a>
Replying to [vdelecroix](#comment%3A8):
> The name `var` by itself makes a lot of confusion. There are Python variables which are a very different concept. What about calling it `symbol` or `Symbol` as it is done in [sympy](http://www.sympy.org/en/index.html)?


+1

Eric.



---

archive/issue_comments_295317.json:
```json
{
    "body": "<a id='comment:10'></a>\nReplying to [egourgoulhon](#comment%3A9):\n> Replying to [vdelecroix](#comment%3A8):\n> > The name `var` by itself makes a lot of confusion. There are Python variables which are a very different concept. What about calling it `symbol` or `Symbol` as it is done in [sympy](http://www.sympy.org/en/index.html)?\n\n> \n> +1\n> \n> Eric.\n\n\n+1 as well, the name \"variable\" causes a lot of troubles to newcommers that use `var()` to declare Python names, see for example [this list of ask questions](http://ask.sagemath.org/questions/scope:all/sort:activity-desc/tags:variable_issue/page:1/). Instead of a generic \"variable\", we should use \"symbol\" for SR, \"name\" (for Python), \"indeterminate\" for polynomials. This will help learning Sage a lot.\n\nBy the way, note the difference between \n\n```\nsage: SR.var('x,y')\n(x, y)\n```\n\nand\n\n```\nsage: SR.symbol('x,y')\nx,y\nsage: SR.symbol('x y')\nx y\n```\n\nSo perhaps should we also make a difference between `Symbol` and `Symbols` ?",
    "created_at": "2015-03-26T10:57:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295317",
    "user": "https://trac.sagemath.org/admin/accounts/users/tmonteil"
}
```

<a id='comment:10'></a>
Replying to [egourgoulhon](#comment%3A9):
> Replying to [vdelecroix](#comment%3A8):
> > The name `var` by itself makes a lot of confusion. There are Python variables which are a very different concept. What about calling it `symbol` or `Symbol` as it is done in [sympy](http://www.sympy.org/en/index.html)?

> 
> +1
> 
> Eric.


+1 as well, the name "variable" causes a lot of troubles to newcommers that use `var()` to declare Python names, see for example [this list of ask questions](http://ask.sagemath.org/questions/scope:all/sort:activity-desc/tags:variable_issue/page:1/). Instead of a generic "variable", we should use "symbol" for SR, "name" (for Python), "indeterminate" for polynomials. This will help learning Sage a lot.

By the way, note the difference between 

```
sage: SR.var('x,y')
(x, y)
```

and

```
sage: SR.symbol('x,y')
x,y
sage: SR.symbol('x y')
x y
```

So perhaps should we also make a difference between `Symbol` and `Symbols` ?



---

archive/issue_comments_295318.json:
```json
{
    "body": "<a id='comment:11'></a>\n`SR.var` does exactly what the `declare_var` does without the drawbacks of an additional global, so as it stands I'm against the ticket description.\n\n`SR.symbol` and `SR.var` should probably be aliases but aren't. I wasn't even aware of `SR.symbol`, which is why I only fixed the comma parsing in `SR.var` in #7496.\n\nHow about something like `R.<x> = SR()` to get symbolic generators?",
    "created_at": "2015-03-26T12:34:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295318",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:11'></a>
`SR.var` does exactly what the `declare_var` does without the drawbacks of an additional global, so as it stands I'm against the ticket description.

`SR.symbol` and `SR.var` should probably be aliases but aren't. I wasn't even aware of `SR.symbol`, which is why I only fixed the comma parsing in `SR.var` in #7496.

How about something like `R.<x> = SR()` to get symbolic generators?



---

archive/issue_comments_295319.json:
```json
{
    "body": "<a id='comment:12'></a>\nReplying to [vbraun](#comment%3A11):\n> How about something like `R.<x> = SR()` to get symbolic generators?\n\n\nYes, that's probably better that the syntax I suggested.",
    "created_at": "2015-03-26T12:55:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295319",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:12'></a>
Replying to [vbraun](#comment%3A11):
> How about something like `R.<x> = SR()` to get symbolic generators?


Yes, that's probably better that the syntax I suggested.



---

archive/issue_comments_295320.json:
```json
{
    "body": "<a id='comment:13'></a>\nReplying to [vdelecroix](#comment%3A8):\n> The name `var` by itself makes a lot of confusion. There are Python variables which are a very different concept. What about calling it `symbol` or `Symbol` as it is done in [sympy](http://www.sympy.org/en/index.html)?\n\n\nDefinitely not `Symbol()`. As for `symbol()`, it could have been a better name choice than `var()`, but I doubt switching to it now is a good idea. The benefits are not that significant, and since `var()` is proabably one of the most widely used functions outside the sage tree itself (in particular, in random code snippets), the compatibility break would be a pain for many of people (the recent deprecation of `pol.coeffs()` already was pretty bad from this point of view).",
    "created_at": "2015-03-26T13:02:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295320",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:13'></a>
Replying to [vdelecroix](#comment%3A8):
> The name `var` by itself makes a lot of confusion. There are Python variables which are a very different concept. What about calling it `symbol` or `Symbol` as it is done in [sympy](http://www.sympy.org/en/index.html)?


Definitely not `Symbol()`. As for `symbol()`, it could have been a better name choice than `var()`, but I doubt switching to it now is a good idea. The benefits are not that significant, and since `var()` is proabably one of the most widely used functions outside the sage tree itself (in particular, in random code snippets), the compatibility break would be a pain for many of people (the recent deprecation of `pol.coeffs()` already was pretty bad from this point of view).



---

archive/issue_comments_295321.json:
```json
{
    "body": "<a id='comment:14'></a>\nReplying to [vbraun](#comment%3A11):\n> `SR.symbol` and `SR.var` should probably be aliases but aren't. I wasn't even aware of `SR.symbol`, which is why I only fixed the comma parsing in `SR.var` in #7496.\n\n\nActually `SR.var` is a wrapper over `SR.symbol` that splits commas and spaces to create tuples of symbols.\n\n> How about something like `R.<x> = SR()` to get symbolic generators?\n\n\nThis is non-pythonic, requires additional preparsing, needs to create the name `R` while the ring `SR` is already here, and will add even more confusion to newcomers that hardly understand the difference between a symbolic expression like `x^2+1` and a well defined polynomial over a well defined ring.\n\nReplying to [mmezzarobba](#comment%3A13):\n> Definitely not `Symbol()`. As for `symbol()`, it could have been a better name choice than `var()`, but I doubt switching to it now is a good idea. The benefits are not that significant, and since `var()` is proabably one of the most widely used functions outside the sage tree itself (in particular, in random code snippets), the compatibility break would be a pain for many of people (the recent deprecation of `pol.coeffs()` already was pretty bad from this point of view).\n\n\nThe benefits are very significant for newcomers and anyone that interacts with newcomers, i personally spent a huge amount of time to deal with that issue (on ask.sagemath.org (see my previous link for a small sample) but also during tutorials).\n\nSage is full of inconsistencies, refusing to clean them because they are used increases the entry cost and will eventually lead to an obscure language where each function/method has its own semantics. This is not long-term viable. This is why we have a deprecation policy. For such a function, we could make the deprecation message more verbose and pedagogical than usual.",
    "created_at": "2015-03-26T14:13:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295321",
    "user": "https://trac.sagemath.org/admin/accounts/users/tmonteil"
}
```

<a id='comment:14'></a>
Replying to [vbraun](#comment%3A11):
> `SR.symbol` and `SR.var` should probably be aliases but aren't. I wasn't even aware of `SR.symbol`, which is why I only fixed the comma parsing in `SR.var` in #7496.


Actually `SR.var` is a wrapper over `SR.symbol` that splits commas and spaces to create tuples of symbols.

> How about something like `R.<x> = SR()` to get symbolic generators?


This is non-pythonic, requires additional preparsing, needs to create the name `R` while the ring `SR` is already here, and will add even more confusion to newcomers that hardly understand the difference between a symbolic expression like `x^2+1` and a well defined polynomial over a well defined ring.

Replying to [mmezzarobba](#comment%3A13):
> Definitely not `Symbol()`. As for `symbol()`, it could have been a better name choice than `var()`, but I doubt switching to it now is a good idea. The benefits are not that significant, and since `var()` is proabably one of the most widely used functions outside the sage tree itself (in particular, in random code snippets), the compatibility break would be a pain for many of people (the recent deprecation of `pol.coeffs()` already was pretty bad from this point of view).


The benefits are very significant for newcomers and anyone that interacts with newcomers, i personally spent a huge amount of time to deal with that issue (on ask.sagemath.org (see my previous link for a small sample) but also during tutorials).

Sage is full of inconsistencies, refusing to clean them because they are used increases the entry cost and will eventually lead to an obscure language where each function/method has its own semantics. This is not long-term viable. This is why we have a deprecation policy. For such a function, we could make the deprecation message more verbose and pedagogical than usual.



---

archive/issue_comments_295322.json:
```json
{
    "body": "<a id='comment:15'></a>\nThierry, I agree fully but:\n> > How about something like `R.<x> = SR()` to get symbolic generators?\n\n> \n> This is non-pythonic, requires additional preparsing, needs to create the name `R` while the ring `SR` is already here, and will add even more confusion to newcomers that hardly understand the difference between a symbolic expression like `x^2+1` and a well defined polynomial over a well defined ring.\n\n\nBut it would be consistent and allow different ring types (later). Actually `declare_var` could be provided additionally.",
    "created_at": "2015-03-26T14:37:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295322",
    "user": "https://github.com/rwst"
}
```

<a id='comment:15'></a>
Thierry, I agree fully but:
> > How about something like `R.<x> = SR()` to get symbolic generators?

> 
> This is non-pythonic, requires additional preparsing, needs to create the name `R` while the ring `SR` is already here, and will add even more confusion to newcomers that hardly understand the difference between a symbolic expression like `x^2+1` and a well defined polynomial over a well defined ring.


But it would be consistent and allow different ring types (later). Actually `declare_var` could be provided additionally.



---

archive/issue_comments_295323.json:
```json
{
    "body": "<a id='comment:16'></a>\nReplying to [tmonteil](#comment%3A14):\n> This is non-pythonic, requires additional preparsing, needs to create the name `R` while the ring `SR` is already here, and will add even more confusion to newcomers that hardly understand the difference between a symbolic expression like `x^2+1` and a well defined polynomial over a well defined ring.\n\n\nI don't care much about \"pythonicity\", but what Volker suggests would be consistent with the rest of Sage. And since this is all for interactive use anyway, I don't see the problem with using the preparser, nor with writing `_.<x> = SR()`.\n\nFrom a pedagogical point of view, it might actually be a good thing to make it clearer that `var()` (or, to be precise, `symbol()`) is more or less the same as `gen()`, only for `SR`.\n\n> Sage is full of inconsistencies, refusing to clean them because they are used increases the entry cost and will eventually lead to an obscure language where each function/method has its own semantics. This is not long-term viable.\n\n\nI tend to agree in general, but I am not convinced in this particular case. Having a longer function name is inconvenient, and I find `symbol()` only marginally clearer (if at all) than `SR.var()`. (I'm fine with either removing `var()` entirely or making it equivalent to `SR.var()`, however.)\n\n> This is why we have a deprecation policy.\n\n\nThe deprecation policy is a joke... Except perhaps for a few `_`-functions, just about anything in sage can be considered public, but only few changes are considered worth a deprecation.\n\n> For such a function, we could make the deprecation message more verbose and pedagogical than usual.\n\n\nYes, but please keep in mind that it will pop up everywhere for a long time.",
    "created_at": "2015-03-26T15:10:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295323",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:16'></a>
Replying to [tmonteil](#comment%3A14):
> This is non-pythonic, requires additional preparsing, needs to create the name `R` while the ring `SR` is already here, and will add even more confusion to newcomers that hardly understand the difference between a symbolic expression like `x^2+1` and a well defined polynomial over a well defined ring.


I don't care much about "pythonicity", but what Volker suggests would be consistent with the rest of Sage. And since this is all for interactive use anyway, I don't see the problem with using the preparser, nor with writing `_.<x> = SR()`.

From a pedagogical point of view, it might actually be a good thing to make it clearer that `var()` (or, to be precise, `symbol()`) is more or less the same as `gen()`, only for `SR`.

> Sage is full of inconsistencies, refusing to clean them because they are used increases the entry cost and will eventually lead to an obscure language where each function/method has its own semantics. This is not long-term viable.


I tend to agree in general, but I am not convinced in this particular case. Having a longer function name is inconvenient, and I find `symbol()` only marginally clearer (if at all) than `SR.var()`. (I'm fine with either removing `var()` entirely or making it equivalent to `SR.var()`, however.)

> This is why we have a deprecation policy.


The deprecation policy is a joke... Except perhaps for a few `_`-functions, just about anything in sage can be considered public, but only few changes are considered worth a deprecation.

> For such a function, we could make the deprecation message more verbose and pedagogical than usual.


Yes, but please keep in mind that it will pop up everywhere for a long time.



---

archive/issue_comments_295324.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [vbraun](#comment%3A11):\n> `SR.var` does exactly what the `declare_var`\n\n\nNo, it does not:\n\n- `SR.var` a symbol and *does not* inject anything.\n- `var` (toplevel) as it exists now returns a symbol *and* injects a binding to it\n- `declare_var` as proposed would inject a binding to a symbol and return `None`.\n\nThe problem with the mixed actions of `var` is that people learn it, see it returns a symbol, and then use it in circumstances where they need a symbol returned. That works, but behind the scenes there is *also* a binding injected. That then surprises them later.\n\nIf we have two routines, one that *only* returns a symbol and the other that *only* injects a binding, this potential for surprise is eliminated.\n\nI think we do want the possibility of injecting something, because `x=var('x')` or `x=SR.var('x')` is too verbose (and more importantly, requires the `x` to by typed twice).\n\nWe need the injection capability on toplevel because this is one of the first things that novices need to be able to do. I'm not completely sure we need an entry to `SR.var` in the global namespace. However, the capability has been there as part of `var` (with sometimes surprising side-effects) so I think we pretty much have to continue it.\n\n> `SR.symbol` and `SR.var` should probably be aliases but aren't. I wasn't even aware of `SR.symbol`, which is why I only fixed the comma parsing in `SR.var` in #7496.\n\n\nThey probably shouldn't. At least one of them should be 'make a symbol with the given print name or raise an error'. The fact that the return type of `var` depends on the formatting of the string (either a symbol or a tuple of symbols) is a wart that stems from convenience for the injection purpose.\n\n> How about something like `R.<x> = SR()` to get symbolic generators?\n\n\nCute, but I think it misses the mark for the intended audience: complete novices. It makes it very hard to convince people that Sage is a reasonable choice relative to Maple and Mathematica (and Maxima), where you can just start using a symbol.",
    "created_at": "2015-03-26T15:22:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295324",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:17'></a>
Replying to [vbraun](#comment%3A11):
> `SR.var` does exactly what the `declare_var`


No, it does not:

- `SR.var` a symbol and *does not* inject anything.
- `var` (toplevel) as it exists now returns a symbol *and* injects a binding to it
- `declare_var` as proposed would inject a binding to a symbol and return `None`.

The problem with the mixed actions of `var` is that people learn it, see it returns a symbol, and then use it in circumstances where they need a symbol returned. That works, but behind the scenes there is *also* a binding injected. That then surprises them later.

If we have two routines, one that *only* returns a symbol and the other that *only* injects a binding, this potential for surprise is eliminated.

I think we do want the possibility of injecting something, because `x=var('x')` or `x=SR.var('x')` is too verbose (and more importantly, requires the `x` to by typed twice).

We need the injection capability on toplevel because this is one of the first things that novices need to be able to do. I'm not completely sure we need an entry to `SR.var` in the global namespace. However, the capability has been there as part of `var` (with sometimes surprising side-effects) so I think we pretty much have to continue it.

> `SR.symbol` and `SR.var` should probably be aliases but aren't. I wasn't even aware of `SR.symbol`, which is why I only fixed the comma parsing in `SR.var` in #7496.


They probably shouldn't. At least one of them should be 'make a symbol with the given print name or raise an error'. The fact that the return type of `var` depends on the formatting of the string (either a symbol or a tuple of symbols) is a wart that stems from convenience for the injection purpose.

> How about something like `R.<x> = SR()` to get symbolic generators?


Cute, but I think it misses the mark for the intended audience: complete novices. It makes it very hard to convince people that Sage is a reasonable choice relative to Maple and Mathematica (and Maxima), where you can just start using a symbol.



---

archive/issue_comments_295325.json:
```json
{
    "body": "<a id='comment:18'></a>\nReplying to [mmezzarobba](#comment%3A16):\n> I don't care much about \"pythonicity\", but what Volker suggests would be consistent with the rest of Sage. And since this is all for interactive use anyway, I don't see the problem with using the preparser, nor with writing `_.<x> = SR()`.\n> \n> From a pedagogical point of view, it might actually be a good thing to make it clearer that `var()` (or, to be precise, `symbol()`) is more or less the same as `gen()`, only for `SR`.\n\n\nIt is *not* consistent with the rest of sage and hard to implement, since presently it amounts to\n`_ = SR(names=('x',)); (x,) = _._first_ngens(1)`\nNormally, calling a constructor with different names gives different results:\n\n```\nsage: PolynomialRing(QQ,names=('x',)) == PolynomialRing(QQ,names=('y',))\nFalse\n```\nand we would need to hack `SR._first_ngens` to remember the last set of generators that got returned.\n\nThe scenario really doesn't fit in the current meaning of `_.<..>=...`, neither in implementation nor in semantics.",
    "created_at": "2015-03-26T15:57:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295325",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:18'></a>
Replying to [mmezzarobba](#comment%3A16):
> I don't care much about "pythonicity", but what Volker suggests would be consistent with the rest of Sage. And since this is all for interactive use anyway, I don't see the problem with using the preparser, nor with writing `_.<x> = SR()`.
> 
> From a pedagogical point of view, it might actually be a good thing to make it clearer that `var()` (or, to be precise, `symbol()`) is more or less the same as `gen()`, only for `SR`.


It is *not* consistent with the rest of sage and hard to implement, since presently it amounts to
`_ = SR(names=('x',)); (x,) = _._first_ngens(1)`
Normally, calling a constructor with different names gives different results:

```
sage: PolynomialRing(QQ,names=('x',)) == PolynomialRing(QQ,names=('y',))
False
```
and we would need to hack `SR._first_ngens` to remember the last set of generators that got returned.

The scenario really doesn't fit in the current meaning of `_.<..>=...`, neither in implementation nor in semantics.



---

archive/issue_comments_295326.json:
```json
{
    "body": "<a id='comment:19'></a>\nReplying to [nbruin](#comment%3A18):\n> It is *not* consistent with the rest of sage and hard to implement, since presently it amounts to\n> `_ = SR(names=('x',)); (x,) = _._first_ngens(1)`\n> Normally, calling a constructor with different names gives different results:\n> \n> ```\n> sage: PolynomialRing(QQ,names=('x',)) == PolynomialRing(QQ,names=('y',))\n> False\n> ```\n> and we would need to hack `SR._first_ngens` to remember the last set of generators that got returned.\n\n\nI mean from a UI point of view. Otherwise, sure, it would require the preparser to repeat the names when asking for the generators, or something similar.\n\nIs there another variant that you like better?",
    "created_at": "2015-03-26T16:37:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295326",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:19'></a>
Replying to [nbruin](#comment%3A18):
> It is *not* consistent with the rest of sage and hard to implement, since presently it amounts to
> `_ = SR(names=('x',)); (x,) = _._first_ngens(1)`
> Normally, calling a constructor with different names gives different results:
> 
> ```
> sage: PolynomialRing(QQ,names=('x',)) == PolynomialRing(QQ,names=('y',))
> False
> ```
> and we would need to hack `SR._first_ngens` to remember the last set of generators that got returned.


I mean from a UI point of view. Otherwise, sure, it would require the preparser to repeat the names when asking for the generators, or something similar.

Is there another variant that you like better?



---

archive/issue_comments_295327.json:
```json
{
    "body": "<a id='comment:20'></a>\nRemember that defining a new mathematical variable might be the first thing that a new Sage user will want to do, so from a UI point of view, `_.<x> = SR()` is a disaster. It looks like a meaningless string of symbols. `var('x')` or `declare_var('x')` or `symbol('x')` or similar at least have a chance to indicate some meaning when someone glances at the code/worksheet/notebook.\n\nMaybe something like `math_variable('x')` would convey what Sage is doing here, and in particular will distinguish this from Python variables.",
    "created_at": "2015-03-26T16:45:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295327",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:20'></a>
Remember that defining a new mathematical variable might be the first thing that a new Sage user will want to do, so from a UI point of view, `_.<x> = SR()` is a disaster. It looks like a meaningless string of symbols. `var('x')` or `declare_var('x')` or `symbol('x')` or similar at least have a chance to indicate some meaning when someone glances at the code/worksheet/notebook.

Maybe something like `math_variable('x')` would convey what Sage is doing here, and in particular will distinguish this from Python variables.



---

archive/issue_comments_295328.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [jhpalmieri](#comment%3A20):\n> Remember that defining a new mathematical variable might be the first thing that a new Sage user will want to do, so from a UI point of view, `_.<x> = SR()` is a disaster. It looks like a meaningless string of symbols. `var('x')` or `declare_var('x')` or `symbol('x')` or similar at least have a chance to indicate some meaning when someone glances at the code/worksheet/notebook.\n\n\nWell, then, form that point of view, I find `x = SR.var('x')` much better. It clarifies in particular (i) that you are assigning an object to a certain Python variable, and (ii) that the indeterminate you are creating belongs to a particular parent--often not the one you want if you are using sage in the first place!",
    "created_at": "2015-03-26T16:56:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295328",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:21'></a>
Replying to [jhpalmieri](#comment%3A20):
> Remember that defining a new mathematical variable might be the first thing that a new Sage user will want to do, so from a UI point of view, `_.<x> = SR()` is a disaster. It looks like a meaningless string of symbols. `var('x')` or `declare_var('x')` or `symbol('x')` or similar at least have a chance to indicate some meaning when someone glances at the code/worksheet/notebook.


Well, then, form that point of view, I find `x = SR.var('x')` much better. It clarifies in particular (i) that you are assigning an object to a certain Python variable, and (ii) that the indeterminate you are creating belongs to a particular parent--often not the one you want if you are using sage in the first place!



---

archive/issue_comments_295329.json:
```json
{
    "body": "<a id='comment:22'></a>\nRe `SR.var('x')`: \"What does SR mean?\" \"The Symbolic Ring.\" \"What's a ring?\"\n\nRemember that we have users who just want to do calculus. They don't know what a ring is. They also are not that familiar with Python, and we shouldn't use this particular situation to educate them on Python syntax. So I think we need a top-level function. The proposed `declare_var('x')`, which returns `None` but injects the variable into the global namespace, seems like the more natural behavior for novices. (We can have two functions, as Nils says, one like this and a second one which does not inject anything but returns the symbol. I would suggest advertising the first of these in the tutorial and other parts of the documentation. )\n\nThe name `declare_var` could maybe be improved because of the different uses of the word \"variable\". Something like `declare_math_var`? `declare_math_symbol`? `new_math_symbol`?",
    "created_at": "2015-03-26T17:21:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295329",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:22'></a>
Re `SR.var('x')`: "What does SR mean?" "The Symbolic Ring." "What's a ring?"

Remember that we have users who just want to do calculus. They don't know what a ring is. They also are not that familiar with Python, and we shouldn't use this particular situation to educate them on Python syntax. So I think we need a top-level function. The proposed `declare_var('x')`, which returns `None` but injects the variable into the global namespace, seems like the more natural behavior for novices. (We can have two functions, as Nils says, one like this and a second one which does not inject anything but returns the symbol. I would suggest advertising the first of these in the tutorial and other parts of the documentation. )

The name `declare_var` could maybe be improved because of the different uses of the word "variable". Something like `declare_math_var`? `declare_math_symbol`? `new_math_symbol`?



---

archive/issue_comments_295330.json:
```json
{
    "body": "<a id='comment:23'></a>\nReplying to [jhpalmieri](#comment%3A22):\n> Re `SR.var('x')`: \"What does SR mean?\" \"The Symbolic Ring.\" \"What's a ring?\"\n> \n> Remember that we have users who just want to do calculus. They don't know what a ring is. They also are not that familiar with Python, and we shouldn't use this particular situation to educate them on Python syntax. \n\n\nI doubt you can use sage (and not shoot yourself in the foot on every possible occasion) without understanding this kind of things at least a little. And for sure I've seen intelligent people with a very reasonable level in math, use sage in teaching while completely misunderstanding how basic things work... because, at first, they just wanted to do calculus, so they were led to use things like `var('x')` without understanding what they did, and basically assumed that names in sage had the same kinds of semantics as in maple.\n\n> The name `declare_var` could maybe be improved because of the different uses of the word \"variable\". Something like `declare_math_var`? `declare_math_symbol`? `new_math_symbol`?\n\n\n`declare_symbolic_variable` perhaps, if you really feel such a function is useful?",
    "created_at": "2015-03-26T17:46:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295330",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:23'></a>
Replying to [jhpalmieri](#comment%3A22):
> Re `SR.var('x')`: "What does SR mean?" "The Symbolic Ring." "What's a ring?"
> 
> Remember that we have users who just want to do calculus. They don't know what a ring is. They also are not that familiar with Python, and we shouldn't use this particular situation to educate them on Python syntax. 


I doubt you can use sage (and not shoot yourself in the foot on every possible occasion) without understanding this kind of things at least a little. And for sure I've seen intelligent people with a very reasonable level in math, use sage in teaching while completely misunderstanding how basic things work... because, at first, they just wanted to do calculus, so they were led to use things like `var('x')` without understanding what they did, and basically assumed that names in sage had the same kinds of semantics as in maple.

> The name `declare_var` could maybe be improved because of the different uses of the word "variable". Something like `declare_math_var`? `declare_math_symbol`? `new_math_symbol`?


`declare_symbolic_variable` perhaps, if you really feel such a function is useful?



---

archive/issue_comments_295331.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [mmezzarobba](#comment%3A23):\n> I doubt you can use sage (and not shoot yourself in the foot on every possible occasion) without understanding this kind of things at least a little.\n\n\nYou can do some very simple examples, such as differentiating a function, plotting one, trying to compute an antiderivative without understanding the way python names (really, python has \"names\" in its namespaces. Variables have other connotations) and SR symbols interact; sort of the level of \"wolfram alpha\". We have to give people at that level at least a way into sage, otherwise they don't even get to shoot themselves in the foot, experience that as unpleasant and then gain the motivation to learn how to avoid that in the future.\n\nThere's a reason why maple, mathematica, maxima went with their approach. We can't quite do that, but we have to make the hurdle as low as possible. I think\n\n```\nvar('x')\n```\nor\n\n```\ndeclare_var('x')\n```\nare about the best we can do. I think it's a problem they return something in addition to injecting a binding. If we need to produce feedback on the action taken, I think printing something would be preferable (it's a routine that's only meant to be used interactively anyway), so perhaps:\n\n```\nsage: declare_var('x,y')\nDeclaring x, y as symbolic variables\nsage: A=declare_var('z')\nDeclaring z as a symbolic variable\nsage: A\nNone\nsage: declare_var('w',quiet=True)\nsage:\n```\n(where the `quiet` would be the gateway to getting people to use other ways--perhaps we shouldn't provide that)\n\nI'd be completely OK with `declare_var` being spelled as `var` too. The main thing is that I think it has been shown that injecting *as well as* returning something is harmful, so I hope we can our change our interface to not do that.",
    "created_at": "2015-03-26T18:44:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295331",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:24'></a>
Replying to [mmezzarobba](#comment%3A23):
> I doubt you can use sage (and not shoot yourself in the foot on every possible occasion) without understanding this kind of things at least a little.


You can do some very simple examples, such as differentiating a function, plotting one, trying to compute an antiderivative without understanding the way python names (really, python has "names" in its namespaces. Variables have other connotations) and SR symbols interact; sort of the level of "wolfram alpha". We have to give people at that level at least a way into sage, otherwise they don't even get to shoot themselves in the foot, experience that as unpleasant and then gain the motivation to learn how to avoid that in the future.

There's a reason why maple, mathematica, maxima went with their approach. We can't quite do that, but we have to make the hurdle as low as possible. I think

```
var('x')
```
or

```
declare_var('x')
```
are about the best we can do. I think it's a problem they return something in addition to injecting a binding. If we need to produce feedback on the action taken, I think printing something would be preferable (it's a routine that's only meant to be used interactively anyway), so perhaps:

```
sage: declare_var('x,y')
Declaring x, y as symbolic variables
sage: A=declare_var('z')
Declaring z as a symbolic variable
sage: A
None
sage: declare_var('w',quiet=True)
sage:
```
(where the `quiet` would be the gateway to getting people to use other ways--perhaps we shouldn't provide that)

I'd be completely OK with `declare_var` being spelled as `var` too. The main thing is that I think it has been shown that injecting *as well as* returning something is harmful, so I hope we can our change our interface to not do that.



---

archive/issue_comments_295332.json:
```json
{
    "body": "<a id='comment:26'></a>\n`declare_var` sounds like *varibale declaration* that exists in many languages and is completely different that what is done here. There is already a lot of newcomer's code that start with\n\n```\nvar('a')\na=2\n```\n\nSo i can imagine how much more there will be with `declare_var`, since it will add confusion to programmers too.\n\nWhat is currently discussed is a function that injects a symbol into the namespace, so `inject_symbol` sounds more meaningful as it just tells what is actually done.\n\nAs for the `Symbolic Ring`, it is perhaps better not to know what a mathematical ring is, so perhaps thinking about that object as `The Lord of the Rings` is not so bad. We do not have much \"calculus\" course in France so i can not tell much about the benefits of playing with objects we are not able to define, i can just witness from what i see on ask.sagemath.org that people get more lost by lack of clear definitions than by excess (e.g. how to factor a polynomial if we do not know on which ring it is defined?).\n\nI agree that in any case, both injecting and returning is harmful (`function` does that too).",
    "created_at": "2015-03-27T17:07:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295332",
    "user": "https://trac.sagemath.org/admin/accounts/users/tmonteil"
}
```

<a id='comment:26'></a>
`declare_var` sounds like *varibale declaration* that exists in many languages and is completely different that what is done here. There is already a lot of newcomer's code that start with

```
var('a')
a=2
```

So i can imagine how much more there will be with `declare_var`, since it will add confusion to programmers too.

What is currently discussed is a function that injects a symbol into the namespace, so `inject_symbol` sounds more meaningful as it just tells what is actually done.

As for the `Symbolic Ring`, it is perhaps better not to know what a mathematical ring is, so perhaps thinking about that object as `The Lord of the Rings` is not so bad. We do not have much "calculus" course in France so i can not tell much about the benefits of playing with objects we are not able to define, i can just witness from what i see on ask.sagemath.org that people get more lost by lack of clear definitions than by excess (e.g. how to factor a polynomial if we do not know on which ring it is defined?).

I agree that in any case, both injecting and returning is harmful (`function` does that too).



---

archive/issue_comments_295333.json:
```json
{
    "body": "<a id='comment:27'></a>\nReplying to [tmonteil](#comment%3A26):\n> What is currently discussed is a function that injects a symbol into the namespace, so `inject_symbol` sounds more meaningful as it just tells what is actually done.\n\n\nExcept that \"inject\" is rather technical and not what the novice thinks about doing. You'd probably have to explain to them: \"Before using y, you have to declare that it is a math symbol, which you do by\n`declare_symbol(\"y\")`.\" \n\nI indeed agree that using \"symbol\" instead of \"symbolic variable\" would be better to distinguish the concept from a python name. However, we've been calling these things \"var\" since the start of sage, so changing that may be painful for our current users.\n\n> I agree that in any case, both injecting and returning is harmful (`function` does that too).\n\n\nThere the terminology is even worse: python actually calls its \"def\" and \"lambda\" objects \"functions\". So \"declare_function\" will be even more confusing than \"declare_var\". \n\n---\n\nA minimal plan is to either not have `var` produce side-effects, meaning\n\n```\nsage: var('z')\nz\nsage: z+1\nError\n```\nor let `var` return None, meaning\n\n```\nsage: z = var('z')\nsage: z+1\nError\n```\n\nIf neither one is palatable then we can stop the discussion now. We're stuck with a bad design decision, for which the pain for repairing it is too high.\n\n---\n\nAn alternative is to migrate to the unspoilt\n\n```\nsage: z = symbol('z')\nsage: declare_symbol('w')\nsage: z+w+1\nz+w+1\n```\nand let `var` rot and fester, trying to nudge people away from it (put a deprecation on it after a while?). In 10 years or so we could think of removing `var`.\n\n---\n\nFor `function` we can perhaps do the deprecation in-place. That's mainly going to affect people trying to solve ODEs and PDEs (outside of that, symbolic (formal/abstract) functions don't have much use)",
    "created_at": "2015-03-27T18:01:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295333",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:27'></a>
Replying to [tmonteil](#comment%3A26):
> What is currently discussed is a function that injects a symbol into the namespace, so `inject_symbol` sounds more meaningful as it just tells what is actually done.


Except that "inject" is rather technical and not what the novice thinks about doing. You'd probably have to explain to them: "Before using y, you have to declare that it is a math symbol, which you do by
`declare_symbol("y")`." 

I indeed agree that using "symbol" instead of "symbolic variable" would be better to distinguish the concept from a python name. However, we've been calling these things "var" since the start of sage, so changing that may be painful for our current users.

> I agree that in any case, both injecting and returning is harmful (`function` does that too).


There the terminology is even worse: python actually calls its "def" and "lambda" objects "functions". So "declare_function" will be even more confusing than "declare_var". 

---

A minimal plan is to either not have `var` produce side-effects, meaning

```
sage: var('z')
z
sage: z+1
Error
```
or let `var` return None, meaning

```
sage: z = var('z')
sage: z+1
Error
```

If neither one is palatable then we can stop the discussion now. We're stuck with a bad design decision, for which the pain for repairing it is too high.

---

An alternative is to migrate to the unspoilt

```
sage: z = symbol('z')
sage: declare_symbol('w')
sage: z+w+1
z+w+1
```
and let `var` rot and fester, trying to nudge people away from it (put a deprecation on it after a while?). In 10 years or so we could think of removing `var`.

---

For `function` we can perhaps do the deprecation in-place. That's mainly going to affect people trying to solve ODEs and PDEs (outside of that, symbolic (formal/abstract) functions don't have much use)



---

archive/issue_comments_295334.json:
```json
{
    "body": "<a id='comment:29'></a>\nReplying to [nbruin](#comment%3A27):\n> \n> An alternative is to migrate to the unspoilt\n> \n> ```\n> sage: z = symbol('z')\n> sage: declare_symbol('w')\n> sage: z+w+1\n> z+w+1\n> ```\n> and let `var` rot and fester, trying to nudge people away from it (put a deprecation on it after a while?). In 10 years or so we could think of removing `var`.\n> \n\nIMHO, this should be the good strategy. `declare_symbol` is a bit long however and could be replaced by simply `symbol`, while the above `symbol` could be replaced by something like `SR.get_symbol`. Indeed, the end user has hardly the need of `z = symbol('z')` (am I right ?), so replacing it by something \"sophisticated\" like `z = SR.get_symbol('z')` seems fine. To summarize, the above code would become\n\n```\n sage: z = SR.get_symbol('z')\n sage: symbol('w')  # what end users really need\n sage: z+w+1\n z+w+1\n```",
    "created_at": "2015-03-28T13:49:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295334",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:29'></a>
Replying to [nbruin](#comment%3A27):
> 
> An alternative is to migrate to the unspoilt
> 
> ```
> sage: z = symbol('z')
> sage: declare_symbol('w')
> sage: z+w+1
> z+w+1
> ```
> and let `var` rot and fester, trying to nudge people away from it (put a deprecation on it after a while?). In 10 years or so we could think of removing `var`.
> 

IMHO, this should be the good strategy. `declare_symbol` is a bit long however and could be replaced by simply `symbol`, while the above `symbol` could be replaced by something like `SR.get_symbol`. Indeed, the end user has hardly the need of `z = symbol('z')` (am I right ?), so replacing it by something "sophisticated" like `z = SR.get_symbol('z')` seems fine. To summarize, the above code would become

```
 sage: z = SR.get_symbol('z')
 sage: symbol('w')  # what end users really need
 sage: z+w+1
 z+w+1
```



---

archive/issue_comments_295335.json:
```json
{
    "body": "<a id='comment:30'></a>\nReplying to [egourgoulhon](#comment%3A29):\n> Indeed, the end user has hardly the need of `z = symbol('z')` (am I right ?),\n\n\nSearching our current codebase and examples indicates you might not be right in that assumption. I didn't do a precise count, but the occurrences of `a=var('a')` and `c,d=var('c,d')` are quite frequent (half of the `var` occurrences maybe?), so there's definitely an immediate need for it to do an automatic replacement.\n\nThe fact that this developed in the first place also suggests that a significant number of people were not aware of/did not trust the injecting behaviour of `var`, so it's probably \"surprising\" behaviour (it's certainly non-pythonic to go and scribble in the globals dictionary). That indicates to me that the routine doing it needs a name that makes explicit it's having a side effect. A normal way of doing that is making the name a verb or verbal phrase, hence `declare_var` or `declare_symbol`.\n\nFor obtaining a symbol as a return value a noun or nominal phrase should be OK, hence `var` or `symbol`.",
    "created_at": "2015-03-28T16:54:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295335",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:30'></a>
Replying to [egourgoulhon](#comment%3A29):
> Indeed, the end user has hardly the need of `z = symbol('z')` (am I right ?),


Searching our current codebase and examples indicates you might not be right in that assumption. I didn't do a precise count, but the occurrences of `a=var('a')` and `c,d=var('c,d')` are quite frequent (half of the `var` occurrences maybe?), so there's definitely an immediate need for it to do an automatic replacement.

The fact that this developed in the first place also suggests that a significant number of people were not aware of/did not trust the injecting behaviour of `var`, so it's probably "surprising" behaviour (it's certainly non-pythonic to go and scribble in the globals dictionary). That indicates to me that the routine doing it needs a name that makes explicit it's having a side effect. A normal way of doing that is making the name a verb or verbal phrase, hence `declare_var` or `declare_symbol`.

For obtaining a symbol as a return value a noun or nominal phrase should be OK, hence `var` or `symbol`.



---

archive/issue_comments_295336.json:
```json
{
    "body": "<a id='comment:31'></a>\n* Why not `SR.gen('x')` to create a new variable instead of `SR.symbol` / `SR.var`? Also: currently broken, so would be nice to fix.\n\n* To inject variables into the namespace, why not attach a method `ex.inject_variables()` to symbolic expressions that injects the output of `ex.variables()`.\n\nAt the end of the day, I don't think that the purity of functional programming conventions is worth the pain of changing how `var` behaves. Yes it does chafe against your OCD. But imagine you don't know Python and just want to do some symbolic stuff. I can guarantee you that that user is not going to appreciate your lesson in functional programming.",
    "created_at": "2015-03-28T21:02:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295336",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:31'></a>
* Why not `SR.gen('x')` to create a new variable instead of `SR.symbol` / `SR.var`? Also: currently broken, so would be nice to fix.

* To inject variables into the namespace, why not attach a method `ex.inject_variables()` to symbolic expressions that injects the output of `ex.variables()`.

At the end of the day, I don't think that the purity of functional programming conventions is worth the pain of changing how `var` behaves. Yes it does chafe against your OCD. But imagine you don't know Python and just want to do some symbolic stuff. I can guarantee you that that user is not going to appreciate your lesson in functional programming.



---

archive/issue_comments_295337.json:
```json
{
    "body": "<a id='comment:32'></a>\n> Searching our current codebase and examples indicates you might not be right in that assumption. I didn't do a precise count, but the occurrences of `a=var('a')` and `c,d=var('c,d')` are quite frequent (half of the `var` occurrences maybe?), so there's definitely an immediate need for it to do an automatic replacement.\n> \n> The fact that this developed in the first place also suggests that a significant number of people were not aware of/did not trust the injecting behaviour of `var`, so it's probably \"surprising\" behaviour (it's certainly non-pythonic to go and scribble in the globals dictionary). That indicates to me that the routine doing it needs a name that makes explicit it's having a side effect. A normal way of doing that is making the name a verb or verbal phrase, hence `declare_var` or `declare_symbol`.\n\n\nWell, of course another reason is that in doctests it can be annoying to do\n\n```\nsage: var('a')\na\n```\nwhile \n\n```\nsage: a=var('a')\nsage:\n```\nseems cleaner.   Maybe it's not all due to confusion.",
    "created_at": "2015-03-29T01:14:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295337",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:32'></a>
> Searching our current codebase and examples indicates you might not be right in that assumption. I didn't do a precise count, but the occurrences of `a=var('a')` and `c,d=var('c,d')` are quite frequent (half of the `var` occurrences maybe?), so there's definitely an immediate need for it to do an automatic replacement.
> 
> The fact that this developed in the first place also suggests that a significant number of people were not aware of/did not trust the injecting behaviour of `var`, so it's probably "surprising" behaviour (it's certainly non-pythonic to go and scribble in the globals dictionary). That indicates to me that the routine doing it needs a name that makes explicit it's having a side effect. A normal way of doing that is making the name a verb or verbal phrase, hence `declare_var` or `declare_symbol`.


Well, of course another reason is that in doctests it can be annoying to do

```
sage: var('a')
a
```
while 

```
sage: a=var('a')
sage:
```
seems cleaner.   Maybe it's not all due to confusion.



---

archive/issue_comments_295338.json:
```json
{
    "body": "<a id='comment:33'></a>\nReplying to [kcrisman](#comment%3A32):\n> Well, of course another reason is that in doctests it can be annoying to do\n> \n> ```\n> sage: var('a')\n> a\n> ```\n> while \n> \n> ```\n> sage: a=var('a')\n> sage:\n> ```\n> seems cleaner.   Maybe it's not all due to confusion.\n\nI'm not quite clear whether you mean:\n- side-effectful routines should NOT return a value (quite standard) and should NOT print something.\n- side-effectful routines are unclean anyway and it's no bother to type `a=var('a')`.",
    "created_at": "2015-03-29T01:21:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295338",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:33'></a>
Replying to [kcrisman](#comment%3A32):
> Well, of course another reason is that in doctests it can be annoying to do
> 
> ```
> sage: var('a')
> a
> ```
> while 
> 
> ```
> sage: a=var('a')
> sage:
> ```
> seems cleaner.   Maybe it's not all due to confusion.

I'm not quite clear whether you mean:
- side-effectful routines should NOT return a value (quite standard) and should NOT print something.
- side-effectful routines are unclean anyway and it's no bother to type `a=var('a')`.



---

archive/issue_comments_295339.json:
```json
{
    "body": "<a id='comment:34'></a>\n> > seems cleaner.   Maybe it's not all due to confusion.\n\n> I'm not quite clear whether you mean:\n>  - side-effectful routines should NOT return a value (quite standard) and should NOT print something.\n>  - side-effectful routines are unclean anyway and it's no bother to type `a=var('a')`.\n\n\nWhat I mean is that I think the doctests were written that way because it was easier to type`a=var('a')` than have to deal with an output.  For myself, I think that \n* keeping previous behavior\n* ease of use\nargue strongly for `var('a')` or something else *easy*, no equals signs etc.  In fact, `var(a)` would be easiest but Python wouldn't allow that.",
    "created_at": "2015-03-29T02:25:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295339",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:34'></a>
> > seems cleaner.   Maybe it's not all due to confusion.

> I'm not quite clear whether you mean:
>  - side-effectful routines should NOT return a value (quite standard) and should NOT print something.
>  - side-effectful routines are unclean anyway and it's no bother to type `a=var('a')`.


What I mean is that I think the doctests were written that way because it was easier to type`a=var('a')` than have to deal with an output.  For myself, I think that 
* keeping previous behavior
* ease of use
argue strongly for `var('a')` or something else *easy*, no equals signs etc.  In fact, `var(a)` would be easiest but Python wouldn't allow that.



---

archive/issue_comments_295340.json:
```json
{
    "body": "<a id='comment:35'></a>\nReplying to [kcrisman](#comment%3A34):\n>...`var(a)` would be easiest but Python wouldn't allow that.\n\nWe're not so picky when it comes to other preparsed stuff.",
    "created_at": "2015-03-29T08:50:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295340",
    "user": "https://github.com/rwst"
}
```

<a id='comment:35'></a>
Replying to [kcrisman](#comment%3A34):
>...`var(a)` would be easiest but Python wouldn't allow that.

We're not so picky when it comes to other preparsed stuff.



---

archive/issue_comments_295341.json:
```json
{
    "body": "<a id='comment:36'></a>\nHow about\n\n```\nsage: var a, b\n```\nhandled by the preparser. Its not a function, so it alleviates the side effect concern. The `var` statement would only be allowed at the beginning of the line (just like the print statement), so you wouldn't be able to assign anything anyways. And its easily handled by the preparser as `'^[\\s]*var '` regex.",
    "created_at": "2015-03-29T08:57:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295341",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:36'></a>
How about

```
sage: var a, b
```
handled by the preparser. Its not a function, so it alleviates the side effect concern. The `var` statement would only be allowed at the beginning of the line (just like the print statement), so you wouldn't be able to assign anything anyways. And its easily handled by the preparser as `'^[\s]*var '` regex.



---

archive/issue_comments_295342.json:
```json
{
    "body": "<a id='comment:37'></a>\nReplying to [vbraun](#comment%3A36):\n> How about\n> \n> ```\n> sage: var a, b\n> ```\n\nNote that SageMathCloud supports\n\n```\nsage: %var a, b\n```\nfor this.",
    "created_at": "2015-03-29T11:10:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295342",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:37'></a>
Replying to [vbraun](#comment%3A36):
> How about
> 
> ```
> sage: var a, b
> ```

Note that SageMathCloud supports

```
sage: %var a, b
```
for this.



---

archive/issue_comments_295343.json:
```json
{
    "body": "Replying to [ticket:17958 rws]:\n>  2. `var('x')` prints deprecation message, returns variable as before; error after deprecation period\n>  3. `y = var('x')` as before (but without globals), NO deprecation message\n\n\nI think it's technically impossible that `var('x')` and `y = var('x')` behave in a different way.",
    "created_at": "2015-03-29T11:19:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295343",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [ticket:17958 rws]:
>  2. `var('x')` prints deprecation message, returns variable as before; error after deprecation period
>  3. `y = var('x')` as before (but without globals), NO deprecation message


I think it's technically impossible that `var('x')` and `y = var('x')` behave in a different way.



---

archive/issue_comments_295344.json:
```json
{
    "body": "<a id='comment:39'></a>\nThen what about doing the following:\n1. Implement `%var a, b` (or perhaps `var a, b`) and/or `SR.var('a').inject()`, leaving `var()` alone for the moment.\n2. Change as much as possible of the documentation and examples to use either `a = SR.var('a')` or `%var a`.\n3. Wait a year or two to see if the new syntax catches on.\n4. Formally deprecate `var()`, add a deprecation warning, a remove it after a while.",
    "created_at": "2015-03-29T12:02:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295344",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:39'></a>
Then what about doing the following:
1. Implement `%var a, b` (or perhaps `var a, b`) and/or `SR.var('a').inject()`, leaving `var()` alone for the moment.
2. Change as much as possible of the documentation and examples to use either `a = SR.var('a')` or `%var a`.
3. Wait a year or two to see if the new syntax catches on.
4. Formally deprecate `var()`, add a deprecation warning, a remove it after a while.



---

archive/issue_comments_295345.json:
```json
{
    "body": "<a id='comment:40'></a>\nPlease change the description accordingly if no one has serious arguments (I think it's optimal). If asked about `%var`/`var` my purely personal preference would be the latter.",
    "created_at": "2015-03-29T12:43:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295345",
    "user": "https://github.com/rwst"
}
```

<a id='comment:40'></a>
Please change the description accordingly if no one has serious arguments (I think it's optimal). If asked about `%var`/`var` my purely personal preference would be the latter.



---

archive/issue_comments_295346.json:
```json
{
    "body": "<a id='comment:41'></a>\nReplying to [mmezzarobba](#comment%3A39):\n> 1. Implement `%var a, b` (or perhaps `var a, b`) and/or `SR.var('a').inject()`, leaving `var()` alone for the moment.\n> 2. Change as much as possible of the documentation and examples to use either `a = SR.var('a')` or `%var a`.\n\n\nYou'd need to take into account that the `%var` processing is done by the REPL. So for notebook, ipython and the doctest framework (and any new interfaces that arise) you'd have to provide it.\n\nBy making `var` not a function you're also blocking off reasonable programmatic use. Presently:\n\n```\nsage: var(''.join('x%d '%i for i in [1..10]))\n(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)\n```\nThis is comparable to why in Python3 print was turned into a function.\n\nOtherwise I like the missing quotes in the syntax; I dislike having to explain what the modulo or string formatting sign is doing at the start of a line when you're explaining to someone that sage is \"just like python\" (should they know that already). \n\n`SR.var('a').inject()` has problems. The incantation is obviously atrocious to type. But also: note that `inject()` would simply be a method on an expression. Would it inject all variables that occur in it?",
    "created_at": "2015-03-29T16:37:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295346",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:41'></a>
Replying to [mmezzarobba](#comment%3A39):
> 1. Implement `%var a, b` (or perhaps `var a, b`) and/or `SR.var('a').inject()`, leaving `var()` alone for the moment.
> 2. Change as much as possible of the documentation and examples to use either `a = SR.var('a')` or `%var a`.


You'd need to take into account that the `%var` processing is done by the REPL. So for notebook, ipython and the doctest framework (and any new interfaces that arise) you'd have to provide it.

By making `var` not a function you're also blocking off reasonable programmatic use. Presently:

```
sage: var(''.join('x%d '%i for i in [1..10]))
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)
```
This is comparable to why in Python3 print was turned into a function.

Otherwise I like the missing quotes in the syntax; I dislike having to explain what the modulo or string formatting sign is doing at the start of a line when you're explaining to someone that sage is "just like python" (should they know that already). 

`SR.var('a').inject()` has problems. The incantation is obviously atrocious to type. But also: note that `inject()` would simply be a method on an expression. Would it inject all variables that occur in it?



---

archive/issue_comments_295347.json:
```json
{
    "body": "<a id='comment:42'></a>\nReplying to [nbruin](#comment%3A41):\n> By making `var` not a function you're also blocking off reasonable programmatic use.\n\n\nExactly, and that is IMHO a big plus of the proposal. \n\nEven right row you are not **supposed** to use `var` in library code, but there is nothing stopping you. Programmatically generated symbolic variables should always be declared as `x = SR.var('x')`. This is already spelled out in the current `var` docstring.",
    "created_at": "2015-03-29T16:51:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295347",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:42'></a>
Replying to [nbruin](#comment%3A41):
> By making `var` not a function you're also blocking off reasonable programmatic use.


Exactly, and that is IMHO a big plus of the proposal. 

Even right row you are not **supposed** to use `var` in library code, but there is nothing stopping you. Programmatically generated symbolic variables should always be declared as `x = SR.var('x')`. This is already spelled out in the current `var` docstring.



---

archive/issue_comments_295348.json:
```json
{
    "body": "<a id='comment:43'></a>\nPS: The Sage doctests are preparsed but not run in IPython. So `var a` would work in a doctest, whereas `%var a` would not.",
    "created_at": "2015-03-29T16:53:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295348",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:43'></a>
PS: The Sage doctests are preparsed but not run in IPython. So `var a` would work in a doctest, whereas `%var a` would not.



---

archive/issue_comments_295349.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -7,6 +7,3 @@\n This and the same with functions is the most annoying problem for people doing calculus in Sage.\n \n * http://ask.sagemath.org/question/8145/difference-between-varx-and-xvarx/\n-\n-Also #6559 deprecated the `ns` keyword 5 years ago, let's remove it from `var()`.\n-\n``````\n",
    "created_at": "2015-03-29T17:23:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295349",
    "user": "https://github.com/jdemeyer"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -7,6 +7,3 @@
 This and the same with functions is the most annoying problem for people doing calculus in Sage.
 
 * http://ask.sagemath.org/question/8145/difference-between-varx-and-xvarx/
-
-Also #6559 deprecated the `ns` keyword 5 years ago, let's remove it from `var()`.
-
``````




---

archive/issue_comments_295350.json:
```json
{
    "body": "<a id='comment:45'></a>\nNOTE: I am making changes to the implementation of `var()` in #18083.",
    "created_at": "2015-03-29T17:52:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295350",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:45'></a>
NOTE: I am making changes to the implementation of `var()` in #18083.



---

archive/issue_comments_295351.json:
```json
{
    "body": "<a id='comment:46'></a>\nReplying to [vbraun](#comment%3A42):\n> Even right row you are not **supposed** to use `var` in library code, but there is nothing stopping you. Programmatically generated symbolic variables should always be declared as `x = SR.var('x')`. This is already spelled out in the current `var` docstring.\n\n\nIs that spelled out? I looked at sage.calculus.var.var? (that's the var that also occurs at top-level) and didn't find it there. I don't think a programmatic approach to injecting `x1,...,x10` is so bad.\n\nA possible scenario:\n\n```\nsage: A=var(''.join('x%d '%i for i in [1..10]))\nsage: L=sum(A[i]^(i+1) for i in [0..9])^2\nsage: L.expand().coefficient(x4^4)\n2*x10^10 + 2*x9^9 + 2*x8^8 + 2*x7^7 + 2*x6^6 + 2*x5^5 + 2*x3^3 + 2*x2^2 + 2*x1\n```\nwhich actually illustrates a genuine use of \"inject as well as return\". D'oh.",
    "created_at": "2015-03-29T18:06:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295351",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:46'></a>
Replying to [vbraun](#comment%3A42):
> Even right row you are not **supposed** to use `var` in library code, but there is nothing stopping you. Programmatically generated symbolic variables should always be declared as `x = SR.var('x')`. This is already spelled out in the current `var` docstring.


Is that spelled out? I looked at sage.calculus.var.var? (that's the var that also occurs at top-level) and didn't find it there. I don't think a programmatic approach to injecting `x1,...,x10` is so bad.

A possible scenario:

```
sage: A=var(''.join('x%d '%i for i in [1..10]))
sage: L=sum(A[i]^(i+1) for i in [0..9])^2
sage: L.expand().coefficient(x4^4)
2*x10^10 + 2*x9^9 + 2*x8^8 + 2*x7^7 + 2*x6^6 + 2*x5^5 + 2*x3^3 + 2*x2^2 + 2*x1
```
which actually illustrates a genuine use of "inject as well as return". D'oh.



---

archive/issue_comments_295352.json:
```json
{
    "body": "<a id='comment:47'></a>\nThe var docstring (`var?`) contains\n\n```\n   Note: The new variable is both returned and automatically\n     injected into the global namespace. If you need symbolic variable\n     in library code, it is better to use either SR.var() or\n     SR.symbol().\n```",
    "created_at": "2015-03-29T19:48:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295352",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:47'></a>
The var docstring (`var?`) contains

```
   Note: The new variable is both returned and automatically
     injected into the global namespace. If you need symbolic variable
     in library code, it is better to use either SR.var() or
     SR.symbol().
```



---

archive/issue_comments_295353.json:
```json
{
    "body": "<a id='comment:48'></a>\nSee also #18084.",
    "created_at": "2015-03-29T19:50:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295353",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:48'></a>
See also #18084.



---

archive/issue_comments_295354.json:
```json
{
    "body": "<a id='comment:49'></a>\nReplying to [vbraun](#comment%3A47):\n> The var docstring (`var?`) contains\n> \n> ```\n>    Note: The new variable is both returned and automatically\n>      injected into the global namespace. If you need symbolic variable\n>      in library code, it is better to use either SR.var() or\n>      SR.symbol().\n> ```\n\nYes that's for use in the library. The problem with `%var` would be feeding programmatically generated input into it. I don't think that's currently explicitly discouraged in the documentation.\n\nReducing support for that would be a reduction in functionality. If the advantages of `%var` are otherwise overwhelming we could still decide to go that route, but it shows that the spelling with quotes does have its advantages too.",
    "created_at": "2015-03-29T20:44:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295354",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:49'></a>
Replying to [vbraun](#comment%3A47):
> The var docstring (`var?`) contains
> 
> ```
>    Note: The new variable is both returned and automatically
>      injected into the global namespace. If you need symbolic variable
>      in library code, it is better to use either SR.var() or
>      SR.symbol().
> ```

Yes that's for use in the library. The problem with `%var` would be feeding programmatically generated input into it. I don't think that's currently explicitly discouraged in the documentation.

Reducing support for that would be a reduction in functionality. If the advantages of `%var` are otherwise overwhelming we could still decide to go that route, but it shows that the spelling with quotes does have its advantages too.



---

archive/issue_comments_295355.json:
```json
{
    "body": "<a id='comment:50'></a>\nOh you mean the good old `var(', '.join(['x{0}'.format(i) for i in range(10)]))` trick. Calculus freshmen are going to love your class... In any case I don't mind having a way to inject multiple variables at once, but something like\n\n```\nsage: SR.inject_variables('x, y')    \nsage: SR.inject_variables('x', 'y')   # strings to variable names\nsage: SR.inject_variables('x{i}', i=range(10))    # use keyword arguments to format\nsage: SR.inject_variables(ex)     # inject all of ex.variables()\n```\nwould probably be a lot better.",
    "created_at": "2015-03-29T21:37:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295355",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:50'></a>
Oh you mean the good old `var(', '.join(['x{0}'.format(i) for i in range(10)]))` trick. Calculus freshmen are going to love your class... In any case I don't mind having a way to inject multiple variables at once, but something like

```
sage: SR.inject_variables('x, y')    
sage: SR.inject_variables('x', 'y')   # strings to variable names
sage: SR.inject_variables('x{i}', i=range(10))    # use keyword arguments to format
sage: SR.inject_variables(ex)     # inject all of ex.variables()
```
would probably be a lot better.



---

archive/issue_comments_295356.json:
```json
{
    "body": "<a id='comment:51'></a>\n> How about\n> \n> ```\n> sage: var a, b\n> ```\n\n\nSomething along these lines would MASSIVELY help with this issue.  As long as we have to declare variables anyway, we should at least make it easy to do so, and the syntax currently is kind of hard to type\n\n```\nvar('z,y')\n```\n(try this on a qwerty board slowly to see all the unusual movements due to the shifts and non-home row things) so it would definitely be so for a beginner.\n\nAs long as there is a LONG deprecation period for this (as it's likely to bite quite a few people who wouldn't upgrade very frequently) something along these lines seems fine, return value `None` or whatever seems appropriate.  It would also be great to have `%var` eventually since SMC does but that could be a different ticket as long as there is a good deprecation period to `var('a')`.",
    "created_at": "2015-03-30T17:36:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295356",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:51'></a>
> How about
> 
> ```
> sage: var a, b
> ```


Something along these lines would MASSIVELY help with this issue.  As long as we have to declare variables anyway, we should at least make it easy to do so, and the syntax currently is kind of hard to type

```
var('z,y')
```
(try this on a qwerty board slowly to see all the unusual movements due to the shifts and non-home row things) so it would definitely be so for a beginner.

As long as there is a LONG deprecation period for this (as it's likely to bite quite a few people who wouldn't upgrade very frequently) something along these lines seems fine, return value `None` or whatever seems appropriate.  It would also be great to have `%var` eventually since SMC does but that could be a different ticket as long as there is a good deprecation period to `var('a')`.



---

archive/issue_comments_295357.json:
```json
{
    "body": "<a id='comment:52'></a>\nI would favor an \"infinite\" deprecation period for `var()`: deprecate it but keep supporting it forever.",
    "created_at": "2015-03-30T20:17:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295357",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:52'></a>
I would favor an "infinite" deprecation period for `var()`: deprecate it but keep supporting it forever.



---

archive/issue_comments_295358.json:
```json
{
    "body": "<a id='comment:53'></a>\nSeems reasonable.",
    "created_at": "2015-03-31T01:19:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295358",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:53'></a>
Seems reasonable.



---

archive/issue_comments_295359.json:
```json
{
    "body": "<a id='comment:54'></a>\nReplying to [vbraun](#comment%3A50):\n> \n> ```\n> sage: SR.inject_variables('x, y')    \n> sage: SR.inject_variables('x', 'y')   # strings to variable names\n> sage: SR.inject_variables('x{i}', i=range(10))    # use keyword arguments to format\n> sage: SR.inject_variables(ex)     # inject all of ex.variables()\n> ```\n\nSomething like that would work, but probably not under that name. The method already exists on `SR` by inheritance (and doesn't work), and the signature you're proposing is incompatible with the one on other rings.\n\nInjecting in general isn't really a method that belongs on the object, since the object doesn't naturally have access to the dictionary into which these things should be injected. It's really more the task of a REPL utility function. In which case the spelling\n\n```\ninject_generators(QQ['x'])\n```\nwould make more sense. The magic of figuring out into which dictionary the bindings should be injected is compartmentalized into a single function which could be implemented basically as\n\n```\ndef inject_generators(parent):\n    D={repr(a): a for a in parent.gens()}\n    print \"defining \",D.keys()\n    user_globals.update(D)\n```\nThis probably much nicer than scattering references to user_globals all over the place (we'd probably want to add some sanity checks to prevent this from inserting objectionable bindings).\n\nFor symbolic binding we could then have something along the lines of\n\n```\ndef inject_symbols(*args):\n    user_globals.update({ repr(a):a for e in args for a in e.variables()})\n```\n\nInterfacing via `%var` is then an additional measure.\n\nIn short, what we seem to be converging towards is:\n- deprecate `sage.calculus.var.var` (but keep supporting it; after a while probably do adorn it with a deprecation warning)\n- support symbolic variable injection via a special `%var` directive (which saves quotes too!) -- Is the `%` a problem? We'd need to make doctests aware of it.\n- have `SR.var(...)` as general symbol creation (which we already have).\n\nThere is some further rationalization around injection behaviour possible.",
    "created_at": "2015-03-31T01:30:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295359",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:54'></a>
Replying to [vbraun](#comment%3A50):
> 
> ```
> sage: SR.inject_variables('x, y')    
> sage: SR.inject_variables('x', 'y')   # strings to variable names
> sage: SR.inject_variables('x{i}', i=range(10))    # use keyword arguments to format
> sage: SR.inject_variables(ex)     # inject all of ex.variables()
> ```

Something like that would work, but probably not under that name. The method already exists on `SR` by inheritance (and doesn't work), and the signature you're proposing is incompatible with the one on other rings.

Injecting in general isn't really a method that belongs on the object, since the object doesn't naturally have access to the dictionary into which these things should be injected. It's really more the task of a REPL utility function. In which case the spelling

```
inject_generators(QQ['x'])
```
would make more sense. The magic of figuring out into which dictionary the bindings should be injected is compartmentalized into a single function which could be implemented basically as

```
def inject_generators(parent):
    D={repr(a): a for a in parent.gens()}
    print "defining ",D.keys()
    user_globals.update(D)
```
This probably much nicer than scattering references to user_globals all over the place (we'd probably want to add some sanity checks to prevent this from inserting objectionable bindings).

For symbolic binding we could then have something along the lines of

```
def inject_symbols(*args):
    user_globals.update({ repr(a):a for e in args for a in e.variables()})
```

Interfacing via `%var` is then an additional measure.

In short, what we seem to be converging towards is:
- deprecate `sage.calculus.var.var` (but keep supporting it; after a while probably do adorn it with a deprecation warning)
- support symbolic variable injection via a special `%var` directive (which saves quotes too!) -- Is the `%` a problem? We'd need to make doctests aware of it.
- have `SR.var(...)` as general symbol creation (which we already have).

There is some further rationalization around injection behaviour possible.



---

archive/issue_comments_295360.json:
```json
{
    "body": "<a id='comment:55'></a>\nI've announce this discussion on sage-devel https://groups.google.com/forum/#!topic/sage-devel/iy8Ck6BbhSE",
    "created_at": "2015-04-13T14:14:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295360",
    "user": "https://github.com/dkrenn"
}
```

<a id='comment:55'></a>
I've announce this discussion on sage-devel https://groups.google.com/forum/#!topic/sage-devel/iy8Ck6BbhSE



---

archive/issue_comments_295361.json:
```json
{
    "body": "<a id='comment:56'></a>\nI'm  against deprecating var.\n\nIt is also common for a Python function to do something with side effects -- e.g., run a subprocess -- and also return some information about what it did, e.g., the exit code.    This is computer programming, not mathematics. \n\nI prefer\n\n    %var x, y\n\nto \n\n     var x, y\n\nby the way, since we have been generally deprecated non-% special commands.   I was annoyed at first by, e.g.,  Jason Grout doing this, but I've come around.",
    "created_at": "2015-04-13T14:27:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295361",
    "user": "https://github.com/williamstein"
}
```

<a id='comment:56'></a>
I'm  against deprecating var.

It is also common for a Python function to do something with side effects -- e.g., run a subprocess -- and also return some information about what it did, e.g., the exit code.    This is computer programming, not mathematics. 

I prefer

    %var x, y

to 

     var x, y

by the way, since we have been generally deprecated non-% special commands.   I was annoyed at first by, e.g.,  Jason Grout doing this, but I've come around.



---

archive/issue_comments_295362.json:
```json
{
    "body": "<a id='comment:57'></a>\nos.system is a terrible example, its just a syscall wrapper. The subprocess module precisely tries to improve that interface by giving you separate check_output / check_call functions so you can create subprocesses in a more pythonic manner.",
    "created_at": "2015-04-13T14:49:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295362",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:57'></a>
os.system is a terrible example, its just a syscall wrapper. The subprocess module precisely tries to improve that interface by giving you separate check_output / check_call functions so you can create subprocesses in a more pythonic manner.



---

archive/issue_comments_295363.json:
```json
{
    "body": "<a id='comment:58'></a>\nReplying to [was](#comment%3A56):\n> It is also common for a Python function to do something with side effects -- e.g., run a subprocess -- and also return some information about what it did, e.g., the exit code.    This is computer programming, not mathematics. \n\n\nI thought something similar originally as well (although I thought \"this is mathematics software, not computer programming\"), but after seeing several questions from people getting thoroughly confused, I came to the conclusion that in this case having a side effect *and* a return value is a major source of confusion. See the original comment\n[ticket:17447#comment:23]. This is exacerbated by the fact that `x=var('x')` is very common in the documentation, which further trains people to be unaware of the side effect of `var`. See [comment:32](#comment%3A32) for a hypothesis on why this happens (which argues why the return value of the side-effect-having `var` is a nuisance rather than helpful)\n\nWe really need to decide if deprecating the current behaviour of `var` is ever going to be doable (possibly with supporting indefinitely). If it's not we can stop right now: we'll just be adding extra interfaces which will only confuse people more. In that case it'll just be another victim of the tar-pits of interface compatibility (which does have value).",
    "created_at": "2015-04-13T15:23:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295363",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:58'></a>
Replying to [was](#comment%3A56):
> It is also common for a Python function to do something with side effects -- e.g., run a subprocess -- and also return some information about what it did, e.g., the exit code.    This is computer programming, not mathematics. 


I thought something similar originally as well (although I thought "this is mathematics software, not computer programming"), but after seeing several questions from people getting thoroughly confused, I came to the conclusion that in this case having a side effect *and* a return value is a major source of confusion. See the original comment
[ticket:17447#comment:23]. This is exacerbated by the fact that `x=var('x')` is very common in the documentation, which further trains people to be unaware of the side effect of `var`. See [comment:32](#comment%3A32) for a hypothesis on why this happens (which argues why the return value of the side-effect-having `var` is a nuisance rather than helpful)

We really need to decide if deprecating the current behaviour of `var` is ever going to be doable (possibly with supporting indefinitely). If it's not we can stop right now: we'll just be adding extra interfaces which will only confuse people more. In that case it'll just be another victim of the tar-pits of interface compatibility (which does have value).



---

archive/issue_comments_295364.json:
```json
{
    "body": "<a id='comment:59'></a>\n* Many examples given so far use `sage: var('x')` while `x` is the one variable that is injected automatically into the namespace. I feel like this particularity of `x` does not help an easy understanding of how it works for newcomers.\n* Many users may be satisfied if any non-yet-defined symbol was automatically injected into the namespace. I guess it would also help users to understand the difference between a \"symbol\" (from `SR`), on which nothing is known, and a \"polynomial variable\" (for instance from `ZZ['x']`). In some sense, this would imply that one can play around with symbolic variables, perform some simple calculations, etc. but that one should properly define their objects to obtain more functionalities and better performances.\n* Note that the previous point can be activated, in the Notebook only, using `automatic_names(True)`. We may have a magic function to activate this behavior, as well as `implicit_multiplication(True)`.\n* Amongst the different propositions for a new name if one is needed, I like the use of the keyword `math` that helps to makes the difference between a math symbol/variable/whatever and a python variable.\n* I also like the proposition to define `%var x,y` (or even `%var x y`). I think it would be nice to have something printed as for `inject_variables()` in this case, such as `Defining x, y as symbolic variables.`\n* For the deprecation, it is certainly less annoying for users if the change occurs with a new version number such as 7.0 or 8.0.",
    "created_at": "2015-04-13T15:28:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295364",
    "user": "https://github.com/bgrenet"
}
```

<a id='comment:59'></a>
* Many examples given so far use `sage: var('x')` while `x` is the one variable that is injected automatically into the namespace. I feel like this particularity of `x` does not help an easy understanding of how it works for newcomers.
* Many users may be satisfied if any non-yet-defined symbol was automatically injected into the namespace. I guess it would also help users to understand the difference between a "symbol" (from `SR`), on which nothing is known, and a "polynomial variable" (for instance from `ZZ['x']`). In some sense, this would imply that one can play around with symbolic variables, perform some simple calculations, etc. but that one should properly define their objects to obtain more functionalities and better performances.
* Note that the previous point can be activated, in the Notebook only, using `automatic_names(True)`. We may have a magic function to activate this behavior, as well as `implicit_multiplication(True)`.
* Amongst the different propositions for a new name if one is needed, I like the use of the keyword `math` that helps to makes the difference between a math symbol/variable/whatever and a python variable.
* I also like the proposition to define `%var x,y` (or even `%var x y`). I think it would be nice to have something printed as for `inject_variables()` in this case, such as `Defining x, y as symbolic variables.`
* For the deprecation, it is certainly less annoying for users if the change occurs with a new version number such as 7.0 or 8.0.



---

archive/issue_comments_295365.json:
```json
{
    "body": "<a id='comment:60'></a>\nI won't approve of `declare_var`, as it's too close to `declare_war`...\n\nAnyhow, I don't understand what `SR` is. It looks as if it is no more than a hack provided by Sage, no more than that. Documentation says nothing about it. Perhaps before discussing `var()`, one should provide a definition. So far I don't understand the difference between symbolic variables and polynomial ring variables (except that the latter somehow don't work in `solve()`).",
    "created_at": "2015-04-14T14:02:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295365",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:60'></a>
I won't approve of `declare_var`, as it's too close to `declare_war`...

Anyhow, I don't understand what `SR` is. It looks as if it is no more than a hack provided by Sage, no more than that. Documentation says nothing about it. Perhaps before discussing `var()`, one should provide a definition. So far I don't understand the difference between symbolic variables and polynomial ring variables (except that the latter somehow don't work in `solve()`).



---

archive/issue_comments_295366.json:
```json
{
    "body": "<a id='comment:61'></a>\nReplying to [dimpase](#comment%3A60):\n> Anyhow, I don't understand what `SR` is. It looks as if it is no more than a hack provided by Sage, no more than that. Documentation says nothing about it. Perhaps before discussing `var()`, one should provide a definition. So far I don't understand the difference between symbolic variables and polynomial ring variables (except that the latter somehow don't work in `solve()`).\n\n\nCalculus.",
    "created_at": "2015-04-14T14:10:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295366",
    "user": "https://github.com/williamstein"
}
```

<a id='comment:61'></a>
Replying to [dimpase](#comment%3A60):
> Anyhow, I don't understand what `SR` is. It looks as if it is no more than a hack provided by Sage, no more than that. Documentation says nothing about it. Perhaps before discussing `var()`, one should provide a definition. So far I don't understand the difference between symbolic variables and polynomial ring variables (except that the latter somehow don't work in `solve()`).


Calculus.



---

archive/issue_comments_295367.json:
```json
{
    "body": "<a id='comment:62'></a>\nTo get this back on track, the minimal change that would satisfactorily resolve the issue would be a warning (but keep `var` indefinitely)\n\n```\nsage: var('x, y')    # warning but keep indefinitely\nWarning: var has side effects. Consider using %var x, y\n(x, y)\n```\nand\n\n```\nsage: %var x, y\nDefining x, y as symbolic variables.\n```\nThe latter would also have to work in doctests where percent-magics currently do not work.",
    "created_at": "2015-04-14T14:16:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295367",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:62'></a>
To get this back on track, the minimal change that would satisfactorily resolve the issue would be a warning (but keep `var` indefinitely)

```
sage: var('x, y')    # warning but keep indefinitely
Warning: var has side effects. Consider using %var x, y
(x, y)
```
and

```
sage: %var x, y
Defining x, y as symbolic variables.
```
The latter would also have to work in doctests where percent-magics currently do not work.



---

archive/issue_comments_295368.json:
```json
{
    "body": "<a id='comment:63'></a>\nReplying to [vbraun](#comment%3A62):\n> To get this back on track, the minimal change that would satisfactorily resolve the issue would be a warning (but keep `var` indefinitely)\n> \n> ```\n> sage: var('x, y')    # warning but keep indefinitely\n> Warning: var has side effects. Consider using %var x, y\n> (x, y)\n> ```\n> and\n> \n> ```\n> sage: %var x, y\n> Defining x, y as symbolic variables.\n> ```\n\nI think this would be an improvement, so I'd be in favour if this change, even as proposed. Some details:\n\n- the warning correctly mentions a snag about `var` and then proposes an alternative that also has side-effects. I hate to make warning messages more than one line, but perhaps more information is beneficial here:\n\n```\nWarning: var has side effects. Consider using SR.var('x,y') to return symbolic variables and %var x,y for binding them.\n```\n- I personally like the printing of a message by `%var` for novices, but [comment:32](#comment%3A32) suggests that the printing is a nuisance. So is it better for  `%var` to do its work silently?",
    "created_at": "2015-04-14T14:29:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295368",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:63'></a>
Replying to [vbraun](#comment%3A62):
> To get this back on track, the minimal change that would satisfactorily resolve the issue would be a warning (but keep `var` indefinitely)
> 
> ```
> sage: var('x, y')    # warning but keep indefinitely
> Warning: var has side effects. Consider using %var x, y
> (x, y)
> ```
> and
> 
> ```
> sage: %var x, y
> Defining x, y as symbolic variables.
> ```

I think this would be an improvement, so I'd be in favour if this change, even as proposed. Some details:

- the warning correctly mentions a snag about `var` and then proposes an alternative that also has side-effects. I hate to make warning messages more than one line, but perhaps more information is beneficial here:

```
Warning: var has side effects. Consider using SR.var('x,y') to return symbolic variables and %var x,y for binding them.
```
- I personally like the printing of a message by `%var` for novices, but [comment:32](#comment%3A32) suggests that the printing is a nuisance. So is it better for  `%var` to do its work silently?



---

archive/issue_comments_295369.json:
```json
{
    "body": "<a id='comment:64'></a>\nReplying to [nbruin](#comment%3A63):\n>  - I personally like the printing of a message by `%var` for novices, but [comment:32](#comment%3A32) suggests that the printing is a nuisance. So is it better for  `%var` to do its work silently?\n\n\nAn option may be to print it using `verbose(level=0)`, and document that the verbosity level may be set to negative to suppress such messages.",
    "created_at": "2015-04-14T14:33:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295369",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:64'></a>
Replying to [nbruin](#comment%3A63):
>  - I personally like the printing of a message by `%var` for novices, but [comment:32](#comment%3A32) suggests that the printing is a nuisance. So is it better for  `%var` to do its work silently?


An option may be to print it using `verbose(level=0)`, and document that the verbosity level may be set to negative to suppress such messages.



---

archive/issue_comments_295370.json:
```json
{
    "body": "<a id='comment:65'></a>\nReplying to [was](#comment%3A61):\n> Replying to [dimpase](#comment%3A60):\n> > Anyhow, I don't understand what `SR` is. It looks as if it is no more than a hack provided by Sage, no more than that. Documentation says nothing about it. Perhaps before discussing `var()`, one should provide a definition. So far I don't understand the difference between symbolic variables and polynomial ring variables (except that the latter somehow don't work in `solve()`).\n\n> \n> Calculus.\n\nI don't think it's precise enough; for myself I understand `SR` as sequences of terms subject to certain rewriting rules, but neither what the term are, nor what the rewriting rules are, is not stated anywhere except in the source code and in examples...",
    "created_at": "2015-04-14T14:36:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295370",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:65'></a>
Replying to [was](#comment%3A61):
> Replying to [dimpase](#comment%3A60):
> > Anyhow, I don't understand what `SR` is. It looks as if it is no more than a hack provided by Sage, no more than that. Documentation says nothing about it. Perhaps before discussing `var()`, one should provide a definition. So far I don't understand the difference between symbolic variables and polynomial ring variables (except that the latter somehow don't work in `solve()`).

> 
> Calculus.

I don't think it's precise enough; for myself I understand `SR` as sequences of terms subject to certain rewriting rules, but neither what the term are, nor what the rewriting rules are, is not stated anywhere except in the source code and in examples...



---

archive/issue_comments_295371.json:
```json
{
    "body": "<a id='comment:66'></a>\nReplying to [dimpase](#comment%3A65):\n>  for myself I understand `SR` as sequences of terms subject to certain rewriting rules, but neither what the term are, nor what the rewriting rules are, is not stated anywhere except in the source code and in examples...\n\n\nTo repeat what I said on #15605, I for one basically view symbolic expressions as straight-line programs that are just required to evaluate to what you'd expect when you assign values to free variables. I believe this may be more accurate than thinking in terms of rewriting rules, since, as far as I know, nothing in the Sage implementation of symbolic expression systematically applies \u201crewriting rules\u201d.\n\nMany *operations* on symbolic expressions, however, only make sense with stronger assumptions on the expressions. Typically, simplifications are supposed to transform these \u201dprograms\u201c into \u201dequivalent\u201c ones, but of course whether two \u201dprograms\u201c are equivalent depends on what the variables can represent.\nIn this context, the sensible thing to do IMO is to view all variables as complex by default, and require simplifications to be valid for arbitrary complex values of all variables (or more accurately, for a generic choice of complex values: for example, we probably do want `x/x` to simplify to `1`). But of course this default does not cover all cases, for instance, `expand()` also makes sense for expressions containing constants from a finite field.",
    "created_at": "2015-04-14T14:53:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295371",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:66'></a>
Replying to [dimpase](#comment%3A65):
>  for myself I understand `SR` as sequences of terms subject to certain rewriting rules, but neither what the term are, nor what the rewriting rules are, is not stated anywhere except in the source code and in examples...


To repeat what I said on #15605, I for one basically view symbolic expressions as straight-line programs that are just required to evaluate to what you'd expect when you assign values to free variables. I believe this may be more accurate than thinking in terms of rewriting rules, since, as far as I know, nothing in the Sage implementation of symbolic expression systematically applies “rewriting rules”.

Many *operations* on symbolic expressions, however, only make sense with stronger assumptions on the expressions. Typically, simplifications are supposed to transform these ”programs“ into ”equivalent“ ones, but of course whether two ”programs“ are equivalent depends on what the variables can represent.
In this context, the sensible thing to do IMO is to view all variables as complex by default, and require simplifications to be valid for arbitrary complex values of all variables (or more accurately, for a generic choice of complex values: for example, we probably do want `x/x` to simplify to `1`). But of course this default does not cover all cases, for instance, `expand()` also makes sense for expressions containing constants from a finite field.



---

archive/issue_comments_295372.json:
```json
{
    "body": "<a id='comment:67'></a>\nReplying to [mmezzarobba](#comment%3A64):\n> An option may be to print it using `verbose(level=0)`, and document that the verbosity level may be set to negative to suppress such messages.\n\nI'm pretty sure that would be at least as annoying as dealing with values printed by a bare `var` (at least for doctests).",
    "created_at": "2015-04-14T15:10:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295372",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:67'></a>
Replying to [mmezzarobba](#comment%3A64):
> An option may be to print it using `verbose(level=0)`, and document that the verbosity level may be set to negative to suppress such messages.

I'm pretty sure that would be at least as annoying as dealing with values printed by a bare `var` (at least for doctests).



---

archive/issue_comments_295373.json:
```json
{
    "body": "<a id='comment:68'></a>\nRelated to this discussion, note that there is another (strange) way to declare variables in Sage that currently works:\n\n```\nsage: ,var x a b c\n(x, a, b, c)\nsage: type(a)\n<type 'sage.symbolic.expression.Expression'>\n```\n\nApparently, it is ipython that provides this. I learn about the existence of this when I recently read the [wikipedia page of Sage](http://en.wikipedia.org/wiki/Sage_(mathematics_software)):\n\n```\nx, a, b, c = var('x, a, b, c')\n# Note that IPython also supports a faster way to do this, by calling \n# this equivalent expression starting with a comma:\n# ,var x a b c\n```",
    "created_at": "2015-04-14T18:57:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295373",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:68'></a>
Related to this discussion, note that there is another (strange) way to declare variables in Sage that currently works:

```
sage: ,var x a b c
(x, a, b, c)
sage: type(a)
<type 'sage.symbolic.expression.Expression'>
```

Apparently, it is ipython that provides this. I learn about the existence of this when I recently read the [wikipedia page of Sage](http://en.wikipedia.org/wiki/Sage_(mathematics_software)):

```
x, a, b, c = var('x, a, b, c')
# Note that IPython also supports a faster way to do this, by calling 
# this equivalent expression starting with a comma:
# ,var x a b c
```



---

archive/issue_comments_295374.json:
```json
{
    "body": "<a id='comment:69'></a>\nReplying to [slabbe](#comment%3A68):\n> Apparently, it is ipython that provides this. I learn about the existence of this when I recently read the [wikipedia page of Sage](http://en.wikipedia.org/wiki/Sage_(mathematics_software)):\n> \n> ```\n> x, a, b, c = var('x, a, b, c')\n> # Note that IPython also supports a faster way to do this, by calling \n> # this equivalent expression starting with a comma:\n> # ,var x a b c\n> ```\nYuck. It's a good illustration of the general confusion caused by the current behaviour of `var`. Reading the IPython documentation,\n\n```\n,var x a b c\n```\nis equivalent to\n\n```\nvar(\"x\",\"a\",\"b\",\"c\")\n```\nwhich happens to do almost the same effect as the other `var` command given, except that the second form consists of a value returning expression and the first form is a non-expression statement that does not return a value (and hence prints nothing in the REPL).",
    "created_at": "2015-04-14T22:56:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17958#issuecomment-295374",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:69'></a>
Replying to [slabbe](#comment%3A68):
> Apparently, it is ipython that provides this. I learn about the existence of this when I recently read the [wikipedia page of Sage](http://en.wikipedia.org/wiki/Sage_(mathematics_software)):
> 
> ```
> x, a, b, c = var('x, a, b, c')
> # Note that IPython also supports a faster way to do this, by calling 
> # this equivalent expression starting with a comma:
> # ,var x a b c
> ```
Yuck. It's a good illustration of the general confusion caused by the current behaviour of `var`. Reading the IPython documentation,

```
,var x a b c
```
is equivalent to

```
var("x","a","b","c")
```
which happens to do almost the same effect as the other `var` command given, except that the second form consists of a value returning expression and the first form is a non-expression statement that does not return a value (and hence prints nothing in the REPL).
