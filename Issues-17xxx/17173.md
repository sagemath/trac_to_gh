# Issue 17173: Poset: faster is_distributive_lattice

archive/issues_016936.json:
```json
{
    "assignees": [],
    "body": "After #17121 it is faster to say `P.is_lattice() and LatticePoset(P).is_distibutive()` than `P._hasse_diagram.is_distributive_lattice()`. However, there exists also fast algorithm to directly check if a given poset is distributive lattice.\n\nCC:  @tscrim\n\nBranch/Commit: **[public/poset__faster_is_distributive_lattice](https://github.com/sagemath/sagetrac-mirror/tree/public/poset__faster_is_distributive_lattice) @ [f5416f7](https://github.com/sagemath/sagetrac-mirror/commit/f5416f799262d0540e61f0b337d900cc8e776bff)**\n\nAuthor: **Jori M\u00e4ntysalo**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/17173_\n\n",
    "created_at": "2014-10-18T07:24:03Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/component%3A%20combinatorics",
        "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/enhancement",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Poset: faster is_distributive_lattice",
    "type": "issue",
    "updated_at": "2022-12-29T01:35:57Z",
    "url": "https://github.com/sagemath/sage/issues/17173",
    "user": "https://github.com/jm58660"
}
```
After #17121 it is faster to say `P.is_lattice() and LatticePoset(P).is_distibutive()` than `P._hasse_diagram.is_distributive_lattice()`. However, there exists also fast algorithm to directly check if a given poset is distributive lattice.

CC:  @tscrim

Branch/Commit: **[public/poset__faster_is_distributive_lattice](https://github.com/sagemath/sagetrac-mirror/tree/public/poset__faster_is_distributive_lattice) @ [f5416f7](https://github.com/sagemath/sagetrac-mirror/commit/f5416f799262d0540e61f0b337d900cc8e776bff)**

Author: **Jori Mäntysalo**

_Issue created by migration from https://trac.sagemath.org/ticket/17173_





---

archive/issue_events_227550.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2014-10-18T07:24:03Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20combinatorics",
    "label_color": "0000ff",
    "label_name": "component: combinatorics",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227550"
}
```



---

archive/issue_events_227551.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2014-10-18T07:24:03Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "label": "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227551"
}
```



---

archive/issue_events_227552.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2014-10-18T07:24:03Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227552"
}
```



---

archive/issue_events_227553.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2014-10-18T07:24:03Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "label": "https://github.com/sagemath/sage/labels/wishlist%20item",
    "label_color": "e81ff9",
    "label_name": "wishlist item",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227553"
}
```



---

archive/issue_comments_230544.json:
```json
{
    "body": "Branch: **[u/jmantysalo/poset__faster_is_distributive_lattice](https://github.com/sagemath/sagetrac-mirror/tree/u/jmantysalo/poset__faster_is_distributive_lattice)**",
    "created_at": "2014-10-20T06:38:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230544",
    "user": "https://github.com/jm58660"
}
```

Branch: **[u/jmantysalo/poset__faster_is_distributive_lattice](https://github.com/sagemath/sagetrac-mirror/tree/u/jmantysalo/poset__faster_is_distributive_lattice)**



---

archive/issue_comments_230545.json:
```json
{
    "body": "Author: **Jori M\u00e4ntysalo**",
    "created_at": "2014-10-20T06:41:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230545",
    "user": "https://github.com/jm58660"
}
```

Author: **Jori Mäntysalo**



---

archive/issue_comments_230546.json:
```json
{
    "body": "Commit: **[d69e73a](https://github.com/sagemath/sagetrac-mirror/commit/d69e73a0a0a655e4e1595a77cda807ccb017fb02)**",
    "created_at": "2014-10-20T06:41:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230546",
    "user": "https://github.com/jm58660"
}
```

Commit: **[d69e73a](https://github.com/sagemath/sagetrac-mirror/commit/d69e73a0a0a655e4e1595a77cda807ccb017fb02)**



---

archive/issue_events_227554.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2014-10-20T06:41:14Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "milestone_number": null,
    "milestone_title": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227554"
}
```



---

archive/issue_events_227555.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2014-10-20T06:41:14Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "label": "https://github.com/sagemath/sage/labels/wishlist%20item",
    "label_color": "e81ff9",
    "label_name": "wishlist item",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227555"
}
```



---

archive/issue_comments_230547.json:
```json
{
    "body": "<a id='comment:3'>Comment 3:</a>\nAlso deprecated same function from `hasse_diagram.py`.\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/26e45c282ad073bc862c87b04f95696ebced5d48\">26e45c2</a></td><td><code>Added O(n) recognition of distributive lattices to posets.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d69e73a0a0a655e4e1595a77cda807ccb017fb02\">d69e73a</a></td><td><code>Unnecessary spaces removed.</code></td></tr></table>\n",
    "created_at": "2014-10-20T06:41:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230547",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:3'>Comment 3:</a>
Also deprecated same function from `hasse_diagram.py`.

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/26e45c282ad073bc862c87b04f95696ebced5d48">26e45c2</a></td><td><code>Added O(n) recognition of distributive lattices to posets.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d69e73a0a0a655e4e1595a77cda807ccb017fb02">d69e73a</a></td><td><code>Unnecessary spaces removed.</code></td></tr></table>




---

archive/issue_comments_230548.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,50 +1 @@\n-After #17121 it is faster to say `P.is_lattice() and LatticePoset(P).is_distibutive()` than `P._hasse_diagram.is_distributive_lattice()`. However, there exists also fast algorithm to directly check if a given poset is distributive lattice, see http://www.lirmm.fr/~nourine/Papiers/dist-recognition.ps .\n-\n-To show that algorithm works I did a small example code, which is not optimized at all. I will continue with this later. If someone is going to implement this, please add a note to this ticket.\n-\n-```\n-def join_irreducibles(self): return [e for e in self if len(self.lower_covers(e))==1]\n-def meet_irreducibles(self): return [e for e in self if len(self.upper_covers(e))==1]\n-\n-def is_distributive_lattice(self):\n-    if ( not self.is_graded() or not self.is_bounded() or not\n-    self.rank() == len(join_irreducibles(self)) == len(meet_irreducibles(self)) ):\n-        return False\n-    return _is_distributive_lattice_workhorse(self)\n-\n-def _is_distributive_lattice_workhorse(P):\n-    # Real workhorse, a recursive algorithm.\n-    # To show how the reduction goes:\n-    P.show()\n-    if not len([x for x in P if len(P.upper_covers(x))==1])==len([x for x in P if len(P.lower_covers(x))==1])==P.rank():\n-        return False\n-    if P.cardinality() == 2:\n-        if len(P.minimal_elements())==1:\n-            return True\n-        return \"This should not happen!\"\n-    M=P.subposet([x for x in P if len(P.upper_covers(x))==1])\n-    if len(M) == 0:\n-        return \"This should not happen!\"\n-    m=M.minimal_elements()[0]\n-    if len(P.upper_covers(m)) > 1:\n-        return \"This should not happen!\"\n-    m_=P.upper_covers(m)[0]\n-    M_=P.subposet([x for x in P if not x in P.closed_interval(P.bottom(), m)])\n-    if len(M_.minimal_elements()) > 1:\n-        return False\n-    j=M_.minimal_elements()\n-    j=j[0]\n-    # Does not really work, but counter-example must be quite big lattice.\n-    Z1=P.interval(P.bottom(), m)\n-    Z2=Set(P.interval(j, m_))\n-    for z in Z1:\n-        if len(Set(P.upper_covers(z)).difference(Z1)) != 1:\n-            return False\n-        if Set(P.upper_covers(z)).intersection(Z2).cardinality() != 1:           \n-            return False\n-        Z2 = Z2.difference(P.upper_covers(z))\n-    if Z2.cardinality() > 0:\n-        return False\n-    P_=P.subposet(x for x in P if not x in P.interval(P.bottom(), m))\n-    return _is_distributive_lattice_workhorse(P_)\n-```\n+After #17121 it is faster to say `P.is_lattice() and LatticePoset(P).is_distibutive()` than `P._hasse_diagram.is_distributive_lattice()`. However, there exists also fast algorithm to directly check if a given poset is distributive lattice.\n``````\n",
    "created_at": "2014-10-20T06:41:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230548",
    "user": "https://github.com/jm58660"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,50 +1 @@
-After #17121 it is faster to say `P.is_lattice() and LatticePoset(P).is_distibutive()` than `P._hasse_diagram.is_distributive_lattice()`. However, there exists also fast algorithm to directly check if a given poset is distributive lattice, see http://www.lirmm.fr/~nourine/Papiers/dist-recognition.ps .
-
-To show that algorithm works I did a small example code, which is not optimized at all. I will continue with this later. If someone is going to implement this, please add a note to this ticket.
-
-```
-def join_irreducibles(self): return [e for e in self if len(self.lower_covers(e))==1]
-def meet_irreducibles(self): return [e for e in self if len(self.upper_covers(e))==1]
-
-def is_distributive_lattice(self):
-    if ( not self.is_graded() or not self.is_bounded() or not
-    self.rank() == len(join_irreducibles(self)) == len(meet_irreducibles(self)) ):
-        return False
-    return _is_distributive_lattice_workhorse(self)
-
-def _is_distributive_lattice_workhorse(P):
-    # Real workhorse, a recursive algorithm.
-    # To show how the reduction goes:
-    P.show()
-    if not len([x for x in P if len(P.upper_covers(x))==1])==len([x for x in P if len(P.lower_covers(x))==1])==P.rank():
-        return False
-    if P.cardinality() == 2:
-        if len(P.minimal_elements())==1:
-            return True
-        return "This should not happen!"
-    M=P.subposet([x for x in P if len(P.upper_covers(x))==1])
-    if len(M) == 0:
-        return "This should not happen!"
-    m=M.minimal_elements()[0]
-    if len(P.upper_covers(m)) > 1:
-        return "This should not happen!"
-    m_=P.upper_covers(m)[0]
-    M_=P.subposet([x for x in P if not x in P.closed_interval(P.bottom(), m)])
-    if len(M_.minimal_elements()) > 1:
-        return False
-    j=M_.minimal_elements()
-    j=j[0]
-    # Does not really work, but counter-example must be quite big lattice.
-    Z1=P.interval(P.bottom(), m)
-    Z2=Set(P.interval(j, m_))
-    for z in Z1:
-        if len(Set(P.upper_covers(z)).difference(Z1)) != 1:
-            return False
-        if Set(P.upper_covers(z)).intersection(Z2).cardinality() != 1:           
-            return False
-        Z2 = Z2.difference(P.upper_covers(z))
-    if Z2.cardinality() > 0:
-        return False
-    P_=P.subposet(x for x in P if not x in P.interval(P.bottom(), m))
-    return _is_distributive_lattice_workhorse(P_)
-```
+After #17121 it is faster to say `P.is_lattice() and LatticePoset(P).is_distibutive()` than `P._hasse_diagram.is_distributive_lattice()`. However, there exists also fast algorithm to directly check if a given poset is distributive lattice.
``````




---

archive/issue_events_227556.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2014-10-20T06:41:14Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227556"
}
```



---

archive/issue_events_227557.json:
```json
{
    "actor": "https://github.com/nathanncohen",
    "created_at": "2014-10-20T09:45:57Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227557"
}
```



---

archive/issue_events_227558.json:
```json
{
    "actor": "https://github.com/nathanncohen",
    "created_at": "2014-10-20T09:45:57Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227558"
}
```



---

archive/issue_comments_230549.json:
```json
{
    "body": "<a id='comment:4'>Comment 4:</a>\nHello Jori !\n\nA couple of comments:\n\nPlease, try to make your code a bit better-looking:\n\n```diff\n-if ( not self.is_graded() or not self.is_bounded() or not\n-     self.rank() == len([e for e in self if len(self.lower_covers(e))==1]) ==\n-     len([e for e in self if len(self.upper_covers(e))==1]) ):\n-    return False\n-return self._is_distributive_lattice_recursion()\n+return (self.is_graded()  and\n+        self.is_bounded() and\n+        (self.rank() == len([e for e in self if len(self.lower_covers(e))==1])\n+                     == len([e for e in self if len(self.upper_covers(e))==1])) and\n+        self._is_distributive_lattice_recursion())\n```\n\nBy the way it is very unpleasant to build the list of upper covers when all you want to do is count its length. This is just a call to `in_degree` in the hasse diagram ! \n\nI also see that you compute 'subposet' very often, and I wonder if you should not compute subgraphs instead, as I expect that it is much more efficient (I beware of the `UniqueRepresentation` stuff)\n\nAlso, you cannot write things like that in Sage code\n\n```\n[x for x in self if not x in self.closed_interval(self.bottom(), m)]\n```\n\nHere is why:\n\n```\nsage: def a():\n....:     print \"Hey\"\n....:     return [1]\n....: [x for x in range(5) if x in a()]\n....: \nHey\nHey\nHey\nHey\nHey\n[1]\n```\n\nWhat you want to do is something like `set(self).difference(self.closed_interval(self.bottom(), m))`\n\nThere is also a broken doctest in `hasse_diagram.py`\n\nOh. And I am just noticing that your function does not seem to be recursive at all: you can replace the recursion by a loop ! First create a copy of self, and at each turn of the loop remove some vertices from the copy you work on.\n\nNathann",
    "created_at": "2014-10-20T09:45:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230549",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:4'>Comment 4:</a>
Hello Jori !

A couple of comments:

Please, try to make your code a bit better-looking:

```diff
-if ( not self.is_graded() or not self.is_bounded() or not
-     self.rank() == len([e for e in self if len(self.lower_covers(e))==1]) ==
-     len([e for e in self if len(self.upper_covers(e))==1]) ):
-    return False
-return self._is_distributive_lattice_recursion()
+return (self.is_graded()  and
+        self.is_bounded() and
+        (self.rank() == len([e for e in self if len(self.lower_covers(e))==1])
+                     == len([e for e in self if len(self.upper_covers(e))==1])) and
+        self._is_distributive_lattice_recursion())
```

By the way it is very unpleasant to build the list of upper covers when all you want to do is count its length. This is just a call to `in_degree` in the hasse diagram ! 

I also see that you compute 'subposet' very often, and I wonder if you should not compute subgraphs instead, as I expect that it is much more efficient (I beware of the `UniqueRepresentation` stuff)

Also, you cannot write things like that in Sage code

```
[x for x in self if not x in self.closed_interval(self.bottom(), m)]
```

Here is why:

```
sage: def a():
....:     print "Hey"
....:     return [1]
....: [x for x in range(5) if x in a()]
....: 
Hey
Hey
Hey
Hey
Hey
[1]
```

What you want to do is something like `set(self).difference(self.closed_interval(self.bottom(), m))`

There is also a broken doctest in `hasse_diagram.py`

Oh. And I am just noticing that your function does not seem to be recursive at all: you can replace the recursion by a loop ! First create a copy of self, and at each turn of the loop remove some vertices from the copy you work on.

Nathann



---

archive/issue_comments_230550.json:
```json
{
    "body": "<a id='comment:5'>Comment 5:</a>\nReplying to [@nathanncohen](#comment%3A4):\n\n> Please, try to make your code a bit better-looking:\n\nOK, I'll try. I was thinkig about some kind of \"short-circuit test\" first: start with trivial ways to see that poset surely has not the property we are looking for. But your code example is cleaner.\n\n> By the way it is very unpleasant to build the list of upper covers when all you want to do is count its length. This is just a call to `in_degree` in the hasse diagram ! \n\nI need the list. It starts with `x=give_an_array(y)` but if it's length is exactly one, then continues with `z=x[0]`. Or do you mean optimizing it so that if code founds out that `len(self.upper_covers(m)` is at least 2, it returns False?\n\n> Also, you cannot write things like that in Sage code\n> \n> ```\n> [x for x in self if not x in self.closed_interval(self.bottom(), m)]\n> ```\n> \n> Here is why:\n\nUh, I somehow thinked that it would be optimized out. But of course it can not be done. I will correct this.\n\n> There is also a broken doctest in `hasse_diagram.py`\n\n?? I didn't touch it, just deprecated a function.\n\n> I also see that you compute 'subposet' very often, and I wonder if you should not compute subgraphs instead, as I expect that it is much more efficient (I beware of the `UniqueRepresentation` stuff)\n\n> Oh. And I am just noticing that your function does not seem to be recursive at all: you can replace the recursion by a loop ! First create a copy of self, and at each turn of the loop remove some vertices from the copy you work on.\n\nHmm... First call to `subposet` can be changed to subgraph and to search of element with in-degree zero.\n\nAnd yes, this can be also changed to direct loop without recursion. Actually I just copied the algorithm without thinking speed; in any case this should now be almost `O(n)` instead of `O(n^3)` in current version.\n\nBut elements can not be removed from poset; vertices can be removed from graph (with right internal implementation). I guess it is faster that way; only code might seem slightly complicated.\n\nThanks for comments! I'll continue with these later.",
    "created_at": "2014-10-20T12:27:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230550",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:5'>Comment 5:</a>
Replying to [@nathanncohen](#comment%3A4):

> Please, try to make your code a bit better-looking:

OK, I'll try. I was thinkig about some kind of "short-circuit test" first: start with trivial ways to see that poset surely has not the property we are looking for. But your code example is cleaner.

> By the way it is very unpleasant to build the list of upper covers when all you want to do is count its length. This is just a call to `in_degree` in the hasse diagram ! 

I need the list. It starts with `x=give_an_array(y)` but if it's length is exactly one, then continues with `z=x[0]`. Or do you mean optimizing it so that if code founds out that `len(self.upper_covers(m)` is at least 2, it returns False?

> Also, you cannot write things like that in Sage code
> 
> ```
> [x for x in self if not x in self.closed_interval(self.bottom(), m)]
> ```
> 
> Here is why:

Uh, I somehow thinked that it would be optimized out. But of course it can not be done. I will correct this.

> There is also a broken doctest in `hasse_diagram.py`

?? I didn't touch it, just deprecated a function.

> I also see that you compute 'subposet' very often, and I wonder if you should not compute subgraphs instead, as I expect that it is much more efficient (I beware of the `UniqueRepresentation` stuff)

> Oh. And I am just noticing that your function does not seem to be recursive at all: you can replace the recursion by a loop ! First create a copy of self, and at each turn of the loop remove some vertices from the copy you work on.

Hmm... First call to `subposet` can be changed to subgraph and to search of element with in-degree zero.

And yes, this can be also changed to direct loop without recursion. Actually I just copied the algorithm without thinking speed; in any case this should now be almost `O(n)` instead of `O(n^3)` in current version.

But elements can not be removed from poset; vertices can be removed from graph (with right internal implementation). I guess it is faster that way; only code might seem slightly complicated.

Thanks for comments! I'll continue with these later.



---

archive/issue_comments_230551.json:
```json
{
    "body": "<a id='comment:6'>Comment 6:</a>\n> I need the list.\n\nNot there\n\n```\nlen([e for e in self if len(self.lower_covers(e))==1])\n```\n\nnor there\n\n```\nif len(self.upper_covers(m))==1:\n```\n\nnor there\n\n```\nif len(M_.minimal_elements()) > 1:\n```\n\n> It starts with `x=give_an_array(y)` but if it's length is exactly one, then continues with `z=x[0]`. Or do you mean optimizing it so that if code founds out that `len(self.upper_covers(m)` is at least 2, it returns False?\n\nI have not read the algorithm closely yet, I do not know what it does exactly. There are places in the code, however, where those lists are created only to compute their length, e.g. above.\n\n> Uh, I somehow thinked that it would be optimized out. But of course it can not be done. I will correct this.\n\nPython is the worst language ever. It is a script. I hate scripts.\n\n> ?? I didn't touch it, just deprecated a function.\n\nyes yes, but the deprecation breaks the tests. Run the tests and see ! It is trivial, however, you probably only need to fix the output (which now contains the deprecation warning).\n\n> Thanks for comments! I'll continue with these later.\n\nGood luck ! `:-)`\n\nNathann",
    "created_at": "2014-10-20T12:32:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230551",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:6'>Comment 6:</a>
> I need the list.

Not there

```
len([e for e in self if len(self.lower_covers(e))==1])
```

nor there

```
if len(self.upper_covers(m))==1:
```

nor there

```
if len(M_.minimal_elements()) > 1:
```

> It starts with `x=give_an_array(y)` but if it's length is exactly one, then continues with `z=x[0]`. Or do you mean optimizing it so that if code founds out that `len(self.upper_covers(m)` is at least 2, it returns False?

I have not read the algorithm closely yet, I do not know what it does exactly. There are places in the code, however, where those lists are created only to compute their length, e.g. above.

> Uh, I somehow thinked that it would be optimized out. But of course it can not be done. I will correct this.

Python is the worst language ever. It is a script. I hate scripts.

> ?? I didn't touch it, just deprecated a function.

yes yes, but the deprecation breaks the tests. Run the tests and see ! It is trivial, however, you probably only need to fix the output (which now contains the deprecation warning).

> Thanks for comments! I'll continue with these later.

Good luck ! `:-)`

Nathann



---

archive/issue_comments_230552.json:
```json
{
    "body": "<a id='comment:7'>Comment 7:</a>\nIf I convert this to loop, I must have a working copy on Hasse diagram. Do I then still have linear extension? I must find a minimal element of subposet containing only meet-irreducible elements, i.e. a meet-irreducible element that is not greater than any other meet-irreducible element. For a poset `P` I can found it just looping throught `P` --- it will give elements by (some) linear extension.\n\nIn other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?\n\nI forgot one place where `minimal_elements()` was computed twice. Otherwise there is no unneeded lists generated in loop.",
    "created_at": "2014-10-20T15:17:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230552",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:7'>Comment 7:</a>
If I convert this to loop, I must have a working copy on Hasse diagram. Do I then still have linear extension? I must find a minimal element of subposet containing only meet-irreducible elements, i.e. a meet-irreducible element that is not greater than any other meet-irreducible element. For a poset `P` I can found it just looping throught `P` --- it will give elements by (some) linear extension.

In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?

I forgot one place where `minimal_elements()` was computed twice. Otherwise there is no unneeded lists generated in loop.



---

archive/issue_comments_230553.json:
```json
{
    "body": "<a id='comment:8'>Comment 8:</a>\nHello !\n\n> In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?\n\nHmmmmm... If the vertex set consists of integers this will not happens, but is that really a problem ? You can also store and manage the list of vertices yourself. Or rename the set of points.\n\n> I forgot one place where `minimal_elements()` was computed twice. Otherwise there is no unneeded lists generated in loop.\n\nWhat about this ?\n\n```\nlen([e for e in self if len(self.lower_covers(e))==1])\nif len(self.upper_covers(m))==1:\nif len(M_.minimal_elements()) > 1:\n```\n\nnathann",
    "created_at": "2014-10-20T15:21:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230553",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:8'>Comment 8:</a>
Hello !

> In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?

Hmmmmm... If the vertex set consists of integers this will not happens, but is that really a problem ? You can also store and manage the list of vertices yourself. Or rename the set of points.

> I forgot one place where `minimal_elements()` was computed twice. Otherwise there is no unneeded lists generated in loop.

What about this ?

```
len([e for e in self if len(self.lower_covers(e))==1])
if len(self.upper_covers(m))==1:
if len(M_.minimal_elements()) > 1:
```

nathann



---

archive/issue_comments_230554.json:
```json
{
    "body": "<a id='comment:9'>Comment 9:</a>\nReplying to [@nathanncohen](#comment%3A8):\n> Hello !\n> \n> > In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?\n\n> \n> Hmmmmm... If the vertex set consists of integers this will not happens, but is that really a problem ? You can also store and manage the list of vertices yourself. Or rename the set of points.\n\nHasse diagram has always integers `0,...,n-1` as labels. But I don't quite get this: if I write code that manages list of vertex labels, I am doing code that posets code already does.\n\nActually I think that I will start discussion about this on sage-devel.",
    "created_at": "2014-10-20T16:50:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230554",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:9'>Comment 9:</a>
Replying to [@nathanncohen](#comment%3A8):
> Hello !
> 
> > In other words: If `G.vertices()` prints `..., a, ..., b, ...`, can it after `D.delete_edges(...)` print  `..., b, ..., a, ...`? If not, is this guaranteed behaviour in following versions of Sage?

> 
> Hmmmmm... If the vertex set consists of integers this will not happens, but is that really a problem ? You can also store and manage the list of vertices yourself. Or rename the set of points.

Hasse diagram has always integers `0,...,n-1` as labels. But I don't quite get this: if I write code that manages list of vertex labels, I am doing code that posets code already does.

Actually I think that I will start discussion about this on sage-devel.



---

archive/issue_comments_230555.json:
```json
{
    "body": "<a id='comment:10'>Comment 10:</a>\nTravis: This is an old ticket that has been lying for two years. What you think about adding this as a recursive function? I think that it is still better than not having this at all.",
    "created_at": "2016-04-12T10:41:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230555",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:10'>Comment 10:</a>
Travis: This is an old ticket that has been lying for two years. What you think about adding this as a recursive function? I think that it is still better than not having this at all.



---

archive/issue_events_227559.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2016-04-13T13:40:55Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "milestone_number": null,
    "milestone_title": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227559"
}
```



---

archive/issue_events_227560.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2016-04-13T13:40:55Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "milestone_number": null,
    "milestone_title": "sage-7.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227560"
}
```



---

archive/issue_comments_230556.json:
```json
{
    "body": "<a id='comment:11'>Comment 11:</a>\nNeeds a rebase from the latest beta, but I will review this.",
    "created_at": "2016-04-13T13:40:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230556",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:11'>Comment 11:</a>
Needs a rebase from the latest beta, but I will review this.



---

archive/issue_comments_230557.json:
```json
{
    "body": "Changed commit from **[d69e73a](https://github.com/sagemath/sagetrac-mirror/commit/d69e73a0a0a655e4e1595a77cda807ccb017fb02)** to **[9a86b0a](https://github.com/sagemath/sagetrac-mirror/commit/9a86b0acba7649ecffe0c61bf6b4404bb72283e8)**",
    "created_at": "2016-04-19T07:40:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230557",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[d69e73a](https://github.com/sagemath/sagetrac-mirror/commit/d69e73a0a0a655e4e1595a77cda807ccb017fb02)** to **[9a86b0a](https://github.com/sagemath/sagetrac-mirror/commit/9a86b0acba7649ecffe0c61bf6b4404bb72283e8)**



---

archive/issue_comments_230558.json:
```json
{
    "body": "<a id='comment:12'>Comment 12:</a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9a86b0acba7649ecffe0c61bf6b4404bb72283e8\">9a86b0a</a></td><td><code>Merged with latest beta</code></td></tr></table>\n",
    "created_at": "2016-04-19T07:40:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230558",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:12'>Comment 12:</a>
Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9a86b0acba7649ecffe0c61bf6b4404bb72283e8">9a86b0a</a></td><td><code>Merged with latest beta</code></td></tr></table>




---

archive/issue_comments_230559.json:
```json
{
    "body": "<a id='comment:13'>Comment 13:</a>\nMerged, but I am re-reading the code, compiling and testing. Not ready for review yet.",
    "created_at": "2016-04-19T07:41:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230559",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:13'>Comment 13:</a>
Merged, but I am re-reading the code, compiling and testing. Not ready for review yet.



---

archive/issue_comments_230560.json:
```json
{
    "body": "Changed commit from **[9a86b0a](https://github.com/sagemath/sagetrac-mirror/commit/9a86b0acba7649ecffe0c61bf6b4404bb72283e8)** to **[db89e46](https://github.com/sagemath/sagetrac-mirror/commit/db89e467f8ae6d7ce2c54b55c1737664ea7c5ce3)**",
    "created_at": "2019-11-23T20:37:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230560",
    "user": "https://github.com/fchapoton"
}
```

Changed commit from **[9a86b0a](https://github.com/sagemath/sagetrac-mirror/commit/9a86b0acba7649ecffe0c61bf6b4404bb72283e8)** to **[db89e46](https://github.com/sagemath/sagetrac-mirror/commit/db89e467f8ae6d7ce2c54b55c1737664ea7c5ce3)**



---

archive/issue_comments_230561.json:
```json
{
    "body": "Changed branch from **[u/jmantysalo/poset__faster_is_distributive_lattice](https://github.com/sagemath/sagetrac-mirror/tree/u/jmantysalo/poset__faster_is_distributive_lattice)** to **[public/poset__faster_is_distributive_lattice](https://github.com/sagemath/sagetrac-mirror/tree/public/poset__faster_is_distributive_lattice)**",
    "created_at": "2019-11-23T20:37:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230561",
    "user": "https://github.com/fchapoton"
}
```

Changed branch from **[u/jmantysalo/poset__faster_is_distributive_lattice](https://github.com/sagemath/sagetrac-mirror/tree/u/jmantysalo/poset__faster_is_distributive_lattice)** to **[public/poset__faster_is_distributive_lattice](https://github.com/sagemath/sagetrac-mirror/tree/public/poset__faster_is_distributive_lattice)**



---

archive/issue_comments_230562.json:
```json
{
    "body": "<a id='comment:14'>Comment 14:</a>\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/44358354b8a3166626a46e43713977d13f54f122\">4435835</a></td><td><code>Merge branch 'u/jmantysalo/poset__faster_is_distributive_lattice' in 9.0.b6</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/db89e467f8ae6d7ce2c54b55c1737664ea7c5ce3\">db89e46</a></td><td><code>some enhancements</code></td></tr></table>\n",
    "created_at": "2019-11-23T20:37:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230562",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:14'>Comment 14:</a>
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/44358354b8a3166626a46e43713977d13f54f122">4435835</a></td><td><code>Merge branch 'u/jmantysalo/poset__faster_is_distributive_lattice' in 9.0.b6</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/db89e467f8ae6d7ce2c54b55c1737664ea7c5ce3">db89e46</a></td><td><code>some enhancements</code></td></tr></table>




---

archive/issue_comments_230563.json:
```json
{
    "body": "<a id='comment:15'>Comment 15:</a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f5416f799262d0540e61f0b337d900cc8e776bff\">f5416f7</a></td><td><code>fix</code></td></tr></table>\n",
    "created_at": "2019-11-23T20:47:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230563",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:15'>Comment 15:</a>
Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f5416f799262d0540e61f0b337d900cc8e776bff">f5416f7</a></td><td><code>fix</code></td></tr></table>




---

archive/issue_comments_230564.json:
```json
{
    "body": "Changed commit from **[db89e46](https://github.com/sagemath/sagetrac-mirror/commit/db89e467f8ae6d7ce2c54b55c1737664ea7c5ce3)** to **[f5416f7](https://github.com/sagemath/sagetrac-mirror/commit/f5416f799262d0540e61f0b337d900cc8e776bff)**",
    "created_at": "2019-11-23T20:47:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/17173#issuecomment-230564",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[db89e46](https://github.com/sagemath/sagetrac-mirror/commit/db89e467f8ae6d7ce2c54b55c1737664ea7c5ce3)** to **[f5416f7](https://github.com/sagemath/sagetrac-mirror/commit/f5416f799262d0540e61f0b337d900cc8e776bff)**



---

archive/issue_events_227561.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-12-29T01:35:57Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/17173",
    "milestone_number": null,
    "milestone_title": "sage-7.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/17173#event-227561"
}
```
