# Issue 23756: Translate Mathematica's Rule (->) operator back to Sage, possibly translating the related conditions.

Issue created by migration from Trac.

Original creator: charpent

Original creation time: 2017-10-08 19:53:08

Keywords: symbolics, mathematica, interfaces

See [this post](https://groups.google.com/d/msg/sage-support/cGpJmhps3lI/UA6kgHAkAgAJ) for example and (some) justification.

Short story : calling `mathematica.Solve()` from Sage does work (and can solve some examples out of the reach of the current Sage's `solve()`), but the result can't be translated back to Sage.

It turns out that `mathematica.Solve()` returns (a vector or array of) Rule expression(s) (`variable -> expression`, meaning `Rule[variable, expression]` in Mathematica), which is currently not translated back to Sage.

In this case, I think that a "reasonable" translation is `variable == expression`, but I do not know Mathematica well enough to know if other translations, in other contexts, would be preferable...

Note that, in order to fully translate all `mathematica.Solve()` answers, we also need to translate the conditions that can be added to these solutions. This would need some conditional expression or operator, currently nonexistent in Sage. This is also true for some sympy answers, which use a similar system.


---

Comment by rws created at 2017-10-09 13:42:36

Since recently you can write 

```
sage: rel = x == cases(((x<0,exp(x)),(x>=0,2^x)))
sage: rel
x == cases(((x < 0, e^x), (x >= 0, 2^x)))
sage: rel.rhs().subs(x == -1)
e^(-1)
sage: rel.rhs().subs(x == 1)
2
```

This helps in constructing combined conditions. However it would be nice if one could express a condition using boolean notation. So this would benefit from such operators as well. For convenience I would propose functions with the same name as in SymPy:

```
In [28]: And(Eq(x,0), Eq(x,1))
Out[28]: x = 0 ∧ x = 1

In [29]: Or(Eq(x,0), Eq(x,1))
Out[29]: x = 0 ∨ x = 1

In [30]: Not(Eq(x,0))
Out[30]: x ≠ 0
```



---

Comment by charpent created at 2017-10-09 14:01:42

Replying to [comment:1 rws]:
> Since recently you can write 
> {{{
> sage: rel = x == cases(((x<0,exp(x)),(x>=0,2^x)))

Huh ? That doesn't work for me (in 8.1.beta6) :


```
sage: version
<function version at 0x7f0559248938>
sage: version()
'SageMath version 8.1.beta6, Release Date: 2017-09-21'
sage: rel = x == cases(((x<0,exp(x)),(x>=0,2^x)))
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-6-7efd8dce6cab> in <module>()
----> 1 rel = x == cases(((x<Integer(0),exp(x)),(x>=Integer(0),Integer(2)**x)))

NameError: name 'cases' is not defined
```


Is that an optional or experimental package ?


---

Comment by rws created at 2017-10-09 14:11:59

`SageMath version 8.1.beta7, Release Date: 2017-10-03`


---

Comment by charpent created at 2017-10-09 14:22:33

Replying to [comment:3 rws]:
> `SageMath version 8.1.beta7, Release Date: 2017-10-03`

Aha ! Compiling it //right// **now**...

Thanks !


---

Comment by charpent created at 2017-10-09 15:35:58

Replying to [comment:1 rws]:
> However it would be nice if one could express a condition using boolean notation. So this would benefit from such operators as well. For convenience I would propose functions with the same name as in SymPy:
> {{{
> In [28]: And(Eq(x,0), Eq(x,1))
> Out[28]: x = 0 ∧ x = 1
> 
> In [29]: Or(Eq(x,0), Eq(x,1))
> Out[29]: x = 0 ∨ x = 1
> 
> In [30]: Not(Eq(x,0))
> Out[30]: x ≠ 0
> }}}

Hmmm... Would you agree with :

```
def And(*args):
    return(reduce(lambda a,b:a and b, args, True)

def Or(*args):
    return(reduce(lambda a,b a or b, args, False)
```



---

Comment by rws created at 2017-10-09 15:49:35

No, symbolic functions are needed so that they can be mixed with symbolic relations without immediately being evaluated. But that's not much more complicated.


---

Comment by mkoeppe created at 2021-07-06 02:54:34

We now have `ConditionSet`, `ImageSet`, see #24176
