# Issue 16849: GenericGraph's documentation, __eq__, and __hash__ out of sync

archive/issues_016849.json:
```json
{
    "body": "CC:  simonking\n\n1. The documentation of `GenericGraph.__eq__` contains \"For equality, ..., output the same vertex list (in order), ...\". However, since [b59285e6](http://git.sagemath.org/sage.git/commit/?id=b59285e6f9b91f25ee2c77bfe940a45c51b58f80) (Trac #14806: Immutable graph backend), the order of the vertices is no longer checked. So either that check should be reintroduced, or the documentation should be updated.\n\n   The list returned by `.vertices()` is sorted, so that checking the order only affects the result in rare cases. Hence I think updating the documentation should be okay, even while it is technically backwards incompatible.\n\n2. While `GenericGraph.__eq__` no longer takes the ordering of vertices into account, `GenericGraph.__hash__` still does. Consequently graphs that compare equal can have different hashes.\n\n3. For graphs that are not weighted, `GenericGraph.__eq__` ignores the edge labels, while `GenericGraph.__hash__` does not.\n\nItem 3 is most easily shown:\n\n```\nsage: G1 = Graph({0: {1: 'edge label A'}}, immutable=True)\nsage: G2 = Graph({0: {1: 'edge label B'}}, immutable=True)\nsage: G1 == G2\nTrue\nsage: G1.__hash__() == G2.__hash__()\nFalse\n```\n\n\nFor items 2 and 3, here is some contrived but deterministic code showing that the order is not checked in `.__eq__`, while it is in `.__hash__`:\n\n```python\nimport functools\n@functools.total_ordering\nclass C:\n    def __init__(self, val, reverse):\n        self.val = val\n        self.reverse = reverse\n    def __repr__(self):\n        return 'C(%r, %r)' % (self.val, self.reverse)\n    def __hash__(self):\n        return hash(self.val)\n    def __eq__(self, other):\n        return self.val == other.val\n    def __lt__(self, other):\n        if self.reverse:\n            return self.val > other.val\n        else:\n            return self.val < other.val\nG1 = Graph({C(0, False): [], C(1, False): []}, immutable=True)\nG2 = Graph({C(0, True ): [], C(1, True ): []}, immutable=True)\n```\n\n\n```\nsage: [G1.vertices(), G2.vertices()]\n[[C(0, False), C(1, False)], [C(1, True), C(0, True)]]\nsage: G1 == G2\nTrue\nsage: hash(G1) == hash(G2)\nFalse\n```\n\n\nThe trick in the code above is to obtain tuples (x1, y1) and (x2, y2) that compare equal but sort differently. Above this is achieved explicitly using the argument `reverse`. However, this can also happen by coincidence, as the code below shows. Here the inequality comparison falls back to comparison of ids, so we just generate objects until the ids are in an unlucky order.\n\n```python\nfrom random import randint\nfrom sage.graphs.graph import Graph\n\nclass Foo:\n    def __init__(self, b):\n        self.b = b\n    def __eq__(self, other):\n        return self.b == other.b\n    def __hash__(self):\n        return hash(self.b)\n    def __repr__(self):\n        return \"foo(%r)\" % (self.b,)\n\ndef gen(f):\n    print \"* Trying to obtain res = ((f(0),f(1)), (f(0),f(1))) with\\n\" \\\n          \"  (not res[0][0] < res[0][1]) and (res[1][0] < res[1][1]).\"\n    candidates = [[],[]]\n    res = [None, None]\n    while res[False] is None or res[True] is None:\n        bit = randint(0,1)\n        candidates[bit].append( f(bit) )\n        for x in candidates[0]:\n            for y in candidates[1]:\n                res[bool(x < y)] = (x,y)\n    print \"* Succeeded after %i random picks.\" \\\n           % (len(candidates[0]) + len(candidates[1]),)\n    print (\"* res[0] = %r\\n  res[1] = %r\") % (res[0], res[1])\n    return res\n\ndef doit(f):\n    print\n    print \"* f = %r\" % (f,)\n    res = gen(f)\n    print \"* For i=0 and i=1 creating graph G[i] with vertices \" \\\n          \"res[i] and no edges\"\n    G = [Graph(dict((x, []) for x in res[bit]), immutable = True)\n         for bit in range(2)]\n    print \"* G[0] = %r\\n  G[1] = %r\" % (G[0], G[1])\n    print \"* G[0].vertices() = %r\\n  G[1].vertices() = %r\" % \\\n            (G[0].vertices(), G[1].vertices())\n    print \"*         res[0] == res[1]         : %r\" % \\\n            (res[0] == res[1],)\n    print \"* sorted(res[0]) == sorted(res[1]) : %r\" % \\\n            (sorted(res[0]) == sorted(res[1]),)\n    print \"*           G[0] == G[1]           : %r\" % (G[0] == G[1],)\n    print \"*     hash(G[0]) == hash(G[1])     : %r\" % \\\n            (hash(G[0]) == hash(G[1]),)\n    print\n```\n\n\n```\nsage: doit(Foo)\n\n* f = <class __main__.Foo at 0xacb694ac>\n* Trying to obtain res = ((f(0),f(1)), (f(0),f(1))) with\n  (not res[0][0] < res[0][1]) and (res[1][0] < res[1][1]).\n* Succeeded after 6 random picks.\n* res[0] = (foo(0), foo(1))\n  res[1] = (foo(0), foo(1))\n* For i=0 and i=1 creating graph G[i] with vertices res[i] and no edges\n* G[0] = Graph on 2 vertices\n  G[1] = Graph on 2 vertices\n* G[0].vertices() = [foo(1), foo(0)]\n  G[1].vertices() = [foo(0), foo(1)]\n*         res[0] == res[1]         : True\n* sorted(res[0]) == sorted(res[1]) : False\n*           G[0] == G[1]           : True\n*     hash(G[0]) == hash(G[1])     : False\n\n```\n\n\nThe custom class `Foo` above is not necessary:\n\n```\nsage: doit(lambda x: sage.graphs.graph.Graph(x, immutable=True))\n\n* f = <function <lambda> at 0xac556b1c>\n* Trying to obtain res = ((f(0),f(1)), (f(0),f(1))) with\n  (not res[0][0] < res[0][1]) and (res[1][0] < res[1][1]).\n* Succeeded after 4 random picks.\n* res[0] = (Graph on 0 vertices, Graph on 1 vertex)\n  res[1] = (Graph on 0 vertices, Graph on 1 vertex)\n* For i=0 and i=1 creating graph G[i] with vertices res[i] and no edges\n* G[0] = Graph on 2 vertices\n  G[1] = Graph on 2 vertices\n* G[0].vertices() = [Graph on 1 vertex, Graph on 0 vertices]\n  G[1].vertices() = [Graph on 0 vertices, Graph on 1 vertex]\n*         res[0] == res[1]         : True\n* sorted(res[0]) == sorted(res[1]) : False\n*           G[0] == G[1]           : True\n*     hash(G[0]) == hash(G[1])     : False\n\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/17086\n\n",
    "created_at": "2014-10-02T00:10:23Z",
    "labels": [
        "component: graph theory",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "GenericGraph's documentation, __eq__, and __hash__ out of sync",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16849",
    "user": "https://trac.sagemath.org/admin/accounts/users/emassop"
}
```
CC:  simonking

1. The documentation of `GenericGraph.__eq__` contains "For equality, ..., output the same vertex list (in order), ...". However, since [b59285e6](http://git.sagemath.org/sage.git/commit/?id=b59285e6f9b91f25ee2c77bfe940a45c51b58f80) (Trac #14806: Immutable graph backend), the order of the vertices is no longer checked. So either that check should be reintroduced, or the documentation should be updated.

   The list returned by `.vertices()` is sorted, so that checking the order only affects the result in rare cases. Hence I think updating the documentation should be okay, even while it is technically backwards incompatible.

2. While `GenericGraph.__eq__` no longer takes the ordering of vertices into account, `GenericGraph.__hash__` still does. Consequently graphs that compare equal can have different hashes.

3. For graphs that are not weighted, `GenericGraph.__eq__` ignores the edge labels, while `GenericGraph.__hash__` does not.

Item 3 is most easily shown:

```
sage: G1 = Graph({0: {1: 'edge label A'}}, immutable=True)
sage: G2 = Graph({0: {1: 'edge label B'}}, immutable=True)
sage: G1 == G2
True
sage: G1.__hash__() == G2.__hash__()
False
```


For items 2 and 3, here is some contrived but deterministic code showing that the order is not checked in `.__eq__`, while it is in `.__hash__`:

```python
import functools
@functools.total_ordering
class C:
    def __init__(self, val, reverse):
        self.val = val
        self.reverse = reverse
    def __repr__(self):
        return 'C(%r, %r)' % (self.val, self.reverse)
    def __hash__(self):
        return hash(self.val)
    def __eq__(self, other):
        return self.val == other.val
    def __lt__(self, other):
        if self.reverse:
            return self.val > other.val
        else:
            return self.val < other.val
G1 = Graph({C(0, False): [], C(1, False): []}, immutable=True)
G2 = Graph({C(0, True ): [], C(1, True ): []}, immutable=True)
```


```
sage: [G1.vertices(), G2.vertices()]
[[C(0, False), C(1, False)], [C(1, True), C(0, True)]]
sage: G1 == G2
True
sage: hash(G1) == hash(G2)
False
```


The trick in the code above is to obtain tuples (x1, y1) and (x2, y2) that compare equal but sort differently. Above this is achieved explicitly using the argument `reverse`. However, this can also happen by coincidence, as the code below shows. Here the inequality comparison falls back to comparison of ids, so we just generate objects until the ids are in an unlucky order.

```python
from random import randint
from sage.graphs.graph import Graph

class Foo:
    def __init__(self, b):
        self.b = b
    def __eq__(self, other):
        return self.b == other.b
    def __hash__(self):
        return hash(self.b)
    def __repr__(self):
        return "foo(%r)" % (self.b,)

def gen(f):
    print "* Trying to obtain res = ((f(0),f(1)), (f(0),f(1))) with\n" \
          "  (not res[0][0] < res[0][1]) and (res[1][0] < res[1][1])."
    candidates = [[],[]]
    res = [None, None]
    while res[False] is None or res[True] is None:
        bit = randint(0,1)
        candidates[bit].append( f(bit) )
        for x in candidates[0]:
            for y in candidates[1]:
                res[bool(x < y)] = (x,y)
    print "* Succeeded after %i random picks." \
           % (len(candidates[0]) + len(candidates[1]),)
    print ("* res[0] = %r\n  res[1] = %r") % (res[0], res[1])
    return res

def doit(f):
    print
    print "* f = %r" % (f,)
    res = gen(f)
    print "* For i=0 and i=1 creating graph G[i] with vertices " \
          "res[i] and no edges"
    G = [Graph(dict((x, []) for x in res[bit]), immutable = True)
         for bit in range(2)]
    print "* G[0] = %r\n  G[1] = %r" % (G[0], G[1])
    print "* G[0].vertices() = %r\n  G[1].vertices() = %r" % \
            (G[0].vertices(), G[1].vertices())
    print "*         res[0] == res[1]         : %r" % \
            (res[0] == res[1],)
    print "* sorted(res[0]) == sorted(res[1]) : %r" % \
            (sorted(res[0]) == sorted(res[1]),)
    print "*           G[0] == G[1]           : %r" % (G[0] == G[1],)
    print "*     hash(G[0]) == hash(G[1])     : %r" % \
            (hash(G[0]) == hash(G[1]),)
    print
```


```
sage: doit(Foo)

* f = <class __main__.Foo at 0xacb694ac>
* Trying to obtain res = ((f(0),f(1)), (f(0),f(1))) with
  (not res[0][0] < res[0][1]) and (res[1][0] < res[1][1]).
* Succeeded after 6 random picks.
* res[0] = (foo(0), foo(1))
  res[1] = (foo(0), foo(1))
* For i=0 and i=1 creating graph G[i] with vertices res[i] and no edges
* G[0] = Graph on 2 vertices
  G[1] = Graph on 2 vertices
* G[0].vertices() = [foo(1), foo(0)]
  G[1].vertices() = [foo(0), foo(1)]
*         res[0] == res[1]         : True
* sorted(res[0]) == sorted(res[1]) : False
*           G[0] == G[1]           : True
*     hash(G[0]) == hash(G[1])     : False

```


The custom class `Foo` above is not necessary:

```
sage: doit(lambda x: sage.graphs.graph.Graph(x, immutable=True))

* f = <function <lambda> at 0xac556b1c>
* Trying to obtain res = ((f(0),f(1)), (f(0),f(1))) with
  (not res[0][0] < res[0][1]) and (res[1][0] < res[1][1]).
* Succeeded after 4 random picks.
* res[0] = (Graph on 0 vertices, Graph on 1 vertex)
  res[1] = (Graph on 0 vertices, Graph on 1 vertex)
* For i=0 and i=1 creating graph G[i] with vertices res[i] and no edges
* G[0] = Graph on 2 vertices
  G[1] = Graph on 2 vertices
* G[0].vertices() = [Graph on 1 vertex, Graph on 0 vertices]
  G[1].vertices() = [Graph on 0 vertices, Graph on 1 vertex]
*         res[0] == res[1]         : True
* sorted(res[0]) == sorted(res[1]) : False
*           G[0] == G[1]           : True
*     hash(G[0]) == hash(G[1])     : False

```


Issue created by migration from https://trac.sagemath.org/ticket/17086





---

archive/issue_comments_222729.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-10-02T07:41:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222729",
    "user": "https://github.com/nathanncohen"
}
```

New commits:



---

archive/issue_comments_222730.json:
```json
{
    "body": "Hello !\n\nThank you for this 'Counter' thing, I did not know that it existed `^^;`\n\n1) About `self.edge_iterator(labels = self._weighted)`:\n\nYou can have graphs with edge labels for which _weighted is not True\n\n\n```\nsage: Graph([(1,2,\"Hey\")])._weighted\nFalse\nsage: Graph([(1,2,\"Hey\")],immutable=True)._weighted\nFalse\n```\n\n\nI do not think that this 'weighted' notion makes a lot of sense anyway, perhaps we should remove it. Either way it is probably best to set 'labels' to `True` anytime.\n\n2) Perhaps I do not understand what your tests do, but even when the graph is immutable the list of vertices returned by `.vertices()` should be sorted. Do you have a counterexample to that ?\n\n  Indeed, we cannot assume that sorting a list produces a unique sorted list (because the order is not always a total order) but that list, however, should be sorted.\n\n  This, because even when the immutable graph is created, the vertices are labelled using the order returned by `.vertices()`. So I hope that you found no bad behaviour there.\n\n  But indeed, wrapping it with a frozenset if the right thing to do.\n\n3) Technically, you do not need to add `._is_weighted` in the hash function, as graphs with different values for `._is_weighted` are nonequal anyway. But that does not hurt either.\n\n4) `O_O`\n\n\n```\nsage: G1 = Graph({0: {1: 'edge label A'}})                \nsage: G2 = Graph({0: {1: 'edge label B'}})                \nsage: G1 == G2                            \nTrue\n```\n\n\nThis is *REALLY* bad ! Graphs with different labels should be non-equal !!! `O_O;;;;;`\n\nBut it seems that it has been like that forever... Gosh that's bad `O_o`\n\nHmmmm.. Now I understand why you added this `self._weighted` in the hash function `:-/`\n\nNathann",
    "created_at": "2014-10-02T08:08:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222730",
    "user": "https://github.com/nathanncohen"
}
```

Hello !

Thank you for this 'Counter' thing, I did not know that it existed `^^;`

1) About `self.edge_iterator(labels = self._weighted)`:

You can have graphs with edge labels for which _weighted is not True


```
sage: Graph([(1,2,"Hey")])._weighted
False
sage: Graph([(1,2,"Hey")],immutable=True)._weighted
False
```


I do not think that this 'weighted' notion makes a lot of sense anyway, perhaps we should remove it. Either way it is probably best to set 'labels' to `True` anytime.

2) Perhaps I do not understand what your tests do, but even when the graph is immutable the list of vertices returned by `.vertices()` should be sorted. Do you have a counterexample to that ?

  Indeed, we cannot assume that sorting a list produces a unique sorted list (because the order is not always a total order) but that list, however, should be sorted.

  This, because even when the immutable graph is created, the vertices are labelled using the order returned by `.vertices()`. So I hope that you found no bad behaviour there.

  But indeed, wrapping it with a frozenset if the right thing to do.

3) Technically, you do not need to add `._is_weighted` in the hash function, as graphs with different values for `._is_weighted` are nonequal anyway. But that does not hurt either.

4) `O_O`


```
sage: G1 = Graph({0: {1: 'edge label A'}})                
sage: G2 = Graph({0: {1: 'edge label B'}})                
sage: G1 == G2                            
True
```


This is *REALLY* bad ! Graphs with different labels should be non-equal !!! `O_O;;;;;`

But it seems that it has been like that forever... Gosh that's bad `O_o`

Hmmmm.. Now I understand why you added this `self._weighted` in the hash function `:-/`

Nathann



---

archive/issue_comments_222731.json:
```json
{
    "body": "Replying to [comment:3 ncohen]:\n\n> Thank you for this 'Counter' thing, I did not know that it existed `^^;`\n\nIt's shiny new Python 2.7 material :).\n\n\n\n> 1) About `self.edge_iterator(labels = self._weighted)`:\n> \n> You can have graphs with edge labels for which _weighted is not True\n> \n> {{{\n> sage: Graph([(1,2,\"Hey\")])._weighted\n> False\n> sage: Graph([(1,2,\"Hey\")],immutable=True)._weighted\n> False\n> }}}\n>\n> I do not think that this 'weighted' notion makes a lot of sense anyway, perhaps we should remove it. Either way it is probably best to set 'labels' to `True` anytime.\n\nIndeed you can set edge labels on unweighted graphs, but the documented behaviour is that they are ignored in `__eq__`: \"Note that graphs must be considered weighted, or Sage will not pay attention to edge label data in equality testing\". Whether edge labels *should* be checked or not, is a different question, that I would like to keep outside the scope of this ticket. Either way, when `__eq__` is true, the hashes have to be the same. So if `__eq__` ignores labels, then so should `__hash__`. I really see no point in ignoring edge labels in `__hash__` when they are not ignored in `__eq__`. I think that would just makes the hash weaker.\n\n\n\n> 2) Perhaps I do not understand what your tests do, but even when the graph is immutable the list of vertices returned by `.vertices()` should be sorted. Do you have a counterexample to that ?\n> \n>   Indeed, we cannot assume that sorting a list produces a unique sorted list (because the order is not always a total order) but that list, however, should be sorted.\n>\n>   This, because even when the immutable graph is created, the vertices are labelled using the order returned by `.vertices()`. So I hope that you found no bad behaviour there.\n> \n\nNo, I do not have a counter example. I might look into it, or not. Either way, I would like to restrict this ticket to the totally ordered case where the axioms for ordering use `is` and not `==`.\n\nWhen an `is`-based ordering does not respect `==`, such as Python's default ordering using `id`, you can have `a1==a2 and b1==b2` and `a1<b1 and a2>b2` at the same time. Within a single graph this cannot happen as there `a1==a2` implies `a1 is a2` (assuming that the given vertex labels are `==`-distinct). However, it *is* possible to construct *a pair* of graphs using `==`-equal vertex lists that nonetheless have distinct `.vertices()`. This is what happens above.\n\nIn the example using `class C`, I have explicitly constructed a comparison that gives such evil results. (Presently I have modified it to obey the axioms of an `is`-based ordering.) In the example using `class Foo`, I show that the problem also occurs with Python's default ordering. Since Python's default ordering depends on `id` over which you have no control, you need a bit of luck. The example using `lambda x: ...`, shows that the behaviour of `class Foo` occurs in the wild.\n\n>   But indeed, wrapping it with a frozenset if the right thing to do.\n\n:)\n\n\n\n> 3) Technically, you do not need to add `._is_weighted` in the hash function, as graphs with different values for `._is_weighted` are nonequal anyway. But that does not hurt either.\n\nIn `hash(..., self._is_weighted, ...)` I indeed included it redundantly.\n\n\n\n> 4) `O_O`\n> \n> {{{\n> sage: G1 = Graph({0: {1: 'edge label A'}})                \n> sage: G2 = Graph({0: {1: 'edge label B'}})                \n> sage: G1 == G2                            \n> True\n> }}}\n> \n> This is *REALLY* bad ! Graphs with different labels should be non-equal !!! `O_O;;;;;`\n>\n> But it seems that it has been like that forever... Gosh that's bad `O_o`\n\nAccording to the documentation the labels are ignored. Let's defer what is right(tm) to a different ticket.\n\n> Hmmmm.. Now I understand why you added this `self._weighted` in the hash function `:-/`\n\n:)",
    "created_at": "2014-10-02T11:56:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222731",
    "user": "https://trac.sagemath.org/admin/accounts/users/emassop"
}
```

Replying to [comment:3 ncohen]:

> Thank you for this 'Counter' thing, I did not know that it existed `^^;`

It's shiny new Python 2.7 material :).



> 1) About `self.edge_iterator(labels = self._weighted)`:
> 
> You can have graphs with edge labels for which _weighted is not True
> 
> {{{
> sage: Graph([(1,2,"Hey")])._weighted
> False
> sage: Graph([(1,2,"Hey")],immutable=True)._weighted
> False
> }}}
>
> I do not think that this 'weighted' notion makes a lot of sense anyway, perhaps we should remove it. Either way it is probably best to set 'labels' to `True` anytime.

Indeed you can set edge labels on unweighted graphs, but the documented behaviour is that they are ignored in `__eq__`: "Note that graphs must be considered weighted, or Sage will not pay attention to edge label data in equality testing". Whether edge labels *should* be checked or not, is a different question, that I would like to keep outside the scope of this ticket. Either way, when `__eq__` is true, the hashes have to be the same. So if `__eq__` ignores labels, then so should `__hash__`. I really see no point in ignoring edge labels in `__hash__` when they are not ignored in `__eq__`. I think that would just makes the hash weaker.



> 2) Perhaps I do not understand what your tests do, but even when the graph is immutable the list of vertices returned by `.vertices()` should be sorted. Do you have a counterexample to that ?
> 
>   Indeed, we cannot assume that sorting a list produces a unique sorted list (because the order is not always a total order) but that list, however, should be sorted.
>
>   This, because even when the immutable graph is created, the vertices are labelled using the order returned by `.vertices()`. So I hope that you found no bad behaviour there.
> 

No, I do not have a counter example. I might look into it, or not. Either way, I would like to restrict this ticket to the totally ordered case where the axioms for ordering use `is` and not `==`.

When an `is`-based ordering does not respect `==`, such as Python's default ordering using `id`, you can have `a1==a2 and b1==b2` and `a1<b1 and a2>b2` at the same time. Within a single graph this cannot happen as there `a1==a2` implies `a1 is a2` (assuming that the given vertex labels are `==`-distinct). However, it *is* possible to construct *a pair* of graphs using `==`-equal vertex lists that nonetheless have distinct `.vertices()`. This is what happens above.

In the example using `class C`, I have explicitly constructed a comparison that gives such evil results. (Presently I have modified it to obey the axioms of an `is`-based ordering.) In the example using `class Foo`, I show that the problem also occurs with Python's default ordering. Since Python's default ordering depends on `id` over which you have no control, you need a bit of luck. The example using `lambda x: ...`, shows that the behaviour of `class Foo` occurs in the wild.

>   But indeed, wrapping it with a frozenset if the right thing to do.

:)



> 3) Technically, you do not need to add `._is_weighted` in the hash function, as graphs with different values for `._is_weighted` are nonequal anyway. But that does not hurt either.

In `hash(..., self._is_weighted, ...)` I indeed included it redundantly.



> 4) `O_O`
> 
> {{{
> sage: G1 = Graph({0: {1: 'edge label A'}})                
> sage: G2 = Graph({0: {1: 'edge label B'}})                
> sage: G1 == G2                            
> True
> }}}
> 
> This is *REALLY* bad ! Graphs with different labels should be non-equal !!! `O_O;;;;;`
>
> But it seems that it has been like that forever... Gosh that's bad `O_o`

According to the documentation the labels are ignored. Let's defer what is right(tm) to a different ticket.

> Hmmmm.. Now I understand why you added this `self._weighted` in the hash function `:-/`

:)



---

archive/issue_comments_222732.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-02T12:07:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222732",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222733.json:
```json
{
    "body": "Yoooooooo !\n\n> It's shiny new Python 2.7 material :).\n\nNiiiiiiiiiice `:-P`\n\n> Indeed you can set edge labels on unweighted graphs, but the documented behaviour is that they are ignored in `__eq__`: \"Note that graphs must be considered weighted, or Sage will not pay attention to edge label data in equality testing\".\n\nWeird. I had no idea and expected something different. Well. Nothing wrong if it works as claimed, then `:-P`\n\n\n> Whether edge labels *should* be checked or not, is a different question, that I would like to keep outside the scope of this ticket.\n\nRight right. I just did not expect that and I thought it was a bug. I don't mind it if it is not.\n\n> Either way, when `__eq__` is true, the hashes have to be the same. So if `__eq__` ignores labels, then so should `__hash__`. I really see no point in ignoring edge labels in `__hash__` when they are not ignored in `__eq__`. I think that would just makes the hash weaker.\n\nOf course, what you do makes sense in that case.\n\n> No, I do not have a counter example. I might look into it, or not. Either way, I would like to restrict this ticket to the totally ordered case where the axioms for ordering use `is` and not `==`.\n> \n> When an `is`-based ordering does not respect `==`, such as Python's default ordering using `id`, you can have `a1==a2 and b1==b2` and `a1<b1 and a2>b2` at the same time. Within a single graph this cannot happen as there `a1==a2` implies `a1 is a2` (assuming that the given vertex labels are `==`-distinct). However, it *is* possible to construct *a pair* of graphs using `==`-equal vertex lists that nonetheless have distinct `.vertices()`. This is what happens above.\n\nOkay, it took me a while to understand but it seems that to you a 'is-based' ordering when comparison does not yield a total order, and is not necessarily agreeing with '=='. Why not. It has to work in this case too, anyway.\n\nDespite that, I call a list L 'sorted' when applying 'sorted' to L does not change L. Even if the ordering only makes sense to Python. And lists returned by `.vertices()`  should always be sorted in this way. I do not think that it is very bad if it does not hold, but that is how it is meant to work.\n\n> Since Python's default ordering depends on `id` over which you have no control, you need a bit of luck.\n\nI would not have complained even if you had build a class for which `<=` returns a random value `:-P`\n\n> In `hash(..., self._is_weighted, ...)` I indeed included it redundantly.\n\nYou were right.\n\n> According to the documentation the labels are ignored. Let's defer what is right(tm) to a different ticket.\n\nWell, I do not think it needs a different ticket. I was surprised, but that's as bad as it got. If it is documented I don't see anything wrong with it. Especially since `is_isomorphic` also ignores edges by default.\n\nThe only problem is this 'weighted' keyword. It does not have anything to do with weights, so the keyword is ill-chosen. This can be fixed in another ticket, but there is nothing really urgent to solve either.\n\nNathann\n----\nNew commits:",
    "created_at": "2014-10-02T12:13:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222733",
    "user": "https://github.com/nathanncohen"
}
```

Yoooooooo !

> It's shiny new Python 2.7 material :).

Niiiiiiiiiice `:-P`

> Indeed you can set edge labels on unweighted graphs, but the documented behaviour is that they are ignored in `__eq__`: "Note that graphs must be considered weighted, or Sage will not pay attention to edge label data in equality testing".

Weird. I had no idea and expected something different. Well. Nothing wrong if it works as claimed, then `:-P`


> Whether edge labels *should* be checked or not, is a different question, that I would like to keep outside the scope of this ticket.

Right right. I just did not expect that and I thought it was a bug. I don't mind it if it is not.

> Either way, when `__eq__` is true, the hashes have to be the same. So if `__eq__` ignores labels, then so should `__hash__`. I really see no point in ignoring edge labels in `__hash__` when they are not ignored in `__eq__`. I think that would just makes the hash weaker.

Of course, what you do makes sense in that case.

> No, I do not have a counter example. I might look into it, or not. Either way, I would like to restrict this ticket to the totally ordered case where the axioms for ordering use `is` and not `==`.
> 
> When an `is`-based ordering does not respect `==`, such as Python's default ordering using `id`, you can have `a1==a2 and b1==b2` and `a1<b1 and a2>b2` at the same time. Within a single graph this cannot happen as there `a1==a2` implies `a1 is a2` (assuming that the given vertex labels are `==`-distinct). However, it *is* possible to construct *a pair* of graphs using `==`-equal vertex lists that nonetheless have distinct `.vertices()`. This is what happens above.

Okay, it took me a while to understand but it seems that to you a 'is-based' ordering when comparison does not yield a total order, and is not necessarily agreeing with '=='. Why not. It has to work in this case too, anyway.

Despite that, I call a list L 'sorted' when applying 'sorted' to L does not change L. Even if the ordering only makes sense to Python. And lists returned by `.vertices()`  should always be sorted in this way. I do not think that it is very bad if it does not hold, but that is how it is meant to work.

> Since Python's default ordering depends on `id` over which you have no control, you need a bit of luck.

I would not have complained even if you had build a class for which `<=` returns a random value `:-P`

> In `hash(..., self._is_weighted, ...)` I indeed included it redundantly.

You were right.

> According to the documentation the labels are ignored. Let's defer what is right(tm) to a different ticket.

Well, I do not think it needs a different ticket. I was surprised, but that's as bad as it got. If it is documented I don't see anything wrong with it. Especially since `is_isomorphic` also ignores edges by default.

The only problem is this 'weighted' keyword. It does not have anything to do with weights, so the keyword is ill-chosen. This can be fixed in another ticket, but there is nothing really urgent to solve either.

Nathann
----
New commits:



---

archive/issue_comments_222734.json:
```json
{
    "body": "Hello again ! \n\nI see nothing wrong with your code, but I fear that I may be scared of your big doctest in a couple of years if I am still around.\n\nCould you make it more explicit, like \n\n    Equality and hash do not depend on ordering of vertices (i.e. `G==H` can be true even when `G.vertices()==H.vertices()` is `False`)\n\n\nThanks,\n\nNathann",
    "created_at": "2014-10-02T12:46:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222734",
    "user": "https://github.com/nathanncohen"
}
```

Hello again ! 

I see nothing wrong with your code, but I fear that I may be scared of your big doctest in a couple of years if I am still around.

Could you make it more explicit, like 

    Equality and hash do not depend on ordering of vertices (i.e. `G==H` can be true even when `G.vertices()==H.vertices()` is `False`)


Thanks,

Nathann



---

archive/issue_comments_222735.json:
```json
{
    "body": "Replying to [comment:6 ncohen]:\n\n> > No, I do not have a counter example. I might look into it, or not. Either way, I would like to restrict this ticket to the totally ordered case where the axioms for ordering use `is` and not `==`.\n> > \n> > When an `is`-based ordering does not respect `==`, such as Python's default ordering using `id`, you can have `a1==a2 and b1==b2` and `a1<b1 and a2>b2` at the same time. Within a single graph this cannot happen as there `a1==a2` implies `a1 is a2` (assuming that the given vertex labels are `==`-distinct). However, it *is* possible to construct *a pair* of graphs using `==`-equal vertex lists that nonetheless have distinct `.vertices()`. This is what happens above.\n> \n> Okay, it took me a while to understand but it seems that to you a 'is-based' ordering when comparison does not yield a total order, and is not necessarily agreeing with '=='. Why not. It has to work in this case too, anyway.\n\nI can't understand \"to you ... with '=='\" here. The problem can occur when an `is`-based ordering disagrees with `==`. This can still happen when it is total.\n\nTo be precise, the problem occurs when\n* there are `x`, `y`, and `z` with `x < y`, `y < z` and `x == z`.\nThis does not contradict the following axioms of an `is`-based total ordering:\n* `x < y and y < z` implies `x < z` for all `x`, `y`, `z`\n* for all `x` and `y` exactly one of `x < y`, `x is y`, and `y < x` holds.\n\n\n> Despite that, I call a list L 'sorted' when applying 'sorted' to L does not change L. Even if the ordering only makes sense to Python. And lists returned by `.vertices()`  should always be sorted in this way. I do not think that it is very bad if it does not hold, but that is how it is meant to work.\n\nIf sorted only uses `<` and not `==`, and if `<` is an `is`-based total order, then `sorted(sorted(L)) == sorted(L)` is indeed true. So someone should maybe check the implementation of `sorted` to see what comparisons are used.\n\n> > According to the documentation the labels are ignored. Let's defer what is right(tm) to a different ticket.\n> \n> Well, I do not think it needs a different ticket. I was surprised, but that's as bad as it got. If it is documented I don't see anything wrong with it. Especially since `is_isomorphic` also ignores edges by default.\n\nOkay... your punctuation was a bit strange then: \"This is *REALLY* bad ! Graphs with different labels should be non-equal !!! `O_O;;;;;`\"\n\n> The only problem is this 'weighted' keyword. It does not have anything to do with weights, so the keyword is ill-chosen. This can be fixed in another ticket, but there is nothing really urgent to solve either.\n\nAgreed.",
    "created_at": "2014-10-02T12:52:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222735",
    "user": "https://trac.sagemath.org/admin/accounts/users/emassop"
}
```

Replying to [comment:6 ncohen]:

> > No, I do not have a counter example. I might look into it, or not. Either way, I would like to restrict this ticket to the totally ordered case where the axioms for ordering use `is` and not `==`.
> > 
> > When an `is`-based ordering does not respect `==`, such as Python's default ordering using `id`, you can have `a1==a2 and b1==b2` and `a1<b1 and a2>b2` at the same time. Within a single graph this cannot happen as there `a1==a2` implies `a1 is a2` (assuming that the given vertex labels are `==`-distinct). However, it *is* possible to construct *a pair* of graphs using `==`-equal vertex lists that nonetheless have distinct `.vertices()`. This is what happens above.
> 
> Okay, it took me a while to understand but it seems that to you a 'is-based' ordering when comparison does not yield a total order, and is not necessarily agreeing with '=='. Why not. It has to work in this case too, anyway.

I can't understand "to you ... with '=='" here. The problem can occur when an `is`-based ordering disagrees with `==`. This can still happen when it is total.

To be precise, the problem occurs when
* there are `x`, `y`, and `z` with `x < y`, `y < z` and `x == z`.
This does not contradict the following axioms of an `is`-based total ordering:
* `x < y and y < z` implies `x < z` for all `x`, `y`, `z`
* for all `x` and `y` exactly one of `x < y`, `x is y`, and `y < x` holds.


> Despite that, I call a list L 'sorted' when applying 'sorted' to L does not change L. Even if the ordering only makes sense to Python. And lists returned by `.vertices()`  should always be sorted in this way. I do not think that it is very bad if it does not hold, but that is how it is meant to work.

If sorted only uses `<` and not `==`, and if `<` is an `is`-based total order, then `sorted(sorted(L)) == sorted(L)` is indeed true. So someone should maybe check the implementation of `sorted` to see what comparisons are used.

> > According to the documentation the labels are ignored. Let's defer what is right(tm) to a different ticket.
> 
> Well, I do not think it needs a different ticket. I was surprised, but that's as bad as it got. If it is documented I don't see anything wrong with it. Especially since `is_isomorphic` also ignores edges by default.

Okay... your punctuation was a bit strange then: "This is *REALLY* bad ! Graphs with different labels should be non-equal !!! `O_O;;;;;`"

> The only problem is this 'weighted' keyword. It does not have anything to do with weights, so the keyword is ill-chosen. This can be fixed in another ticket, but there is nothing really urgent to solve either.

Agreed.



---

archive/issue_comments_222736.json:
```json
{
    "body": "> I can't understand \"to you ... with '=='\" here. The problem can occur when an `is`-based ordering disagrees with `==`. This can still happen when it is total.\n\nOkayokay right. So it can happen even when the ordering is total, when `==` does not agree with `<`. Or actually, it happens when `<` is not an order at all.\n\n> If sorted only uses `<` and not `==`, and if `<` is an `is`-based total order, then `sorted(sorted(L)) == sorted(L)` is indeed true. So someone should maybe check the implementation of `sorted` to see what comparisons are used.\n\nI expect that it only uses `<` or `<=`.\n\n> > Well, I do not think it needs a different ticket. I was surprised, but that's as bad as it got. If it is documented I don't see anything wrong with it. Especially since `is_isomorphic` also ignores edges by default.\n> \n> Okay... your punctuation was a bit strange then: \"This is *REALLY* bad ! Graphs with different labels should be non-equal !!! `O_O;;;;;`\"\n\nWell, I *did* freak out. But if it works as intended, no problem `:-P`\n\nNathann",
    "created_at": "2014-10-02T13:14:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222736",
    "user": "https://github.com/nathanncohen"
}
```

> I can't understand "to you ... with '=='" here. The problem can occur when an `is`-based ordering disagrees with `==`. This can still happen when it is total.

Okayokay right. So it can happen even when the ordering is total, when `==` does not agree with `<`. Or actually, it happens when `<` is not an order at all.

> If sorted only uses `<` and not `==`, and if `<` is an `is`-based total order, then `sorted(sorted(L)) == sorted(L)` is indeed true. So someone should maybe check the implementation of `sorted` to see what comparisons are used.

I expect that it only uses `<` or `<=`.

> > Well, I do not think it needs a different ticket. I was surprised, but that's as bad as it got. If it is documented I don't see anything wrong with it. Especially since `is_isomorphic` also ignores edges by default.
> 
> Okay... your punctuation was a bit strange then: "This is *REALLY* bad ! Graphs with different labels should be non-equal !!! `O_O;;;;;`"

Well, I *did* freak out. But if it works as intended, no problem `:-P`

Nathann



---

archive/issue_comments_222737.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-02T13:46:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222737",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222738.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-10-02T13:47:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222738",
    "user": "https://trac.sagemath.org/admin/accounts/users/emassop"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_222739.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-10-02T13:48:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222739",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_222740.json:
```json
{
    "body": "Thank you very much !\n\nNathann",
    "created_at": "2014-10-02T13:48:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222740",
    "user": "https://github.com/nathanncohen"
}
```

Thank you very much !

Nathann



---

archive/issue_comments_222741.json:
```json
{
    "body": "At [http://build.sagedev.org/trac/builders/trac_builder/builds/1112](http://build.sagedev.org/trac/builders/trac_builder/builds/1112), there are these failures:\n\n```\n----------------------------------------------------------------------\nsage -t src/sage/crypto/mq/sr.py  # 5 doctests failed\nsage -t src/sage/modular/modform/numerical.py  # 2 doctests failed\nsage -t src/sage/quivers/path_semigroup.py  # 3 doctests failed\nsage -t src/sage/rings/polynomial/multi_polynomial_sequence.py  # 9 doctests failed\nsage -t src/sage/rings/polynomial/pbori.pyx  # Killed due to segmentation fault\nsage -t src/sage/rings/polynomial/polynomial_element.pyx  # 2 doctests failed\nsage -t src/sage/rings/real_double.pyx  # 2 doctests failed\n----------------------------------------------------------------------\n```\n\nOf these\n\n```\nsage -t src/sage/modular/modform/numerical.py  # 2 doctests failed\nsage -t src/sage/rings/polynomial/polynomial_element.pyx  # 2 doctests failed\nsage -t src/sage/rings/real_double.pyx  # 2 doctests failed\n```\n\nseem to be numerical noise that I can't reproduce. Moreover\n\n```\nsage -t src/sage/crypto/mq/sr.py  # 5 doctests failed\nsage -t src/sage/rings/polynomial/multi_polynomial_sequence.py  # 9 doctests failed\nsage -t src/sage/rings/polynomial/pbori.pyx  # Killed due to segmentation fault\n```\n\nare pbori segfaults, that I also get after reverting my patches for this ticket. The remaining failed doctest is\n\n```\nsage -t src/sage/quivers/path_semigroup.py  # 3 doctests failed\n```\n\nwhich is indeed caused by my patches here.\n\nHere is the output:\n\n```\nsage -t src/sage/quivers/path_semigroup.py\n**********************************************************************\nFile \"src/sage/quivers/path_semigroup.py\", line 179, in sage.quivers.path_semigroup.PathSemigroup._coerce_map_from_\nFailed example:\n    P1.has_coerce_map_from(P3)\nExpected:\n    False\nGot:\n    True\n**********************************************************************\nFile \"src/sage/quivers/path_semigroup.py\", line 195, in sage.quivers.path_semigroup.PathSemigroup._coerce_map_from_\nFailed example:\n    c3 in P1   # indirect doctest\nExpected:\n    False\nGot:\n    True\n**********************************************************************\nFile \"src/sage/quivers/path_semigroup.py\", line 197, in sage.quivers.path_semigroup.PathSemigroup._coerce_map_from_\nFailed example:\n    d*c3\nExpected:\n    Traceback (most recent call last):\n    ...\n    TypeError: unsupported operand parent(s) for '*':\n     'Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices'\n     and 'Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices'\nGot:\n    d*c\n**********************************************************************\n1 item had failures:\n   3 of  18 in sage.quivers.path_semigroup.PathSemigroup._coerce_map_from_\n    [151 tests, 3 failures, 0.83 s]\n```\n\nand the failing code:\n\n```\n    def _coerce_map_from_(self, other):\n        \"\"\"\n        A coercion from `A` to `B` exists if the underlying quiver\n        of `A` is a sub-quiver of the underlying quiver of `B` (preserving\n        names).\n\n        EXAMPLES::\n\n            sage: Q1 = DiGraph({1:{2:['a','b'], 3:['c']}, 3:{1:['d']}})\n            sage: Q2 = DiGraph({1:{2:['a'], 3:['c']}})\n            sage: Q3 = DiGraph({1:{2:['a','x'], 3:['c']}, 3:{1:['d']}})\n            sage: P1 = Q1.path_semigroup()\n            sage: P2 = Q2.path_semigroup()\n            sage: P3 = Q3.path_semigroup()\n            sage: P1.has_coerce_map_from(P2)   # indirect doctest\n            True\n            sage: P1.has_coerce_map_from(P3)\n            False\n            sage: d = P1([(3,1,'d')]); d\n            d\n            sage: c = P2([(1,3,'c')]); c\n            c\n            sage: c.parent() is P1\n            False\n            sage: c in P1    # indirect doctest\n            True\n            sage: d*c        # indirect doctest\n            d*c\n            sage: (d*c).parent() is P1\n            True\n            sage: c3 = P3([(1,3,'c')]); c3\n            c\n            sage: c3 in P1   # indirect doctest\n            False\n            sage: d*c3\n            Traceback (most recent call last):\n            ...\n            TypeError: unsupported operand parent(s) for '*':\n             'Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices'\n             and 'Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices'\n        \"\"\"\n```\n\n\nThe problem seems to be that `Q1 == Q3` is true while it should be false as the labels ought to be checked. This in turn makes `P1 == P3` true. This didn't register before as the hashes were different, so that the unique representations P1 and P3 also became different.\n\nRunning `git grep path_semigroup`, I see that the digraphs on which path_semigroup is called are nowhere 'weighted'. It therefore seems that the people working on quivers assume that edge labels are checked... This is now bug #17092.",
    "created_at": "2014-10-02T18:33:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222741",
    "user": "https://trac.sagemath.org/admin/accounts/users/emassop"
}
```

At [http://build.sagedev.org/trac/builders/trac_builder/builds/1112](http://build.sagedev.org/trac/builders/trac_builder/builds/1112), there are these failures:

```
----------------------------------------------------------------------
sage -t src/sage/crypto/mq/sr.py  # 5 doctests failed
sage -t src/sage/modular/modform/numerical.py  # 2 doctests failed
sage -t src/sage/quivers/path_semigroup.py  # 3 doctests failed
sage -t src/sage/rings/polynomial/multi_polynomial_sequence.py  # 9 doctests failed
sage -t src/sage/rings/polynomial/pbori.pyx  # Killed due to segmentation fault
sage -t src/sage/rings/polynomial/polynomial_element.pyx  # 2 doctests failed
sage -t src/sage/rings/real_double.pyx  # 2 doctests failed
----------------------------------------------------------------------
```

Of these

```
sage -t src/sage/modular/modform/numerical.py  # 2 doctests failed
sage -t src/sage/rings/polynomial/polynomial_element.pyx  # 2 doctests failed
sage -t src/sage/rings/real_double.pyx  # 2 doctests failed
```

seem to be numerical noise that I can't reproduce. Moreover

```
sage -t src/sage/crypto/mq/sr.py  # 5 doctests failed
sage -t src/sage/rings/polynomial/multi_polynomial_sequence.py  # 9 doctests failed
sage -t src/sage/rings/polynomial/pbori.pyx  # Killed due to segmentation fault
```

are pbori segfaults, that I also get after reverting my patches for this ticket. The remaining failed doctest is

```
sage -t src/sage/quivers/path_semigroup.py  # 3 doctests failed
```

which is indeed caused by my patches here.

Here is the output:

```
sage -t src/sage/quivers/path_semigroup.py
**********************************************************************
File "src/sage/quivers/path_semigroup.py", line 179, in sage.quivers.path_semigroup.PathSemigroup._coerce_map_from_
Failed example:
    P1.has_coerce_map_from(P3)
Expected:
    False
Got:
    True
**********************************************************************
File "src/sage/quivers/path_semigroup.py", line 195, in sage.quivers.path_semigroup.PathSemigroup._coerce_map_from_
Failed example:
    c3 in P1   # indirect doctest
Expected:
    False
Got:
    True
**********************************************************************
File "src/sage/quivers/path_semigroup.py", line 197, in sage.quivers.path_semigroup.PathSemigroup._coerce_map_from_
Failed example:
    d*c3
Expected:
    Traceback (most recent call last):
    ...
    TypeError: unsupported operand parent(s) for '*':
     'Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices'
     and 'Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices'
Got:
    d*c
**********************************************************************
1 item had failures:
   3 of  18 in sage.quivers.path_semigroup.PathSemigroup._coerce_map_from_
    [151 tests, 3 failures, 0.83 s]
```

and the failing code:

```
    def _coerce_map_from_(self, other):
        """
        A coercion from `A` to `B` exists if the underlying quiver
        of `A` is a sub-quiver of the underlying quiver of `B` (preserving
        names).

        EXAMPLES::

            sage: Q1 = DiGraph({1:{2:['a','b'], 3:['c']}, 3:{1:['d']}})
            sage: Q2 = DiGraph({1:{2:['a'], 3:['c']}})
            sage: Q3 = DiGraph({1:{2:['a','x'], 3:['c']}, 3:{1:['d']}})
            sage: P1 = Q1.path_semigroup()
            sage: P2 = Q2.path_semigroup()
            sage: P3 = Q3.path_semigroup()
            sage: P1.has_coerce_map_from(P2)   # indirect doctest
            True
            sage: P1.has_coerce_map_from(P3)
            False
            sage: d = P1([(3,1,'d')]); d
            d
            sage: c = P2([(1,3,'c')]); c
            c
            sage: c.parent() is P1
            False
            sage: c in P1    # indirect doctest
            True
            sage: d*c        # indirect doctest
            d*c
            sage: (d*c).parent() is P1
            True
            sage: c3 = P3([(1,3,'c')]); c3
            c
            sage: c3 in P1   # indirect doctest
            False
            sage: d*c3
            Traceback (most recent call last):
            ...
            TypeError: unsupported operand parent(s) for '*':
             'Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices'
             and 'Partial semigroup formed by the directed paths of Multi-digraph on 3 vertices'
        """
```


The problem seems to be that `Q1 == Q3` is true while it should be false as the labels ought to be checked. This in turn makes `P1 == P3` true. This didn't register before as the hashes were different, so that the unique representations P1 and P3 also became different.

Running `git grep path_semigroup`, I see that the digraphs on which path_semigroup is called are nowhere 'weighted'. It therefore seems that the people working on quivers assume that edge labels are checked... This is now bug #17092.



---

archive/issue_comments_222742.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2014-10-02T19:41:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222742",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_222743.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2014-10-02T19:42:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222743",
    "user": "https://github.com/vbraun"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_222744.json:
```json
{
    "body": "Got these on the buildbot, too.",
    "created_at": "2014-10-02T19:42:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222744",
    "user": "https://github.com/vbraun"
}
```

Got these on the buildbot, too.



---

archive/issue_comments_222745.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2014-10-03T09:08:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222745",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_222746.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-10-03T09:09:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222746",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_222747.json:
```json
{
    "body": "(does not pass tests in `sage/quivers/path_semigroup.py`)",
    "created_at": "2014-10-03T09:09:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222747",
    "user": "https://github.com/nathanncohen"
}
```

(does not pass tests in `sage/quivers/path_semigroup.py`)



---

archive/issue_comments_222748.json:
```json
{
    "body": "Replying to [comment:18 ncohen]:\n> (does not pass tests in `sage/quivers/path_semigroup.py`)\n\nWith #17092 applied?",
    "created_at": "2014-10-03T09:12:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222748",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:18 ncohen]:
> (does not pass tests in `sage/quivers/path_semigroup.py`)

With #17092 applied?



---

archive/issue_comments_222749.json:
```json
{
    "body": "> With #17092 applied?\n\nI do not know, I just tested it by itself. Anyway Volker does not want to see a patch in `positive_review` before all its dependencies. And I wonder if it is the good fix, by the way, for I really expected that two graphs with different labels would be returned as nonequal, regardless of this misnamed weighted parameter.\n\nNathann",
    "created_at": "2014-10-03T09:14:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222749",
    "user": "https://github.com/nathanncohen"
}
```

> With #17092 applied?

I do not know, I just tested it by itself. Anyway Volker does not want to see a patch in `positive_review` before all its dependencies. And I wonder if it is the good fix, by the way, for I really expected that two graphs with different labels would be returned as nonequal, regardless of this misnamed weighted parameter.

Nathann



---

archive/issue_comments_222750.json:
```json
{
    "body": "Its fine to have this as positive review before the dependency is finished, assuming that tests will pass once the dependency is finished.\n\nIf you have any doubts then you should sort that out, of course.",
    "created_at": "2014-10-03T09:37:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222750",
    "user": "https://github.com/vbraun"
}
```

Its fine to have this as positive review before the dependency is finished, assuming that tests will pass once the dependency is finished.

If you have any doubts then you should sort that out, of course.



---

archive/issue_comments_222751.json:
```json
{
    "body": "> Its fine to have this as positive review before the dependency is finished, assuming that tests will pass once the dependency is finished.\n\nYou set a designs ticket of mine to \"needs_work\" for that very reason not so long ago.",
    "created_at": "2014-10-03T09:38:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222751",
    "user": "https://github.com/nathanncohen"
}
```

> Its fine to have this as positive review before the dependency is finished, assuming that tests will pass once the dependency is finished.

You set a designs ticket of mine to "needs_work" for that very reason not so long ago.



---

archive/issue_comments_222752.json:
```json
{
    "body": "Which ticket? In general I think it should be avoided to have positively-reviewed tickets hang around for a long time while waiting for a dependency. But I have improved the release management scripts a few months ago to handle this case more easily.",
    "created_at": "2014-10-03T10:11:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222752",
    "user": "https://github.com/vbraun"
}
```

Which ticket? In general I think it should be avoided to have positively-reviewed tickets hang around for a long time while waiting for a dependency. But I have improved the release management scripts a few months ago to handle this case more easily.



---

archive/issue_comments_222753.json:
```json
{
    "body": "> Which ticket? In general I think it should be avoided to have positively-reviewed tickets hang around for a long time while waiting for a dependency. But I have improved the release management scripts a few months ago to handle this case more easily.\n\nOkay.",
    "created_at": "2014-10-03T10:12:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222753",
    "user": "https://github.com/nathanncohen"
}
```

> Which ticket? In general I think it should be avoided to have positively-reviewed tickets hang around for a long time while waiting for a dependency. But I have improved the release management scripts a few months ago to handle this case more easily.

Okay.



---

archive/issue_comments_222754.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-03T12:40:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222754",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222755.json:
```json
{
    "body": "IMHO `__eq__` should appear in the html/pdf documentation somewhere, with all this confusion about what is checked. How do I do that? and where should it appear?",
    "created_at": "2014-10-03T12:42:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222755",
    "user": "https://trac.sagemath.org/admin/accounts/users/emassop"
}
```

IMHO `__eq__` should appear in the html/pdf documentation somewhere, with all this confusion about what is checked. How do I do that? and where should it appear?



---

archive/issue_comments_222756.json:
```json
{
    "body": "You need to add `.. automethod: __eq__` to the class docstringc.",
    "created_at": "2014-10-03T13:03:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222756",
    "user": "https://github.com/vbraun"
}
```

You need to add `.. automethod: __eq__` to the class docstringc.



---

archive/issue_comments_222757.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-03T16:49:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222757",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222758.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-10-05T10:40:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222758",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_222759.json:
```json
{
    "body": "I am running the doctests again just in case, but the tests pass in quivers/  when #17092 is applied.\n\nI change this ticket's branch to include a merge commit with #17092.\n\nThanks !\n\nNathann\n----\nNew commits:",
    "created_at": "2014-10-05T10:40:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222759",
    "user": "https://github.com/nathanncohen"
}
```

I am running the doctests again just in case, but the tests pass in quivers/  when #17092 is applied.

I change this ticket's branch to include a merge commit with #17092.

Thanks !

Nathann
----
New commits:



---

archive/issue_comments_222760.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-10-07T14:23:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16849#issuecomment-222760",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_016307.json:
```json
{
    "actor": "@vbraun",
    "created_at": "2014-10-07T14:23:21Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/16849",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16849#event-16307"
}
```
