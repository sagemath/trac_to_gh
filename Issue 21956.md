# Issue 21956: Port cypari2 documentation as a standalone doctests

Issue created by migration from Trac.

Original creator: vdelecroix

Original creation time: 2017-01-16 18:39:02

CC:  defeo jdemeyer

Since cypari2 is aimed to become an external module we should move the doctest of its documentation in a standalone file.


---

Comment by jdemeyer created at 2017-01-17 09:10:23

We already have `src/sage/libs/pari/tests.py`. That would be a good place to put those tests.


---

Comment by vdelecroix created at 2017-01-17 10:48:16

doing that...


---

Attachment

I joined the script I used to generate the files.


---

Comment by vdelecroix created at 2017-01-17 18:15:21

New commits:


---

Comment by vdelecroix created at 2017-01-17 18:15:21

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-01-18 17:32:24

I don't really like that this is automatic. I think we should manually figure out which doctests should be kept in cypari2 and which ones should be moved to Sage.


---

Comment by jdemeyer created at 2017-01-18 17:35:06

I think that the tests in `convert.pyx` don't really involve Sage at all (except for the preparser, so `2^64` should be changed to `2**64` for example).


---

Comment by defeo created at 2017-02-03 16:07:52

What's the status of this? Anyone working on it?


---

Comment by defeo created at 2017-02-06 22:00:28

It's been extremely painful, but I've manually gone through all docstrings. As Jeroen suspected, very few of them were Sage-specific, but most of them needed to be de-Saged.

I moved the few Sage-specific tests to `test.py`, and also duplicated there some tests that could have been done entirely in CyPari2, but that used to activate some code-paths in Sage that wouldn't be activated otherwise.

There's two notable bits of docstring I haven't touched yet:

1. The "Guide to real precision" in the module docstring of `pari_instance.pyx`. This is very Sage-specific, and it's more than just a testsuite. Where shall we move it?

2. The `Gen.sage()`, which of course has no place in CyPari. Did we decide anything on subclassing `Gen`, though?

For the rest, I hopefully changed all `^` to `**` at the right spots, and removed all dependencies on Sage (except for the `sage:` prompt and the import statements). If I forgot something, we will notice anyway when setting up tests outside of Sage. I also fear that some doctests may fail in Python3, but that should also be easy to fix.

In my doctest trip, I saw a lot of very archaic code, esp. in the number field and the elliptic curve methods. For example `nfbasis` has a very weird docstring, and takes a flag parameter that seems to be undocumented in PARI.
----
New commits:


---

Comment by defeo created at 2017-02-06 22:00:28

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-02-08 18:17:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by defeo created at 2017-02-08 18:18:20

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-02-08 19:52:04

Just had a quick look and it looks good on first sight. I need to check a bit better in order to give positive_review though.

Does the documentation from `src/sage/libs/pari/__init__.py` actually appear anywhere?


---

Comment by defeo created at 2017-02-08 22:15:07

> Does the documentation from `src/sage/libs/pari/__init__.py` actually appear anywhere?

I don't think so, but all documentation from `cypari2` seems to have disappeared from the reference manual anyway. I thought that was a deliberate choice?


---

Comment by jdemeyer created at 2017-02-09 08:39:20

Please rebase to 7.6.beta3


---

Comment by jdemeyer created at 2017-02-09 08:39:20

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-02-09 08:41:05

Replying to [comment:14 defeo]:
> all documentation from `cypari2` seems to have disappeared from the reference manual anyway.

The code for `src/sage/libs/cypari2` will be removed from Sage anyway, so I don't consider it a problem that the doc is not in Sage anymore.

However, the doc for `src/sage/libs/pari` should remain in Sage. It is currently not.


---

Comment by jdemeyer created at 2017-02-09 11:14:18

Rebased (and fixed a typo in the commit message).
----
New commits:


---

Comment by jdemeyer created at 2017-02-09 11:14:47

I'm having a look at the documentation right now.


---

Comment by git created at 2017-02-09 15:31:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-02-09 15:32:03

Changing status from needs_work to needs_review.


---

Comment by defeo created at 2017-02-09 17:28:04

Thanks for the rebase.

We could improve the documentation of `sage.libs.pari`, but that's probably best kept for another ticket.


---

Comment by defeo created at 2017-02-09 17:28:04

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2017-02-10 08:27:52

Changing status from positive_review to needs_work.


---

Comment by jdemeyer created at 2017-02-10 08:27:52

Some details...

1. You forgot to remove one `int()` here:

```
sage: int(2) ** pari(-5)
```


2. Why did you remove this?

```
sage: bnr = pari("K = bnfinit(x^4 - 4*x^2 + 1); bnrinit(K, 2*x)")
sage: bnr.nf_get_pol()
```


3. This sentence is no longer relevant:

```
However, beware that ``pari(L)`` returns an absolute number field::
```


4. This is a significant change:

```
-            sage: two = RealField(256)(2)._pari_()
+            sage: two = pari(2)
```

Instead, you could use

```
two = pari("2.0000000000000000000000000000000000000000000000000000000000000000000000000000")
```


5. This is confusing since the `5/3` is not the fraction 5/3 in Python!

```
sage: pari([-1, 5/3, -8.0]).vecmin()
```

You could keep the original test with quotes: `pari("[1, -5/3, 8.0]").vecmin()`


---

Comment by defeo created at 2017-02-10 15:06:57

> 1. You forgot to remove one `int()` here:
> {{{
> sage: int(2) ** pari(-5)
> }}}

This breaks in Sage, unless we positive review #22321. But I wanted to explore that ticket a bit more before setting it to needs review.

On the other hand, it doesn't hurt Python.

> 2. Why did you remove this?
> {{{
> sage: bnr = pari("K = bnfinit(x^4 - 4*x^2 + 1); bnrinit(K, 2*x)")
> sage: bnr.nf_get_pol()
> }}}

I did not remove it. I changed it to


```
sage: x = pari('x')                                                                                                         
sage: K = (x**4 - 4*x**2 + 1).nfinit()
sage: K.nf_get_pol()                                                                                                        
```


which seems to be functionally equivalent and more concise. However, you know PARI better than me. If you think that's more appropriate, I can change it to
 

```
sage: x = pari('x')                                                                                                         
sage: K = (x**4 - 4*x**2 + 1).bnfinit().bnrinit(2*x)                                                                        
sage: K.nf_get_pol()                                                                                                        
```



---

Comment by defeo created at 2017-02-10 15:09:27

fixed the rest
----
New commits:


---

Comment by git created at 2017-02-10 15:16:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by defeo created at 2017-02-10 15:18:08

Replying to [comment:24 defeo]:
> > 1. You forgot to remove one `int()` here:
> > {{{
> > sage: int(2) ** pari(-5)
> > }}}
> 
> This breaks in Sage, unless we positive review #22321.

Wait, no, I got confused: it just needs #22319, which is positive reviewed. Fixed now.


---

Comment by jdemeyer created at 2017-02-10 15:35:02

Replying to [comment:24 defeo]:
> ... which seems to be functionally equivalent

But the `bnrinit()` call is gone, so it's clearly a different test.

Why not keep the original test? It should work as written in CyPari2.


---

Comment by defeo created at 2017-02-10 15:56:02

Replying to [comment:29 jdemeyer]:
> Replying to [comment:24 defeo]:
> > ... which seems to be functionally equivalent
> 
> But the `bnrinit()` call is gone, so it's clearly a different test.
> 
> Why not keep the original test? It should work as written in CyPari2.

Because examples in the documentation should show the proper way to do things, not the ugly one.

I admit I do not understand the reason for the call to `bnrinit()`, maybe you can elucidate.

We can put the old test in `TESTS::`, however, if you wish to keep it.


---

Comment by jdemeyer created at 2017-02-10 16:01:54

Replying to [comment:30 defeo]:
> I admit I do not understand the reason for the call to `bnrinit()`, maybe you can elucidate.

It shows that `nf_get_pol()` works when given a bnr (the output of `bnrinit()`) as input. So it is an important test which really should not be removed.


---

Comment by git created at 2017-02-10 16:05:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by defeo created at 2017-02-10 16:06:16

what about this?


---

Comment by defeo created at 2017-02-10 16:06:16

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-02-11 09:35:45

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-02-12 22:08:47

Resolution: fixed


---

Comment by vbraun created at 2017-02-13 19:11:43

fails on 32-bit:

```
sage -t --long src/sage/libs/cypari2/pari_instance.pyx
3569**********************************************************************
3570File "src/sage/libs/cypari2/pari_instance.pyx", line 112, in sage.libs.cypari2.pari_instance
3571Failed example:
3572    pari(float(1.0)).sin(precision=180) - pari(1).sin(precision=180)
3573Expected:
3574    5.42101086242752 E-20
3575Got:
3576    5.42101086 E-20
3577**********************************************************************
35781 item had failures:
3579   1 of  31 in sage.libs.cypari2.pari_instance
3580    [151 tests, 1 failure, 0.33 s]
```



---

Comment by vbraun created at 2017-02-13 19:11:43

Changing status from closed to new.


---

Comment by vbraun created at 2017-02-13 19:11:43

Resolution changed from fixed to 


---

Comment by defeo created at 2017-02-15 11:33:18

New commits:


---

Comment by defeo created at 2017-02-15 11:33:18

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-02-15 11:57:10

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-02-15 11:57:10

I think  it would be better to keep the spirit of the original examples instead of inventing a pointless example like `pari(float(1.0)).sin(precision=180) - pari(1).sin(precision=180) == 0`. Remember that these doctests are meant as _documentation_ and I don't see what you are documenting there...


---

Comment by defeo created at 2017-02-15 12:19:59

Replying to [comment:39 jdemeyer]:
> I think  it would be better to keep the spirit of the original examples instead of inventing a pointless example like `pari(float(1.0)).sin(precision=180) - pari(1).sin(precision=180) == 0`. Remember that these doctests are meant as _documentation_ and I don't see what you are documenting there...

The original documentation said


```
In the third case, the precision is determined only by the inexact
inputs and the ``precision`` argument is ignored::
                                                  
    sage: pari(1.0).sin(precision=180).sage()
    0.841470984807896507
    sage: pari(1.0).sin(precision=40).sage()
    0.841470984807896507
    sage: pari(RealField(100).one()).sin().sage()
    0.84147098480789650665250232163029899962
```


which has no equivalent in CyPari. Would you find this clearer?


```
    sage: d = pari(float(1.0)).sin(precision=180); d
    0.8414709848078965067
    sage: d.bitprecision()                                 
    64
```


However this test is also architecture dependent.


---

Comment by defeo created at 2017-02-16 21:07:55

`@`jdemeyer ping?

Replying to [comment:40 defeo]:
> Replying to [comment:39 jdemeyer]:
> Would you find this clearer?
> 
> {{{
>     sage: d = pari(float(1.0)).sin(precision=180); d
>     0.8414709848078965067
>     sage: d.bitprecision()                                 
>     64
> }}}
> 
> However this test is also architecture dependent.


---

Comment by jdemeyer created at 2017-02-17 13:38:24

Replying to [comment:40 defeo]:
> which has no equivalent in CyPari.

I disagree with this.

There are plenty of ways to create high-precision numbers in CyPari:

```
sage: n = pari("1.0000000000000000000000000000"); n.bitprecision()
128
sage: n = pari("localbitprec(100); 1.0"); n.bitprecision()
128
sage: n = pari(1.0).bitprecision(100); n.bitprecision()
128
```


Personally, I would prefer the third way.

So I think that you can mostly keep the old doctests, just replacing `pari(RealField(100)(1.0))` by `pari(1.0).bitprecision(100)`.


---

Comment by jdemeyer created at 2017-02-17 13:44:17

Looking at the documentation of precision more carefully, I think you should actually restore larger parts of the docs. For example, the first part of "Internal representation and conversion between Sage and PARI" and all of "Output precision for printing" should be kept for CyPari2.


---

Comment by defeo created at 2017-02-17 15:22:38

Replying to [comment:43 jdemeyer]:
> For example, the first part of "Internal representation and conversion between Sage and PARI" 

There's pretty much nothing that can be salvaged from this section: precision in PARI is in multiples of 32 or 64. That's it.

> and all of "Output precision for printing" should be kept for CyPari2.

I think this section is completely misleading, and the more I try to understand, the less I get it. It talks about "printing" precision, `set_real_precision` seems to affect more than printing:


```
sage: pari.set_real_precision_bits(1000)
sage: a = pari('Pi')
sage: 
sage: pari.set_real_precision_bits(10)
sage: b = pari('Pi')
sage: a - b
-2.17 E-19
sage: pari.set_real_precision_bits(1000)
sage: a - b
-2.168404344971008868 E-19
sage: a - b.bitprecision(1000)
-5.016557612668332023557327080330757013833665769218359371379100137196517465788293201785191348671769335290615539044941776827464059187151888254971589729806147889444035537705104506961803557118902433406655387152435176621321683472879809085435143307653965138954567335178660639273975085872627541300 E-20
```


I think this whole part needs to be rewritten, not translated from the old docs. Problem is, I'm not sure I understand what it does.


---

Comment by jdemeyer created at 2017-02-17 18:46:19

Can you explain me what you don't understand?

I could certainly try to improve the docs, but then I need to know what's wrong with the current docs.


---

Comment by jdemeyer created at 2017-02-17 18:47:33

Replying to [comment:44 defeo]:
> There's pretty much nothing that can be salvaged from this section: precision in PARI is in multiples of 32 or 64. That's it.

...but that is a very important fact to mention which is certainly more than "pretty much nothing".


---

Comment by jdemeyer created at 2017-02-17 18:52:22

Replying to [comment:44 defeo]:
> I think this section is completely misleading, and the more I try to understand, the less I get it. It talks about "printing" precision, `set_real_precision` seems to affect more than printing:

I hope that "completely misleading" is an exaggeration. The sentence "The maximum number of digits when printing a PARI real can be set using the methods `Pari.set_real_precision_bits` or `Pari.set_real_precision`" is correct but it's true that `set_real_precision_bits` affects more than just printing. It also affects precision for numbers parsed using the string interface, which is documented in the "Input precision for function calls" section. So I wonder where your confusion comes from.


---

Comment by defeo created at 2017-02-17 22:12:11

Sorry, I shouldn't be doing so many things in parallel. I'll try to frame my doubts better.

For one, I do not understand this:


```
sage: pi = pari('Pi')
sage: a = pari(float(1.0))
sage: pari.set_real_precision(500)
15
sage: pi
3.141592653589793239
sage: a
1.0000000000000000000
sage: pi.bitprecision(1000)
3.1415926535897932385128089594061862044327426701784133911132812500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
sage: a.bitprecision(1000)
1.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```


How does PARI decide what bits to add when calling `bitprecision()`? Why does `Pi` have junk digits before all the zeros, while `1.0` gets only added zeros?


---

Comment by defeo created at 2017-02-17 22:18:35

Then, there's the fact that I expect (too optimistically) `Pi` to be a _symbolic_ quantity, i.e. that incrementing precision (with `pi.bitprecision(1000)`) would compute correctly the new digits instead of adding random junk.

That's probably asking too much from PARI, but I got bad habits from Sage :)

The same behavior from `pari.pi()` surprises me much less: when I see a function call, I understand that's a function supposed to compute π up to a fixed precision.

Anyway, not much we can do here: that's the way PARI it is.


---

Comment by defeo created at 2017-02-17 22:21:30

And, finally, when I read

> The maximum number of digits when printing a PARI real can be set using the methods :meth:`Pari.set_real_precision_bits` or :meth:`Pari.set_real_precision`.

I understand that's the SOLE role of `set_real_precision`: controlling output precision. Then, when I go further down, I discover that it also controls input precision for strings.

I would find it clearer, if it was stated right away that `set_real_precision` controls input and output precision for strings.


---

Comment by jdemeyer created at 2017-02-18 08:51:21

Replying to [comment:48 defeo]:
> Sorry, I shouldn't be doing so many things in parallel. I'll try to frame my doubts better.
> 
> For one, I do not understand this:
> 
> {{{
> sage: pi = pari('Pi')
> sage: a = pari(float(1.0))
> sage: pari.set_real_precision(500)
> 15
> sage: pi
> 3.141592653589793239
> sage: a
> 1.0000000000000000000
> sage: pi.bitprecision(1000)
> 3.1415926535897932385128089594061862044327426701784133911132812500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
> sage: a.bitprecision(1000)
> 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
> }}}
> 
> How does PARI decide what bits to add when calling `bitprecision()`?

It just adds zero bits.

> Why does `Pi` have junk digits before all the zeros, while `1.0` gets only added zeros?

You should not make any conclusions from the _decimal_ representation of the number, in binary it's just zeros.

Replying to [comment:49 defeo]:
> Then, there's the fact that I expect (too optimistically) `Pi` to be a _symbolic_ quantity, i.e. that incrementing precision (with `pi.bitprecision(1000)`) would compute correctly the new digits instead of adding random junk.

PARI doesn't really do symbolic computations. `Pi` does a computation returning a floating-point approximation of π.

> The same behavior from `pari.pi()` surprises me much less: when I see a function call, I understand that's a function supposed to compute π up to a fixed precision.

Actually, `Pi` is a function call. This works:

```
gp> Pi()
%1 = 3.1415926535897932384626433832795028842
```

It's just that the GP parser turns `Pi` into `Pi()` to improve user-friendliness.


---

Comment by defeo created at 2017-02-18 16:27:51

> > Why does `Pi` have junk digits before all the zeros, while `1.0` gets only added zeros?
> 
> You should not make any conclusions from the _decimal_ representation of the number, in binary it's just zeros.

Right. So I think 


```
n = pari(1.0).bitprecision(100)
```


is giving bad advice to the user: it only gets the intended value by chance, and the doctstring of `bitprecision` does nothing to help the user guess what the result would be.

> It's just that the GP parser turns `Pi` into `Pi()` to improve user-friendliness.

I call this user-hateness.


---

Comment by jdemeyer created at 2017-02-18 17:43:01

Feel free to complain to the PARI developers for anything that you don't like...


---

Comment by jdemeyer created at 2017-02-21 07:41:15

Luca, are you going to work on this, or should I?


---

Comment by defeo created at 2017-02-21 10:08:12

Sorry, I was busy teaching. I was meaning to finalize this, but if I don't make it by today, it will have to wait until Fri.

Of course, if you have time to donate to this, feel free to jump in.


---

Comment by jdemeyer created at 2017-02-22 11:38:56

OK, I will try to have a look today.


---

Comment by git created at 2017-02-22 16:05:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-02-22 16:06:10

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-02-22 16:06:59

I hope this helps...


---

Comment by defeo created at 2017-02-25 14:22:53

Changing status from needs_review to positive_review.


---

Comment by defeo created at 2017-02-25 14:22:53

Sorry for the delay. It is clearer now, thanks for the patch.

Are you sure the doctests pass on 32-bits? This, for example:


```
sage: c = pari(1).sin(); c
0.841470984807897
sage: c.bitprecision()
64
```



---

Comment by defeo created at 2017-02-26 22:20:47

> Are you sure the doctests pass on 32-bits? This, for example:
> 
> {{{
> sage: c = pari(1).sin(); c
> 0.841470984807897
> sage: c.bitprecision()
> 64
> }}}

Ok, went again through the examples, and this example is obviously not a problem. The only problematic tests are those that do `pari(1.0)`: that's not arch dependent in Sage (because 1.0 is a real), but it is in Python.

Anyway, they are ok for now. We shall see when we bring this to cypari.


---

Comment by jdemeyer created at 2017-02-27 07:03:18

Replying to [comment:62 defeo]:
> The only problematic tests are those that do `pari(1.0)`: that's not arch dependent in Sage (because 1.0 is a real), but it is in Python.

No, Python floats are the same on 32-bit and 64-bit. It's true that certain _computations_ involving floats might give different results. But for a conversion, the results should be the same on 32-bit and 64-bit.


---

Comment by vbraun created at 2017-02-28 23:23:50


```
sage -t --long src/sage/libs/cypari2/pari_instance.pyx
**********************************************************************
File "src/sage/libs/cypari2/pari_instance.pyx", line 91, in sage.libs.cypari2.pari_instance
Failed example:
    pari("Pi") - p
Expected:
    1.22514845490862 E-16
Got:
    1.225148455 E-16
**********************************************************************
File "src/sage/libs/cypari2/pari_instance.pyx", line 94, in sage.libs.cypari2.pari_instance
Failed example:
    pari("Pi") - p
Expected:
    1.22514845490862 E-16
Got:
    1.225148455 E-16
**********************************************************************
1 item had failures:
   2 of  54 in sage.libs.cypari2.pari_instance
    [174 tests, 2 failures, 0.22 s]
```



---

Comment by vbraun created at 2017-02-28 23:23:50

Changing status from positive_review to needs_work.


---

Comment by jdemeyer created at 2017-03-01 07:28:29

Sorry for that.


---

Comment by git created at 2017-03-01 07:30:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-03-01 07:36:43

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-03-01 12:35:01

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2017-03-01 12:35:01

This fixes the 32-bit tests.


---

Comment by vbraun created at 2017-03-02 17:43:50

Resolution: fixed
