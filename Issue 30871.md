# Issue 30871: lazy p-adics

Issue created by migration from https://trac.sagemath.org/ticket/31108

Original creator: caruso

Original creation time: 2020-12-25 20:42:30

CC:  tristanvaccon @thibautverron roed saraedum

We propose an implement of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.

Here is a small demo:


```
This module provides basic support for lazy p-adic integers.

    sage: R = ZpL(5)
    sage: R
    Lazy 5-adic Ring

One creates elements as usual::

    sage: a = R(17/42)
    sage: a
    ...00244200244200244201

    sage: R.random_element()  # random
    ...21013213133412431402

By default, 20 digits of precision are computed (and printed).
If more (or less) digits are needed, one can specify it as follows::

    sage: b = R(42/17, prec=30)
    sage: b
    ...104201213402432310420121340301

Alternatively, one can increase the precision using the method meth:`jump`::

    sage: a.jump(30)
    sage: a
    ...244200244200244200244200244201

Standard operations are implemented::

    sage: a + b
    ...03232011214322140002
    sage: a - b
    ...42311334324023403400

    sage: a * b
    ...00000000000000000001
    sage: a / b
    ...12442142113021233401

We observe again that only 20 digits are computed.
If we need more, we have to create a new variable::

    sage: c = a / b
    sage: c.jump(40)
    sage: c
    ...4230030104200433321312442142113021233401

Note that this automatically increases the precision on `a` and `b`::

    sage: a
    ...4200244200244200244200244200244200244201
    sage: b
    ...2134024323104201213402432310420121340301

Equality test works but equality is only checked up to the
*minimal* current precision of the elements::

    sage: c == R(289/1764, prec=100)
    True
    sage: c == R(289/1764 + 5^50, prec=100)
    True

    sage: c.jump(100)
    sage: c == R(289/1764 + 5^50, prec=100)
    False
    sage: c == R(289/1764 + 5^50)
    True

A quite interesting feature with lazy p-adics is the possibility to
create (in somes cases) self-referrent numbers. Here is an example.
We first declare a new variable as follows::

    sage: x = R()
    sage: x
    O(1)

We then write down an equation satisfied by `x`::

    sage: x == 1 + 5*x^2
    True

The variable `x` now contains the unique solution of the above equation::

    sage: x
    ...04222412141121000211

This works because the `n`-th digit of the right hand size of the
defining equation only involves the `i`-th digits of `x` with `i < n`
(this is due to the factor `5`).

As a comparison, the following produces an error::
    sage: y = R()
    sage: y == 1 + 3*y^2
    Traceback (most recent call last):
    ...
    RecursionError: definition looks circular

Previous self-referrent definitions also work with system of equations::

    sage: u = R(); v = R(); w = R()

    sage: u == 1 + 2*v + 3*w^2 + 5*u*v*w
    True
    sage: v == 2 + 4/w^3 + 10*(u + v + w)^2
    True
    sage: w == 3 + 25*(u*v + v*w + u*w)
    True

    sage: u
    ...21111231040212114001
    sage: v
    ...04313122332303332234
    sage: w
    ...30020001022124410403
```



---

Comment by caruso created at 2020-12-26 07:46:31

New commits:


---

Comment by git created at 2020-12-26 09:41:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-12-29 20:42:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2020-12-29 20:54:49

New commits:


---

Comment by git created at 2021-01-02 23:31:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-04 14:08:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-04 22:01:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-04 22:46:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-05 09:27:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-05 23:22:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-06 08:14:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-06 08:30:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-06 19:26:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-06 23:20:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-08 13:52:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-11 00:49:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-11 15:22:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-24 10:21:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-26 13:37:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2021-01-26 17:53:11

A note about operator choice: While the ``@`` notation is definite informative and cute when considered stand-alone, it doesn't fit very well with other places where the operator is used in python. Specifically, the operator was introduced upon request of the numpy people, to signify matrix multiplication. With that in mind ``@`` has a rather strong association with (function) composition (which, in a specific way, is also how you could read ``@`` decorators to function definitions).

There's a reasonable chance that ``@`` will at some point be integrated in the coercion framework. The use for ``@`` proposed here will cause problems. I'd suggest just using a named method to cap precision.

Otherwise, this package looks really cool! It would be great to see some performance specs at some point.


---

Comment by caruso created at 2021-01-26 18:47:38

I'm a bit disappointed but I note your argument for ``@`` and will probably disallow this construction.

About performances, it's of course not as fast as other types of p-adics but I would say that it's already reasonable (although optimizations are still possible):


```
    sage: R = ZpL(5)
    sage: a = R.random_element()
    sage: b = R.random_element()
    sage: c = 1 + 5*R.random_element()
    sage: %timeit _ = (a + b)@10000
    848 µs ± 614 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
    sage: %timeit _ = (a * b)@10000
    9.59 ms ± 116 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
    sage: %timeit _ = (a / b)@10000
    11.7 ms ± 215 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
    sage: %timeit _ = c.sqrt()@10000
    13.7 ms ± 240 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```


Compare with:


```
    sage: R = Zp(5, prec=10000)
    sage: a = R.random_element()
    sage: b = R.random_element()
    sage: c = 1 + 5*R.random_element()
    sage: %timeit _ = a + b
    1.21 µs ± 9.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
    sage: %timeit _ = a * b
    87.8 µs ± 130 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
    sage: %timeit _ = a / b
    667 µs ± 4.08 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
    sage: %timeit _ = c.sqrt()
    27.4 ms ± 125 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
```


EDIT: use `%timeit` instead of `%time`


---

Comment by caruso created at 2021-01-26 20:01:45

Maybe some comments on the timings.
The "bad" performances of lazy p-adic come from two different sources:
- the underlying arithmetics looses a factor log(precision) in the complexity
- I'm working on digits, which means that I basically only manipulate integers between 0 and p (here p=5) and encode them on longs.

Although I cannot do much to get rid of the first problem, I can certainly do something for the second one: instead of working with digits, I can work with blocks of digits (limbs) of the correct size. Actually, I want to do this but this requires many changes in my current code and I planned to delay this for another ticket.

In any case, when p becomes larger, the differences of performances between lazy p-adics and classical p-adics tend to get smaller.


```
    sage: p = next_prime(2^63)
    sage: R = ZpL(p)

    sage: a = R.random_element()
    sage: b = R.random_element()
    sage: c = 1 + p*R.random_element()
    sage: %timeit _ = (a + b)@10000
    3.51 ms ± 407 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
    sage: %timeit _ = (a * b)@10000
    73.7 ms ± 189 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
    sage: %timeit _ = (a / b)@10000
    83.4 ms ± 471 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
    sage: %timeit _ = c.sqrt()@10000
    160 ms ± 3.31 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
```


and:


```
    sage: p = next_prime(2^63)
    sage: R = Zp(p, prec=10000)

    sage: a = R.random_element()
    sage: b = R.random_element()
    sage: c = 1 + p*R.random_element()
    sage: %timeit _ = a + b
    86.4 µs ± 578 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
    sage: %timeit _ = a * b
    9.04 ms ± 63.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
    sage: %timeit _ = a / b
    78.8 ms ± 415 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
    sage: %timeit _ = c.sqrt()
    672 ms ± 1.23 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```



---

Comment by git created at 2021-01-28 23:45:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-30 16:08:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-01-31 08:40:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-02-11 00:19:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-02-11 11:19:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-02-11 15:10:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2021-02-11 15:12:10

Changing status from new to needs_review.


---

Comment by caruso created at 2021-02-11 15:12:10

I guess that the ticket is ready for a first review...


---

Comment by git created at 2021-02-18 22:26:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by roed created at 2021-02-18 22:29:31

Some issues that we talked about on video:

* Add some halting parameters to the parent
* Inconsistency with valuation and set method.  Add a check parameter to `set` to ensure that the element satisfies the given equation (even with provided valuation and/or digits) or have `set` return `True` or `False` depending on whether the equation is satisfied.
* Figure out segfaults in gcd computations, conversions
* Change `selfref` to `unknown`

For another ticket: add more transcendental functions like `exp` and `log`


---

Comment by roed created at 2021-02-18 22:29:31

Changing status from needs_review to needs_work.


---

Comment by roed created at 2021-02-25 20:31:14

More comments as I read through the code.

* In `digit_smallest` you call `fmpz_init` but not `fmpz_clear`.  I think this is a memory leak.  I may have missed other leaks....  I also think that the documentation of `digit_smallest` should clarify that the input should already be in the range `0..p-1`.
* For `digit_sqrt` it may be worth using FLINT's `n_sqrtmod` if `p` is word-size.  You could also do some other easy cases in-line rather than calling out to Sage's integer_mod code.  See `square_root_mod_prime` in `sage/rings/finite_rings/integer_mod.pyx`.
* You should add documentation to `sage/misc/persist.pyx` on how `already_pickled` and `already_unpickled` are intended to work, and some tests to check that it's working correctly.
* When converting an element between a lazy p-adic ring and its field of fractions it looks in `_element_constructor_` that you create a bounded element.  Why is this necessary?  It also looks like you don't check that the primes are the same....
* The error codes in `padic_lazy_error.pyx` and `next_c()` aren't the same.
* In `_repr_` it looks like some print modes aren't included (e.g. `terse` and `val-unit`).  I would guess it to be easier to use code from `padic_printing.pyx` here.
* Last week we talked about adding some parameters about how halting is handled (e.g. a strict mode that raises an error whenever unbounded elements are compared).  `__nonzero__` should also be updated.  I think the precision behavior for `__nonzero__` should be the same as for `== 0`; currently it will return `True` rather than raising a precision error if it looks like `0` at known precision.
* I found the use of `permissive=None` a bit strange in `at_precision_absolute`.  I think if a user specifies infinite precision, `permissive` should be treated as `False` (so, replace `if permissive is False` with `if not permissive`.
* Shouldn't `at_precision_relative` also support `prec=infinity`?
* You can probably remove some code by changing `if error: raise_error(error)` to just `raise_error(error)` since this has no effect if error is 0.
* `_sub_` has a bug: currently `0-1` will give `1`.

More comments to come....


---

Comment by roed created at 2021-02-26 08:42:49

* In `next_c()` for random elements, do you need to `digit_clear(r)` in both branches of the if statement?
* It would be good to have some tests for slices of slices.
* In `next_c()` for `LazyElement_div`, if `definition is None` and you set it, don't you still want to execute the `else` clause?  If not, you can just `return self._bootstrap_c()` rather than `if error: return error`.  Same for `LazyElement_sqrt`.
* In the `__init__` method for `LazyElement_sqrt`, shouldn't you check that the valuation is even?
* You should probably delete the `next` method on `LazyElement_sqrt` (I assume it was for debugging; it's not documented).


---

Comment by caruso created at 2021-03-04 21:57:09

Replying to [comment:36 roed] and [comment:37 roed]:
> * In `digit_smallest` you call `fmpz_init` but not `fmpz_clear`.  I think this is a memory leak.  I may have missed other leaks....  I also think that the documentation of `digit_smallest` should clarify that the input should already be in the range `0..p-1`.
> * You should add documentation to `sage/misc/persist.pyx` on how `already_pickled` and `already_unpickled` are intended to work, and some tests to check that it's working correctly.
> * The error codes in `padic_lazy_error.pyx` and `next_c()` aren't the same.
> * I found the use of `permissive=None` a bit strange in `at_precision_absolute`.  I think if a user specifies infinite precision, `permissive` should be treated as `False` (so, replace `if permissive is False` with `if not permissive`.
> * Shouldn't `at_precision_relative` also support `prec=infinity`?
> * You can probably remove some code by changing `if error: raise_error(error)` to just `raise_error(error)` since this has no effect if error is 0.
> * `_sub_` has a bug: currently `0-1` will give `1`.
> * In `next_c()` for random elements, do you need to `digit_clear(r)` in both branches of the if statement?
> * It would be good to have some tests for slices of slices.
> * You should probably delete the `next` method on `LazyElement_sqrt` (I assume it was for debugging; it's not documented).

Fixed.

> * In `_repr_` it looks like some print modes aren't included (e.g. `terse` and `val-unit`).  I would guess it to be easier to use code from `padic_printing.pyx` here.

They are included.
I agree that we should include this code in `padic_printing.pyx` but it does not sounds easy.

> * When converting an element between a lazy p-adic ring and its field of fractions it looks in `_element_constructor_` that you create a bounded element.  Why is this necessary?  It also looks like you don't check that the primes are the same....

It's true than I call `LazyElement_bound` but I pass in `boundprec=maxordp` so that the resulting element remains unbounded. It's a convenient way to do copies. (I cannot return the same element because the parent changes.)

> * In `next_c()` for `LazyElement_div`, if `definition is None` and you set it, don't you still want to execute the `else` clause?  If not, you can just `return self._bootstrap_c()` rather than `if error: return error`.  Same for `LazyElement_sqrt`.

Well, `_bootstrap_c` already computes the first significant digit, so I think it's fine like this. I changed `if error: return error` to `return self._bootstrap_c()`.

> * In the `__init__` method for `LazyElement_sqrt`, shouldn't you check that the valuation is even?

It's checked in the bootstrap function.
I think we cannot check it in the `__init__` method because the valuation might be not known for self-referent numbers.
----
New commits:


---

Comment by caruso created at 2021-03-04 22:00:32

And here the comments I have not addressed yet:

> * Last week we talked about adding some parameters about how halting is handled (e.g. a strict mode that raises an error whenever unbounded elements are compared).  `__nonzero__` should also be updated.  I think the precision behavior for `__nonzero__` should be the same as for `== 0`; currently it will return `True` rather than raising a precision error if it looks like `0` at known precision.
> * Inconsistency with valuation and set method.  Add a check parameter to `set` to ensure that the element satisfies the given equation (even with provided valuation and/or digits) or have `set` return `True` or `False` depending on whether the equation is satisfied.
> * Figure out segfaults in gcd computations, conversions
> * Change `selfref` to `unknown`
> * For `digit_sqrt` it may be worth using FLINT's `n_sqrtmod` if `p` is word-size.  You could also do some other easy cases in-line rather than calling out to Sage's integer_mod code.  See `square_root_mod_prime` in `sage/rings/finite_rings/integer_mod.pyx`.


---

Comment by git created at 2021-03-04 22:01:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-03-24 02:04:25

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.


---

Comment by git created at 2021-04-01 22:38:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-04-04 18:46:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-04-04 19:50:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2021-04-04 19:52:22

I think that all your comments have been addressed now.

We still need to discuss the choice of the name for the classes implemented in this ticket (cf discussion on zulip).


---

Comment by caruso created at 2021-04-04 19:52:22

Changing status from needs_work to needs_review.


---

Comment by git created at 2021-04-07 09:16:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-04-22 20:58:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2021-04-22 21:02:21

I changed the naming (`Relaxed` instead of `Lazy`, `ZpER` instead of `ZpL`).

Ticket ready for a second review.


---

Comment by git created at 2021-04-28 12:55:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-04-28 13:05:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by roed created at 2021-04-28 20:54:46

Changing status from needs_review to positive_review.


---

Comment by roed created at 2021-04-28 20:54:46

Looks good to me!  I think any additional issues can be addressed in followup tickets.


---

Comment by git created at 2021-04-29 06:20:49

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2021-04-29 06:20:49

Changing status from positive_review to needs_review.


---

Comment by caruso created at 2021-04-29 06:22:00

Changing status from needs_review to positive_review.


---

Comment by caruso created at 2021-04-29 06:22:00

Great, thanks!
I set again the ticket to positive review, I've just fixed two typos.


---

Comment by git created at 2021-05-01 11:27:25

Changing status from positive_review to needs_review.


---

Comment by git created at 2021-05-01 11:27:25

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by caruso created at 2021-05-01 11:27:43

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-05-27 20:30:03

Resolution: fixed


---

Comment by mkoeppe created at 2021-06-03 22:33:33

Looks like this broke the build --> #31903
