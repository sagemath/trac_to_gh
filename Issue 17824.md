# Issue 17824: Fix Newform.atkin_lehner_eigenvalue() for coefficient fields other than QQ

Issue created by migration from https://trac.sagemath.org/ticket/18061

Original creator: pbruin

Original creation time: 2015-03-26 18:20:08

CC:  klui was jpflori

Keywords: newform Atkin-Lehner operator

Consider the following newform of weight 2 for Γ<sub>1</sub>(30) with coefficients in *Q*(_i_):

```
sage: f = Newforms(Gamma1(30), 2, names='a')[1]; f
q + a1*q^2 - a1*q^3 - q^4 + (a1 - 2)*q^5 + O(q^6)
sage: f.base_ring()
Number Field in a1 with defining polynomial x^2 + 1
sage: f.character()
Dirichlet character modulo 30 of conductor 5 mapping 11 |--> 1, 7 |--> -1
```

The method `atkin_lehner_eigenvalue()` returns a nonsensical result:

```
sage: f.atkin_lehner_eigenvalue()
-2
```

This is just the upper left entry of the matrix of the Atkin-Lehner operator _W_<sub>30</sub> with respect to some basis of the space of modular symbols attached to _f_:

```
sage: f.modular_symbols(sign=1).atkin_lehner_operator()
Hecke module morphism Atkin-Lehner operator W_30 defined by the matrix
[-2 -3]
[ 1  2]
Domain: Modular Symbols subspace of dimension 2 of Modular Symbols space ...
Codomain: Modular Symbols subspace of dimension 2 of Modular Symbols space ...
```

The correct result is in fact only a _pseudo_-eigenvalue; it is a complex number _η_ of absolute value 1 such that _W_<sub>30</sub>_f_ = _ηf_<sup>*</sup>, where _f_<sup>*</sup> is the form whose coefficients are the complex conjugates of those of _f_.


---

Comment by pbruin created at 2015-03-26 18:33:19

A relevant sage-nt discussion: https://groups.google.com/forum/#!topic/sage-nt/SoBQfo0QnwM


---

Comment by pbruin created at 2015-03-27 11:03:09

The implementation should probably use the formulae from this paper: A.O.L. Atkin and Wen-Ch'ing Winnie Li, Twists of newforms and pseudo-eigenvalues of _W_-operators, _Inventiones math._ *48* (1978), 221–243.


---

Comment by pbruin created at 2015-03-27 12:58:55

I am working on implementing this using a more general method `atkin_lehner_action()` that returns a pair `(eta, f_star)`, where `eta` is the pseudo-eigenvalue and `f_star` is the conjugate form.


---

Comment by pbruin created at 2015-04-30 17:25:31

Changing status from new to needs_review.


---

Comment by pbruin created at 2015-05-06 14:28:56

Note: the branch merges cleanly with 6.7.beta4 despite the name in the "Branch" field being red.


---

Comment by git created at 2015-05-18 10:18:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-05-19 17:47:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by davidloeffler created at 2015-05-21 12:27:27

Hi Peter! It's great that someone has got around to implementing this at last. But there are some things needing a little more work:

- I think it's not good that the new implementation returns `NotImplementedError` on some cases where the _old_ implementation was correct and valid:

```
# old implementation
sage: F = Newforms(169,names='a')[0]
sage: F[13]
0
sage: F.atkin_lehner_eigenvalue(169)
-1
```

 Here the A-L operator on the modular symbols space is actually a diagonal matrix, so taking its top left entry is the right thing to do:

```
sage: F.modular_symbols(sign=0).atkin_lehner_operator(169).matrix()
[-1  0  0  0]
[ 0 -1  0  0]
[ 0  0 -1  0]
[ 0  0  0 -1]
```

 With your patch this bombs out at `NotImplementedError: action of W_Q is not implemented if a_Q(f) = 0`. If I'm not mistaken, the old implementation is correct if (and maybe only if) the character is trivial, while your new implementation will refuse to handle any case where the character is trivial and the base field is not QQ. (The old algorithm can be easily patched up to work whenever the Q-part of the character is trivial.)

- The error message returned if Q is not an exact divisor of N is very uninformative:

```

sage: F = Newforms(20, 8, names='a')[1]; F
q - a1*q^3 + 125*q^5 + O(q^6)
sage: F.atkin_lehner_action(2)
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-36-b33b9d9d015f> in <module>()
----> 1 F.atkin_lehner_action(Integer(2))

/storage/masiao/sage/local/lib/python2.7/site-packages/sage/modular/modform/element.pyc in atkin_lehner_action(self, d, embedding)
   1224         Q = q**e
   1225         M = d // Q
-> 1226         eps_Q = [eps for eps in self.character().decomposition() if eps.modulus() == Q][0]
   1227         eps = eps_Q(M)
   1228         if embedding is not None:

IndexError: list index out of range
```

 I would actually favour handing the special case where Q is a prime separately (interpreting it as W_p<sup>e</sup> where p<sup>e</sup> is the power of p dividing N). The `atkin_lehner_operator` method of modular symbol spaces does something along these lines. But in any case it should react more intelligently than this.

- This error message is misleading:

```
sage: F.atkin_lehner_action(4)
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
<ipython-input-77-65866aefe137> in <module>()
----> 1 F.atkin_lehner_action(Integer(4))

/storage/masiao/sage/local/lib/python2.7/site-packages/sage/modular/modform/element.pyc in atkin_lehner_action(self, d, embedding)
   1229             eps = embedding(eps)
   1230         eta0, g0 = self.atkin_lehner_action(M, embedding)
-> 1231         eta1, g1 = g0._atkin_lehner_action_prime_power(Q, embedding)
   1232         return eps * eta0 * eta1, g1
   1233 

/storage/masiao/sage/local/lib/python2.7/site-packages/sage/modular/modform/element.pyc in _atkin_lehner_action_prime_power(self, Q, embedding)
   1135         a_Q = self[Q]
   1136         if not a_Q:
-> 1137             raise NotImplementedError("action of W_Q is not implemented if a_Q(f) = 0")
   1138         epsilon = self.character()
   1139         eps_Q = [eps for eps in epsilon.decomposition() if eps.modulus() == Q][0]

NotImplementedError: action of W_Q is not implemented if a_Q(f) = 0
```

 This action *is* implemented in some cases -- when the base ring is QQ (and it should be implemented in more). We don't want to sell our capabilities short here.

 - Your implementation will always fail for odd weights:

```
sage: Newforms(Gamma1(15), 3, names='a')
[q - q^2 + 3*q^3 - 3*q^4 - 5*q^5 + O(q^6),
 q + q^2 - 3*q^3 - 3*q^4 + 5*q^5 + O(q^6),
 q + a2*q^2 + (-a2 - 2)*q^3 - q^4 - a2*q^5 + O(q^6),
 q + a3*q^2 + (3/5*a3^3 + 11/5*a3^2 + 22/5*a3 - 11/5)*q^3 + (-8/5*a3^3 - 31/5*a3^2 - 72/5*a3 + 16/5)*q^4 + (a3^3 + 4*a3^2 + 6*a3 - 6)*q^5 + O(q^6)]
sage: f = _[2]
sage: f.atkin_lehner_eigenvalue(5)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-87-4262769bbfb2> in <module>()
----> 1 f.atkin_lehner_eigenvalue(Integer(5))

/storage/masiao/sage/local/lib/python2.7/site-packages/sage/modular/modform/element.pyc in atkin_lehner_eigenvalue(self, d, embedding)
   1285         if d is None:
   1286             d = self.level()
-> 1287         eta, g = self.atkin_lehner_action(d, embedding)
   1288         if g != self:
   1289             raise ValueError("%r is not an eigenform for W_%r" % (self, d))

/storage/masiao/sage/local/lib/python2.7/site-packages/sage/modular/modform/element.pyc in atkin_lehner_action(self, d, embedding)
   1229             eps = embedding(eps)
   1230         eta0, g0 = self.atkin_lehner_action(M, embedding)
-> 1231         eta1, g1 = g0._atkin_lehner_action_prime_power(Q, embedding)
   1232         return eps * eta0 * eta1, g1
   1233 

/storage/masiao/sage/local/lib/python2.7/site-packages/sage/modular/modform/element.pyc in _atkin_lehner_action_prime_power(self, Q, embedding)
   1149         lambda_Q = g / a_Q
   1150         Q = lambda_Q.parent()(Q)
-> 1151         return Q**(self.weight()/2 - 1) * lambda_Q, f_star
   1152 
   1153     def atkin_lehner_action(self, d, embedding=None):

/storage/masiao/sage/src/sage/structure/element.pyx in sage.structure.element.RingElement.__mul__ (build/cythonized/sage/structure/element.c:17184)()
   1905         elif PyInt_CheckExact(left):
   1906             return (<ModuleElement>right)._mul_long(PyInt_AS_LONG(left))
-> 1907         return coercion_model.bin_op(left, right, mul)
   1908 
   1909     cpdef RingElement _mul_(self, RingElement right):

/storage/masiao/sage/src/sage/structure/coerce.pyx in sage.structure.coerce.CoercionModel_cache_maps.bin_op (build/cythonized/sage/structure/coerce.c:9131)()
   1044         # We should really include the underlying error.
   1045         # This causes so much headache.
-> 1046         raise TypeError, arith_error_message(x,y,op)
   1047 
   1048     cpdef canonical_coercion(self, x, y):

TypeError: unsupported operand parent(s) for '*': 'Symbolic Ring' and 'Number Field in a2 with defining polynomial x^2 + 5'
```

 Sage doesn't know which square root of 5 to take here, so it returns sqrt(5) in the symbolic ring, which of course causes an error when you try to multiply it by something in the base ring of f. Are you trying to renormalise the Atkin--Lehner operator so as to be an involution in all weights? This can't be done Galois-equivariantly, and is inconsistent with normalisations elsewhere in Sage. (There's a great quote from Deligne re these normalisations: "Langlands is very sure he knows what the square root of p is. I have never been so sure".) I personally favour the normalisation where W_Q<sup>2</sup> is Q^(k/2 - 1)^ up to a root of unity, which *is* Galois equivariant.


---

Comment by davidloeffler created at 2015-05-21 12:27:43

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-05-22 08:49:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2015-05-22 09:01:05

Hi David,

Thanks a lot for taking a look at this!

> - I think it's not good that the new implementation returns `NotImplementedError` on some cases where the _old_ implementation was correct and valid:
Fixed by first checking if the Atkin-Lehner matrix is a scalar.

> - The error message returned if Q is not an exact divisor of N is very uninformative:
> [...]
>  I would actually favour handing the special case where Q is a prime separately (interpreting it as W_p<sup>e</sup> where p<sup>e</sup> is the power of p dividing N). The `atkin_lehner_operator` method of modular symbol spaces does something along these lines.
The argument `d` is now handled in the same way as in the `atkin_lehner_operator` method of modular symbol spaces.
> - This error message is misleading:
> {{{
> ...
> NotImplementedError: action of W_Q is not implemented if a_Q(f) = 0
> }}}
>  This action *is* implemented in some cases -- when the base ring is QQ (and it should be implemented in more). We don't want to sell our capabilities short here.
I changed `if a_Q(f) = 0` to `for general newforms with a_Q(f) = 0`.

> - Your implementation will always fail for odd weights:
> [...]
>  Are you trying to renormalise the Atkin--Lehner operator so as to be an involution in all weights? This can't be done Galois-equivariantly, and is inconsistent with normalisations elsewhere in Sage. (There's a great quote from Deligne re these normalisations: "Langlands is very sure he knows what the square root of p is. I have never been so sure".) I personally favour the normalisation where W_Q<sup>2</sup> is Q^(k/2 - 1)^ up to a root of unity, which *is* Galois equivariant.

I was somehow convinced that the normalisation I used was consistent with the rest of sage, but apparently it isn't.  I changed it as you suggested (I think; did you mean W_Q<sup>2</sup> = Q^(k - 2)^ up to a root of unity?).


---

Comment by pbruin created at 2015-05-22 09:05:44

The following still fails:

```
sage: f = Newforms(Gamma1(15), 3, names='a')[2]
sage: f.atkin_lehner_eigenvalue(5)
Traceback (most recent call last):
...
ValueError: q + a2*q^2 + (-a2 - 2)*q^3 - q^4 - a2*q^5 + O(q^6) is not an eigenform for W_5
```

This is wrong because `f` _is_ an eigenform for `W_5`:

```
sage: f
q + a2*q^2 + (-a2 - 2)*q^3 - q^4 - a2*q^5 + O(q^6)
sage: _, g = f.atkin_lehner_action(5); g
q + a2*q^2 + (-a2 - 2)*q^3 - q^4 - a2*q^5 + O(q^6)
```

The reason is probably that the parents of `f` and `g` are different:

```
sage: parent(f)
Cuspidal subspace of dimension 8 of Modular Forms space of dimension 24 for Congruence Subgroup Gamma1(15) of weight 3 over Number Field in a2 with defining polynomial x^2 + 5
sage: parent(g)
Cuspidal subspace of dimension 2 of Modular Forms space of dimension 6, character [-1, 1] and weight 3 over Number Field in a2 with defining polynomial x^2 + 5
```



---

Comment by davidloeffler created at 2015-05-22 09:14:37

Here's another gripe. The following is waaay too slow:

```
sage: F = Newforms(299,names='a')[0]
sage: time F.atkin_lehner_eigenvalue(299)
CPU times: user 4.99 s, sys: 18.9 ms, total: 5.01 s
Wall time: 5 s
1
```

What on earth can be taking the time here? According to the profiler, the total time is 5.028 seconds, of which 5.026 is spent in four calls to the "twist" routine. Ultimately, most of that is actually spent creating Dirichlet character groups over number fields, which requires factoring some fairly large polynomials over those number fields. Why on earth is this necessary, or even relevant? Evaluating an Atkin--Lehner eigenvalue can't possibly require factorising 82 polynomials over number fields!


---

Comment by pbruin created at 2015-05-23 06:53:21

The bug in comment:15 is fixed by #18478.


---

Comment by git created at 2015-05-23 07:03:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2015-05-23 07:11:29

Replying to [comment:16 davidloeffler]:
> Here's another gripe. The following is waaay too slow:
> {{{
> sage: F = Newforms(299,names='a')[0]
> sage: time F.atkin_lehner_eigenvalue(299)
> CPU times: user 4.99 s, sys: 18.9 ms, total: 5.01 s
> Wall time: 5 s
> 1
> }}}
> What on earth can be taking the time here? According to the profiler, the total time is 5.028 seconds, of which 5.026 is spent in four calls to the "twist" routine.
You are right, `twist()` can and should be made much faster.  I propose to do this either on #18086 or on a follow-up ticket; I think this one can go back to needs_review.


---

Comment by pbruin created at 2015-05-23 07:11:29

Changing status from needs_work to needs_review.


---

Comment by davidloeffler created at 2015-05-27 18:51:22

I think there are still some cases where the modular symbol algorithm actually works, but this implementation doesn't realise it. Here are two ways this can come up:

- It can happen that the action of W_Q on f is multiplication by a scalar in the Hecke eigenvalue field of f, but not one which is in the base ring of f. Then the matrix of W_Q on the modular symbol space is not obviously recognisable as a scalar, but is contained in the subalgebra of the endomorphisms of the mod sym space generated by the Hecke operators (which is isomorphic to the Hecke eigenvalue field), and one should really recognise it as such and return the appropriate number field element. This comes up for my level 15 weight 3 example, where the W_5 eigenvalue is a square root of -5, but not just any square root -- rather, a specific one lying in the Hecke eigenvalue field of f:

```
sage: Newforms(Gamma1(15), 3, names='a')
[q - q^2 + 3*q^3 - 3*q^4 - 5*q^5 + O(q^6),
 q + q^2 - 3*q^3 - 3*q^4 + 5*q^5 + O(q^6),
 q + a2*q^2 + (-a2 - 2)*q^3 - q^4 - a2*q^5 + O(q^6),
 q + a3*q^2 + (3/5*a3^3 + 11/5*a3^2 + 22/5*a3 - 11/5)*q^3 + (-8/5*a3^3 - 31/5*a3^2 - 72/5*a3 + 16/5)*q^4 + (a3^3 + 4*a3^2 + 6*a3 - 6)*q^5 + O(q^6)]
sage: F = _[2]
sage: M = F.modular_symbols(sign=0)
sage: M.atkin_lehner_operator(5).matrix()
[  -1/5 -39/10 -33/10    3/2]
[   9/5 -19/10 -63/10  -13/2]
[  -3/5    9/5   28/5      6]
[     0   -3/2   -9/2   -7/2]
sage: M.hecke_operator(5).matrix()
[  1/5 39/10 33/10  -3/2]
[ -9/5 19/10 63/10  13/2]
[  3/5  -9/5 -28/5    -6]
[    0   3/2   9/2   7/2]
```


- It can also happen that calculating the action of W_Q on the modular symbols space fails if you use "sign = 1" (as in your implementation). This is because the Atkin--Lehner operator and the star involution don't commute, although they do when restricted to an eigenspace on which the diamond operators at Q are trivial (if I remember rightly, the commutator of the two operators is exactly eps_Q(-1)). So one can get spurious linear algebra errors working on the sign 1 symbols, because the action of W_Q on the whole space is not defined, even though it is defined on the subspace we care about. This also comes up in the above example:

```
sage: F.modular_symbols(sign=1).atkin_lehner_operator(5) 
...
ArithmeticError: subspace is not invariant under matrix
```

I have a proof-of-concept implementation lying around on my hard drive which avoids these pitfalls, and I can merge it with your implementation to cover these extra cases; but this is definitely an enhancement of your work rather than a bug, and I won't have time to work on it for a week or so since I am away at a conference. So I will leave the ticket at needs_review for now, in case anybody else wants to look at it.


---

Comment by davidloeffler created at 2015-06-03 10:19:52

I had another look at your implementation. When using the modular-symbols algorithm, why do you take the conjugate of the (0,0) matrix entry? This is going to be quite slow to compute (because Sage has to verify from first principles that the coefficient fields are CM); and, more importantly, isn't it clearly the wrong answer?

(Maybe Sage's conventions for Atkin--Lehner operators aren't the same as Atkin and Li, and the conjugation is the difference between conventions; but I think it would be very bad and confusing if Sage's conventions weren't internally consistent!)


---

Comment by davidloeffler created at 2015-06-03 11:21:34

I checked this against a newform of level 21 and character of conductor 7, and it does indeed appear to be the case that the Atkin--Lehner operator as currently implemented in Sage differs from Atkin and Li's conventions (even in weight 2, where the issue of powers of Q does not arise).

Sage's definition of the Atkin--Lehner operator seems to be that W<sub>Q</sub><sup>2</sup> = e<sub>Q</sub>(-1) e<sub>N/Q</sub>(Q), while Atkin and Li require that W<sub>Q</sub><sup>2</sup> = e<sub>Q</sub>(-1) e<sub>N/Q</sub>(Q)<sup>-1</sup>.

So there's a choice to be made here: we must have either an inconsistency between different parts of Sage, an inconsistency between Sage and Atkin--Li, or a non-backward-compatible change of conventions.

I would actually favour the second option: there are plenty of other papers in the literature which use the convention W<sub>Q</sub><sup>2</sup> = Q<sup>k-2</sup>e<sub>Q</sub>(-1) e<sub>N/Q</sub>(Q). The great advantage of this convention is that if you use it, then the pseudo-eigenvalues l<sub>Q</sub> satisfy l<sub>QQ'</sub> = l<sub>Q</sub> l<sub>Q'</sub>, which is not the case with Atkin and Li's conventions.


---

Comment by davidloeffler created at 2015-06-03 16:55:14

OK, here's my best attempt to merge your implementation and mine to cover the absolute maximum range of cases (sticking with the Atkin--Li conventions for now). 
----
New commits:


---

Comment by git created at 2015-06-03 16:58:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2015-06-03 19:29:42

I uploaded a rebased branch (by cherry-picking the relevant commits) on top of #18086.  The reasons are (1) there were some duplicate commits (from the two versions of #18086) and merges of dependencies that are no longer needed since they are in the latest beta, and (2) merging the new branch from #18086 accidentally caused two copies of the method `Newform.twist()` to be present.  Hopefully we now have a clean branch to work on.


---

Comment by pbruin created at 2015-06-03 19:36:20

Replying to [comment:21 davidloeffler]:
> I had another look at your implementation. When using the modular-symbols algorithm, why do you take the conjugate of the (0,0) matrix entry? This is going to be quite slow to compute (because Sage has to verify from first principles that the coefficient fields are CM); and, more importantly, isn't it clearly the wrong answer?
To be honest I ran into this through a doctest failure, and figured that in all probability either the (0,0) entry or its conjugate would be the correct value, with the conjugate being explained by some sesquilinear pairing intervening somewhere...
> (Maybe Sage's conventions for Atkin--Lehner operators aren't the same as Atkin and Li, and the conjugation is the difference between conventions; but I think it would be very bad and confusing if Sage's conventions weren't internally consistent!)
I didn't realise that the various conventions for the Atkin-Lehner operator differ in other ways than by a power of _Q_.  We should carefully document what convention we use and how it differs from others!


---

Comment by git created at 2015-06-04 23:26:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-08-19 13:12:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2015-08-19 13:15:20

New commits:
- changes to `gauss_sum()` and `gauss_sum_numerical()` over `QQbar` should be done on the new ticket #19056 (it does not seem to be essential for this ticket, `gauss_sum()` and `gauss_sum_numerical()` should behave differently, and we should add doctests)
- use correct precision in computation of root number in `lseries()`
- clean up whitespace


---

Comment by git created at 2015-08-19 13:21:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-08-19 14:08:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-08-20 12:05:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2015-08-20 12:07:16

I changed `_atkin_lehner_action_from_{qexp,modsym}` to use the Sage convention instead of the Atkin-Li convention for Atkin-Lehner operators.  We still have to document this clearly.


---

Comment by git created at 2015-08-20 13:17:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2015-08-20 14:22:43

After fixing the ticket description, I hope everything is consistent now.


---

Comment by davidloeffler created at 2015-12-04 15:33:44

Hi Peter,

Mega-pedantic comment: in the docstring for "def atkin_lehner_eigenvalue", the "NOTE" is untrue (as the accompanying example shows). It would be nice if we could get this merged, but our contributions are now so much intertwined that we can't really review each other's code -- we need a third-party reviewer.


---

Comment by davidloeffler created at 2015-12-04 15:33:44

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-12-07 22:16:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2015-12-07 22:17:08

Hi David,
> Mega-pedantic comment: in the docstring for "def atkin_lehner_eigenvalue", the "NOTE" is untrue (as the accompanying example shows).
Removed in the last commit, thanks for spotting this!
> It would be nice if we could get this merged, but our contributions are now so much intertwined that we can't really review each other's code -- we need a third-party reviewer.
I agree.


---

Comment by pbruin created at 2015-12-07 22:17:20

Changing status from needs_work to needs_review.


---

Comment by davidloeffler created at 2015-12-10 09:32:37

Changing status from needs_review to needs_work.


---

Comment by davidloeffler created at 2015-12-10 09:32:37

This now doesn't merge, because it conflicts with #19668 (merged in 6.10.rc0). I'll upload a rebased version shortly.


---

Comment by git created at 2015-12-10 13:09:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by davidloeffler created at 2015-12-10 13:13:35

I rebased it to 6.10.rc0, and created a new public branch.


---

Comment by davidloeffler created at 2015-12-10 13:13:35

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-08-11 07:49:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-10-11 14:29:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-10-13 06:53:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-01-06 09:27:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2017-01-06 09:28:42

References had to be changed due to #21454.


---

Comment by pbruin created at 2017-01-27 08:20:53

Failing doctests in `sage/modular/abvar/lseries.py`, see [patchbot report](https://patchbot.sagemath.org/log/18061/Ubuntu/16.04/x86_64/3.13.0-83-generic/poseidon/2017-01-26%2018:44:56?short)


---

Comment by pbruin created at 2017-01-27 08:20:53

Changing status from needs_review to needs_work.


---

Comment by pbruin created at 2017-01-30 13:56:51

I am CC-ing Kevin Lui and William Stein because the failing doctest was introduced in #21496.  I suspect that the numerical value occurring in the following doctest may be incorrect:

```
sage: L = J1(23).lseries(); L
Complex L-series attached to Abelian variety J1(23) of dimension 12
sage: L(1)
1.71571957480487e-7
```


With the current branch, the doctest fails with a `ValueError` because some of the cusp forms occurring in the decomposition of J_1(23) are not eigenforms for the Atkin-Lehner operator.  After fixing the method `ModularForm_abstract.lseries()` to dispense with this assumption (work in progress, not pushed yet), I get

```
sage: L = J1(23).lseries(); L
Complex L-series attached to Abelian variety J1(23) of dimension 12
sage: L(1)
0.000129519861426989 + 1.14001148377577e-19*I
```

This value agrees with the product of all special values _L_(_f_, 1) with _f_ ranging over the 12 complex primitive forms of weight 2 for Gamma_1(23), which according to the LMFDB pages for the modular forms [23.2.1.a](http://www.lmfdb.org/ModularForm/GL2/Q/holomorphic/23/2/1/a/) and [23.2.2.a](http://www.lmfdb.org/ModularForm/GL2/Q/holomorphic/23/2/2/a/) are

```
0.4503793707,
0.5516057856,
0.2732227586 - 0.2394635951*I,
0.4450567187 + 0.2281314535*I,
0.5144735331 + 0.0030140754*I,
0.4295189659 - 0.1720855959*I,
0.5226459551 - 0.0741564295*I,
0.5226459551 + 0.0741564295*I,
0.4295189659 + 0.1720855959*I,
0.5144735331 - 0.0030140754*I,
0.4450567187 - 0.2281314535*I,
0.2732227586 + 0.2394635951*I
```

(follow the various links to the L-functions on these pages, and look at the values _L_(_f_, 1/2); note that LMFDB uses the "analytic" normalisation).

Unfortunately, Magma agrees with neither of the above two values:

```
> Evaluate(LSeries(JOne(23)), 1);
8.07776970747857754200906998408E-8 + 5.36796212774822177732076691797E-8*i
```



---

Comment by pbruin created at 2017-01-30 14:26:52

Here is a smaller example of incorrectly computed special _L_-values of cusp forms:

```
sage: f = Newforms(Gamma1(13), 2, names='a')[0]  # coefficient field QQ(zeta_3)
sage: f.lseries(embedding=0)(1)
0.150417043086554 - 0.0100341694561220*I
sage: f.lseries(embedding=1)(1)
0.150417043086554 + 0.0100341694561220*I
sage: J1(13).lseries()(1)  # product of the above two
0.0227259714075763
```

With my branch, these become

```
sage: f.lseries(embedding=0)(1)
0.298115272465799 - 0.0402203326076734*I
sage: f.lseries(embedding=1)(1)
0.298115272465799 + 0.0402203326076732*I
sage: J1(13).lseries()(1)  # product of the above two
0.0904903908324296 - 4.51028103753970e-17*I
```

which agrees with the LMFDB data for [newform 13.2.4.a](http://www.lmfdb.org/ModularForm/GL2/Q/holomorphic/13/2/4/a/).

Here Magma is almost certainly wrong (the result should be close to a real number):

```
> Evaluate(LSeries(JOne(13)), 1);
0.00926625827718259912085805050640 - 0.0306402029795322002630256221347*i
```



---

Comment by git created at 2017-01-30 16:39:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2017-01-30 16:42:09

Here are some improvements that should fix the above problems.


---

Comment by pbruin created at 2017-01-30 16:42:09

Changing status from needs_work to needs_review.


---

Comment by git created at 2017-03-13 08:27:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2017-03-13 20:02:00

green bot, please review


---

Comment by git created at 2017-03-28 12:03:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2017-03-28 12:05:17

Improved a doctest to avoid failures due to "numerical noise".


---

Comment by git created at 2017-03-31 07:11:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2017-04-05 10:15:37

green bot


---

Comment by chapoton created at 2017-05-10 11:21:10

green bot ! experts and interested people, please look at this ticket !


---

Comment by chapoton created at 2017-05-18 19:05:27

**PING** ?


---

Comment by git created at 2017-07-11 07:54:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pbruin created at 2017-07-11 07:58:52

The "blocks" plugin of the patchbot complains about the `.. SEEALSO::` blocks inserted by this ticket; see [this report](https://patchbot.sagemath.org/log/18061/Ubuntu/15.10/x86_64/3.13.0-123-generic/sagemath-patchbot-docker/2017-07-06%2006:51:02?plugin=blocks&diff=/log/0/Ubuntu/15.10/x86_64/3.13.0-123-generic/sagemath-patchbot-docker/2017-07-05%2023%3A23%3A47&ticket=18061&base=8.0.rc1).  One of them was missing a colon, but the others had the correct syntax as far as I can see.

Frédéric, could you perhaps check the plugin to see if it is doing the right thing?


---

Comment by chapoton created at 2017-07-11 08:01:40

This has been fixed already. In fact, patchbot 2.6.9 is not quite the latest, but I forgot to make a tag for 2.7.0

EDIT: patchbot 2.7.0 now officially the latest version


---

Comment by chapoton created at 2017-08-26 14:01:26

I think one could set this one to positive-review. There is one fully-green bot.

Confirmation, somebody ?


---

Comment by pbruin created at 2017-08-30 13:11:44

Replying to [comment:68 chapoton]:
> I think one could set this one to positive-review. There is one fully-green bot.
> 
> Confirmation, somebody ?
Personally I would be very happy if this could finally be merged.  It fixes known bugs and is not known to introduce new ones.  If someone could verify that the fixed doctests in `sage/modular/abvar/lseries.py` are correct (see comment:51) then maybe together with the fact that David and I have looked at each other's code, that could count as a positive review?


---

Comment by chapoton created at 2017-08-30 13:31:41

ok, let it be. It has been waiting for long enough.

EDIT: I confirm that magma V2.22-3 has not the same value as us for J1(23). Let us keep that for another ticket.


---

Comment by chapoton created at 2017-08-30 13:31:41

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-09-04 06:11:08

Resolution: fixed
