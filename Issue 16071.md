# Issue 16071: Improve sums of squares

Issue created by migration from https://trac.sagemath.org/ticket/16308

Original creator: jdemeyer

Original creation time: 2014-05-08 09:28:38

CC:  ncohen kcrisman vdelecroix

Writing an integer as sum of N squares.


---

Comment by pbruin created at 2014-05-08 09:53:50

Changing component from basic arithmetic to number theory.


---

Comment by pbruin created at 2014-05-08 13:51:40

Replying to [comment:2 jdemeyer]:

OK, I should have written a comment to ask what the idea was instead of adding possible interpretations to the description.  Given that your name is in the Author field, are you working on this?


---

Comment by leif created at 2014-05-08 14:02:19

Define "number".


---

Comment by jdemeyer created at 2014-05-08 15:59:34

Replying to [comment:6 leif]:
> Define "number".
Element of `ZZ`.


---

Comment by jdemeyer created at 2014-05-08 16:15:54

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2014-05-08 16:15:54

New commits:


---

Comment by jdemeyer created at 2014-05-08 16:25:42

It is embarrassing to say so, but for many examples, the old GAP code is actually faster. The reason seems to be that GAP beats PARI on factoring small numbers (which is a big surprise to me!). But GAP doesn't support large numbers:

```
sage: two_squares(3^100+1)
RuntimeError: Gap produced error output
Error, sorry,  cannot factor [ 1109667565348268894775749972955601 ]
type 'return;' to try again with a larger number of trials in
FactorsRho (or use option 'RhoTrials')


   executing TwoSquares(515377520732011331036461129765621272702107522002);

```



---

Comment by jdemeyer created at 2014-05-08 16:31:52

GAP is amazing:


```
sage: timeit('libgap(19180172397815991981).FactorsInt()', number=1000, repeat=10)
1000 loops, best of 10: 103 µs per loop
sage: timeit('pari(19180172397815991981).factor(proof=False)', number=1000, repeat=10)
1000 loops, best of 10: 2.43 ms per loop
```



---

Comment by pbruin created at 2014-05-08 16:47:12

Interesting...  Since this code is probably not the place where Sage should have to make a decision about which factoring algorithm to use, it looks tempting to use `Integer.factor()` instead of `pari.factor()` and spend some effort on #1145.  (And possibly add support for `algorithm=gap` in `Integer.factor()` if it is worthwhile?)


---

Comment by leif created at 2014-05-08 16:59:46

And I'd still support the `algorithm` keyword...

Does make returning `(a,b)` with a (or b) zero any sense?


---

Comment by leif created at 2014-05-08 17:19:22

Replying to [comment:13 leif]:
> Does make returning `(a,b)` with a (or b) zero any sense?

To be more precise, IMHO both a and b should be < n<sup>1/2</sup> (for `two_squares()`).

I don't think anybody would expect e.g. `two_squares(25)` to return the trivial solution `(0,5)` instead of `(3,4)`.


---

Comment by leif created at 2014-05-08 17:32:08

(GAP apparently only returns (0,sqrt(n)) if there is no other solution, with sqrt(n) integer of course.)


---

Comment by kcrisman created at 2014-05-08 17:58:52

> I don't think anybody would expect e.g. two_squares(25) to return the trivial solution (0,5) instead of (3,4).
Hmm, well that IS a solution.  And if you want to use it to approximate the value of pi, you need all of them (though this one in any case wouldn't give negative solutions).


---

Comment by leif created at 2014-05-08 18:02:01

Replying to [comment:16 kcrisman]:
> > I don't think anybody would expect e.g. two_squares(25) to return the trivial solution (0,5) instead of (3,4).
> Hmm, well that IS a solution.

Depends on the definition of two_squares(); the previous one in Sage was pretty vague.


---

Comment by jdemeyer created at 2014-05-08 19:45:23

Replying to [comment:14 leif]:
> I don't think anybody would expect e.g. `two_squares(25)` to return the trivial solution `(0,5)` instead of `(3,4)`.

From a number-theory point of view, there is nothing wrong with `(0,5)`. In fact, in some cases, the only solution is the "trivial" one, for example for 9.


---

Comment by jdemeyer created at 2014-05-08 19:49:18

Replying to [comment:12 pbruin]:
> Interesting...  Since this code is probably not the place where Sage should have to make a decision about which factoring algorithm to use, it looks tempting to use `Integer.factor()` instead of `pari.factor()`
I guess you're right, but I decided to do everything in PARI for speed, also with the idea that the code could be changed to use direct calls to the PARI library if needed.


---

Comment by leif created at 2014-05-08 19:51:34

Replying to [comment:18 jdemeyer]:
> Replying to [comment:14 leif]:
> > I don't think anybody would expect e.g. `two_squares(25)` to return the trivial solution `(0,5)` instead of `(3,4)`.
> 
> From a number-theory point of view, there is nothing wrong with `(0,5)`. In fact, in some cases, the only solution is the "trivial" one, for example for 9.

As mentioned, depends on how you specify two_squares().

From a user perspective, I think there should be some optional argument `no_trivial_solutions`, as feeding the function with perfect squares otherwise doesn't make much sense.


---

Comment by jdemeyer created at 2014-05-08 20:07:11

Replying to [comment:20 leif]:
> as feeding the function with perfect squares otherwise doesn't make much sense.
Depends on your application...

Anyway, if people really care about non-trivial solutions, let those people implement such a flag, I'm not going to do it.


---

Comment by pbruin created at 2014-05-08 20:10:02

Replying to [comment:18 jdemeyer]:
> Replying to [comment:14 leif]:
> > I don't think anybody would expect e.g. `two_squares(25)` to return the trivial solution `(0,5)` instead of `(3,4)`.
> 
> From a number-theory point of view, there is nothing wrong with `(0,5)`. In fact, in some cases, the only solution is the "trivial" one, for example for 9.
I agree.  Given that 0 is a square, it makes complete sense to allow it as a term in a sum of squares.  That convention makes a lot of things nicer, for example:
- every square is also a sum of two squares, and more generally every sum of _k_ squares is also a sum of _k_ + 1 squares;
- _n_ is a sum of 2 squares if and only if _n_ can be factored non-trivially in *Z*[_i_];
- _n_ is a sum of _k_ squares if and only if the lattice *Z*<sup>_k_</sup> has a point of squared distance _n_ from the origin.
There are also nice formulae for the number of ways to write _n_ as a sum of _k_ squares if you interpret this number as the number of points (_x_<sub>1</sub> , ... , _x_<sub>k</sub>) in *Z*<sup>_k_</sup> with _x_<sub>1</sub><sup>2</sup> + ... + _x<sub>k</sub>_<sup>2</sup> = _n_.


---

Comment by leif created at 2014-05-08 20:12:45

Replying to [comment:21 jdemeyer]:
> Anyway, if people really care about non-trivial solutions, let those people implement such a flag, I'm not going to do it.

`algorithm="gap"`?

We'd need that for backwards compatibility anyway, besides that you said GAP is faster (in factoring at least) for some (which kind of?) inputs.


---

Comment by vdelecroix created at 2014-05-08 21:16:32

Hi there,

For very small integers (<500) a naive cython implementation is *much* faster (at least x100)... as this was the initial purpose of Nathann I make the remark here.

```
def two_squares_pyx(int n):
    cdef int i,ii,j,nn
    if n < 2:
        return True

    i = ii = 0
    while ii < n:
        j = 0
        while j <= i:
            nn = ii + j*j
            if nn >= n:
                break
            j += 1

        if nn == n:
            return (i,j)

        i += 1
        ii = i*i

    raise ValueError("%d is not the sum of 2 squares"%n)
```

then

```
sage: %timeit two_squares(37)
10000 loops, best of 3: 108 µs per loop
sage: %timeit two_squares_pyx(37)
1000000 loops, best of 3: 464 ns per loop

sage: %timeit two_squares(97)
10000 loops, best of 3: 185 µs per loop
sage: %timeit two_squares_pyx(97)
1000000 loops, best of 3: 558 ns per loop

sage: %timeit two_squares(212)
10000 loops, best of 3: 130 µs per loop
sage: %timeit two_squares_pyx(212)
1000000 loops, best of 3: 734 ns per loop

sage: %timeit two_squares(500)
10000 loops, best of 3: 131 µs per loop
sage: %timeit two_squares_pyx(500)
1000000 loops, best of 3: 1 µs per loop
```


What do you think of using it for entries < 500?

Vincent


---

Comment by vdelecroix created at 2014-05-08 21:18:13

(and the Cython version can even be improved)


---

Comment by kcrisman created at 2014-05-09 01:18:47

I was hoping someone would do this.

I agree with pbruin, though of course this is not the same function as "number of ways to write as two squares" or "all ways to write as sum of two squares".  This is what happens when we "unwrap" :-)


---

Comment by leif created at 2014-05-09 01:19:39

Replying to [comment:25 vdelecroix]:
> {{{
> def two_squares_pyx(int n):
>     cdef int i,ii,j,nn
>     if n < 2:
>         return True
> 
>     i = ii = 0
>     while ii < n:
>         j = 0
>         while j <= i:
>             nn = ii + j*j
>             if nn >= n:
>                 break
>             j += 1
> 
>         if nn == n:
>             return (i,j)
> 
>         i += 1
>         ii = i*i
> 
>     raise ValueError("%d is not the sum of 2 squares"%n)
> }}}

Minor correction: `while ii <= n` (such that we get "trivial" solutions with `j==0` as well).  Also, I'd swap i and j, or `return (j,i)`.


---

Comment by leif created at 2014-05-09 01:27:50

Well, I don't care much about `a==0` (a matter of definition, it's ok, and one usually has to treat zeroes differently anyway), but normally one isn't interested in a trivial solution, unless it's _the only one_, and if there's no way to get (or even get to know whether there is) a non-trivial solution [as well]...


---

Comment by leif created at 2014-05-09 01:29:22

And feel free to implement a _different_ function that returns _a list of_ [all] solutions...


---

Comment by vdelecroix created at 2014-05-15 20:37:52

Hello,

I implemented what I said in Cython (i.e. `two_squares_pyx`, `three_squares_pyx` and `four_squares_pyx`). Timings are now much better for small values (but it also influences small values).

Based on the timings below (with the old version), I put the threshold to 500 for the three functions. But if you have strong opinion for another threshold please tell me. 

There are many comments, but is there somebody up for a review ?

Vincent

Two squares

```
sage: %timeit two_squares(101)
10000 loops, best of 3: 94.5 µs per loop
sage: %timeit two_squares_pyx(101)
1000000 loops, best of 3: 780 ns per loop

sage: timeit("try:\n    two_squares(102)\nexcept ValueError:\n    pass")
625 loops, best of 3: 57.4 µs per loop
sage: timeit("try:\n    two_squares_pyx(102)\nexcept ValueError:\n    pass")
625 loops, best of 3: 6.4 µs per loop

sage: %timeit two_squares(200)
10000 loops, best of 3: 87.3 µs per loop
sage: %timeit two_squares_pyx(200)
1000000 loops, best of 3: 788 ns per loop

sage: timeit("try:\n    two_squares(201)\nexcept ValueError:\n    pass")
625 loops, best of 3: 39.6 µs per loop
sage: timeit("try:\n    two_squares_pyx(201)\nexcept ValueError:\n    pass")
625 loops, best of 3: 6.61 µs per loop

sage: %timeit two_squares(305)
10000 loops, best of 3: 158 µs per loop
sage: %timeit two_squares_pyx(305)
1000000 loops, best of 3: 998 ns per loop

sage: timeit("try:\n    two_squares(304)\nexcept ValueError:\n    pass")
625 loops, best of 3: 50.8 µs per loop
sage: timeit("try:\n    two_squares_pyx(304)\nexcept ValueError:\n    pass")
625 loops, best of 3: 6.71 µs per loop

sage: %timeit two_squares(400)
10000 loops, best of 3: 69.4 µs per loop
sage: %timeit two_squares_pyx(400)
1000000 loops, best of 3: 1.01 µs per loop

sage: timeit("try:\n    two_squares(402)\nexcept ValueError:\n    pass")
625 loops, best of 3: 57.5 µs per loop
sage: timeit("try:\n    two_squares_pyx(402)\nexcept ValueError:\n    pass")
625 loops, best of 3: 6.85 µs per loop

sage: %timeit two_squares(500)
10000 loops, best of 3: 119 µs per loop
sage: %timeit two_squares_pyx(500)
1000000 loops, best of 3: 1.18 µs per loop

sage: timeit("try:\n    two_squares(501)\nexcept ValueError:\n    pass")
625 loops, best of 3: 39.5 µs per loop
sage: timeit("try:\n    two_squares_pyx(501)\nexcept ValueError:\n    pass")
625 loops, best of 3: 6.76 µs per loop
```


Three squares

```
sage: %timeit three_squares(106)
1000 loops, best of 3: 266 µs per loop
sage: %timeit three_squares_pyx(106)
1000000 loops, best of 3: 1.38 µs per loop

sage: timeit("try:\n    three_squares(103)\nexcept ValueError:\n    pass")
625 loops, best of 3: 52.2 µs per loop
sage: timeit("try:\n    three_squares_pyx(103)\nexcept ValueError:\n    pass")
625 loops, best of 3: 6.9 µs per loop

sage: %timeit three_squares(200)
1000 loops, best of 3: 205 µs per loop
sage: %timeit three_squares_pyx(200)
1000000 loops, best of 3: 1.81 µs per loop

sage: timeit("try:\n    three_squares(303)\nexcept ValueError:\n    pass")
625 loops, best of 3: 52.1 µs per loop
sage: timeit("try:\n    three_squares_pyx(303)\nexcept ValueError:\n    pass")
625 loops, best of 3: 9.24 µs per loop

sage: %timeit three_squares(406)
1000 loops, best of 3: 189 µs per loop
sage: %timeit three_squares_pyx(406)
100000 loops, best of 3: 3.46 µs per loop

sage: timeit("try:\n    three_squares(407)\nexcept ValueError:\n    pass")
625 loops, best of 3: 51.6 µs per loop
sage: timeit("try:\n    three_squares_pyx(407)\nexcept ValueError:\n    pass")
625 loops, best of 3: 10.5 µs per loop

sage: %timeit three_squares(500)
10000 loops, best of 3: 167 µs per loop
sage: %timeit three_squares_pyx(500)
100000 loops, best of 3: 3.89 µs per loop

sage: timeit("try:\n    three_squares(503)\nexcept ValueError:\n    pass")
625 loops, best of 3: 51.2 µs per loop
sage: timeit("try:\n    three_squares_pyx(503)\nexcept ValueError:\n    pass")
625 loops, best of 3: 10.7 µs per loop
```


Four squares

```
sage: %timeit four_squares(503)
1000 loops, best of 3: 259 µs per loop
sage: %timeit four_squares_pyx(503)
100000 loops, best of 3: 13.5 µs per loop
```

----
New commits:


---

Comment by vdelecroix created at 2014-05-15 21:54:26

Of course, we can revert to the jeroen branch if my contribution seems useless...

Vincent


---

Comment by vdelecroix created at 2014-05-15 22:01:13

Hi,

Sorry. I was a bit fast. The decision of choosing my branch or not might be the choice of the author of the ticket. So if you want to have a look at my changes, see either u/vdelecroix/16308 or public/16308

Vincent


---

Comment by vdelecroix created at 2014-05-15 22:01:43

New commits:


---

Comment by leif created at 2014-05-15 23:43:13

There's even more room for optimizations; a C/Cython version is probably faster up to at least 10000 or even 2<sup>16</sup> (for `two_squares()`).

I'd also compare the overall speed over a range.


---

Comment by leif created at 2014-05-15 23:47:43

P.S.:  If a solution exists, _k_`_squares()` should IMHO *always* return a _k_-tuple.


---

Comment by leif created at 2014-05-16 15:03:09

Replying to [comment:33 vdelecroix]:
> Sorry. I was a bit fast. The decision of choosing my branch or not might be the choice of the author of the ticket. So if you want to have a look at my changes, see either u/vdelecroix/16308 or public/16308

Probably open a separate ticket "Improve sums of squares _for small input_" and we can later (re)base one of them on the other.


---

Comment by vdelecroix created at 2014-05-17 19:38:49

Replying to [comment:37 leif]:
> Replying to [comment:33 vdelecroix]:
> > Sorry. I was a bit fast. The decision of choosing my branch or not might be the choice of the author of the ticket. So if you want to have a look at my changes, see either u/vdelecroix/16308 or public/16308
> 
> Probably open a separate ticket "Improve sums of squares _for small input_" and we can later (re)base one of them on the other.

Good idea. Done in #16374.


---

Comment by jdemeyer created at 2014-05-19 10:10:18

Replying to [comment:36 leif]:
> P.S.:  If a solution exists, _k_`_squares()` should IMHO *always* return a _k_-tuple.
Sure, in which case does it not do that?


---

Comment by leif created at 2014-05-19 19:27:52

Replying to [comment:40 jdemeyer]:
> Replying to [comment:36 leif]:
> > P.S.:  If a solution exists, _k_`_squares()` should IMHO *always* return a _k_-tuple.
> Sure, in which case does it not do that?

Sorry, I had been looking at some diff of Vincent's code against yours, and only saw some `return (foo,)` (and I *swear* it was more than one!1!!1 ;-) ), but in your original code, or the one that's again here now, it's of course only in the case k=1 (sum of _one_ square), which is correct.

Sorry for the noise.


---

Comment by vdelecroix created at 2014-06-06 16:17:08

Hi,

Related to comment:12, can you justify why using pari? We already have `factor` and `is_pseudoprime` and `sqrtrem` might be the replacement for `N.sqrtint`.

There are also trailing whitespaces on the lines 5161 and 5246.

Vincent


---

Comment by vdelecroix created at 2014-06-06 16:17:08

Changing status from needs_review to needs_info.


---

Comment by git created at 2014-06-25 09:14:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2014-06-25 09:15:28

Changing status from needs_info to needs_review.


---

Comment by vdelecroix created at 2014-06-25 18:48:53

Hey,

Looks cool! I added micro optimizations and random tests at `u/vdelecroix/16308`. If you like my changes, this is good for a positive review!

Vincent


---

Comment by jdemeyer created at 2014-06-25 21:41:11

New commits:


---

Comment by jdemeyer created at 2014-06-25 21:42:20

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-06-26 19:37:47

Resolution: fixed
