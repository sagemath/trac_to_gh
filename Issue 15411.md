# Issue 15411: lazy import attributes of a class are not substituted back after the import

Issue created by migration from https://trac.sagemath.org/ticket/15648

Original creator: nthiery

Original creation time: 2014-01-08 08:42:20


```
sage: class A:
....:     Associative = LazyImport('sage.categories.magmas', 'Magmas')
....: 
sage: A.Associative
<class 'sage.categories.magmas.Magmas'>
sage: type(A.__dict__["Associative"])
<type 'sage.misc.lazy_import.LazyImport'>
```




---

Comment by SimonKing created at 2014-01-08 11:31:04

See my comment at #10963. We could simply create a lazy class attribute with an import statement inside. Proof of concept:

```
sage: def imported_lazy_class_attribute(module_name, cls_name):                         
....:     return lazy_class_attribute(lambda cls: getattr(__import__(module_name, {}, {}, [cls_name]),cls_name))
....: 
sage: class Test(object):
....:     Finite = imported_lazy_class_attribute('sage.categories.finite_permutation_groups', 'FinitePermutationGroups')
....:     
sage: Test.Finite
<class 'sage.categories.finite_permutation_groups.FinitePermutationGroups'>
```


Alternatively, since `LazyImport` has some `__get__`: We could make the lazy import _behave_ as a class attribute, if it is used as attribute of a class (`__get__` knows whether it is used as attribute of a class.


---

Comment by SimonKing created at 2014-01-08 11:40:48

Strange. Shouldn't `LazyImport` already act as a class attribute? After all, I see the following code:

```python
            if owner is None:
                if self._namespace and self._namespace[alias] is self:
                    self._namespace[alias] = self._object
            else:
                from inspect import getmro
                for cls in getmro(owner):
                    if cls.__dict__.get(alias, None) is self:
                        setattr(cls, alias, self._object)
                        break
```

This should actually do the trick.


---

Comment by SimonKing created at 2014-01-08 11:50:26

In the example of the ticket description, I suppose you simply need to proved `as_name="Associative"`, and then it should work. Can't test it right now, though.


---

Comment by SimonKing created at 2014-01-08 11:53:54

The only (mild) problems I see:
1. Why is the `_get_object`, if it does what ostensibly is the job of `__get__`?
2. Why is the imported object put into the dict of a class, but not into the dict of an instance? `_get_object` can't do it, since it doesn't know the instance.

Hence, I am all for removing `_get_object`.


---

Comment by SimonKing created at 2014-01-08 12:07:53


```
sage: from sage.misc.lazy_import import LazyImport
sage: class A:
....:     Associative = LazyImport('sage.categories.magmas', 'Magmas', 'Associative')
....:     
sage: A.Associative
<class 'sage.categories.magmas.Magmas'>
sage: A.__dict__['Associative']
<class 'sage.categories.magmas.Magmas'>
```


Hence, unless you agree that we should change the lazy import statement so that it additionally acts as a lazy instance attribute, then this ticket is invalid.


---

Comment by SimonKing created at 2014-01-08 12:07:53

Changing status from new to needs_info.


---

Comment by jdemeyer created at 2017-04-06 11:44:58

Changing type from PLEASE CHANGE to defect.


---

Comment by jdemeyer created at 2017-04-06 11:56:56

Changing status from needs_info to needs_review.


---

Comment by jdemeyer created at 2017-04-06 11:56:56

New commits:


---

Comment by git created at 2017-04-06 12:41:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-04-06 20:15:50

Resolution: wontfix


---

Comment by jdemeyer created at 2017-04-06 20:26:13

Changing status from closed to new.


---

Comment by jdemeyer created at 2017-04-06 20:26:13

Resolution changed from wontfix to 
