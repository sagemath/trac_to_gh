# Issue 16996: Uniform  random generation  of StandardTableau of a given size

Issue created by migration from https://trac.sagemath.org/ticket/17233

Original creator: g.chatel

Original creation time: 2014-10-27 14:06:43

Assignee: gchatel

CC:  vivianepons tscrim darij sage-combinat nthiery

Keywords: StandardTableaux, random, combinat

I am overwritting the default random_element method of the StandardTableaux_size class to implement an efficient way to compute a random standard tableau.

As explained in the documentation, we use the fact that standard tableau are in bijection with involution.


---

Comment by g.chatel created at 2014-10-27 14:47:35

New commits:


---

Comment by g.chatel created at 2014-10-27 14:58:35

This code is finished and seems to be working. How can I add doctest and examples although the output is random. For this reason, I didn't put a "need review" yet but anyone is welcome to start.


---

Comment by tscrim created at 2014-10-27 17:59:43

You mark it as `# random`.


---

Comment by darij created at 2014-10-27 18:07:24

Just a few comments:

- The doc should start with a brief description of what the code does, not what theorems it uses. If your algorithm gives a uniform random permutation, then it should say so explicitly.

- Do not use generic catch-all constructors such as `Permutation(...)`. These ducktype the input to guess which form you are giving the permutation in. This is great for interactive use, but in your code you know what form you are giving already -- it is the cycle form. So you can save some time and remove a source of possible bugs by replacing `Permutation(...)` by `sage.combinat.permutation.from_cycles(...)`.

- Is this:

```
PerfectMatchings(set(range(1, self.size + 1)) - set(fixed_point_positions)).random_element()
```

actually efficient? I am asking because I don't see a random method in perfect_matchings.py, but I might not be looking in the right place.


---

Comment by tscrim created at 2014-10-27 18:30:32

Replying to [comment:4 darij]:
> - Is this:
> {{{
> PerfectMatchings(set(range(1, self.size + 1)) - set(fixed_point_positions)).random_element()
> }}}
>   actually efficient? I am asking because I don't see a random method in perfect_matchings.py, but I might not be looking in the right place.

There is a `random_element` in `perfect_matchings.py`; although it calls `Permutations(n).random_element()` which looks like it's fast.


---

Comment by darij created at 2014-10-27 18:37:07

Oops, I think I was looking at some outdated version of the file on the internet.


---

Comment by tscrim created at 2014-10-27 18:51:02

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by darij created at 2014-10-27 19:39:49

More minor comments:

- "couple" should be "pair" in mathematical usage.

- You are using `Permutations(self.size).random_element()[:fixed_point_number]` to generate a random `k`-element subset of `{1, 2, ..., n}` (if I understand you correctly -- otherwise, please correct me!). I think you can just as well do `sage.misc.prandom.sample(range(1, n+1), k)`, which is the method that is internally used when you call `Permutations(self.size).random_element()`.


---

Comment by git created at 2014-10-28 10:03:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-10-28 10:21:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by g.chatel created at 2014-10-28 11:22:04

Changing status from new to needs_review.


---

Comment by git created at 2014-10-28 13:03:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-10-28 15:28:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-10-28 15:29:37

Here's my review patch. If you are fine with it, please set this to positive_review.

`binomial` should be imported from `sage.rings.arith` rather than from `sage.functions.other` when you just want to compute binomial coefficients of integers. Check this:

```
sage: %timeit binomial(13, 5) # This is the one from sage.functions.other
10000 loops, best of 3: 61.1 µs per loop
sage: %timeit sage.rings.arith.binomial(13, 5)
100000 loops, best of 3: 5.6 µs per loop
sage: %timeit binomial(54, 23)
10000 loops, best of 3: 61.7 µs per loop
sage: %timeit sage.rings.arith.binomial(54, 23)
100000 loops, best of 3: 6.16 µs per loop
```



---

Comment by git created at 2014-10-28 18:18:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-10-28 18:19:28

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-10-28 21:46:25

PDF docs don't bulid (lfoor -> lfloor)


---

Comment by vbraun created at 2014-10-28 21:46:25

Changing status from positive_review to needs_work.


---

Comment by git created at 2014-10-28 22:14:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2014-10-28 22:14:34

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2014-10-29 22:13:21

Resolution: fixed
