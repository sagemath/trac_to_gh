# Issue 18703: Polynomials ignore the step argument in __getitem__

Issue created by migration from https://trac.sagemath.org/ticket/18940

Original creator: pbruin

Original creation time: 2015-07-22 20:28:09

Sage should support a `step` different from 1 in the `__getitem__()` method of polynomials:

```
sage: R.<x> = ZZ[]
sage: f = sum(x^j for j in range(5))
sage: f
x^4 + x^3 + x^2 + x + 1
sage: f[-2:4:2]
x^3 + x^2 + x + 1  # should be x^2 + 1
```



---

Comment by pbruin created at 2015-07-22 21:49:47

Fixing this for all polynomials is somewhat involved because every polynomial class defines its own `__getitem__()` method.  The following 14 methods are relevant (line numbers for SageMath 6.8.rc0):

```
laurent_polynomial.pyx:321:    def __getitem__(self, i):
padics/polynomial_padic_capped_relative_dense.py:381:    def __getitem__(self, n):
polynomial_element_generic.py:300:    def __getitem__(self,n):
polynomial_element.pyx:7608:    def __getitem__(self, n):
polynomial_gf2x.pyx:64:    def __getitem__(self, i):
polynomial_integer_dense_flint.pyx:415:    def __getitem__(self, n):
polynomial_integer_dense_ntl.pyx:284:    def __getitem__(self, n):
polynomial_modn_dense_ntl.pyx:180:    def __getitem__(self, n):
polynomial_modn_dense_ntl.pyx:658:    def __getitem__(self, n):
polynomial_modn_dense_ntl.pyx:1223:    def __getitem__(self, n):
polynomial_rational_flint.pyx:379:    def __getitem__(self, n):
polynomial_real_mpfr_dense.pyx:183:    def __getitem__(self, ix):
polynomial_zmod_flint.pyx:231:    def __getitem__(self, i):
polynomial_zz_pex.pyx:151:    def __getitem__(self,i):
```



---

Comment by jdemeyer created at 2015-07-23 08:03:33

For matrices and vectors, this is done using `get_unsafe()` which is the implementation of `a[i]` for one index `i`. Then the slicing is done by a generic `__getitem__` function.


---

Comment by pbruin created at 2015-10-14 20:50:19

Replying to [comment:2 jdemeyer]:
> For matrices and vectors, this is done using `get_unsafe()` which is the implementation of `a[i]` for one index `i`. Then the slicing is done by a generic `__getitem__` function.
I implemented this suggestion, now testing.


---

Comment by pbruin created at 2015-10-14 21:20:07

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2015-10-16 11:31:30

I might review this once the dependency is merged.


---

Comment by jdemeyer created at 2015-10-16 11:41:51

Just a remark: did you have a look at [PySlice_GetIndicesEx](https://docs.python.org/2/c-api/slice.html#c.PySlice_GetIndicesEx)? That might be used to avoid slice arithmetic like

```diff
+            start, stop, step = n.start, n.stop, n.step
+            if step is None:
+                step = 1
+            if start is None:
+                start = 0
+            elif start < 0:
+                start %= step
+            if stop is None or stop > d:
+                stop = d
```



---

Comment by pbruin created at 2015-10-16 12:01:02

Replying to [comment:7 jdemeyer]:
> Just a remark: did you have a look at [PySlice_GetIndicesEx](https://docs.python.org/2/c-api/slice.html#c.PySlice_GetIndicesEx)?
I tried this, but unfortunately it does not return the correct indices for polynomials.  For example, it wraps around negative `start` values (as in the Python convention that `L[-1]` with `L` a list returns the last item in `L`); this is incompatible with Sage's convention that `P[n]` returns 0 if `P` is a polynomial and `n < 0`.


---

Comment by bruno created at 2015-10-26 13:54:56

Replying to [comment:8 pbruin]:
> Replying to [comment:7 jdemeyer]:
> > Just a remark: did you have a look at [PySlice_GetIndicesEx](https://docs.python.org/2/c-api/slice.html#c.PySlice_GetIndicesEx)?
> I tried this, but unfortunately it does not return the correct indices for polynomials.  For example, it wraps around negative `start` values (as in the Python convention that `L[-1]` with `L` a list returns the last item in `L`); this is incompatible with Sage's convention that `P[n]` returns 0 if `P` is a polynomial and `n < 0`.

I think this behavior should be documented: I'd add a `Warning` block to the documentation to specify that it doesn't (and cannot!) respect Python convention. This may be obvious for Laurent polynomials, but it is not clear for polynomials.


---

Comment by bruno created at 2015-10-26 13:55:17

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-10-27 16:58:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-27 17:01:11

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by pbruin created at 2015-10-27 17:03:40

Changing status from needs_work to needs_review.


---

Comment by pbruin created at 2015-10-27 17:03:40

Replying to [comment:9 bruno]:
> Replying to [comment:8 pbruin]:
> > Replying to [comment:7 jdemeyer]:
> > > Just a remark: did you have a look at [PySlice_GetIndicesEx](https://docs.python.org/2/c-api/slice.html#c.PySlice_GetIndicesEx)?
> > I tried this, but unfortunately it does not return the correct indices for polynomials.  For example, it wraps around negative `start` values (as in the Python convention that `L[-1]` with `L` a list returns the last item in `L`); this is incompatible with Sage's convention that `P[n]` returns 0 if `P` is a polynomial and `n < 0`.
> 
> I think this behavior should be documented: I'd add a `Warning` block to the documentation to specify that it doesn't (and cannot!) respect Python convention. This may be obvious for Laurent polynomials, but it is not clear for polynomials.
OK, I added a warning and an example for this.

Also, in the meantime I realised that `step <= 0` is (1) not necessarily well-defined, and (2) may cause Sage to crash with the current implementation.  I added a few lines to detect this case and raise an `IndexError`.


---

Comment by git created at 2015-10-30 14:53:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-11-02 09:07:50

For some classes, you still reimplement `__getitem__` for slices. Why is that? Why cannot you always use the generic implementation for slicing?


---

Comment by jdemeyer created at 2015-11-02 09:14:16

Why not allow `step < 0`? Actually, I think that `step = -1` might be the most mathematically useful value of `step`.


---

Comment by jdemeyer created at 2015-11-02 09:43:53

Changing status from needs_review to needs_info.


---

Comment by jdemeyer created at 2015-11-02 09:43:53

Are you sure that the current behaviour is really what we want?

```
sage: pol = PolynomialRing(QQ, 'x')(range(10))
sage: pol
9*x^9 + 8*x^8 + 7*x^7 + 6*x^6 + 5*x^5 + 4*x^4 + 3*x^3 + 2*x^2 + x
sage: pol[2:]
9*x^9 + 8*x^8 + 7*x^7 + 6*x^6 + 5*x^5 + 4*x^4 + 3*x^3 + 2*x^2
```

I would have expected

```
sage: pol[2:]
9*x^7 + 8*x^6 + 7*x^5 + 6*x^4 + 5*x^3 + 4*x^2 + 3*x + 2
```


I know that this branch just extends the current behaviour. However, I think we need to step back and define mathematically what should be returned when asking for `pol[a:b:c]`. The current definition is not very useful.

I think that `list(pol[a:b:c])` should be the same as `list(pol)[a:b:c]`, except for different rules when the range is outside of `0 ... pol.degree()`.


---

Comment by jdemeyer created at 2015-11-02 09:53:43

Peter, what's your use-case for `pol[a:b:c]`, i.e. why did you create this ticket?


---

Comment by jdemeyer created at 2015-11-02 10:05:52

For the record, the current definition of `pol[a:b]` was introduced with

```
commit ff63a1c2b5798a777dcef6a4366a43dc60a6bebd
Author: William Stein <wstein@gmail.com>
Date:   Fri Jan 26 02:42:10 2007 -0800

    A huge amount -- starting with writing tons of doctests for power series, pyrex integer_ring, etc.
    
        * changed before of polynomial and power series slicing to return objects of the same type,
          which is much more consistent.
        * optimized integer constructor
        * improved random number generation (e.g., ZZ.random_element()) ten times faster and more
          flexible.
        * separated out pmem_malloc
```



---

Comment by tscrim created at 2015-11-02 16:09:31

We currently have

```
sage: R.<x> = QQ[]
sage: p = R.random_element((-1, 10)); p
-2/3*x^10 + 3/2*x^9 - 1/2*x^8 + 10*x^7 + x^6 + 3/2*x^5 + 1/3*x^4 + 5/2*x^3 - x^2 + 29*x - 1
sage: list(p)
[-1, 29, -1, 5/2, 1/3, 3/2, 1, 10, -1/2, 3/2, -2/3]
```

So `list` does go low to high and the current behavior is consistent with converting to a list.

+1 for supporting negative steps.


---

Comment by jdemeyer created at 2015-11-02 16:14:48

Replying to [comment:20 tscrim]:
> the current behavior is consistent with converting to a list.

What do you mean? I think that these two outputs should be equal:

```
sage: pol = PolynomialRing(QQ, 'x')(range(10))
sage: list(pol[5:])
[0, 0, 0, 0, 0, 5, 6, 7, 8, 9]
sage: list(pol)[5:]
[5, 6, 7, 8, 9]
```



---

Comment by tscrim created at 2015-11-02 17:54:27

Ah, I see what you mean. I'm sorry, I didn't read your example closely enough and though you were truncating off the 2 leading terms.

However, list and slice already don't commute because of the python wrap around, so I'm not so sure on how much we should enforce the exact same behavior (granted, an error gets raised in the polynomial case). I personally would find that the degree was lowered more surprising if we still wanted slices to return polynomials as opposed to a list of the coefficients. Yet I don't really have much invested in this.


---

Comment by jdemeyer created at 2015-11-02 18:14:07

Replying to [comment:22 tscrim]:
> I personally would find that the degree was lowered more surprising
So what's in your opinion the correct answer for

```
sage: pol = PolynomialRing(QQ, 'x')(range(10))
sage: list(pol[2::2])
```


If we cannot agree on a "natural" definition for `pol[a:b:c]`, perhaps the best compromise is simply

```
if isinstance(i, slice):
    raise NotImplementedError("polynomial slicing is not defined")
```



---

Comment by tscrim created at 2015-11-02 18:35:14

Replying to [comment:23 jdemeyer]:
> Replying to [comment:22 tscrim]:
> > I personally would find that the degree was lowered more surprising
> So what's in your opinion the correct answer for
> {{{
> sage: pol = PolynomialRing(QQ, 'x')(range(10))
> sage: list(pol[2::2])
> }}}

That depends on if we want a slice of a polynomial returns a polynomial or a simple list of the coefficients. I am (very) slightly in favor of returning a polynomial, so with that `[0, 2, 4, 6, 8]`.

> If we cannot agree on a "natural" definition for `pol[a:b:c]`, perhaps the best compromise is simply
> {{{
> if isinstance(i, slice):
>     raise NotImplementedError("polynomial slicing is not defined")
> }}}

This would be okay with me as well, but I don't think my opinion here should weigh very much here because I am mostly ambivalent about this behavior since I don't have a use for it.


---

Comment by jdemeyer created at 2015-11-02 18:41:26

Replying to [comment:24 tscrim]:
> That depends on if we want a slice of a polynomial returns a polynomial or a simple list of the coefficients. I am (very) slightly in favor of returning a polynomial, so with that `[0, 2, 4, 6, 8]`.

Sorry, I asked a bad question so I cannot interpret your answer. Please try again with this question:

```
sage: pol = PolynomialRing(QQ, 'x')(range(1,10))
sage: list(pol[3::2])
```



---

Comment by tscrim created at 2015-11-02 18:52:38

Replying to [comment:25 jdemeyer]:
> Replying to [comment:24 tscrim]:
> > That depends on if we want a slice of a polynomial returns a polynomial or a simple list of the coefficients. I am (very) slightly in favor of returning a polynomial, so with that `[0, 2, 4, 6, 8]`.
> 
> Sorry, I asked a bad question so I cannot interpret your answer. Please try again with this question:
> {{{
> sage: pol = PolynomialRing(QQ, 'x')(range(1,10))
> sage: list(pol[3::2])
> }}}
I would want this:

```
sage: list(pol[3::2])
[0, 0, 0, 4, 0, 6, 0, 8]
```

Actually, my answer above was wrong and shouw be `[0, 0, 2, 0, 4, 0, 6, 0, 8]`. [Edit - Some changes due to me not thinking things completely through]

However, when trying to think about how this would work for Laurent polynomials, we currently have this behavior for `list`:

```
sage: R.<x> = LaurentPolynomialRing(QQ)
sage: p = ~x + 2 + 3*x + 4*x^2
sage: list(p)
[1, 2, 3, 4]
sage: p = 3*x + 4*x^2
sage: list(p)
[3, 4]
```

In some ways I would say the iterator for polynomials should be changed to agree with that of Laurent polynomials, in that it starts from the lowest degree. Although I understand there are many (good) reasons why we do not want that behavior. I feel that at some point we just have to choose the least bad of all options and then put up warning messages about our choices.


---

Comment by jdemeyer created at 2015-11-02 19:02:50

Replying to [comment:26 tscrim]:
> I would want this:
> {{{
> sage: list(pol[3::2])
> [0, 0, 0, 4, 0, 6, 0, 8]
> }}}
Interesting. This is indeed what this branch does, but it doesn't correspond with my intuition about what it should do (I would expect `[4, 6, 8]`).


---

Comment by pbruin created at 2015-11-02 19:45:28

Replying to [comment:18 jdemeyer]:
> Peter, what's your use-case for `pol[a:b:c]`, i.e. why did you create this ticket?
Because of comments 22, 25 and 26 on ticket #15601.


---

Comment by pbruin created at 2015-11-02 19:53:23

Replying to [comment:17 jdemeyer]:
> Are you sure that the current behaviour is really what we want?
> {{{
> sage: pol = PolynomialRing(QQ, 'x')(range(10))
> sage: pol
> 9*x^9 + 8*x^8 + 7*x^7 + 6*x^6 + 5*x^5 + 4*x^4 + 3*x^3 + 2*x^2 + x
> sage: pol[2:]
> 9*x^9 + 8*x^8 + 7*x^7 + 6*x^6 + 5*x^5 + 4*x^4 + 3*x^3 + 2*x^2
> }}}
Yes.  The fact that polynomials are usually written with decreasing exponents is just a historical convention.  I think it is absolutely reasonable that `pol[2:]` should return the monomials of degree 2 and higher, whether as a polynomial or as a list.  And in fact

```
sage: list(pol)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

so doing `list(pol)[2:]` also extracts the coefficients of the monomials of degree at least 2.

Similarly, in PARI, my experience is that `Vecrev` (which does the equivalent of `list` above) is more useful than `Vec` to extract the list of coefficients of a polynomial.


---

Comment by pbruin created at 2015-11-02 19:54:32

Replying to [comment:21 jdemeyer]:
> Replying to [comment:20 tscrim]:
> > the current behavior is consistent with converting to a list.
> 
> What do you mean? I think that these two outputs should be equal:
> {{{
> sage: pol = PolynomialRing(QQ, 'x')(range(10))
> sage: list(pol[5:])
> [0, 0, 0, 0, 0, 5, 6, 7, 8, 9]
> sage: list(pol)[5:]
> [5, 6, 7, 8, 9]
> }}}
What would you want the output of `pol[5:]` itself to be?


---

Comment by pbruin created at 2015-11-02 19:58:07

Replying to [comment:16 jdemeyer]:
> Why not allow `step < 0`? Actually, I think that `step = -1` might be the most mathematically useful value of `step`.
We already have the `reverse()` method for that.  I can think of two possible results for `pol[a:b:-1]`, one of which would be the `reverse()` of the other.  I am afraid allowing `step = -1` would only create confusion...


---

Comment by jhpalmieri created at 2015-11-02 21:40:18

Mathematically, I can certainly imagine wanting the part of the polynomial between degrees 2 and 5: I might want this:

```
sage: f
-10*x^6 + 1/2*x^5 - x^4 + 7*x^3 - 2*x^2 + x - 3
sage: f[2:6]
1/2*x^5 - x^4 + 7*x^3 - 2*x^2
```

I don't know if I would ever want `f[2:6]` to return the polynomial with same coefficients but translated down in degree (i.e., `1/2*x^3 - x^2 + 7*x - 2`). Computationally, though, if I have that second result, I can easily get back to the first one by multiplying by `x^2`. If I have the first, I can get to the second by dividing, but that puts the result in the fraction field, which is probably not what I want. Alternatively, I can also get to the second by creating a polynomial from `list(f)[2:6]`, which is not as intuitive, but not too hard.

Surely different mathematicians will have different points of view on this.

I think this is the issue for me: do we want

```
sage: list(pol[5:]) == list(pol)[5:]
True
```

or do we want

```
sage: pol[:5] + pol[5:] == pol
True
```

We can't have both, right? I prefer the second. That is, I tend to think of polynomials as graded objects and slicing is returning some of their homogeneous components, and it seems most natural to do this without regrading the result: if a term is in degree 3 in the original polynomial, it should still be in degree 3 after slicing. I would also like this:

```
sage: pol[0:10:2] + pol[1:10:2] == pol[0:10]
True
```

Adding the even terms to the odd terms should yield the original polynomial.

A related question: should `f[2]` return `-2` or `-2 * x^2`?

-----------

When it comes down to it, I'm not sure I care which option is implemented as `__getitem__`, but perhaps both should be implemented as methods which are visible via tab-completion, or as a single method with a keyword which determines which option to use.


---

Comment by jdemeyer created at 2015-11-02 21:41:30

Replying to [comment:28 pbruin]:
> Replying to [comment:18 jdemeyer]:
> > Peter, what's your use-case for `pol[a:b:c]`, i.e. why did you create this ticket?
> Because of comments 22, 25 and 26 on ticket #15601.

You're just justifying a dubious use-case with a different dubious use-case.


---

Comment by jdemeyer created at 2015-11-02 22:01:49

Replying to [comment:29 pbruin]:
> Similarly, in PARI, my experience is that `Vecrev` (which does the equivalent of `list` above) is more useful than `Vec` to extract the list of coefficients of a polynomial.

I think you are totally misunderstanding me. This is not at all about in _which order_ the monomials are extracted. Obviously, PARI's `Vecrev()` is the right thing, I'm not arguing against that.

It's about

```
9*x^9 + 8*x^8 + 7*x^7 + 6*x^6 + 5*x^5 + 4*x^4 + 3*x^3 + 2*x^2
```

versus

```
9*x^7 + 8*x^6 + 7*x^5 + 6*x^4 + 5*x^3 + 4*x^2 + 3*x + 2
```



---

Comment by jdemeyer created at 2015-11-02 22:02:43

Replying to [comment:30 pbruin]:
> What would you want the output of `pol[5:]` itself to be?

```
sage: pol = PolynomialRing(QQ, 'x')(range(10))
sage: pol[5:]
9*x^4 + 8*x^3 + 7*x^2 + 6*x + 5
```

(although, I don't really _want_ it to be this, but this is what I would _expect_)


---

Comment by jdemeyer created at 2015-11-02 22:19:02

What I *really* want is probably

```
sage: pol = PolynomialRing(QQ, 'x')(range(10))
sage: pol[5:]
DeprecationWarning: slicing polynomials is deprecated...
```



---

Comment by jdemeyer created at 2015-11-02 22:29:32

In the Sage library, there are use cases for `pol[:n]` (i.e. truncation) and that's also the only case (I think) where both definitions agree.


---

Comment by jhpalmieri created at 2015-11-02 22:34:42

So deprecate slicing unless it's a truncation?


---

Comment by jdemeyer created at 2015-11-03 07:38:30

One more thought. Let's call this *degree-keeping slicing*:

```
sage: pol = PolynomialRing(QQ, 'x')(range(10))
sage: pol[3::2]
9*x^9 + 7*x^7 + 5*x^5 + 3*x^3
```

and let's call this *degree-reducing slicing*:

```
sage: pol = PolynomialRing(QQ, 'x')(range(10))
sage: pol[3::2]
9*x^3 + 7*x^2 + 5*x + 3
```


The implementation of certain divide-and-conquer algorithms (e.g. Karatsuba multiplication and FFT) can be expressed very easily using degree-reducing slicing.

I'm not saying that this is a particularly strong argument for degree-reducing slicing, since most likely you'd implement those algorithms using lists instead of polynomials anyway.


---

Comment by jdemeyer created at 2015-11-03 08:38:43

A new idea, let's call it *double slicing*. The argument to `__getitem__` can be a pair of slices `i, j`, where the slice `i` is used to define the coefficients and the second slice `j` is used to define the exponents. It would allow for example:

```
sage: pol = PolynomialRing(QQ, 'x')(range(10))
sage: pol[:, ::2]
9*x^18 + 8*x^16 + 7*x^14 + 6*x^12 + 5*x^10 + 4*x^8 + 3*x^6 + 2*x^4 + x^2
sage: pol[:5, 100:]
4*x^104 + 3*x^103 + 2*x^102 + x^101
```


We could define shorthands `pol[i]` equivalent to `pol[i, i]` for degree-keeping slicing and `pol[i,]` equivalent to `pol[i, :]` for degree-reducing slicing.

This would be very general and cover all possible use-cases. The question is: is it over-engineered? Do we really need this?


---

Comment by jdemeyer created at 2015-11-03 11:10:46

I can confirm that the Sage library doesn't use any polynomial slicing except for truncation `pol[:n]`. After adding

```
if start or step is not None:
    raise NotImplementedError
```

to the `__getitem__` methods, the only doctest failures were with slicing in the actual doctest example.


---

Comment by pbruin created at 2015-11-03 14:57:37

Replying to [comment:34 jdemeyer]:
> Replying to [comment:29 pbruin]:
> I think you are totally misunderstanding me. This is not at all about in _which order_ the monomials are extracted. Obviously, PARI's `Vecrev()` is the right thing, I'm not arguing against that.
> 
> It's about
> {{{
> 9*x^9 + 8*x^8 + 7*x^7 + 6*x^6 + 5*x^5 + 4*x^4 + 3*x^3 + 2*x^2
> }}}
> versus
> {{{
> 9*x^7 + 8*x^6 + 7*x^5 + 6*x^4 + 5*x^3 + 4*x^2 + 3*x + 2
> }}}
OK, I see.  As you can guess from how I interpreted your proposal, for me this is not the expected answer at all.

I would personally be quite happy with just deprecating the `start` and `stop` parameters and allowing polynomial slicing only for `pol[:n]`, i.e. truncation.  I think users can easily implement other forms of slicing via lists.


---

Comment by tscrim created at 2015-11-03 15:05:14

I think the double-slicing is probably something we don't really need. So I'm also for deprecating the (non-zero?) `start` and `step` conditions.


---

Comment by jdemeyer created at 2015-11-03 17:21:18

If we deprecate general slicing, shouldn't we deprecate all kinds of slicing, including `pol[:n]` in favour of the `truncate()` method?


---

Comment by jdemeyer created at 2015-11-03 17:29:01

Changing status from needs_info to needs_work.


---

Comment by jdemeyer created at 2015-11-03 19:22:19

Truncation is actually implemented using slicing, so we cannot easily deprecate that.

I am working on a patch.


---

Comment by git created at 2015-11-04 13:12:26

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2015-11-04 13:22:58

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2015-11-04 13:24:45

Sorry, forgot `src/sage/rings/polynomial/padics/polynomial_padic_capped_relative_dense.py`


---

Comment by jdemeyer created at 2015-11-04 13:24:45

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-11-04 13:47:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-11-04 13:48:04

Changing status from needs_work to needs_review.


---

Comment by mmezzarobba created at 2015-11-10 12:04:13

FWIW, I think I have personal code that uses (“degree-keeping”) slicing of the form `pol[n:]`. I can port it, but I may not be alone...


---

Comment by jdemeyer created at 2015-11-10 15:01:57

Cool, what's your use case? I'm curious because I couldn't think of any.


---

Comment by mmezzarobba created at 2015-11-10 17:26:17

Replying to [comment:56 jdemeyer]:
> Cool, what's your use case? I'm curious because I couldn't think of any.

Splitting polynomials that actually represent power series expansions into an “approximation” and a “remainder“; removing the constant term of a polynomial; removing low-order terms that are know to be zero mathematically but are computed as intervals containing zero from a residual Φ(pol) where Φ is an operator and pol is a polynomial close to a zero of Φ.


---

Comment by jdemeyer created at 2015-11-11 20:57:40

`@`mmezzarobba: what is your opinion on [comment:40]?


---

Comment by mmezzarobba created at 2015-11-11 21:10:31

Replying to [comment:58 jdemeyer]:
> `@`mmezzarobba: what is your opinion on [comment:40]?

I don't think I'd need it—any of the two basic forms of slicing (either “degree-keeping” or “degree-reducing”) is enough for me. Regardless whether “double slicing” is implemented, I'd prefer `pol[i:]` to keep working (with one of the two basic meanings, I don't really care which, though I find the “degree-keeping” version more intuitive with polynomials). It wouldn't be a big effort to change my code to work without slicing in any case.


---

Comment by pbruin created at 2016-01-13 14:58:11

Fixed a merge conflict.


---

Comment by rws created at 2016-01-18 08:05:56

Changing status from needs_review to positive_review.


---

Comment by rws created at 2016-01-18 08:05:56

This is one of those enhancements I like to do myself. It is also thoroughly done. Since patchbot is happy too, I feel confident to set it positive.


---

Comment by vbraun created at 2016-01-20 10:20:06

Resolution: fixed


---

Comment by roed created at 2017-06-11 22:36:56

Replying to [comment:41 jdemeyer]:
> I can confirm that the Sage library doesn't use any polynomial slicing except for truncation `pol[:n]`. After adding
> {{{
> if start or step is not None:
>     raise NotImplementedError
> }}}
> to the `__getitem__` methods, the only doctest failures were with slicing in the actual doctest example.

For a use case where deprecating `pol[n:]` is annoying, if you have an Eisenstein polynomial `pol` and want to compute `p/x^n` modulo `pol`, it's natural to express it as `-(pol[n:] >> n) / (pol[:n] // p)`, where the division is taken modulo `pol`.  Obviously, this is doable with lists.


---

Comment by jdemeyer created at 2017-06-12 10:00:56

Maybe a different solution would be to re-introduce the slicing but with a different interface (not `__getitem__` but an explicit method).
