# Issue 24854: Expose some normaliz features

Issue created by migration from https://trac.sagemath.org/ticket/25091

Original creator: jipilab

Original creation time: 2018-04-03 18:59:18

CC:  vdelecroix moritz mkoeppe @sebasguts winfried @braunmath tscrim

Keywords: polytope, normaliz, IMA-PolyGeom

Using Normaliz can compute several things that are currently not interfaced. For example:

 - Integral points generators
 - Volume
 - Euclidean volume
 - Triangulations

This ticket provides some new features.


---

Comment by jipilab created at 2018-04-03 19:02:45

Last 10 new commits:


---

Comment by git created at 2018-04-03 19:05:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2018-04-03 19:11:05

New commits:


---

Comment by jipilab created at 2018-04-03 23:13:15

New commits:


---

Comment by git created at 2018-04-04 00:14:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-04 14:34:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2018-04-04 14:38:00

Note that `is_package_installed` is being deprecated, see #20382


---

Comment by git created at 2018-04-04 19:36:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-04 19:56:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-04 19:58:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-04 20:02:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-07 18:26:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-07 18:38:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-08 16:23:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-08 17:05:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2018-04-09 04:28:13

It's probably best to add all lattice-point related methods to `Polyhedron_QQ_normaliz` rather than `Polyhedron_normaliz` in anticipation of #25097 (which moves `integral_points` and `integral_hull` there).


---

Comment by jipilab created at 2018-04-09 13:24:52

Replying to [comment:18 mkoeppe]:
> It's probably best to add all lattice-point related methods to `Polyhedron_QQ_normaliz` rather than `Polyhedron_normaliz` in anticipation of #25097 (which moves `integral_points` and `integral_hull` there). 

I see. Yes I can do that.


---

Comment by jipilab created at 2018-04-09 14:34:18

Replying to [comment:19 jipilab]:
> Replying to [comment:18 mkoeppe]:
> > It's probably best to add all lattice-point related methods to `Polyhedron_QQ_normaliz` rather than `Polyhedron_normaliz` in anticipation of #25097 (which moves `integral_points` and `integral_hull` there). 
> 
> I see. Yes I can do that.

As discussed with mkoeppe: The move of the rational polyhedron methods will be done in #25097. The merge should go without conflicts.


---

Comment by jipilab created at 2018-04-09 15:12:40

Replying to [comment:7 vdelecroix]:
> Note that `is_package_installed` is being deprecated, see #20382

Oh! Wow! Thanks for the timely warning! I set it as a dependency. I will change the check once it is merged...


---

Comment by git created at 2018-04-09 15:13:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-13 19:36:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-13 20:32:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-13 22:09:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-13 22:39:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2018-09-11 15:21:30

Out of interest: Given a monomial ideal in Sage, how can one compute its Hilbert series using normaliz?


---

Comment by SimonKing created at 2018-09-11 16:48:02

Replying to [comment:21 jipilab]:
> Replying to [comment:7 vdelecroix]:
> > Note that `is_package_installed` is being deprecated, see #20382
> 
> Oh! Wow! Thanks for the timely warning! I set it as a dependency. I will change the check once it is merged...

It is really a pity that #20382 doesn't explain (in the ticket description!!!) what one is supposed to do instead of `is_package_installed`.

So, how would one change the current branch to make it use #20382?


---

Comment by Winfried created at 2018-09-11 19:18:38

Replying to SimonKing

Normaliz can compute Hilbert series of the integral closures of monomial ideals, not of arbitrary monomial ideals. If one wants to apply it: input the monomials as vertices, the polynomial ring as cone (= unit matrix), and put the weights of the indeterminates into the grading.

Example for Normaliz input (integral closure of (x^2, y^2, deg x = 2, deg y =1)



```
amb_space 2
vertices 2
2 0 1
0 2 1
cone 2
1 0
0 1
grading 
2 1
HilbertSeries
```



---

Comment by SimonKing created at 2018-09-11 19:44:18

Replying to [comment:31 Winfried]:
> Replying to SimonKing
> 
> Normaliz can compute Hilbert series of the integral closures of monomial ideals, not of arbitrary monomial ideals. If one wants to apply it: input the monomials as vertices, the polynomial ring as cone (= unit matrix), and put the weights of the indeterminates into the grading.
> 
> Example for Normaliz input (integral closure of (x^2, y^2, deg x = 2, deg y =1)
> 
> 
> {{{
> amb_space 2
> vertices 2
> 2 0 1
> 0 2 1
> cone 2
> 1 0
> 0 1
> grading 
> 2 1
> HilbertSeries
> }}}

Thank you. But my question was really: Given a monomial ideal *in Sage*, how to compute the Hilbert series of it (or maybe of its integral closure) using normaliz as a backend (not: _in_ normaliz).

I.e.:

```
        sage: n=4;m=11;P = PolynomialRing(QQ,n*m,"x"); x = P.gens(); M = Matrix(n,x)
        sage: I = P.ideal(M.minors(2))
        sage: J = P*[m.lm() for m in I.groebner_basis()]
```

and what now? How to use the new interface to normaliz to compute the Hilbert series of (the integral closure of) `J`?

Since I never worked with the integral closure of a monomial ideal: How are the Hilbert series of the ideal and its integral closure related?


---

Comment by Winfried created at 2018-09-12 07:50:14

"What now?" is a question that Jean-Philippe should answer. I have no overview which of the Normaliz computation goals can be reached from Sage. However, all of them can be reached via PyNormaliz. For example, Normaliz can take a binomial ideal (suitably encoded) as input. It finds the affine monoid A defined by the binomial ideal, and then computes invariants of the normalization of A.

I think there is no way to relate the Hilbert series of an ideal I and the Hilbert series of its integral closure in a useful way.


---

Comment by jipilab created at 2018-09-17 15:31:11

> 
> Thank you. But my question was really: Given a monomial ideal *in Sage*, how to compute the Hilbert series of it (or maybe of its integral closure) using normaliz as a backend (not: _in_ normaliz).
> 
> I.e.:
> {{{
>         sage: n=4;m=11;P = PolynomialRing(QQ,n*m,"x"); x = P.gens(); M = Matrix(n,x)
>         sage: I = P.ideal(M.minors(2))
>         sage: J = P*[m.lm() for m in I.groebner_basis()]
> }}}
> and what now? How to use the new interface to normaliz to compute the Hilbert series of (the integral closure of) `J`?
> 
> Since I never worked with the integral closure of a monomial ideal: How are the Hilbert series of the ideal and its integral closure related?

My knowledge of the theory lacks in order to give you a satisfactory answer to your questions.

The present ticket allows you to get the Hilbert series _of a rational polyhedron_. Whether this Hilbert series _is_ or corresponds to the Hilbert series of a monomial ideal should be clarified. In case they match, then, what I would do in Sage is

1) a function that transfers the data of the monomial ideal to a polyhedron that uses the backend normaliz and compute its hilbert series (a function implemented in this ticket).

2) use PyNormaliz package directly as the normaliz backend of polyhedron is currently doing. This is not really well documented as its usage is currently only in the backend for polyhedron.

For this, the present ticket provides some useful functions to deal with PyNormaliz that builds on #25090.


---

Comment by jipilab created at 2018-09-17 15:52:18

Would this compute what you want? I did this with the current ticket and merge with the latest sage.


```

sage: n=4;m=11;P = PolynomialRing(QQ,n*m,"x"); x = P.gens(); M = Matrix(n,x)
sage: I = P.ideal(M.minors(2))
sage: J = P*[m.lm() for m in I.groebner_basis()]
sage: P = Polyhedron(rays=[m.degrees() for m in J.gens()],backend='normaliz')
sage: P
A 42-dimensional polyhedron in ZZ^44 defined as the convex hull of 1 vertex and 330 rays
sage: P.hilbert_series()

```


Well, I'd say this is a quite large computation involving triangulating a 42 dimensional polyhedron with 330 vertices...


---

Comment by Winfried created at 2018-09-17 16:10:34

What one really wants is not the Hilbert series of the ideal. The goal is the Hilbert series of the residue class ring defined by the ideal. The residue class ring can be identified with a monomial algebra of Krull dimension 14. The Hilbert series is easily calculated. If one wants to use Normaliz for it, then the best approach is to input the binomial ideal to Normaliz.

You make a matrix of integer vectors whose rows represent the binomials in the form v-w, corresponding to x^v - x^w. The input type is "lattice_ideal". You must also define a grading. Simply say "total_degree". In this case it represents a vector with 44 entries 1.

That one can go this way is due to the fact that the residue class ring is a normal monoid algebra. In general this is not the case.


---

Comment by jipilab created at 2018-09-17 17:51:45

Replying to [comment:30 SimonKing]:
> Replying to [comment:21 jipilab]:
> > Replying to [comment:7 vdelecroix]:
> > > Note that `is_package_installed` is being deprecated, see #20382
> > 
> > Oh! Wow! Thanks for the timely warning! I set it as a dependency. I will change the check once it is merged...
> 
> It is really a pity that #20382 doesn't explain (in the ticket description!!!) what one is supposed to do instead of `is_package_installed`.

Indeed.


---

Comment by jipilab created at 2018-09-17 18:21:19

Concerning the `is_package_installed` thing, it seems that it is _not_ deprecated when we want to check whether a package was installed using `sage -i` which is what we want here I guess.

So I would remove it from the necessary things to do for this ticket.


---

Comment by SimonKing created at 2018-09-17 21:03:10

Replying to [comment:38 jipilab]:
> Concerning the `is_package_installed` thing, it seems that it is _not_ deprecated when we want to check whether a package was installed using `sage -i` which is what we want here I guess.
> 
> So I would remove it from the necessary things to do for this ticket.

I tend to disagree. `is_package_installed` is used here to test whether pynormaliz, normaliz, or latte_int is available. And it may be available for reasons that have nothing to do with `sage -i`.


---

Comment by jipilab created at 2018-09-19 00:24:23

Replying to [comment:39 SimonKing]:
> Replying to [comment:38 jipilab]:
> > Concerning the `is_package_installed` thing, it seems that it is _not_ deprecated when we want to check whether a package was installed using `sage -i` which is what we want here I guess.
> > 
> > So I would remove it from the necessary things to do for this ticket.
> 
> I tend to disagree. `is_package_installed` is used here to test whether pynormaliz, normaliz, or latte_int is available. And it may be available for reasons that have nothing to do with `sage -i`.

Okay. Nevertheless, the mentionned ticket does not provide a way to check if they are available or not. Right?


---

Comment by SimonKing created at 2018-09-19 06:20:05

Replying to [comment:40 jipilab]:
> Okay. Nevertheless, the mentionned ticket does not provide a way to check if they are available or not. Right?

Yes, it doesn't. But I guess that's because the author of that ticket thought that the solution is relatively straight forward: When you code in Python, how do you use a package? You do so by importing stuff. Hence, you should test whether the package is available by trying to import something from that package (sooner or later, you will do anyway!), surrounded with a `try: ... except ImportError: ...` clause.

Indeed, in your code, you do `import PyNormaliz`. So, this could be

```
try:
    import PyNormaliz
except ImportError:
    raise ImportError("some meaningful error message, telling the user at least one way to install PyNormaliz")
```


For latte_int, I am not so sure what you do, because I don't see a related import statement in your code. However, in some place of your code, you do use it; you should try and see what happens if latte_int is not available: Will there be an ImportError, or a TypeError, or a ValueError, etc.? Then, instead of `is_package_available`, you could try to use latte_int in a dry run, and if an error occurs, you take it as an answer (namely the answer that latte_int is not available).


---

Comment by mkoeppe created at 2018-09-19 12:58:39

Replying to [comment:40 jipilab]:
> Replying to [comment:39 SimonKing]:
> > Replying to [comment:38 jipilab]:
> > > Concerning the `is_package_installed` thing, it seems that it is _not_ deprecated when we want to check whether a package was installed using `sage -i` which is what we want here I guess.
> > > 
> > > So I would remove it from the necessary things to do for this ticket.
> > 
> > I tend to disagree. `is_package_installed` is used here to test whether pynormaliz, normaliz, or latte_int is available. And it may be available for reasons that have nothing to do with `sage -i`.
> 
> Okay. Nevertheless, the mentionned ticket does not provide a way to check if they are available or not. Right?

I think what may be intended here is to subclass `sage.features.PythonModule`.


---

Comment by git created at 2018-10-10 19:26:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-10-11 17:49:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-01-28 16:59:20

I looked back at this now, and I'm getting a weird result from an example in Normaliz' manual:


```
sage: P = Polyhedron(vertices=[(1/2,1/2),(1/3,1/3),(1/4,-1/2)],backend='normaliz')
sage: P
A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 3 vertices
sage: P.hilbert_series()
0
```


From calling PyNormaliz, I get:


```
sage: h = PyNormaliz.NmzResult(new_cone, "HilbertSeries")
sage: h
[[], [], -1L]
```


So it's not the parsing from PyNormaliz to sage, but rather something weird is happening here. It has been a while since I wrote the code so I am a bit lost in trying to figure out what is going on...

I'll try to do some more searching...


---

Comment by Winfried created at 2019-01-28 18:13:12

I guess you want the Ehrhart series. The Normaliz computation goal HilbertSeries requires the existence of a grading which is not defined with this input. 

This is an intricate point, but it is inevitable: the grading is defined on the space in which the polyhedron lives, not on the cone over it.


---

Comment by jipilab created at 2019-01-29 08:36:13

Replying to [comment:47 Winfried]:
> I guess you want the Ehrhart series. The Normaliz computation goal HilbertSeries requires the existence of a grading which is not defined with this input. 
> 

Yes, in the end I want the Ehrhart series, but I was doing both computations to understand their difference again...

> This is an intricate point, but it is inevitable: the grading is defined on the space in which the polyhedron lives, not on the cone over it.  

Yes, agreed. I take this example from p.23 of the Normaliz manual. I thought that HilbertSeries would work out of the box like in the example. That's why I am asking myself what I did wrong.

In the code for hilbert_series, if no grading is given, we canonically give the all 1's grading on the ambient space, and then ask for the HilbertSeries, in which case we get the empty result(!?). (Is that a good choice of canonical grading?)

So, my question would be, how do I get the result from the Normaliz manual?

This issue makes me wonder also if the results in the current examples are actually true (because maybe I am doing something wrong). For example, what would be the expected outputs of for the 3-dimensional 0-1 cube?

Currently it gives me:


```
sage: C = Polyhedron(vertices = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1]
....: ,[1,1,0],[1,1,1]],backend='normaliz')
sage: C.hilbert_series()
t^3 + 3*t^2 + 3*t + 1
sage: C.ehrhart_series()
(t^2 + 4*t + 1)/(t^10 - t^9 - t^8 + 2*t^5 - t^2 - t + 1)
sage: C.ehrhart_series().denominator().factor()
(t + 1)^2 * (t - 1)^4 * (t^2 + 1) * (t^2 + t + 1)
sage: C.ehrhart_quasipolynomial()
t^3 + 3*t^2 + 3*t + 1
```


Hilbert series and ehrhart polynomials look fine, but the denominator of the Ehrhart series is not what I would expect. Is that related to the discussion on p.24 of Normaliz' manual?

I would have expected (1-t)^4, so that the degree would be -2 so that when we dilate by a factor two, we see the first interior integer point. Right?


---

Comment by Winfried created at 2019-01-29 11:58:34

HilbertSeries works out of the box, provided you use the right input type:

**polytope** defines a cone and a grading, and the Hilbert series of the cone under this grading is the Ehrhart series of the polytope that arises as the intersection of the cone and the hyperplane of degree 1 elements. **polytope** is a homogeneous input type.

The inhomogeneous type **vertices**  only defines a polytope P, or in connection with cone a potentially umbounded polyhedron. We can have an grding on the space in which the polytope lives, and then HilbertSeries makes sense.  This Hilbert series is the generating function of the lattice point enumerator of the points **in** P. You can ask Normaliz to compute the Ehrhart series of P if P is bounded. It constructs a cone with a grading behind the scenes and computes the Hilbert series of that cone.

So far, so good.

In your cube example: the vertices are in principle rational vectors. What are your denominators? Does Sage choose them automatically? If so what are they? 

Moreover, it seems to me tat Sage implicitly defines a grading on the space of the polytpe, taking the sum of the coordinates. This explains why you get a Hilbert series and that it is exactly the result shown: 1 point of degree 0, 3 points of degree 1, 3 of degree 2 and 1 of degree 3.

The denominator of the Ehrhart series is for a 3-dimensional polytope that has vertices of degree 4,3,2 qnd 1.

Before I can say more, I must know what happens on the way from Sage input to Normaliz input.


---

Comment by Winfried created at 2019-01-29 14:03:01

PS. My question for the denominators must be understood form the viewpoint of Normaliz input. For the 3-cube we need vertices with **four** coordinates in Normaliz where the last coordinate represents a denominator for the first three. (This was introduced before Normaliz allowed fractions in input; it would be superfluous now.)

If you send the matrix with the 8 vertices as it is to Normaliz as input type **vertices**, then the result will be a BadInputexception, because we have the denominator 0 for some vertices. In other words: Something must have happened from the Sage vertices before they go into Normaliz.

I think you want the denominator 1 attached to each vertex. If we do that, the Normaliz input becomes



```
amb_space auto
vertices
[[0,0,0,1],[0,0,1,1],[0,1,0,1],[0,1,1,1],[1,0,0,1],[1,0,1,1],[1,1,0,1],[1,1,1,1]]
EhrhartSeries
```


and the output contains



```
Ehrhart series:
1 4 1 
denominator with 4 factors:
1: 4
```

 
as one expects.

Again my question: what happens on the way from Sage input to Normaliz input?


---

Comment by jipilab created at 2019-01-30 10:08:19

Dear Winfried,

Thanks for your quick reply. This explanation is really good, and probably I should add it to the top to shortly describe how the translation from sage to normaliz is done.

Here is the verbose of the example for the cube, we can see the input given by sage to normaliz.
The current way is to always use inhomogeneous (vertices, cones, and subspaces). Eventually, inhom. equations and inequalities are added.


```
sage: C = Polyhedron(vertices = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]],backend='normaliz',
....: verbose=True)
# Calling PyNormaliz.NmzCone(**{'subspace': [], 'vertices': [[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1], [1, 0, 0, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 1]], 'cone': []})
# ----8<---- Equivalent Normaliz input file ----8<----
amb_space 3
subspace 0
vertices 8
 0 0 0 1
 0 0 1 1
 0 1 0 1
 0 1 1 1
 1 0 0 1
 1 0 1 1
 1 1 0 1
 1 1 1 1
cone 0
# ----8<-------------------8<-------------------8<----
```


Once I have this, I compute the hilbert series, **without** giving any grading. In this case, Sage assign the grading [1,...,1] and passes it to normaliz (as you observed) and get:


```
sage: C.hilbert_series()
t^3 + 3*t^2 + 3*t + 1
```


Now, for the Ehrhart series, I get:


```
sage: C.ehrhart_series()
(t^2 + 4*t + 1)/(t^10 - t^9 - t^8 + 2*t^5 - t^2 - t + 1)
```


As you said:

>  It constructs a cone with a grading behind the scenes and computes the Hilbert series of that cone. 

What is the grading in this case?

So there seems to be a difference between the above input and the one you mentioned:


```
amb_space auto
vertices
[[0,0,0,1],[0,0,1,1],[0,1,0,1],[0,1,1,1],[1,0,0,1],[1,0,1,1],[1,1,0,1],[1,1,1,1]]
EhrhartSeries
```


because they give different output for the Ehrhart series?


---

Comment by Winfried created at 2019-01-30 11:47:27

The Normaliz input is the desired one. If I run it with the computation goal EhhhartSeries I get the right answer, and if I run it with the computation goal HilbertSeries, then the answer is that it cannot be computed. Everything o.k.

But it is also clear that this workflow is not exactly that of Sage/PyNormaliz: the latter constructs a cone and then calls functions that trigger computations and return results. For a better analysis the next step is to put the same data into PyNormaliz and to see what happens.


---

Comment by jipilab created at 2019-01-30 12:24:52

Replying to [comment:52 Winfried]:
> The Normaliz input is the desired one. If I run it with the computation goal EhhhartSeries I get the right answer, and if I run it with the computation goal HilbertSeries, then the answer is that it cannot be computed. Everything o.k.

Ok. Good to know!

> 
> But it is also clear that this workflow is not exactly that of Sage/PyNormaliz: the latter constructs a cone and then calls functions that trigger computations and return results. For a better analysis the next step is to put the same data into PyNormaliz and to see what happens.

Ok, I will look into that.


---

Comment by jipilab created at 2019-01-30 14:31:59

Ok, I think that I have figured out something, that I did not expect.


```
sage: C = Polyhedron(vertices = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]
....: ],backend='normaliz',verbose=True)
# Calling PyNormaliz.NmzCone(**{'subspace': [], 'vertices': [[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1], [1, 0, 0, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 1]], 'cone': []})
# ----8<---- Equivalent Normaliz input file ----8<----
amb_space 3
subspace 0
vertices 8
 0 0 0 1
 0 0 1 1
 0 1 0 1
 0 1 1 1
 1 0 0 1
 1 0 1 1
 1 1 0 1
 1 1 1 1
cone 0
# ----8<-------------------8<-------------------8<----
```


So far I simply created the 0-1-cube using normaliz. Then, I get the normaliz cone and the enclosed data:


```
sage: cone = C._normaliz_cone;cone
<capsule object "Cone" at 0x7fcc880cf210>
sage: data = C._get_nmzcone_data()
```


From there, if I compute the Hilbert Series directly, it will complain, because it does not have a grading:


```
sage: PyNormaliz.NmzResult(cone,"HilbertSeries")
---------------------------------------------------------------------------
error                                     Traceback (most recent call last)
<ipython-input-26-93c9989a5377> in <module>()
----> 1 PyNormaliz.NmzResult(cone,"HilbertSeries")

error: Could not compute: No grading specified and cannot find one. Cannot compute some requested properties!
```


So far so good. Then, I ask for the Ehrhart series and then, it unlocks the Hilbert series:


```
sage: PyNormaliz.NmzResult(cone,"EhrhartSeries")
[[1L, 4L, 1L], [1L, 1L, 1L, 1L], 0L]
sage: PyNormaliz.NmzResult(cone,"HilbertSeries")
[[1L, 4L, 1L], [1L, 1L, 1L, 1L], 0L]
```


For now, there is no way to access the difference in the normaliz cone. It is now equipped with a grading in the background, but it seems that we can not extract it:


```
sage: new_C = C.parent().element_class._from_normaliz_cone(parent=C.parent(),normaliz_cone=cone)
sage: PyNormaliz.NmzResult(new_C._normaliz_cone,"HilbertSeries")
[[1L, 4L, 1L], [1L, 1L, 1L, 1L], 0L]
sage: PyNormaliz.NmzResult(new_C._normaliz_cone,"Grading")
---------------------------------------------------------------------------
error                                     Traceback (most recent call last)
<ipython-input-43-809cb91899e5> in <module>()
----> 1 PyNormaliz.NmzResult(new_C._normaliz_cone,"Grading")

error: Could not compute: Grading !
```


But, when creating a whole new cone from the data and adding by hand the grading (which is what is done in `hilbert_series` in sage, we get the enumeration of the lattice points with respect to this grading:


```
sage: C.hilbert_series()
t^3 + 3*t^2 + 3*t + 1
```


This can be reproduced manually as:


```
sage: data['grading'] = [1] * C.ambient_dim()
sage: new_cone = C._make_normaliz_cone(data)
sage: h = PyNormaliz.NmzResult(new_cone, "HilbertSeries");h
[[1L, 3L, 3L, 1L], [], 0L]
```


So, right now, we get two potential output for Hilbert series.

Further, if we actually change the normaliz cone while doing the computation of the Hilbert series (instead of doing it on a distinct cone created on the side), it then breaks the ehrhart series:


```
sage: C._normaliz_cone = new_cone
sage: C.ehrhart_series()
---------------------------------------------------------------------------
error                                     Traceback (most recent call last)
<ipython-input-85-0117d93a819f> in <module>()
----> 1 C.ehrhart_series()

/home/jplabbe/sage/local/lib/python2.7/site-packages/sage/geometry/polyhedron/backend_normaliz.pyc in ehrhart_series(self, variable)
    636 
    637         cone = self._normaliz_cone
--> 638         e = PyNormaliz.NmzResult(cone, "EhrhartSeries")
    639 
    640         from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing

error: Some error in the normaliz input data detected: Grading not allowed with Ehrhart series in the inhomogeneous case
```



Oi Oi Oi...


---

Comment by Winfried created at 2019-01-30 15:56:31

Everything above is as it should be, with 2 exceptions:

1) The computation of the Ehrhart series should not make the Hilbert series computed. This requires a correction in libnormaliz.

There is no grading in the background. The Ehrhart series was computed on an auxiliary cone.

2) Sage should not add a default grading if one asks for the Hilbert series. This is not in my hands.

Further remark: if one changes the grading later on (or defines one), all grading dependent results are erased.


---

Comment by Winfried created at 2019-01-30 16:03:14

PS. The last observation is the intended behavior of Normaliz: HilbertSeries and EhrhartSeries are not allowed on the same input. One intended obstruction to this is that we do not even allow a grading if EhrhartSeries is to be computed.


---

Comment by Winfried created at 2019-02-01 08:22:27

The next Normaliz release will store the Hilbert series and the Ehrhart series separately and provide a specific access function for the Ehrhart series. Then the confusion that we see in the preceding remarks will not arise anymore.


---

Comment by jipilab created at 2019-02-04 13:09:08

Ok!!

So I went back to PyNormaliz and had a look at the tutorial mentioned in Appendix E of the normaliz manual:

https://mybinder.org/v2/gh/Normaliz/NormalizJupyter/master

In there, the PyNormaliz output of .hilbert_series is explained. **Importantly**, it seems that the output is different than the one of normaliz(!). This was the source of one of the above problems.


```
[[1L, 4L, 1L], [1L, 1L, 1L, 1L], 0L]
```


As to be interpreted as `t^2+4t+1` divided by `(1-t)(1-t)(1-t)(1-t)` and a `0` shift.

So, it's all good. But it indicates that the code should be more explicit on those output formats... I'll put this on my list of TODO to add on some comments on the pynormaliz side...


---

Comment by Winfried created at 2019-02-04 16:33:45

In the Normaliz pitput file we use a multiset notation. i think this is difficult to represent in Python. Therefore it is translated into a vector format where each element of the multiset is repeated as often as it occurs in the multiset.


---

Comment by git created at 2019-02-04 17:54:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-02-04 17:56:37

Replying to [comment:59 Winfried]:
> In the Normaliz pitput file we use a multiset notation. i think this is difficult to represent in Python. Therefore it is translated into a vector format where each element of the multiset is repeated as often as it occurs in the multiset.

Yes, makes sense now. Somehow got it wrong from the beginning. I just commited an update that should cover the mistake. I added several examples coming from normaliz manual to be able to compare.

I still have to smoothen the usage for the user. But now, at least things look like they work and make sense...


---

Comment by git created at 2019-02-05 10:00:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-02-05 10:45:35

Here is a bug, which I think is coming from the PyNormaliz side of things:


```
sage: v = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
sage: cube = Polyhedron(vertices=v,backend='normaliz')
sage: cube._volume_normaliz()
sage: cube._volume_normaliz('induced_lattice')
6
sage: cube._volume_normaliz()
1.0
```


Equivalently:


```
sage: v = [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
sage: cube = Polyhedron(vertices=v,backend='normaliz',verbose=True)
# Calling PyNormaliz.NmzCone(**{'subspace': [], 'vertices': [[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 1], [1, 0, 0, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 1]], 'cone': []})
# ----8<---- Equivalent Normaliz input file ----8<----
amb_space 3
subspace 0
vertices 8
 0 0 0 1
 0 0 1 1
 0 1 0 1
 0 1 1 1
 1 0 0 1
 1 0 1 1
 1 1 0 1
 1 1 1 1
cone 0
# ----8<-------------------8<-------------------8<----
sage: cone = cube._normaliz_cone
sage: import PyNormaliz
sage: PyNormaliz.NmzResult(cone,'EuclideanVolume')
sage: PyNormaliz.NmzResult(cone,'EuclideanVolume')
1.0
```


This is weird. The volume somehow seems to get lost on the way. When one asks again, the output appears.


---

Comment by git created at 2019-02-05 11:08:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-03-13 14:18:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-03-13 19:40:53

This

```
try:
    import PyNormaliz
except ImportError:
    raise ImportError("This backend requires PyNormaliz. To install PyNormaliz, type 'sage -i pynormaliz' in the terminal.")
```

is not desirable. You should do that via a "feature". See the class `PythonModule` in `sage/features/__init__.py`. The main reason is that `sage -i` would only work for people compiling from source (which is the case of less and less people nowadays).


---

Comment by embray created at 2019-03-25 10:56:15

Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)


---

Comment by mkoeppe created at 2019-04-23 12:52:08

I'd suggest to merge #27716 as a dependency and use the new helper method `_nmz_result`


---

Comment by git created at 2019-04-23 13:27:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-04-23 13:31:40

I merge the latest develop and #27682 in the last commits. I will merge #27716 as the next step.


---

Comment by git created at 2019-04-25 17:29:31

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2019-04-25 17:39:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2019-04-25 17:41:30

Changing status from new to needs_review.


---

Comment by tscrim created at 2019-04-25 23:13:23

I have some comments:

This is a general Python convention we try to follow with the messages, moreover, the error is because the class has the wrong type (you are not expecting it to be implemented at some point, right?):

```diff
-raise NotImplementedError("The backend should be normaliz.")
+raise TypeError("the backend should be normaliz")
```

A similar comment applies elsewhere too. However, the `ImportError` can be the exception to this guide as it is "long".

The `INPUT:` bullet points are not considered to be complete sentences, so they should not end in a period/full-stop.

PEP8:

```diff
-sage: S = Polyhedron(vertices = [[0,1],[1,0]],backend='normaliz') # optional - pynormaliz
+sage: S = Polyhedron(vertices=[[0,1],[1,0]], backend='normaliz')  # optional - pynormaliz
```

and similar such things.

In `ehrhart_series()`, i think this will look better in latex formatting:

```
-``t^k`` is number of integer lattice points inside the ``k``-th dilation of
+`t^k` is number of integer lattice points inside the `k`-th dilation of
```

Note that `k` and `t` are not input variable names.


---

Comment by git created at 2019-04-26 08:39:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-04-26 12:16:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2019-04-26 14:47:32

There's an error in a doctest. 

```
sage -t --long src/sage/geometry/polyhedron/base.py
**********************************************************************
File "src/sage/geometry/polyhedron/base.py", line 2874, in sage.geometry.polyhedron.base.Polyhedron_base._triangulate_normaliz
Failed example:
    K._triangulate_normaliz(engine='normaliz')
Expected:
    Traceback (most recent call last):
    ...
    TypeError: The polyhedron's backend should be 'normaliz'
Got:
    <BLANKLINE>
    Traceback (most recent call last):
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-algebraic-2018-spring/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 671, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-algebraic-2018-spring/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1095, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.geometry.polyhedron.base.Polyhedron_base._triangulate_normaliz[1]>", line 1, in <module>
        K._triangulate_normaliz(engine='normaliz')
    TypeError: _triangulate_normaliz() got an unexpected keyword argument 'engine'
**********************************************************************
```



---

Comment by mkoeppe created at 2019-04-26 14:47:32

Changing status from needs_review to needs_work.


---

Comment by git created at 2019-04-27 17:15:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-04-27 17:18:58

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2019-04-29 23:18:31

I think I ended up being a little vague about the error messages. In Python, error messages start with a lowercase letter and do not end with a period/full-stop. While I do not expect you to change them all, I think it is good not to make it further from the general convention. I know this is not documented, but is sort of an agreement. So if you want to keep things the way they are, then you can go ahead and set a positive review. Although I would appreciate you changing them (or at least making a uniform convention for all of your added error messages).


---

Comment by slabbe created at 2019-04-30 08:07:05

One comment:


```
+# FLINT is a standard package and E-ANTIC is a standard pakcage. We
```


the 2nd occ. of standard -> optional


---

Comment by jipilab created at 2019-04-30 08:44:26

Replying to [comment:86 tscrim]:
> I think I ended up being a little vague about the error messages. In Python, error messages start with a lowercase letter and do not end with a period/full-stop. While I do not expect you to change them all, I think it is good not to make it further from the general convention. I know this is not documented, but is sort of an agreement. So if you want to keep things the way they are, then you can go ahead and set a positive review. Although I would appreciate you changing them (or at least making a uniform convention for all of your added error messages).

Oh, I see. No problem, I will change it.


---

Comment by jdemeyer created at 2019-04-30 10:27:32

This is still using `is_package_installed`.


---

Comment by jdemeyer created at 2019-04-30 10:27:32

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2019-04-30 10:30:05

Instead of putting `Latte().require()` in a `try` block, you can just check `if Latte().is_present()`

It can be argued which kind of error should be given here (I would go for `RuntimeError`), but certainly not a `TypeError`:

```
raise TypeError("The induced rational measure can only be computed with the optional packages `latte_int`, or `pynormaliz`")
```



---

Comment by jdemeyer created at 2019-04-30 10:33:53

Replying to [comment:42 mkoeppe]:
> I think what may be intended here is to subclass `sage.features.PythonModule`.

Not subclassing, just use it like `PythonModule("package.submodule").is_present()` or whatever.


---

Comment by jdemeyer created at 2019-04-30 10:41:00

More in detail: replace

```
        try:
            import PyNormaliz
        except ImportError:
            raise ImportError("This backend requires PyNormaliz. To install PyNormaliz, type 'sage -i pynormaliz' in the terminal.")
```

by

```
from sage.features import PythonModule

        PythonModule("PyNormaliz", spkg="pynormaliz").require()
        import PyNormaliz
```



---

Comment by git created at 2019-04-30 12:06:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-04-30 12:08:12

I fixed the error messages, typos, and the `require()` of `PyNormaliz`.

Ready for review again.


---

Comment by jipilab created at 2019-04-30 12:08:12

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2019-04-30 12:13:05

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2019-04-30 12:13:05

[comment:89]


---

Comment by git created at 2019-04-30 12:36:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-04-30 12:37:52

Changing status from needs_work to needs_review.


---

Comment by jipilab created at 2019-04-30 12:37:52

... forgot about this latte/pynormaliz switch there. Hopefully complete now.


---

Comment by jdemeyer created at 2019-04-30 12:56:33

I would still recommend to change the type of exception: `TypeError` makes no sense here.


---

Comment by git created at 2019-04-30 15:40:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-04-30 15:42:17

... sorry for the omission, and thanks for the coaching on the features module.


---

Comment by tscrim created at 2019-05-01 00:00:01

Thank you for changing the error message strings.

You also need to make a changes in the `combinat/rigged_configurations/kleber_tree.py`

```diff
         try:
             poly = Polyhedron(ieqs=ieqs, backend='normaliz')
             self._has_normaliz = True
-        except ImportError:
+        except FeatureNotPresentError:
             poly = Polyhedron(ieqs=ieqs)
             self._has_normaliz = False
```

to reflect the new error message is thrown. That should take care of all of the errors reported on the patchbot (for when `normaliz` is not installed).

Modulo that, I am happy with this and am willing to set a positive review. Jeroen, any other comments?


---

Comment by git created at 2019-05-01 07:51:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-05-01 07:55:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2019-05-01 10:09:41

You forgot to import `FeatureNotPresentError` in `kleber_tree.py`.


---

Comment by git created at 2019-05-01 15:30:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-05-01 15:30:36

... it has been a long workshop.


---

Comment by git created at 2019-05-02 06:59:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-05-02 07:01:24

The last commit refactors things in the spirit of #27716.

It is now completely ready for review... No more forgotten things hopefully.


---

Comment by tscrim created at 2019-05-02 08:22:50

You definitely seem to have done quite a bit in your workshop. However, now there are serious things failing: I am getting an infinite recursion happening that ends with

```
/home/uqtscrim/sage-build/local/lib/python2.7/site-packages/sage/geometry/polyhedron/backend_normaliz.pyc in _nmz_result(self, normaliz_cone, property)
    193         PythonModule("PyNormaliz", spkg="pynormaliz").require()
    194         import PyNormaliz
--> 195         return self._nmz_result(normaliz_cone, property)
    196 
    197     def _init_from_normaliz_cone(self, normaliz_cone):

... last 1 frames repeated, from the frame below ...

/home/uqtscrim/sage-build/local/lib/python2.7/site-packages/sage/geometry/polyhedron/backend_normaliz.pyc in _nmz_result(self, normaliz_cone, property)
    193         PythonModule("PyNormaliz", spkg="pynormaliz").require()
    194         import PyNormaliz
--> 195         return self._nmz_result(normaliz_cone, property)
    196 
    197     def _init_from_normaliz_cone(self, normaliz_cone):

RuntimeError: maximum recursion depth exceeded in cmp
```

A function that only calls itself will definitely infinitely recurse. `;)`

Additionally, a couple of little details noted by the patchbot from pyflakes for `backend_normaliz.py`:

In `def _cone_generators(pynormaliz_cone):`, you have

```
return self._nmz_result(pynormaliz_cone, "Generators")
```

In particular, `self` is not been defined in this ``@`staticmethod`.

Do you require the `import PyNormaliz` here in `_nmz_result`:

```
        PythonModule("PyNormaliz", spkg="pynormaliz").require()
        import PyNormaliz
        return self._nmz_result(normaliz_cone, property)
```



---

Comment by tscrim created at 2019-05-02 08:22:50

Changing status from needs_review to needs_work.


---

Comment by jipilab created at 2019-05-02 14:12:48

Oï oï oï... Will fix this, asap.

Replying to [comment:109 tscrim]:
> You definitely seem to have done quite a bit in your workshop. However, now there are serious things failing: I am getting an infinite recursion happening that ends with
> {{{
> /home/uqtscrim/sage-build/local/lib/python2.7/site-packages/sage/geometry/polyhedron/backend_normaliz.pyc in _nmz_result(self, normaliz_cone, property)
>     193         PythonModule("PyNormaliz", spkg="pynormaliz").require()
>     194         import PyNormaliz
> --> 195         return self._nmz_result(normaliz_cone, property)
>     196 
>     197     def _init_from_normaliz_cone(self, normaliz_cone):
> 
> ... last 1 frames repeated, from the frame below ...
> 
> /home/uqtscrim/sage-build/local/lib/python2.7/site-packages/sage/geometry/polyhedron/backend_normaliz.pyc in _nmz_result(self, normaliz_cone, property)
>     193         PythonModule("PyNormaliz", spkg="pynormaliz").require()
>     194         import PyNormaliz
> --> 195         return self._nmz_result(normaliz_cone, property)
>     196 
>     197     def _init_from_normaliz_cone(self, normaliz_cone):
> 
> RuntimeError: maximum recursion depth exceeded in cmp
> }}}
> A function that only calls itself will definitely infinitely recurse. `;)`
> 
> Additionally, a couple of little details noted by the patchbot from pyflakes for `backend_normaliz.py`:
> 
> In `def _cone_generators(pynormaliz_cone):`, you have
> {{{
> return self._nmz_result(pynormaliz_cone, "Generators")
> }}}
> In particular, `self` is not been defined in this ``@`staticmethod`.
> 
> Do you require the `import PyNormaliz` here in `_nmz_result`:
> {{{
>         PythonModule("PyNormaliz", spkg="pynormaliz").require()
>         import PyNormaliz
>         return self._nmz_result(normaliz_cone, property)
> }}}


---

Comment by git created at 2019-05-02 16:42:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-05-02 16:50:26

Replying to [comment:109 tscrim]:

> A function that only calls itself will definitely infinitely recurse. `;)`
>

I love those...
 
> Additionally, a couple of little details noted by the patchbot from pyflakes for `backend_normaliz.py`:
> 
> In `def _cone_generators(pynormaliz_cone):`, you have
> {{{
> return self._nmz_result(pynormaliz_cone, "Generators")
> }}}
> In particular, `self` is not been defined in this ``@`staticmethod`.

Is now fixed.

> Do you require the `import PyNormaliz` here in `_nmz_result`:
> {{{
>         PythonModule("PyNormaliz", spkg="pynormaliz").require()
>         import PyNormaliz
>         return self._nmz_result(normaliz_cone, property)
> }}}

This was the cause of the infinite recursion. It is now fixed.


---

Comment by jipilab created at 2019-05-02 16:50:36

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2019-05-09 14:42:40

Needs review again!


---

Comment by tscrim created at 2019-05-09 22:55:45

LGTM.


---

Comment by tscrim created at 2019-05-09 22:55:45

Changing status from needs_review to positive_review.


---

Comment by jipilab created at 2019-05-10 05:01:50

Replying to [comment:115 tscrim]:
> LGTM.

Great news!


---

Comment by vbraun created at 2019-05-14 07:03:58


```
**********************************************************************
File "src/sage/geometry/polyhedron/base.py", line 5295, in sage.geometry.polyhedron.base.Polyhedron_base.volume
Failed example:
    P.volume(measure='induced_rational')  # optional - latte_int
Expected:
    3/2
Got:
    1
**********************************************************************
1 item had failures:
   1 of  47 in sage.geometry.polyhedron.base.Polyhedron_base.volume
    [1137 tests, 1 failure, 48.32 s]
----------------------------------------------------------------------
sage -t --long src/sage/geometry/polyhedron/base.py  # 1 doctest failed
----------------------------------------------------------------------
```



---

Comment by vbraun created at 2019-05-14 07:03:58

Changing status from positive_review to needs_work.


---

Comment by jipilab created at 2019-05-14 08:10:42

Replying to [comment:117 vbraun]:
> {{{
> **********************************************************************
> File "src/sage/geometry/polyhedron/base.py", line 5295, in sage.geometry.polyhedron.base.Polyhedron_base.volume
> Failed example:
>     P.volume(measure='induced_rational')  # optional - latte_int
> Expected:
>     3/2
> Got:
>     1
> **********************************************************************
> 1 item had failures:
>    1 of  47 in sage.geometry.polyhedron.base.Polyhedron_base.volume
>     [1137 tests, 1 failure, 48.32 s]
> ----------------------------------------------------------------------
> sage -t --long src/sage/geometry/polyhedron/base.py  # 1 doctest failed
> ----------------------------------------------------------------------
> }}}

Hm. Annoying.

I can reproduce this with `--optional=4ti2,bliss,dochtml,e_antic,gfortran,latte_int,lidia,lrslib,memlimit,mpir,ninja_build,python2,sage,topcom`

and all tests pass with `pynormaliz` added. Dammit.


---

Comment by jipilab created at 2019-05-14 08:14:55

Replying to [comment:118 jipilab]:
> Replying to [comment:117 vbraun]:
> > {{{
> > **********************************************************************
> > File "src/sage/geometry/polyhedron/base.py", line 5295, in sage.geometry.polyhedron.base.Polyhedron_base.volume
> > Failed example:
> >     P.volume(measure='induced_rational')  # optional - latte_int
> > Expected:
> >     3/2
> > Got:
> >     1
> > **********************************************************************
> > 1 item had failures:
> >    1 of  47 in sage.geometry.polyhedron.base.Polyhedron_base.volume
> >     [1137 tests, 1 failure, 48.32 s]
> > ----------------------------------------------------------------------
> > sage -t --long src/sage/geometry/polyhedron/base.py  # 1 doctest failed
> > ----------------------------------------------------------------------
> > }}}
> 
> Hm. Annoying.
> 
> I can reproduce this with `--optional=4ti2,bliss,dochtml,e_antic,gfortran,latte_int,lidia,lrslib,memlimit,mpir,ninja_build,python2,sage,topcom`
> 
> and all tests pass with `pynormaliz` added. Dammit.

Got it! It's from a previous test... That's a easy fix. I forgot to put both latte_it and pynormaliz as optional...


---

Comment by git created at 2019-05-14 08:17:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2019-05-14 08:17:23

Needs review again...


---

Comment by jipilab created at 2019-05-14 08:17:23

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2019-05-15 00:10:43

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2019-05-21 12:16:05

Resolution: fixed
