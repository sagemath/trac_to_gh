# Issue 12750: Implicit derivative

Issue created by migration from Trac.

Original creator: mmarco

Original creation time: 2012-05-08 11:35:00

Assignee: burcin

CC:  kcrisman sjg10 burcin

Keywords: implicit derivative

Added implicit_derivative function. It allows to compute the n'th derivative of the implicit function defined by a symbolic expression.


---

Attachment


---

Comment by mmarco created at 2012-05-08 11:41:34

Changing status from new to needs_review.


---

Comment by sjg10 created at 2012-07-11 11:40:22

Reviewed, seems good. Added a check for having no y term in the expression. Was previously an uncaught `DivideByZero`, while code now gives a more informative error.
Was my first review, would appreciate to know whether I'm actually being any help!


---

Comment by kcrisman created at 2012-07-11 13:25:43

Yes, both helpful!  A few comments.
* The reviewer patch should be a separate patch on top of the original patch, so that the original author is kept.
* In any case, the patch should have a meaningful commit message.
* I'm a little apprehensive about the many specific variables and functions defined here.  Won't that cause some kind of conflict with (say) an already-defined `yy`?  We shouldn't depend on people not needing those variables.  Or is everything only in local scope because of the use of `SR.symbol`?

I'm also wondering - is it possible to have an implicit derivative method for symbolic expressions?  Just curious.


---

Comment by sjg10 created at 2012-07-11 16:02:27

adds error handler


---

Attachment

All the variables defined in the function are local. They do not get mixed with the global variables with the same name. You can even call the function with xx and yy as parameters, and they will  not be mixed with the local xx and yy.


```
sage: var('x,y')
(x, y)
sage: implicit_derivative(y,x,y*x/cos(x+y))
-(x*y*sin(x + y)/cos(x + y)^2 + y/cos(x + y))/(x*y*sin(x + y)/cos(x + y)^2 + x/cos(x + y))
sage: var('xx,yy')
(xx, yy)
sage: implicit_derivative(yy,xx,yy*xx/cos(xx+yy))
-(xx*yy*sin(xx + yy)/cos(xx + yy)^2 + yy/cos(xx + yy))/(xx*yy*sin(xx + yy)/cos(xx + yy)^2 + xx/cos(xx + yy))
```


About writing this as a method for symbolic expressions... that was my first idea; but i prefeared this aproach, due to the fact that you are actually not  diferentiating the symbolic expression, but a function defined implicitely by the symbolic expression. So it seemed more natural to me this kind of syntax.


---

Comment by sjg10 created at 2012-07-13 10:35:10

Calling `var` or `SR.symbol('somename')` even locally does add to the `pynac_symbol_registry`, yet calling `SR.symbol()` with no argument will create a temporary variable that will not be added to this registry. Possibly adding to the registry may cause problems if it is being referenced directly for some reason. Maybe worth just using `x = SR.symbol()` etc?



```
sage: from sage.symbolic.ring import pynac_symbol_registry
sage: pynac_symbol_registry                               
{'some_variable': some_variable, 'A': A, 'C': C, 'B': B, 'E': E, 'D': D, 'G': G, 'F': F, 'H': H, 'K': K, 'J': J, 'M': M, 'L': L, 'N': N, 'Q': Q, 'P': P, 'S': S, 'R': R, 'U': U, 'T': T, 'W': W, 'V': V, 'Y': Y, 'X': X, 'Z': Z, 'a': a, 'c': c, 'b': b, 'd': d, 'g': g, 'f': f, 'h': h, 'k': k, 'j': j, 'm': m, 'l': l, 'o': o, 'n': n, 'q': q, 'p': p, 's': s, 'r': r, 'u': u, 't': t, 'w': w, 'v': v, 'y': y, 'x': x, 'z': z}
sage: def f(): temp = SR.symbol()                         
....: 
sage: f()
sage: pynac_symbol_registry
{'some_variable': some_variable, 'A': A, 'C': C, 'B': B, 'E': E, 'D': D, 'G': G, 'F': F, 'H': H, 'K': K, 'J': J, 'M': M, 'L': L, 'N': N, 'Q': Q, 'P': P, 'S': S, 'R': R, 'U': U, 'T': T, 'W': W, 'V': V, 'Y': Y, 'X': X, 'Z': Z, 'a': a, 'c': c, 'b': b, 'd': d, 'g': g, 'f': f, 'h': h, 'k': k, 'j': j, 'm': m, 'l': l, 'o': o, 'n': n, 'q': q, 'p': p, 's': s, 'r': r, 'u': u, 't': t, 'w': w, 'v': v, 'y': y, 'x': x, 'z': z}
sage: def f(): temp = SR.symbol('temp')
....: 
sage: f()
sage: pynac_symbol_registry
{'temp': temp, 'some_variable': some_variable, 'A': A, 'C': C, 'B': B, 'E': E, 'D': D, 'G': G, 'F': F, 'H': H, 'K': K, 'J': J, 'M': M, 'L': L, 'N': N, 'Q': Q, 'P': P, 'S': S, 'R': R, 'U': U, 'T': T, 'W': W, 'V': V, 'Y': Y, 'X': X, 'Z': Z, 'a': a, 'c': c, 'b': b, 'd': d, 'g': g, 'f': f, 'h': h, 'k': k, 'j': j, 'm': m, 'l': l, 'o': o, 'n': n, 'q': q, 'p': p, 's': s, 'r': r, 'u': u, 't': t, 'w': w, 'v': v, 'y': y, 'x': x, 'z': z}
```



---

Comment by mmarco created at 2012-07-13 10:52:38

I have tried to use SR.symbol() instead of SR.symbol('x'), but then the result is a mess.

I can't think of a way to make this work without the said side effect.


---

Comment by mmarco created at 2013-06-07 17:46:09

I solved the pynac symbol registry pollution by saving a copy of it at the beginning of the function, and restoring it at the end. I am not sure if this is the best choice, but it is the only solution i found, and seems to work fine.


---

Comment by burcin created at 2013-06-07 20:53:00

Changing status from needs_review to needs_work.


---

Comment by burcin created at 2013-06-07 20:53:00

Messing with the symbol registry this way is really not a good idea. That is just supposed to be internal data.

What if there is an exception in that code and the registry is not restored?

What exactly is the problem with using temporary variables? Looking briefly at the patch, it looks like we also need temporary functions.


---

Comment by mmarco created at 2013-06-07 21:05:30

The problem with using temporary variables without giving them a name string is this:


```

sage: from sage.symbolic.function_factory import SymbolicFunction
sage: var('x,y')                                                                                                                                    
(x, y)
sage: def implicit_derivative(Y,X,F,n=1):                                                                                                           
....:         x=SR.symbol()                                                                                                                         
....:         yy=SR.symbol()                                                                                                                        
....:         y=SymbolicFunction('y',1)(x)                                                                                                          
....:         f=SymbolicFunction('f',2)(x,yy)                                                                                                       
....:         Fx=f.diff(x)                                                                                                                          
....:         Fy=f.diff(yy)                                                                                                                         
....:         G=-(Fx/Fy)                                                                                                                            
....:         G=G.subs_expr({yy:y})                                                                                                                 
....:         di={y.diff(x):-F.diff(X)/F.diff(Y)}                                                                                                   
....:         R=G                                                                                                                                   
....:         S=G.diff(x,n-1)                                                                                                                       
....:         for i in range(n+1):                                                                                                                  
....:                 di[y.diff(x,i+1)(x=x)]=R                                                                                                      
....:                 S=S.subs_expr(di)                                                                                                             
....:                 R=G.diff(x,i)                                                                                                                 
....:                 for j in range(n+1-i):                                                                                                        
....:                         di[f.diff(x,i,yy,j)(x=x,yy=y)]=F.diff(X,i,Y,j)                                                                        
....:                         S=S.subs_expr(di)                                                                                                     
....:                 return S                                                                                                                      
....:                                                                                                                                               
sage: implicit_derivative(y,x,x^2+y^2-1)                                                                                                            
-D[0](f)(symbol160, y(symbol160))/D[1](f)(symbol160, y(symbol160))
```


I don't know why, this problem is not present if we put the strings in the definitions of the variables.


---

Comment by burcin created at 2013-06-08 09:26:54

Replying to [comment:10 mmarco]:
> {{{             
> sage: implicit_derivative(y,x,x<sup>2+y</sup>2-1)                                                                                  
> -D[0](f)(symbol160, y(symbol160))/D[1](f)(symbol160, y(symbol160))
> }}}

It looks like the substitution doesn't work at some point.

Looking at the code...

The calls `y.diff(x,i+1)(x=x)` and `f.diff(x,i,yy,j)(x=x,yy=y)` rely on the name of the variable. You should use a dictionary argument to `.subs()`.

BTW, the `subs_expr()` method will go away at some point. Why not just use `.subs()` everywhere?


---

Comment by burcin created at 2013-06-08 09:33:46

Before this gets switched to positive review, we should check how it behaves if there already is a symbolic function defined with a custom method for evaluation named `y` or `f`.

Why is this not a method of symbolic expressions? Isn't it inconsistent to have the functional notation supported but not a class method?


---

Comment by mmarco created at 2013-06-08 10:00:31

Thanks for the comments. I will try to work on it.

As i said, the reason why it is not a method is that it is not clear to me what class should it be in. 

Is this a method of the expression F? Well, not exactly, since F is not the function that we are trying to differentiate, but the symbollic expression that deffines it implicitly.

Of X? This is just the variable with which we differentiate on.

Of Y? Riguorilously that should be the function that we are differentiating. But doesn't sound natural at all to add a method like this for symbollic variables.

Or maybe we could define a new class ImplicitelyDefinedSymbolicFunction for this case, bat that sounds way overkill.


---

Attachment

Newer version, solves the pynac registry pollution without manipulating it


---

Comment by mmarco created at 2013-06-08 16:04:31

Ok, your suggestions seemed to work fine. I have uploaded a newer version. Please check it.


---

Comment by mmarco created at 2013-06-10 11:23:04

Changing status from needs_work to needs_review.


---

Comment by mmarco created at 2014-08-22 14:48:43

bump


---

Comment by knsam created at 2014-08-23 12:10:27

Hi mmarco: 

Thanks for writing up a patch regarding something very fundamental to calculus. Sage has since v6.0 moved to Git for its revision control. As a consequence, we work with "branches" instead of "patches" and so on. Could you kindly make the patch here into a branch? 

I think this might be a bit painful depending on several factors. So, please feel free to ask for any help!


---

Comment by knsam created at 2014-08-23 12:10:47

Changing status from needs_review to needs_work.


---

Comment by knsam created at 2014-08-24 15:54:23

Changing status from needs_work to needs_review.


---

Comment by knsam created at 2014-08-24 15:54:23

New commits:


---

Comment by knsam created at 2014-08-24 16:05:38

For starters, I have the following comments: 

1. The one-line docstring for the function is "incorrect": it computes something, yes, but it also returns it. So, please change that to "Return <whatever>". 
2. The value error could return the expression `F` explicitly instead of saying the generic F. While you are it, please use the `.format` to format the string for the output instead.

Honestly, I have not looked at the math. I will get back about the math and the programming part in a bit.


---

Comment by git created at 2014-08-24 16:59:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2014-09-01 09:17:53

Replying to [comment:13 mmarco]:
> As i said, the reason why it is not a method is that it is not clear to me what class should it be in. 
> 
> Is this a method of the expression F? Well, not exactly, since F is not the function that we are trying to differentiate, but the symbollic expression that deffines it implicitly.
I think Burcin wants this method part of the symbolic expression or function class. If it's not tied to a specific expression then make it a ``@`classmethod` (equivalent to a static method in C), and then create the globally accessible name for it.


---

Comment by git created at 2014-09-02 17:29:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmarco created at 2014-09-02 17:32:15

Moved it to a method in the expression class.


---

Comment by rws created at 2015-02-02 14:23:09

Just some minor fixes. It looks good. I did no `make ptestlong` as it's just a new method.
----
New commits:


---

Comment by rws created at 2015-02-02 14:23:09

Changing status from needs_review to positive_review.


---

Comment by mmarco created at 2015-02-02 14:57:53

Thanks for the review.


---

Comment by mmezzarobba created at 2015-02-07 15:17:36


```
**********************************************************************
File "src/sage/misc/sageinspect.py", line 1815, in sage.misc.sageinspect.sage_getsourcelines
Failed example:
    sage_getsourcelines(x)[0][-1]    # last line
Expected:
    '        return self / x\n'
Got:
    '        return S\n'
**********************************************************************
```



---

Comment by mmezzarobba created at 2015-02-07 15:17:36

Changing status from positive_review to needs_work.


---

Comment by git created at 2015-02-08 07:14:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-02-08 07:17:24

Interesting. That doctest depends on the last line in `class Expression` to remain unchanged.


---

Comment by rws created at 2015-02-08 07:17:24

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2015-02-17 19:28:19

Resolution: fixed
