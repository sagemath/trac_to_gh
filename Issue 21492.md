# Issue 21492: Implement Didier Caucal's structural description of Cayley graphs

Issue created by migration from https://trac.sagemath.org/ticket/21729

Original creator: amri

Original creation time: 2016-10-19 13:39:36

CC:  jason boothby jmantysalo dimpase

Keywords: cayley graphs

In a recent preprint [https://arxiv.org/abs/1609.08272](https://arxiv.org/abs/1609.08272) titled _Structural characterization of Cayley graphs_, Didier Caucal has proved that a directed graph is Cayley if and only if it is strongly connected, simple, deterministic, and vertex transitive.

The present method for determining if a graph is Cayley in Sage involves looking for a free transitive subgroup of the automorphism group, which appears to be slower for directed graphs.


---

Comment by amri created at 2016-10-19 14:01:14

New commits:


---

Comment by amri created at 2016-10-19 15:05:40

It runs a little faster than the existing code, even though my implementation is probably far from optimized.

```
sage: G = groups.permutation.Mathieu(9)
sage: S = Set(G).subsets().random_element()
sage: gr = G.cayley_graph(generators=list(S))
sage: %timeit gr.is_cayley()
100 loops, best of 3: 14.5 ms per loop
sage: %timeit gr.is_cayley_directed()
100 loops, best of 3: 6.92 ms per loop

```



---

Comment by git created at 2016-10-27 12:18:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by amri created at 2016-10-27 12:33:48

Changing status from new to needs_review.


---

Comment by amri created at 2016-11-10 15:24:56

More speed testing (see noticable improvement):

```
sage: G = groups.permutation.DiCyclic(4)
sage: D = G.cayley_graph()
sage: %timeit D.is_cayley()
10 loops, best of 3: 6.82 ms per loop
sage: %timeit D.is_cayley_directed()
1000 loops, best of 3: 343 µs per loop
```


```
sage: G = groups.permutation.PGL(2,4)
sage: D = G.cayley_graph()
sage: %timeit D.is_cayley()
1 loop, best of 3: 96.8 ms per loop
sage: %timeit D.is_cayley_directed()
1000 loops, best of 3: 1.25 ms per loop
```

We try a random graph

```
sage: D = digraphs.RandomDirectedGN(20)
sage: %timeit D.is_cayley()
The slowest run took 6.25 times longer than the fastest. This could mean that an intermediate result is being cached.
10 loops, best of 3: 4.01 ms per loop
sage: %timeit D.is_cayley_directed()
The slowest run took 10.74 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.31 µs per loop
```



---

Comment by git created at 2016-11-10 15:47:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by amri created at 2016-11-10 15:50:54

New commits:


---

Comment by jmantysalo created at 2016-11-11 09:30:45

At least `seen_ends` is now unused.

This can be done in two lines,


```
seen = set()
not any(e[2] in seen or seen.add(e[2]) for v in self for e in self.outgoing_edge_iterator(v))
```


but your version might be easier to read.

I still hope that someone who has read the paper can review this.


---

Comment by dimpase created at 2016-11-11 11:02:34

I think the documentation should include a warning saying that the result has not been published in a refereed medium yet. While the author is certainly a respected researcher, it's in itself is not a guarantee for correctness.


---

Comment by dimpase created at 2016-11-11 11:24:59

I don't think it's correct to say that this is a faster algorithm to determine if the graph is Cayley. This is an algorithm to do this for a special class of edge-labelled (di)graphs. It's not clear at all that this method can be efficiently extended to the unlabelled case (and indeed nothing of this is claimed in the paper).

In the docstring 

```
+        A directed graph with labeled edges is Cayley if and only if it is
+        strongly connected, vertex transitive, simple and deterministic.
```

the main result of the paper is misstated; certainly not every labelling of edges can be considered. Certainly for each vertex each outedge on it must have a different label. And a directed labelled Cayley graph has more restrictions of labels---there must be exactly k different labels, for k the out-degree of the (di)graph.


---

Comment by amri created at 2016-11-11 12:18:57

In this setting, a Cayley graph *is* a directed graph with edges labeled by generators. Dima rightly points out that if the edge labeling is changed, then the algorithm will not recognize the graph as Cayley. I pointed this out in the documentation:

```
+        This method is sensitive to edge labels::
+
+            sage: g = DiGraph([(1, 2, 1), (2, 3, 1), (3, 1, 1), (2, 1, 1), (3, 2, 1), (1, 3, 1)])
+            sage: g.is_cayley()
+            True
+            sage: g.is_cayley_directed()
+            False
```

Do you think I should make it more prominent? And of course, it is for this reason that the algorithm runs so fast - it uses the additional information (edge labels) which the earlier (Sabidussi) algorithm does not take into account.


---

Comment by dimpase created at 2016-11-11 17:18:27

Replying to [comment:12 amri]:
> In this setting, a Cayley graph *is* a directed graph with edges labeled by generators. Dima rightly points out that if the edge labeling is changed, then the algorithm will not recognize the graph as Cayley. I pointed this out in the documentation:
> {{{
> +        This method is sensitive to edge labels::
> +
> +            sage: g = DiGraph([(1, 2, 1), (2, 3, 1), (3, 1, 1), (2, 1, 1), (3, 2, 1), (1, 3, 1)])
> +            sage: g.is_cayley()
> +            True
> +            sage: g.is_cayley_directed()
> +            False
> }}}
> Do you think I should make it more prominent? And of course, it is for this reason that the algorithm runs so fast - it uses the additional information (edge labels) which the earlier (Sabidussi) algorithm does not take into account.

The problem this ticket solve is the following: 

given a digraph D with edge labels 1,2,...,k, decide if there exists a group G generated by g_1,...,g_k so that D is the Cayley graph of G w.r.t. the generators g_1,...,g_k, right?

This is much more restrictive and much easier than recognising whether a digraph is a Cayley graph w.r.t. some group G with some set of generators.

In fact, it is straightforward to read the group off a Cayley graph with edge labels, and so I don't see why this is so interesting (it's good to have, but probably the punchline of the paper in question is somewhere else).
Indeed, if the arc (ij) is labelled by g this just means that the permutation g
maps i to j, and so you can reconstruct all the permutations, or get stuck at some point---the latter simply means that it's not a Cayley graph w.r.t. the set of generators corresponding to edge labels.


---

Comment by dcoudert created at 2016-11-11 17:22:19

As a complement on the discussion on sage-dev, you may consider method `G._scream_if_not_simple()` that raises an error if the graph is not simple (loops or multiple edges).
David.


---

Comment by amri created at 2016-11-15 03:57:45

Replying to [comment:14 dimpase]:

While I agree that it is easy to read off a group from its Cayley graph when the edges are labeled, I believe that recognizing the graph to be Cayley is less easy. You could, for example take the group with generators the out edges from some node, and then use as relations the cycle language of that node (which forms a subgroup). However, you would still need to check that the graph you have is the Cayley graph of this group you have constructed. This turns out to be equivalent to vertex-transitivity.

> Replying to [comment:12 amri]:
> > In this setting, a Cayley graph *is* a directed graph with edges labeled by generators. Dima rightly points out that if the edge labeling is changed, then the algorithm will not recognize the graph as Cayley. I pointed this out in the documentation:
> > {{{
> > +        This method is sensitive to edge labels::
> > +
> > +            sage: g = DiGraph([(1, 2, 1), (2, 3, 1), (3, 1, 1), (2, 1, 1), (3, 2, 1), (1, 3, 1)])
> > +            sage: g.is_cayley()
> > +            True
> > +            sage: g.is_cayley_directed()
> > +            False
> > }}}
> > Do you think I should make it more prominent? And of course, it is for this reason that the algorithm runs so fast - it uses the additional information (edge labels) which the earlier (Sabidussi) algorithm does not take into account.
> 
> The problem this ticket solve is the following: 
> 
> given a digraph D with edge labels 1,2,...,k, decide if there exists a group G generated by g_1,...,g_k so that D is the Cayley graph of G w.r.t. the generators g_1,...,g_k, right?
> 
> This is much more restrictive and much easier than recognising whether a digraph is a Cayley graph w.r.t. some group G with some set of generators.
> 
> In fact, it is straightforward to read the group off a Cayley graph with edge labels, and so I don't see why this is so interesting (it's good to have, but probably the punchline of the paper in question is somewhere else).
> Indeed, if the arc (ij) is labelled by g this just means that the permutation g
> maps i to j, and so you can reconstruct all the permutations, or get stuck at some point---the latter simply means that it's not a Cayley graph w.r.t. the set of generators corresponding to edge labels.
> 
> 
> 
>


---

Comment by amri created at 2016-11-15 03:58:42

Replying to [comment:15 dcoudert]:
> As a complement on the discussion on sage-dev, you may consider method `G._scream_if_not_simple()` that raises an error if the graph is not simple (loops or multiple edges).
> David.
I am not sure I understand how this works. Can you point me to a similar example?


---

Comment by dcoudert created at 2016-11-15 06:59:53

Replying to [comment:17 amri]:
> Replying to [comment:15 dcoudert]:
> > As a complement on the discussion on sage-dev, you may consider method `G._scream_if_not_simple()` that raises an error if the graph is not simple (loops or multiple edges).
> > David.
> I am not sure I understand how this works. Can you point me to a similar example?

```
sage: G = Graph([(0,1)])
sage: G._scream_if_not_simple()
sage: G = Graph([(0,1), (0,1)], multiedges=True)
sage: G._scream_if_not_simple()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-4-598886da2d1f> in <module>()
----> 1 G._scream_if_not_simple()

/Users/dcoudert/sage/local/lib/python2.7/site-packages/sage/graphs/generic_graph.pyc in _scream_if_not_simple(self, allow_loops, allow_multiple_edges)
   1295                    "meantime if you want to use it please disallow "+name+" using "+
   1296                    functions+".")
-> 1297             raise ValueError(msg)
   1298 
   1299     def networkx_graph(self, copy=True):

ValueError: This method is not known to work on graphs with multiedges. Perhaps this method can be updated to handle them, but in the meantime if you want to use it please disallow multiedges using allow_multiple_edges().
sage: try:
....:     G._scream_if_not_simple()
....:     print "I'm simple"
....: except:
....:     print "I'm not simple"
....:     
I'm not simple
```

you can also decide to tolerate loops but not multiedges or the opposite.

```
sage: G = Graph([(0,1), (0,1)], multiedges=True)
sage: G._scream_if_not_simple(allow_multiple_edges=True)
sage: G._scream_if_not_simple(allow_loops=True)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-8-45f9140e8d3e> in <module>()
----> 1 G._scream_if_not_simple(allow_loops=True)

/Users/dcoudert/sage/local/lib/python2.7/site-packages/sage/graphs/generic_graph.pyc in _scream_if_not_simple(self, allow_loops, allow_multiple_edges)
   1295                    "meantime if you want to use it please disallow "+name+" using "+
   1296                    functions+".")
-> 1297             raise ValueError(msg)
   1298 
   1299     def networkx_graph(self, copy=True):

ValueError: This method is not known to work on graphs with multiedges. Perhaps this method can be updated to handle them, but in the meantime if you want to use it please disallow multiedges using allow_multiple_edges().
```



---

Comment by dcoudert created at 2016-11-15 16:17:07

A few comments:
* In method `is_deterministic`, please use `self.vertex_iterator()` and `self.outgoing_edge_iterator(v)`. Also, `seen_ends = set()` but not used.
* the `EXAMPLES` section should show the interest for your new method, not `is_cayley` only.
* I think that references should now be placed in the global bibliography file. See #21454
* Add in method a SEEALSO section with :meth:`~sage.graphs.digraph.DiGraph.is_cayley_directed`
* What if the digraph has loops?


---

Comment by dimpase created at 2016-11-15 16:40:32

Replying to [comment:16 amri]:
> Replying to [comment:14 dimpase]:
> 
> While I agree that it is easy to read off a group from its Cayley graph when the edges are labeled, I believe that recognizing the graph to be Cayley is less easy. You could, for example take the group with generators the out edges from some node, and then use as relations the cycle language of that node (which forms a subgroup). However, you would still need to check that the graph you have is the Cayley graph of this group you have constructed. This turns out to be equivalent to vertex-transitivity.

Checking transitivity of a permutation group given by generators is quite easy and can be done very efficiently. 

What is however less obvious is how to check is that you get a group acting regularly (i.e. transitively and with trivial vertex stabiliser). And this is something I did not mention in my previous comment.

For this, the quickest way I know is to write down the Schreier generators for the point stabiliser and check that they are all trivial.
This seems to be possible to do in time O(nr), with n the number of vertices and r number of group generators.

Does the paper offer anything faster?


---

Comment by vdelecroix created at 2020-02-17 06:43:34

Changing status from needs_review to needs_info.


---

Comment by vdelecroix created at 2020-02-17 06:43:34

I agree with Dima, this characterization is certainly not new, and probably not the punchline of the article advertised in the description. For example, it corresponds to the characterization of Galois covers in algebraic topology (see e.g. the book of A. Hatcher).

Dima: following these steps it is enough to check for a **single** vertex stabilizer
- Test whether the graph `G` is connected and at each vertex there are exactly an input and an output edges of each label. If not return `False`.
- Build the permutation group `P` acting on the vertices of `G` that consists in "following the labels" (one generator per label). Note that the transitivity of `P` is equivalent to the connectivity of `G`.
- Pick a vertex `v0` of `G`. If the vertex stabilizer in `P` of `v0` is trivial then return `True` otherwise return `False`.

The reason that it works is that vertex stabilizers are conjugate (since the group `P` acts transitively on the vertices).

As pointed out by Dima, testing whether an **unlabelled graph** is Cayley is much more interesting. It is certainly doable starting from the automorphism group of the graph and analyzing the vertex stabilizer of a point.


---

Comment by dimpase created at 2020-02-17 08:24:09

Replying to [comment:21 vdelecroix]:

> As pointed out by Dima, testing whether an **unlabelled graph** is Cayley is much more interesting. It is certainly doable starting from the automorphism group of the graph and analyzing the vertex stabilizer of a point.

it's much harder than that: the full automorphism group can be bigger, so one needs to look up all the transitive subgroups (up to conjugation) and check whether one of them is regular.
