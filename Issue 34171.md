# Issue 34171: Speedup Conversion from integers to Gaussian Integers

archive/issues_034171.json:
```json
{
    "body": "CC:  @slel\n\nCurrently, when converting an integer to the Gaussian integers, a costly check is performed, whether the integer is actually an order element:\n\n\n```\nsage: G = GaussianIntegers()\nsage: %timeit G(2)\n141 \u00b5s \u00b1 423 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n```\n\n\nThe culprit seems to be the following check in `_element_constructor_` in `order.py`:\n\n\n```\n        if not embedding(x) in self._module_rep:\n            raise TypeError(\"Not an element of the order.\")\n```\n\n\nThis check is not necessary for integers which are contained in every order.\n\nRemoving this check speeds this up substantially (we should of course not remove this check but maybe only skip it for integers):\n\n\n```\nsage: G = GaussianIntegers()\nsage: %timeit G(2)\n1.8 \u00b5s \u00b1 24.8 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/34408\n\n",
    "created_at": "2022-08-22T09:42:45Z",
    "labels": [
        "number fields",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Speedup Conversion from integers to Gaussian Integers",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/34171",
    "user": "@saraedum"
}
```
CC:  @slel

Currently, when converting an integer to the Gaussian integers, a costly check is performed, whether the integer is actually an order element:


```
sage: G = GaussianIntegers()
sage: %timeit G(2)
141 µs ± 423 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
```


The culprit seems to be the following check in `_element_constructor_` in `order.py`:


```
        if not embedding(x) in self._module_rep:
            raise TypeError("Not an element of the order.")
```


This check is not necessary for integers which are contained in every order.

Removing this check speeds this up substantially (we should of course not remove this check but maybe only skip it for integers):


```
sage: G = GaussianIntegers()
sage: %timeit G(2)
1.8 µs ± 24.8 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)
```


Issue created by migration from https://trac.sagemath.org/ticket/34408





---

archive/issue_comments_484855.json:
```json
{
    "body": "The check for containment of a Gaussian integers in the integers also seems to be slow, see #9540.",
    "created_at": "2022-08-22T09:43:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34171#issuecomment-484855",
    "user": "@saraedum"
}
```

The check for containment of a Gaussian integers in the integers also seems to be slow, see #9540.



---

archive/issue_comments_484856.json:
```json
{
    "body": "We could imagine three ways to fix this:\n\n- Add a `check=True` argument to be able to skip this check (however, this only fixes the slowness for the experts who know about this flag.)\n- Explicitly skip this check for integers.\n- Define a coercion map from the integers that uses a faster path.",
    "created_at": "2022-08-22T09:46:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34171#issuecomment-484856",
    "user": "@saraedum"
}
```

We could imagine three ways to fix this:

- Add a `check=True` argument to be able to skip this check (however, this only fixes the slowness for the experts who know about this flag.)
- Explicitly skip this check for integers.
- Define a coercion map from the integers that uses a faster path.



---

archive/issue_comments_484857.json:
```json
{
    "body": "The absolute fastest will be (3), which can be applied at the level of `Order` (perhaps just `absolute`?). However, with only one indirection, you could simply add a check to the `_element_constructor_` for the special case when the input is in `ZZ` (or its parent is `ZZ`). While this would then be applied to all elements, it would mean there is no difference in performance between `G(2)` and `G(4/2)`. This would not be the case for doing a custom coercion map.",
    "created_at": "2022-08-22T10:00:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34171",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34171#issuecomment-484857",
    "user": "@tscrim"
}
```

The absolute fastest will be (3), which can be applied at the level of `Order` (perhaps just `absolute`?). However, with only one indirection, you could simply add a check to the `_element_constructor_` for the special case when the input is in `ZZ` (or its parent is `ZZ`). While this would then be applied to all elements, it would mean there is no difference in performance between `G(2)` and `G(4/2)`. This would not be the case for doing a custom coercion map.
