# Issue 29849: Faster maxima_lib

archive/issues_029849.json:
```json
{
    "body": "CC:  egourgoulhon tscrim nbruin dimpase @spaghettisalat\n\n(from #30061)\n\nSymbolics going through maxima_lib can be made a bit faster by adding a few more methods that can be implemented faster. \n\nFor example, the maxima-specific part of the implementation of `sage.symbolic.assumptions` can be folded into the maxima interface.\nThen the maxima_lib implementation of the interface could use ECL objects for handling contexts instead of going through interface objects for this. This would remove the overhead seen in  #30061#comment:33\n\nAnother direction (on the branch already) is to add a simpler version of `.eval` that only handles a single statement and does not  create an interface object.\n\nIssue created by migration from https://trac.sagemath.org/ticket/30086\n\n",
    "created_at": "2020-07-07T18:26:38Z",
    "labels": [
        "interfaces",
        "minor",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Faster maxima_lib",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/29849",
    "user": "mkoeppe"
}
```
CC:  egourgoulhon tscrim nbruin dimpase @spaghettisalat

(from #30061)

Symbolics going through maxima_lib can be made a bit faster by adding a few more methods that can be implemented faster. 

For example, the maxima-specific part of the implementation of `sage.symbolic.assumptions` can be folded into the maxima interface.
Then the maxima_lib implementation of the interface could use ECL objects for handling contexts instead of going through interface objects for this. This would remove the overhead seen in  #30061#comment:33

Another direction (on the branch already) is to add a simpler version of `.eval` that only handles a single statement and does not  create an interface object.

Issue created by migration from https://trac.sagemath.org/ticket/30086





---

archive/issue_comments_423984.json:
```json
{
    "body": "New commits:",
    "created_at": "2020-07-07T22:12:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29849#issuecomment-423984",
    "user": "mkoeppe"
}
```

New commits:



---

archive/issue_comments_423985.json:
```json
{
    "body": "perhaps the Lisp code in src/sage/interfaces/maxima_lib.py may be  taken out and compiled, and src/sage/interfaces/maxima_lib.py cythonised and made to use the compiled Lisp functions.",
    "created_at": "2020-07-08T08:36:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29849#issuecomment-423985",
    "user": "dimpase"
}
```

perhaps the Lisp code in src/sage/interfaces/maxima_lib.py may be  taken out and compiled, and src/sage/interfaces/maxima_lib.py cythonised and made to use the compiled Lisp functions.



---

archive/issue_comments_423986.json:
```json
{
    "body": "You can test whether compiling MAXIMA-EVAL makes a difference with this patch. For #30074 it did not make a difference.\n\n\n```diff\ndiff --git a/src/sage/interfaces/maxima_lib.py b/src/sage/interfaces/maxima_lib.py\nindex 75826f679f..bb380b91dc 100644\n--- a/src/sage/interfaces/maxima_lib.py\n+++ b/src/sage/interfaces/maxima_lib.py\n@@ -188,6 +188,7 @@ for l in init_code:\n ## This is the main function (ECL object) used for evaluation\n # This returns an EclObject\n maxima_eval=ecl_eval(\"\"\"\n+(prog1\n (defun maxima-eval( form )\n     (let ((result (catch 'macsyma-quit (cons 'maxima_eval (meval form)))))\n         ;(princ (list \"result=\" result))\n@@ -217,6 +218,8 @@ maxima_eval=ecl_eval(\"\"\"\n         )\n     )\n )\n+(ignore-errors (compile 'maxima-eval))\n+)\n \"\"\")\n \n ## Number of instances of this interface\n```\n",
    "created_at": "2020-07-08T17:21:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29849#issuecomment-423986",
    "user": "mkoeppe"
}
```

You can test whether compiling MAXIMA-EVAL makes a difference with this patch. For #30074 it did not make a difference.


```diff
diff --git a/src/sage/interfaces/maxima_lib.py b/src/sage/interfaces/maxima_lib.py
index 75826f679f..bb380b91dc 100644
--- a/src/sage/interfaces/maxima_lib.py
+++ b/src/sage/interfaces/maxima_lib.py
@@ -188,6 +188,7 @@ for l in init_code:
 ## This is the main function (ECL object) used for evaluation
 # This returns an EclObject
 maxima_eval=ecl_eval("""
+(prog1
 (defun maxima-eval( form )
     (let ((result (catch 'macsyma-quit (cons 'maxima_eval (meval form)))))
         ;(princ (list "result=" result))
@@ -217,6 +218,8 @@ maxima_eval=ecl_eval("""
         )
     )
 )
+(ignore-errors (compile 'maxima-eval))
+)
 """)
 
 ## Number of instances of this interface
```




---

archive/issue_comments_423987.json:
```json
{
    "body": "Replying to [comment:5 mkoeppe]:\n> You can test whether compiling MAXIMA-EVAL makes a difference with this patch. For #30074 it did not make a difference.\n> \n> {{{#!diff\n> diff --git a/src/sage/interfaces/maxima_lib.py b/src/sage/interfaces/maxima_lib.py\n> index 75826f679f..bb380b91dc 100644\n> --- a/src/sage/interfaces/maxima_lib.py\n> +++ b/src/sage/interfaces/maxima_lib.py\n> `@``@` -188,6 +188,7 `@``@` for l in init_code:\n>  ## This is the main function (ECL object) used for evaluation\n>  # This returns an EclObject\n>  maxima_eval=ecl_eval(\"\"\"\n> +(prog1\n>  (defun maxima-eval( form )\n>      (let ((result (catch 'macsyma-quit (cons 'maxima_eval (meval form)))))\n>          ;(princ (list \"result=\" result))\n> `@``@` -217,6 +218,8 `@``@` maxima_eval=ecl_eval(\"\"\"\n>          )\n>      )\n>  )\n> +(ignore-errors (compile 'maxima-eval))\n> +)\n>  \"\"\")\n>  \n>  ## Number of instances of this interface\n> }}}\n\nI am not sure if this is the right kind of `compile`. ECL manual only mentions `compile-file` etc. Probably `compile` just expands macros.\n\nI cc'd Marius, the ECL expert.",
    "created_at": "2020-07-08T19:27:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29849#issuecomment-423987",
    "user": "dimpase"
}
```

Replying to [comment:5 mkoeppe]:
> You can test whether compiling MAXIMA-EVAL makes a difference with this patch. For #30074 it did not make a difference.
> 
> {{{#!diff
> diff --git a/src/sage/interfaces/maxima_lib.py b/src/sage/interfaces/maxima_lib.py
> index 75826f679f..bb380b91dc 100644
> --- a/src/sage/interfaces/maxima_lib.py
> +++ b/src/sage/interfaces/maxima_lib.py
> `@``@` -188,6 +188,7 `@``@` for l in init_code:
>  ## This is the main function (ECL object) used for evaluation
>  # This returns an EclObject
>  maxima_eval=ecl_eval("""
> +(prog1
>  (defun maxima-eval( form )
>      (let ((result (catch 'macsyma-quit (cons 'maxima_eval (meval form)))))
>          ;(princ (list "result=" result))
> `@``@` -217,6 +218,8 `@``@` maxima_eval=ecl_eval("""
>          )
>      )
>  )
> +(ignore-errors (compile 'maxima-eval))
> +)
>  """)
>  
>  ## Number of instances of this interface
> }}}

I am not sure if this is the right kind of `compile`. ECL manual only mentions `compile-file` etc. Probably `compile` just expands macros.

I cc'd Marius, the ECL expert.



---

archive/issue_comments_423988.json:
```json
{
    "body": "You can check that running compile changes the function from byte-compiled to compiled.\nThis is a standard common lisp function.",
    "created_at": "2020-07-09T15:35:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29849#issuecomment-423988",
    "user": "mkoeppe"
}
```

You can check that running compile changes the function from byte-compiled to compiled.
This is a standard common lisp function.



---

archive/issue_comments_423989.json:
```json
{
    "body": "For your reference: http://clhs.lisp.se/Body/f_cmp.htm#compile",
    "created_at": "2020-07-09T15:38:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29849#issuecomment-423989",
    "user": "mkoeppe"
}
```

For your reference: http://clhs.lisp.se/Body/f_cmp.htm#compile



---

archive/issue_comments_423990.json:
```json
{
    "body": "it actually makes the example with L=...\nto run about 5-10% slower. Does not strike me as efficient.",
    "created_at": "2020-07-09T15:57:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29849#issuecomment-423990",
    "user": "dimpase"
}
```

it actually makes the example with L=...
to run about 5-10% slower. Does not strike me as efficient.



---

archive/issue_comments_423991.json:
```json
{
    "body": "Replying to [comment:6 dimpase]:\n> I am not sure if this is the right kind of `compile`. ECL manual only mentions `compile-file` etc. Probably `compile` just expands macros.\n\nNo, that's full-on compile, which in ECL means: generate C code, run it through a C compiler, and dynamically link the generated object. The normal \"interpreter\" in fact is a byte code compiler.\n\nI suspect that the gains to be had by compiling interfacing code are rather limited. I haven't profiled it, but I suspect that the context switching in terms of changing signal handlers (and FP exception settings?) is dwarfing most of that. Unfortunately, ECL and Python are both designed with the expectation that they're \"top level\" in terms of the things they control (even though both can technically be embedded), so they make a lot of demands on how process-wide settings are configured. Those demands are incompatible in several places, so we end up making expensive switches.\nYou might want to time how much the `ecl_sig_on` and `ecl_sig_off` calls in `ecl.pyx` are costing. I don't think we can get around those.",
    "created_at": "2020-07-09T17:31:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29849#issuecomment-423991",
    "user": "nbruin"
}
```

Replying to [comment:6 dimpase]:
> I am not sure if this is the right kind of `compile`. ECL manual only mentions `compile-file` etc. Probably `compile` just expands macros.

No, that's full-on compile, which in ECL means: generate C code, run it through a C compiler, and dynamically link the generated object. The normal "interpreter" in fact is a byte code compiler.

I suspect that the gains to be had by compiling interfacing code are rather limited. I haven't profiled it, but I suspect that the context switching in terms of changing signal handlers (and FP exception settings?) is dwarfing most of that. Unfortunately, ECL and Python are both designed with the expectation that they're "top level" in terms of the things they control (even though both can technically be embedded), so they make a lot of demands on how process-wide settings are configured. Those demands are incompatible in several places, so we end up making expensive switches.
You might want to time how much the `ecl_sig_on` and `ecl_sig_off` calls in `ecl.pyx` are costing. I don't think we can get around those.



---

archive/issue_comments_423992.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29849#issuecomment-423992",
    "user": "mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
