# Issue 29849: Faster maxima_lib

Issue created by migration from https://trac.sagemath.org/ticket/30086

Original creator: mkoeppe

Original creation time: 2020-07-07 18:26:38

CC:  egourgoulhon tscrim nbruin dimpase @spaghettisalat

(from #30061)

Symbolics going through maxima_lib can be made a bit faster by adding a few more methods that can be implemented faster. 

For example, the maxima-specific part of the implementation of `sage.symbolic.assumptions` can be folded into the maxima interface.
Then the maxima_lib implementation of the interface could use ECL objects for handling contexts instead of going through interface objects for this. This would remove the overhead seen in  #30061#comment:33

Another direction (on the branch already) is to add a simpler version of `.eval` that only handles a single statement and does not  create an interface object.


---

Comment by mkoeppe created at 2020-07-07 22:12:45

New commits:


---

Comment by dimpase created at 2020-07-08 08:36:31

perhaps the Lisp code in src/sage/interfaces/maxima_lib.py may be  taken out and compiled, and src/sage/interfaces/maxima_lib.py cythonised and made to use the compiled Lisp functions.


---

Comment by mkoeppe created at 2020-07-08 17:21:51

You can test whether compiling MAXIMA-EVAL makes a difference with this patch. For #30074 it did not make a difference.


```diff
diff --git a/src/sage/interfaces/maxima_lib.py b/src/sage/interfaces/maxima_lib.py
index 75826f679f..bb380b91dc 100644
--- a/src/sage/interfaces/maxima_lib.py
+++ b/src/sage/interfaces/maxima_lib.py
@@ -188,6 +188,7 @@ for l in init_code:
 ## This is the main function (ECL object) used for evaluation
 # This returns an EclObject
 maxima_eval=ecl_eval("""
+(prog1
 (defun maxima-eval( form )
     (let ((result (catch 'macsyma-quit (cons 'maxima_eval (meval form)))))
         ;(princ (list "result=" result))
@@ -217,6 +218,8 @@ maxima_eval=ecl_eval("""
         )
     )
 )
+(ignore-errors (compile 'maxima-eval))
+)
 """)
 
 ## Number of instances of this interface
```



---

Comment by dimpase created at 2020-07-08 19:27:18

Replying to [comment:5 mkoeppe]:
> You can test whether compiling MAXIMA-EVAL makes a difference with this patch. For #30074 it did not make a difference.
> 
> {{{#!diff
> diff --git a/src/sage/interfaces/maxima_lib.py b/src/sage/interfaces/maxima_lib.py
> index 75826f679f..bb380b91dc 100644
> --- a/src/sage/interfaces/maxima_lib.py
> +++ b/src/sage/interfaces/maxima_lib.py
> `@``@` -188,6 +188,7 `@``@` for l in init_code:
>  ## This is the main function (ECL object) used for evaluation
>  # This returns an EclObject
>  maxima_eval=ecl_eval("""
> +(prog1
>  (defun maxima-eval( form )
>      (let ((result (catch 'macsyma-quit (cons 'maxima_eval (meval form)))))
>          ;(princ (list "result=" result))
> `@``@` -217,6 +218,8 `@``@` maxima_eval=ecl_eval("""
>          )
>      )
>  )
> +(ignore-errors (compile 'maxima-eval))
> +)
>  """)
>  
>  ## Number of instances of this interface
> }}}

I am not sure if this is the right kind of `compile`. ECL manual only mentions `compile-file` etc. Probably `compile` just expands macros.

I cc'd Marius, the ECL expert.


---

Comment by mkoeppe created at 2020-07-09 15:35:48

You can check that running compile changes the function from byte-compiled to compiled.
This is a standard common lisp function.


---

Comment by mkoeppe created at 2020-07-09 15:38:09

For your reference: http://clhs.lisp.se/Body/f_cmp.htm#compile


---

Comment by dimpase created at 2020-07-09 15:57:03

it actually makes the example with L=...
to run about 5-10% slower. Does not strike me as efficient.


---

Comment by nbruin created at 2020-07-09 17:31:52

Replying to [comment:6 dimpase]:
> I am not sure if this is the right kind of `compile`. ECL manual only mentions `compile-file` etc. Probably `compile` just expands macros.

No, that's full-on compile, which in ECL means: generate C code, run it through a C compiler, and dynamically link the generated object. The normal "interpreter" in fact is a byte code compiler.

I suspect that the gains to be had by compiling interfacing code are rather limited. I haven't profiled it, but I suspect that the context switching in terms of changing signal handlers (and FP exception settings?) is dwarfing most of that. Unfortunately, ECL and Python are both designed with the expectation that they're "top level" in terms of the things they control (even though both can technically be embedded), so they make a lot of demands on how process-wide settings are configured. Those demands are incompatible in several places, so we end up making expensive switches.
You might want to time how much the `ecl_sig_on` and `ecl_sig_off` calls in `ecl.pyx` are costing. I don't think we can get around those.


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
