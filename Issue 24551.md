# Issue 24551: Multiplication of the Gram Matrix

Issue created by migration from Trac.

Original creator: pmenegat

Original creation time: 2018-02-20 13:12:57

Let `L` an integer quadratic lattice and `M` its Gram matrix. For a non-zero integer `d` we could define `L(d)` as the lattice with matrix of intersection `dM`.
If `d=1` it creates just a new lattice with a standard basis.


---

Comment by sbrandhorst created at 2018-02-21 16:47:31

The basis should be preserved. -> Just the ambient module/vector space changes.
I would suggest a different name. 
How about `scale` ? 
----
New commits:


---

Comment by pmenegat created at 2018-02-21 18:31:41

I agree with the change of name. 
Preserving the basis is complicated if you have a sublattice, and I don't see the utility of that. At the contrary, I've used it specifically in order to obtain new lattices with a standard basis, with `L.mul(1)`


---

Comment by sbrandhorst created at 2018-02-22 05:28:32

So here are some reasons why the basis should be preserved:

Say, I have lattice `L` and computed a lot of data, for example sublattices, the automorphism group, something in the discriminant form etc..
All of this is represented with respect to the coordinates of the ambient module / or the basis. If we change that, it is hard to transfer information from a lattice to its scaled counterpart. But if the bases are equal - it is very easy.

The code is just a few lines:

```
def scale(self, s):
    n = self.degree()
    inner_product_matrix = s * self.inner_product_matrix()
    ambient = FreeQuadraticModule(self.base_ring(), n, inner_product_matrix)
    return FreeQuadraticModule_integer_symmetric(ambient=ambient, basis=self.basis(), inner_product_matrix=inner_product_matrix)
```



---

Comment by pmenegat created at 2018-02-22 09:23:24

I still think that there are more practical situations where you need a lattice with a new standard basis. Maybe we could put it as an option?

```
def scale(self, s, new_basis=true):
    if (new_basis):
        return IntegralLattice(s*self.gram_matrix()) 
    else:
        n = self.degree()
        inner_product_matrix = s * self.inner_product_matrix()
        ambient = FreeQuadraticModule(self.base_ring(), n, inner_product_matrix)
        return FreeQuadraticModule_integer_symmetric(ambient=ambient, basis=self.basis(), inner_product_matrix=inner_product_matrix)

```



---

Comment by sbrandhorst created at 2018-02-22 09:43:15

I am fine with an option. Though I believe that the default should be to keep the basis and only forget it at request.
How about calling the optional argument `discard_basis` ? new_basis sounds like one should input a basis and not a boolean.


---

Comment by pmenegat created at 2018-02-22 10:52:07

Ok


---

Comment by git created at 2018-02-23 09:35:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pmenegat created at 2018-02-23 09:37:15

Changing status from new to needs_review.


---

Comment by sbrandhorst created at 2018-02-23 14:05:56

Positive review if you are happy with my changes.
----
New commits:


---

Comment by pmenegat created at 2018-02-23 14:58:39

It seems good, but now I'm asking if we should allow scaling by rationals


---

Comment by sbrandhorst created at 2018-02-24 21:32:55

For me scaling by integers is good enough. Else we have to check the scale of the lattice. But one could think about that: scale and norm.


---

Comment by pmenegat created at 2018-02-25 10:45:43

And something like this?


```
if (s==0):
    raise ValueError("the scale factor must be non zero")
if (discard_basis):
    try:
        inner_product_matrix = matrix(self.base_ring(),s*self.gram_matrix())
    except:
        ValueError("the scaled gram matrix must be a matrix on the base ring.")
    return IntegralLattice(inner_product_matrix)
else:
    try:
        inner_product_matrix = matrix(self.base_ring(),s*self.inner_product_matrix())
    except:
        ValueError("the scaled inner product matrix must be a matrix on the base ring.")
    n = self.degree()
    ambient = FreeQuadraticModule(self.base_ring(), n, inner_product_matrix)
    return FreeQuadraticModule_integer_symmetric(ambient=ambient, basis=self.basis(), inner_product_matrix=inner_product_matrix)


---

Comment by sbrandhorst created at 2018-02-25 13:12:54

In fact the gram matrix must be integral - not the inner product matrix. So I guess I would opt against rational scaling - it is not as natural as integer scaling.
Btw. there still seems to be a problem with the documentation - the patchbot failed.


---

Comment by git created at 2018-02-27 08:25:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-02-27 08:26:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by sbrandhorst created at 2018-02-27 08:28:58

Doc builds on my computer. If you're o.k. and we have a green bot then positive review.


---

Comment by pmenegat created at 2018-02-27 08:51:13

Changing status from needs_review to positive_review.


---

Comment by sbrandhorst created at 2018-02-27 10:51:38

I just noticed that there is a scale function (=scale the basis) for free modules already. And we are changing its meaning. I guess it is better to stay consistent. 
How about twist? Then we can also allow a matrix as input. I think that could be very useful.


---

Comment by sbrandhorst created at 2018-02-27 10:51:38

Changing status from positive_review to needs_work.


---

Comment by pmenegat created at 2018-02-27 12:34:32

Twist is even a better name than scale. 
Actually what we do is as a tensor product between lattices, where the integer 'd' represents the lattice <d>. Maybe what we can do is allowing it in general.


---

Comment by sbrandhorst created at 2018-02-27 12:39:42

So you are suggesting to implement a tensor_product() method?


---

Comment by pmenegat created at 2018-02-27 12:46:59

Yes, we can left "twist" as name.
Something like:

Inner_product_matrix = self.inner_product_matrix().tensor_product(other.inner_product_matrix())

basis_matrix = self.basis_matrix().tensor_product(other.basis_matrix())


---

Comment by git created at 2018-03-20 10:37:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by sbrandhorst created at 2018-03-20 10:38:56

Changing status from needs_work to needs_review.


---

Comment by sbrandhorst created at 2018-03-20 10:38:56

Positive review if you are happy with my changes.


---

Comment by pmenegat created at 2018-03-27 13:56:08

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-05-08 17:26:15

Resolution: fixed
