# Issue 20050: Implement the Mooreâ€“Penrose pseudoinverse

Issue created by migration from https://trac.sagemath.org/ticket/20287

Original creator: jdemeyer

Original creation time: 2016-03-25 11:02:18




---

Comment by git created at 2016-03-25 13:20:18

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2016-03-25 13:23:09

Changing status from new to needs_review.


---

Comment by chapoton created at 2016-03-27 17:41:20

failing doctests, see bot report


---

Comment by chapoton created at 2016-03-27 17:41:20

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2016-03-28 09:19:54

A line number in the doc changed from less than 1000 to more than 1000 causing a 1-character shift.


---

Comment by git created at 2016-03-28 09:21:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2016-03-28 09:24:14

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2016-03-28 18:23:58

ok, looks good to me


---

Comment by chapoton created at 2016-03-28 18:23:58

Changing status from needs_review to positive_review.


---

Comment by mjo created at 2016-03-28 21:07:59

Late to the party: is there any case where the inferred algorithm would not do the right thing, and the user would have to specify one?


---

Comment by jdemeyer created at 2016-03-29 06:19:54

Replying to [comment:11 mjo]:
> Late to the party: is there any case where the inferred algorithm would not do the right thing, and the user would have to specify one?

I don't think that there are cases where the is a better choice than the default one. However, there might be cases where there is no suitable algorithm at all.


---

Comment by git created at 2016-03-29 07:30:22

Changing status from positive_review to needs_review.


---

Comment by git created at 2016-03-29 07:30:22

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by jdemeyer created at 2016-03-29 07:32:30

I had to mark one test as `random` due to numerical noise.


---

Comment by jdemeyer created at 2016-03-29 07:32:30

Changing status from needs_review to positive_review.


---

Comment by mjo created at 2016-03-29 12:56:00

Replying to [comment:12 jdemeyer]:
> 
> I don't think that there are cases where the is a better choice than the default one. However, there might be cases where there is no suitable algorithm at all.

Then why offer the choice? I ask because, if you remove the `algorithm` parameter, it looks like a matrix superclass method is trying to figure out what to do by a "what subclass am I" heuristic. In that case, if the matrix class hierarchy is good enough, it might make more sense to move the subclass-specific behavior into subclass methods.

For example, the default `Matrix` would implement the "exact" or "exactconj" algorithms. (Is there a situation where "exactconj" does the wrong thing on a real matrix?) In `Matrix_real_double_dense` and `Matrix_complex_double_dense`, you would call numpy. In `Matrix_generic_dense`, you would do the precision check and either call numpy or raise an error. Et cetera. On the other hand, if the matrix hierarchy would make you copy/paste the same implementation around, forget I said anything.

Later on if we get an SVD that works for RR/CC, we can just add it to override the naive algorithm in those subclasses. With `algorithm` in the function signature, we have to worry about breaking the user interface with those changes.


---

Comment by jdemeyer created at 2016-03-29 13:16:56

Replying to [comment:15 mjo]:
> Then why offer the choice?
General principle: because I see no reason to _not_ offer the choice. If a choice is available, why not allow the user to override that choice? Of course, offer a good default.

More specifically: it might be hard to guess between `exact` and `exactconj`.

> I ask because, if you remove the `algorithm` parameter, it looks like a matrix superclass method is trying to figure out what to do by a "what subclass am I" heuristic.
I disagree completely. This has nothing to do with the `type()` of the matrix, but with the mathematical properties of the parent.

With your proposal, `pseudoinverse()` would no longer work for matrices over `RR` or `CC` or for sparse matrices.


---

Comment by mjo created at 2016-03-29 13:31:59

Replying to [comment:16 jdemeyer]:
> General principle: because I see no reason to _not_ offer the choice. If a choice is available, why not allow the user to override that choice? Of course, offer a good default.

I generally agree, but I wanted to be sure that the choice we're giving the user isn't `do_it_wrong=True`. If the default always does the right thing, and one of the other algorithms might not, then it's just noise in the docstring. And we'd have to go through a deprecation cycle to change it in the future.

> I disagree completely. This has nothing to do with the `type()` of the matrix, but with the mathematical properties of the parent.

Fair enough, but the resulting type of the matrix is determined by the ring that you pass in (and whether or not it's sparse).

> With your proposal, `pseudoinverse()` would no longer work for matrices over `RR` or `CC` or for sparse matrices.

You would at least get the exact(conj) implementation in every case. But you would have to override that in every subclass where it makes sense, like the generic_dense ones for RR/CC. If that's difficult or results in code duplication, then it's fine as-is. I just brought it up in case you hadn't considered it.


---

Comment by vbraun created at 2016-03-30 14:05:45

Resolution: fixed
