# Issue 26532: Add an issequence utility to check for list, tuple, and other compatible objects

Issue created by migration from https://trac.sagemath.org/ticket/26769

Original creator: embray

Original creation time: 2018-11-26 15:09:10

CC:  chapoton jdemeyer tscrim

Keywords: python3

Adds an `issequence()` function that can work as a more generic replacement for `isinstance(x, (list, tuple))` but will also work with a broader range of similar types (e.g. `xrange`, Sage vectors, Numpy arrays, etc).  Note `issequence(x)` is also True for `str` and `bytes`.  So when using this to replace `(list, tuple)` care should be taken to make sure other sequence-like types are handled first, in cases where they require separate handling in the first place.

For the very common case of `(list, tuple)` this is faster than `isinstance`, but also has the benefit of being more generic, while not _quite_ as generic as the much slower `isinstance(x, Sequence)`.


---

Comment by embray created at 2018-11-26 15:26:48

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2018-11-26 16:48:57

1. What's the difference between this and `isinstance(x, Sequence)`? I feel like that should be explained better.

2. There is no point in adding an empty `.pyx` file (unless I'm missing something)


---

Comment by jdemeyer created at 2018-11-26 17:01:33

3. Is it possible for a subclass of `list`/`tuple` not to be a sequence? Just asking because you use `FOO_CheckExact` as opposed to `FOO_Check`.


---

Comment by embray created at 2018-11-27 12:43:25

Replying to [comment:2 jdemeyer]:
> 1. What's the difference between this and `isinstance(x, Sequence)`? I feel like that should be explained better.

These are technically completely different things.  The C-API level "sequence protocol" is defined by implementing some or all of the [PySequenceMethods](https://docs.python.org/2/c-api/typeobj.html#c.PySequenceMethods) (the way `PySequence_Check` is implemented all it cares about is that `sq_item` by implemented at a minimum).

This is different from the Python level `collections.abc` "Sequence" ABC which requires that both `__getitem__` and `__len__` are implemented.

This inconsistent overloading of terms is irritating and confusing, but it is what it is.  So this interface defines my own sort of middle-ground which is closer to the ABC in that it requires both the C-level sequence interface (which Python classes that implement `__getitem__` have), but also that `PySequence_Length` works and returns a non-negative integer.  There is an assumption then that `obj[n]` will work for `[0:len(obj)]`.  Unfortunately, for types defined at the Python level there is no obvious way to explicitly distinguish between a "sequence" and a "mapping".

A class that implements a custom `__getitem__` may work as one or the other, or both, so the best we can do is check for `__getitem__` and `__len__` and hope it works "like a list", which is how I'm defining "sequence" in this case.

We special case tuple and list here since they are going to be quite common and are known to be the two most fundamental sequence types built into Python (as opposed to dict, which is not considered a sequence).

> 2. There is no point in adding an empty `.pyx` file (unless I'm missing something)

If you don't have the .pyx file Cython won't actually generate a Python module that can be used by Python.  You can still `cimport` cpdef functions defined in a .pxd file from other Cython code, but you can't use it in Python :/


---

Comment by embray created at 2018-11-27 12:53:24

Replying to [comment:3 jdemeyer]:
> 3. Is it possible for a subclass of `list`/`tuple` not to be a sequence? Just asking because you use `FOO_CheckExact` as opposed to `FOO_Check`.

From the C API perspective a subclass will still technically be a sequence, but there's no guarantee that it isn't broken in some way, and it's still necessary in those cases to go through the slower but more generic `PySequence_ITEM` calls, as opposed to `PyList_GET_ITEM` when accessing items, for example.

Likewise in `issequence`, for subclasses it's kind of necessary to go through the slightly slower path of calling `PySequence_Length`, and you only add overhead to the more common "exact" case, while gaining nothing.


---

Comment by embray created at 2018-11-27 13:36:00

It would be better if Python had, say, a `__getindex__` and related magic methods that could explicitly distinguish a type as a sequence as opposed to a more general mapping.  Perhaps I will propose that...


---

Comment by embray created at 2018-11-27 13:48:05

Replying to [comment:2 jdemeyer]:
> 1. What's the difference between this and `isinstance(x, Sequence)`? I feel like that should be explained better.

Now that I've had lunch, let me give a slightly clearer answer to this: This is effectively the same as `isinstance(x, Sequence)`, but it is much faster, both in the positive and negative cases, in that it bypasses all of the slow `isinstance` machinery entirely and does not result in calls to `Sequence.__subclasshook__` for types that do not obviously already implement the Sequence protocol.

The only case where it can be a slightly slow is for the cases where it has to call `PySequence_Length`, but that itself is only slow on classes that already implement `__getitem__` and `__len__`.


---

Comment by chapoton created at 2018-12-07 19:33:02

What about point 2 in comment:2 ?

EDIT: OK, I missed that you answered that already.

Can we move on ? I hope that Jeroen can finish the review.


---

Comment by embray created at 2018-12-10 13:07:39

One other comment worth adding about this, is that it needs to be used _carefully_.  Almost any custom class in Python (except those explicitly inheriting from `dict`, I believe) that implements a `__getitem__` can be interpreted by Python as a "sequence" type.  Per my note in comment:7, I think this is a fundamental shortcoming in Python though, and something we just have to deal with on some level...


---

Comment by embray created at 2018-12-28 14:10:15

Retargeting some of my tickets (somewhat optimistically for now).


---

Comment by jdemeyer created at 2019-01-29 12:11:31

Replying to [ticket:26769 embray]:
> Adds an `issequence()` function that can work as a more generic replacement for `isinstance(x, (list, tuple))`

I'm not really convinced that this `issequence(x)` is the correct replacement for `isinstance(x, (list, tuple))`. In the majority of cases, you probably want to be more general and accept any iterable. In the example #24804 that you refer to, you only iterate over the object so why restrict to sequences?

And the way: I also agree that the mapping vs sequence thing is annoying.


---

Comment by embray created at 2019-01-29 16:53:58

This is specifically intended for cases where the iterable is treated sequentially: That is, it is assumed that it can be indexed with monotonically increasing integer indices.   There are many cases like this where you do _not_ want to be more general and do not want to accept an arbitrary iterable, at least, without eagerly consuming the iterable in order to convert it to a sequence (e.g. `list(iterable)`) which is obviously wasteful if you already have a sequence-like object.


---

Comment by embray created at 2019-01-29 16:55:04

For example, there are many cases where you have `isinstance(x, (list tuple))` where it should also be able to accept something like a vector or a matrix, and just arbitrarily doesn't because of this less general check.


---

Comment by embray created at 2019-03-25 10:43:18

Moving all my in-progress tickets to 8.8 milestone.


---

Comment by embray created at 2019-04-08 16:10:01

Replying to [comment:12 jdemeyer]:
> Replying to [ticket:26769 embray]:
> > Adds an `issequence()` function that can work as a more generic replacement for `isinstance(x, (list, tuple))`
> 
> I'm not really convinced that this `issequence(x)` is the correct replacement for `isinstance(x, (list, tuple))`. In the majority of cases, you probably want to be more general and accept any iterable. In the example #24804 that you refer to, you only iterate over the object so why restrict to sequences?

In many cases you _don't_ just want an arbitrary iterable and that's what this is for.

Anything more general and you wind up back mired in the performance problems of using `isinstance` and ABCs.

If there's one tweak to this I would make it would be to explicitly exclude `str` and `bytes`, since although they are technically sequences under this definition, most of the time we want to treat them separately.

I think this problem _badly_ needs a solution so I'd be happy to consider an alternative, but I think this is pretty useful in the vast majority of cases where it's needed.


---

Comment by embray created at 2019-07-03 11:37:56

Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).


---

Comment by embray created at 2019-12-30 14:48:17

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by mkoeppe created at 2020-08-27 04:32:46

Changing status from needs_review to needs_info.


---

Comment by mkoeppe created at 2020-08-27 04:32:46

The ticket description is too abstract. There should be a demonstration of the benefits of this new interface on key examples. IOW - what problem does it solve.


---

Comment by embray created at 2020-08-31 13:42:03

I'm not sure what's clear about it.  This would fix a lot of code for example that used to work when passed `range(n)` on Python 2 but no longer works with Python 3 `range` objects, just as an example.  It can replace lots of code that explicitly tests for `isinstance(obj, (list, tuple))` to support any sequence (where a sequence is an object that admits integer indices from `0` to `len(obj) - 1`).


---

Comment by mkoeppe created at 2020-08-31 14:01:43

Thanks. So as an example of an example, we have

```
sage: vector(range(5))                                                                                                                            
(0, 1, 2, 3, 4)
sage: (QQ^5)(range(5))
TypeError: can't initialize vector from nonzero non-list
sage: (QQ^5)(list(range(5)))                                                                                                                      
(0, 1, 2, 3, 4)
```

Is this what you are concerned about? More examples are needed on the ticket description so that the scope becomes clear.


---

Comment by embray created at 2020-08-31 14:29:23

Replying to [comment:22 mkoeppe]:
> Thanks. So as an example of an example, we have
> {{{
> sage: vector(range(5))                                                                                                                            
> (0, 1, 2, 3, 4)
> sage: (QQ^5)(range(5))
> TypeError: can't initialize vector from nonzero non-list
> sage: (QQ^5)(list(range(5)))                                                                                                                      
> (0, 1, 2, 3, 4)
> }}}
> Is this what you are concerned about? More examples are needed on the ticket description so that the scope becomes clear.
> 

Yes, that's the idea.  Thank you for coming up with the example.  I'll see if I can find more.

I think in the case of `vector()` we must have special-cased `range` (I'm just guessing) but the idea is to have fewer special cases and broader support for this kind of case.  For example `vector` itself is a sequence but there are countless cases in Sage where you should be able to pass a vector as a sequence but that isn't supported.  I'm not a strong-enough Sage user to think of a good example off the top of my head though.


---

Comment by mkoeppe created at 2020-08-31 15:08:00

How about 

```
(QQ^5)(iter([1, 2, 3, 4, 5]))
```



---

Comment by embray created at 2020-08-31 15:20:39

Replying to [comment:25 mkoeppe]:
> How about 
> {{{
> (QQ^5)(iter([1, 2, 3, 4, 5]))
> }}}

An iterator is _not_ a sequence.  Many interfaces could and should support iterators too, but that needs to be handled separately since iterators do not necessarily have a length.  The focus here on sequences is that they do have a fixed length and so certain guarantees and optimizations can be made about them that can't be made with arbitrary iterators.


---

Comment by mkoeppe created at 2020-08-31 15:52:31

Replying to [ticket:26769 embray]:
> `Note `issequence(x)` is also True for `str` and `bytes`.  So when using this to replace `(list, tuple)` care should be taken to make sure other sequence-like types are handled first, in cases where they require separate handling in the first place.

I think it would be worth excluding `str` and `bytes`. I think I have run several times into the problem that a string was destructured into a list of characters -- something that none of our classes should ever do if I'm not overlooking something.


---

Comment by embray created at 2020-08-31 16:06:38

Replying to [comment:28 mkoeppe]:
> Replying to [ticket:26769 embray]:
> > `Note `issequence(x)` is also True for `str` and `bytes`.  So when using this to replace `(list, tuple)` care should be taken to make sure other sequence-like types are handled first, in cases where they require separate handling in the first place.
> 
> I think it would be worth excluding `str` and `bytes`. I think I have run several times into the problem that a string was destructured into a list of characters -- something that none of our classes should ever do if I'm not overlooking something.

Yeah I've agonized over this.  From a purist standpoint it really should include bytes and str.  But I agree with you completely.  Maybe it could be an optional flag (excluding them by default).  At least having a flag for it might make me more comfortable :)


As an aside, I just noticed a small bug in my code:


```
+    PyErr_Clear()
```


As I recently learned from the review of a PR I made to Python, a bare `PyErr_Clear()` is slightly dangerous, because it can also clear exceptions from external events like `MemoryError` and `KeyboardInterrupt`.  I should use `PyErr_ExceptionMatches` here.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.
