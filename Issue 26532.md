# Issue 26532: Add an issequence utility to check for list, tuple, and other compatible objects

archive/issues_026532.json:
```json
{
    "body": "CC:  @fchapoton @jdemeyer @tscrim\n\nKeywords: python3\n\nAdds an `issequence()` function that can work as a more generic replacement for `isinstance(x, (list, tuple))` but will also work with a broader range of similar types (e.g. `xrange`, Sage vectors, Numpy arrays, etc).  Note `issequence(x)` is also True for `str` and `bytes`.  So when using this to replace `(list, tuple)` care should be taken to make sure other sequence-like types are handled first, in cases where they require separate handling in the first place.\n\nFor the very common case of `(list, tuple)` this is faster than `isinstance`, but also has the benefit of being more generic, while not *quite* as generic as the much slower `isinstance(x, Sequence)`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/26769\n\n",
    "created_at": "2018-11-26T15:09:10Z",
    "labels": [
        "misc",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Add an issequence utility to check for list, tuple, and other compatible objects",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/26532",
    "user": "@embray"
}
```
CC:  @fchapoton @jdemeyer @tscrim

Keywords: python3

Adds an `issequence()` function that can work as a more generic replacement for `isinstance(x, (list, tuple))` but will also work with a broader range of similar types (e.g. `xrange`, Sage vectors, Numpy arrays, etc).  Note `issequence(x)` is also True for `str` and `bytes`.  So when using this to replace `(list, tuple)` care should be taken to make sure other sequence-like types are handled first, in cases where they require separate handling in the first place.

For the very common case of `(list, tuple)` this is faster than `isinstance`, but also has the benefit of being more generic, while not *quite* as generic as the much slower `isinstance(x, Sequence)`.

Issue created by migration from https://trac.sagemath.org/ticket/26769





---

archive/issue_comments_373016.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-11-26T15:26:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373016",
    "user": "@embray"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_373017.json:
```json
{
    "body": "1. What's the difference between this and `isinstance(x, Sequence)`? I feel like that should be explained better.\n\n2. There is no point in adding an empty `.pyx` file (unless I'm missing something)",
    "created_at": "2018-11-26T16:48:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373017",
    "user": "@jdemeyer"
}
```

1. What's the difference between this and `isinstance(x, Sequence)`? I feel like that should be explained better.

2. There is no point in adding an empty `.pyx` file (unless I'm missing something)



---

archive/issue_comments_373018.json:
```json
{
    "body": "3. Is it possible for a subclass of `list`/`tuple` not to be a sequence? Just asking because you use `FOO_CheckExact` as opposed to `FOO_Check`.",
    "created_at": "2018-11-26T17:01:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373018",
    "user": "@jdemeyer"
}
```

3. Is it possible for a subclass of `list`/`tuple` not to be a sequence? Just asking because you use `FOO_CheckExact` as opposed to `FOO_Check`.



---

archive/issue_comments_373019.json:
```json
{
    "body": "Replying to [comment:2 jdemeyer]:\n> 1. What's the difference between this and `isinstance(x, Sequence)`? I feel like that should be explained better.\n\nThese are technically completely different things.  The C-API level \"sequence protocol\" is defined by implementing some or all of the [PySequenceMethods](https://docs.python.org/2/c-api/typeobj.html#c.PySequenceMethods) (the way `PySequence_Check` is implemented all it cares about is that `sq_item` by implemented at a minimum).\n\nThis is different from the Python level `collections.abc` \"Sequence\" ABC which requires that both `__getitem__` and `__len__` are implemented.\n\nThis inconsistent overloading of terms is irritating and confusing, but it is what it is.  So this interface defines my own sort of middle-ground which is closer to the ABC in that it requires both the C-level sequence interface (which Python classes that implement `__getitem__` have), but also that `PySequence_Length` works and returns a non-negative integer.  There is an assumption then that `obj[n]` will work for `[0:len(obj)]`.  Unfortunately, for types defined at the Python level there is no obvious way to explicitly distinguish between a \"sequence\" and a \"mapping\".\n\nA class that implements a custom `__getitem__` may work as one or the other, or both, so the best we can do is check for `__getitem__` and `__len__` and hope it works \"like a list\", which is how I'm defining \"sequence\" in this case.\n\nWe special case tuple and list here since they are going to be quite common and are known to be the two most fundamental sequence types built into Python (as opposed to dict, which is not considered a sequence).\n\n> 2. There is no point in adding an empty `.pyx` file (unless I'm missing something)\n\nIf you don't have the .pyx file Cython won't actually generate a Python module that can be used by Python.  You can still `cimport` cpdef functions defined in a .pxd file from other Cython code, but you can't use it in Python :/",
    "created_at": "2018-11-27T12:43:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373019",
    "user": "@embray"
}
```

Replying to [comment:2 jdemeyer]:
> 1. What's the difference between this and `isinstance(x, Sequence)`? I feel like that should be explained better.

These are technically completely different things.  The C-API level "sequence protocol" is defined by implementing some or all of the [PySequenceMethods](https://docs.python.org/2/c-api/typeobj.html#c.PySequenceMethods) (the way `PySequence_Check` is implemented all it cares about is that `sq_item` by implemented at a minimum).

This is different from the Python level `collections.abc` "Sequence" ABC which requires that both `__getitem__` and `__len__` are implemented.

This inconsistent overloading of terms is irritating and confusing, but it is what it is.  So this interface defines my own sort of middle-ground which is closer to the ABC in that it requires both the C-level sequence interface (which Python classes that implement `__getitem__` have), but also that `PySequence_Length` works and returns a non-negative integer.  There is an assumption then that `obj[n]` will work for `[0:len(obj)]`.  Unfortunately, for types defined at the Python level there is no obvious way to explicitly distinguish between a "sequence" and a "mapping".

A class that implements a custom `__getitem__` may work as one or the other, or both, so the best we can do is check for `__getitem__` and `__len__` and hope it works "like a list", which is how I'm defining "sequence" in this case.

We special case tuple and list here since they are going to be quite common and are known to be the two most fundamental sequence types built into Python (as opposed to dict, which is not considered a sequence).

> 2. There is no point in adding an empty `.pyx` file (unless I'm missing something)

If you don't have the .pyx file Cython won't actually generate a Python module that can be used by Python.  You can still `cimport` cpdef functions defined in a .pxd file from other Cython code, but you can't use it in Python :/



---

archive/issue_comments_373020.json:
```json
{
    "body": "Replying to [comment:3 jdemeyer]:\n> 3. Is it possible for a subclass of `list`/`tuple` not to be a sequence? Just asking because you use `FOO_CheckExact` as opposed to `FOO_Check`.\n\nFrom the C API perspective a subclass will still technically be a sequence, but there's no guarantee that it isn't broken in some way, and it's still necessary in those cases to go through the slower but more generic `PySequence_ITEM` calls, as opposed to `PyList_GET_ITEM` when accessing items, for example.\n\nLikewise in `issequence`, for subclasses it's kind of necessary to go through the slightly slower path of calling `PySequence_Length`, and you only add overhead to the more common \"exact\" case, while gaining nothing.",
    "created_at": "2018-11-27T12:53:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373020",
    "user": "@embray"
}
```

Replying to [comment:3 jdemeyer]:
> 3. Is it possible for a subclass of `list`/`tuple` not to be a sequence? Just asking because you use `FOO_CheckExact` as opposed to `FOO_Check`.

From the C API perspective a subclass will still technically be a sequence, but there's no guarantee that it isn't broken in some way, and it's still necessary in those cases to go through the slower but more generic `PySequence_ITEM` calls, as opposed to `PyList_GET_ITEM` when accessing items, for example.

Likewise in `issequence`, for subclasses it's kind of necessary to go through the slightly slower path of calling `PySequence_Length`, and you only add overhead to the more common "exact" case, while gaining nothing.



---

archive/issue_comments_373021.json:
```json
{
    "body": "It would be better if Python had, say, a `__getindex__` and related magic methods that could explicitly distinguish a type as a sequence as opposed to a more general mapping.  Perhaps I will propose that...",
    "created_at": "2018-11-27T13:36:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373021",
    "user": "@embray"
}
```

It would be better if Python had, say, a `__getindex__` and related magic methods that could explicitly distinguish a type as a sequence as opposed to a more general mapping.  Perhaps I will propose that...



---

archive/issue_comments_373022.json:
```json
{
    "body": "Replying to [comment:2 jdemeyer]:\n> 1. What's the difference between this and `isinstance(x, Sequence)`? I feel like that should be explained better.\n\nNow that I've had lunch, let me give a slightly clearer answer to this: This is effectively the same as `isinstance(x, Sequence)`, but it is much faster, both in the positive and negative cases, in that it bypasses all of the slow `isinstance` machinery entirely and does not result in calls to `Sequence.__subclasshook__` for types that do not obviously already implement the Sequence protocol.\n\nThe only case where it can be a slightly slow is for the cases where it has to call `PySequence_Length`, but that itself is only slow on classes that already implement `__getitem__` and `__len__`.",
    "created_at": "2018-11-27T13:48:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373022",
    "user": "@embray"
}
```

Replying to [comment:2 jdemeyer]:
> 1. What's the difference between this and `isinstance(x, Sequence)`? I feel like that should be explained better.

Now that I've had lunch, let me give a slightly clearer answer to this: This is effectively the same as `isinstance(x, Sequence)`, but it is much faster, both in the positive and negative cases, in that it bypasses all of the slow `isinstance` machinery entirely and does not result in calls to `Sequence.__subclasshook__` for types that do not obviously already implement the Sequence protocol.

The only case where it can be a slightly slow is for the cases where it has to call `PySequence_Length`, but that itself is only slow on classes that already implement `__getitem__` and `__len__`.



---

archive/issue_comments_373023.json:
```json
{
    "body": "What about point 2 in comment:2 ?\n\nEDIT: OK, I missed that you answered that already.\n\nCan we move on ? I hope that Jeroen can finish the review.",
    "created_at": "2018-12-07T19:33:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373023",
    "user": "@fchapoton"
}
```

What about point 2 in comment:2 ?

EDIT: OK, I missed that you answered that already.

Can we move on ? I hope that Jeroen can finish the review.



---

archive/issue_comments_373024.json:
```json
{
    "body": "One other comment worth adding about this, is that it needs to be used *carefully*.  Almost any custom class in Python (except those explicitly inheriting from `dict`, I believe) that implements a `__getitem__` can be interpreted by Python as a \"sequence\" type.  Per my note in comment:7, I think this is a fundamental shortcoming in Python though, and something we just have to deal with on some level...",
    "created_at": "2018-12-10T13:07:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373024",
    "user": "@embray"
}
```

One other comment worth adding about this, is that it needs to be used *carefully*.  Almost any custom class in Python (except those explicitly inheriting from `dict`, I believe) that implements a `__getitem__` can be interpreted by Python as a "sequence" type.  Per my note in comment:7, I think this is a fundamental shortcoming in Python though, and something we just have to deal with on some level...



---

archive/issue_comments_373025.json:
```json
{
    "body": "Retargeting some of my tickets (somewhat optimistically for now).",
    "created_at": "2018-12-28T14:10:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373025",
    "user": "@embray"
}
```

Retargeting some of my tickets (somewhat optimistically for now).



---

archive/issue_comments_373026.json:
```json
{
    "body": "Replying to [ticket:26769 embray]:\n> Adds an `issequence()` function that can work as a more generic replacement for `isinstance(x, (list, tuple))`\n\nI'm not really convinced that this `issequence(x)` is the correct replacement for `isinstance(x, (list, tuple))`. In the majority of cases, you probably want to be more general and accept any iterable. In the example #24804 that you refer to, you only iterate over the object so why restrict to sequences?\n\nAnd the way: I also agree that the mapping vs sequence thing is annoying.",
    "created_at": "2019-01-29T12:11:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373026",
    "user": "@jdemeyer"
}
```

Replying to [ticket:26769 embray]:
> Adds an `issequence()` function that can work as a more generic replacement for `isinstance(x, (list, tuple))`

I'm not really convinced that this `issequence(x)` is the correct replacement for `isinstance(x, (list, tuple))`. In the majority of cases, you probably want to be more general and accept any iterable. In the example #24804 that you refer to, you only iterate over the object so why restrict to sequences?

And the way: I also agree that the mapping vs sequence thing is annoying.



---

archive/issue_comments_373027.json:
```json
{
    "body": "This is specifically intended for cases where the iterable is treated sequentially: That is, it is assumed that it can be indexed with monotonically increasing integer indices.   There are many cases like this where you do *not* want to be more general and do not want to accept an arbitrary iterable, at least, without eagerly consuming the iterable in order to convert it to a sequence (e.g. `list(iterable)`) which is obviously wasteful if you already have a sequence-like object.",
    "created_at": "2019-01-29T16:53:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373027",
    "user": "@embray"
}
```

This is specifically intended for cases where the iterable is treated sequentially: That is, it is assumed that it can be indexed with monotonically increasing integer indices.   There are many cases like this where you do *not* want to be more general and do not want to accept an arbitrary iterable, at least, without eagerly consuming the iterable in order to convert it to a sequence (e.g. `list(iterable)`) which is obviously wasteful if you already have a sequence-like object.



---

archive/issue_comments_373028.json:
```json
{
    "body": "For example, there are many cases where you have `isinstance(x, (list tuple))` where it should also be able to accept something like a vector or a matrix, and just arbitrarily doesn't because of this less general check.",
    "created_at": "2019-01-29T16:55:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373028",
    "user": "@embray"
}
```

For example, there are many cases where you have `isinstance(x, (list tuple))` where it should also be able to accept something like a vector or a matrix, and just arbitrarily doesn't because of this less general check.



---

archive/issue_comments_373029.json:
```json
{
    "body": "Moving all my in-progress tickets to 8.8 milestone.",
    "created_at": "2019-03-25T10:43:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373029",
    "user": "@embray"
}
```

Moving all my in-progress tickets to 8.8 milestone.



---

archive/issue_comments_373030.json:
```json
{
    "body": "Replying to [comment:12 jdemeyer]:\n> Replying to [ticket:26769 embray]:\n> > Adds an `issequence()` function that can work as a more generic replacement for `isinstance(x, (list, tuple))`\n> \n> I'm not really convinced that this `issequence(x)` is the correct replacement for `isinstance(x, (list, tuple))`. In the majority of cases, you probably want to be more general and accept any iterable. In the example #24804 that you refer to, you only iterate over the object so why restrict to sequences?\n\nIn many cases you *don't* just want an arbitrary iterable and that's what this is for.\n\nAnything more general and you wind up back mired in the performance problems of using `isinstance` and ABCs.\n\nIf there's one tweak to this I would make it would be to explicitly exclude `str` and `bytes`, since although they are technically sequences under this definition, most of the time we want to treat them separately.\n\nI think this problem *badly* needs a solution so I'd be happy to consider an alternative, but I think this is pretty useful in the vast majority of cases where it's needed.",
    "created_at": "2019-04-08T16:10:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373030",
    "user": "@embray"
}
```

Replying to [comment:12 jdemeyer]:
> Replying to [ticket:26769 embray]:
> > Adds an `issequence()` function that can work as a more generic replacement for `isinstance(x, (list, tuple))`
> 
> I'm not really convinced that this `issequence(x)` is the correct replacement for `isinstance(x, (list, tuple))`. In the majority of cases, you probably want to be more general and accept any iterable. In the example #24804 that you refer to, you only iterate over the object so why restrict to sequences?

In many cases you *don't* just want an arbitrary iterable and that's what this is for.

Anything more general and you wind up back mired in the performance problems of using `isinstance` and ABCs.

If there's one tweak to this I would make it would be to explicitly exclude `str` and `bytes`, since although they are technically sequences under this definition, most of the time we want to treat them separately.

I think this problem *badly* needs a solution so I'd be happy to consider an alternative, but I think this is pretty useful in the vast majority of cases where it's needed.



---

archive/issue_comments_373031.json:
```json
{
    "body": "Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).",
    "created_at": "2019-07-03T11:37:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373031",
    "user": "@embray"
}
```

Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).



---

archive/issue_comments_373032.json:
```json
{
    "body": "Ticket retargeted after milestone closed",
    "created_at": "2019-12-30T14:48:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373032",
    "user": "@embray"
}
```

Ticket retargeted after milestone closed



---

archive/issue_comments_373033.json:
```json
{
    "body": "Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373033",
    "user": "@mkoeppe"
}
```

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_comments_373034.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2020-08-27T04:32:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373034",
    "user": "@mkoeppe"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_373035.json:
```json
{
    "body": "The ticket description is too abstract. There should be a demonstration of the benefits of this new interface on key examples. IOW - what problem does it solve.",
    "created_at": "2020-08-27T04:32:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373035",
    "user": "@mkoeppe"
}
```

The ticket description is too abstract. There should be a demonstration of the benefits of this new interface on key examples. IOW - what problem does it solve.



---

archive/issue_comments_373036.json:
```json
{
    "body": "I'm not sure what's clear about it.  This would fix a lot of code for example that used to work when passed `range(n)` on Python 2 but no longer works with Python 3 `range` objects, just as an example.  It can replace lots of code that explicitly tests for `isinstance(obj, (list, tuple))` to support any sequence (where a sequence is an object that admits integer indices from `0` to `len(obj) - 1`).",
    "created_at": "2020-08-31T13:42:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373036",
    "user": "@embray"
}
```

I'm not sure what's clear about it.  This would fix a lot of code for example that used to work when passed `range(n)` on Python 2 but no longer works with Python 3 `range` objects, just as an example.  It can replace lots of code that explicitly tests for `isinstance(obj, (list, tuple))` to support any sequence (where a sequence is an object that admits integer indices from `0` to `len(obj) - 1`).



---

archive/issue_comments_373037.json:
```json
{
    "body": "Thanks. So as an example of an example, we have\n\n```\nsage: vector(range(5))                                                                                                                            \n(0, 1, 2, 3, 4)\nsage: (QQ^5)(range(5))\nTypeError: can't initialize vector from nonzero non-list\nsage: (QQ^5)(list(range(5)))                                                                                                                      \n(0, 1, 2, 3, 4)\n```\n\nIs this what you are concerned about? More examples are needed on the ticket description so that the scope becomes clear.",
    "created_at": "2020-08-31T14:01:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373037",
    "user": "@mkoeppe"
}
```

Thanks. So as an example of an example, we have

```
sage: vector(range(5))                                                                                                                            
(0, 1, 2, 3, 4)
sage: (QQ^5)(range(5))
TypeError: can't initialize vector from nonzero non-list
sage: (QQ^5)(list(range(5)))                                                                                                                      
(0, 1, 2, 3, 4)
```

Is this what you are concerned about? More examples are needed on the ticket description so that the scope becomes clear.



---

archive/issue_comments_373038.json:
```json
{
    "body": "Replying to [comment:22 mkoeppe]:\n> Thanks. So as an example of an example, we have\n> {{{\n> sage: vector(range(5))                                                                                                                            \n> (0, 1, 2, 3, 4)\n> sage: (QQ^5)(range(5))\n> TypeError: can't initialize vector from nonzero non-list\n> sage: (QQ^5)(list(range(5)))                                                                                                                      \n> (0, 1, 2, 3, 4)\n> }}}\n> Is this what you are concerned about? More examples are needed on the ticket description so that the scope becomes clear.\n> \n\nYes, that's the idea.  Thank you for coming up with the example.  I'll see if I can find more.\n\nI think in the case of `vector()` we must have special-cased `range` (I'm just guessing) but the idea is to have fewer special cases and broader support for this kind of case.  For example `vector` itself is a sequence but there are countless cases in Sage where you should be able to pass a vector as a sequence but that isn't supported.  I'm not a strong-enough Sage user to think of a good example off the top of my head though.",
    "created_at": "2020-08-31T14:29:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373038",
    "user": "@embray"
}
```

Replying to [comment:22 mkoeppe]:
> Thanks. So as an example of an example, we have
> {{{
> sage: vector(range(5))                                                                                                                            
> (0, 1, 2, 3, 4)
> sage: (QQ^5)(range(5))
> TypeError: can't initialize vector from nonzero non-list
> sage: (QQ^5)(list(range(5)))                                                                                                                      
> (0, 1, 2, 3, 4)
> }}}
> Is this what you are concerned about? More examples are needed on the ticket description so that the scope becomes clear.
> 

Yes, that's the idea.  Thank you for coming up with the example.  I'll see if I can find more.

I think in the case of `vector()` we must have special-cased `range` (I'm just guessing) but the idea is to have fewer special cases and broader support for this kind of case.  For example `vector` itself is a sequence but there are countless cases in Sage where you should be able to pass a vector as a sequence but that isn't supported.  I'm not a strong-enough Sage user to think of a good example off the top of my head though.



---

archive/issue_comments_373039.json:
```json
{
    "body": "How about \n\n```\n(QQ^5)(iter([1, 2, 3, 4, 5]))\n```\n",
    "created_at": "2020-08-31T15:08:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373039",
    "user": "@mkoeppe"
}
```

How about 

```
(QQ^5)(iter([1, 2, 3, 4, 5]))
```




---

archive/issue_comments_373040.json:
```json
{
    "body": "Replying to [comment:25 mkoeppe]:\n> How about \n> {{{\n> (QQ^5)(iter([1, 2, 3, 4, 5]))\n> }}}\n\nAn iterator is *not* a sequence.  Many interfaces could and should support iterators too, but that needs to be handled separately since iterators do not necessarily have a length.  The focus here on sequences is that they do have a fixed length and so certain guarantees and optimizations can be made about them that can't be made with arbitrary iterators.",
    "created_at": "2020-08-31T15:20:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373040",
    "user": "@embray"
}
```

Replying to [comment:25 mkoeppe]:
> How about 
> {{{
> (QQ^5)(iter([1, 2, 3, 4, 5]))
> }}}

An iterator is *not* a sequence.  Many interfaces could and should support iterators too, but that needs to be handled separately since iterators do not necessarily have a length.  The focus here on sequences is that they do have a fixed length and so certain guarantees and optimizations can be made about them that can't be made with arbitrary iterators.



---

archive/issue_comments_373041.json:
```json
{
    "body": "Replying to [ticket:26769 embray]:\n> `Note `issequence(x)` is also True for `str` and `bytes`.  So when using this to replace `(list, tuple)` care should be taken to make sure other sequence-like types are handled first, in cases where they require separate handling in the first place.\n\nI think it would be worth excluding `str` and `bytes`. I think I have run several times into the problem that a string was destructured into a list of characters -- something that none of our classes should ever do if I'm not overlooking something.",
    "created_at": "2020-08-31T15:52:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373041",
    "user": "@mkoeppe"
}
```

Replying to [ticket:26769 embray]:
> `Note `issequence(x)` is also True for `str` and `bytes`.  So when using this to replace `(list, tuple)` care should be taken to make sure other sequence-like types are handled first, in cases where they require separate handling in the first place.

I think it would be worth excluding `str` and `bytes`. I think I have run several times into the problem that a string was destructured into a list of characters -- something that none of our classes should ever do if I'm not overlooking something.



---

archive/issue_comments_373042.json:
```json
{
    "body": "Replying to [comment:28 mkoeppe]:\n> Replying to [ticket:26769 embray]:\n> > `Note `issequence(x)` is also True for `str` and `bytes`.  So when using this to replace `(list, tuple)` care should be taken to make sure other sequence-like types are handled first, in cases where they require separate handling in the first place.\n> \n> I think it would be worth excluding `str` and `bytes`. I think I have run several times into the problem that a string was destructured into a list of characters -- something that none of our classes should ever do if I'm not overlooking something.\n\nYeah I've agonized over this.  From a purist standpoint it really should include bytes and str.  But I agree with you completely.  Maybe it could be an optional flag (excluding them by default).  At least having a flag for it might make me more comfortable :)\n\n\nAs an aside, I just noticed a small bug in my code:\n\n\n```\n+    PyErr_Clear()\n```\n\n\nAs I recently learned from the review of a PR I made to Python, a bare `PyErr_Clear()` is slightly dangerous, because it can also clear exceptions from external events like `MemoryError` and `KeyboardInterrupt`.  I should use `PyErr_ExceptionMatches` here.",
    "created_at": "2020-08-31T16:06:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373042",
    "user": "@embray"
}
```

Replying to [comment:28 mkoeppe]:
> Replying to [ticket:26769 embray]:
> > `Note `issequence(x)` is also True for `str` and `bytes`.  So when using this to replace `(list, tuple)` care should be taken to make sure other sequence-like types are handled first, in cases where they require separate handling in the first place.
> 
> I think it would be worth excluding `str` and `bytes`. I think I have run several times into the problem that a string was destructured into a list of characters -- something that none of our classes should ever do if I'm not overlooking something.

Yeah I've agonized over this.  From a purist standpoint it really should include bytes and str.  But I agree with you completely.  Maybe it could be an optional flag (excluding them by default).  At least having a flag for it might make me more comfortable :)


As an aside, I just noticed a small bug in my code:


```
+    PyErr_Clear()
```


As I recently learned from the review of a PR I made to Python, a bare `PyErr_Clear()` is slightly dangerous, because it can also clear exceptions from external events like `MemoryError` and `KeyboardInterrupt`.  I should use `PyErr_ExceptionMatches` here.



---

archive/issue_comments_373043.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-15T22:07:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373043",
    "user": "@mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_373044.json:
```json
{
    "body": "Setting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26532",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26532#issuecomment-373044",
    "user": "@mkoeppe"
}
```

Setting a new milestone for this ticket based on a cursory review.
