# Issue 31117: Improve Breadth First Search in c_graph.pyx

archive/issues_030880.json:
```json
{
    "body": "Currently, method `breadth_first_search` in `c_graph.pyx` implements a queue using a list and removes element at position 0. This is ok on small graphs, but for large graphs, This is really slow.\n\nI'm using the following function to benchmark. When `report_distance` is `False`, it calls the code from `c_graph.pyx`, and when it is `True`,  is uses a Python implementation from `generic_graph.py`.\n\n```sage\ndef comp(): \n    for n in [5, 10, 50, 100, 500, 1000]: \n        G = graphs.Grid2dGraph(n, n) \n        print(G) \n        %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=False))\n        %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=True))\n```\n\n\nBefore:\n\n```\nsage: comp()                                                                                                                                        \n2D Grid Graph for [5, 5]\n17.9 \u00b5s \u00b1 470 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n72.8 \u00b5s \u00b1 6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n2D Grid Graph for [10, 10]\n58.5 \u00b5s \u00b1 1.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n269 \u00b5s \u00b1 13.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n2D Grid Graph for [50, 50]\n1.92 ms \u00b1 165 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n8.12 ms \u00b1 263 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n2D Grid Graph for [100, 100]\n9.63 ms \u00b1 232 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n36.2 ms \u00b1 1.43 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n2D Grid Graph for [500, 500]\n397 ms \u00b1 18 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n1.12 s \u00b1 27.3 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n2D Grid Graph for [1000, 1000]\n32.3 s \u00b1 1.1 s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n5.64 s \u00b1 414 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\n\nAfter:\n\n```\nsage: comp()                                                                                                                                        \n2D Grid Graph for [5, 5]\n7.43 \u00b5s \u00b1 269 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n56.4 \u00b5s \u00b1 1.91 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n2D Grid Graph for [10, 10]\n21.8 \u00b5s \u00b1 1.62 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n300 \u00b5s \u00b1 19.9 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n2D Grid Graph for [50, 50]\n716 \u00b5s \u00b1 40.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n8.65 ms \u00b1 457 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n2D Grid Graph for [100, 100]\n2.99 ms \u00b1 141 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n34.8 ms \u00b1 1.69 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n2D Grid Graph for [500, 500]\n105 ms \u00b1 4.5 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n1.18 s \u00b1 14.6 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n2D Grid Graph for [1000, 1000]\n596 ms \u00b1 68.3 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n5.83 s \u00b1 1.11 s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\nAnother improvement is to avoid using `in_neighbors` and `out_neighbors` since these methods return lists of vertices and behind we have some mallocs of arrays. So a lot of operations that can be avoided. \n\nCC:  @kliem @videlec chaperon @dimpase\n\nBranch/Commit: 6159f317c636fa7bd9d14bbc60ea393549afc0e9\n\nReviewer: Jonathan Kliem, David Coudert\n\nAuthor: David Coudert, Jonathan Kliem\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/31117\n\n",
    "closed_at": "2021-01-03T12:15:16Z",
    "created_at": "2020-12-27T17:32:35Z",
    "labels": [
        "component: graph theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.3",
    "title": "Improve Breadth First Search in c_graph.pyx",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31117",
    "user": "https://github.com/dcoudert"
}
```
Currently, method `breadth_first_search` in `c_graph.pyx` implements a queue using a list and removes element at position 0. This is ok on small graphs, but for large graphs, This is really slow.

I'm using the following function to benchmark. When `report_distance` is `False`, it calls the code from `c_graph.pyx`, and when it is `True`,  is uses a Python implementation from `generic_graph.py`.

```sage
def comp(): 
    for n in [5, 10, 50, 100, 500, 1000]: 
        G = graphs.Grid2dGraph(n, n) 
        print(G) 
        %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=False))
        %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=True))
```


Before:

```
sage: comp()                                                                                                                                        
2D Grid Graph for [5, 5]
17.9 µs ± 470 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
72.8 µs ± 6 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
2D Grid Graph for [10, 10]
58.5 µs ± 1.2 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
269 µs ± 13.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [50, 50]
1.92 ms ± 165 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
8.12 ms ± 263 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
2D Grid Graph for [100, 100]
9.63 ms ± 232 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
36.2 ms ± 1.43 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
2D Grid Graph for [500, 500]
397 ms ± 18 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
1.12 s ± 27.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
2D Grid Graph for [1000, 1000]
32.3 s ± 1.1 s per loop (mean ± std. dev. of 7 runs, 1 loop each)
5.64 s ± 414 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```


After:

```
sage: comp()                                                                                                                                        
2D Grid Graph for [5, 5]
7.43 µs ± 269 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
56.4 µs ± 1.91 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
2D Grid Graph for [10, 10]
21.8 µs ± 1.62 µs per loop (mean ± std. dev. of 7 runs, 100000 loops each)
300 µs ± 19.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [50, 50]
716 µs ± 40.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
8.65 ms ± 457 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
2D Grid Graph for [100, 100]
2.99 ms ± 141 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
34.8 ms ± 1.69 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
2D Grid Graph for [500, 500]
105 ms ± 4.5 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
1.18 s ± 14.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
2D Grid Graph for [1000, 1000]
596 ms ± 68.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
5.83 s ± 1.11 s per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

Another improvement is to avoid using `in_neighbors` and `out_neighbors` since these methods return lists of vertices and behind we have some mallocs of arrays. So a lot of operations that can be avoided. 

CC:  @kliem @videlec chaperon @dimpase

Branch/Commit: 6159f317c636fa7bd9d14bbc60ea393549afc0e9

Reviewer: Jonathan Kliem, David Coudert

Author: David Coudert, Jonathan Kliem

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/31117





---

archive/issue_comments_440833.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-12-27T17:33:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440833",
    "user": "https://github.com/dcoudert"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_440834.json:
```json
{
    "body": "<a id='comment:1'></a>New commits:",
    "created_at": "2020-12-27T17:33:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440834",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:1'></a>New commits:



---

archive/issue_comments_440835.json:
```json
{
    "body": "<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-12-27T17:55:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440835",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_440836.json:
```json
{
    "body": "<a id='comment:4'></a>This last commit is not very nice, but it's now way faster.",
    "created_at": "2020-12-27T17:56:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440836",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:4'></a>This last commit is not very nice, but it's now way faster.



---

archive/issue_comments_440837.json:
```json
{
    "body": "<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-12-28T01:35:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440837",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_440838.json:
```json
{
    "body": "<a id='comment:6'></a>I had to remove last commit because method `next_out_neighbor_unsafe` is not implemented in `static_sparse_backend.pyx`, and I don't know yet how to add such method to this backend.",
    "created_at": "2020-12-28T01:38:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440838",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:6'></a>I had to remove last commit because method `next_out_neighbor_unsafe` is not implemented in `static_sparse_backend.pyx`, and I don't know yet how to add such method to this backend.



---

archive/issue_comments_440839.json:
```json
{
    "body": "<a id='comment:7'></a>First of all:\n\nI can confirm an enourmous improvement (something like a factor 2 or 3), but I can't reproduce the 32 seconds for your before `2D Grid Graph for [1000, 1000]`. Looks to me like you went into swap or similar.",
    "created_at": "2020-12-28T10:32:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440839",
    "user": "https://github.com/kliem"
}
```

<a id='comment:7'></a>First of all:

I can confirm an enourmous improvement (something like a factor 2 or 3), but I can't reproduce the 32 seconds for your before `2D Grid Graph for [1000, 1000]`. Looks to me like you went into swap or similar.



---

archive/issue_comments_440840.json:
```json
{
    "body": "<a id='comment:8'></a>I tested on a desktop with more memory than my laptop (which has already 16G Ram), and I don't get such huge slowdown anymore. So it's certainly a swap problem.\n\nActually, the way BFS is implementented in `c_graph`, we start pushing vertices to the queue, and then we say that a vertex is seen if it has already been extracted from the queue. An alternative, which is what is done in `generic_graph` is to say that a vertex is seen if already added to the queue. In the first case, the queue can have up to O(m) vertices, while in the second case, it's at most O(n).\nI will try the second option in `c_graph`.",
    "created_at": "2020-12-28T11:00:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440840",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:8'></a>I tested on a desktop with more memory than my laptop (which has already 16G Ram), and I don't get such huge slowdown anymore. So it's certainly a swap problem.

Actually, the way BFS is implementented in `c_graph`, we start pushing vertices to the queue, and then we say that a vertex is seen if it has already been extracted from the queue. An alternative, which is what is done in `generic_graph` is to say that a vertex is seen if already added to the queue. In the first case, the queue can have up to O(m) vertices, while in the second case, it's at most O(n).
I will try the second option in `c_graph`.



---

archive/issue_comments_440841.json:
```json
{
    "body": "<a id='comment:9'></a>A swap problem is certainly also an implementation problem. If we can use less memory with better implementation that is certainly an improvement.",
    "created_at": "2020-12-28T11:06:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440841",
    "user": "https://github.com/kliem"
}
```

<a id='comment:9'></a>A swap problem is certainly also an implementation problem. If we can use less memory with better implementation that is certainly an improvement.



---

archive/issue_comments_440842.json:
```json
{
    "body": "<a id='comment:10'></a>`CGraph.out_neighbors` etc are still lists. If you really want it to be fast, you should use `CGraph.next_out_neighbor` etc as:\n\n```diff\ndiff --git a/src/sage/graphs/base/c_graph.pyx b/src/sage/graphs/base/c_graph.pyx\nindex 47fe5b2b90..92b16ab283 100644\n--- a/src/sage/graphs/base/c_graph.pyx\n+++ b/src/sage/graphs/base/c_graph.pyx\n@@ -4837,6 +4837,8 @@ cdef class Search_iterator:\n         \"\"\"\n         cdef int v_int\n         cdef int w_int\n+        cdef int l\n+        cdef CGraph cg = self.graph.cg()\n \n         while not self.fifo.empty():\n             v_int = self.fifo.front()\n@@ -4847,11 +4849,15 @@ cdef class Search_iterator:\n                 bitset_add(self.seen, v_int)\n \n                 if self.test_out:\n-                    for w_int in self.graph.cg().out_neighbors(v_int):\n+                    w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)\n+                    while w_int != -1:\n                         self.fifo.push(w_int)\n+                        w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)\n                 if self.test_in:\n-                    for w_int in self.in_neighbors(v_int):\n+                    w_int = cg.next_in_neighbor_unsafe(v_int, -1, &l)\n+                    while w_int != -1:\n                         self.fifo.push(w_int)\n+                        w_int = cg.next_in_neighbor_unsafe(v_int, w_int, &l)\n```",
    "created_at": "2020-12-28T11:13:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440842",
    "user": "https://github.com/kliem"
}
```

<a id='comment:10'></a>`CGraph.out_neighbors` etc are still lists. If you really want it to be fast, you should use `CGraph.next_out_neighbor` etc as:

```diff
diff --git a/src/sage/graphs/base/c_graph.pyx b/src/sage/graphs/base/c_graph.pyx
index 47fe5b2b90..92b16ab283 100644
--- a/src/sage/graphs/base/c_graph.pyx
+++ b/src/sage/graphs/base/c_graph.pyx
@@ -4837,6 +4837,8 @@ cdef class Search_iterator:
         """
         cdef int v_int
         cdef int w_int
+        cdef int l
+        cdef CGraph cg = self.graph.cg()
 
         while not self.fifo.empty():
             v_int = self.fifo.front()
@@ -4847,11 +4849,15 @@ cdef class Search_iterator:
                 bitset_add(self.seen, v_int)
 
                 if self.test_out:
-                    for w_int in self.graph.cg().out_neighbors(v_int):
+                    w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)
+                    while w_int != -1:
                         self.fifo.push(w_int)
+                        w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)
                 if self.test_in:
-                    for w_int in self.in_neighbors(v_int):
+                    w_int = cg.next_in_neighbor_unsafe(v_int, -1, &l)
+                    while w_int != -1:
                         self.fifo.push(w_int)
+                        w_int = cg.next_in_neighbor_unsafe(v_int, w_int, &l)
```



---

archive/issue_comments_440843.json:
```json
{
    "body": "<a id='comment:11'></a>I tried that but it's not compatible with `static_sparse_backend.pyx` (don't have `next_out_neighbor_unsafe`).\nAn option is to implement a specific BFS for `static_sparse_backend.pyx`.",
    "created_at": "2020-12-28T11:18:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440843",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:11'></a>I tried that but it's not compatible with `static_sparse_backend.pyx` (don't have `next_out_neighbor_unsafe`).
An option is to implement a specific BFS for `static_sparse_backend.pyx`.



---

archive/issue_comments_440844.json:
```json
{
    "body": "<a id='comment:12'></a>Replying to [comment:11 dcoudert]:\n> I tried that but it's not compatible with `static_sparse_backend.pyx` (don't have `next_out_neighbor_unsafe`).\n> An option is to implement a specific BFS for `static_sparse_backend.pyx`.\n\n\nOk. I'll think about how this can be fixed.",
    "created_at": "2020-12-28T11:24:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440844",
    "user": "https://github.com/kliem"
}
```

<a id='comment:12'></a>Replying to [comment:11 dcoudert]:
> I tried that but it's not compatible with `static_sparse_backend.pyx` (don't have `next_out_neighbor_unsafe`).
> An option is to implement a specific BFS for `static_sparse_backend.pyx`.


Ok. I'll think about how this can be fixed.



---

archive/issue_comments_440845.json:
```json
{
    "body": "<a id='comment:13'></a>I don't see an improvement in factoring out `next_depth...`.\n\nThe compiler optimzes things fine for me, if I distinct everywhere with `self.direction == 0` and `self.direction != 0`. Then one can right away change the data type for lifo to https://en.cppreference.com/w/cpp/container/stack\nas well.\n\nThis is how my overall diff looks to your branch:\n\n```diff\ndiff --git a/src/sage/graphs/base/c_graph.pyx b/src/sage/graphs/base/c_graph.pyx\nindex 47fe5b2b90..daf9bc8af5 100644\n--- a/src/sage/graphs/base/c_graph.pyx\n+++ b/src/sage/graphs/base/c_graph.pyx\n@@ -48,6 +48,7 @@ from sage.rings.integer cimport Integer\n from sage.arith.long cimport pyobject_to_long\n from libcpp.queue cimport priority_queue\n from libcpp.queue cimport queue\n+from libcpp.stack cimport stack\n from libcpp.pair cimport pair\n from sage.rings.integer_ring import ZZ\n from cysignals.memory cimport check_allocarray, sig_free\n@@ -4716,7 +4717,7 @@ cdef class Search_iterator:\n \n     cdef CGraphBackend graph\n     cdef int direction\n-    cdef list stack\n+    cdef stack[int] lifo\n     cdef queue[int] fifo\n     cdef bitset_t seen\n     cdef bint test_out\n@@ -4794,7 +4795,7 @@ cdef class Search_iterator:\n         if direction == 0:\n             self.fifo.push(v_id)\n         else:\n-            self.stack = [v_id]\n+            self.lifo.push(v_id)\n \n         if not self.graph._directed:\n             ignore_direction = False\n@@ -4823,7 +4824,7 @@ cdef class Search_iterator:\n         \"\"\"\n         return self\n \n-    def next_breadth_first_search(self):\n+    def __next__(self):\n         r\"\"\"\n         Return the next vertex in a breadth first search traversal of a graph.\n \n@@ -4837,53 +4838,38 @@ cdef class Search_iterator:\n         \"\"\"\n         cdef int v_int\n         cdef int w_int\n+        cdef int l\n+        cdef CGraph cg = self.graph.cg()\n \n-        while not self.fifo.empty():\n-            v_int = self.fifo.front()\n-            self.fifo.pop()\n-\n-            if bitset_not_in(self.seen, v_int):\n-                value = self.graph.vertex_label(v_int)\n-                bitset_add(self.seen, v_int)\n-\n-                if self.test_out:\n-                    for w_int in self.graph.cg().out_neighbors(v_int):\n-                        self.fifo.push(w_int)\n-                if self.test_in:\n-                    for w_int in self.in_neighbors(v_int):\n-                        self.fifo.push(w_int)\n-\n-                break\n-        else:\n-            raise StopIteration\n-\n-        return value\n-\n-    def next_depth_first_search(self):\n-        r\"\"\"\n-        Return the next vertex in a depth first search traversal of a graph.\n-\n-        EXAMPLES::\n-\n-            sage: g = graphs.PetersenGraph()\n-            sage: g.depth_first_search(0)\n-            <generator object ...depth_first_search at ...\n-            sage: next(g.depth_first_search(0))\n-            0\n-        \"\"\"\n-        cdef int v_int\n-\n-        while self.stack:\n-            v_int = self.stack.pop()\n+        while ((self.direction == 0 and not self.fifo.empty())\n+                or self.direction != 0 and not self.lifo.empty()):\n+            if self.direction == 0:\n+                v_int = self.fifo.front()\n+                self.fifo.pop()\n+            else:\n+                v_int = self.lifo.top()\n+                self.lifo.pop()\n \n             if bitset_not_in(self.seen, v_int):\n                 value = self.graph.vertex_label(v_int)\n                 bitset_add(self.seen, v_int)\n \n                 if self.test_out:\n-                    self.stack.extend(self.graph.cg().out_neighbors(v_int))\n+                    w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)\n+                    while w_int != -1:\n+                        if self.direction == 0:\n+                            self.fifo.push(w_int)\n+                        else:\n+                            self.lifo.push(w_int)\n+                        w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)\n                 if self.test_in:\n-                    self.stack.extend(self.in_neighbors(v_int))\n+                    w_int = cg.next_in_neighbor_unsafe(v_int, -1, &l)\n+                    while w_int != -1:\n+                        if self.direction == 0:\n+                            self.fifo.push(w_int)\n+                        else:\n+                            self.lifo.push(w_int)\n+                        w_int = cg.next_in_neighbor_unsafe(v_int, w_int, &l)\n \n                 break\n         else:\n@@ -4891,22 +4877,6 @@ cdef class Search_iterator:\n \n         return value\n \n-    def __next__(self):\n-        r\"\"\"\n-        Return the next vertex in a breadth first search traversal of a graph.\n-\n-        EXAMPLES::\n-\n-            sage: g = graphs.PetersenGraph()\n-            sage: g.breadth_first_search(0)\n-            <generator object ...breadth_first_search at ...\n-            sage: next(g.breadth_first_search(0))\n-            0\n-        \"\"\"\n-        if self.direction == 0:\n-            return self.next_breadth_first_search()\n-        return self.next_depth_first_search()\n-\n ##############################\n # Functions to simplify edge iterator.\n ##############################\n```\n\nHowever, as mentioned above, I need to figure out something yet for sparse graphs.\n\nAnd there seems to exist no depth-first doctest for static sparse, at least not in `sage/src/sage/graphs`.",
    "created_at": "2020-12-28T11:29:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440845",
    "user": "https://github.com/kliem"
}
```

<a id='comment:13'></a>I don't see an improvement in factoring out `next_depth...`.

The compiler optimzes things fine for me, if I distinct everywhere with `self.direction == 0` and `self.direction != 0`. Then one can right away change the data type for lifo to https://en.cppreference.com/w/cpp/container/stack
as well.

This is how my overall diff looks to your branch:

```diff
diff --git a/src/sage/graphs/base/c_graph.pyx b/src/sage/graphs/base/c_graph.pyx
index 47fe5b2b90..daf9bc8af5 100644
--- a/src/sage/graphs/base/c_graph.pyx
+++ b/src/sage/graphs/base/c_graph.pyx
@@ -48,6 +48,7 @@ from sage.rings.integer cimport Integer
 from sage.arith.long cimport pyobject_to_long
 from libcpp.queue cimport priority_queue
 from libcpp.queue cimport queue
+from libcpp.stack cimport stack
 from libcpp.pair cimport pair
 from sage.rings.integer_ring import ZZ
 from cysignals.memory cimport check_allocarray, sig_free
@@ -4716,7 +4717,7 @@ cdef class Search_iterator:
 
     cdef CGraphBackend graph
     cdef int direction
-    cdef list stack
+    cdef stack[int] lifo
     cdef queue[int] fifo
     cdef bitset_t seen
     cdef bint test_out
@@ -4794,7 +4795,7 @@ cdef class Search_iterator:
         if direction == 0:
             self.fifo.push(v_id)
         else:
-            self.stack = [v_id]
+            self.lifo.push(v_id)
 
         if not self.graph._directed:
             ignore_direction = False
@@ -4823,7 +4824,7 @@ cdef class Search_iterator:
         """
         return self
 
-    def next_breadth_first_search(self):
+    def __next__(self):
         r"""
         Return the next vertex in a breadth first search traversal of a graph.
 
@@ -4837,53 +4838,38 @@ cdef class Search_iterator:
         """
         cdef int v_int
         cdef int w_int
+        cdef int l
+        cdef CGraph cg = self.graph.cg()
 
-        while not self.fifo.empty():
-            v_int = self.fifo.front()
-            self.fifo.pop()
-
-            if bitset_not_in(self.seen, v_int):
-                value = self.graph.vertex_label(v_int)
-                bitset_add(self.seen, v_int)
-
-                if self.test_out:
-                    for w_int in self.graph.cg().out_neighbors(v_int):
-                        self.fifo.push(w_int)
-                if self.test_in:
-                    for w_int in self.in_neighbors(v_int):
-                        self.fifo.push(w_int)
-
-                break
-        else:
-            raise StopIteration
-
-        return value
-
-    def next_depth_first_search(self):
-        r"""
-        Return the next vertex in a depth first search traversal of a graph.
-
-        EXAMPLES::
-
-            sage: g = graphs.PetersenGraph()
-            sage: g.depth_first_search(0)
-            <generator object ...depth_first_search at ...
-            sage: next(g.depth_first_search(0))
-            0
-        """
-        cdef int v_int
-
-        while self.stack:
-            v_int = self.stack.pop()
+        while ((self.direction == 0 and not self.fifo.empty())
+                or self.direction != 0 and not self.lifo.empty()):
+            if self.direction == 0:
+                v_int = self.fifo.front()
+                self.fifo.pop()
+            else:
+                v_int = self.lifo.top()
+                self.lifo.pop()
 
             if bitset_not_in(self.seen, v_int):
                 value = self.graph.vertex_label(v_int)
                 bitset_add(self.seen, v_int)
 
                 if self.test_out:
-                    self.stack.extend(self.graph.cg().out_neighbors(v_int))
+                    w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)
+                    while w_int != -1:
+                        if self.direction == 0:
+                            self.fifo.push(w_int)
+                        else:
+                            self.lifo.push(w_int)
+                        w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)
                 if self.test_in:
-                    self.stack.extend(self.in_neighbors(v_int))
+                    w_int = cg.next_in_neighbor_unsafe(v_int, -1, &l)
+                    while w_int != -1:
+                        if self.direction == 0:
+                            self.fifo.push(w_int)
+                        else:
+                            self.lifo.push(w_int)
+                        w_int = cg.next_in_neighbor_unsafe(v_int, w_int, &l)
 
                 break
         else:
@@ -4891,22 +4877,6 @@ cdef class Search_iterator:
 
         return value
 
-    def __next__(self):
-        r"""
-        Return the next vertex in a breadth first search traversal of a graph.
-
-        EXAMPLES::
-
-            sage: g = graphs.PetersenGraph()
-            sage: g.breadth_first_search(0)
-            <generator object ...breadth_first_search at ...
-            sage: next(g.breadth_first_search(0))
-            0
-        """
-        if self.direction == 0:
-            return self.next_breadth_first_search()
-        return self.next_depth_first_search()
-
 ##############################
 # Functions to simplify edge iterator.
 ##############################
```

However, as mentioned above, I need to figure out something yet for sparse graphs.

And there seems to exist no depth-first doctest for static sparse, at least not in `sage/src/sage/graphs`.



---

archive/issue_comments_440846.json:
```json
{
    "body": "<a id='comment:14'></a>Never mind my last comment. I think it is a good first step to seperate `next_breadth...` and `next_depth...` for the following reason:\n\nI don't think queue is a good implementation in the long run. The thing is, we know exactly which values things in queue can take and we don't want anything twice, so we might as well implement the queue as `int*` of length number of active vertices (one needs to realloc to segmentation fault, in case someone adds vertices while we perform the depth first search, but I assume non-optimal runtime is okay in this case).\n- And each vertex points to the next in the queue (initial value -1).\n- We need also keep track of first and last of the queue.\n- We only add a vertex to the queue, if it doesn't have a next value yet (and is not the last one).\n\nLater on, we can also report the distance easily.",
    "created_at": "2020-12-28T12:16:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440846",
    "user": "https://github.com/kliem"
}
```

<a id='comment:14'></a>Never mind my last comment. I think it is a good first step to seperate `next_breadth...` and `next_depth...` for the following reason:

I don't think queue is a good implementation in the long run. The thing is, we know exactly which values things in queue can take and we don't want anything twice, so we might as well implement the queue as `int*` of length number of active vertices (one needs to realloc to segmentation fault, in case someone adds vertices while we perform the depth first search, but I assume non-optimal runtime is okay in this case).
- And each vertex points to the next in the queue (initial value -1).
- We need also keep track of first and last of the queue.
- We only add a vertex to the queue, if it doesn't have a next value yet (and is not the last one).

Later on, we can also report the distance easily.



---

archive/issue_comments_440847.json:
```json
{
    "body": "<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-12-28T14:40:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440847",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_440848.json:
```json
{
    "body": "<a id='comment:16'></a>I rebased the branch on 9.3.beta5 and use `int*` to implement the queue. I have let the `in_neighbors` and `out_neighbors` to have a functional branch. \n\nIdeally, we should implement (un)safe iterators over the in/out neighbors of all backends. Currently, some backends have neighbor iterators that first build the list of neighbors and then iterate over that list...",
    "created_at": "2020-12-28T14:47:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440848",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:16'></a>I rebased the branch on 9.3.beta5 and use `int*` to implement the queue. I have let the `in_neighbors` and `out_neighbors` to have a functional branch. 

Ideally, we should implement (un)safe iterators over the in/out neighbors of all backends. Currently, some backends have neighbor iterators that first build the list of neighbors and then iterate over that list...



---

archive/issue_comments_440849.json:
```json
{
    "body": "<a id='comment:17'></a>Ok, I implemented `next_out_neighbor_unsafe` for static sparse graph. It doesn't accept labels, because the labels are only known to the backend.\n\nI pushed it to `u/gh-kliem/next_out_neighbor_for_static_sparse`, not yet a ticket, but with this thing you can apply my suggestion from comment:10.\n\nDoes this appear reasonable to you?\n\nBefore applying comment comment:10\n\n```\nsage: sage: def comp():  \n....:     ....:     for n in [5, 10, 50, 100, 500, 1000]:  \n....:         ....:         G = graphs.Grid2dGraph(n, n)   \n....:         ....:         print(G)   \n....:         ....:         %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=False))  \n....:         ....:         G = G.copy(sparse=True, immutable=True) \n....:         ....:         %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=False))   \n....:          \n....:                                                                                                                                 \nsage: comp()                                                                                                                          \n2D Grid Graph for [5, 5]\n8.35 \u00b5s \u00b1 36.7 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n6.46 \u00b5s \u00b1 17 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n2D Grid Graph for [10, 10]\n25.8 \u00b5s \u00b1 39 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n18.3 \u00b5s \u00b1 105 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n2D Grid Graph for [50, 50]\n796 \u00b5s \u00b1 3.01 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n605 \u00b5s \u00b1 344 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n2D Grid Graph for [100, 100]\n3.27 ms \u00b1 17.9 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n2.46 ms \u00b1 1.42 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n2D Grid Graph for [500, 500]\n104 ms \u00b1 45 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n78.4 ms \u00b1 31.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n2D Grid Graph for [1000, 1000]\n445 ms \u00b1 328 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n319 ms \u00b1 725 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\nAfter:\n\n```\nsage: comp()                                                                                                                                                                                                                                                                                                                                                               \n2D Grid Graph for [5, 5]\n6.26 \u00b5s \u00b1 14.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n5.58 \u00b5s \u00b1 8.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n2D Grid Graph for [10, 10]\n17.2 \u00b5s \u00b1 12.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n14.1 \u00b5s \u00b1 36.5 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n2D Grid Graph for [50, 50]\n484 \u00b5s \u00b1 3.59 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n388 \u00b5s \u00b1 189 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n2D Grid Graph for [100, 100]\n2.05 ms \u00b1 4.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n1.59 ms \u00b1 1.35 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n2D Grid Graph for [500, 500]\n72.9 ms \u00b1 30.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n55.4 ms \u00b1 22.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n2D Grid Graph for [1000, 1000]\n289 ms \u00b1 71.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n228 ms \u00b1 120 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\nAs mentioned, we can also easily add a method that reports the distance of the current vertex as to replace the python method. Do you want to do this here or in an extra ticket.\n\ncomment:10 can of course also be an extra ticket and then I can quickly just review this here.",
    "created_at": "2020-12-28T17:00:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440849",
    "user": "https://github.com/kliem"
}
```

<a id='comment:17'></a>Ok, I implemented `next_out_neighbor_unsafe` for static sparse graph. It doesn't accept labels, because the labels are only known to the backend.

I pushed it to `u/gh-kliem/next_out_neighbor_for_static_sparse`, not yet a ticket, but with this thing you can apply my suggestion from comment:10.

Does this appear reasonable to you?

Before applying comment comment:10

```
sage: sage: def comp():  
....:     ....:     for n in [5, 10, 50, 100, 500, 1000]:  
....:         ....:         G = graphs.Grid2dGraph(n, n)   
....:         ....:         print(G)   
....:         ....:         %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=False))  
....:         ....:         G = G.copy(sparse=True, immutable=True) 
....:         ....:         %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=False))   
....:          
....:                                                                                                                                 
sage: comp()                                                                                                                          
2D Grid Graph for [5, 5]
8.35 µs ± 36.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
6.46 µs ± 17 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
2D Grid Graph for [10, 10]
25.8 µs ± 39 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
18.3 µs ± 105 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
2D Grid Graph for [50, 50]
796 µs ± 3.01 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
605 µs ± 344 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [100, 100]
3.27 ms ± 17.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
2.46 ms ± 1.42 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
2D Grid Graph for [500, 500]
104 ms ± 45 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
78.4 ms ± 31.6 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
2D Grid Graph for [1000, 1000]
445 ms ± 328 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
319 ms ± 725 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

After:

```
sage: comp()                                                                                                                                                                                                                                                                                                                                                               
2D Grid Graph for [5, 5]
6.26 µs ± 14.6 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
5.58 µs ± 8.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
2D Grid Graph for [10, 10]
17.2 µs ± 12.3 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
14.1 µs ± 36.5 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
2D Grid Graph for [50, 50]
484 µs ± 3.59 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
388 µs ± 189 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [100, 100]
2.05 ms ± 4.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
1.59 ms ± 1.35 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [500, 500]
72.9 ms ± 30.8 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
55.4 ms ± 22.7 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
2D Grid Graph for [1000, 1000]
289 ms ± 71.7 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
228 ms ± 120 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

As mentioned, we can also easily add a method that reports the distance of the current vertex as to replace the python method. Do you want to do this here or in an extra ticket.

comment:10 can of course also be an extra ticket and then I can quickly just review this here.



---

archive/issue_comments_440850.json:
```json
{
    "body": "<a id='comment:18'></a>Btw, my idea for the queue imitation does not seem to make a difference, but for limiting the maximum memory usage. What might be simpler (and actually use less memory in some cases) is to use the standard queue implementation with the new setup for seen: Mark a vertex as seen as soon as we add it to the queue.\n\nIts appears to be all the same speed but this would avoid reinventing the wheel while still reducing the memory usage.\n\nWhen we also keep track of the current distance, we will need to change the base type for queue, but that wouldn't be a problem.\n\nAnd on some follow up ticket, we can also allow a list of vertices for the cython implementation.",
    "created_at": "2020-12-28T18:09:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440850",
    "user": "https://github.com/kliem"
}
```

<a id='comment:18'></a>Btw, my idea for the queue imitation does not seem to make a difference, but for limiting the maximum memory usage. What might be simpler (and actually use less memory in some cases) is to use the standard queue implementation with the new setup for seen: Mark a vertex as seen as soon as we add it to the queue.

Its appears to be all the same speed but this would avoid reinventing the wheel while still reducing the memory usage.

When we also keep track of the current distance, we will need to change the base type for queue, but that wouldn't be a problem.

And on some follow up ticket, we can also allow a list of vertices for the cython implementation.



---

archive/issue_comments_440851.json:
```json
{
    "body": "<a id='comment:19'></a>Feel free to modify this ticket and merge your proposals (including using queue to not reinvent the wheel). \n\nFor reporting distances, my only concern is whether we should do all in a single method or if we should design specific methods to save some tests.\n\nObserve that we can use the data structure for distances to report edges.\n\nI agree that in another ticket we can have list of vertices as input.\n\nI still think that it would be nice to have low level neighbor iterators in backends, but this is another story.",
    "created_at": "2020-12-28T18:19:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440851",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:19'></a>Feel free to modify this ticket and merge your proposals (including using queue to not reinvent the wheel). 

For reporting distances, my only concern is whether we should do all in a single method or if we should design specific methods to save some tests.

Observe that we can use the data structure for distances to report edges.

I agree that in another ticket we can have list of vertices as input.

I still think that it would be nice to have low level neighbor iterators in backends, but this is another story.



---

archive/issue_comments_440852.json:
```json
{
    "body": "<a id='comment:20'></a>Replying to [comment:19 dcoudert]:\n> [...]\n> I still think that it would be nice to have low level neighbor iterators in backends, but this is another story.\n\n\nI implemented `next_out_neighbor_unsafe` for static sparse. What do you mean by low level neighbor iterators? Python iterators?",
    "created_at": "2020-12-28T18:27:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440852",
    "user": "https://github.com/kliem"
}
```

<a id='comment:20'></a>Replying to [comment:19 dcoudert]:
> [...]
> I still think that it would be nice to have low level neighbor iterators in backends, but this is another story.


I implemented `next_out_neighbor_unsafe` for static sparse. What do you mean by low level neighbor iterators? Python iterators?



---

archive/issue_comments_440853.json:
```json
{
    "body": "<a id='comment:21'></a>currently, we use `out_neighbors`. it returns a list, and to build it, it calls `out_neighbors_unsafe` with a local array, which itself calls `next_out_neighbor_unsafe`.  When we just want to iterate over the out neighbors once, may be we can combine several operations done in `next_out_neighbor_unsafe` in a method called `out_neighbor_iterator_unsafe` that yields  out neighbors. \n\nWe are going to call directly `next_out_neighbor_unsafe`, but again, inside this method, several operations could be done only once for yielding all the out neighbors of a vertex.",
    "created_at": "2020-12-28T18:57:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440853",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:21'></a>currently, we use `out_neighbors`. it returns a list, and to build it, it calls `out_neighbors_unsafe` with a local array, which itself calls `next_out_neighbor_unsafe`.  When we just want to iterate over the out neighbors once, may be we can combine several operations done in `next_out_neighbor_unsafe` in a method called `out_neighbor_iterator_unsafe` that yields  out neighbors. 

We are going to call directly `next_out_neighbor_unsafe`, but again, inside this method, several operations could be done only once for yielding all the out neighbors of a vertex.



---

archive/issue_comments_440854.json:
```json
{
    "body": "<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-12-28T21:00:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440854",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_440855.json:
```json
{
    "body": "<a id='comment:23'></a>I only noticed now that what I suggested in comment:10 is what you have tried before on this ticket and then have fallen back.",
    "created_at": "2020-12-28T21:14:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440855",
    "user": "https://github.com/kliem"
}
```

<a id='comment:23'></a>I only noticed now that what I suggested in comment:10 is what you have tried before on this ticket and then have fallen back.



---

archive/issue_comments_440856.json:
```json
{
    "body": "<a id='comment:24'></a>Replying to [comment:21 dcoudert]:\n> currently, we use `out_neighbors`. it returns a list, and to build it, it calls `out_neighbors_unsafe` with a local array, which itself calls `next_out_neighbor_unsafe`.  When we just want to iterate over the out neighbors once, may be we can combine several operations done in `next_out_neighbor_unsafe` in a method called `out_neighbor_iterator_unsafe` that yields  out neighbors. \n> \n> We are going to call directly `next_out_neighbor_unsafe`, but again, inside this method, several operations could be done only once for yielding all the out neighbors of a vertex.\n\n\nI think `next_out_neighbor_unsafe` is a pretty good solution to make it work for all backends with one function name.\n\nI tried implementing an iterator in sparse graph and this takes twice as much (I don't know how to make it significantly faster):\n\n```diff\ndiff --git a/src/sage/graphs/base/c_graph.pyx b/src/sage/graphs/base/c_graph.pyx\nindex 63a024e37a..15b070ed7c 100644\n--- a/src/sage/graphs/base/c_graph.pyx\n+++ b/src/sage/graphs/base/c_graph.pyx\n@@ -1122,6 +1122,9 @@ cdef class CGraph:\n     cdef int next_in_neighbor_unsafe(self, int v, int u, int* l) except -2:\n         raise NotImplementedError()\n \n+    def out_neighbor_iterator_unsafe(self, int u):\n+        raise NotImplementedError\n+\n     cdef adjacency_sequence_out(self, int n, int *vertices, int v, int* sequence):\n         r\"\"\"\n         Return the adjacency sequence corresponding to a list of vertices and a\n@@ -4848,12 +4851,13 @@ cdef class Search_iterator:\n             value = self.graph.vertex_label(v_int)\n \n             if self.test_out:\n-                w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)\n-                while w_int != -1:\n+                for w_int in cg.out_neighbor_iterator_unsafe(v_int):\n+                #w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)\n+                #while w_int != -1:\n                     if bitset_not_in(self.seen, w_int):\n                         bitset_add(self.seen, w_int)\n                         self.fifo.push(w_int)\n-                    w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)\n+                    #w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)\n             if self.test_in:\n                 w_int = cg.next_in_neighbor_unsafe(v_int, -1, &l)\n                 while w_int != -1:\ndiff --git a/src/sage/graphs/base/sparse_graph.pyx b/src/sage/graphs/base/sparse_graph.pyx\nindex 19006ceb80..220fcab123 100644\n--- a/src/sage/graphs/base/sparse_graph.pyx\n+++ b/src/sage/graphs/base/sparse_graph.pyx\n@@ -191,11 +191,14 @@ for both of these uses.\n \n \n from libc.string cimport memset\n-from cysignals.memory cimport check_malloc, check_allocarray, sig_free\n+from cysignals.memory cimport check_malloc, check_realloc, check_allocarray, sig_free\n \n from sage.data_structures.bitset_base cimport *\n from sage.data_structures.bitset cimport *\n \n+cdef extern from \"Python.h\":\n+    int unlikely(int) nogil  # Defined by Cython\n+\n cdef enum:\n     BT_REORDERING_CONSTANT = 145533211\n     # Since the binary tree will often see vertices coming in already sorted,\n@@ -706,6 +709,37 @@ cdef class SparseGraph(CGraph):\n             return temp\n         return NULL\n \n+    def out_neighbor_iterator_unsafe(self, int u):\n+        cdef int i\n+        cdef SparseGraphBTNode* v\n+        cdef SparseGraphBTNode** lifo = <SparseGraphBTNode**> check_malloc(2*self.hash_length*sizeof(SparseGraphBTNode*))\n+        cdef int lifo_index = 0\n+        cdef size_t lifo_size = self.hash_length*2\n+\n+        for i in range(u * self.hash_length, (u+1) * self.hash_length):\n+            if not self.vertices[i]:\n+                continue\n+            lifo[lifo_index] = self.vertices[i]\n+            lifo_index += 1\n+\n+        while lifo_index:\n+            lifo_index -= 1\n+            v = lifo[lifo_index]\n+            if unlikely(lifo_size < lifo_index + 2):\n+                lifo = <SparseGraphBTNode**> check_realloc(lifo, 2*lifo_size*sizeof(SparseGraphBTNode*))\n+                lifo_size *= 2\n+\n+            if v.left:\n+                lifo[lifo_index] = v.left\n+                lifo_index += 1\n+            if v.right:\n+                lifo[lifo_index] = v.right\n+                lifo_index += 1\n+            yield v.vertex\n+\n+\n+        sig_free(lifo)\n```\n\nIt is a python function after all.\n\nThe advantage of creating the list of all neighbors is that we need less often to traverse the tree of neighbors. However, for a sparse graph, this should usually be a very fast operation. This seems to be the only thing that can be improved in `next_out_neighbor` for sparse graphs (and I don't see anything for dense graphs at all).",
    "created_at": "2020-12-28T22:47:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440856",
    "user": "https://github.com/kliem"
}
```

<a id='comment:24'></a>Replying to [comment:21 dcoudert]:
> currently, we use `out_neighbors`. it returns a list, and to build it, it calls `out_neighbors_unsafe` with a local array, which itself calls `next_out_neighbor_unsafe`.  When we just want to iterate over the out neighbors once, may be we can combine several operations done in `next_out_neighbor_unsafe` in a method called `out_neighbor_iterator_unsafe` that yields  out neighbors. 
> 
> We are going to call directly `next_out_neighbor_unsafe`, but again, inside this method, several operations could be done only once for yielding all the out neighbors of a vertex.


I think `next_out_neighbor_unsafe` is a pretty good solution to make it work for all backends with one function name.

I tried implementing an iterator in sparse graph and this takes twice as much (I don't know how to make it significantly faster):

```diff
diff --git a/src/sage/graphs/base/c_graph.pyx b/src/sage/graphs/base/c_graph.pyx
index 63a024e37a..15b070ed7c 100644
--- a/src/sage/graphs/base/c_graph.pyx
+++ b/src/sage/graphs/base/c_graph.pyx
@@ -1122,6 +1122,9 @@ cdef class CGraph:
     cdef int next_in_neighbor_unsafe(self, int v, int u, int* l) except -2:
         raise NotImplementedError()
 
+    def out_neighbor_iterator_unsafe(self, int u):
+        raise NotImplementedError
+
     cdef adjacency_sequence_out(self, int n, int *vertices, int v, int* sequence):
         r"""
         Return the adjacency sequence corresponding to a list of vertices and a
@@ -4848,12 +4851,13 @@ cdef class Search_iterator:
             value = self.graph.vertex_label(v_int)
 
             if self.test_out:
-                w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)
-                while w_int != -1:
+                for w_int in cg.out_neighbor_iterator_unsafe(v_int):
+                #w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)
+                #while w_int != -1:
                     if bitset_not_in(self.seen, w_int):
                         bitset_add(self.seen, w_int)
                         self.fifo.push(w_int)
-                    w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)
+                    #w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)
             if self.test_in:
                 w_int = cg.next_in_neighbor_unsafe(v_int, -1, &l)
                 while w_int != -1:
diff --git a/src/sage/graphs/base/sparse_graph.pyx b/src/sage/graphs/base/sparse_graph.pyx
index 19006ceb80..220fcab123 100644
--- a/src/sage/graphs/base/sparse_graph.pyx
+++ b/src/sage/graphs/base/sparse_graph.pyx
@@ -191,11 +191,14 @@ for both of these uses.
 
 
 from libc.string cimport memset
-from cysignals.memory cimport check_malloc, check_allocarray, sig_free
+from cysignals.memory cimport check_malloc, check_realloc, check_allocarray, sig_free
 
 from sage.data_structures.bitset_base cimport *
 from sage.data_structures.bitset cimport *
 
+cdef extern from "Python.h":
+    int unlikely(int) nogil  # Defined by Cython
+
 cdef enum:
     BT_REORDERING_CONSTANT = 145533211
     # Since the binary tree will often see vertices coming in already sorted,
@@ -706,6 +709,37 @@ cdef class SparseGraph(CGraph):
             return temp
         return NULL
 
+    def out_neighbor_iterator_unsafe(self, int u):
+        cdef int i
+        cdef SparseGraphBTNode* v
+        cdef SparseGraphBTNode** lifo = <SparseGraphBTNode**> check_malloc(2*self.hash_length*sizeof(SparseGraphBTNode*))
+        cdef int lifo_index = 0
+        cdef size_t lifo_size = self.hash_length*2
+
+        for i in range(u * self.hash_length, (u+1) * self.hash_length):
+            if not self.vertices[i]:
+                continue
+            lifo[lifo_index] = self.vertices[i]
+            lifo_index += 1
+
+        while lifo_index:
+            lifo_index -= 1
+            v = lifo[lifo_index]
+            if unlikely(lifo_size < lifo_index + 2):
+                lifo = <SparseGraphBTNode**> check_realloc(lifo, 2*lifo_size*sizeof(SparseGraphBTNode*))
+                lifo_size *= 2
+
+            if v.left:
+                lifo[lifo_index] = v.left
+                lifo_index += 1
+            if v.right:
+                lifo[lifo_index] = v.right
+                lifo_index += 1
+            yield v.vertex
+
+
+        sig_free(lifo)
```

It is a python function after all.

The advantage of creating the list of all neighbors is that we need less often to traverse the tree of neighbors. However, for a sparse graph, this should usually be a very fast operation. This seems to be the only thing that can be improved in `next_out_neighbor` for sparse graphs (and I don't see anything for dense graphs at all).



---

archive/issue_comments_440857.json:
```json
{
    "body": "<a id='comment:25'></a>Then we should let this for another ticket. Further cleaning / improvements / implications in the backends may lead to other / faster solutions.",
    "created_at": "2020-12-29T00:16:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440857",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:25'></a>Then we should let this for another ticket. Further cleaning / improvements / implications in the backends may lead to other / faster solutions.



---

archive/issue_comments_440858.json:
```json
{
    "body": "<a id='comment:26'></a>I'm happy with the ticket.",
    "created_at": "2020-12-29T08:21:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440858",
    "user": "https://github.com/kliem"
}
```

<a id='comment:26'></a>I'm happy with the ticket.



---

archive/issue_comments_440859.json:
```json
{
    "body": "<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-12-29T08:41:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440859",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_440860.json:
```json
{
    "body": "<a id='comment:28'></a>Inlining makes a difference. More than 10 percent for any of those test instances.\n\nPlease update the timings in the ticket description.",
    "created_at": "2020-12-29T08:43:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440860",
    "user": "https://github.com/kliem"
}
```

<a id='comment:28'></a>Inlining makes a difference. More than 10 percent for any of those test instances.

Please update the timings in the ticket description.



---

archive/issue_comments_440861.json:
```json
{
    "body": "<a id='comment:30'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-12-29T11:56:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440861",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:30'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_440862.json:
```json
{
    "body": "<a id='comment:31'></a>There was an error in method ` next_in_neighbor_unsafe` of `static_sparse_backend.pyx`:\n\n```diff\n-        cdef int degree = self.g_rev.neighbors[u+1] - self.g.neighbors[u]\n+        cdef int degree = self.g_rev.neighbors[u+1] - self.g_rev.neighbors[u]\n```\nThe segfaults reported by the patchbot for #31129 are all due to this error.\n\nI changed to the safer / cleaner version\n\n```diff\n-        cdef int degree = self.g_rev.neighbors[u+1] - self.g.neighbors[u]\n+        cdef int degree = out_degree(self.g_rev, u)\n```",
    "created_at": "2020-12-29T11:57:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440862",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:31'></a>There was an error in method ` next_in_neighbor_unsafe` of `static_sparse_backend.pyx`:

```diff
-        cdef int degree = self.g_rev.neighbors[u+1] - self.g.neighbors[u]
+        cdef int degree = self.g_rev.neighbors[u+1] - self.g_rev.neighbors[u]
```
The segfaults reported by the patchbot for #31129 are all due to this error.

I changed to the safer / cleaner version

```diff
-        cdef int degree = self.g_rev.neighbors[u+1] - self.g.neighbors[u]
+        cdef int degree = out_degree(self.g_rev, u)
```



---

archive/issue_comments_440863.json:
```json
{
    "body": "<a id='comment:32'></a>We now have green bot. If you agree, we can set this ticket to positive review. We have significant improvements !",
    "created_at": "2020-12-29T16:59:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440863",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:32'></a>We now have green bot. If you agree, we can set this ticket to positive review. We have significant improvements !



---

archive/issue_comments_440864.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-12-29T21:10:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440864",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_440865.json:
```json
{
    "body": "<a id='comment:33'></a>Yes, I agree.",
    "created_at": "2020-12-29T21:10:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440865",
    "user": "https://github.com/kliem"
}
```

<a id='comment:33'></a>Yes, I agree.



---

archive/issue_comments_440866.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2021-01-03T12:15:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31117#issuecomment-440866",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_081295.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-01-03T12:15:16Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/31117",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31117#event-81295"
}
```
