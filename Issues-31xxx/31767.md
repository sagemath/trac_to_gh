# Issue 31767: Enhanced checks for sign() with qqbar elements with addition and subtraction

archive/issues_031530.json:
```json
{
    "assignees": [],
    "body": "<div id=\"comment:0\"></div>\n\nThe following are painfully slow:\n\n```\nsage: x1 = AA(2^(1/100))\nsage: x2 = AA(2^(1/100))\nsage: y = x1 - x2\nsage: z = x1 - x2\nsage: y == y\nsage: y == 0\nsage: y == z\n```\nNote that for testing, you need to recreate `y` before each comparison as otherwise it has been made exact.\n\nWe avoid computing the minimum polynomial (as it calls `exactify()`) in the rich comparison until we need to. We also avoid calling `exactify()` for a binary operation in `sign()` until we absolutely need to. Additionally, the identity test is not done before reaching `_richcmp_`.\n\nCC:  @videlec @mezzarobba @mwageringel @fredrik-johansson @saraedum @slel\n\nComponent: **performance**\n\nKeywords: **qqbar**\n\nAuthor: **Travis Scrimshaw**\n\nBranch/Commit: **[`642b7c2`](https://github.com/sagemath/sagetrac-mirror/commit/642b7c2adc0d2a54c1097eb1cf923bb2e648df0f)**\n\nReviewer: **Vincent Delecroix, Sebastian Oehms**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/31767_\n\n",
    "closed_at": "2021-06-19T20:57:50Z",
    "created_at": "2021-05-03T01:37:39Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/performance",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.4",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Enhanced checks for sign() with qqbar elements with addition and subtraction",
    "type": "issue",
    "updated_at": "2021-06-19T20:57:50Z",
    "url": "https://github.com/sagemath/sage/issues/31767",
    "user": "https://github.com/tscrim"
}
```
<div id="comment:0"></div>

The following are painfully slow:

```
sage: x1 = AA(2^(1/100))
sage: x2 = AA(2^(1/100))
sage: y = x1 - x2
sage: z = x1 - x2
sage: y == y
sage: y == 0
sage: y == z
```
Note that for testing, you need to recreate `y` before each comparison as otherwise it has been made exact.

We avoid computing the minimum polynomial (as it calls `exactify()`) in the rich comparison until we need to. We also avoid calling `exactify()` for a binary operation in `sign()` until we absolutely need to. Additionally, the identity test is not done before reaching `_richcmp_`.

CC:  @videlec @mezzarobba @mwageringel @fredrik-johansson @saraedum @slel

Component: **performance**

Keywords: **qqbar**

Author: **Travis Scrimshaw**

Branch/Commit: **[`642b7c2`](https://github.com/sagemath/sagetrac-mirror/commit/642b7c2adc0d2a54c1097eb1cf923bb2e648df0f)**

Reviewer: **Vincent Delecroix, Sebastian Oehms**

_Issue created by migration from https://trac.sagemath.org/ticket/31767_





---

archive/issue_events_434977.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2021-05-03T01:37:39Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31767#event-434977"
}
```



---

archive/issue_events_434978.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2021-05-03T01:37:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "label": "https://github.com/sagemath/sage/labels/performance",
    "label_color": "696969",
    "label_name": "performance",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31767#event-434978"
}
```



---

archive/issue_events_434979.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2021-05-03T01:37:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31767#event-434979"
}
```



---

archive/issue_events_434980.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2021-05-03T01:37:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31767#event-434980"
}
```



---

archive/issue_comments_510863.json:
```json
{
    "body": "Branch: **[public/performance/qqbar_sign-31767](https://github.com/sagemath/sagetrac-mirror/tree/public/performance/qqbar_sign-31767)**",
    "created_at": "2021-05-03T01:59:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510863",
    "user": "https://github.com/tscrim"
}
```

Branch: **[public/performance/qqbar_sign-31767](https://github.com/sagemath/sagetrac-mirror/tree/public/performance/qqbar_sign-31767)**



---

archive/issue_comments_510864.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nI have not run any timings on this, but things to check for speed regressions would be low degree minimal polynomials. Suggestions for good timing tests would be useful.\n\nI don't completely understand why I need to update some of the test for the eigenvalues, but the real precision seems to have significantly improved. So there might be some other doctests that need fixing; waiting for the patchbot.\n\nI also took the change to mark a test as `# long time` that was taking nearly 2 seconds on my computer.\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fc64ba2ec7d3337e2799fc57f78dcbb30dfa0fe7\"><code>fc64ba2</code></a></td><td><code>Improvements to sign() and comparisons for qqbar elements.</code></td></tr></table>\n",
    "created_at": "2021-05-03T01:59:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510864",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:1" align="right">comment:1</div>

I have not run any timings on this, but things to check for speed regressions would be low degree minimal polynomials. Suggestions for good timing tests would be useful.

I don't completely understand why I need to update some of the test for the eigenvalues, but the real precision seems to have significantly improved. So there might be some other doctests that need fixing; waiting for the patchbot.

I also took the change to mark a test as `# long time` that was taking nearly 2 seconds on my computer.

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fc64ba2ec7d3337e2799fc57f78dcbb30dfa0fe7"><code>fc64ba2</code></a></td><td><code>Improvements to sign() and comparisons for qqbar elements.</code></td></tr></table>




---

archive/issue_events_434981.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2021-05-03T01:59:14Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31767#event-434981"
}
```



---

archive/issue_comments_510865.json:
```json
{
    "body": "Commit: **[`fc64ba2`](https://github.com/sagemath/sagetrac-mirror/commit/fc64ba2ec7d3337e2799fc57f78dcbb30dfa0fe7)**",
    "created_at": "2021-05-03T01:59:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510865",
    "user": "https://github.com/tscrim"
}
```

Commit: **[`fc64ba2`](https://github.com/sagemath/sagetrac-mirror/commit/fc64ba2ec7d3337e2799fc57f78dcbb30dfa0fe7)**



---

archive/issue_comments_510866.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nSee also #31768 for a followup subclassing `ANUnaryExpr` for some finer control and trivial simplifications.",
    "created_at": "2021-05-03T03:37:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510866",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:2" align="right">comment:2</div>

See also #31768 for a followup subclassing `ANUnaryExpr` for some finer control and trivial simplifications.



---

archive/issue_comments_510867.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nThis proposal looks good to me but\n\n```\n+            # Rationals\n+            if type(sd._left._descr) is ANRational and type(sd._right._descr) is ANRational:\n+                ret = sd._op(sd._left._descr._value, sd._right._descr._value)\n+                if ret == 0:\n+                    self._set_descr(ANRational(QQ.zero()))\n+                    return 0\n+                return ret.sign()\n```\nDo you have an instance where the above code path is used? When both operands are rationals the descriptor should be automatically updated. We don't want to repeat this block in all possible places `cmp`, `sign`, `_add_`, ...\n\nReplying to [@tscrim](#comment%3A1):\n> I have not run any timings on this, but things to check for speed regressions would be low degree minimal polynomials. Suggestions for good timing tests would be useful.\n> \n> I don't completely understand why I need to update some of the test for the eigenvalues, but the real precision seems to have significantly improved. So there might be some other doctests that need fixing; waiting for the patchbot.\n\nWhen precision increases it is typically that more enclosure refinement occurred. With the new code it looks to me that we should have less refinement. If my diagnostic is correct, this is bad. Would be nice to check what are the diameters of the intervals before and after the change.",
    "created_at": "2021-05-03T06:34:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510867",
    "user": "https://github.com/videlec"
}
```

<div id="comment:3" align="right">comment:3</div>

This proposal looks good to me but

```
+            # Rationals
+            if type(sd._left._descr) is ANRational and type(sd._right._descr) is ANRational:
+                ret = sd._op(sd._left._descr._value, sd._right._descr._value)
+                if ret == 0:
+                    self._set_descr(ANRational(QQ.zero()))
+                    return 0
+                return ret.sign()
```
Do you have an instance where the above code path is used? When both operands are rationals the descriptor should be automatically updated. We don't want to repeat this block in all possible places `cmp`, `sign`, `_add_`, ...

Replying to [@tscrim](#comment%3A1):
> I have not run any timings on this, but things to check for speed regressions would be low degree minimal polynomials. Suggestions for good timing tests would be useful.
> 
> I don't completely understand why I need to update some of the test for the eigenvalues, but the real precision seems to have significantly improved. So there might be some other doctests that need fixing; waiting for the patchbot.

When precision increases it is typically that more enclosure refinement occurred. With the new code it looks to me that we should have less refinement. If my diagnostic is correct, this is bad. Would be nice to check what are the diameters of the intervals before and after the change.



---

archive/issue_comments_510868.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nReplying to [@videlec](#comment%3A3):\n> This proposal looks good to me but\n> \n> ```\n> +            # Rationals\n> +            if type(sd._left._descr) is ANRational and type(sd._right._descr) is ANRational:\n> +                ret = sd._op(sd._left._descr._value, sd._right._descr._value)\n> +                if ret == 0:\n> +                    self._set_descr(ANRational(QQ.zero()))\n> +                    return 0\n> +                return ret.sign()\n> ```\n> Do you have an instance where the above code path is used? When both operands are rationals the descriptor should be automatically updated. We don't want to repeat this block in all possible places `cmp`, `sign`, `_add_`, ...\n\nThis is occurring after a call to `exactify()`. Thus, we could have something that ends up being a rational that didn't know it before. For example, `b = a - (a + 1)` for some irrational `a`, then taking `b + 1 == 0`). Adding a `print(\"rat check\")` just after the `if` statement gives:\n\n```sage\nsage: a = AA(sqrt(2))\nsage: b = a - (a + 1)\nsage: (b + 1).sign()\nrat check\n0\n```\nI will add this as a test and push. I also need to figure out why the test in `src/sage/geometry/polyhedron/backend_field.py` is failing too...\n\n> Replying to [@tscrim](#comment%3A1):\n> > I have not run any timings on this, but things to check for speed regressions would be low degree minimal polynomials. Suggestions for good timing tests would be useful.\n> > \n> > I don't completely understand why I need to update some of the test for the eigenvalues, but the real precision seems to have significantly improved. So there might be some other doctests that need fixing; waiting for the patchbot.\n> \n> \n> When precision increases it is typically that more enclosure refinement occurred. With the new code it looks to me that we should have less refinement. If my diagnostic is correct, this is bad. Would be nice to check what are the diameters of the intervals before and after the change.\n\nHere is what is happening. Because we are sorting the (complex) roots, we compare things lex on the `(real, imag)` pair. Eventually it has to check that the real parts of the two numbers are not equal (see `case 3:`). This calls the real `_richcmp_` method. In here, before it computed the `minpoly()` (which called `exactify()` of the treal parts), whereas now only gets the minpoly if they are known, so it first tries the refinement before ultimately ended up calling `exactify()` (as both are supposed to actually be 0). This gets called when comparing these roots with a root that is explicitly known with a real part of 0.\n\nI don't think this is a bad thing as I believe the refinement is a relatively fast operation, especially if we ultimately compute `exactify()` on most elements. Also, getting rid of calls to `exactify()` in cases when it is not needed is a larger benefit IMO. However, some more actual use-cases could be useful here for testing timings.",
    "created_at": "2021-05-04T03:03:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510868",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:4" align="right">comment:4</div>

Replying to [@videlec](#comment%3A3):
> This proposal looks good to me but
> 
> ```
> +            # Rationals
> +            if type(sd._left._descr) is ANRational and type(sd._right._descr) is ANRational:
> +                ret = sd._op(sd._left._descr._value, sd._right._descr._value)
> +                if ret == 0:
> +                    self._set_descr(ANRational(QQ.zero()))
> +                    return 0
> +                return ret.sign()
> ```
> Do you have an instance where the above code path is used? When both operands are rationals the descriptor should be automatically updated. We don't want to repeat this block in all possible places `cmp`, `sign`, `_add_`, ...

This is occurring after a call to `exactify()`. Thus, we could have something that ends up being a rational that didn't know it before. For example, `b = a - (a + 1)` for some irrational `a`, then taking `b + 1 == 0`). Adding a `print("rat check")` just after the `if` statement gives:

```sage
sage: a = AA(sqrt(2))
sage: b = a - (a + 1)
sage: (b + 1).sign()
rat check
0
```
I will add this as a test and push. I also need to figure out why the test in `src/sage/geometry/polyhedron/backend_field.py` is failing too...

> Replying to [@tscrim](#comment%3A1):
> > I have not run any timings on this, but things to check for speed regressions would be low degree minimal polynomials. Suggestions for good timing tests would be useful.
> > 
> > I don't completely understand why I need to update some of the test for the eigenvalues, but the real precision seems to have significantly improved. So there might be some other doctests that need fixing; waiting for the patchbot.
> 
> 
> When precision increases it is typically that more enclosure refinement occurred. With the new code it looks to me that we should have less refinement. If my diagnostic is correct, this is bad. Would be nice to check what are the diameters of the intervals before and after the change.

Here is what is happening. Because we are sorting the (complex) roots, we compare things lex on the `(real, imag)` pair. Eventually it has to check that the real parts of the two numbers are not equal (see `case 3:`). This calls the real `_richcmp_` method. In here, before it computed the `minpoly()` (which called `exactify()` of the treal parts), whereas now only gets the minpoly if they are known, so it first tries the refinement before ultimately ended up calling `exactify()` (as both are supposed to actually be 0). This gets called when comparing these roots with a root that is explicitly known with a real part of 0.

I don't think this is a bad thing as I believe the refinement is a relatively fast operation, especially if we ultimately compute `exactify()` on most elements. Also, getting rid of calls to `exactify()` in cases when it is not needed is a larger benefit IMO. However, some more actual use-cases could be useful here for testing timings.



---

archive/issue_comments_510869.json:
```json
{
    "body": "<div id=\"comment:5\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b069b81e5e5fc26b917f22eef825e5746f5510fb\"><code>b069b81</code></a></td><td><code>Fixing bug with addition x + (-x), adding doctests, removing redundancy.</code></td></tr></table>\n",
    "created_at": "2021-05-04T05:37:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510869",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:5"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b069b81e5e5fc26b917f22eef825e5746f5510fb"><code>b069b81</code></a></td><td><code>Fixing bug with addition x + (-x), adding doctests, removing redundancy.</code></td></tr></table>




---

archive/issue_comments_510870.json:
```json
{
    "body": "Changed commit from **[`fc64ba2`](https://github.com/sagemath/sagetrac-mirror/commit/fc64ba2ec7d3337e2799fc57f78dcbb30dfa0fe7)** to **[`b069b81`](https://github.com/sagemath/sagetrac-mirror/commit/b069b81e5e5fc26b917f22eef825e5746f5510fb)**",
    "created_at": "2021-05-04T05:37:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510870",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`fc64ba2`](https://github.com/sagemath/sagetrac-mirror/commit/fc64ba2ec7d3337e2799fc57f78dcbb30dfa0fe7)** to **[`b069b81`](https://github.com/sagemath/sagetrac-mirror/commit/b069b81e5e5fc26b917f22eef825e5746f5510fb)**



---

archive/issue_comments_510871.json:
```json
{
    "body": "Changed commit from **[`b069b81`](https://github.com/sagemath/sagetrac-mirror/commit/b069b81e5e5fc26b917f22eef825e5746f5510fb)** to **[`3b8e217`](https://github.com/sagemath/sagetrac-mirror/commit/3b8e217e54446b5cf6d7a3a18770fe4455f4cc94)**",
    "created_at": "2021-05-04T06:01:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510871",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`b069b81`](https://github.com/sagemath/sagetrac-mirror/commit/b069b81e5e5fc26b917f22eef825e5746f5510fb)** to **[`3b8e217`](https://github.com/sagemath/sagetrac-mirror/commit/3b8e217e54446b5cf6d7a3a18770fe4455f4cc94)**



---

archive/issue_comments_510872.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3b8e217e54446b5cf6d7a3a18770fe4455f4cc94\"><code>3b8e217</code></a></td><td><code>Removing one other redundancy.</code></td></tr></table>\n",
    "created_at": "2021-05-04T06:01:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510872",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:6"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3b8e217e54446b5cf6d7a3a18770fe4455f4cc94"><code>3b8e217</code></a></td><td><code>Removing one other redundancy.</code></td></tr></table>




---

archive/issue_comments_510873.json:
```json
{
    "body": "Changed commit from **[`3b8e217`](https://github.com/sagemath/sagetrac-mirror/commit/3b8e217e54446b5cf6d7a3a18770fe4455f4cc94)** to **[`5da8b27`](https://github.com/sagemath/sagetrac-mirror/commit/5da8b2774eb2e024cc7a850789e1ed1a6816d354)**",
    "created_at": "2021-05-04T06:06:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510873",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`3b8e217`](https://github.com/sagemath/sagetrac-mirror/commit/3b8e217e54446b5cf6d7a3a18770fe4455f4cc94)** to **[`5da8b27`](https://github.com/sagemath/sagetrac-mirror/commit/5da8b2774eb2e024cc7a850789e1ed1a6816d354)**



---

archive/issue_comments_510874.json:
```json
{
    "body": "<div id=\"comment:7\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5da8b2774eb2e024cc7a850789e1ed1a6816d354\"><code>5da8b27</code></a></td><td><code>Removing same redundant checks for the QQbar elements.</code></td></tr></table>\n",
    "created_at": "2021-05-04T06:06:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510874",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:7"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5da8b2774eb2e024cc7a850789e1ed1a6816d354"><code>5da8b27</code></a></td><td><code>Removing same redundant checks for the QQbar elements.</code></td></tr></table>




---

archive/issue_comments_510875.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nI have fixed a bug with addition `x + (-x)` giving the wrong sign. This was the issue with `backend_field.py`. I added in a few other doctests and removed some redundant checks.\n\nI just don't know how much this will affect timings refining the precision instead of calling the `exactify()` via the `minpoly()`. Something else that might be useful is adding a way to compute the `minpoly` without computing `exactify()` for elements that have an idea about what their `minpoly` is. Mainly here I am thinking elements using `ANRoot`. We could also fashion something that passes around the `minpoly` when we do operations that preserve it, such as conjugation. This can be done on a separate ticket. What do you think?",
    "created_at": "2021-05-04T06:11:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510875",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:8" align="right">comment:8</div>

I have fixed a bug with addition `x + (-x)` giving the wrong sign. This was the issue with `backend_field.py`. I added in a few other doctests and removed some redundant checks.

I just don't know how much this will affect timings refining the precision instead of calling the `exactify()` via the `minpoly()`. Something else that might be useful is adding a way to compute the `minpoly` without computing `exactify()` for elements that have an idea about what their `minpoly` is. Mainly here I am thinking elements using `ANRoot`. We could also fashion something that passes around the `minpoly` when we do operations that preserve it, such as conjugation. This can be done on a separate ticket. What do you think?



---

archive/issue_comments_510876.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nReplying to [@tscrim](#comment%3A8):\n> I have fixed a bug with addition `x + (-x)` giving the wrong sign. This was the issue with `backend_field.py`. I added in a few other doctests and removed some redundant checks.\n>\n>\n> I just don't know how much this will affect timings refining the precision instead of calling the `exactify()` via the `minpoly()`. Something else that might be useful is adding a way to compute the `minpoly` without computing `exactify()` for elements that have an idea about what their `minpoly` is. Mainly here I am thinking elements using `ANRoot`. We could also fashion something that passes around the `minpoly` when we do operations that preserve it, such as conjugation. This can be done on a separate ticket. What do you think?\n\nComputing minpoly is doable and desirable for all descriptors without exactification. This is the reason why was introduced the function `composed_op` on polynomials\n\n```\nsage: x = polygen(QQ)\nsage: p = x^3 + 2*x - 1\nsage: q = x^3 - x + 3\nsage: a = p.roots(QQbar, multiplicities=False)[0]\nsage: b = q.roots(QQbar, multiplicities=False)[0]\nsage: r = p.composed_op(q, operator.add)\nsage: r(a + b)  # not necessary minpoly, but at least a multiple\n0.?e-15\n```\n\nMore generally, I think that QQbar elements beyond degree 8 (let say) should not try to find a reasonable representation of the number field they represent (what is exactify currently doing via `polred` which is costly). They should just be considered as the root of some irreducible polynomial. Computing minpoly of `a + b`, `abs(a)`, etc is doable.\n\nThough, all this logic is now in [Fredrik's calcium](https://fredrikj.net/calcium/) and I am not sure how much it is desirable to improve the version in Sage compared to having a calcium version of `AA`/`QQbar`.",
    "created_at": "2021-05-04T07:20:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510876",
    "user": "https://github.com/videlec"
}
```

<div id="comment:9" align="right">comment:9</div>

Replying to [@tscrim](#comment%3A8):
> I have fixed a bug with addition `x + (-x)` giving the wrong sign. This was the issue with `backend_field.py`. I added in a few other doctests and removed some redundant checks.
>
>
> I just don't know how much this will affect timings refining the precision instead of calling the `exactify()` via the `minpoly()`. Something else that might be useful is adding a way to compute the `minpoly` without computing `exactify()` for elements that have an idea about what their `minpoly` is. Mainly here I am thinking elements using `ANRoot`. We could also fashion something that passes around the `minpoly` when we do operations that preserve it, such as conjugation. This can be done on a separate ticket. What do you think?

Computing minpoly is doable and desirable for all descriptors without exactification. This is the reason why was introduced the function `composed_op` on polynomials

```
sage: x = polygen(QQ)
sage: p = x^3 + 2*x - 1
sage: q = x^3 - x + 3
sage: a = p.roots(QQbar, multiplicities=False)[0]
sage: b = q.roots(QQbar, multiplicities=False)[0]
sage: r = p.composed_op(q, operator.add)
sage: r(a + b)  # not necessary minpoly, but at least a multiple
0.?e-15
```

More generally, I think that QQbar elements beyond degree 8 (let say) should not try to find a reasonable representation of the number field they represent (what is exactify currently doing via `polred` which is costly). They should just be considered as the root of some irreducible polynomial. Computing minpoly of `a + b`, `abs(a)`, etc is doable.

Though, all this logic is now in [Fredrik's calcium](https://fredrikj.net/calcium/) and I am not sure how much it is desirable to improve the version in Sage compared to having a calcium version of `AA`/`QQbar`.



---

archive/issue_comments_510877.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nReplying to [@tscrim](#comment%3A1):\n> New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fc64ba2ec7d3337e2799fc57f78dcbb30dfa0fe7\"><code>fc64ba2</code></a></td><td><code>Improvements to sign() and comparisons for qqbar elements.</code></td></tr></table>\n\nWhy not use (good enough refinements of) approximate values to compute the sign of x-y when x and y are known to have different minimal polynomials? (cf. https://groups.google.com/g/sage-devel/c/OaUlf5VHBbc/m/doZC1KpMBAAJ )",
    "created_at": "2021-05-04T12:06:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510877",
    "user": "https://github.com/Ilia-Smilga"
}
```

<div id="comment:10" align="right">comment:10</div>

Replying to [@tscrim](#comment%3A1):
> New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fc64ba2ec7d3337e2799fc57f78dcbb30dfa0fe7"><code>fc64ba2</code></a></td><td><code>Improvements to sign() and comparisons for qqbar elements.</code></td></tr></table>

Why not use (good enough refinements of) approximate values to compute the sign of x-y when x and y are known to have different minimal polynomials? (cf. https://groups.google.com/g/sage-devel/c/OaUlf5VHBbc/m/doZC1KpMBAAJ )



---

archive/issue_comments_510878.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\ncomment:9: I agree that it is better to not invest a lot of time in improving `AA`/`QQbar` since it will almost certainly be replaced by Calcium. However, I think we can do a few improvements around the current code, and some of these changes might still be applicable once we switch the backend over (unlike, say, #31768). Perhaps we can include the current patch, maybe I will do a followup to try and lessen the impact of the changes.\n\nFredrik, do you have any comments about this?\n\ncomment:10: Once you have different minimal polynomials, then I believe you essentially have everything. Perhaps I have misunderstood something?\n\nGreen patchbot (the pyflakes warning existed before this ticket).",
    "created_at": "2021-05-05T01:55:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510878",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:11" align="right">comment:11</div>

comment:9: I agree that it is better to not invest a lot of time in improving `AA`/`QQbar` since it will almost certainly be replaced by Calcium. However, I think we can do a few improvements around the current code, and some of these changes might still be applicable once we switch the backend over (unlike, say, #31768). Perhaps we can include the current patch, maybe I will do a followup to try and lessen the impact of the changes.

Fredrik, do you have any comments about this?

comment:10: Once you have different minimal polynomials, then I believe you essentially have everything. Perhaps I have misunderstood something?

Green patchbot (the pyflakes warning existed before this ticket).



---

archive/issue_comments_510879.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nActually, to construct a better refinement of `a + b` knowing the minimal polynomials `m_a(x)` and `m_b(x)` there are at least two strategies\n- compute `m_{a+b}(x)` (eg via `composed_op`) and do refinement with it\n- compute better refinement of `a` and `b` and add them\nDepending on `deg(m_a)`, `deg(m_b)`, `deg(m_{a+b})` it might be better to use the second option.",
    "created_at": "2021-05-05T06:39:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510879",
    "user": "https://github.com/videlec"
}
```

<div id="comment:12" align="right">comment:12</div>

Actually, to construct a better refinement of `a + b` knowing the minimal polynomials `m_a(x)` and `m_b(x)` there are at least two strategies
- compute `m_{a+b}(x)` (eg via `composed_op`) and do refinement with it
- compute better refinement of `a` and `b` and add them
Depending on `deg(m_a)`, `deg(m_b)`, `deg(m_{a+b})` it might be better to use the second option.



---

archive/issue_comments_510880.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nTo compare (the real parts of) two qqbars in Calcium, I just compare enclosures at a couple of different levels of precision, otherwise do an exact subtraction and check the sign of the difference. Most of the work will then be in the subtraction (which factors the resultant polynomial and then refines the precision of the inputs if needed to get the right root). This is not really optimized, but so far it has not been a bottleneck that I needed to fix. In fact, this issue reminds me that I did not even optimize for both inputs being real, in which case it will suffice to increase the precision until convergence...\n\nMore generally, it's an interesting problem to optimize computing sign(a1+a2+...+an) or proving a1+a2+...+an == 0 without computing the entire sum explicitly.",
    "created_at": "2021-05-05T08:31:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510880",
    "user": "https://github.com/fredrik-johansson"
}
```

<div id="comment:13" align="right">comment:13</div>

To compare (the real parts of) two qqbars in Calcium, I just compare enclosures at a couple of different levels of precision, otherwise do an exact subtraction and check the sign of the difference. Most of the work will then be in the subtraction (which factors the resultant polynomial and then refines the precision of the inputs if needed to get the right root). This is not really optimized, but so far it has not been a bottleneck that I needed to fix. In fact, this issue reminds me that I did not even optimize for both inputs being real, in which case it will suffice to increase the precision until convergence...

More generally, it's an interesting problem to optimize computing sign(a1+a2+...+an) or proving a1+a2+...+an == 0 without computing the entire sum explicitly.



---

archive/issue_comments_510881.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nReplying to [@tscrim](#comment%3A11):\n> comment:10: Once you have different minimal polynomials, then I believe you essentially have everything. Perhaps I have misunderstood something?\n\nConsider the following computation:\n\n```\nx = AA(1+100*2^(-1000))^(1/100)\ny = AA(1+101*2^(-1000))^(1/101)\nx < y\n```\n(which calls `sign(y-x)` internally). With your patch (if I read it correctly; I did not actually run it), Sage will notice that the minimal polynomials are different, but will not take advantage of that information. It will still trigger exact computation of `y-x` (which takes forever). \n\nI suggest adding for this case (different minimal polynomials) the code\n\n```\nwhile self._value.contains_zero():\n    self._more_precision()\nreturn self._value.unique_sign()\n```\nIs there any reason not to do so? (For the record: in this particular example, this loop takes 82ms on my machine.)",
    "created_at": "2021-05-05T10:22:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510881",
    "user": "https://github.com/Ilia-Smilga"
}
```

<div id="comment:14" align="right">comment:14</div>

Replying to [@tscrim](#comment%3A11):
> comment:10: Once you have different minimal polynomials, then I believe you essentially have everything. Perhaps I have misunderstood something?

Consider the following computation:

```
x = AA(1+100*2^(-1000))^(1/100)
y = AA(1+101*2^(-1000))^(1/101)
x < y
```
(which calls `sign(y-x)` internally). With your patch (if I read it correctly; I did not actually run it), Sage will notice that the minimal polynomials are different, but will not take advantage of that information. It will still trigger exact computation of `y-x` (which takes forever). 

I suggest adding for this case (different minimal polynomials) the code

```
while self._value.contains_zero():
    self._more_precision()
return self._value.unique_sign()
```
Is there any reason not to do so? (For the record: in this particular example, this loop takes 82ms on my machine.)



---

archive/issue_comments_510882.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nReplying to [@Ilia-Smilga](#comment%3A14):\n> I suggest adding for this case (different minimal polynomials) the code\n> \n> ```\n> while self._value.contains_zero():\n>     self._more_precision()\n> return self._value.unique_sign()\n> ```\n> Is there any reason not to do so? (For the record: in this particular example, this loop takes 82ms on my machine.)\n\nI see what you're saying, but that is a more invasive change. It probably is better to just do that here. However, I don't quite understand Dima's suggestion on the sage-devel thread. It probably is something simple, and I am just too tired to see it right now.",
    "created_at": "2021-05-05T12:52:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510882",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:15" align="right">comment:15</div>

Replying to [@Ilia-Smilga](#comment%3A14):
> I suggest adding for this case (different minimal polynomials) the code
> 
> ```
> while self._value.contains_zero():
>     self._more_precision()
> return self._value.unique_sign()
> ```
> Is there any reason not to do so? (For the record: in this particular example, this loop takes 82ms on my machine.)

I see what you're saying, but that is a more invasive change. It probably is better to just do that here. However, I don't quite understand Dima's suggestion on the sage-devel thread. It probably is something simple, and I am just too tired to see it right now.



---

archive/issue_comments_510883.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nIn this part of the new code\n\n```\n        if sd._left.minpoly() == sd._right.minpoly():\n            # Negating the element does not change the minpoly\n            right = sd._right if sd._op is operator.sub else -sd._right\n            c = cmp_elements_with_same_minpoly(sd._left, right, sd._left.minpoly())\n            if c == 0:\n                self._set_descr(ANRational(QQ.zero()))\n                return 0\n            elif c is not None:\n                return c\n```\nyou seemed to ignore that the operator could be `mul` or `truediv`.",
    "created_at": "2021-05-30T08:16:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510883",
    "user": "https://github.com/videlec"
}
```

<div id="comment:16" align="right">comment:16</div>

In this part of the new code

```
        if sd._left.minpoly() == sd._right.minpoly():
            # Negating the element does not change the minpoly
            right = sd._right if sd._op is operator.sub else -sd._right
            c = cmp_elements_with_same_minpoly(sd._left, right, sd._left.minpoly())
            if c == 0:
                self._set_descr(ANRational(QQ.zero()))
                return 0
            elif c is not None:
                return c
```
you seemed to ignore that the operator could be `mul` or `truediv`.



---

archive/issue_comments_510884.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nI wonder if we can improve *exactification* instead of avoiding it. At the moment any two instances of `AlgebraicGenerator` are recognized to be different, even if they describe the *same root* of the same polynomial. Is there a special reason for this? What is the idea behind the attribute `_index`?\n\nHowsoever, I did the following attempt modifying the method  `_richcmp_` of this class  and changed `self is other` in `union` to `self == other` and accordingly `super is self` to `super == self` in `super_poly` (`diff` shown with respect to stable 9.3):\n\n```diff\ndiff --git a/src/sage/rings/qqbar.py b/src/sage/rings/qqbar.py\nindex 81e333b..b94bea7 100644\n--- a/src/sage/rings/qqbar.py\n+++ b/src/sage/rings/qqbar.py\n@@ -2911,6 +2911,19 @@ class AlgebraicGenerator(SageObject):\n             sage: gen > qq_generator\n             True\n         \"\"\"\n+        sf = self._field\n+        of = other._field\n+        if type(sf) != type(of):\n+           return rich_to_bool(op, 1)\n+        if sf != of:\n+           return richcmp_not_equal(sf, of, op)\n+        sa = self.root_as_algebraic()\n+        oa = other.root_as_algebraic()\n+        if sa in QQ and oa in QQ:\n+            return richcmp(QQ(sa), QQ(oa), op)\n+        c = cmp_elements_with_same_minpoly(sa, oa, sf.polynomial())\n+        if c is not None:\n+            return rich_to_bool(op, c)\n         return richcmp(self._index, other._index, op)\n\n     def is_complex(self):\n@@ -3108,7 +3121,7 @@ class AlgebraicGenerator(SageObject):\n             return other\n         if other._trivial:\n             return self\n-        if self is other:\n+        if self == other:\n             return self\n         if other in self._unions:\n             return self._unions[other].parent\n@@ -3207,7 +3220,7 @@ class AlgebraicGenerator(SageObject):\n         if checked is None:\n             checked = {}\n         checked[self] = True\n-        if super is self:\n+        if super == self:\n             return self._field.gen()\n         for u in self._unions.values():\n             if u.parent in checked:\n```\n\nThis change passes through all doctests (including `--long`) and makes *exactification* possible for the testcase of the ticket description:\n\n```sage\nsage: x1 = AA(2^(1/100))\n....: x2 = AA(2^(1/100))\n....: y = x1 - x2\n....: z = x1 - x2\nsage: %time y._exact_field()\nCPU times: user 160 ms, sys: 16 ms, total: 176 ms\nWall time: 174 ms\nTrivial generator\nsage: %time y == z\nCPU times: user 260 ms, sys: 0 ns, total: 260 ms\nWall time: 259 ms\nTrue\n```\n\nOf course this does not solve the testcase of [comment:14](https://github.com/sagemath/sage/issues/31767#comment:14). Concerning this it seems, that the function `composed_op` could do a good job here:\n\n\n\n```sage\nsage: x = AA(1+2*2^(-1000))^(1/2); y = AA(1+3*2^(-1000))^(1/3)\nsage: p = x.minpoly()\nsage: q = y.minpoly()\nsage: %time r = p.composed_op(q, operator.sub)\nCPU times: user 4 ms, sys: 0 ns, total: 4 ms\nWall time: 5.53 ms\nsage: %time F = r.factor()\nCPU times: user 0 ns, sys: 0 ns, total: 0 ns\nWall time: 2.65 ms\n```\n\nI would prefer such a solution since it would not just fix this issue, but also improve exactification in general. On the other hand I agree with Vincent that this only makes sense (in view of the upcoming Calcium), if it will be easy to realize.\n\nBut note, that this issue is different from the former one in not just hanging in Pari's `nffactor` but already one step before in the construction of the Pari number field (of degree two!):\n\n```sage\nsage: AG = x._exact_field()\nsage: AG.pari_field()\n^C---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\n<ipython-input-8-2b02365498e1> in <module>\n----> 1 AG.pari_field()\n\n~/devel/sage/local/lib/python3.9/site-packages/sage/rings/qqbar.py in pari_field(self)\n   3025         if self._pari_field is None:\n   3026             pari_pol = self._field.pari_polynomial(\"y\")\n-> 3027             self._pari_field = pari_pol.nfinit(1)\n   3028         return self._pari_field\n   3029\n\ncypari2/auto_gen.pxi in cypari2.gen.Gen_base.nfinit()\n\nKeyboardInterrupt:\n```\n\n\nThus, I would take this for bug in Pari, isn't it?",
    "created_at": "2021-05-30T09:10:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510884",
    "user": "https://github.com/soehms"
}
```

<div id="comment:17" align="right">comment:17</div>

I wonder if we can improve *exactification* instead of avoiding it. At the moment any two instances of `AlgebraicGenerator` are recognized to be different, even if they describe the *same root* of the same polynomial. Is there a special reason for this? What is the idea behind the attribute `_index`?

Howsoever, I did the following attempt modifying the method  `_richcmp_` of this class  and changed `self is other` in `union` to `self == other` and accordingly `super is self` to `super == self` in `super_poly` (`diff` shown with respect to stable 9.3):

```diff
diff --git a/src/sage/rings/qqbar.py b/src/sage/rings/qqbar.py
index 81e333b..b94bea7 100644
--- a/src/sage/rings/qqbar.py
+++ b/src/sage/rings/qqbar.py
@@ -2911,6 +2911,19 @@ class AlgebraicGenerator(SageObject):
             sage: gen > qq_generator
             True
         """
+        sf = self._field
+        of = other._field
+        if type(sf) != type(of):
+           return rich_to_bool(op, 1)
+        if sf != of:
+           return richcmp_not_equal(sf, of, op)
+        sa = self.root_as_algebraic()
+        oa = other.root_as_algebraic()
+        if sa in QQ and oa in QQ:
+            return richcmp(QQ(sa), QQ(oa), op)
+        c = cmp_elements_with_same_minpoly(sa, oa, sf.polynomial())
+        if c is not None:
+            return rich_to_bool(op, c)
         return richcmp(self._index, other._index, op)

     def is_complex(self):
@@ -3108,7 +3121,7 @@ class AlgebraicGenerator(SageObject):
             return other
         if other._trivial:
             return self
-        if self is other:
+        if self == other:
             return self
         if other in self._unions:
             return self._unions[other].parent
@@ -3207,7 +3220,7 @@ class AlgebraicGenerator(SageObject):
         if checked is None:
             checked = {}
         checked[self] = True
-        if super is self:
+        if super == self:
             return self._field.gen()
         for u in self._unions.values():
             if u.parent in checked:
```

This change passes through all doctests (including `--long`) and makes *exactification* possible for the testcase of the ticket description:

```sage
sage: x1 = AA(2^(1/100))
....: x2 = AA(2^(1/100))
....: y = x1 - x2
....: z = x1 - x2
sage: %time y._exact_field()
CPU times: user 160 ms, sys: 16 ms, total: 176 ms
Wall time: 174 ms
Trivial generator
sage: %time y == z
CPU times: user 260 ms, sys: 0 ns, total: 260 ms
Wall time: 259 ms
True
```

Of course this does not solve the testcase of [comment:14](https://github.com/sagemath/sage/issues/31767#comment:14). Concerning this it seems, that the function `composed_op` could do a good job here:



```sage
sage: x = AA(1+2*2^(-1000))^(1/2); y = AA(1+3*2^(-1000))^(1/3)
sage: p = x.minpoly()
sage: q = y.minpoly()
sage: %time r = p.composed_op(q, operator.sub)
CPU times: user 4 ms, sys: 0 ns, total: 4 ms
Wall time: 5.53 ms
sage: %time F = r.factor()
CPU times: user 0 ns, sys: 0 ns, total: 0 ns
Wall time: 2.65 ms
```

I would prefer such a solution since it would not just fix this issue, but also improve exactification in general. On the other hand I agree with Vincent that this only makes sense (in view of the upcoming Calcium), if it will be easy to realize.

But note, that this issue is different from the former one in not just hanging in Pari's `nffactor` but already one step before in the construction of the Pari number field (of degree two!):

```sage
sage: AG = x._exact_field()
sage: AG.pari_field()
^C---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
<ipython-input-8-2b02365498e1> in <module>
----> 1 AG.pari_field()

~/devel/sage/local/lib/python3.9/site-packages/sage/rings/qqbar.py in pari_field(self)
   3025         if self._pari_field is None:
   3026             pari_pol = self._field.pari_polynomial("y")
-> 3027             self._pari_field = pari_pol.nfinit(1)
   3028         return self._pari_field
   3029

cypari2/auto_gen.pxi in cypari2.gen.Gen_base.nfinit()

KeyboardInterrupt:
```


Thus, I would take this for bug in Pari, isn't it?



---

archive/issue_comments_510885.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nReplying to [@videlec](#comment%3A16):\n> In this part of the new code\n> \n> ```\n>         if sd._left.minpoly() == sd._right.minpoly():\n>             # Negating the element does not change the minpoly\n>             right = sd._right if sd._op is operator.sub else -sd._right\n>             c = cmp_elements_with_same_minpoly(sd._left, right, sd._left.minpoly())\n>             if c == 0:\n>                 self._set_descr(ANRational(QQ.zero()))\n>                 return 0\n>             elif c is not None:\n>                 return c\n> ```\n> you seemed to ignore that the operator could be `mul` or `truediv`.\n\nThose cases already would have been picked up earlier in this block:\n\n```diff\n         elif type(sd) is ANBinaryExpr:\n             ls = sd._left.sign()\n             rs = sd._right.sign()\n             if sd._op is operator.mul or sd._op is operator.truediv:\n-                return sd._left.sign() * sd._right.sign()\n+                return ls * rs\n```",
    "created_at": "2021-06-01T01:04:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510885",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:18" align="right">comment:18</div>

Replying to [@videlec](#comment%3A16):
> In this part of the new code
> 
> ```
>         if sd._left.minpoly() == sd._right.minpoly():
>             # Negating the element does not change the minpoly
>             right = sd._right if sd._op is operator.sub else -sd._right
>             c = cmp_elements_with_same_minpoly(sd._left, right, sd._left.minpoly())
>             if c == 0:
>                 self._set_descr(ANRational(QQ.zero()))
>                 return 0
>             elif c is not None:
>                 return c
> ```
> you seemed to ignore that the operator could be `mul` or `truediv`.

Those cases already would have been picked up earlier in this block:

```diff
         elif type(sd) is ANBinaryExpr:
             ls = sd._left.sign()
             rs = sd._right.sign()
             if sd._op is operator.mul or sd._op is operator.truediv:
-                return sd._left.sign() * sd._right.sign()
+                return ls * rs
```



---

archive/issue_comments_510886.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\n@soehms That seems like a good idea. However, we now have to come up with a better hash. My guess behind the  `_index` idea is that they wanted very fast comparison checks and hashing that is consistent with equality. This line actually dates back to the initial implementation of algebraic reals (commit `07704df513`). So there is room for improvement here.",
    "created_at": "2021-06-01T01:53:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510886",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:19" align="right">comment:19</div>

@soehms That seems like a good idea. However, we now have to come up with a better hash. My guess behind the  `_index` idea is that they wanted very fast comparison checks and hashing that is consistent with equality. This line actually dates back to the initial implementation of algebraic reals (commit `07704df513`). So there is room for improvement here.



---

archive/issue_comments_510887.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nWhat about postponing further improvements to other tickets? This one is ready and I think it is worth setting to positive review.",
    "created_at": "2021-06-01T07:01:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510887",
    "user": "https://github.com/videlec"
}
```

<div id="comment:20" align="right">comment:20</div>

What about postponing further improvements to other tickets? This one is ready and I think it is worth setting to positive review.



---

archive/issue_comments_510888.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nReplying to [@Ilia-Smilga](#comment%3A14):\n> Replying to [@tscrim](#comment%3A11):\n> > comment:10: Once you have different minimal polynomials, then I believe you essentially have everything. Perhaps I have misunderstood something?\n> \n> \n> Consider the following computation:\n> \n> ```\n> x = AA(1+100*2^(-1000))^(1/100)\n> y = AA(1+101*2^(-1000))^(1/101)\n> x < y\n> ```\n\nI agree that for a single `+` operation on two elements for which you know the minimal polynomial, infinite refinement is a way to go.\n\nHowever, you need someting to compute minimal polynomials in order to handle\n\n```\nsage: a = AA(1 + 2^(-1000))\nsage: x = a^(1/100) + a^(1/104) - a^(1/102) - a^(1/103)\n```\nI opened #31889 for that purpose.",
    "created_at": "2021-06-01T07:18:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510888",
    "user": "https://github.com/videlec"
}
```

<div id="comment:21" align="right">comment:21</div>

Replying to [@Ilia-Smilga](#comment%3A14):
> Replying to [@tscrim](#comment%3A11):
> > comment:10: Once you have different minimal polynomials, then I believe you essentially have everything. Perhaps I have misunderstood something?
> 
> 
> Consider the following computation:
> 
> ```
> x = AA(1+100*2^(-1000))^(1/100)
> y = AA(1+101*2^(-1000))^(1/101)
> x < y
> ```

I agree that for a single `+` operation on two elements for which you know the minimal polynomial, infinite refinement is a way to go.

However, you need someting to compute minimal polynomials in order to handle

```
sage: a = AA(1 + 2^(-1000))
sage: x = a^(1/100) + a^(1/104) - a^(1/102) - a^(1/103)
```
I opened #31889 for that purpose.



---

archive/issue_comments_510889.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nReplying to [@videlec](#comment%3A20):\n> What about postponing further improvements to other tickets? This one is ready and I think it is worth setting to positive review.\n\nAgreed!",
    "created_at": "2021-06-01T21:42:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510889",
    "user": "https://github.com/soehms"
}
```

<div id="comment:22" align="right">comment:22</div>

Replying to [@videlec](#comment%3A20):
> What about postponing further improvements to other tickets? This one is ready and I think it is worth setting to positive review.

Agreed!



---

archive/issue_comments_510890.json:
```json
{
    "body": "Changed commit from **[`5da8b27`](https://github.com/sagemath/sagetrac-mirror/commit/5da8b2774eb2e024cc7a850789e1ed1a6816d354)** to **[`642b7c2`](https://github.com/sagemath/sagetrac-mirror/commit/642b7c2adc0d2a54c1097eb1cf923bb2e648df0f)**",
    "created_at": "2021-06-02T01:35:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510890",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`5da8b27`](https://github.com/sagemath/sagetrac-mirror/commit/5da8b2774eb2e024cc7a850789e1ed1a6816d354)** to **[`642b7c2`](https://github.com/sagemath/sagetrac-mirror/commit/642b7c2adc0d2a54c1097eb1cf923bb2e648df0f)**



---

archive/issue_comments_510891.json:
```json
{
    "body": "<div id=\"comment:23\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/526bb7d57a342e4b061b5f123a30757c3f2489dd\"><code>526bb7d</code></a></td><td><code>Merge branch 'public/performance/qqbar_sign-31767' of git://trac.sagemath.org/sage into public/performance/qqbar_sign-31767</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/642b7c2adc0d2a54c1097eb1cf923bb2e648df0f\"><code>642b7c2</code></a></td><td><code>Fixing pyflakes warning.</code></td></tr></table>\n",
    "created_at": "2021-06-02T01:35:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510891",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:23"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/526bb7d57a342e4b061b5f123a30757c3f2489dd"><code>526bb7d</code></a></td><td><code>Merge branch 'public/performance/qqbar_sign-31767' of git://trac.sagemath.org/sage into public/performance/qqbar_sign-31767</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/642b7c2adc0d2a54c1097eb1cf923bb2e648df0f"><code>642b7c2</code></a></td><td><code>Fixing pyflakes warning.</code></td></tr></table>




---

archive/issue_comments_510892.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nThe bot was green modulo one pyflakes before I pushed. The last change just removes an unused import. Tests still pass for me.",
    "created_at": "2021-06-02T01:37:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510892",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:24" align="right">comment:24</div>

The bot was green modulo one pyflakes before I pushed. The last change just removes an unused import. Tests still pass for me.



---

archive/issue_events_434982.json:
```json
{
    "actor": "https://github.com/soehms",
    "created_at": "2021-06-02T14:29:40Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31767#event-434982"
}
```



---

archive/issue_events_434983.json:
```json
{
    "actor": "https://github.com/soehms",
    "created_at": "2021-06-02T14:29:40Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31767#event-434983"
}
```



---

archive/issue_comments_510893.json:
```json
{
    "body": "Reviewer: **Vincent Delecroix, Sebastian Oehms**",
    "created_at": "2021-06-02T14:29:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510893",
    "user": "https://github.com/soehms"
}
```

Reviewer: **Vincent Delecroix, Sebastian Oehms**



---

archive/issue_comments_510894.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nThank you.",
    "created_at": "2021-06-02T21:25:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510894",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:26" align="right">comment:26</div>

Thank you.



---

archive/issue_comments_510895.json:
```json
{
    "body": "Changed branch from **[public/performance/qqbar_sign-31767](https://github.com/sagemath/sagetrac-mirror/tree/public/performance/qqbar_sign-31767)** to **[`642b7c2`](https://github.com/sagemath/sagetrac-mirror/commit/642b7c2adc0d2a54c1097eb1cf923bb2e648df0f)**",
    "created_at": "2021-06-19T20:57:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31767#issuecomment-510895",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[public/performance/qqbar_sign-31767](https://github.com/sagemath/sagetrac-mirror/tree/public/performance/qqbar_sign-31767)** to **[`642b7c2`](https://github.com/sagemath/sagetrac-mirror/commit/642b7c2adc0d2a54c1097eb1cf923bb2e648df0f)**



---

archive/issue_events_434984.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-06-19T20:57:50Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31767#event-434984"
}
```



---

archive/issue_events_434985.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "19d4c34a4cfd5112e8de39e76625a7d0ab770856",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2021-06-19T20:57:50Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/31767",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31767#event-434985"
}
```
