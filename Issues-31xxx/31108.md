# Issue 31108: Relaxed p-adics

archive/issues_030871.json:
```json
{
    "body": "We propose an implementation of exact p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.\n\nHere is a small demo:\n\n```\n    The model for relaxed `p`-adics is quite different from any of the\n    other types of `p`-adics. In addition to storing a finite\n    approximation, one also stores a method for increasing the\n    precision.\n\n    Relaxed `p`-adic rings are created by the constructor :func:`ZpER`::\n\n        sage: R = ZpER(5, print_mode=\"digits\")\n        sage: R\n        5-adic Ring handled with relaxed arithmetics\n\n    The precision is not capped in `R`::\n\n        sage: R.precision_cap()\n        +Infinity\n\n    However, a default precision is fixed. This is the precision\n    at which the elements will be printed::\n\n        sage: R.default_prec()\n        20\n\n    A default halting precision is also set. It is the default absolute\n    precision at which the elements will be compared. By default, it is\n    twice the default precision::\n\n        sage: R.halting_prec()\n        40\n\n    However, both the default precision and the halting precision can be\n    customized at the creation of the parent as follows:\n\n        sage: S = ZpER(5, prec=10, halt=100)\n        sage: S.default_prec()\n        10\n        sage: S.halting_prec()\n        100\n\n    One creates elements as usual::\n\n        sage: a = R(17/42)\n        sage: a\n        ...00244200244200244201\n\n        sage: R.random_element()  # random\n        ...21013213133412431402\n\n    Here we notice that 20 digits (that is the default precision) are printed.\n    However, the computation model is designed in order to guarantee that more\n    digits of `a` will be available on demand.\n    This feature is reflected by the fact that, when we ask for the precision\n    of `a`, the software answers `+\\infty`::\n\n        sage: a.precision_absolute()\n        +Infinity\n\n    Asking for more digits is achieved by the methods :meth:`at_precision_absolute`\n    and :meth:`at_precision_relative`::\n\n        sage: a.at_precision_absolute(30)\n        ...?244200244200244200244200244201\n\n    As a shortcut, one can use the bracket operator::\n\n        sage: a[:30]\n        ...?244200244200244200244200244201\n\n    Of course, standard operations are supported::\n\n        sage: b = R(42/17)\n        sage: a + b\n        ...03232011214322140002\n        sage: a - b\n        ...42311334324023403400\n        sage: a * b\n        ...00000000000000000001\n        sage: a / b\n        ...12442142113021233401\n        sage: sqrt(a)\n        ...20042333114021142101\n\n    We observe again that only 20 digits are printed but, as before,\n    more digits are available on demand::\n\n        sage: sqrt(a)[:30]\n        ...?142443342120042333114021142101\n\n    .. RUBRIC:: Equality tests\n\n    Checking equalities between relaxed `p`-adics is a bit subtle and can\n    sometimes be puzzling at first glance.\n\n    When the parent is created with ``secure=False`` (which is the\n    default), elements are compared at the current precision, or at the\n    default halting precision if it is higher::\n\n        sage: a == b\n        False\n\n        sage: a == sqrt(a)^2\n        True\n        sage: a == sqrt(a)^2 + 5^50\n        True\n\n    In the above example, the halting precision is `40`; it is the\n    reason why a congruence modulo `5^50` is considered as an equality.\n    However, if both sides of the equalities have been previously\n    computed with more digits, those digits are taken into account.\n    Hence comparing two elements at different times can produce\n    different results::\n\n        sage: aa = sqrt(a)^2 + 5^50\n        sage: a == aa\n        True\n        sage: a[:60]\n        ...?244200244200244200244200244200244200244200244200244200244201\n        sage: aa[:60]\n        ...?244200244300244200244200244200244200244200244200244200244201\n        sage: a == aa\n        False\n\n    This annoying situation, where the output of `a == aa` may change\n    depending on previous computations, cannot occur when the parent is\n    created with ``secure=True``.\n    Indeed, in this case, if the equality cannot be decided, an error\n    is raised::\n\n        sage: S = ZpER(5, secure=True)\n        sage: u = S.random_element()\n        sage: uu = u + 5^50\n        sage: u == uu\n        Traceback (most recent call last):\n        ...\n        PrecisionError: unable to decide equality; try to bound precision\n\n        sage: u[:60] == uu\n        False\n\n    .. RUBRIC:: Self-referent numbers\n\n    A quite interesting feature with relaxed `p`-adics is the possibility to\n    create (in some cases) self-referent numbers. Here is an example.\n    We first declare a new variable as follows::\n\n        sage: x = R.unknown()\n        sage: x\n        ...?.0\n\n    We then use the method :meth:`set` to define `x` by writing down an equation\n    it satisfies::\n\n        sage: x.set(1 + 5*x^2)\n        True\n\n    The variable `x` now contains the unique solution of the equation\n    `x = 1 + 5 x^2`::\n\n        sage: x\n        ...04222412141121000211\n\n    This works because the `n`-th digit of the right hand size of the\n    defining equation only involves the `i`-th digits of `x` with `i < n`\n    (this is due to the factor `5`).\n\n    As a comparison, the following does not work::\n\n        sage: y = R.unknown()\n        sage: y.set(1 + 3*y^2)\n        True\n        sage: y\n        ...?.0\n        sage: y[:20]\n        Traceback (most recent call last):\n        ...\n        RecursionError: definition looks circular\n\n    Self-referent definitions also work with systems of equations::\n\n        sage: u = R.unknown()\n        sage: v = R.unknown()\n        sage: w = R.unknown()\n\n        sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)\n        True\n        sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))\n        True\n        sage: w.set(3 + 25*(u*v + v*w + u*w))\n        True\n\n        sage: u\n        ...31203130103131131433\n        sage: v\n        ...33441043031103114240\n        sage: w\n        ...30212422041102444403\n```\n\nCC:  tristanvaccon @thibautverron @roed314 @saraedum\n\nReviewer: David Roe\n\nAuthor: Xavier Caruso\n\nBranch: ad06299820b3302a3f39cff8b281dcb95819fba0\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/31108\n\n",
    "closed_at": "2021-05-27T20:30:03Z",
    "created_at": "2020-12-25T20:42:30Z",
    "labels": [
        "component: padics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.4",
    "title": "Relaxed p-adics",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31108",
    "user": "https://github.com/xcaruso"
}
```
We propose an implementation of exact p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.

Here is a small demo:

```
    The model for relaxed `p`-adics is quite different from any of the
    other types of `p`-adics. In addition to storing a finite
    approximation, one also stores a method for increasing the
    precision.

    Relaxed `p`-adic rings are created by the constructor :func:`ZpER`::

        sage: R = ZpER(5, print_mode="digits")
        sage: R
        5-adic Ring handled with relaxed arithmetics

    The precision is not capped in `R`::

        sage: R.precision_cap()
        +Infinity

    However, a default precision is fixed. This is the precision
    at which the elements will be printed::

        sage: R.default_prec()
        20

    A default halting precision is also set. It is the default absolute
    precision at which the elements will be compared. By default, it is
    twice the default precision::

        sage: R.halting_prec()
        40

    However, both the default precision and the halting precision can be
    customized at the creation of the parent as follows:

        sage: S = ZpER(5, prec=10, halt=100)
        sage: S.default_prec()
        10
        sage: S.halting_prec()
        100

    One creates elements as usual::

        sage: a = R(17/42)
        sage: a
        ...00244200244200244201

        sage: R.random_element()  # random
        ...21013213133412431402

    Here we notice that 20 digits (that is the default precision) are printed.
    However, the computation model is designed in order to guarantee that more
    digits of `a` will be available on demand.
    This feature is reflected by the fact that, when we ask for the precision
    of `a`, the software answers `+\infty`::

        sage: a.precision_absolute()
        +Infinity

    Asking for more digits is achieved by the methods :meth:`at_precision_absolute`
    and :meth:`at_precision_relative`::

        sage: a.at_precision_absolute(30)
        ...?244200244200244200244200244201

    As a shortcut, one can use the bracket operator::

        sage: a[:30]
        ...?244200244200244200244200244201

    Of course, standard operations are supported::

        sage: b = R(42/17)
        sage: a + b
        ...03232011214322140002
        sage: a - b
        ...42311334324023403400
        sage: a * b
        ...00000000000000000001
        sage: a / b
        ...12442142113021233401
        sage: sqrt(a)
        ...20042333114021142101

    We observe again that only 20 digits are printed but, as before,
    more digits are available on demand::

        sage: sqrt(a)[:30]
        ...?142443342120042333114021142101

    .. RUBRIC:: Equality tests

    Checking equalities between relaxed `p`-adics is a bit subtle and can
    sometimes be puzzling at first glance.

    When the parent is created with ``secure=False`` (which is the
    default), elements are compared at the current precision, or at the
    default halting precision if it is higher::

        sage: a == b
        False

        sage: a == sqrt(a)^2
        True
        sage: a == sqrt(a)^2 + 5^50
        True

    In the above example, the halting precision is `40`; it is the
    reason why a congruence modulo `5^50` is considered as an equality.
    However, if both sides of the equalities have been previously
    computed with more digits, those digits are taken into account.
    Hence comparing two elements at different times can produce
    different results::

        sage: aa = sqrt(a)^2 + 5^50
        sage: a == aa
        True
        sage: a[:60]
        ...?244200244200244200244200244200244200244200244200244200244201
        sage: aa[:60]
        ...?244200244300244200244200244200244200244200244200244200244201
        sage: a == aa
        False

    This annoying situation, where the output of `a == aa` may change
    depending on previous computations, cannot occur when the parent is
    created with ``secure=True``.
    Indeed, in this case, if the equality cannot be decided, an error
    is raised::

        sage: S = ZpER(5, secure=True)
        sage: u = S.random_element()
        sage: uu = u + 5^50
        sage: u == uu
        Traceback (most recent call last):
        ...
        PrecisionError: unable to decide equality; try to bound precision

        sage: u[:60] == uu
        False

    .. RUBRIC:: Self-referent numbers

    A quite interesting feature with relaxed `p`-adics is the possibility to
    create (in some cases) self-referent numbers. Here is an example.
    We first declare a new variable as follows::

        sage: x = R.unknown()
        sage: x
        ...?.0

    We then use the method :meth:`set` to define `x` by writing down an equation
    it satisfies::

        sage: x.set(1 + 5*x^2)
        True

    The variable `x` now contains the unique solution of the equation
    `x = 1 + 5 x^2`::

        sage: x
        ...04222412141121000211

    This works because the `n`-th digit of the right hand size of the
    defining equation only involves the `i`-th digits of `x` with `i < n`
    (this is due to the factor `5`).

    As a comparison, the following does not work::

        sage: y = R.unknown()
        sage: y.set(1 + 3*y^2)
        True
        sage: y
        ...?.0
        sage: y[:20]
        Traceback (most recent call last):
        ...
        RecursionError: definition looks circular

    Self-referent definitions also work with systems of equations::

        sage: u = R.unknown()
        sage: v = R.unknown()
        sage: w = R.unknown()

        sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)
        True
        sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))
        True
        sage: w.set(3 + 25*(u*v + v*w + u*w))
        True

        sage: u
        ...31203130103131131433
        sage: v
        ...33441043031103114240
        sage: w
        ...30212422041102444403
```

CC:  tristanvaccon @thibautverron @roed314 @saraedum

Reviewer: David Roe

Author: Xavier Caruso

Branch: ad06299820b3302a3f39cff8b281dcb95819fba0

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/31108





---

archive/issue_comments_617252.json:
```json
{
    "body": "Changing branch from \"\" to \"u/caruso/relaxed\"",
    "created_at": "2020-12-25T20:43:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617252",
    "user": "https://github.com/xcaruso"
}
```

Changing branch from "" to "u/caruso/relaxed"



---

archive/issue_comments_617253.json:
```json
{
    "body": "Changing commit from \"\" to \"7229cefe8a60f1482f91d2670863843513791b43\"",
    "created_at": "2020-12-26T07:46:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617253",
    "user": "https://github.com/xcaruso"
}
```

Changing commit from "" to "7229cefe8a60f1482f91d2670863843513791b43"



---

archive/issue_comments_617254.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -95,13 +95,14 @@\n (this is due to the factor `5`).\n \n As a comparison, the following produces an error::\n+\n     sage: y = R()\n     sage: y == 1 + 3*y^2\n     Traceback (most recent call last):\n     ...\n     RecursionError: definition looks circular\n \n-Previous self-referrent definitions also work with system of equations::\n+Previous self-referent definitions also work with system of equations::\n \n     sage: u = R(); v = R(); w = R()\n \n``````\n",
    "created_at": "2020-12-26T07:46:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617254",
    "user": "https://github.com/xcaruso"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -95,13 +95,14 @@
 (this is due to the factor `5`).
 
 As a comparison, the following produces an error::
+
     sage: y = R()
     sage: y == 1 + 3*y^2
     Traceback (most recent call last):
     ...
     RecursionError: definition looks circular
 
-Previous self-referrent definitions also work with system of equations::
+Previous self-referent definitions also work with system of equations::
 
     sage: u = R(); v = R(); w = R()
 
``````




---

archive/issue_comments_617255.json:
```json
{
    "body": "<a id='comment:2'></a>New commits:",
    "created_at": "2020-12-26T07:46:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617255",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:2'></a>New commits:



---

archive/issue_comments_617256.json:
```json
{
    "body": "<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-12-26T09:41:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617256",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617257.json:
```json
{
    "body": "Changing commit from \"7229cefe8a60f1482f91d2670863843513791b43\" to \"1fb0d59cbce16d1d7d6a423474301a6c060f9b43\"",
    "created_at": "2020-12-26T09:41:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617257",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "7229cefe8a60f1482f91d2670863843513791b43" to "1fb0d59cbce16d1d7d6a423474301a6c060f9b43"



---

archive/issue_comments_617258.json:
```json
{
    "body": "Changing commit from \"1fb0d59cbce16d1d7d6a423474301a6c060f9b43\" to \"b69ba5acbc71204fe113a4df7ffb4fc2fca0a27b\"",
    "created_at": "2020-12-29T20:42:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617258",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "1fb0d59cbce16d1d7d6a423474301a6c060f9b43" to "b69ba5acbc71204fe113a4df7ffb4fc2fca0a27b"



---

archive/issue_comments_617259.json:
```json
{
    "body": "<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-12-29T20:42:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617259",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617260.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,127 @@\n+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.\n \n+Here is a small demo:\n+\n+```\n+This module provides basic support for lazy p-adic integers.\n+\n+    sage: R = ZpL(5)\n+    sage: R\n+    Lazy 5-adic Ring\n+\n+One creates elements as usual::\n+\n+    sage: a = R(17/42)\n+    sage: a\n+    ...00244200244200244201\n+\n+    sage: R.random_element()  # random\n+    ...21013213133412431402\n+\n+By default, 20 digits of precision are computed (and printed).\n+If more (or less) digits are needed, one can specify it as follows::\n+\n+    sage: b = R(42/17, prec=30)\n+    sage: b\n+    ...104201213402432310420121340301\n+\n+Alternatively, one can increase the precision using the method meth:`jump`::\n+\n+    sage: a.jump(30)\n+    sage: a\n+    ...244200244200244200244200244201\n+\n+Standard operations are implemented::\n+\n+    sage: a + b\n+    ...03232011214322140002\n+    sage: a - b\n+    ...42311334324023403400\n+\n+    sage: a * b\n+    ...00000000000000000001\n+    sage: a / b\n+    ...12442142113021233401\n+\n+We observe again that only 20 digits are computed.\n+If we need more, we have to create a new variable::\n+\n+    sage: c = a / b\n+    sage: c.jump(40)\n+    sage: c\n+    ...4230030104200433321312442142113021233401\n+\n+Note that this automatically increases the precision on `a` and `b`::\n+\n+    sage: a\n+    ...4200244200244200244200244200244200244201\n+    sage: b\n+    ...2134024323104201213402432310420121340301\n+\n+Equality test works but equality is only checked up to the\n+*minimal* current precision of the elements::\n+\n+    sage: c == R(289/1764, prec=100)\n+    True\n+    sage: c == R(289/1764 + 5^50, prec=100)\n+    True\n+\n+    sage: c.jump(100)\n+    sage: c == R(289/1764 + 5^50, prec=100)\n+    False\n+    sage: c == R(289/1764 + 5^50)\n+    True\n+\n+A quite interesting feature with lazy p-adics is the possibility to\n+create (in somes cases) self-referrent numbers. Here is an example.\n+We first declare a new variable as follows::\n+\n+    sage: x = R()\n+    sage: x\n+    O(1)\n+\n+We then write down an equation satisfied by `x`::\n+\n+    sage: x == 1 + 5*x^2\n+    True\n+\n+The variable `x` now contains the unique solution of the above equation::\n+\n+    sage: x\n+    ...04222412141121000211\n+\n+This works because the `n`-th digit of the right hand size of the\n+defining equation only involves the `i`-th digits of `x` with `i < n`\n+(this is due to the factor `5`).\n+\n+As a comparison, the following produces an error::\n+\n+    sage: y = R()\n+    sage: y == 1 + 3*y^2\n+    Traceback (most recent call last):\n+    ...\n+    RecursionError: definition looks circular\n+\n+Previous self-referent definitions also work with system of equations::\n+\n+    sage: u = R.selfref()\n+    sage: v = R.selfref()\n+    sage: w = R.selfref()\n+\n+    sage: u == 1 + 2*v + 3*w^2 + 5*u*v*w\n+    True\n+    sage: v == 2 + 4/w^3 + 10*(u + v + w)^2\n+    True\n+    sage: w == 3 + 25*(u*v + v*w + u*w)\n+    True\n+\n+    sage: u\n+    ...21111231040212114001\n+    sage: v\n+    ...04313122332303332234\n+    sage: w\n+    ...30020001022124410403\n+```\n \n Comment: 1\n \n``````\n",
    "created_at": "2020-12-29T20:54:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617260",
    "user": "https://github.com/xcaruso"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,127 @@
+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.
 
+Here is a small demo:
+
+```
+This module provides basic support for lazy p-adic integers.
+
+    sage: R = ZpL(5)
+    sage: R
+    Lazy 5-adic Ring
+
+One creates elements as usual::
+
+    sage: a = R(17/42)
+    sage: a
+    ...00244200244200244201
+
+    sage: R.random_element()  # random
+    ...21013213133412431402
+
+By default, 20 digits of precision are computed (and printed).
+If more (or less) digits are needed, one can specify it as follows::
+
+    sage: b = R(42/17, prec=30)
+    sage: b
+    ...104201213402432310420121340301
+
+Alternatively, one can increase the precision using the method meth:`jump`::
+
+    sage: a.jump(30)
+    sage: a
+    ...244200244200244200244200244201
+
+Standard operations are implemented::
+
+    sage: a + b
+    ...03232011214322140002
+    sage: a - b
+    ...42311334324023403400
+
+    sage: a * b
+    ...00000000000000000001
+    sage: a / b
+    ...12442142113021233401
+
+We observe again that only 20 digits are computed.
+If we need more, we have to create a new variable::
+
+    sage: c = a / b
+    sage: c.jump(40)
+    sage: c
+    ...4230030104200433321312442142113021233401
+
+Note that this automatically increases the precision on `a` and `b`::
+
+    sage: a
+    ...4200244200244200244200244200244200244201
+    sage: b
+    ...2134024323104201213402432310420121340301
+
+Equality test works but equality is only checked up to the
+*minimal* current precision of the elements::
+
+    sage: c == R(289/1764, prec=100)
+    True
+    sage: c == R(289/1764 + 5^50, prec=100)
+    True
+
+    sage: c.jump(100)
+    sage: c == R(289/1764 + 5^50, prec=100)
+    False
+    sage: c == R(289/1764 + 5^50)
+    True
+
+A quite interesting feature with lazy p-adics is the possibility to
+create (in somes cases) self-referrent numbers. Here is an example.
+We first declare a new variable as follows::
+
+    sage: x = R()
+    sage: x
+    O(1)
+
+We then write down an equation satisfied by `x`::
+
+    sage: x == 1 + 5*x^2
+    True
+
+The variable `x` now contains the unique solution of the above equation::
+
+    sage: x
+    ...04222412141121000211
+
+This works because the `n`-th digit of the right hand size of the
+defining equation only involves the `i`-th digits of `x` with `i < n`
+(this is due to the factor `5`).
+
+As a comparison, the following produces an error::
+
+    sage: y = R()
+    sage: y == 1 + 3*y^2
+    Traceback (most recent call last):
+    ...
+    RecursionError: definition looks circular
+
+Previous self-referent definitions also work with system of equations::
+
+    sage: u = R.selfref()
+    sage: v = R.selfref()
+    sage: w = R.selfref()
+
+    sage: u == 1 + 2*v + 3*w^2 + 5*u*v*w
+    True
+    sage: v == 2 + 4/w^3 + 10*(u + v + w)^2
+    True
+    sage: w == 3 + 25*(u*v + v*w + u*w)
+    True
+
+    sage: u
+    ...21111231040212114001
+    sage: v
+    ...04313122332303332234
+    sage: w
+    ...30020001022124410403
+```
 
 Comment: 1
 
``````




---

archive/issue_comments_617261.json:
```json
{
    "body": "<a id='comment:5'></a>New commits:",
    "created_at": "2020-12-29T20:54:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617261",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:5'></a>New commits:



---

archive/issue_comments_617262.json:
```json
{
    "body": "Changing commit from \"b69ba5acbc71204fe113a4df7ffb4fc2fca0a27b\" to \"4044cadcc2792847530c6163ab0977c32c56ee45\"",
    "created_at": "2021-01-02T23:31:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617262",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "b69ba5acbc71204fe113a4df7ffb4fc2fca0a27b" to "4044cadcc2792847530c6163ab0977c32c56ee45"



---

archive/issue_comments_617263.json:
```json
{
    "body": "<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-02T23:31:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617263",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617264.json:
```json
{
    "body": "<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-04T14:08:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617264",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617265.json:
```json
{
    "body": "Changing commit from \"4044cadcc2792847530c6163ab0977c32c56ee45\" to \"f3397321658398e03765b57ea852d53fa8e684ab\"",
    "created_at": "2021-01-04T14:08:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617265",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "4044cadcc2792847530c6163ab0977c32c56ee45" to "f3397321658398e03765b57ea852d53fa8e684ab"



---

archive/issue_comments_617266.json:
```json
{
    "body": "<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-04T22:01:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617266",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617267.json:
```json
{
    "body": "Changing commit from \"f3397321658398e03765b57ea852d53fa8e684ab\" to \"a35d5d40556bb6136ac7b24aad7defea1a7346f6\"",
    "created_at": "2021-01-04T22:01:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617267",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "f3397321658398e03765b57ea852d53fa8e684ab" to "a35d5d40556bb6136ac7b24aad7defea1a7346f6"



---

archive/issue_comments_617268.json:
```json
{
    "body": "Changing commit from \"a35d5d40556bb6136ac7b24aad7defea1a7346f6\" to \"707287b49e4e6d45a9ac9ca20c7bb2d1fdcd7a33\"",
    "created_at": "2021-01-04T22:46:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617268",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "a35d5d40556bb6136ac7b24aad7defea1a7346f6" to "707287b49e4e6d45a9ac9ca20c7bb2d1fdcd7a33"



---

archive/issue_comments_617269.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-04T22:46:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617269",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617270.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-05T09:27:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617270",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617271.json:
```json
{
    "body": "Changing commit from \"707287b49e4e6d45a9ac9ca20c7bb2d1fdcd7a33\" to \"b130f140ec7b0835f5ccd5d604c30084792fa15c\"",
    "created_at": "2021-01-05T09:27:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617271",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "707287b49e4e6d45a9ac9ca20c7bb2d1fdcd7a33" to "b130f140ec7b0835f5ccd5d604c30084792fa15c"



---

archive/issue_comments_617272.json:
```json
{
    "body": "Changing commit from \"b130f140ec7b0835f5ccd5d604c30084792fa15c\" to \"ac5dbbc7dc56073ba9830eb2937064f2e91e02eb\"",
    "created_at": "2021-01-05T23:22:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617272",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "b130f140ec7b0835f5ccd5d604c30084792fa15c" to "ac5dbbc7dc56073ba9830eb2937064f2e91e02eb"



---

archive/issue_comments_617273.json:
```json
{
    "body": "<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-05T23:22:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617273",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617274.json:
```json
{
    "body": "<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-06T08:14:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617274",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617275.json:
```json
{
    "body": "Changing commit from \"ac5dbbc7dc56073ba9830eb2937064f2e91e02eb\" to \"4f2f8e6c2754355abcdc318c2d38b938d7b47599\"",
    "created_at": "2021-01-06T08:14:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617275",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "ac5dbbc7dc56073ba9830eb2937064f2e91e02eb" to "4f2f8e6c2754355abcdc318c2d38b938d7b47599"



---

archive/issue_comments_617276.json:
```json
{
    "body": "<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-06T08:30:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617276",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:13'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617277.json:
```json
{
    "body": "Changing commit from \"4f2f8e6c2754355abcdc318c2d38b938d7b47599\" to \"e23dccf09ef602230d5e70ae45cbb73470853578\"",
    "created_at": "2021-01-06T08:30:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617277",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "4f2f8e6c2754355abcdc318c2d38b938d7b47599" to "e23dccf09ef602230d5e70ae45cbb73470853578"



---

archive/issue_comments_617278.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-06T19:26:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617278",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617279.json:
```json
{
    "body": "Changing commit from \"e23dccf09ef602230d5e70ae45cbb73470853578\" to \"596280e920bc8f5a0252327bfa689e540dadaefe\"",
    "created_at": "2021-01-06T19:26:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617279",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "e23dccf09ef602230d5e70ae45cbb73470853578" to "596280e920bc8f5a0252327bfa689e540dadaefe"



---

archive/issue_comments_617280.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,122 @@\n+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.\n \n+Here is a small demo:\n+\n+```\n+This module provides basic support for lazy p-adic integers.\n+\n+    sage: R = ZpL(5, print_mode=\"digits\")\n+    sage: R\n+    5-adic Ring with lazy precision\n+\n+One creates elements as usual::\n+\n+    sage: a = R(17/42)\n+    sage: a\n+    ...00244200244200244201\n+\n+    sage: R.random_element()  # random\n+    ...21013213133412431402\n+\n+By default, 20 digits of precision are printed.\n+If more digits are needed, one can increase the precision by using the\n+meth:`jump`::\n+\n+    sage: a.jump(30)\n+    sage: a\n+    ...244200244200244200244200244201\n+\n+Standard operations are implemented::\n+\n+    sage: b = R(42/17)\n+\n+    sage: a + b\n+    ...03232011214322140002\n+    sage: a - b\n+    ...42311334324023403400\n+\n+    sage: a * b\n+    ...00000000000000000001\n+    sage: a / b\n+    ...12442142113021233401\n+\n+We observe again that only 20 digits are printed, even if the precision\n+on the operands is higher::\n+\n+    sage: b.jump(30)\n+    sage: a\n+    ...244200244200244200244200244201\n+    sage: b\n+    ...104201213402432310420121340301\n+    sage: a / b\n+    ...12442142113021233401\n+\n+If more digits are needed, we have to create a new variable::\n+\n+    sage: c = a / b\n+    sage: c.jump(40)\n+    sage: c\n+    ...4230030104200433321312442142113021233401\n+\n+Note that this automatically increases the precision on `a` and `b`::\n+\n+    sage: a\n+    ...4200244200244200244200244200244200244201\n+    sage: b\n+    ...2134024323104201213402432310420121340301\n+\n+::\n+\n+A quite interesting feature with lazy p-adics is the possibility to\n+create (in somes cases) self-referent numbers. Here is an example.\n+We first declare a new variable as follows::\n+\n+    sage: x = R.selfref()\n+    sage: x\n+    ...?.0\n+\n+We then write down an equation satisfied by `x`::\n+\n+    sage: x == 1 + 5*x^2\n+    True\n+\n+The variable `x` now contains the unique solution of the above equation::\n+\n+    sage: x\n+    ...04222412141121000211\n+\n+This works because the `n`-th digit of the right hand size of the\n+defining equation only involves the `i`-th digits of `x` with `i < n`\n+(this is due to the factor `5`).\n+\n+As a comparison, the following produces an error::\n+\n+    sage: y = R.selfref()\n+    sage: y == 1 + 3*y^2\n+    Traceback (most recent call last):\n+    ...\n+    RecursionError: definition looks circular\n+\n+Self-referent definitions also work with systems of equations::\n+\n+    sage: u = R.selfref()\n+    sage: v = R.selfref()\n+    sage: w = R.selfref()\n+\n+    sage: u == 1 + 2*v + 3*w^2 + 5*u*v*w\n+    True\n+    sage: v == 2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w)\n+    True\n+    sage: w == 3 + 25*(u*v + v*w + u*w)\n+    True\n+\n+    sage: u\n+    ...31203130103131131433\n+    sage: v\n+    ...33441043031103114240\n+    sage: w\n+    ...30212422041102444403\n+```\n \n Comment: 1\n \n``````\n",
    "created_at": "2021-01-06T19:28:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617280",
    "user": "https://github.com/xcaruso"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,122 @@
+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.
 
+Here is a small demo:
+
+```
+This module provides basic support for lazy p-adic integers.
+
+    sage: R = ZpL(5, print_mode="digits")
+    sage: R
+    5-adic Ring with lazy precision
+
+One creates elements as usual::
+
+    sage: a = R(17/42)
+    sage: a
+    ...00244200244200244201
+
+    sage: R.random_element()  # random
+    ...21013213133412431402
+
+By default, 20 digits of precision are printed.
+If more digits are needed, one can increase the precision by using the
+meth:`jump`::
+
+    sage: a.jump(30)
+    sage: a
+    ...244200244200244200244200244201
+
+Standard operations are implemented::
+
+    sage: b = R(42/17)
+
+    sage: a + b
+    ...03232011214322140002
+    sage: a - b
+    ...42311334324023403400
+
+    sage: a * b
+    ...00000000000000000001
+    sage: a / b
+    ...12442142113021233401
+
+We observe again that only 20 digits are printed, even if the precision
+on the operands is higher::
+
+    sage: b.jump(30)
+    sage: a
+    ...244200244200244200244200244201
+    sage: b
+    ...104201213402432310420121340301
+    sage: a / b
+    ...12442142113021233401
+
+If more digits are needed, we have to create a new variable::
+
+    sage: c = a / b
+    sage: c.jump(40)
+    sage: c
+    ...4230030104200433321312442142113021233401
+
+Note that this automatically increases the precision on `a` and `b`::
+
+    sage: a
+    ...4200244200244200244200244200244200244201
+    sage: b
+    ...2134024323104201213402432310420121340301
+
+::
+
+A quite interesting feature with lazy p-adics is the possibility to
+create (in somes cases) self-referent numbers. Here is an example.
+We first declare a new variable as follows::
+
+    sage: x = R.selfref()
+    sage: x
+    ...?.0
+
+We then write down an equation satisfied by `x`::
+
+    sage: x == 1 + 5*x^2
+    True
+
+The variable `x` now contains the unique solution of the above equation::
+
+    sage: x
+    ...04222412141121000211
+
+This works because the `n`-th digit of the right hand size of the
+defining equation only involves the `i`-th digits of `x` with `i < n`
+(this is due to the factor `5`).
+
+As a comparison, the following produces an error::
+
+    sage: y = R.selfref()
+    sage: y == 1 + 3*y^2
+    Traceback (most recent call last):
+    ...
+    RecursionError: definition looks circular
+
+Self-referent definitions also work with systems of equations::
+
+    sage: u = R.selfref()
+    sage: v = R.selfref()
+    sage: w = R.selfref()
+
+    sage: u == 1 + 2*v + 3*w^2 + 5*u*v*w
+    True
+    sage: v == 2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w)
+    True
+    sage: w == 3 + 25*(u*v + v*w + u*w)
+    True
+
+    sage: u
+    ...31203130103131131433
+    sage: v
+    ...33441043031103114240
+    sage: w
+    ...30212422041102444403
+```
 
 Comment: 1
 
``````




---

archive/issue_comments_617281.json:
```json
{
    "body": "Changing commit from \"596280e920bc8f5a0252327bfa689e540dadaefe\" to \"202e160b7973b9068018ebd49c5ea488da87d3b8\"",
    "created_at": "2021-01-06T23:20:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617281",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "596280e920bc8f5a0252327bfa689e540dadaefe" to "202e160b7973b9068018ebd49c5ea488da87d3b8"



---

archive/issue_comments_617282.json:
```json
{
    "body": "<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-06T23:20:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617282",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617283.json:
```json
{
    "body": "Changing commit from \"202e160b7973b9068018ebd49c5ea488da87d3b8\" to \"7e6e696d01878296a910c462fb928e171939348d\"",
    "created_at": "2021-01-08T13:52:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617283",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "202e160b7973b9068018ebd49c5ea488da87d3b8" to "7e6e696d01878296a910c462fb928e171939348d"



---

archive/issue_comments_617284.json:
```json
{
    "body": "<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-08T13:52:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617284",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617285.json:
```json
{
    "body": "<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-11T00:49:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617285",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617286.json:
```json
{
    "body": "Changing commit from \"7e6e696d01878296a910c462fb928e171939348d\" to \"17996461d34bdce6d77d1d4b57a7214f67180285\"",
    "created_at": "2021-01-11T00:49:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617286",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "7e6e696d01878296a910c462fb928e171939348d" to "17996461d34bdce6d77d1d4b57a7214f67180285"



---

archive/issue_comments_617287.json:
```json
{
    "body": "Changing commit from \"17996461d34bdce6d77d1d4b57a7214f67180285\" to \"b2b377aabdd18dbc87d324fc736ac7abeeec3be6\"",
    "created_at": "2021-01-11T15:22:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617287",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "17996461d34bdce6d77d1d4b57a7214f67180285" to "b2b377aabdd18dbc87d324fc736ac7abeeec3be6"



---

archive/issue_comments_617288.json:
```json
{
    "body": "<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-11T15:22:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617288",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617289.json:
```json
{
    "body": "Changing commit from \"b2b377aabdd18dbc87d324fc736ac7abeeec3be6\" to \"2f518421913b570a37754391cfe3f91ef24e1fe5\"",
    "created_at": "2021-01-24T10:21:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617289",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "b2b377aabdd18dbc87d324fc736ac7abeeec3be6" to "2f518421913b570a37754391cfe3f91ef24e1fe5"



---

archive/issue_comments_617290.json:
```json
{
    "body": "<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-24T10:21:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617290",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:20'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617291.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-26T13:37:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617291",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617292.json:
```json
{
    "body": "Changing commit from \"2f518421913b570a37754391cfe3f91ef24e1fe5\" to \"f395104a6ec660d8c9fad4dbe8613290a54642cf\"",
    "created_at": "2021-01-26T13:37:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617292",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "2f518421913b570a37754391cfe3f91ef24e1fe5" to "f395104a6ec660d8c9fad4dbe8613290a54642cf"



---

archive/issue_comments_617293.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,166 @@\n+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.\n \n+Here is a small demo:\n+\n+```\n+The model for lazy elements is quite different from any of the\n+other types of `p`-adics. In addition to storing a finite\n+approximation, one also stores a method for increasing the\n+precision.\n+\n+Lazy p-adic rings are created by the constructor :func:`ZpL`::\n+\n+    sage: R = ZpL(5, print_mode=\"digits\")\n+    sage: R\n+    5-adic Ring with lazy precision\n+\n+Observe that the precision is not capped on `R`::\n+\n+    sage: R.precision_cap()\n+    +Infinity\n+\n+However, a default precision is settled. This is the precision\n+at which the element will be printed::\n+\n+    sage: R.default_prec()\n+    20\n+\n+One creates elements as usual::\n+\n+    sage: a = R(17/42)\n+    sage: a\n+    ...00244200244200244201\n+\n+    sage: R.random_element()  # random\n+    ...21013213133412431402\n+\n+Here we notice that 20 digits (that is the default precision) are printed.\n+However, the computation model is designed in order to guarantee that more\n+digits of `a` are available on demand.\n+This feature is reflected by the fact that, when we ask for the precision\n+of `a`, the software answers `\\infty`::\n+\n+    sage: a.precision_absolute()\n+    +Infinity\n+\n+Asking for more digits is achieved by the methods :meth:`at_precision_absolute`\n+and :meth:`at_precision_relative`::\n+\n+    sage: a.at_precision_absolute(30)\n+    ...?244200244200244200244200244201\n+\n+As a shortcut, one can use the operator ``@``::\n+\n+    sage: a@30\n+    ...?244200244200244200244200244201\n+\n+Of course, standard operations are supported::\n+\n+    sage: b = R(42/17)\n+    sage: a + b\n+    ...03232011214322140002\n+    sage: a - b\n+    ...42311334324023403400\n+    sage: a * b\n+    ...00000000000000000001\n+    sage: a / b\n+    ...12442142113021233401\n+    sage: sqrt(a)\n+    ...20042333114021142101\n+\n+We observe again that only 20 digits are printed but, as before,\n+more digits are available on demand::\n+\n+    sage: sqrt(a)@30\n+    ...?142443342120042333114021142101\n+\n+Checking equalities between lazy p-adics is a bit subtle can could\n+sometimes be puzzling at first glance.\n+Actually, when it is obvious (from the previous computations) that\n+the two sides of the equality are different, everything works well::\n+\n+    sage: a == b\n+    False\n+\n+On the contrary, when the two numbers we want to compare are indeed\n+equal, it is not possible to conclude after a finite amount of\n+computations. In this case, an error is raised::\n+\n+    sage: a == sqrt(a)^2\n+    Traceback (most recent call last):\n+    ...\n+    PrecisionError: unable to decide equality; try to bound precision\n+\n+and we are forced to check equality at some given finite precision\n+as follows::\n+\n+    sage: a@20 == sqrt(a)^2\n+    True\n+    sage: a@100 == sqrt(a)^2\n+    True\n+\n+Finally, note that checking equality may fail even when the two\n+operands are different but when the first different digit is beyond\n+the default precision::\n+\n+    sage: b == b + 5^50\n+    Traceback (most recent call last):\n+    ...\n+    PrecisionError: unable to decide equality; try to bound precision\n+\n+::\n+\n+A quite interesting feature with lazy p-adics is the possibility to\n+create (in somes cases) self-referent numbers. Here is an example.\n+We first declare a new variable as follows::\n+\n+    sage: x = R.selfref()\n+    sage: x\n+    ...?.0\n+\n+We then use the method :meth:`set` to define `x` by writing down an equation\n+it satisfies::\n+\n+    sage: x.set(1 + 5*x^2)\n+\n+The variable `x` now contains the unique solution of the equation\n+`x = 1 + 5 x^2`::\n+\n+    sage: x\n+    ...04222412141121000211\n+\n+This works because the `n`-th digit of the right hand size of the\n+defining equation only involves the `i`-th digits of `x` with `i < n`\n+(this is due to the factor `5`).\n+\n+As a comparison, the following does not work::\n+\n+    sage: y = R.selfref()\n+    sage: y.set(1 + 3*y^2)\n+    sage: y\n+    ...?.0\n+    sage: y@20\n+    Traceback (most recent call last):\n+    ...\n+    RecursionError: definition looks circular\n+\n+Self-referent definitions also work with systems of equations::\n+\n+    sage: u = R.selfref()\n+    sage: v = R.selfref()\n+    sage: w = R.selfref()\n+\n+    sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)\n+    sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))\n+    sage: w.set(3 + 25*(u*v + v*w + u*w))\n+\n+    sage: u\n+    ...31203130103131131433\n+    sage: v\n+    ...33441043031103114240\n+    sage: w\n+    ...30212422041102444403\n+```\n \n Comment: 1\n \n``````\n",
    "created_at": "2021-01-26T13:40:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617293",
    "user": "https://github.com/xcaruso"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,166 @@
+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.
 
+Here is a small demo:
+
+```
+The model for lazy elements is quite different from any of the
+other types of `p`-adics. In addition to storing a finite
+approximation, one also stores a method for increasing the
+precision.
+
+Lazy p-adic rings are created by the constructor :func:`ZpL`::
+
+    sage: R = ZpL(5, print_mode="digits")
+    sage: R
+    5-adic Ring with lazy precision
+
+Observe that the precision is not capped on `R`::
+
+    sage: R.precision_cap()
+    +Infinity
+
+However, a default precision is settled. This is the precision
+at which the element will be printed::
+
+    sage: R.default_prec()
+    20
+
+One creates elements as usual::
+
+    sage: a = R(17/42)
+    sage: a
+    ...00244200244200244201
+
+    sage: R.random_element()  # random
+    ...21013213133412431402
+
+Here we notice that 20 digits (that is the default precision) are printed.
+However, the computation model is designed in order to guarantee that more
+digits of `a` are available on demand.
+This feature is reflected by the fact that, when we ask for the precision
+of `a`, the software answers `\infty`::
+
+    sage: a.precision_absolute()
+    +Infinity
+
+Asking for more digits is achieved by the methods :meth:`at_precision_absolute`
+and :meth:`at_precision_relative`::
+
+    sage: a.at_precision_absolute(30)
+    ...?244200244200244200244200244201
+
+As a shortcut, one can use the operator ``@``::
+
+    sage: a@30
+    ...?244200244200244200244200244201
+
+Of course, standard operations are supported::
+
+    sage: b = R(42/17)
+    sage: a + b
+    ...03232011214322140002
+    sage: a - b
+    ...42311334324023403400
+    sage: a * b
+    ...00000000000000000001
+    sage: a / b
+    ...12442142113021233401
+    sage: sqrt(a)
+    ...20042333114021142101
+
+We observe again that only 20 digits are printed but, as before,
+more digits are available on demand::
+
+    sage: sqrt(a)@30
+    ...?142443342120042333114021142101
+
+Checking equalities between lazy p-adics is a bit subtle can could
+sometimes be puzzling at first glance.
+Actually, when it is obvious (from the previous computations) that
+the two sides of the equality are different, everything works well::
+
+    sage: a == b
+    False
+
+On the contrary, when the two numbers we want to compare are indeed
+equal, it is not possible to conclude after a finite amount of
+computations. In this case, an error is raised::
+
+    sage: a == sqrt(a)^2
+    Traceback (most recent call last):
+    ...
+    PrecisionError: unable to decide equality; try to bound precision
+
+and we are forced to check equality at some given finite precision
+as follows::
+
+    sage: a@20 == sqrt(a)^2
+    True
+    sage: a@100 == sqrt(a)^2
+    True
+
+Finally, note that checking equality may fail even when the two
+operands are different but when the first different digit is beyond
+the default precision::
+
+    sage: b == b + 5^50
+    Traceback (most recent call last):
+    ...
+    PrecisionError: unable to decide equality; try to bound precision
+
+::
+
+A quite interesting feature with lazy p-adics is the possibility to
+create (in somes cases) self-referent numbers. Here is an example.
+We first declare a new variable as follows::
+
+    sage: x = R.selfref()
+    sage: x
+    ...?.0
+
+We then use the method :meth:`set` to define `x` by writing down an equation
+it satisfies::
+
+    sage: x.set(1 + 5*x^2)
+
+The variable `x` now contains the unique solution of the equation
+`x = 1 + 5 x^2`::
+
+    sage: x
+    ...04222412141121000211
+
+This works because the `n`-th digit of the right hand size of the
+defining equation only involves the `i`-th digits of `x` with `i < n`
+(this is due to the factor `5`).
+
+As a comparison, the following does not work::
+
+    sage: y = R.selfref()
+    sage: y.set(1 + 3*y^2)
+    sage: y
+    ...?.0
+    sage: y@20
+    Traceback (most recent call last):
+    ...
+    RecursionError: definition looks circular
+
+Self-referent definitions also work with systems of equations::
+
+    sage: u = R.selfref()
+    sage: v = R.selfref()
+    sage: w = R.selfref()
+
+    sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)
+    sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))
+    sage: w.set(3 + 25*(u*v + v*w + u*w))
+
+    sage: u
+    ...31203130103131131433
+    sage: v
+    ...33441043031103114240
+    sage: w
+    ...30212422041102444403
+```
 
 Comment: 1
 
``````




---

archive/issue_comments_617294.json:
```json
{
    "body": "<a id='comment:23'></a>A note about operator choice: While the ``@`` notation is definite informative and cute when considered stand-alone, it doesn't fit very well with other places where the operator is used in python. Specifically, the operator was introduced upon request of the numpy people, to signify matrix multiplication. With that in mind ``@`` has a rather strong association with (function) composition (which, in a specific way, is also how you could read ``@`` decorators to function definitions).\n\nThere's a reasonable chance that ``@`` will at some point be integrated in the coercion framework. The use for ``@`` proposed here will cause problems. I'd suggest just using a named method to cap precision.\n\nOtherwise, this package looks really cool! It would be great to see some performance specs at some point.",
    "created_at": "2021-01-26T17:53:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617294",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:23'></a>A note about operator choice: While the ``@`` notation is definite informative and cute when considered stand-alone, it doesn't fit very well with other places where the operator is used in python. Specifically, the operator was introduced upon request of the numpy people, to signify matrix multiplication. With that in mind ``@`` has a rather strong association with (function) composition (which, in a specific way, is also how you could read ``@`` decorators to function definitions).

There's a reasonable chance that ``@`` will at some point be integrated in the coercion framework. The use for ``@`` proposed here will cause problems. I'd suggest just using a named method to cap precision.

Otherwise, this package looks really cool! It would be great to see some performance specs at some point.



---

archive/issue_comments_617295.json:
```json
{
    "body": "<a id='comment:24'></a>I'm a bit disappointed but I note your argument for ``@`` and will probably disallow this construction.\n\nAbout performances, it's of course not as fast as other types of p-adics but I would say that it's already reasonable (although optimizations are still possible):\n\n```\n    sage: R = ZpL(5)\n    sage: a = R.random_element()\n    sage: b = R.random_element()\n    sage: c = 1 + 5*R.random_element()\n    sage: %timeit _ = (a + b)@10000\n    848 \u00b5s \u00b1 614 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n    sage: %timeit _ = (a * b)@10000\n    9.59 ms \u00b1 116 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n    sage: %timeit _ = (a / b)@10000\n    11.7 ms \u00b1 215 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n    sage: %timeit _ = c.sqrt()@10000\n    13.7 ms \u00b1 240 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n```\n\nCompare with:\n\n```\n    sage: R = Zp(5, prec=10000)\n    sage: a = R.random_element()\n    sage: b = R.random_element()\n    sage: c = 1 + 5*R.random_element()\n    sage: %timeit _ = a + b\n    1.21 \u00b5s \u00b1 9.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n    sage: %timeit _ = a * b\n    87.8 \u00b5s \u00b1 130 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n    sage: %timeit _ = a / b\n    667 \u00b5s \u00b1 4.08 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n    sage: %timeit _ = c.sqrt()\n    27.4 ms \u00b1 125 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n```\n\nEDIT: use `%timeit` instead of `%time`",
    "created_at": "2021-01-26T18:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617295",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:24'></a>I'm a bit disappointed but I note your argument for ``@`` and will probably disallow this construction.

About performances, it's of course not as fast as other types of p-adics but I would say that it's already reasonable (although optimizations are still possible):

```
    sage: R = ZpL(5)
    sage: a = R.random_element()
    sage: b = R.random_element()
    sage: c = 1 + 5*R.random_element()
    sage: %timeit _ = (a + b)@10000
    848 s  614 ns per loop (mean  std. dev. of 7 runs, 1000 loops each)
    sage: %timeit _ = (a * b)@10000
    9.59 ms  116 s per loop (mean  std. dev. of 7 runs, 100 loops each)
    sage: %timeit _ = (a / b)@10000
    11.7 ms  215 s per loop (mean  std. dev. of 7 runs, 100 loops each)
    sage: %timeit _ = c.sqrt()@10000
    13.7 ms  240 s per loop (mean  std. dev. of 7 runs, 100 loops each)
```

Compare with:

```
    sage: R = Zp(5, prec=10000)
    sage: a = R.random_element()
    sage: b = R.random_element()
    sage: c = 1 + 5*R.random_element()
    sage: %timeit _ = a + b
    1.21 s  9.2 ns per loop (mean  std. dev. of 7 runs, 1000000 loops each)
    sage: %timeit _ = a * b
    87.8 s  130 ns per loop (mean  std. dev. of 7 runs, 10000 loops each)
    sage: %timeit _ = a / b
    667 s  4.08 s per loop (mean  std. dev. of 7 runs, 1000 loops each)
    sage: %timeit _ = c.sqrt()
    27.4 ms  125 s per loop (mean  std. dev. of 7 runs, 10 loops each)
```

EDIT: use `%timeit` instead of `%time`



---

archive/issue_comments_617296.json:
```json
{
    "body": "<a id='comment:25'></a>Maybe some comments on the timings.\nThe \"bad\" performances of lazy p-adic come from two different sources:\n- the underlying arithmetics looses a factor log(precision) in the complexity\n- I'm working on digits, which means that I basically only manipulate integers between 0 and p (here p=5) and encode them on longs.\n\nAlthough I cannot do much to get rid of the first problem, I can certainly do something for the second one: instead of working with digits, I can work with blocks of digits (limbs) of the correct size. Actually, I want to do this but this requires many changes in my current code and I planned to delay this for another ticket.\n\nIn any case, when p becomes larger, the differences of performances between lazy p-adics and classical p-adics tend to get smaller.\n\n```\n    sage: p = next_prime(2^63)\n    sage: R = ZpL(p)\n\n    sage: a = R.random_element()\n    sage: b = R.random_element()\n    sage: c = 1 + p*R.random_element()\n    sage: %timeit _ = (a + b)@10000\n    3.51 ms \u00b1 407 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n    sage: %timeit _ = (a * b)@10000\n    73.7 ms \u00b1 189 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n    sage: %timeit _ = (a / b)@10000\n    83.4 ms \u00b1 471 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n    sage: %timeit _ = c.sqrt()@10000\n    160 ms \u00b1 3.31 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n```\n\nand:\n\n```\n    sage: p = next_prime(2^63)\n    sage: R = Zp(p, prec=10000)\n\n    sage: a = R.random_element()\n    sage: b = R.random_element()\n    sage: c = 1 + p*R.random_element()\n    sage: %timeit _ = a + b\n    86.4 \u00b5s \u00b1 578 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n    sage: %timeit _ = a * b\n    9.04 ms \u00b1 63.9 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n    sage: %timeit _ = a / b\n    78.8 ms \u00b1 415 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n    sage: %timeit _ = c.sqrt()\n    672 ms \u00b1 1.23 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```",
    "created_at": "2021-01-26T20:01:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617296",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:25'></a>Maybe some comments on the timings.
The "bad" performances of lazy p-adic come from two different sources:
- the underlying arithmetics looses a factor log(precision) in the complexity
- I'm working on digits, which means that I basically only manipulate integers between 0 and p (here p=5) and encode them on longs.

Although I cannot do much to get rid of the first problem, I can certainly do something for the second one: instead of working with digits, I can work with blocks of digits (limbs) of the correct size. Actually, I want to do this but this requires many changes in my current code and I planned to delay this for another ticket.

In any case, when p becomes larger, the differences of performances between lazy p-adics and classical p-adics tend to get smaller.

```
    sage: p = next_prime(2^63)
    sage: R = ZpL(p)

    sage: a = R.random_element()
    sage: b = R.random_element()
    sage: c = 1 + p*R.random_element()
    sage: %timeit _ = (a + b)@10000
    3.51 ms  407 s per loop (mean  std. dev. of 7 runs, 100 loops each)
    sage: %timeit _ = (a * b)@10000
    73.7 ms  189 s per loop (mean  std. dev. of 7 runs, 10 loops each)
    sage: %timeit _ = (a / b)@10000
    83.4 ms  471 s per loop (mean  std. dev. of 7 runs, 10 loops each)
    sage: %timeit _ = c.sqrt()@10000
    160 ms  3.31 ms per loop (mean  std. dev. of 7 runs, 10 loops each)
```

and:

```
    sage: p = next_prime(2^63)
    sage: R = Zp(p, prec=10000)

    sage: a = R.random_element()
    sage: b = R.random_element()
    sage: c = 1 + p*R.random_element()
    sage: %timeit _ = a + b
    86.4 s  578 ns per loop (mean  std. dev. of 7 runs, 10000 loops each)
    sage: %timeit _ = a * b
    9.04 ms  63.9 s per loop (mean  std. dev. of 7 runs, 100 loops each)
    sage: %timeit _ = a / b
    78.8 ms  415 s per loop (mean  std. dev. of 7 runs, 10 loops each)
    sage: %timeit _ = c.sqrt()
    672 ms  1.23 ms per loop (mean  std. dev. of 7 runs, 1 loop each)
```



---

archive/issue_comments_617297.json:
```json
{
    "body": "Changing commit from \"f395104a6ec660d8c9fad4dbe8613290a54642cf\" to \"7fc3fb35f8c363c1200e5761fa7d0a9acd26d743\"",
    "created_at": "2021-01-28T23:45:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617297",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "f395104a6ec660d8c9fad4dbe8613290a54642cf" to "7fc3fb35f8c363c1200e5761fa7d0a9acd26d743"



---

archive/issue_comments_617298.json:
```json
{
    "body": "<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-28T23:45:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617298",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617299.json:
```json
{
    "body": "Changing commit from \"7fc3fb35f8c363c1200e5761fa7d0a9acd26d743\" to \"bac0fd109708dc1305db0a4f5f080b2d1fa2f519\"",
    "created_at": "2021-01-30T16:08:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617299",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "7fc3fb35f8c363c1200e5761fa7d0a9acd26d743" to "bac0fd109708dc1305db0a4f5f080b2d1fa2f519"



---

archive/issue_comments_617300.json:
```json
{
    "body": "<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-30T16:08:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617300",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617301.json:
```json
{
    "body": "<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-31T08:40:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617301",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617302.json:
```json
{
    "body": "Changing commit from \"bac0fd109708dc1305db0a4f5f080b2d1fa2f519\" to \"ab8111d78c0d31e72b6a668fc5b664f6707d41a3\"",
    "created_at": "2021-01-31T08:40:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617302",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "bac0fd109708dc1305db0a4f5f080b2d1fa2f519" to "ab8111d78c0d31e72b6a668fc5b664f6707d41a3"



---

archive/issue_comments_617303.json:
```json
{
    "body": "Changing commit from \"ab8111d78c0d31e72b6a668fc5b664f6707d41a3\" to \"30089ba5a067f09a8d7f4deabbf26f611e8d8b1e\"",
    "created_at": "2021-02-11T00:19:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617303",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "ab8111d78c0d31e72b6a668fc5b664f6707d41a3" to "30089ba5a067f09a8d7f4deabbf26f611e8d8b1e"



---

archive/issue_comments_617304.json:
```json
{
    "body": "<a id='comment:29'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-11T00:19:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617304",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:29'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617305.json:
```json
{
    "body": "<a id='comment:30'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-11T11:19:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617305",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:30'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617306.json:
```json
{
    "body": "Changing commit from \"30089ba5a067f09a8d7f4deabbf26f611e8d8b1e\" to \"e0acbd9770d38d400fa9debc739f1935cdc54aba\"",
    "created_at": "2021-02-11T11:19:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617306",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "30089ba5a067f09a8d7f4deabbf26f611e8d8b1e" to "e0acbd9770d38d400fa9debc739f1935cdc54aba"



---

archive/issue_comments_617307.json:
```json
{
    "body": "<a id='comment:31'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-11T15:10:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617307",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:31'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617308.json:
```json
{
    "body": "Changing commit from \"e0acbd9770d38d400fa9debc739f1935cdc54aba\" to \"0cf1d59137af3e6a346153e148120e934669d347\"",
    "created_at": "2021-02-11T15:10:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617308",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "e0acbd9770d38d400fa9debc739f1935cdc54aba" to "0cf1d59137af3e6a346153e148120e934669d347"



---

archive/issue_comments_617309.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2021-02-11T15:12:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617309",
    "user": "https://github.com/xcaruso"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_617310.json:
```json
{
    "body": "<a id='comment:32'></a>I guess that the ticket is ready for a first review...",
    "created_at": "2021-02-11T15:12:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617310",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:32'></a>I guess that the ticket is ready for a first review...



---

archive/issue_comments_617311.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,169 @@\n+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.\n \n+Here is a small demo:\n+\n+```\n+The model for lazy elements is quite different from any of the\n+other types of `p`-adics. In addition to storing a finite\n+approximation, one also stores a method for increasing the\n+precision.\n+\n+Lazy `p`-adic rings are created by the constructor :func:`ZpL`::\n+\n+    sage: R = ZpL(5, print_mode=\"digits\")\n+    sage: R\n+    5-adic Ring with lazy precision\n+\n+The precision is not capped on `R`::\n+\n+    sage: R.precision_cap()\n+    +Infinity\n+\n+However, a default precision is settled. This is the precision\n+at which the elements will be printed::\n+\n+    sage: R.default_prec()\n+    20\n+\n+One creates elements as usual::\n+\n+    sage: a = R(17/42)\n+    sage: a\n+    ...00244200244200244201\n+\n+    sage: R.random_element()  # random\n+    ...21013213133412431402\n+\n+Here we notice that 20 digits (that is the default precision) are printed.\n+However, the computation model is designed in order to guarantee that more\n+digits of `a` will be available on demand.\n+This feature is reflected by the fact that, when we ask for the precision\n+of `a`, the software answers `+\\infty`::\n+\n+    sage: a.precision_absolute()\n+    +Infinity\n+\n+Asking for more digits is achieved by the methods :meth:`at_precision_absolute`\n+and :meth:`at_precision_relative`::\n+\n+    sage: a.at_precision_absolute(30)\n+    ...?244200244200244200244200244201\n+\n+As a shortcut, one can use the bracket operator::\n+\n+    sage: a[:30]\n+    ...?244200244200244200244200244201\n+\n+Of course, standard operations are supported::\n+\n+    sage: b = R(42/17)\n+    sage: a + b\n+    ...03232011214322140002\n+    sage: a - b\n+    ...42311334324023403400\n+    sage: a * b\n+    ...00000000000000000001\n+    sage: a / b\n+    ...12442142113021233401\n+    sage: sqrt(a)\n+    ...20042333114021142101\n+\n+We observe again that only 20 digits are printed but, as before,\n+more digits are available on demand::\n+\n+    sage: sqrt(a)[:30]\n+    ...?142443342120042333114021142101\n+\n+.. RUBRIC:: Equality tests\n+\n+Checking equalities between lazy `p`-adics is a bit subtle and can\n+sometimes be puzzling at first glance.\n+Actually, when it is obvious (from the previous computations) that\n+the two sides of the equality are different, everything works well::\n+\n+    sage: a == b\n+    False\n+\n+On the contrary, when the two numbers we want to compare are indeed\n+equal, it is not possible to conclude after a finite amount of\n+computations. In this case, an error is raised::\n+\n+    sage: a == sqrt(a)^2\n+    Traceback (most recent call last):\n+    ...\n+    PrecisionError: unable to decide equality; try to bound precision\n+\n+and we are forced to check equality at some given finite precision\n+as follows::\n+\n+    sage: a[:20] == sqrt(a)^2\n+    True\n+    sage: a[:100] == sqrt(a)^2\n+    True\n+\n+Finally, note that checking equality may fail even when the two\n+operands are different but when the first different digit is beyond\n+the default precision::\n+\n+    sage: b == b + 5^50\n+    Traceback (most recent call last):\n+    ...\n+    PrecisionError: unable to decide equality; try to bound precision\n+\n+.. RUBRIC:: Self-referent numbers\n+\n+A quite interesting feature with lazy `p`-adics is the possibility to\n+create (in some cases) self-referent numbers. Here is an example.\n+We first declare a new variable as follows::\n+\n+    sage: x = R.selfref()\n+    sage: x\n+    ...?.0\n+\n+We then use the method :meth:`set` to define `x` by writing down an equation\n+it satisfies::\n+\n+    sage: x.set(1 + 5*x^2)\n+\n+The variable `x` now contains the unique solution of the equation\n+`x = 1 + 5 x^2`::\n+\n+    sage: x\n+    ...04222412141121000211\n+\n+This works because the `n`-th digit of the right hand size of the\n+defining equation only involves the `i`-th digits of `x` with `i < n`\n+(this is due to the factor `5`).\n+\n+As a comparison, the following does not work::\n+\n+    sage: y = R.selfref()\n+    sage: y.set(1 + 3*y^2)\n+    sage: y\n+    ...?.0\n+    sage: y[:20]\n+    Traceback (most recent call last):\n+    ...\n+    RecursionError: definition looks circular\n+\n+Self-referent definitions also work with systems of equations::\n+\n+    sage: u = R.selfref()\n+    sage: v = R.selfref()\n+    sage: w = R.selfref()\n+\n+    sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)\n+    sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))\n+    sage: w.set(3 + 25*(u*v + v*w + u*w))\n+\n+    sage: u\n+    ...31203130103131131433\n+    sage: v\n+    ...33441043031103114240\n+    sage: w\n+    ...30212422041102444403\n+\n+```\n \n Comment: 1\n \n``````\n",
    "created_at": "2021-02-15T10:03:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617311",
    "user": "https://github.com/xcaruso"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,169 @@
+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.
 
+Here is a small demo:
+
+```
+The model for lazy elements is quite different from any of the
+other types of `p`-adics. In addition to storing a finite
+approximation, one also stores a method for increasing the
+precision.
+
+Lazy `p`-adic rings are created by the constructor :func:`ZpL`::
+
+    sage: R = ZpL(5, print_mode="digits")
+    sage: R
+    5-adic Ring with lazy precision
+
+The precision is not capped on `R`::
+
+    sage: R.precision_cap()
+    +Infinity
+
+However, a default precision is settled. This is the precision
+at which the elements will be printed::
+
+    sage: R.default_prec()
+    20
+
+One creates elements as usual::
+
+    sage: a = R(17/42)
+    sage: a
+    ...00244200244200244201
+
+    sage: R.random_element()  # random
+    ...21013213133412431402
+
+Here we notice that 20 digits (that is the default precision) are printed.
+However, the computation model is designed in order to guarantee that more
+digits of `a` will be available on demand.
+This feature is reflected by the fact that, when we ask for the precision
+of `a`, the software answers `+\infty`::
+
+    sage: a.precision_absolute()
+    +Infinity
+
+Asking for more digits is achieved by the methods :meth:`at_precision_absolute`
+and :meth:`at_precision_relative`::
+
+    sage: a.at_precision_absolute(30)
+    ...?244200244200244200244200244201
+
+As a shortcut, one can use the bracket operator::
+
+    sage: a[:30]
+    ...?244200244200244200244200244201
+
+Of course, standard operations are supported::
+
+    sage: b = R(42/17)
+    sage: a + b
+    ...03232011214322140002
+    sage: a - b
+    ...42311334324023403400
+    sage: a * b
+    ...00000000000000000001
+    sage: a / b
+    ...12442142113021233401
+    sage: sqrt(a)
+    ...20042333114021142101
+
+We observe again that only 20 digits are printed but, as before,
+more digits are available on demand::
+
+    sage: sqrt(a)[:30]
+    ...?142443342120042333114021142101
+
+.. RUBRIC:: Equality tests
+
+Checking equalities between lazy `p`-adics is a bit subtle and can
+sometimes be puzzling at first glance.
+Actually, when it is obvious (from the previous computations) that
+the two sides of the equality are different, everything works well::
+
+    sage: a == b
+    False
+
+On the contrary, when the two numbers we want to compare are indeed
+equal, it is not possible to conclude after a finite amount of
+computations. In this case, an error is raised::
+
+    sage: a == sqrt(a)^2
+    Traceback (most recent call last):
+    ...
+    PrecisionError: unable to decide equality; try to bound precision
+
+and we are forced to check equality at some given finite precision
+as follows::
+
+    sage: a[:20] == sqrt(a)^2
+    True
+    sage: a[:100] == sqrt(a)^2
+    True
+
+Finally, note that checking equality may fail even when the two
+operands are different but when the first different digit is beyond
+the default precision::
+
+    sage: b == b + 5^50
+    Traceback (most recent call last):
+    ...
+    PrecisionError: unable to decide equality; try to bound precision
+
+.. RUBRIC:: Self-referent numbers
+
+A quite interesting feature with lazy `p`-adics is the possibility to
+create (in some cases) self-referent numbers. Here is an example.
+We first declare a new variable as follows::
+
+    sage: x = R.selfref()
+    sage: x
+    ...?.0
+
+We then use the method :meth:`set` to define `x` by writing down an equation
+it satisfies::
+
+    sage: x.set(1 + 5*x^2)
+
+The variable `x` now contains the unique solution of the equation
+`x = 1 + 5 x^2`::
+
+    sage: x
+    ...04222412141121000211
+
+This works because the `n`-th digit of the right hand size of the
+defining equation only involves the `i`-th digits of `x` with `i < n`
+(this is due to the factor `5`).
+
+As a comparison, the following does not work::
+
+    sage: y = R.selfref()
+    sage: y.set(1 + 3*y^2)
+    sage: y
+    ...?.0
+    sage: y[:20]
+    Traceback (most recent call last):
+    ...
+    RecursionError: definition looks circular
+
+Self-referent definitions also work with systems of equations::
+
+    sage: u = R.selfref()
+    sage: v = R.selfref()
+    sage: w = R.selfref()
+
+    sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)
+    sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))
+    sage: w.set(3 + 25*(u*v + v*w + u*w))
+
+    sage: u
+    ...31203130103131131433
+    sage: v
+    ...33441043031103114240
+    sage: w
+    ...30212422041102444403
+
+```
 
 Comment: 1
 
``````




---

archive/issue_comments_617312.json:
```json
{
    "body": "Changing author from \"\" to \"Xavier Caruso\"",
    "created_at": "2021-02-15T10:03:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617312",
    "user": "https://github.com/xcaruso"
}
```

Changing author from "" to "Xavier Caruso"



---

archive/issue_comments_617313.json:
```json
{
    "body": "<a id='comment:34'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-18T22:26:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617313",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:34'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617314.json:
```json
{
    "body": "Changing commit from \"0cf1d59137af3e6a346153e148120e934669d347\" to \"9398e979dc4c22deed2140d039bba807616accb2\"",
    "created_at": "2021-02-18T22:26:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617314",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "0cf1d59137af3e6a346153e148120e934669d347" to "9398e979dc4c22deed2140d039bba807616accb2"



---

archive/issue_comments_617315.json:
```json
{
    "body": "<a id='comment:35'></a>Some issues that we talked about on video:\n\n* Add some halting parameters to the parent\n* Inconsistency with valuation and set method.  Add a check parameter to `set` to ensure that the element satisfies the given equation (even with provided valuation and/or digits) or have `set` return `True` or `False` depending on whether the equation is satisfied.\n* Figure out segfaults in gcd computations, conversions\n* Change `selfref` to `unknown`\n\nFor another ticket: add more transcendental functions like `exp` and `log`",
    "created_at": "2021-02-18T22:29:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617315",
    "user": "https://github.com/roed314"
}
```

<a id='comment:35'></a>Some issues that we talked about on video:

* Add some halting parameters to the parent
* Inconsistency with valuation and set method.  Add a check parameter to `set` to ensure that the element satisfies the given equation (even with provided valuation and/or digits) or have `set` return `True` or `False` depending on whether the equation is satisfied.
* Figure out segfaults in gcd computations, conversions
* Change `selfref` to `unknown`

For another ticket: add more transcendental functions like `exp` and `log`



---

archive/issue_comments_617316.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2021-02-18T22:29:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617316",
    "user": "https://github.com/roed314"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_617317.json:
```json
{
    "body": "Changing reviewer from \"\" to \"David Roe\"",
    "created_at": "2021-02-18T22:29:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617317",
    "user": "https://github.com/roed314"
}
```

Changing reviewer from "" to "David Roe"



---

archive/issue_comments_617318.json:
```json
{
    "body": "<a id='comment:36'></a>More comments as I read through the code.\n\n* In `digit_smallest` you call `fmpz_init` but not `fmpz_clear`.  I think this is a memory leak.  I may have missed other leaks....  I also think that the documentation of `digit_smallest` should clarify that the input should already be in the range `0..p-1`.\n* For `digit_sqrt` it may be worth using FLINT's `n_sqrtmod` if `p` is word-size.  You could also do some other easy cases in-line rather than calling out to Sage's integer_mod code.  See `square_root_mod_prime` in `sage/rings/finite_rings/integer_mod.pyx`.\n* You should add documentation to `sage/misc/persist.pyx` on how `already_pickled` and `already_unpickled` are intended to work, and some tests to check that it's working correctly.\n* When converting an element between a lazy p-adic ring and its field of fractions it looks in `_element_constructor_` that you create a bounded element.  Why is this necessary?  It also looks like you don't check that the primes are the same....\n* The error codes in `padic_lazy_error.pyx` and `next_c()` aren't the same.\n* In `_repr_` it looks like some print modes aren't included (e.g. `terse` and `val-unit`).  I would guess it to be easier to use code from `padic_printing.pyx` here.\n* Last week we talked about adding some parameters about how halting is handled (e.g. a strict mode that raises an error whenever unbounded elements are compared).  `__nonzero__` should also be updated.  I think the precision behavior for `__nonzero__` should be the same as for `== 0`; currently it will return `True` rather than raising a precision error if it looks like `0` at known precision.\n* I found the use of `permissive=None` a bit strange in `at_precision_absolute`.  I think if a user specifies infinite precision, `permissive` should be treated as `False` (so, replace `if permissive is False` with `if not permissive`.\n* Shouldn't `at_precision_relative` also support `prec=infinity`?\n* You can probably remove some code by changing `if error: raise_error(error)` to just `raise_error(error)` since this has no effect if error is 0.\n* `_sub_` has a bug: currently `0-1` will give `1`.\n\nMore comments to come....",
    "created_at": "2021-02-25T20:31:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617318",
    "user": "https://github.com/roed314"
}
```

<a id='comment:36'></a>More comments as I read through the code.

* In `digit_smallest` you call `fmpz_init` but not `fmpz_clear`.  I think this is a memory leak.  I may have missed other leaks....  I also think that the documentation of `digit_smallest` should clarify that the input should already be in the range `0..p-1`.
* For `digit_sqrt` it may be worth using FLINT's `n_sqrtmod` if `p` is word-size.  You could also do some other easy cases in-line rather than calling out to Sage's integer_mod code.  See `square_root_mod_prime` in `sage/rings/finite_rings/integer_mod.pyx`.
* You should add documentation to `sage/misc/persist.pyx` on how `already_pickled` and `already_unpickled` are intended to work, and some tests to check that it's working correctly.
* When converting an element between a lazy p-adic ring and its field of fractions it looks in `_element_constructor_` that you create a bounded element.  Why is this necessary?  It also looks like you don't check that the primes are the same....
* The error codes in `padic_lazy_error.pyx` and `next_c()` aren't the same.
* In `_repr_` it looks like some print modes aren't included (e.g. `terse` and `val-unit`).  I would guess it to be easier to use code from `padic_printing.pyx` here.
* Last week we talked about adding some parameters about how halting is handled (e.g. a strict mode that raises an error whenever unbounded elements are compared).  `__nonzero__` should also be updated.  I think the precision behavior for `__nonzero__` should be the same as for `== 0`; currently it will return `True` rather than raising a precision error if it looks like `0` at known precision.
* I found the use of `permissive=None` a bit strange in `at_precision_absolute`.  I think if a user specifies infinite precision, `permissive` should be treated as `False` (so, replace `if permissive is False` with `if not permissive`.
* Shouldn't `at_precision_relative` also support `prec=infinity`?
* You can probably remove some code by changing `if error: raise_error(error)` to just `raise_error(error)` since this has no effect if error is 0.
* `_sub_` has a bug: currently `0-1` will give `1`.

More comments to come....



---

archive/issue_comments_617319.json:
```json
{
    "body": "<a id='comment:37'></a>* In `next_c()` for random elements, do you need to `digit_clear(r)` in both branches of the if statement?\n* It would be good to have some tests for slices of slices.\n* In `next_c()` for `LazyElement_div`, if `definition is None` and you set it, don't you still want to execute the `else` clause?  If not, you can just `return self._bootstrap_c()` rather than `if error: return error`.  Same for `LazyElement_sqrt`.\n* In the `__init__` method for `LazyElement_sqrt`, shouldn't you check that the valuation is even?\n* You should probably delete the `next` method on `LazyElement_sqrt` (I assume it was for debugging; it's not documented).",
    "created_at": "2021-02-26T08:42:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617319",
    "user": "https://github.com/roed314"
}
```

<a id='comment:37'></a>* In `next_c()` for random elements, do you need to `digit_clear(r)` in both branches of the if statement?
* It would be good to have some tests for slices of slices.
* In `next_c()` for `LazyElement_div`, if `definition is None` and you set it, don't you still want to execute the `else` clause?  If not, you can just `return self._bootstrap_c()` rather than `if error: return error`.  Same for `LazyElement_sqrt`.
* In the `__init__` method for `LazyElement_sqrt`, shouldn't you check that the valuation is even?
* You should probably delete the `next` method on `LazyElement_sqrt` (I assume it was for debugging; it's not documented).



---

archive/issue_comments_617320.json:
```json
{
    "body": "Changing branch from \"u/caruso/relaxed\" to \"u/roed/relaxed\"",
    "created_at": "2021-03-01T19:40:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617320",
    "user": "https://github.com/roed314"
}
```

Changing branch from "u/caruso/relaxed" to "u/roed/relaxed"



---

archive/issue_comments_617321.json:
```json
{
    "body": "<a id='comment:39'></a>Replying to [comment:36 roed] and [comment:37 roed]:\n> * In `digit_smallest` you call `fmpz_init` but not `fmpz_clear`.  I think this is a memory leak.  I may have missed other leaks....  I also think that the documentation of `digit_smallest` should clarify that the input should already be in the range `0..p-1`.\n> * You should add documentation to `sage/misc/persist.pyx` on how `already_pickled` and `already_unpickled` are intended to work, and some tests to check that it's working correctly.\n> * The error codes in `padic_lazy_error.pyx` and `next_c()` aren't the same.\n> * I found the use of `permissive=None` a bit strange in `at_precision_absolute`.  I think if a user specifies infinite precision, `permissive` should be treated as `False` (so, replace `if permissive is False` with `if not permissive`.\n> * Shouldn't `at_precision_relative` also support `prec=infinity`?\n> * You can probably remove some code by changing `if error: raise_error(error)` to just `raise_error(error)` since this has no effect if error is 0.\n> * `_sub_` has a bug: currently `0-1` will give `1`.\n> * In `next_c()` for random elements, do you need to `digit_clear(r)` in both branches of the if statement?\n> * It would be good to have some tests for slices of slices.\n> * You should probably delete the `next` method on `LazyElement_sqrt` (I assume it was for debugging; it's not documented).\n\n\nFixed.\n\n> * In `_repr_` it looks like some print modes aren't included (e.g. `terse` and `val-unit`).  I would guess it to be easier to use code from `padic_printing.pyx` here.\n\n\nThey are included.\nI agree that we should include this code in `padic_printing.pyx` but it does not sounds easy.\n\n> * When converting an element between a lazy p-adic ring and its field of fractions it looks in `_element_constructor_` that you create a bounded element.  Why is this necessary?  It also looks like you don't check that the primes are the same....\n\n\nIt's true than I call `LazyElement_bound` but I pass in `boundprec=maxordp` so that the resulting element remains unbounded. It's a convenient way to do copies. (I cannot return the same element because the parent changes.)\n\n> * In `next_c()` for `LazyElement_div`, if `definition is None` and you set it, don't you still want to execute the `else` clause?  If not, you can just `return self._bootstrap_c()` rather than `if error: return error`.  Same for `LazyElement_sqrt`.\n\n\nWell, `_bootstrap_c` already computes the first significant digit, so I think it's fine like this. I changed `if error: return error` to `return self._bootstrap_c()`.\n\n> * In the `__init__` method for `LazyElement_sqrt`, shouldn't you check that the valuation is even?\n\n\nIt's checked in the bootstrap function.\nI think we cannot check it in the `__init__` method because the valuation might be not known for self-referent numbers.\n\n---\nNew commits:",
    "created_at": "2021-03-04T21:57:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617321",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:39'></a>Replying to [comment:36 roed] and [comment:37 roed]:
> * In `digit_smallest` you call `fmpz_init` but not `fmpz_clear`.  I think this is a memory leak.  I may have missed other leaks....  I also think that the documentation of `digit_smallest` should clarify that the input should already be in the range `0..p-1`.
> * You should add documentation to `sage/misc/persist.pyx` on how `already_pickled` and `already_unpickled` are intended to work, and some tests to check that it's working correctly.
> * The error codes in `padic_lazy_error.pyx` and `next_c()` aren't the same.
> * I found the use of `permissive=None` a bit strange in `at_precision_absolute`.  I think if a user specifies infinite precision, `permissive` should be treated as `False` (so, replace `if permissive is False` with `if not permissive`.
> * Shouldn't `at_precision_relative` also support `prec=infinity`?
> * You can probably remove some code by changing `if error: raise_error(error)` to just `raise_error(error)` since this has no effect if error is 0.
> * `_sub_` has a bug: currently `0-1` will give `1`.
> * In `next_c()` for random elements, do you need to `digit_clear(r)` in both branches of the if statement?
> * It would be good to have some tests for slices of slices.
> * You should probably delete the `next` method on `LazyElement_sqrt` (I assume it was for debugging; it's not documented).


Fixed.

> * In `_repr_` it looks like some print modes aren't included (e.g. `terse` and `val-unit`).  I would guess it to be easier to use code from `padic_printing.pyx` here.


They are included.
I agree that we should include this code in `padic_printing.pyx` but it does not sounds easy.

> * When converting an element between a lazy p-adic ring and its field of fractions it looks in `_element_constructor_` that you create a bounded element.  Why is this necessary?  It also looks like you don't check that the primes are the same....


It's true than I call `LazyElement_bound` but I pass in `boundprec=maxordp` so that the resulting element remains unbounded. It's a convenient way to do copies. (I cannot return the same element because the parent changes.)

> * In `next_c()` for `LazyElement_div`, if `definition is None` and you set it, don't you still want to execute the `else` clause?  If not, you can just `return self._bootstrap_c()` rather than `if error: return error`.  Same for `LazyElement_sqrt`.


Well, `_bootstrap_c` already computes the first significant digit, so I think it's fine like this. I changed `if error: return error` to `return self._bootstrap_c()`.

> * In the `__init__` method for `LazyElement_sqrt`, shouldn't you check that the valuation is even?


It's checked in the bootstrap function.
I think we cannot check it in the `__init__` method because the valuation might be not known for self-referent numbers.

---
New commits:



---

archive/issue_comments_617322.json:
```json
{
    "body": "Changing commit from \"9398e979dc4c22deed2140d039bba807616accb2\" to \"54c46e2aa52716fd74a40cfbbefece56bae23372\"",
    "created_at": "2021-03-04T21:57:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617322",
    "user": "https://github.com/xcaruso"
}
```

Changing commit from "9398e979dc4c22deed2140d039bba807616accb2" to "54c46e2aa52716fd74a40cfbbefece56bae23372"



---

archive/issue_comments_617323.json:
```json
{
    "body": "Changing branch from \"u/roed/relaxed\" to \"u/caruso/relaxed\"",
    "created_at": "2021-03-04T21:57:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617323",
    "user": "https://github.com/xcaruso"
}
```

Changing branch from "u/roed/relaxed" to "u/caruso/relaxed"



---

archive/issue_comments_617324.json:
```json
{
    "body": "<a id='comment:41'></a>And here the comments I have not addressed yet:\n\n> * Last week we talked about adding some parameters about how halting is handled (e.g. a strict mode that raises an error whenever unbounded elements are compared).  `__nonzero__` should also be updated.  I think the precision behavior for `__nonzero__` should be the same as for `== 0`; currently it will return `True` rather than raising a precision error if it looks like `0` at known precision.\n> * Inconsistency with valuation and set method.  Add a check parameter to `set` to ensure that the element satisfies the given equation (even with provided valuation and/or digits) or have `set` return `True` or `False` depending on whether the equation is satisfied.\n> * Figure out segfaults in gcd computations, conversions\n> * Change `selfref` to `unknown`\n> * For `digit_sqrt` it may be worth using FLINT's `n_sqrtmod` if `p` is word-size.  You could also do some other easy cases in-line rather than calling out to Sage's integer_mod code.  See `square_root_mod_prime` in `sage/rings/finite_rings/integer_mod.pyx`.",
    "created_at": "2021-03-04T22:00:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617324",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:41'></a>And here the comments I have not addressed yet:

> * Last week we talked about adding some parameters about how halting is handled (e.g. a strict mode that raises an error whenever unbounded elements are compared).  `__nonzero__` should also be updated.  I think the precision behavior for `__nonzero__` should be the same as for `== 0`; currently it will return `True` rather than raising a precision error if it looks like `0` at known precision.
> * Inconsistency with valuation and set method.  Add a check parameter to `set` to ensure that the element satisfies the given equation (even with provided valuation and/or digits) or have `set` return `True` or `False` depending on whether the equation is satisfied.
> * Figure out segfaults in gcd computations, conversions
> * Change `selfref` to `unknown`
> * For `digit_sqrt` it may be worth using FLINT's `n_sqrtmod` if `p` is word-size.  You could also do some other easy cases in-line rather than calling out to Sage's integer_mod code.  See `square_root_mod_prime` in `sage/rings/finite_rings/integer_mod.pyx`.



---

archive/issue_comments_617325.json:
```json
{
    "body": "<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-03-04T22:01:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617325",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617326.json:
```json
{
    "body": "Changing commit from \"54c46e2aa52716fd74a40cfbbefece56bae23372\" to \"5a5bdd963d0e9151d7bf463282c636a014d24103\"",
    "created_at": "2021-03-04T22:01:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617326",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "54c46e2aa52716fd74a40cfbbefece56bae23372" to "5a5bdd963d0e9151d7bf463282c636a014d24103"



---

archive/issue_comments_617327.json:
```json
{
    "body": "<a id='comment:43'></a>Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-24T02:04:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617327",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:43'></a>Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_081265.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-03-24T02:04:25Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31108#event-81265"
}
```



---

archive/issue_comments_617328.json:
```json
{
    "body": "Changing commit from \"5a5bdd963d0e9151d7bf463282c636a014d24103\" to \"b520df3d37344fe3dfef0b53198cefbf195910f3\"",
    "created_at": "2021-04-01T22:38:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617328",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "5a5bdd963d0e9151d7bf463282c636a014d24103" to "b520df3d37344fe3dfef0b53198cefbf195910f3"



---

archive/issue_comments_617329.json:
```json
{
    "body": "<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-01T22:38:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617329",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617330.json:
```json
{
    "body": "<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-04T18:46:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617330",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617331.json:
```json
{
    "body": "Changing commit from \"b520df3d37344fe3dfef0b53198cefbf195910f3\" to \"a4a72a532adac9d23a57af9c7115023abde73306\"",
    "created_at": "2021-04-04T18:46:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617331",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "b520df3d37344fe3dfef0b53198cefbf195910f3" to "a4a72a532adac9d23a57af9c7115023abde73306"



---

archive/issue_comments_617332.json:
```json
{
    "body": "Changing commit from \"a4a72a532adac9d23a57af9c7115023abde73306\" to \"b21c36d21cac890236e1f6865a32ccf18b184168\"",
    "created_at": "2021-04-04T19:50:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617332",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "a4a72a532adac9d23a57af9c7115023abde73306" to "b21c36d21cac890236e1f6865a32ccf18b184168"



---

archive/issue_comments_617333.json:
```json
{
    "body": "<a id='comment:46'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-04T19:50:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617333",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:46'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617334.json:
```json
{
    "body": "<a id='comment:47'></a>I think that all your comments have been addressed now.\n\nWe still need to discuss the choice of the name for the classes implemented in this ticket (cf discussion on zulip).",
    "created_at": "2021-04-04T19:52:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617334",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:47'></a>I think that all your comments have been addressed now.

We still need to discuss the choice of the name for the classes implemented in this ticket (cf discussion on zulip).



---

archive/issue_comments_617335.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2021-04-04T19:52:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617335",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_617336.json:
```json
{
    "body": "<a id='comment:48'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-07T09:16:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617336",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:48'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617337.json:
```json
{
    "body": "Changing commit from \"b21c36d21cac890236e1f6865a32ccf18b184168\" to \"7f49e18bbeb2113d4ce5a304af11c3e19f9515fb\"",
    "created_at": "2021-04-07T09:16:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617337",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "b21c36d21cac890236e1f6865a32ccf18b184168" to "7f49e18bbeb2113d4ce5a304af11c3e19f9515fb"



---

archive/issue_comments_617338.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,204 @@\n-\n+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.\n+\n+Here is a small demo:\n+\n+```\n+    The model for lazy elements is quite different from any of the\n+    other types of `p`-adics. In addition to storing a finite\n+    approximation, one also stores a method for increasing the\n+    precision.\n+\n+    Lazy `p`-adic rings are created by the constructor :func:`ZpL`::\n+\n+        sage: R = ZpL(5, print_mode=\"digits\")\n+        sage: R\n+        5-adic Ring with lazy precision\n+\n+    The precision is not capped in `R`::\n+\n+        sage: R.precision_cap()\n+        +Infinity\n+\n+    However, a default precision is fixed. This is the precision\n+    at which the elements will be printed::\n+\n+        sage: R.default_prec()\n+        20\n+\n+    A default halting precision is also set. It is the default absolute\n+    precision at which the elements will be compared. By default, it is\n+    twice the default precision::\n+\n+        sage: R.halting_prec()\n+        40\n+\n+    However, both the default precision and the halting precision can be\n+    customized at the creation of the parent as follows:\n+\n+        sage: S = ZpL(5, prec=10, halt=100)\n+        sage: S.default_prec()\n+        10\n+        sage: S.halting_prec()\n+        100\n+\n+    One creates elements as usual::\n+\n+        sage: a = R(17/42)\n+        sage: a\n+        ...00244200244200244201\n+\n+        sage: R.random_element()  # random\n+        ...21013213133412431402\n+\n+    Here we notice that 20 digits (that is the default precision) are printed.\n+    However, the computation model is designed in order to guarantee that more\n+    digits of `a` will be available on demand.\n+    This feature is reflected by the fact that, when we ask for the precision\n+    of `a`, the software answers `+\\infty`::\n+\n+        sage: a.precision_absolute()\n+        +Infinity\n+\n+    Asking for more digits is achieved by the methods :meth:`at_precision_absolute`\n+    and :meth:`at_precision_relative`::\n+\n+        sage: a.at_precision_absolute(30)\n+        ...?244200244200244200244200244201\n+\n+    As a shortcut, one can use the bracket operator::\n+\n+        sage: a[:30]\n+        ...?244200244200244200244200244201\n+\n+    Of course, standard operations are supported::\n+\n+        sage: b = R(42/17)\n+        sage: a + b\n+        ...03232011214322140002\n+        sage: a - b\n+        ...42311334324023403400\n+        sage: a * b\n+        ...00000000000000000001\n+        sage: a / b\n+        ...12442142113021233401\n+        sage: sqrt(a)\n+        ...20042333114021142101\n+\n+    We observe again that only 20 digits are printed but, as before,\n+    more digits are available on demand::\n+\n+        sage: sqrt(a)[:30]\n+        ...?142443342120042333114021142101\n+\n+    .. RUBRIC:: Equality tests\n+\n+    Checking equalities between lazy `p`-adics is a bit subtle and can\n+    sometimes be puzzling at first glance.\n+\n+    When the parent is created with ``secure=False`` (which is the\n+    default), elements are compared at the current precision, or at the\n+    default halting precision if it is higher::\n+\n+        sage: a == b\n+        False\n+\n+        sage: a == sqrt(a)^2\n+        True\n+        sage: a == sqrt(a)^2 + 5^50\n+        True\n+\n+    In the above example, the halting precision is `40`; it is the\n+    reason why a congruence modulo `5^50` is considered as an equality.\n+    However, if both sides of the equalities have been previously\n+    computed with more digits, those digits are taken into account.\n+    Hence comparing two elements at different times can produce\n+    different results::\n+\n+        sage: aa = sqrt(a)^2 + 5^50\n+        sage: a == aa\n+        True\n+        sage: a[:60]\n+        ...?244200244200244200244200244200244200244200244200244200244201\n+        sage: aa[:60]\n+        ...?244200244300244200244200244200244200244200244200244200244201\n+        sage: a == aa\n+        False\n+\n+    This annoying situation, where the output of `a == aa` may change\n+    depending on previous computations, cannot occur when the parent is\n+    created with ``secure=True``.\n+    Indeed, in this case, if the equality cannot be decided, an error\n+    is raised::\n+\n+        sage: S = ZpL(5, secure=True)\n+        sage: u = S.random_element()\n+        sage: uu = u + 5^50\n+        sage: u == uu\n+        Traceback (most recent call last):\n+        ...\n+        PrecisionError: unable to decide equality; try to bound precision\n+\n+        sage: u[:60] == uu\n+        False\n+\n+    .. RUBRIC:: Self-referent numbers\n+\n+    A quite interesting feature with lazy `p`-adics is the possibility to\n+    create (in some cases) self-referent numbers. Here is an example.\n+    We first declare a new variable as follows::\n+\n+        sage: x = R.unknown()\n+        sage: x\n+        ...?.0\n+\n+    We then use the method :meth:`set` to define `x` by writing down an equation\n+    it satisfies::\n+\n+        sage: x.set(1 + 5*x^2)\n+        True\n+\n+    The variable `x` now contains the unique solution of the equation\n+    `x = 1 + 5 x^2`::\n+\n+        sage: x\n+        ...04222412141121000211\n+\n+    This works because the `n`-th digit of the right hand size of the\n+    defining equation only involves the `i`-th digits of `x` with `i < n`\n+    (this is due to the factor `5`).\n+\n+    As a comparison, the following does not work::\n+\n+        sage: y = R.unknown()\n+        sage: y.set(1 + 3*y^2)\n+        True\n+        sage: y\n+        ...?.0\n+        sage: y[:20]\n+        Traceback (most recent call last):\n+        ...\n+        RecursionError: definition looks circular\n+\n+    Self-referent definitions also work with systems of equations::\n+\n+        sage: u = R.unknown()\n+        sage: v = R.unknown()\n+        sage: w = R.unknown()\n+\n+        sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)\n+        True\n+        sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))\n+        True\n+        sage: w.set(3 + 25*(u*v + v*w + u*w))\n+        True\n+\n+        sage: u\n+        ...31203130103131131433\n+        sage: v\n+        ...33441043031103114240\n+        sage: w\n+        ...30212422041102444403\n+```\n \n Comment: 1\n \n``````\n",
    "created_at": "2021-04-07T09:18:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617338",
    "user": "https://github.com/xcaruso"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,204 @@
-
+We propose an implementation of lazy p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.
+
+Here is a small demo:
+
+```
+    The model for lazy elements is quite different from any of the
+    other types of `p`-adics. In addition to storing a finite
+    approximation, one also stores a method for increasing the
+    precision.
+
+    Lazy `p`-adic rings are created by the constructor :func:`ZpL`::
+
+        sage: R = ZpL(5, print_mode="digits")
+        sage: R
+        5-adic Ring with lazy precision
+
+    The precision is not capped in `R`::
+
+        sage: R.precision_cap()
+        +Infinity
+
+    However, a default precision is fixed. This is the precision
+    at which the elements will be printed::
+
+        sage: R.default_prec()
+        20
+
+    A default halting precision is also set. It is the default absolute
+    precision at which the elements will be compared. By default, it is
+    twice the default precision::
+
+        sage: R.halting_prec()
+        40
+
+    However, both the default precision and the halting precision can be
+    customized at the creation of the parent as follows:
+
+        sage: S = ZpL(5, prec=10, halt=100)
+        sage: S.default_prec()
+        10
+        sage: S.halting_prec()
+        100
+
+    One creates elements as usual::
+
+        sage: a = R(17/42)
+        sage: a
+        ...00244200244200244201
+
+        sage: R.random_element()  # random
+        ...21013213133412431402
+
+    Here we notice that 20 digits (that is the default precision) are printed.
+    However, the computation model is designed in order to guarantee that more
+    digits of `a` will be available on demand.
+    This feature is reflected by the fact that, when we ask for the precision
+    of `a`, the software answers `+\infty`::
+
+        sage: a.precision_absolute()
+        +Infinity
+
+    Asking for more digits is achieved by the methods :meth:`at_precision_absolute`
+    and :meth:`at_precision_relative`::
+
+        sage: a.at_precision_absolute(30)
+        ...?244200244200244200244200244201
+
+    As a shortcut, one can use the bracket operator::
+
+        sage: a[:30]
+        ...?244200244200244200244200244201
+
+    Of course, standard operations are supported::
+
+        sage: b = R(42/17)
+        sage: a + b
+        ...03232011214322140002
+        sage: a - b
+        ...42311334324023403400
+        sage: a * b
+        ...00000000000000000001
+        sage: a / b
+        ...12442142113021233401
+        sage: sqrt(a)
+        ...20042333114021142101
+
+    We observe again that only 20 digits are printed but, as before,
+    more digits are available on demand::
+
+        sage: sqrt(a)[:30]
+        ...?142443342120042333114021142101
+
+    .. RUBRIC:: Equality tests
+
+    Checking equalities between lazy `p`-adics is a bit subtle and can
+    sometimes be puzzling at first glance.
+
+    When the parent is created with ``secure=False`` (which is the
+    default), elements are compared at the current precision, or at the
+    default halting precision if it is higher::
+
+        sage: a == b
+        False
+
+        sage: a == sqrt(a)^2
+        True
+        sage: a == sqrt(a)^2 + 5^50
+        True
+
+    In the above example, the halting precision is `40`; it is the
+    reason why a congruence modulo `5^50` is considered as an equality.
+    However, if both sides of the equalities have been previously
+    computed with more digits, those digits are taken into account.
+    Hence comparing two elements at different times can produce
+    different results::
+
+        sage: aa = sqrt(a)^2 + 5^50
+        sage: a == aa
+        True
+        sage: a[:60]
+        ...?244200244200244200244200244200244200244200244200244200244201
+        sage: aa[:60]
+        ...?244200244300244200244200244200244200244200244200244200244201
+        sage: a == aa
+        False
+
+    This annoying situation, where the output of `a == aa` may change
+    depending on previous computations, cannot occur when the parent is
+    created with ``secure=True``.
+    Indeed, in this case, if the equality cannot be decided, an error
+    is raised::
+
+        sage: S = ZpL(5, secure=True)
+        sage: u = S.random_element()
+        sage: uu = u + 5^50
+        sage: u == uu
+        Traceback (most recent call last):
+        ...
+        PrecisionError: unable to decide equality; try to bound precision
+
+        sage: u[:60] == uu
+        False
+
+    .. RUBRIC:: Self-referent numbers
+
+    A quite interesting feature with lazy `p`-adics is the possibility to
+    create (in some cases) self-referent numbers. Here is an example.
+    We first declare a new variable as follows::
+
+        sage: x = R.unknown()
+        sage: x
+        ...?.0
+
+    We then use the method :meth:`set` to define `x` by writing down an equation
+    it satisfies::
+
+        sage: x.set(1 + 5*x^2)
+        True
+
+    The variable `x` now contains the unique solution of the equation
+    `x = 1 + 5 x^2`::
+
+        sage: x
+        ...04222412141121000211
+
+    This works because the `n`-th digit of the right hand size of the
+    defining equation only involves the `i`-th digits of `x` with `i < n`
+    (this is due to the factor `5`).
+
+    As a comparison, the following does not work::
+
+        sage: y = R.unknown()
+        sage: y.set(1 + 3*y^2)
+        True
+        sage: y
+        ...?.0
+        sage: y[:20]
+        Traceback (most recent call last):
+        ...
+        RecursionError: definition looks circular
+
+    Self-referent definitions also work with systems of equations::
+
+        sage: u = R.unknown()
+        sage: v = R.unknown()
+        sage: w = R.unknown()
+
+        sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)
+        True
+        sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))
+        True
+        sage: w.set(3 + 25*(u*v + v*w + u*w))
+        True
+
+        sage: u
+        ...31203130103131131433
+        sage: v
+        ...33441043031103114240
+        sage: w
+        ...30212422041102444403
+```
 
 Comment: 1
 
``````




---

archive/issue_comments_617339.json:
```json
{
    "body": "<a id='comment:50'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-22T20:58:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617339",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:50'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617340.json:
```json
{
    "body": "Changing commit from \"7f49e18bbeb2113d4ce5a304af11c3e19f9515fb\" to \"24ef236af58e1c7171b079c9a47d1f67b891e00b\"",
    "created_at": "2021-04-22T20:58:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617340",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "7f49e18bbeb2113d4ce5a304af11c3e19f9515fb" to "24ef236af58e1c7171b079c9a47d1f67b891e00b"



---

archive/issue_comments_617341.json:
```json
{
    "body": "<a id='comment:51'></a>I changed the naming (`Relaxed` instead of `Lazy`, `ZpER` instead of `ZpL`).\n\nTicket ready for a second review.",
    "created_at": "2021-04-22T21:02:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617341",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:51'></a>I changed the naming (`Relaxed` instead of `Lazy`, `ZpER` instead of `ZpL`).

Ticket ready for a second review.



---

archive/issue_comments_617342.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,204 @@\n-\n+We propose an implementation of exact p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.\n+\n+Here is a small demo:\n+\n+```\n+    The model for relaxed `p`-adics is quite different from any of the\n+    other types of `p`-adics. In addition to storing a finite\n+    approximation, one also stores a method for increasing the\n+    precision.\n+\n+    Relaxed `p`-adic rings are created by the constructor :func:`ZpER`::\n+\n+        sage: R = ZpER(5, print_mode=\"digits\")\n+        sage: R\n+        5-adic Ring handled with relaxed arithmetics\n+\n+    The precision is not capped in `R`::\n+\n+        sage: R.precision_cap()\n+        +Infinity\n+\n+    However, a default precision is fixed. This is the precision\n+    at which the elements will be printed::\n+\n+        sage: R.default_prec()\n+        20\n+\n+    A default halting precision is also set. It is the default absolute\n+    precision at which the elements will be compared. By default, it is\n+    twice the default precision::\n+\n+        sage: R.halting_prec()\n+        40\n+\n+    However, both the default precision and the halting precision can be\n+    customized at the creation of the parent as follows:\n+\n+        sage: S = ZpER(5, prec=10, halt=100)\n+        sage: S.default_prec()\n+        10\n+        sage: S.halting_prec()\n+        100\n+\n+    One creates elements as usual::\n+\n+        sage: a = R(17/42)\n+        sage: a\n+        ...00244200244200244201\n+\n+        sage: R.random_element()  # random\n+        ...21013213133412431402\n+\n+    Here we notice that 20 digits (that is the default precision) are printed.\n+    However, the computation model is designed in order to guarantee that more\n+    digits of `a` will be available on demand.\n+    This feature is reflected by the fact that, when we ask for the precision\n+    of `a`, the software answers `+\\infty`::\n+\n+        sage: a.precision_absolute()\n+        +Infinity\n+\n+    Asking for more digits is achieved by the methods :meth:`at_precision_absolute`\n+    and :meth:`at_precision_relative`::\n+\n+        sage: a.at_precision_absolute(30)\n+        ...?244200244200244200244200244201\n+\n+    As a shortcut, one can use the bracket operator::\n+\n+        sage: a[:30]\n+        ...?244200244200244200244200244201\n+\n+    Of course, standard operations are supported::\n+\n+        sage: b = R(42/17)\n+        sage: a + b\n+        ...03232011214322140002\n+        sage: a - b\n+        ...42311334324023403400\n+        sage: a * b\n+        ...00000000000000000001\n+        sage: a / b\n+        ...12442142113021233401\n+        sage: sqrt(a)\n+        ...20042333114021142101\n+\n+    We observe again that only 20 digits are printed but, as before,\n+    more digits are available on demand::\n+\n+        sage: sqrt(a)[:30]\n+        ...?142443342120042333114021142101\n+\n+    .. RUBRIC:: Equality tests\n+\n+    Checking equalities between relaxed `p`-adics is a bit subtle and can\n+    sometimes be puzzling at first glance.\n+\n+    When the parent is created with ``secure=False`` (which is the\n+    default), elements are compared at the current precision, or at the\n+    default halting precision if it is higher::\n+\n+        sage: a == b\n+        False\n+\n+        sage: a == sqrt(a)^2\n+        True\n+        sage: a == sqrt(a)^2 + 5^50\n+        True\n+\n+    In the above example, the halting precision is `40`; it is the\n+    reason why a congruence modulo `5^50` is considered as an equality.\n+    However, if both sides of the equalities have been previously\n+    computed with more digits, those digits are taken into account.\n+    Hence comparing two elements at different times can produce\n+    different results::\n+\n+        sage: aa = sqrt(a)^2 + 5^50\n+        sage: a == aa\n+        True\n+        sage: a[:60]\n+        ...?244200244200244200244200244200244200244200244200244200244201\n+        sage: aa[:60]\n+        ...?244200244300244200244200244200244200244200244200244200244201\n+        sage: a == aa\n+        False\n+\n+    This annoying situation, where the output of `a == aa` may change\n+    depending on previous computations, cannot occur when the parent is\n+    created with ``secure=True``.\n+    Indeed, in this case, if the equality cannot be decided, an error\n+    is raised::\n+\n+        sage: S = ZpER(5, secure=True)\n+        sage: u = S.random_element()\n+        sage: uu = u + 5^50\n+        sage: u == uu\n+        Traceback (most recent call last):\n+        ...\n+        PrecisionError: unable to decide equality; try to bound precision\n+\n+        sage: u[:60] == uu\n+        False\n+\n+    .. RUBRIC:: Self-referent numbers\n+\n+    A quite interesting feature with relaxed `p`-adics is the possibility to\n+    create (in some cases) self-referent numbers. Here is an example.\n+    We first declare a new variable as follows::\n+\n+        sage: x = R.unknown()\n+        sage: x\n+        ...?.0\n+\n+    We then use the method :meth:`set` to define `x` by writing down an equation\n+    it satisfies::\n+\n+        sage: x.set(1 + 5*x^2)\n+        True\n+\n+    The variable `x` now contains the unique solution of the equation\n+    `x = 1 + 5 x^2`::\n+\n+        sage: x\n+        ...04222412141121000211\n+\n+    This works because the `n`-th digit of the right hand size of the\n+    defining equation only involves the `i`-th digits of `x` with `i < n`\n+    (this is due to the factor `5`).\n+\n+    As a comparison, the following does not work::\n+\n+        sage: y = R.unknown()\n+        sage: y.set(1 + 3*y^2)\n+        True\n+        sage: y\n+        ...?.0\n+        sage: y[:20]\n+        Traceback (most recent call last):\n+        ...\n+        RecursionError: definition looks circular\n+\n+    Self-referent definitions also work with systems of equations::\n+\n+        sage: u = R.unknown()\n+        sage: v = R.unknown()\n+        sage: w = R.unknown()\n+\n+        sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)\n+        True\n+        sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))\n+        True\n+        sage: w.set(3 + 25*(u*v + v*w + u*w))\n+        True\n+\n+        sage: u\n+        ...31203130103131131433\n+        sage: v\n+        ...33441043031103114240\n+        sage: w\n+        ...30212422041102444403\n+```\n \n Comment: 1\n \n``````\n",
    "created_at": "2021-04-22T21:02:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617342",
    "user": "https://github.com/xcaruso"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,204 @@
-
+We propose an implementation of exact p-adic numbers relaying on relaxed arithmetics proposed by van der Hoeven and al.
+
+Here is a small demo:
+
+```
+    The model for relaxed `p`-adics is quite different from any of the
+    other types of `p`-adics. In addition to storing a finite
+    approximation, one also stores a method for increasing the
+    precision.
+
+    Relaxed `p`-adic rings are created by the constructor :func:`ZpER`::
+
+        sage: R = ZpER(5, print_mode="digits")
+        sage: R
+        5-adic Ring handled with relaxed arithmetics
+
+    The precision is not capped in `R`::
+
+        sage: R.precision_cap()
+        +Infinity
+
+    However, a default precision is fixed. This is the precision
+    at which the elements will be printed::
+
+        sage: R.default_prec()
+        20
+
+    A default halting precision is also set. It is the default absolute
+    precision at which the elements will be compared. By default, it is
+    twice the default precision::
+
+        sage: R.halting_prec()
+        40
+
+    However, both the default precision and the halting precision can be
+    customized at the creation of the parent as follows:
+
+        sage: S = ZpER(5, prec=10, halt=100)
+        sage: S.default_prec()
+        10
+        sage: S.halting_prec()
+        100
+
+    One creates elements as usual::
+
+        sage: a = R(17/42)
+        sage: a
+        ...00244200244200244201
+
+        sage: R.random_element()  # random
+        ...21013213133412431402
+
+    Here we notice that 20 digits (that is the default precision) are printed.
+    However, the computation model is designed in order to guarantee that more
+    digits of `a` will be available on demand.
+    This feature is reflected by the fact that, when we ask for the precision
+    of `a`, the software answers `+\infty`::
+
+        sage: a.precision_absolute()
+        +Infinity
+
+    Asking for more digits is achieved by the methods :meth:`at_precision_absolute`
+    and :meth:`at_precision_relative`::
+
+        sage: a.at_precision_absolute(30)
+        ...?244200244200244200244200244201
+
+    As a shortcut, one can use the bracket operator::
+
+        sage: a[:30]
+        ...?244200244200244200244200244201
+
+    Of course, standard operations are supported::
+
+        sage: b = R(42/17)
+        sage: a + b
+        ...03232011214322140002
+        sage: a - b
+        ...42311334324023403400
+        sage: a * b
+        ...00000000000000000001
+        sage: a / b
+        ...12442142113021233401
+        sage: sqrt(a)
+        ...20042333114021142101
+
+    We observe again that only 20 digits are printed but, as before,
+    more digits are available on demand::
+
+        sage: sqrt(a)[:30]
+        ...?142443342120042333114021142101
+
+    .. RUBRIC:: Equality tests
+
+    Checking equalities between relaxed `p`-adics is a bit subtle and can
+    sometimes be puzzling at first glance.
+
+    When the parent is created with ``secure=False`` (which is the
+    default), elements are compared at the current precision, or at the
+    default halting precision if it is higher::
+
+        sage: a == b
+        False
+
+        sage: a == sqrt(a)^2
+        True
+        sage: a == sqrt(a)^2 + 5^50
+        True
+
+    In the above example, the halting precision is `40`; it is the
+    reason why a congruence modulo `5^50` is considered as an equality.
+    However, if both sides of the equalities have been previously
+    computed with more digits, those digits are taken into account.
+    Hence comparing two elements at different times can produce
+    different results::
+
+        sage: aa = sqrt(a)^2 + 5^50
+        sage: a == aa
+        True
+        sage: a[:60]
+        ...?244200244200244200244200244200244200244200244200244200244201
+        sage: aa[:60]
+        ...?244200244300244200244200244200244200244200244200244200244201
+        sage: a == aa
+        False
+
+    This annoying situation, where the output of `a == aa` may change
+    depending on previous computations, cannot occur when the parent is
+    created with ``secure=True``.
+    Indeed, in this case, if the equality cannot be decided, an error
+    is raised::
+
+        sage: S = ZpER(5, secure=True)
+        sage: u = S.random_element()
+        sage: uu = u + 5^50
+        sage: u == uu
+        Traceback (most recent call last):
+        ...
+        PrecisionError: unable to decide equality; try to bound precision
+
+        sage: u[:60] == uu
+        False
+
+    .. RUBRIC:: Self-referent numbers
+
+    A quite interesting feature with relaxed `p`-adics is the possibility to
+    create (in some cases) self-referent numbers. Here is an example.
+    We first declare a new variable as follows::
+
+        sage: x = R.unknown()
+        sage: x
+        ...?.0
+
+    We then use the method :meth:`set` to define `x` by writing down an equation
+    it satisfies::
+
+        sage: x.set(1 + 5*x^2)
+        True
+
+    The variable `x` now contains the unique solution of the equation
+    `x = 1 + 5 x^2`::
+
+        sage: x
+        ...04222412141121000211
+
+    This works because the `n`-th digit of the right hand size of the
+    defining equation only involves the `i`-th digits of `x` with `i < n`
+    (this is due to the factor `5`).
+
+    As a comparison, the following does not work::
+
+        sage: y = R.unknown()
+        sage: y.set(1 + 3*y^2)
+        True
+        sage: y
+        ...?.0
+        sage: y[:20]
+        Traceback (most recent call last):
+        ...
+        RecursionError: definition looks circular
+
+    Self-referent definitions also work with systems of equations::
+
+        sage: u = R.unknown()
+        sage: v = R.unknown()
+        sage: w = R.unknown()
+
+        sage: u.set(1 + 2*v + 3*w^2 + 5*u*v*w)
+        True
+        sage: v.set(2 + 4*w + sqrt(1 + 5*u + 10*v + 15*w))
+        True
+        sage: w.set(3 + 25*(u*v + v*w + u*w))
+        True
+
+        sage: u
+        ...31203130103131131433
+        sage: v
+        ...33441043031103114240
+        sage: w
+        ...30212422041102444403
+```
 
 Comment: 1
 
``````




---

archive/issue_comments_617343.json:
```json
{
    "body": "<a id='comment:52'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-28T12:55:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617343",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:52'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617344.json:
```json
{
    "body": "Changing commit from \"24ef236af58e1c7171b079c9a47d1f67b891e00b\" to \"df13f1ebea093a6ffb4d86e56a62e08a0fd24cc3\"",
    "created_at": "2021-04-28T12:55:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617344",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "24ef236af58e1c7171b079c9a47d1f67b891e00b" to "df13f1ebea093a6ffb4d86e56a62e08a0fd24cc3"



---

archive/issue_comments_617345.json:
```json
{
    "body": "<a id='comment:53'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-28T13:05:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617345",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:53'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_617346.json:
```json
{
    "body": "Changing commit from \"df13f1ebea093a6ffb4d86e56a62e08a0fd24cc3\" to \"50c9719335ca47ba46d4cc4214f7a79f9ae51add\"",
    "created_at": "2021-04-28T13:05:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617346",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "df13f1ebea093a6ffb4d86e56a62e08a0fd24cc3" to "50c9719335ca47ba46d4cc4214f7a79f9ae51add"



---

archive/issue_comments_617347.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-04-28T20:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617347",
    "user": "https://github.com/roed314"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_617348.json:
```json
{
    "body": "<a id='comment:54'></a>Looks good to me!  I think any additional issues can be addressed in followup tickets.",
    "created_at": "2021-04-28T20:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617348",
    "user": "https://github.com/roed314"
}
```

<a id='comment:54'></a>Looks good to me!  I think any additional issues can be addressed in followup tickets.



---

archive/issue_comments_617349.json:
```json
{
    "body": "Changing commit from \"50c9719335ca47ba46d4cc4214f7a79f9ae51add\" to \"e30393b481a97b0428b9926d01769e9b2e242eb7\"",
    "created_at": "2021-04-29T06:20:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617349",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "50c9719335ca47ba46d4cc4214f7a79f9ae51add" to "e30393b481a97b0428b9926d01769e9b2e242eb7"



---

archive/issue_comments_617350.json:
```json
{
    "body": "<a id='comment:55'></a>Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2021-04-29T06:20:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617350",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:55'></a>Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_617351.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2021-04-29T06:20:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617351",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_617352.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-04-29T06:22:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617352",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_617353.json:
```json
{
    "body": "<a id='comment:56'></a>Great, thanks!\nI set again the ticket to positive review, I've just fixed two typos.",
    "created_at": "2021-04-29T06:22:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617353",
    "user": "https://github.com/xcaruso"
}
```

<a id='comment:56'></a>Great, thanks!
I set again the ticket to positive review, I've just fixed two typos.



---

archive/issue_comments_617354.json:
```json
{
    "body": "Changing commit from \"e30393b481a97b0428b9926d01769e9b2e242eb7\" to \"ad06299820b3302a3f39cff8b281dcb95819fba0\"",
    "created_at": "2021-05-01T11:27:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617354",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "e30393b481a97b0428b9926d01769e9b2e242eb7" to "ad06299820b3302a3f39cff8b281dcb95819fba0"



---

archive/issue_comments_617355.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2021-05-01T11:27:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617355",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_617356.json:
```json
{
    "body": "<a id='comment:57'></a>Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2021-05-01T11:27:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617356",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:57'></a>Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_617357.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-05-01T11:27:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617357",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_617358.json:
```json
{
    "body": "Changing branch from \"u/caruso/relaxed\" to \"ad06299820b3302a3f39cff8b281dcb95819fba0\"",
    "created_at": "2021-05-27T20:30:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617358",
    "user": "https://github.com/vbraun"
}
```

Changing branch from "u/caruso/relaxed" to "ad06299820b3302a3f39cff8b281dcb95819fba0"



---

archive/issue_comments_617359.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2021-05-27T20:30:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617359",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_081266.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-05-27T20:30:03Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31108#event-81266"
}
```



---

archive/issue_comments_617360.json:
```json
{
    "body": "Changing commit from \"ad06299820b3302a3f39cff8b281dcb95819fba0\" to \"\"",
    "created_at": "2021-06-03T22:33:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617360",
    "user": "https://github.com/mkoeppe"
}
```

Changing commit from "ad06299820b3302a3f39cff8b281dcb95819fba0" to ""



---

archive/issue_comments_617361.json:
```json
{
    "body": "<a id='comment:60'></a>Looks like this broke the build --> #31903",
    "created_at": "2021-06-03T22:33:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31108#issuecomment-617361",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:60'></a>Looks like this broke the build --> #31903
