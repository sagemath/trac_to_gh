# Issue 31421: Cached methods of superclasses can overshadow subclass methods

archive/issues_031184.json:
```json
{
    "body": "If a cached superclass method is called before the corresponding cached subclass method, the superclass method gets \"saved\" and overshadows the subclass method from then on. This can easily happen while initializing a subclass as an extension of a superclass with some additional structure. Here is a contrived example:\n\n```python\n....: class MyRealAlgebra: \n....:  \n....:     def __init__(self, basis): \n....:         self._basis = basis \n....:  \n....:     @cached_method \n....:     def basis(self): \n....:         d = len(self._basis[0]) \n....:         V = VectorSpace(RR,d) \n....:         return [V(b) for b in self._basis] \n....:  \n....:  \n....: class MyRationalAlgebra(MyRealAlgebra): \n....:     def __init__(self, basis): \n....:         super().__init__(basis) \n....:         self._basis = [b.change_ring(QQ) for b in super().basis()] \n....:  \n....:     @cached_method \n....:     def basis(self): \n....:         return self._basis \n....:                                                                           \nsage: A = MyRationalAlgebra([(1,0),(0,1)])                                      \nsage: A.basis()                                                                 \n[(1.00000000000000, 0.000000000000000), (0.000000000000000, 1.00000000000000)]\n```\n\nSince the superclass `basis()` method is called while initializing the subclass, it gets cached. Then later when we try to use the subclass method, the superclass method is what we get. Deleting the ``@`cached_method` decorators fixes the issue, but is not a good solution when the superclass method is expensive and the superclass is of independent use.\n\nStopgaps: #31422\n\nStatus: new\n\nIssue created by migration from https://trac.sagemath.org/ticket/31421\n\n",
    "created_at": "2021-02-21T00:52:29Z",
    "labels": [
        "component: categories",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Cached methods of superclasses can overshadow subclass methods",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31421",
    "user": "https://github.com/orlitzky"
}
```
If a cached superclass method is called before the corresponding cached subclass method, the superclass method gets "saved" and overshadows the subclass method from then on. This can easily happen while initializing a subclass as an extension of a superclass with some additional structure. Here is a contrived example:

```python
....: class MyRealAlgebra: 
....:  
....:     def __init__(self, basis): 
....:         self._basis = basis 
....:  
....:     @cached_method 
....:     def basis(self): 
....:         d = len(self._basis[0]) 
....:         V = VectorSpace(RR,d) 
....:         return [V(b) for b in self._basis] 
....:  
....:  
....: class MyRationalAlgebra(MyRealAlgebra): 
....:     def __init__(self, basis): 
....:         super().__init__(basis) 
....:         self._basis = [b.change_ring(QQ) for b in super().basis()] 
....:  
....:     @cached_method 
....:     def basis(self): 
....:         return self._basis 
....:                                                                           
sage: A = MyRationalAlgebra([(1,0),(0,1)])                                      
sage: A.basis()                                                                 
[(1.00000000000000, 0.000000000000000), (0.000000000000000, 1.00000000000000)]
```

Since the superclass `basis()` method is called while initializing the subclass, it gets cached. Then later when we try to use the subclass method, the superclass method is what we get. Deleting the ``@`cached_method` decorators fixes the issue, but is not a good solution when the superclass method is expensive and the superclass is of independent use.

Stopgaps: #31422

Status: new

Issue created by migration from https://trac.sagemath.org/ticket/31421





---

archive/issue_comments_445297.json:
```json
{
    "body": "<a id='comment:1'></a>Stopgap in #31422.",
    "created_at": "2021-02-21T01:01:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445297",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:1'></a>Stopgap in #31422.



---

archive/issue_comments_445298.json:
```json
{
    "body": "<a id='comment:2'></a>This is an issue with the ``@`cached_method`, not with these specific methods. The problem comes from the `super()` call:\n\n```python\nsage: class Foo:\n....:     @cached_method\n....:     def check(self, x):\n....:         return x\n....: class Bar(Foo):\n....:     @cached_method   % This can also be removed and it will still fail\n....:     def check(self, x):\n....:         y = super().check(x)\n....:         return y * y\n```\n\n```\nsage: B = Bar()\nsage: B.check(5)\n25\nsage: B.check(7)\n7\n```\n\nCalling the `super().check()` invokes the `Foo.check()`'s ``@`cached_method`, which invokes the decorator to set the actual function.\n\nBecause of this, I don't think the proposal on #31422 is a valid stopgap because it is a deeper underlying issue rather than tied to these specific methods. Furthermore, having those cached is very useful for computations.\n\nThe obvious workaround would be to copy the code directly. Alternatively, the code of these methods can be pushed to a, e.g., `_cartesian_projection` with the access done directly to avoid code duplication. However, these are hacks and would need to be done on a case-by-case basis.\n\nLikely the solution will involve being more careful with how the `@`cached_method works, hopefully being able to do something with which class in the MRO it replaces.",
    "created_at": "2021-02-22T05:04:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445298",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>This is an issue with the ``@`cached_method`, not with these specific methods. The problem comes from the `super()` call:

```python
sage: class Foo:
....:     @cached_method
....:     def check(self, x):
....:         return x
....: class Bar(Foo):
....:     @cached_method   % This can also be removed and it will still fail
....:     def check(self, x):
....:         y = super().check(x)
....:         return y * y
```

```
sage: B = Bar()
sage: B.check(5)
25
sage: B.check(7)
7
```

Calling the `super().check()` invokes the `Foo.check()`'s ``@`cached_method`, which invokes the decorator to set the actual function.

Because of this, I don't think the proposal on #31422 is a valid stopgap because it is a deeper underlying issue rather than tied to these specific methods. Furthermore, having those cached is very useful for computations.

The obvious workaround would be to copy the code directly. Alternatively, the code of these methods can be pushed to a, e.g., `_cartesian_projection` with the access done directly to avoid code duplication. However, these are hacks and would need to be done on a case-by-case basis.

Likely the solution will involve being more careful with how the `@`cached_method works, hopefully being able to do something with which class in the MRO it replaces.



---

archive/issue_comments_445299.json:
```json
{
    "body": "<a id='comment:3'></a>Thanks! I'm using this pattern elsewhere (which is why I thought it was related to the cartesian product) but I guess I've been extremely lucky so far, only using it for performance gains and not to change the actual output.\n\nI marked the stopgap WONTFIX.",
    "created_at": "2021-02-22T12:35:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445299",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:3'></a>Thanks! I'm using this pattern elsewhere (which is why I thought it was related to the cartesian product) but I guess I've been extremely lucky so far, only using it for performance gains and not to change the actual output.

I marked the stopgap WONTFIX.



---

archive/issue_comments_445300.json:
```json
{
    "body": "<a id='comment:4'></a>Even copy/pasting the code doesn't work! I give up.",
    "created_at": "2021-02-22T13:19:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445300",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:4'></a>Even copy/pasting the code doesn't work! I give up.



---

archive/issue_comments_445301.json:
```json
{
    "body": "<a id='comment:5'></a>With slight modification:\n\n```python\nfrom sage.all import *\nfrom sage.combinat.free_module import CombinatorialFreeModule_CartesianProduct\n\nclass MyAlgebra(CombinatorialFreeModule):\n    def __init__(self, R, n, *args, **kwargs):\n        CombinatorialFreeModule.__init__(self, R, Zmod(n), *args, **kwargs)\n\n\nclass MyCartProd(CombinatorialFreeModule_CartesianProduct, MyAlgebra):\n    def __init__(self, modules, **kwargs):\n        CombinatorialFreeModule_CartesianProduct.__init__(self,\n                                                          modules,\n                                                          **kwargs)\n\n        x = modules[0].monomial(0)\n        y = modules[1].monomial(0)\n        z = self._cartesian_product_of_elements((x,y))\n        print(z)\n\n    @cached_method\n    def cartesian_projection(self, i):\n        Ji = self.cartesian_factors()[i]\n        Pi = self._module_morphism(lambda j_t: Ji.monomial(j_t[1])\n                                   if i == j_t[0] else Ji.zero(),\n                                   codomain=Ji)\n        return len(str(Pi))\n\n    @cached_method\n    def cartesian_embedding(self, i):\n        Ji = self.cartesian_factors()[i]\n        Ei = Ji._module_morphism(lambda t: self.monomial((i, t)),\n                                 codomain=self)\n        return len(str(Ei))\n\nMyAlgebra.CartesianProduct = MyCartProd\n```\n\nThe superclass embedding method is still used, as it gets cached by the call to  `_cartesian_product_of_elements()`:\n\n```\nsage: A = MyAlgebra(QQ,3)                                                                                                                                                    \nsage: B = MyAlgebra(QQ,2)                                                                                                                                                    \nsage: C = cartesian_product([A,B])                                                                                                                                           \nB[(0, 0)] + B[(1, 0)]\nsage: C.cartesian_embedding(0)                                                                                                                                               \nGeneric morphism:\n  From: Free module generated by Ring of integers modulo 3 over Rational Field\n  To:   Free module generated by Ring of integers modulo 3 over Rational Field (+) Free module generated by Ring of integers modulo 2 over Rational Field\n```",
    "created_at": "2021-02-22T13:35:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445301",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:5'></a>With slight modification:

```python
from sage.all import *
from sage.combinat.free_module import CombinatorialFreeModule_CartesianProduct

class MyAlgebra(CombinatorialFreeModule):
    def __init__(self, R, n, *args, **kwargs):
        CombinatorialFreeModule.__init__(self, R, Zmod(n), *args, **kwargs)


class MyCartProd(CombinatorialFreeModule_CartesianProduct, MyAlgebra):
    def __init__(self, modules, **kwargs):
        CombinatorialFreeModule_CartesianProduct.__init__(self,
                                                          modules,
                                                          **kwargs)

        x = modules[0].monomial(0)
        y = modules[1].monomial(0)
        z = self._cartesian_product_of_elements((x,y))
        print(z)

    @cached_method
    def cartesian_projection(self, i):
        Ji = self.cartesian_factors()[i]
        Pi = self._module_morphism(lambda j_t: Ji.monomial(j_t[1])
                                   if i == j_t[0] else Ji.zero(),
                                   codomain=Ji)
        return len(str(Pi))

    @cached_method
    def cartesian_embedding(self, i):
        Ji = self.cartesian_factors()[i]
        Ei = Ji._module_morphism(lambda t: self.monomial((i, t)),
                                 codomain=self)
        return len(str(Ei))

MyAlgebra.CartesianProduct = MyCartProd
```

The superclass embedding method is still used, as it gets cached by the call to  `_cartesian_product_of_elements()`:

```
sage: A = MyAlgebra(QQ,3)                                                                                                                                                    
sage: B = MyAlgebra(QQ,2)                                                                                                                                                    
sage: C = cartesian_product([A,B])                                                                                                                                           
B[(0, 0)] + B[(1, 0)]
sage: C.cartesian_embedding(0)                                                                                                                                               
Generic morphism:
  From: Free module generated by Ring of integers modulo 3 over Rational Field
  To:   Free module generated by Ring of integers modulo 3 over Rational Field (+) Free module generated by Ring of integers modulo 2 over Rational Field
```



---

archive/issue_comments_445302.json:
```json
{
    "body": "<a id='comment:6'></a>Interestingly it seems to work for `cartesian_projection`:\n\n```\nsage: C.cartesian_projection(0)                                                                                   \n250\nsage: C.cartesian_projection(1)                                                                                   \n250\n```\nSomething very strange is happening with the `cartesian_embedding`, which is a different error.",
    "created_at": "2021-02-22T23:25:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445302",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>Interestingly it seems to work for `cartesian_projection`:

```
sage: C.cartesian_projection(0)                                                                                   
250
sage: C.cartesian_projection(1)                                                                                   
250
```
Something very strange is happening with the `cartesian_embedding`, which is a different error.



---

archive/issue_comments_445303.json:
```json
{
    "body": "<a id='comment:7'></a>Okay, the other problem comes from the alias:\n\n```\nsummand_embedding = cartesian_embedding\n```\nand `summand_embedding` gets called in `CombinatorialFreeModule._cartesian_product_of_elements`. Because the name is actually tied to `cartesian_embedding`, the ``@`cached_method` then overrides that. So the workaround here is to reset the alias (which is something you want to do anyways).",
    "created_at": "2021-02-22T23:28:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445303",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:7'></a>Okay, the other problem comes from the alias:

```
summand_embedding = cartesian_embedding
```
and `summand_embedding` gets called in `CombinatorialFreeModule._cartesian_product_of_elements`. Because the name is actually tied to `cartesian_embedding`, the ``@`cached_method` then overrides that. So the workaround here is to reset the alias (which is something you want to do anyways).



---

archive/issue_comments_445304.json:
```json
{
    "body": "<a id='comment:8'></a>Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`.",
    "created_at": "2021-02-22T23:29:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445304",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`.



---

archive/issue_comments_445305.json:
```json
{
    "body": "<a id='comment:9'></a>Replying to [comment:7 tscrim]:\n> So the workaround here is to reset the alias (which is something you want to do anyways).\n\n\nCan I ask why? What does `summand_embedding` even do? git grep turns up only the one hit on free_module.py.\n\n> Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`. \n\n\nAdding to the list of things I cannot explain, this also doesn't work. After changing `summand` to `cartesian`, it returns... an int?",
    "created_at": "2021-02-23T01:36:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445305",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:9'></a>Replying to [comment:7 tscrim]:
> So the workaround here is to reset the alias (which is something you want to do anyways).


Can I ask why? What does `summand_embedding` even do? git grep turns up only the one hit on free_module.py.

> Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`. 


Adding to the list of things I cannot explain, this also doesn't work. After changing `summand` to `cartesian`, it returns... an int?



---

archive/issue_comments_445306.json:
```json
{
    "body": "<a id='comment:10'></a>Replying to [comment:9 mjo]:\n> Replying to [comment:7 tscrim]:\n> > So the workaround here is to reset the alias (which is something you want to do anyways).\n\n> \n> Can I ask why? What does `summand_embedding` even do? git grep turns up only the one hit on free_module.py.\n\n\nThis was likely leftover from before that stuff got moved up to the category level. It can simply be replaced too (see below).\n \n> > Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`. \n\n>\n> Adding to the list of things I cannot explain, this also doesn't work. After changing `summand` to `cartesian`, it returns... an int?\n\n\nWhere, in your code? I would just add the line\n\n```\nsummand_embedding = cartesian_embedding\n```\nI haven't tested it, but I think that should fix it.",
    "created_at": "2021-02-25T22:52:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445306",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:10'></a>Replying to [comment:9 mjo]:
> Replying to [comment:7 tscrim]:
> > So the workaround here is to reset the alias (which is something you want to do anyways).

> 
> Can I ask why? What does `summand_embedding` even do? git grep turns up only the one hit on free_module.py.


This was likely leftover from before that stuff got moved up to the category level. It can simply be replaced too (see below).
 
> > Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`. 

>
> Adding to the list of things I cannot explain, this also doesn't work. After changing `summand` to `cartesian`, it returns... an int?


Where, in your code? I would just add the line

```
summand_embedding = cartesian_embedding
```
I haven't tested it, but I think that should fix it.



---

archive/issue_comments_445307.json:
```json
{
    "body": "<a id='comment:11'></a>Replying to [comment:10 tscrim]:\n> \n> Where, in your code? I would just add the line\n> \n> ```\n> summand_embedding = cartesian_embedding\n> ```\n> I haven't tested it, but I think that should fix it.\n\n\nYeah. Running that gives,\n\n```\nsage: A = MyAlgebra(QQ,3)                                                       \nsage: B = MyAlgebra(QQ,2)                                                       \nsage: C = cartesian_product([A,B])                                              \n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5974)()\n    995             try:\n--> 996                 return self.cache[k]\n    997             except TypeError:  # k is not hashable\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/weak_dict.pyx in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3736)()\n    703         if wr == NULL:\n--> 704             raise KeyError(k)\n    705         out = PyWeakref_GetObject(wr)\n\nKeyError: ((<class '__main__.MyCartProd'>, (Free module generated by Ring of integers modulo 3 over Rational Field, Free module generated by Ring of integers modulo 2 over Rational Field)), (('category', Category of Cartesian products of vector spaces with basis over Rational Field),))\n\nDuring handling of the above exception, another exception occurred:\n\nTypeError                                 Traceback (most recent call last)\n<ipython-input-4-1785ba83158c> in <module>\n----> 1 C = cartesian_product([A,B])\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/lazy_import.pyx in sage.misc.lazy_import.LazyImport.__call__ (build/cythonized/sage/misc/lazy_import.c:4032)()\n    358             True\n    359         \"\"\"\n--> 360         return self.get_object()(*args, **kwds)\n    361 \n    362     def __repr__(self):\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/cartesian_product.py in __call__(self, args, **kwds)\n    191             return super(CartesianProductFunctor, self).__call__(args, category=self._forced_category, **kwds)\n    192 \n--> 193         return super(CartesianProductFunctor, self).__call__(args, **kwds)\n    194 \n    195     def __eq__(self, other):\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/covariant_functorial_construction.py in __call__(self, args, **kwargs)\n    220         assert(all( hasattr(arg, self._functor_name) for arg in args))\n    221         assert(len(args) > 0)\n--> 222         return getattr(args[0], self._functor_name)(*args[1:], **kwargs)\n    223 \n    224 class FunctorialConstructionCategory(Category): # Should this be CategoryWithBase?\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/sets_cat.py in cartesian_product(*parents, **kwargs)\n   1583                 else:\n   1584                     category = category & extra_category\n-> 1585             return parents[0].CartesianProduct(parents, category=category, **kwargs)\n   1586 \n   1587         def algebra(self, base_ring, category=None, **kwds):\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1761)()\n    320         \"\"\"\n    321         if cls.classcall is not None:\n--> 322             return cls.classcall(cls, *args, **kwds)\n    323         else:\n    324             # Fast version of type.__call__(cls, *args, **kwds)\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6100)()\n    999                 return self.cache[k]\n   1000         except KeyError:\n-> 1001             w = self.f(*args, **kwds)\n   1002             self.cache[k] = w\n   1003             return w\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/structure/unique_representation.py in __classcall__(cls, *args, **options)\n   1005             True\n   1006         \"\"\"\n-> 1007         instance = typecall(cls, *args, **options)\n   1008         assert isinstance( instance, cls )\n   1009         if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2223)()\n    484             TypeError: Argument 'cls' has incorrect type (expected type, got classobj)\n    485     \"\"\"\n--> 486     return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n    487 \n    488 # Class for timing::\n\n<ipython-input-1-f81f7af80573> in __init__(self, modules, **kwargs)\n     15         x = modules[Integer(0)].monomial(Integer(0))\n     16         y = modules[Integer(1)].monomial(Integer(0))\n---> 17         z = self._cartesian_product_of_elements((x,y))\n     18         print(z)\n     19 \n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in _cartesian_product_of_elements(self, elements)\n   1813 \n   1814         \"\"\"\n-> 1815         return self.sum(self.summand_embedding(i)(elements[i]) for i in self._sets_keys())\n   1816 \n   1817     def cartesian_factors(self):\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in sum(self, iter_of_elements)\n    993             10*B[1] + 10*B[2]\n    994         \"\"\"\n--> 995         D = blas.sum(element._monomial_coefficients for element in iter_of_elements)\n    996         return self._from_dict(D, remove_zeros=False)\n    997 \n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/data_structures/blas_dict.pyx in sage.data_structures.blas_dict.sum (build/cythonized/sage/data_structures/blas_dict.c:3095)()\n    270     return axpy(1, D2, D)\n    271 \n--> 272 cpdef dict sum(dict_iter):\n    273     r\"\"\"\n    274     Return the pointwise addition of dictionaries with coefficients.\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/data_structures/blas_dict.pyx in sage.data_structures.blas_dict.sum (build/cythonized/sage/data_structures/blas_dict.c:2841)()\n    304     cdef list for_removal\n    305 \n--> 306     for D in dict_iter:\n    307         if result:\n    308             iaxpy(1, D, result, remove_zeros=False)\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in <genexpr>(.0)\n    993             10*B[1] + 10*B[2]\n    994         \"\"\"\n--> 995         D = blas.sum(element._monomial_coefficients for element in iter_of_elements)\n    996         return self._from_dict(D, remove_zeros=False)\n    997 \n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in <genexpr>(.0)\n   1813 \n   1814         \"\"\"\n-> 1815         return self.sum(self.summand_embedding(i)(elements[i]) for i in self._sets_keys())\n   1816 \n   1817     def cartesian_factors(self):\n\nTypeError: 'int' object is not callable\n```",
    "created_at": "2021-02-27T03:34:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445307",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:11'></a>Replying to [comment:10 tscrim]:
> 
> Where, in your code? I would just add the line
> 
> ```
> summand_embedding = cartesian_embedding
> ```
> I haven't tested it, but I think that should fix it.


Yeah. Running that gives,

```
sage: A = MyAlgebra(QQ,3)                                                       
sage: B = MyAlgebra(QQ,2)                                                       
sage: C = cartesian_product([A,B])                                              
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5974)()
    995             try:
--> 996                 return self.cache[k]
    997             except TypeError:  # k is not hashable

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/weak_dict.pyx in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3736)()
    703         if wr == NULL:
--> 704             raise KeyError(k)
    705         out = PyWeakref_GetObject(wr)

KeyError: ((<class '__main__.MyCartProd'>, (Free module generated by Ring of integers modulo 3 over Rational Field, Free module generated by Ring of integers modulo 2 over Rational Field)), (('category', Category of Cartesian products of vector spaces with basis over Rational Field),))

During handling of the above exception, another exception occurred:

TypeError                                 Traceback (most recent call last)
<ipython-input-4-1785ba83158c> in <module>
----> 1 C = cartesian_product([A,B])

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/lazy_import.pyx in sage.misc.lazy_import.LazyImport.__call__ (build/cythonized/sage/misc/lazy_import.c:4032)()
    358             True
    359         """
--> 360         return self.get_object()(*args, **kwds)
    361 
    362     def __repr__(self):

~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/cartesian_product.py in __call__(self, args, **kwds)
    191             return super(CartesianProductFunctor, self).__call__(args, category=self._forced_category, **kwds)
    192 
--> 193         return super(CartesianProductFunctor, self).__call__(args, **kwds)
    194 
    195     def __eq__(self, other):

~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/covariant_functorial_construction.py in __call__(self, args, **kwargs)
    220         assert(all( hasattr(arg, self._functor_name) for arg in args))
    221         assert(len(args) > 0)
--> 222         return getattr(args[0], self._functor_name)(*args[1:], **kwargs)
    223 
    224 class FunctorialConstructionCategory(Category): # Should this be CategoryWithBase?

~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/sets_cat.py in cartesian_product(*parents, **kwargs)
   1583                 else:
   1584                     category = category & extra_category
-> 1585             return parents[0].CartesianProduct(parents, category=category, **kwargs)
   1586 
   1587         def algebra(self, base_ring, category=None, **kwds):

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1761)()
    320         """
    321         if cls.classcall is not None:
--> 322             return cls.classcall(cls, *args, **kwds)
    323         else:
    324             # Fast version of type.__call__(cls, *args, **kwds)

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6100)()
    999                 return self.cache[k]
   1000         except KeyError:
-> 1001             w = self.f(*args, **kwds)
   1002             self.cache[k] = w
   1003             return w

~/src/sage.git/local/lib/python3.9/site-packages/sage/structure/unique_representation.py in __classcall__(cls, *args, **options)
   1005             True
   1006         """
-> 1007         instance = typecall(cls, *args, **options)
   1008         assert isinstance( instance, cls )
   1009         if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2223)()
    484             TypeError: Argument 'cls' has incorrect type (expected type, got classobj)
    485     """
--> 486     return (<PyTypeObject*>type).tp_call(cls, args, kwds)
    487 
    488 # Class for timing::

<ipython-input-1-f81f7af80573> in __init__(self, modules, **kwargs)
     15         x = modules[Integer(0)].monomial(Integer(0))
     16         y = modules[Integer(1)].monomial(Integer(0))
---> 17         z = self._cartesian_product_of_elements((x,y))
     18         print(z)
     19 

~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in _cartesian_product_of_elements(self, elements)
   1813 
   1814         """
-> 1815         return self.sum(self.summand_embedding(i)(elements[i]) for i in self._sets_keys())
   1816 
   1817     def cartesian_factors(self):

~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in sum(self, iter_of_elements)
    993             10*B[1] + 10*B[2]
    994         """
--> 995         D = blas.sum(element._monomial_coefficients for element in iter_of_elements)
    996         return self._from_dict(D, remove_zeros=False)
    997 

~/src/sage.git/local/lib/python3.9/site-packages/sage/data_structures/blas_dict.pyx in sage.data_structures.blas_dict.sum (build/cythonized/sage/data_structures/blas_dict.c:3095)()
    270     return axpy(1, D2, D)
    271 
--> 272 cpdef dict sum(dict_iter):
    273     r"""
    274     Return the pointwise addition of dictionaries with coefficients.

~/src/sage.git/local/lib/python3.9/site-packages/sage/data_structures/blas_dict.pyx in sage.data_structures.blas_dict.sum (build/cythonized/sage/data_structures/blas_dict.c:2841)()
    304     cdef list for_removal
    305 
--> 306     for D in dict_iter:
    307         if result:
    308             iaxpy(1, D, result, remove_zeros=False)

~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in <genexpr>(.0)
    993             10*B[1] + 10*B[2]
    994         """
--> 995         D = blas.sum(element._monomial_coefficients for element in iter_of_elements)
    996         return self._from_dict(D, remove_zeros=False)
    997 

~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in <genexpr>(.0)
   1813 
   1814         """
-> 1815         return self.sum(self.summand_embedding(i)(elements[i]) for i in self._sets_keys())
   1816 
   1817     def cartesian_factors(self):

TypeError: 'int' object is not callable
```



---

archive/issue_comments_445308.json:
```json
{
    "body": "<a id='comment:12'></a>It is doing that because you are returning an `int` from the `return len(str(Pi))`.",
    "created_at": "2021-02-27T06:52:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445308",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:12'></a>It is doing that because you are returning an `int` from the `return len(str(Pi))`.



---

archive/issue_comments_445309.json:
```json
{
    "body": "<a id='comment:13'></a>I have now tested it with changing\n\n```python\n    @cached_method \n    def cartesian_embedding(self, i): \n        Ji = self.cartesian_factors()[i] \n        Ei = Ji._module_morphism(lambda t: self.monomial((i, t)), \n                                 codomain=self) \n        print(len(str(Ei))) \n        return Ei \n```\nthis now works and I get\n\n```\nsage: A = MyAlgebra(QQ, 3)                                                                                        \nsage: B = MyAlgebra(QQ, 2)                                                                                        \nsage: C = cartesian_product([A,B])                                                                                \n250\n250\nB[(0, 0)] + B[(1, 0)]\n```",
    "created_at": "2021-02-27T06:55:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445309",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:13'></a>I have now tested it with changing

```python
    @cached_method 
    def cartesian_embedding(self, i): 
        Ji = self.cartesian_factors()[i] 
        Ei = Ji._module_morphism(lambda t: self.monomial((i, t)), 
                                 codomain=self) 
        print(len(str(Ei))) 
        return Ei 
```
this now works and I get

```
sage: A = MyAlgebra(QQ, 3)                                                                                        
sage: B = MyAlgebra(QQ, 2)                                                                                        
sage: C = cartesian_product([A,B])                                                                                
250
250
B[(0, 0)] + B[(1, 0)]
```



---

archive/issue_comments_445310.json:
```json
{
    "body": "<a id='comment:14'></a>Replying to [comment:12 tscrim]:\n> It is doing that because you are returning an `int` from the `return len(str(Pi))`.\n\n\nOh, duh, sorry. Yeah, it works.\n\n...but with that out of the way, I started hitting the same problem with `basis()` getting cached higher up and ignoring the fact that I've changed the indices. I think I'm just going to drop the CFM cartesian product superclass for now. Half of it is already copy/pasted =)",
    "created_at": "2021-02-27T13:36:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445310",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:14'></a>Replying to [comment:12 tscrim]:
> It is doing that because you are returning an `int` from the `return len(str(Pi))`.


Oh, duh, sorry. Yeah, it works.

...but with that out of the way, I started hitting the same problem with `basis()` getting cached higher up and ignoring the fact that I've changed the indices. I think I'm just going to drop the CFM cartesian product superclass for now. Half of it is already copy/pasted =)



---

archive/issue_comments_445311.json:
```json
{
    "body": "<a id='comment:15'></a>For `basis()`, you shouldn't override that, but instead pass the appropriate data up to CFM. Perhaps we should talk about this in more detail off trac to see if we can find a good workaround.",
    "created_at": "2021-02-28T05:46:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445311",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:15'></a>For `basis()`, you shouldn't override that, but instead pass the appropriate data up to CFM. Perhaps we should talk about this in more detail off trac to see if we can find a good workaround.



---

archive/issue_comments_445312.json:
```json
{
    "body": "<a id='comment:16'></a>Replying to [comment:15 tscrim]:\n> For `basis()`, you shouldn't override that, but instead pass the appropriate data up to CFM. Perhaps we should talk about this in more detail off trac to see if we can find a good workaround.\n\n\nI know, but there's a situation with `basis()` like there is with `_cartesian_product_of_elements()` in comment 5. My algebra class is a subclass of CFM. Likewise, CFM_CartesianProduct is a subclass of CFM. When I want to create a cartesian-product subclass of my algebra, it therefore winds up having CFM as a superclass in two different ways, and `CFM.__init__` winds up getting called twice. Between the first and the second, `basis()` gets called somewhere, and the result is cached. Then the second time I initialize it (via my algebra class, with the right data), the `_indices` are updated but the cached `basis()` still returns the data from the first round of initialization.\n\nThis code is all public but not yet polished enough for inclusion:\n\n  http://gitweb.michael.orlitzky.com/?p=sage.d.git;a=tree;f=mjo/eja;hb=HEAD\n\nThe class in question is `mjo.eja.eja_algebra.CartesianProductEJA`.",
    "created_at": "2021-02-28T13:40:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445312",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:16'></a>Replying to [comment:15 tscrim]:
> For `basis()`, you shouldn't override that, but instead pass the appropriate data up to CFM. Perhaps we should talk about this in more detail off trac to see if we can find a good workaround.


I know, but there's a situation with `basis()` like there is with `_cartesian_product_of_elements()` in comment 5. My algebra class is a subclass of CFM. Likewise, CFM_CartesianProduct is a subclass of CFM. When I want to create a cartesian-product subclass of my algebra, it therefore winds up having CFM as a superclass in two different ways, and `CFM.__init__` winds up getting called twice. Between the first and the second, `basis()` gets called somewhere, and the result is cached. Then the second time I initialize it (via my algebra class, with the right data), the `_indices` are updated but the cached `basis()` still returns the data from the first round of initialization.

This code is all public but not yet polished enough for inclusion:

  http://gitweb.michael.orlitzky.com/?p=sage.d.git;a=tree;f=mjo/eja;hb=HEAD

The class in question is `mjo.eja.eja_algebra.CartesianProductEJA`.



---

archive/issue_comments_445313.json:
```json
{
    "body": "<a id='comment:17'></a>Hmm...that is slightly annoying because you do want some extra structure. I believe the original premise of `CFM_CartesianProduct` was that no extra structure would be needed, or if it was, it would be done at the category level. I personally don't want to implement categories for each type algebra, but that is one possibility...\n\nHowever, I do see 2 other reasonable ways to get around this:\n\n1. Be sure to initialize the indices with the correct product on the first call to CFM and don't call the `CFM_CartesianProduct` initialization. The only thing you need to set is `self._sets`.\n2. Factor out the algebra initialization part either into an ABC or `_init_EJA` method.",
    "created_at": "2021-02-28T22:29:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445313",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:17'></a>Hmm...that is slightly annoying because you do want some extra structure. I believe the original premise of `CFM_CartesianProduct` was that no extra structure would be needed, or if it was, it would be done at the category level. I personally don't want to implement categories for each type algebra, but that is one possibility...

However, I do see 2 other reasonable ways to get around this:

1. Be sure to initialize the indices with the correct product on the first call to CFM and don't call the `CFM_CartesianProduct` initialization. The only thing you need to set is `self._sets`.
2. Factor out the algebra initialization part either into an ABC or `_init_EJA` method.



---

archive/issue_comments_445314.json:
```json
{
    "body": "<a id='comment:18'></a>It's really not that big of a deal. For a while I thought I wanted to stick as close to the CFM machinery as possible, but the basis index notation for a disjoint union gets out of hand when you start dealing with cartesian products of cartesian products. Having changed that, I have to redefine the cartesian embedding/projection methods anyway, because they expect the indices to be ordered pairs. And soon enough I've redefined the entire class.\n\nI still think there's a bug here, but my original report obscured the essence of it. I'm going to update the description with a simpler example.",
    "created_at": "2021-03-01T03:07:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445314",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:18'></a>It's really not that big of a deal. For a while I thought I wanted to stick as close to the CFM machinery as possible, but the basis index notation for a disjoint union gets out of hand when you start dealing with cartesian products of cartesian products. Having changed that, I have to redefine the cartesian embedding/projection methods anyway, because they expect the indices to be ordered pairs. And soon enough I've redefined the entire class.

I still think there's a bug here, but my original report obscured the essence of it. I'm going to update the description with a simpler example.



---

archive/issue_events_082408.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-03-24T02:04:25Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31421#event-82408"
}
```



---

archive/issue_comments_445315.json:
```json
{
    "body": "<a id='comment:19'></a>Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-24T02:04:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445315",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:19'></a>Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_082409.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:16:42Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31421#event-82409"
}
```



---

archive/issue_events_082410.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:16:42Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31421#event-82410"
}
```



---

archive/issue_comments_445316.json:
```json
{
    "body": "<a id='comment:21'></a>This is reported in #17201 and #21281, too. Using ``@`cached_method(name=...)` in the superclass to specify a different dict key does work; but if (as in my original report) the superclass is part of the sage library, then that's not an option.",
    "created_at": "2021-10-04T23:53:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31421#issuecomment-445316",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:21'></a>This is reported in #17201 and #21281, too. Using ``@`cached_method(name=...)` in the superclass to specify a different dict key does work; but if (as in my original report) the superclass is part of the sage library, then that's not an option.



---

archive/issue_events_082411.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:11:26Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31421#event-82411"
}
```



---

archive/issue_events_082412.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:11:26Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31421#event-82412"
}
```



---

archive/issue_events_082413.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:17:06Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31421#event-82413"
}
```



---

archive/issue_events_082414.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:17:06Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31421#event-82414"
}
```



---

archive/issue_events_082415.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31421#event-82415"
}
```



---

archive/issue_events_082416.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31421",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31421#event-82416"
}
```
