# Issue 31421: Cached methods of superclasses can overshadow subclass methods

archive/issues_031184.json:
```json
{
    "assignees": [],
    "body": "If a cached superclass method is called before the corresponding cached subclass method, the superclass method gets \"saved\" and overshadows the subclass method from then on. This can easily happen while initializing a subclass as an extension of a superclass with some additional structure. Here is a contrived example:\n\n```python\n....: class MyRealAlgebra: \n....:  \n....:     def __init__(self, basis): \n....:         self._basis = basis \n....:  \n....:     @cached_method \n....:     def basis(self): \n....:         d = len(self._basis[0]) \n....:         V = VectorSpace(RR,d) \n....:         return [V(b) for b in self._basis] \n....:  \n....:  \n....: class MyRationalAlgebra(MyRealAlgebra): \n....:     def __init__(self, basis): \n....:         super().__init__(basis) \n....:         self._basis = [b.change_ring(QQ) for b in super().basis()] \n....:  \n....:     @cached_method \n....:     def basis(self): \n....:         return self._basis \n....:                                                                           \nsage: A = MyRationalAlgebra([(1,0),(0,1)])                                      \nsage: A.basis()                                                                 \n[(1.00000000000000, 0.000000000000000), (0.000000000000000, 1.00000000000000)]\n```\n\nSince the superclass `basis()` method is called while initializing the subclass, it gets cached. Then later when we try to use the subclass method, the superclass method is what we get. Deleting the `@cached_method` decorators fixes the issue, but is not a good solution when the superclass method is expensive and the superclass is of independent use.\n\nStopgaps: **#31422**\n\nComponent: **categories**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/31421_\n\n",
    "created_at": "2021-02-21T00:52:29Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20categories",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.8",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Cached methods of superclasses can overshadow subclass methods",
    "type": "issue",
    "updated_at": "2022-09-19T18:58:47Z",
    "url": "https://github.com/sagemath/sage/issues/31421",
    "user": "https://github.com/orlitzky"
}
```
If a cached superclass method is called before the corresponding cached subclass method, the superclass method gets "saved" and overshadows the subclass method from then on. This can easily happen while initializing a subclass as an extension of a superclass with some additional structure. Here is a contrived example:

```python
....: class MyRealAlgebra: 
....:  
....:     def __init__(self, basis): 
....:         self._basis = basis 
....:  
....:     @cached_method 
....:     def basis(self): 
....:         d = len(self._basis[0]) 
....:         V = VectorSpace(RR,d) 
....:         return [V(b) for b in self._basis] 
....:  
....:  
....: class MyRationalAlgebra(MyRealAlgebra): 
....:     def __init__(self, basis): 
....:         super().__init__(basis) 
....:         self._basis = [b.change_ring(QQ) for b in super().basis()] 
....:  
....:     @cached_method 
....:     def basis(self): 
....:         return self._basis 
....:                                                                           
sage: A = MyRationalAlgebra([(1,0),(0,1)])                                      
sage: A.basis()                                                                 
[(1.00000000000000, 0.000000000000000), (0.000000000000000, 1.00000000000000)]
```

Since the superclass `basis()` method is called while initializing the subclass, it gets cached. Then later when we try to use the subclass method, the superclass method is what we get. Deleting the `@cached_method` decorators fixes the issue, but is not a good solution when the superclass method is expensive and the superclass is of independent use.

Stopgaps: **#31422**

Component: **categories**

_Issue created by migration from https://trac.sagemath.org/ticket/31421_





---

archive/issue_events_429986.json:
```json
{
    "actor": "https://github.com/orlitzky",
    "created_at": "2021-02-21T00:52:29Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429986"
}
```



---

archive/issue_events_429987.json:
```json
{
    "actor": "https://github.com/orlitzky",
    "created_at": "2021-02-21T00:52:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20categories",
    "label_color": "0000ff",
    "label_name": "c: categories",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429987"
}
```



---

archive/issue_events_429988.json:
```json
{
    "actor": "https://github.com/orlitzky",
    "created_at": "2021-02-21T00:52:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429988"
}
```



---

archive/issue_events_429989.json:
```json
{
    "actor": "https://github.com/orlitzky",
    "created_at": "2021-02-21T00:52:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429989"
}
```



---

archive/issue_comments_504491.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nStopgap in #31422.",
    "created_at": "2021-02-21T01:01:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504491",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:1" align="right">comment:1</div>

Stopgap in #31422.



---

archive/issue_comments_504492.json:
```json
{
    "body": "Stopgaps: **#31422**",
    "created_at": "2021-02-21T01:01:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504492",
    "user": "https://github.com/orlitzky"
}
```

Stopgaps: **#31422**



---

archive/issue_comments_504493.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nThis is an issue with the `@cached_method`, not with these specific methods. The problem comes from the `super()` call:\n\n```python\nsage: class Foo:\n....:     @cached_method\n....:     def check(self, x):\n....:         return x\n....: class Bar(Foo):\n....:     @cached_method   % This can also be removed and it will still fail\n....:     def check(self, x):\n....:         y = super().check(x)\n....:         return y * y\n```\n\n```\nsage: B = Bar()\nsage: B.check(5)\n25\nsage: B.check(7)\n7\n```\n\nCalling the `super().check()` invokes the `Foo.check()`'s `@cached_method`, which invokes the decorator to set the actual function.\n\nBecause of this, I don't think the proposal on #31422 is a valid stopgap because it is a deeper underlying issue rather than tied to these specific methods. Furthermore, having those cached is very useful for computations.\n\nThe obvious workaround would be to copy the code directly. Alternatively, the code of these methods can be pushed to a, e.g., `_cartesian_projection` with the access done directly to avoid code duplication. However, these are hacks and would need to be done on a case-by-case basis.\n\nLikely the solution will involve being more careful with how the `@`cached_method works, hopefully being able to do something with which class in the MRO it replaces.",
    "created_at": "2021-02-22T05:04:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504493",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:2" align="right">comment:2</div>

This is an issue with the `@cached_method`, not with these specific methods. The problem comes from the `super()` call:

```python
sage: class Foo:
....:     @cached_method
....:     def check(self, x):
....:         return x
....: class Bar(Foo):
....:     @cached_method   % This can also be removed and it will still fail
....:     def check(self, x):
....:         y = super().check(x)
....:         return y * y
```

```
sage: B = Bar()
sage: B.check(5)
25
sage: B.check(7)
7
```

Calling the `super().check()` invokes the `Foo.check()`'s `@cached_method`, which invokes the decorator to set the actual function.

Because of this, I don't think the proposal on #31422 is a valid stopgap because it is a deeper underlying issue rather than tied to these specific methods. Furthermore, having those cached is very useful for computations.

The obvious workaround would be to copy the code directly. Alternatively, the code of these methods can be pushed to a, e.g., `_cartesian_projection` with the access done directly to avoid code duplication. However, these are hacks and would need to be done on a case-by-case basis.

Likely the solution will involve being more careful with how the `@`cached_method works, hopefully being able to do something with which class in the MRO it replaces.



---

archive/issue_comments_504494.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nThanks! I'm using this pattern elsewhere (which is why I thought it was related to the cartesian product) but I guess I've been extremely lucky so far, only using it for performance gains and not to change the actual output.\n\nI marked the stopgap WONTFIX.",
    "created_at": "2021-02-22T12:35:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504494",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:3" align="right">comment:3</div>

Thanks! I'm using this pattern elsewhere (which is why I thought it was related to the cartesian product) but I guess I've been extremely lucky so far, only using it for performance gains and not to change the actual output.

I marked the stopgap WONTFIX.



---

archive/issue_comments_504495.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nEven copy/pasting the code doesn't work! I give up.",
    "created_at": "2021-02-22T13:19:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504495",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:4" align="right">comment:4</div>

Even copy/pasting the code doesn't work! I give up.



---

archive/issue_comments_504496.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nWith slight modification:\n\n```python\nfrom sage.all import *\nfrom sage.combinat.free_module import CombinatorialFreeModule_CartesianProduct\n\nclass MyAlgebra(CombinatorialFreeModule):\n    def __init__(self, R, n, *args, **kwargs):\n        CombinatorialFreeModule.__init__(self, R, Zmod(n), *args, **kwargs)\n\n\nclass MyCartProd(CombinatorialFreeModule_CartesianProduct, MyAlgebra):\n    def __init__(self, modules, **kwargs):\n        CombinatorialFreeModule_CartesianProduct.__init__(self,\n                                                          modules,\n                                                          **kwargs)\n\n        x = modules[0].monomial(0)\n        y = modules[1].monomial(0)\n        z = self._cartesian_product_of_elements((x,y))\n        print(z)\n\n    @cached_method\n    def cartesian_projection(self, i):\n        Ji = self.cartesian_factors()[i]\n        Pi = self._module_morphism(lambda j_t: Ji.monomial(j_t[1])\n                                   if i == j_t[0] else Ji.zero(),\n                                   codomain=Ji)\n        return len(str(Pi))\n\n    @cached_method\n    def cartesian_embedding(self, i):\n        Ji = self.cartesian_factors()[i]\n        Ei = Ji._module_morphism(lambda t: self.monomial((i, t)),\n                                 codomain=self)\n        return len(str(Ei))\n\nMyAlgebra.CartesianProduct = MyCartProd\n```\n\nThe superclass embedding method is still used, as it gets cached by the call to  `_cartesian_product_of_elements()`:\n\n```\nsage: A = MyAlgebra(QQ,3)                                                                                                                                                    \nsage: B = MyAlgebra(QQ,2)                                                                                                                                                    \nsage: C = cartesian_product([A,B])                                                                                                                                           \nB[(0, 0)] + B[(1, 0)]\nsage: C.cartesian_embedding(0)                                                                                                                                               \nGeneric morphism:\n  From: Free module generated by Ring of integers modulo 3 over Rational Field\n  To:   Free module generated by Ring of integers modulo 3 over Rational Field (+) Free module generated by Ring of integers modulo 2 over Rational Field\n```",
    "created_at": "2021-02-22T13:35:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504496",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:5" align="right">comment:5</div>

With slight modification:

```python
from sage.all import *
from sage.combinat.free_module import CombinatorialFreeModule_CartesianProduct

class MyAlgebra(CombinatorialFreeModule):
    def __init__(self, R, n, *args, **kwargs):
        CombinatorialFreeModule.__init__(self, R, Zmod(n), *args, **kwargs)


class MyCartProd(CombinatorialFreeModule_CartesianProduct, MyAlgebra):
    def __init__(self, modules, **kwargs):
        CombinatorialFreeModule_CartesianProduct.__init__(self,
                                                          modules,
                                                          **kwargs)

        x = modules[0].monomial(0)
        y = modules[1].monomial(0)
        z = self._cartesian_product_of_elements((x,y))
        print(z)

    @cached_method
    def cartesian_projection(self, i):
        Ji = self.cartesian_factors()[i]
        Pi = self._module_morphism(lambda j_t: Ji.monomial(j_t[1])
                                   if i == j_t[0] else Ji.zero(),
                                   codomain=Ji)
        return len(str(Pi))

    @cached_method
    def cartesian_embedding(self, i):
        Ji = self.cartesian_factors()[i]
        Ei = Ji._module_morphism(lambda t: self.monomial((i, t)),
                                 codomain=self)
        return len(str(Ei))

MyAlgebra.CartesianProduct = MyCartProd
```

The superclass embedding method is still used, as it gets cached by the call to  `_cartesian_product_of_elements()`:

```
sage: A = MyAlgebra(QQ,3)                                                                                                                                                    
sage: B = MyAlgebra(QQ,2)                                                                                                                                                    
sage: C = cartesian_product([A,B])                                                                                                                                           
B[(0, 0)] + B[(1, 0)]
sage: C.cartesian_embedding(0)                                                                                                                                               
Generic morphism:
  From: Free module generated by Ring of integers modulo 3 over Rational Field
  To:   Free module generated by Ring of integers modulo 3 over Rational Field (+) Free module generated by Ring of integers modulo 2 over Rational Field
```



---

archive/issue_comments_504497.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nInterestingly it seems to work for `cartesian_projection`:\n\n```\nsage: C.cartesian_projection(0)                                                                                   \n250\nsage: C.cartesian_projection(1)                                                                                   \n250\n```\nSomething very strange is happening with the `cartesian_embedding`, which is a different error.",
    "created_at": "2021-02-22T23:25:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504497",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:6" align="right">comment:6</div>

Interestingly it seems to work for `cartesian_projection`:

```
sage: C.cartesian_projection(0)                                                                                   
250
sage: C.cartesian_projection(1)                                                                                   
250
```
Something very strange is happening with the `cartesian_embedding`, which is a different error.



---

archive/issue_comments_504498.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nOkay, the other problem comes from the alias:\n\n```\nsummand_embedding = cartesian_embedding\n```\nand `summand_embedding` gets called in `CombinatorialFreeModule._cartesian_product_of_elements`. Because the name is actually tied to `cartesian_embedding`, the `@cached_method` then overrides that. So the workaround here is to reset the alias (which is something you want to do anyways).",
    "created_at": "2021-02-22T23:28:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504498",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:7" align="right">comment:7</div>

Okay, the other problem comes from the alias:

```
summand_embedding = cartesian_embedding
```
and `summand_embedding` gets called in `CombinatorialFreeModule._cartesian_product_of_elements`. Because the name is actually tied to `cartesian_embedding`, the `@cached_method` then overrides that. So the workaround here is to reset the alias (which is something you want to do anyways).



---

archive/issue_comments_504499.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nAlso, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`.",
    "created_at": "2021-02-22T23:29:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504499",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:8" align="right">comment:8</div>

Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`.



---

archive/issue_comments_504500.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nReplying to [@tscrim](#comment%3A7):\n> So the workaround here is to reset the alias (which is something you want to do anyways).\n\nCan I ask why? What does `summand_embedding` even do? git grep turns up only the one hit on free_module.py.\n\n> Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`. \n\nAdding to the list of things I cannot explain, this also doesn't work. After changing `summand` to `cartesian`, it returns... an int?",
    "created_at": "2021-02-23T01:36:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504500",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:9" align="right">comment:9</div>

Replying to [@tscrim](#comment%3A7):
> So the workaround here is to reset the alias (which is something you want to do anyways).

Can I ask why? What does `summand_embedding` even do? git grep turns up only the one hit on free_module.py.

> Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`. 

Adding to the list of things I cannot explain, this also doesn't work. After changing `summand` to `cartesian`, it returns... an int?



---

archive/issue_comments_504501.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nReplying to [@orlitzky](#comment%3A9):\n> Replying to [@tscrim](#comment%3A7):\n> > So the workaround here is to reset the alias (which is something you want to do anyways).\n\n> \n> Can I ask why? What does `summand_embedding` even do? git grep turns up only the one hit on free_module.py.\n\nThis was likely leftover from before that stuff got moved up to the category level. It can simply be replaced too (see below).\n \n> > Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`. \n\n>\n> Adding to the list of things I cannot explain, this also doesn't work. After changing `summand` to `cartesian`, it returns... an int?\n\nWhere, in your code? I would just add the line\n\n```\nsummand_embedding = cartesian_embedding\n```\nI haven't tested it, but I think that should fix it.",
    "created_at": "2021-02-25T22:52:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504501",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:10" align="right">comment:10</div>

Replying to [@orlitzky](#comment%3A9):
> Replying to [@tscrim](#comment%3A7):
> > So the workaround here is to reset the alias (which is something you want to do anyways).

> 
> Can I ask why? What does `summand_embedding` even do? git grep turns up only the one hit on free_module.py.

This was likely leftover from before that stuff got moved up to the category level. It can simply be replaced too (see below).
 
> > Also, we should instead call `cartesian_embedding` in the CFM code instead of `summand_embedding`. 

>
> Adding to the list of things I cannot explain, this also doesn't work. After changing `summand` to `cartesian`, it returns... an int?

Where, in your code? I would just add the line

```
summand_embedding = cartesian_embedding
```
I haven't tested it, but I think that should fix it.



---

archive/issue_comments_504502.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nReplying to [@tscrim](#comment%3A10):\n> \n> Where, in your code? I would just add the line\n> \n> ```\n> summand_embedding = cartesian_embedding\n> ```\n> I haven't tested it, but I think that should fix it.\n\nYeah. Running that gives,\n\n```\nsage: A = MyAlgebra(QQ,3)                                                       \nsage: B = MyAlgebra(QQ,2)                                                       \nsage: C = cartesian_product([A,B])                                              \n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5974)()\n    995             try:\n--> 996                 return self.cache[k]\n    997             except TypeError:  # k is not hashable\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/weak_dict.pyx in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3736)()\n    703         if wr == NULL:\n--> 704             raise KeyError(k)\n    705         out = PyWeakref_GetObject(wr)\n\nKeyError: ((<class '__main__.MyCartProd'>, (Free module generated by Ring of integers modulo 3 over Rational Field, Free module generated by Ring of integers modulo 2 over Rational Field)), (('category', Category of Cartesian products of vector spaces with basis over Rational Field),))\n\nDuring handling of the above exception, another exception occurred:\n\nTypeError                                 Traceback (most recent call last)\n<ipython-input-4-1785ba83158c> in <module>\n----> 1 C = cartesian_product([A,B])\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/lazy_import.pyx in sage.misc.lazy_import.LazyImport.__call__ (build/cythonized/sage/misc/lazy_import.c:4032)()\n    358             True\n    359         \"\"\"\n--> 360         return self.get_object()(*args, **kwds)\n    361 \n    362     def __repr__(self):\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/cartesian_product.py in __call__(self, args, **kwds)\n    191             return super(CartesianProductFunctor, self).__call__(args, category=self._forced_category, **kwds)\n    192 \n--> 193         return super(CartesianProductFunctor, self).__call__(args, **kwds)\n    194 \n    195     def __eq__(self, other):\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/covariant_functorial_construction.py in __call__(self, args, **kwargs)\n    220         assert(all( hasattr(arg, self._functor_name) for arg in args))\n    221         assert(len(args) > 0)\n--> 222         return getattr(args[0], self._functor_name)(*args[1:], **kwargs)\n    223 \n    224 class FunctorialConstructionCategory(Category): # Should this be CategoryWithBase?\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/sets_cat.py in cartesian_product(*parents, **kwargs)\n   1583                 else:\n   1584                     category = category & extra_category\n-> 1585             return parents[0].CartesianProduct(parents, category=category, **kwargs)\n   1586 \n   1587         def algebra(self, base_ring, category=None, **kwds):\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1761)()\n    320         \"\"\"\n    321         if cls.classcall is not None:\n--> 322             return cls.classcall(cls, *args, **kwds)\n    323         else:\n    324             # Fast version of type.__call__(cls, *args, **kwds)\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6100)()\n    999                 return self.cache[k]\n   1000         except KeyError:\n-> 1001             w = self.f(*args, **kwds)\n   1002             self.cache[k] = w\n   1003             return w\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/structure/unique_representation.py in __classcall__(cls, *args, **options)\n   1005             True\n   1006         \"\"\"\n-> 1007         instance = typecall(cls, *args, **options)\n   1008         assert isinstance( instance, cls )\n   1009         if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2223)()\n    484             TypeError: Argument 'cls' has incorrect type (expected type, got classobj)\n    485     \"\"\"\n--> 486     return (<PyTypeObject*>type).tp_call(cls, args, kwds)\n    487 \n    488 # Class for timing::\n\n<ipython-input-1-f81f7af80573> in __init__(self, modules, **kwargs)\n     15         x = modules[Integer(0)].monomial(Integer(0))\n     16         y = modules[Integer(1)].monomial(Integer(0))\n---> 17         z = self._cartesian_product_of_elements((x,y))\n     18         print(z)\n     19 \n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in _cartesian_product_of_elements(self, elements)\n   1813 \n   1814         \"\"\"\n-> 1815         return self.sum(self.summand_embedding(i)(elements[i]) for i in self._sets_keys())\n   1816 \n   1817     def cartesian_factors(self):\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in sum(self, iter_of_elements)\n    993             10*B[1] + 10*B[2]\n    994         \"\"\"\n--> 995         D = blas.sum(element._monomial_coefficients for element in iter_of_elements)\n    996         return self._from_dict(D, remove_zeros=False)\n    997 \n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/data_structures/blas_dict.pyx in sage.data_structures.blas_dict.sum (build/cythonized/sage/data_structures/blas_dict.c:3095)()\n    270     return axpy(1, D2, D)\n    271 \n--> 272 cpdef dict sum(dict_iter):\n    273     r\"\"\"\n    274     Return the pointwise addition of dictionaries with coefficients.\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/data_structures/blas_dict.pyx in sage.data_structures.blas_dict.sum (build/cythonized/sage/data_structures/blas_dict.c:2841)()\n    304     cdef list for_removal\n    305 \n--> 306     for D in dict_iter:\n    307         if result:\n    308             iaxpy(1, D, result, remove_zeros=False)\n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in <genexpr>(.0)\n    993             10*B[1] + 10*B[2]\n    994         \"\"\"\n--> 995         D = blas.sum(element._monomial_coefficients for element in iter_of_elements)\n    996         return self._from_dict(D, remove_zeros=False)\n    997 \n\n~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in <genexpr>(.0)\n   1813 \n   1814         \"\"\"\n-> 1815         return self.sum(self.summand_embedding(i)(elements[i]) for i in self._sets_keys())\n   1816 \n   1817     def cartesian_factors(self):\n\nTypeError: 'int' object is not callable\n```",
    "created_at": "2021-02-27T03:34:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504502",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:11" align="right">comment:11</div>

Replying to [@tscrim](#comment%3A10):
> 
> Where, in your code? I would just add the line
> 
> ```
> summand_embedding = cartesian_embedding
> ```
> I haven't tested it, but I think that should fix it.

Yeah. Running that gives,

```
sage: A = MyAlgebra(QQ,3)                                                       
sage: B = MyAlgebra(QQ,2)                                                       
sage: C = cartesian_product([A,B])                                              
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5974)()
    995             try:
--> 996                 return self.cache[k]
    997             except TypeError:  # k is not hashable

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/weak_dict.pyx in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3736)()
    703         if wr == NULL:
--> 704             raise KeyError(k)
    705         out = PyWeakref_GetObject(wr)

KeyError: ((<class '__main__.MyCartProd'>, (Free module generated by Ring of integers modulo 3 over Rational Field, Free module generated by Ring of integers modulo 2 over Rational Field)), (('category', Category of Cartesian products of vector spaces with basis over Rational Field),))

During handling of the above exception, another exception occurred:

TypeError                                 Traceback (most recent call last)
<ipython-input-4-1785ba83158c> in <module>
----> 1 C = cartesian_product([A,B])

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/lazy_import.pyx in sage.misc.lazy_import.LazyImport.__call__ (build/cythonized/sage/misc/lazy_import.c:4032)()
    358             True
    359         """
--> 360         return self.get_object()(*args, **kwds)
    361 
    362     def __repr__(self):

~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/cartesian_product.py in __call__(self, args, **kwds)
    191             return super(CartesianProductFunctor, self).__call__(args, category=self._forced_category, **kwds)
    192 
--> 193         return super(CartesianProductFunctor, self).__call__(args, **kwds)
    194 
    195     def __eq__(self, other):

~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/covariant_functorial_construction.py in __call__(self, args, **kwargs)
    220         assert(all( hasattr(arg, self._functor_name) for arg in args))
    221         assert(len(args) > 0)
--> 222         return getattr(args[0], self._functor_name)(*args[1:], **kwargs)
    223 
    224 class FunctorialConstructionCategory(Category): # Should this be CategoryWithBase?

~/src/sage.git/local/lib/python3.9/site-packages/sage/categories/sets_cat.py in cartesian_product(*parents, **kwargs)
   1583                 else:
   1584                     category = category & extra_category
-> 1585             return parents[0].CartesianProduct(parents, category=category, **kwargs)
   1586 
   1587         def algebra(self, base_ring, category=None, **kwds):

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1761)()
    320         """
    321         if cls.classcall is not None:
--> 322             return cls.classcall(cls, *args, **kwds)
    323         else:
    324             # Fast version of type.__call__(cls, *args, **kwds)

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/cachefunc.pyx in sage.misc.cachefunc.CachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:6100)()
    999                 return self.cache[k]
   1000         except KeyError:
-> 1001             w = self.f(*args, **kwds)
   1002             self.cache[k] = w
   1003             return w

~/src/sage.git/local/lib/python3.9/site-packages/sage/structure/unique_representation.py in __classcall__(cls, *args, **options)
   1005             True
   1006         """
-> 1007         instance = typecall(cls, *args, **options)
   1008         assert isinstance( instance, cls )
   1009         if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:

~/src/sage.git/local/lib/python3.9/site-packages/sage/misc/classcall_metaclass.pyx in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2223)()
    484             TypeError: Argument 'cls' has incorrect type (expected type, got classobj)
    485     """
--> 486     return (<PyTypeObject*>type).tp_call(cls, args, kwds)
    487 
    488 # Class for timing::

<ipython-input-1-f81f7af80573> in __init__(self, modules, **kwargs)
     15         x = modules[Integer(0)].monomial(Integer(0))
     16         y = modules[Integer(1)].monomial(Integer(0))
---> 17         z = self._cartesian_product_of_elements((x,y))
     18         print(z)
     19 

~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in _cartesian_product_of_elements(self, elements)
   1813 
   1814         """
-> 1815         return self.sum(self.summand_embedding(i)(elements[i]) for i in self._sets_keys())
   1816 
   1817     def cartesian_factors(self):

~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in sum(self, iter_of_elements)
    993             10*B[1] + 10*B[2]
    994         """
--> 995         D = blas.sum(element._monomial_coefficients for element in iter_of_elements)
    996         return self._from_dict(D, remove_zeros=False)
    997 

~/src/sage.git/local/lib/python3.9/site-packages/sage/data_structures/blas_dict.pyx in sage.data_structures.blas_dict.sum (build/cythonized/sage/data_structures/blas_dict.c:3095)()
    270     return axpy(1, D2, D)
    271 
--> 272 cpdef dict sum(dict_iter):
    273     r"""
    274     Return the pointwise addition of dictionaries with coefficients.

~/src/sage.git/local/lib/python3.9/site-packages/sage/data_structures/blas_dict.pyx in sage.data_structures.blas_dict.sum (build/cythonized/sage/data_structures/blas_dict.c:2841)()
    304     cdef list for_removal
    305 
--> 306     for D in dict_iter:
    307         if result:
    308             iaxpy(1, D, result, remove_zeros=False)

~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in <genexpr>(.0)
    993             10*B[1] + 10*B[2]
    994         """
--> 995         D = blas.sum(element._monomial_coefficients for element in iter_of_elements)
    996         return self._from_dict(D, remove_zeros=False)
    997 

~/src/sage.git/local/lib/python3.9/site-packages/sage/combinat/free_module.py in <genexpr>(.0)
   1813 
   1814         """
-> 1815         return self.sum(self.summand_embedding(i)(elements[i]) for i in self._sets_keys())
   1816 
   1817     def cartesian_factors(self):

TypeError: 'int' object is not callable
```



---

archive/issue_comments_504503.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nIt is doing that because you are returning an `int` from the `return len(str(Pi))`.",
    "created_at": "2021-02-27T06:52:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504503",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:12" align="right">comment:12</div>

It is doing that because you are returning an `int` from the `return len(str(Pi))`.



---

archive/issue_comments_504504.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nI have now tested it with changing\n\n```python\n    @cached_method \n    def cartesian_embedding(self, i): \n        Ji = self.cartesian_factors()[i] \n        Ei = Ji._module_morphism(lambda t: self.monomial((i, t)), \n                                 codomain=self) \n        print(len(str(Ei))) \n        return Ei \n```\nthis now works and I get\n\n```\nsage: A = MyAlgebra(QQ, 3)                                                                                        \nsage: B = MyAlgebra(QQ, 2)                                                                                        \nsage: C = cartesian_product([A,B])                                                                                \n250\n250\nB[(0, 0)] + B[(1, 0)]\n```",
    "created_at": "2021-02-27T06:55:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504504",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:13" align="right">comment:13</div>

I have now tested it with changing

```python
    @cached_method 
    def cartesian_embedding(self, i): 
        Ji = self.cartesian_factors()[i] 
        Ei = Ji._module_morphism(lambda t: self.monomial((i, t)), 
                                 codomain=self) 
        print(len(str(Ei))) 
        return Ei 
```
this now works and I get

```
sage: A = MyAlgebra(QQ, 3)                                                                                        
sage: B = MyAlgebra(QQ, 2)                                                                                        
sage: C = cartesian_product([A,B])                                                                                
250
250
B[(0, 0)] + B[(1, 0)]
```



---

archive/issue_comments_504505.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nReplying to [@tscrim](#comment%3A12):\n> It is doing that because you are returning an `int` from the `return len(str(Pi))`.\n\nOh, duh, sorry. Yeah, it works.\n\n...but with that out of the way, I started hitting the same problem with `basis()` getting cached higher up and ignoring the fact that I've changed the indices. I think I'm just going to drop the CFM cartesian product superclass for now. Half of it is already copy/pasted =)",
    "created_at": "2021-02-27T13:36:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504505",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:14" align="right">comment:14</div>

Replying to [@tscrim](#comment%3A12):
> It is doing that because you are returning an `int` from the `return len(str(Pi))`.

Oh, duh, sorry. Yeah, it works.

...but with that out of the way, I started hitting the same problem with `basis()` getting cached higher up and ignoring the fact that I've changed the indices. I think I'm just going to drop the CFM cartesian product superclass for now. Half of it is already copy/pasted =)



---

archive/issue_comments_504506.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nFor `basis()`, you shouldn't override that, but instead pass the appropriate data up to CFM. Perhaps we should talk about this in more detail off trac to see if we can find a good workaround.",
    "created_at": "2021-02-28T05:46:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504506",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:15" align="right">comment:15</div>

For `basis()`, you shouldn't override that, but instead pass the appropriate data up to CFM. Perhaps we should talk about this in more detail off trac to see if we can find a good workaround.



---

archive/issue_comments_504507.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nReplying to [@tscrim](#comment%3A15):\n> For `basis()`, you shouldn't override that, but instead pass the appropriate data up to CFM. Perhaps we should talk about this in more detail off trac to see if we can find a good workaround.\n\nI know, but there's a situation with `basis()` like there is with `_cartesian_product_of_elements()` in comment 5. My algebra class is a subclass of CFM. Likewise, CFM_CartesianProduct is a subclass of CFM. When I want to create a cartesian-product subclass of my algebra, it therefore winds up having CFM as a superclass in two different ways, and `CFM.__init__` winds up getting called twice. Between the first and the second, `basis()` gets called somewhere, and the result is cached. Then the second time I initialize it (via my algebra class, with the right data), the `_indices` are updated but the cached `basis()` still returns the data from the first round of initialization.\n\nThis code is all public but not yet polished enough for inclusion:\n\n  http://gitweb.michael.orlitzky.com/?p=sage.d.git;a=tree;f=mjo/eja;hb=HEAD\n\nThe class in question is `mjo.eja.eja_algebra.CartesianProductEJA`.",
    "created_at": "2021-02-28T13:40:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504507",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:16" align="right">comment:16</div>

Replying to [@tscrim](#comment%3A15):
> For `basis()`, you shouldn't override that, but instead pass the appropriate data up to CFM. Perhaps we should talk about this in more detail off trac to see if we can find a good workaround.

I know, but there's a situation with `basis()` like there is with `_cartesian_product_of_elements()` in comment 5. My algebra class is a subclass of CFM. Likewise, CFM_CartesianProduct is a subclass of CFM. When I want to create a cartesian-product subclass of my algebra, it therefore winds up having CFM as a superclass in two different ways, and `CFM.__init__` winds up getting called twice. Between the first and the second, `basis()` gets called somewhere, and the result is cached. Then the second time I initialize it (via my algebra class, with the right data), the `_indices` are updated but the cached `basis()` still returns the data from the first round of initialization.

This code is all public but not yet polished enough for inclusion:

  http://gitweb.michael.orlitzky.com/?p=sage.d.git;a=tree;f=mjo/eja;hb=HEAD

The class in question is `mjo.eja.eja_algebra.CartesianProductEJA`.



---

archive/issue_comments_504508.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nHmm...that is slightly annoying because you do want some extra structure. I believe the original premise of `CFM_CartesianProduct` was that no extra structure would be needed, or if it was, it would be done at the category level. I personally don't want to implement categories for each type algebra, but that is one possibility...\n\nHowever, I do see 2 other reasonable ways to get around this:\n\n1. Be sure to initialize the indices with the correct product on the first call to CFM and don't call the `CFM_CartesianProduct` initialization. The only thing you need to set is `self._sets`.\n2. Factor out the algebra initialization part either into an ABC or `_init_EJA` method.",
    "created_at": "2021-02-28T22:29:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504508",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:17" align="right">comment:17</div>

Hmm...that is slightly annoying because you do want some extra structure. I believe the original premise of `CFM_CartesianProduct` was that no extra structure would be needed, or if it was, it would be done at the category level. I personally don't want to implement categories for each type algebra, but that is one possibility...

However, I do see 2 other reasonable ways to get around this:

1. Be sure to initialize the indices with the correct product on the first call to CFM and don't call the `CFM_CartesianProduct` initialization. The only thing you need to set is `self._sets`.
2. Factor out the algebra initialization part either into an ABC or `_init_EJA` method.



---

archive/issue_comments_504509.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,50 +1,30 @@\n-As reported in https://www.mail-archive.com/sage-devel@googlegroups.com/msg101760.html, cached methods of cartesian products act weird. The superclass method results can wind up cached in subclasses that should have those methods overridden. Here is a minimal example:\n+If a cached superclass method is called before the corresponding cached subclass method, the superclass method gets \"saved\" and overshadows the subclass method from then on. This can easily happen while initializing a subclass as an extension of a superclass with some additional structure. Here is a contrived example:\n \n ```python\n-from sage.all import *\n-from sage.combinat.free_module import CombinatorialFreeModule_CartesianProduct\n-\n-class MyAlgebra(CombinatorialFreeModule):\n-    def __init__(self, R, n, *args, **kwargs):\n-        CombinatorialFreeModule.__init__(self, R, Zmod(n), *args, **kwargs)\n-\n-\n-class MyCartProd(MyAlgebra, CombinatorialFreeModule_CartesianProduct):\n-    def __init__(self, modules, **kwargs):\n-        CombinatorialFreeModule_CartesianProduct.__init__(self,\n-                                                          modules,\n-                                                          **kwargs)\n-    @cached_method\n-    def cartesian_projection(self, i):\n-        P = super().cartesian_projection(i)\n-        return \"Just kidding\"\n-\n-    @cached_method\n-    def cartesian_embedding(self, i):\n-        E = super().cartesian_embedding(i)\n-        return \"Just kidding\"\n-\n-MyAlgebra.CartesianProduct = MyCartProd\n+....: class MyRealAlgebra: \n+....:  \n+....:     def __init__(self, basis): \n+....:         self._basis = basis \n+....:  \n+....:     @cached_method \n+....:     def basis(self): \n+....:         d = len(self._basis[0]) \n+....:         V = VectorSpace(RR,d) \n+....:         return [V(b) for b in self._basis] \n+....:  \n+....:  \n+....: class MyRationalAlgebra(MyRealAlgebra): \n+....:     def __init__(self, basis): \n+....:         super().__init__(basis) \n+....:         self._basis = [b.change_ring(QQ) for b in super().basis()] \n+....:  \n+....:     @cached_method \n+....:     def basis(self): \n+....:         return self._basis \n+....:                                                                           \n+sage: A = MyRationalAlgebra([(1,0),(0,1)])                                      \n+sage: A.basis()                                                                 \n+[(1.00000000000000, 0.000000000000000), (0.000000000000000, 1.00000000000000)]\n ```\n \n-Running this in a terminal shows what happens. In all cases, the \"Just kidding\" result should be returned. The generic morphism thing is from CombinatorialFreeModule_CartesianProduct:\n-\n-```\n-sage: A = MyAlgebra(QQ,3)                                                                                                                                                    \n-sage: B = MyAlgebra(QQ,2)                                                                                                                                                    \n-sage: C = cartesian_product([A,B])                                                                                                                                           \n-sage: C.cartesian_projection(0)                                                                                                                                              \n-'Just kidding'\n-sage: C.cartesian_projection(1)                                                                                                                                              \n-Generic morphism:\n-  From: Free module generated by Ring of integers modulo 3 over Rational Field (+) Free module generated by Ring of integers modulo 2 over Rational Field\n-  To:   Free module generated by Ring of integers modulo 2 over Rational Field\n-sage: C.cartesian_embedding(0)                                                                                                                                               \n-'Just kidding'\n-sage: C.cartesian_embedding(1)                                                                                                                                               \n-Generic morphism:\n-  From: Free module generated by Ring of integers modulo 2 over Rational Field\n-  To:   Free module generated by Ring of integers modulo 3 over Rational Field (+) Free module generated by Ring of integers modulo 2 over Rational Field\n-```\n-\n-I am opening this now so that I can add a stopgap in another ticket. Deleting the `@cached_method` decorators on the `CombinatorialFreeModule_CartesianProduct` methods fixes the problem, but obviously does not address the root cause.\n+Since the superclass `basis()` method is called while initializing the subclass, it gets cached. Then later when we try to use the subclass method, the superclass method is what we get. Deleting the `@cached_method` decorators fixes the issue, but is not a good solution when the superclass method is expensive and the superclass is of independent use.\n``````\n",
    "created_at": "2021-03-01T03:07:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504509",
    "user": "https://github.com/orlitzky"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,50 +1,30 @@
-As reported in https://www.mail-archive.com/sage-devel@googlegroups.com/msg101760.html, cached methods of cartesian products act weird. The superclass method results can wind up cached in subclasses that should have those methods overridden. Here is a minimal example:
+If a cached superclass method is called before the corresponding cached subclass method, the superclass method gets "saved" and overshadows the subclass method from then on. This can easily happen while initializing a subclass as an extension of a superclass with some additional structure. Here is a contrived example:
 
 ```python
-from sage.all import *
-from sage.combinat.free_module import CombinatorialFreeModule_CartesianProduct
-
-class MyAlgebra(CombinatorialFreeModule):
-    def __init__(self, R, n, *args, **kwargs):
-        CombinatorialFreeModule.__init__(self, R, Zmod(n), *args, **kwargs)
-
-
-class MyCartProd(MyAlgebra, CombinatorialFreeModule_CartesianProduct):
-    def __init__(self, modules, **kwargs):
-        CombinatorialFreeModule_CartesianProduct.__init__(self,
-                                                          modules,
-                                                          **kwargs)
-    @cached_method
-    def cartesian_projection(self, i):
-        P = super().cartesian_projection(i)
-        return "Just kidding"
-
-    @cached_method
-    def cartesian_embedding(self, i):
-        E = super().cartesian_embedding(i)
-        return "Just kidding"
-
-MyAlgebra.CartesianProduct = MyCartProd
+....: class MyRealAlgebra: 
+....:  
+....:     def __init__(self, basis): 
+....:         self._basis = basis 
+....:  
+....:     @cached_method 
+....:     def basis(self): 
+....:         d = len(self._basis[0]) 
+....:         V = VectorSpace(RR,d) 
+....:         return [V(b) for b in self._basis] 
+....:  
+....:  
+....: class MyRationalAlgebra(MyRealAlgebra): 
+....:     def __init__(self, basis): 
+....:         super().__init__(basis) 
+....:         self._basis = [b.change_ring(QQ) for b in super().basis()] 
+....:  
+....:     @cached_method 
+....:     def basis(self): 
+....:         return self._basis 
+....:                                                                           
+sage: A = MyRationalAlgebra([(1,0),(0,1)])                                      
+sage: A.basis()                                                                 
+[(1.00000000000000, 0.000000000000000), (0.000000000000000, 1.00000000000000)]
 ```
 
-Running this in a terminal shows what happens. In all cases, the "Just kidding" result should be returned. The generic morphism thing is from CombinatorialFreeModule_CartesianProduct:
-
-```
-sage: A = MyAlgebra(QQ,3)                                                                                                                                                    
-sage: B = MyAlgebra(QQ,2)                                                                                                                                                    
-sage: C = cartesian_product([A,B])                                                                                                                                           
-sage: C.cartesian_projection(0)                                                                                                                                              
-'Just kidding'
-sage: C.cartesian_projection(1)                                                                                                                                              
-Generic morphism:
-  From: Free module generated by Ring of integers modulo 3 over Rational Field (+) Free module generated by Ring of integers modulo 2 over Rational Field
-  To:   Free module generated by Ring of integers modulo 2 over Rational Field
-sage: C.cartesian_embedding(0)                                                                                                                                               
-'Just kidding'
-sage: C.cartesian_embedding(1)                                                                                                                                               
-Generic morphism:
-  From: Free module generated by Ring of integers modulo 2 over Rational Field
-  To:   Free module generated by Ring of integers modulo 3 over Rational Field (+) Free module generated by Ring of integers modulo 2 over Rational Field
-```
-
-I am opening this now so that I can add a stopgap in another ticket. Deleting the `@cached_method` decorators on the `CombinatorialFreeModule_CartesianProduct` methods fixes the problem, but obviously does not address the root cause.
+Since the superclass `basis()` method is called while initializing the subclass, it gets cached. Then later when we try to use the subclass method, the superclass method is what we get. Deleting the `@cached_method` decorators fixes the issue, but is not a good solution when the superclass method is expensive and the superclass is of independent use.
``````




---

archive/issue_events_429990.json:
```json
{
    "actor": "https://github.com/orlitzky",
    "created_at": "2021-03-01T03:07:33Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "title_is": "Cached methods of superclasses can overshadow subclass methods",
    "title_was": "Cached methods of Cartesian products act weird",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429990"
}
```



---

archive/issue_comments_504510.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nIt's really not that big of a deal. For a while I thought I wanted to stick as close to the CFM machinery as possible, but the basis index notation for a disjoint union gets out of hand when you start dealing with cartesian products of cartesian products. Having changed that, I have to redefine the cartesian embedding/projection methods anyway, because they expect the indices to be ordered pairs. And soon enough I've redefined the entire class.\n\nI still think there's a bug here, but my original report obscured the essence of it. I'm going to update the description with a simpler example.",
    "created_at": "2021-03-01T03:07:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504510",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:18" align="right">comment:18</div>

It's really not that big of a deal. For a while I thought I wanted to stick as close to the CFM machinery as possible, but the basis index notation for a disjoint union gets out of hand when you start dealing with cartesian products of cartesian products. Having changed that, I have to redefine the cartesian embedding/projection methods anyway, because they expect the indices to be ordered pairs. And soon enough I've redefined the entire class.

I still think there's a bug here, but my original report obscured the essence of it. I'm going to update the description with a simpler example.



---

archive/issue_events_429991.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-03-24T02:04:25Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429991"
}
```



---

archive/issue_events_429992.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-03-24T02:04:25Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429992"
}
```



---

archive/issue_comments_504511.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nSage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-24T02:04:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504511",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:19" align="right">comment:19</div>

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_429993.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:16:42Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429993"
}
```



---

archive/issue_events_429994.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:16:42Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429994"
}
```



---

archive/issue_comments_504512.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nThis is reported in #17201 and #21281, too. Using `@cached_method(name=...)` in the superclass to specify a different dict key does work; but if (as in my original report) the superclass is part of the sage library, then that's not an option.",
    "created_at": "2021-10-04T23:53:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31421#issuecomment-504512",
    "user": "https://github.com/orlitzky"
}
```

<div id="comment:21" align="right">comment:21</div>

This is reported in #17201 and #21281, too. Using `@cached_method(name=...)` in the superclass to specify a different dict key does work; but if (as in my original report) the superclass is part of the sage library, then that's not an option.



---

archive/issue_events_429995.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:11:26Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429995"
}
```



---

archive/issue_events_429996.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:11:26Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429996"
}
```



---

archive/issue_events_429997.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:17:06Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429997"
}
```



---

archive/issue_events_429998.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:17:06Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429998"
}
```



---

archive/issue_events_429999.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-429999"
}
```



---

archive/issue_events_430000.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31421",
    "milestone_number": null,
    "milestone_title": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31421#event-430000"
}
```
