# Issue 31236: Fix hashing of permutation group elements

archive/issues_030999.json:
```json
{
    "assignees": [],
    "body": "As noticed on [this sage-devel thread](https://groups.google.com/g/sage-devel/c/0Ca0m94lfOE) the hash function of `PermutationGroupElement` does not behave coherently with respect to the natural inclusions `SymmetricGroup(n) c SymmetricGroup(n+1)`.\n\nWe design a hash function:\n- whose value on the identity is 1\n- which does only depend on the support (ie ignores fixed points so that the hash is consistent with permutation restriction)\n- which is independent of the domain ordering\n\n**Branch:** [u/vdelecroix/31236](https://github.com/sagemath/sagetrac-mirror/tree/u/vdelecroix/31236)\n\n**Commit:** [e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552](https://github.com/sagemath/sagetrac-mirror/commit/e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552)\n\n**Reviewer:** Dima Pasechnik, \u200bDavid Roe\n\n**Author:** Vincent Delecroix\n\nIssue created by migration from https://trac.sagemath.org/ticket/31236\n\n",
    "created_at": "2021-01-14T12:01:07Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/component%3A%20group%20theory",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.8",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Fix hashing of permutation group elements",
    "type": "issue",
    "updated_at": "2022-09-19T18:58:47Z",
    "url": "https://github.com/sagemath/sage/issues/31236",
    "user": "https://github.com/videlec"
}
```
As noticed on [this sage-devel thread](https://groups.google.com/g/sage-devel/c/0Ca0m94lfOE) the hash function of `PermutationGroupElement` does not behave coherently with respect to the natural inclusions `SymmetricGroup(n) c SymmetricGroup(n+1)`.

We design a hash function:
- whose value on the identity is 1
- which does only depend on the support (ie ignores fixed points so that the hash is consistent with permutation restriction)
- which is independent of the domain ordering

**Branch:** [u/vdelecroix/31236](https://github.com/sagemath/sagetrac-mirror/tree/u/vdelecroix/31236)

**Commit:** [e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552](https://github.com/sagemath/sagetrac-mirror/commit/e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552)

**Reviewer:** Dima Pasechnik, ​David Roe

**Author:** Vincent Delecroix

Issue created by migration from https://trac.sagemath.org/ticket/31236





---

archive/issue_events_378654.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2021-01-14T12:01:07Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378654"
}
```



---

archive/issue_events_378655.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2021-01-14T12:01:07Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "008080",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378655"
}
```



---

archive/issue_comments_503303.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n-As noticed on [this sage-devel thread](https://groups.google.com/g/sage-devel/c/0Ca0m94lfOE) the hash function of `PermutationGroupElement` do not behave coherently with respect to the natural inclusions `SymmetricGroup(n) c SymmetricGroup(n+1)`.\n+As noticed on [this sage-devel thread](https://groups.google.com/g/sage-devel/c/0Ca0m94lfOE) the hash function of `PermutationGroupElement` does not behave coherently with respect to the natural inclusions `SymmetricGroup(n) c SymmetricGroup(n+1)`.\n \n We design a hash function:\n - whose value on the identity is 1\n``````\n",
    "created_at": "2021-01-14T12:01:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503303",
    "user": "https://github.com/videlec"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
-As noticed on [this sage-devel thread](https://groups.google.com/g/sage-devel/c/0Ca0m94lfOE) the hash function of `PermutationGroupElement` do not behave coherently with respect to the natural inclusions `SymmetricGroup(n) c SymmetricGroup(n+1)`.
+As noticed on [this sage-devel thread](https://groups.google.com/g/sage-devel/c/0Ca0m94lfOE) the hash function of `PermutationGroupElement` does not behave coherently with respect to the natural inclusions `SymmetricGroup(n) c SymmetricGroup(n+1)`.
 
 We design a hash function:
 - whose value on the identity is 1
``````




---

archive/issue_comments_503304.json:
```json
{
    "body": "<a id='comment:2'></a>\nGAP has a function `LargestMovedPoint()` for permutations, so instead of using `self.n`, where `n` is the degree of the permutation group, one can use this value to iterate over while computing the hash.\n\nWhile this does not ignore all the fixed points, this is still OK in terms of the consistency.",
    "created_at": "2021-01-14T12:24:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503304",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:2'></a>
GAP has a function `LargestMovedPoint()` for permutations, so instead of using `self.n`, where `n` is the degree of the permutation group, one can use this value to iterate over while computing the hash.

While this does not ignore all the fixed points, this is still OK in terms of the consistency.



---

archive/issue_events_378656.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2021-01-14T12:25:01Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20group%20theory",
    "label_color": "08517b",
    "label_name": "component: group theory",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378656"
}
```



---

archive/issue_comments_503305.json:
```json
{
    "body": "**Commit:** [462fdb1f2b903204041b6fc304ce2099aceae062](https://github.com/sagemath/sagetrac-mirror/commit/462fdb1f2b903204041b6fc304ce2099aceae062)",
    "created_at": "2021-01-14T12:41:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503305",
    "user": "https://github.com/videlec"
}
```

**Commit:** [462fdb1f2b903204041b6fc304ce2099aceae062](https://github.com/sagemath/sagetrac-mirror/commit/462fdb1f2b903204041b6fc304ce2099aceae062)



---

archive/issue_comments_503306.json:
```json
{
    "body": "**Branch:** [u/vdelecroix/31236](https://github.com/sagemath/sagetrac-mirror/tree/u/vdelecroix/31236)",
    "created_at": "2021-01-14T12:41:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503306",
    "user": "https://github.com/videlec"
}
```

**Branch:** [u/vdelecroix/31236](https://github.com/sagemath/sagetrac-mirror/tree/u/vdelecroix/31236)



---

archive/issue_comments_503307.json:
```json
{
    "body": "<a id='comment:4'></a>\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/462fdb1f2b903204041b6fc304ce2099aceae062\">462fdb1</a></td><td><code>31236: fix hash function of permutations</code></td></tr></table>\n",
    "created_at": "2021-01-14T12:41:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503307",
    "user": "https://github.com/videlec"
}
```

<a id='comment:4'></a>
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/462fdb1f2b903204041b6fc304ce2099aceae062">462fdb1</a></td><td><code>31236: fix hash function of permutations</code></td></tr></table>




---

archive/issue_events_378657.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2021-01-14T12:41:22Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "008080",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378657"
}
```



---

archive/issue_comments_503308.json:
```json
{
    "body": "<a id='comment:5'></a>\nWhat is `145623773L` doing there? \n\nAre you replacing something which looks to me as a perfect hash function (i.e. no collisions) with something that might have collisions?",
    "created_at": "2021-01-14T13:30:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503308",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:5'></a>
What is `145623773L` doing there? 

Are you replacing something which looks to me as a perfect hash function (i.e. no collisions) with something that might have collisions?



---

archive/issue_comments_503309.json:
```json
{
    "body": "<a id='comment:6'></a>\nIf you find a collision, I pay you a beer.",
    "created_at": "2021-01-14T13:40:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503309",
    "user": "https://github.com/videlec"
}
```

<a id='comment:6'></a>
If you find a collision, I pay you a beer.



---

archive/issue_comments_503310.json:
```json
{
    "body": "<a id='comment:7'></a>\nI asked a theory question.",
    "created_at": "2021-01-14T15:35:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503310",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:7'></a>
I asked a theory question.



---

archive/issue_comments_503311.json:
```json
{
    "body": "<a id='comment:8'></a>\n`145623773L` is an offset to ensure bit shuffling. See https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function (though I might not have used the best constants).",
    "created_at": "2021-01-14T16:25:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503311",
    "user": "https://github.com/videlec"
}
```

<a id='comment:8'></a>
`145623773L` is an offset to ensure bit shuffling. See https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function (though I might not have used the best constants).



---

archive/issue_comments_503312.json:
```json
{
    "body": "<a id='comment:9'></a>\nthanks. please add this info in the docs.",
    "created_at": "2021-01-14T16:42:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503312",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:9'></a>
thanks. please add this info in the docs.



---

archive/issue_comments_503313.json:
```json
{
    "body": "<a id='comment:10'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4\">ba9d62d</a></td><td><code>31326: reference for algorithm</code></td></tr></table>\n",
    "created_at": "2021-01-14T16:47:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503313",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:10'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4">ba9d62d</a></td><td><code>31326: reference for algorithm</code></td></tr></table>




---

archive/issue_comments_503314.json:
```json
{
    "body": "**Changing commit** from \"[462fdb1f2b903204041b6fc304ce2099aceae062](https://github.com/sagemath/sagetrac-mirror/commit/462fdb1f2b903204041b6fc304ce2099aceae062)\" to \"[ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4](https://github.com/sagemath/sagetrac-mirror/commit/ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4)\".",
    "created_at": "2021-01-14T16:47:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503314",
    "user": "https://github.com/sagetrac-git"
}
```

**Changing commit** from "[462fdb1f2b903204041b6fc304ce2099aceae062](https://github.com/sagemath/sagetrac-mirror/commit/462fdb1f2b903204041b6fc304ce2099aceae062)" to "[ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4](https://github.com/sagemath/sagetrac-mirror/commit/ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4)".



---

archive/issue_comments_503315.json:
```json
{
    "body": "<a id='comment:11'></a>\ndone",
    "created_at": "2021-01-14T16:47:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503315",
    "user": "https://github.com/videlec"
}
```

<a id='comment:11'></a>
done



---

archive/issue_comments_503316.json:
```json
{
    "body": "**Reviewer:** Dima Pasechnik",
    "created_at": "2021-01-16T22:09:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503316",
    "user": "https://github.com/dimpase"
}
```

**Reviewer:** Dima Pasechnik



---

archive/issue_comments_503317.json:
```json
{
    "body": "<a id='comment:12'></a>\nOK, looks good, thanks.",
    "created_at": "2021-01-16T22:09:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503317",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:12'></a>
OK, looks good, thanks.



---

archive/issue_events_378658.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2021-01-16T22:09:33Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "008080",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378658"
}
```



---

archive/issue_events_378659.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2021-01-16T22:09:33Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "008080",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378659"
}
```



---

archive/issue_events_378660.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2021-01-17T07:06:29Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "008080",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378660"
}
```



---

archive/issue_events_378661.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2021-01-17T07:06:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "008080",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378661"
}
```



---

archive/issue_comments_503318.json:
```json
{
    "body": "<a id='comment:13'></a>\n\n```\nsage: S1 = SymmetricGroup(FiniteEnumeratedSet([1,2,3]))\nsage: S2 = SymmetricGroup(FiniteEnumeratedSet([2,1,3]))\nsage: S1(\"(1,3,2)\") == S2(\"(1,3,2)\")\nTrue\nsage: hash(S1(\"(1,3,2)\")) == hash(S2(\"(1,3,2)\"))\nFalse\n```",
    "created_at": "2021-01-17T07:06:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503318",
    "user": "https://github.com/videlec"
}
```

<a id='comment:13'></a>

```
sage: S1 = SymmetricGroup(FiniteEnumeratedSet([1,2,3]))
sage: S2 = SymmetricGroup(FiniteEnumeratedSet([2,1,3]))
sage: S1("(1,3,2)") == S2("(1,3,2)")
True
sage: hash(S1("(1,3,2)")) == hash(S2("(1,3,2)"))
False
```



---

archive/issue_comments_503319.json:
```json
{
    "body": "<a id='comment:14'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3e2994829b5c1ce4ad74c1400015339498240c18\">3e29948</a></td><td><code>31326: change algorithm for consistency</code></td></tr></table>\n",
    "created_at": "2021-01-17T09:34:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503319",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:14'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3e2994829b5c1ce4ad74c1400015339498240c18">3e29948</a></td><td><code>31326: change algorithm for consistency</code></td></tr></table>




---

archive/issue_comments_503320.json:
```json
{
    "body": "**Changing commit** from \"[ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4](https://github.com/sagemath/sagetrac-mirror/commit/ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4)\" to \"[3e2994829b5c1ce4ad74c1400015339498240c18](https://github.com/sagemath/sagetrac-mirror/commit/3e2994829b5c1ce4ad74c1400015339498240c18)\".",
    "created_at": "2021-01-17T09:34:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503320",
    "user": "https://github.com/sagetrac-git"
}
```

**Changing commit** from "[ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4](https://github.com/sagemath/sagetrac-mirror/commit/ba9d62d7cdd8cf81f3e06d1399af8b0cb9d57bc4)" to "[3e2994829b5c1ce4ad74c1400015339498240c18](https://github.com/sagemath/sagetrac-mirror/commit/3e2994829b5c1ce4ad74c1400015339498240c18)".



---

archive/issue_comments_503321.json:
```json
{
    "body": "<a id='comment:15'></a>\nConsistent hashing with more tests.",
    "created_at": "2021-01-17T09:35:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503321",
    "user": "https://github.com/videlec"
}
```

<a id='comment:15'></a>
Consistent hashing with more tests.



---

archive/issue_events_378662.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2021-01-17T09:35:18Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "008080",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378662"
}
```



---

archive/issue_events_378663.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2021-01-17T09:35:18Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "008080",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378663"
}
```



---

archive/issue_comments_503322.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -2,4 +2,5 @@\n \n We design a hash function:\n - whose value on the identity is 1\n-- which does only depend on the support (ie ignores fixed points)\n+- which does only depend on the support (ie ignores fixed points so that the hash is consistent with permutation restriction)\n+- which is independent of the domain ordering\n``````\n",
    "created_at": "2021-01-17T09:36:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503322",
    "user": "https://github.com/videlec"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -2,4 +2,5 @@
 
 We design a hash function:
 - whose value on the identity is 1
-- which does only depend on the support (ie ignores fixed points)
+- which does only depend on the support (ie ignores fixed points so that the hash is consistent with permutation restriction)
+- which is independent of the domain ordering
``````




---

archive/issue_comments_503323.json:
```json
{
    "body": "<a id='comment:17'></a>\nCan't one do hashing based on the position in the lexicographically ordered set of all permutations?\n\nhttps://en.wikipedia.org/wiki/Factorial_number_system",
    "created_at": "2021-01-18T00:24:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503323",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:17'></a>
Can't one do hashing based on the position in the lexicographically ordered set of all permutations?

https://en.wikipedia.org/wiki/Factorial_number_system



---

archive/issue_comments_503324.json:
```json
{
    "body": "<a id='comment:18'></a>\nSee [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.",
    "created_at": "2021-01-18T10:46:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503324",
    "user": "https://github.com/videlec"
}
```

<a id='comment:18'></a>
See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.



---

archive/issue_comments_503325.json:
```json
{
    "body": "<a id='comment:19'></a>\nReplying to [@videlec](#comment%3A18):\n> See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.\n\nThis seems to be an entirely different issue - one can 1st canonise the permutation to the standard\ndomain [1..n], and only then compute hash.\n\n\n---\n\nHaving said this, it's in general a quite bad idea to ignore the nature of the group the element comes from, as it affects the performance of algorithms quite badly. Every permutation group G has a base, a minimal size set B  s.t. g_1(B)\\=g_2(B) as soon as g_1\\=g_2, and for transitive permutation groups this is in general the quickest test, and |B| is usually very small compared to the degree (it's even possible to quantify what \"usually\" means here - e.g. for primitive groups \nthis is governed by [O'Nan-Scott theorem](https://en.wikipedia.org/wiki/O%27Nan%E2%80%93Scott_theorem)).",
    "created_at": "2021-01-18T16:55:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503325",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:19'></a>
Replying to [@videlec](#comment%3A18):
> See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.

This seems to be an entirely different issue - one can 1st canonise the permutation to the standard
domain [1..n], and only then compute hash.


---

Having said this, it's in general a quite bad idea to ignore the nature of the group the element comes from, as it affects the performance of algorithms quite badly. Every permutation group G has a base, a minimal size set B  s.t. g_1(B)\=g_2(B) as soon as g_1\=g_2, and for transitive permutation groups this is in general the quickest test, and |B| is usually very small compared to the degree (it's even possible to quantify what "usually" means here - e.g. for primitive groups 
this is governed by [O'Nan-Scott theorem](https://en.wikipedia.org/wiki/O%27Nan%E2%80%93Scott_theorem)).



---

archive/issue_comments_503326.json:
```json
{
    "body": "<a id='comment:20'></a>\nReplying to [@dimpase](#comment%3A19):\n> Replying to [@videlec](#comment%3A18):\n> > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.\n\n> This seems to be an entirely different issue - one can 1st canonise the permutation to the standard\n> domain [1..n], and only then compute hash.\n\n \nHow do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?\n\n> ---\n> \n> Having said this, it's in general a quite bad idea to ignore the nature of the group the element comes from, as it affects the performance of algorithms quite badly. Every permutation group G has a base, a minimal size set B  s.t. g_1(B)\\=g_2(B) as soon as g_1\\=g_2, and for transitive permutation groups this is in general the quickest test, and |B| is usually very small compared to the degree (it's even possible to quantify what \"usually\" means here - e.g. for primitive groups \n> this is governed by [O'Nan-Scott theorem](https://en.wikipedia.org/wiki/O%27Nan%E2%80%93Scott_theorem)).\n\nWhy is this relevent for hashing?",
    "created_at": "2021-01-18T17:03:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503326",
    "user": "https://github.com/videlec"
}
```

<a id='comment:20'></a>
Replying to [@dimpase](#comment%3A19):
> Replying to [@videlec](#comment%3A18):
> > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.

> This seems to be an entirely different issue - one can 1st canonise the permutation to the standard
> domain [1..n], and only then compute hash.

 
How do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?

> ---
> 
> Having said this, it's in general a quite bad idea to ignore the nature of the group the element comes from, as it affects the performance of algorithms quite badly. Every permutation group G has a base, a minimal size set B  s.t. g_1(B)\=g_2(B) as soon as g_1\=g_2, and for transitive permutation groups this is in general the quickest test, and |B| is usually very small compared to the degree (it's even possible to quantify what "usually" means here - e.g. for primitive groups 
> this is governed by [O'Nan-Scott theorem](https://en.wikipedia.org/wiki/O%27Nan%E2%80%93Scott_theorem)).

Why is this relevent for hashing?



---

archive/issue_comments_503327.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [@videlec](#comment%3A20):\n> Replying to [@dimpase](#comment%3A19):\n> > Replying to [@videlec](#comment%3A18):\n> > > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.\n\n> > This seems to be an entirely different issue - one can 1st canonise the permutation to the standard\n> > domain [1..n], and only then compute hash.\n\n>  \n> How do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?\n\nBy their positions in the list, i.e. as `[1,2,3]`, why not?\n\n\n> \n> > \n> > ---\n> > \n> > Having said this, it's in general a quite bad idea to ignore the nature of the group the element comes from, as it affects the performance of algorithms quite badly. Every permutation group G has a base, a minimal size set B  s.t. g_1(B)\\=g_2(B) as soon as g_1\\=g_2, and for transitive permutation groups this is in general the quickest test, and |B| is usually very small compared to the degree (it's even possible to quantify what \"usually\" means here - e.g. for primitive groups \n> > this is governed by [O'Nan-Scott theorem](https://en.wikipedia.org/wiki/O%27Nan%E2%80%93Scott_theorem)).\n\n> \n> Why is this relevent for hashing?\n\nI am inclined to say that one should not hash permutation group elements ignoring their parent group. A workaround, to hash `Permutation(g)` rather than `g` itself, should work, though - although it does not, due to the usual sloppiness of `Permutation`.",
    "created_at": "2021-01-18T17:19:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503327",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:21'></a>
Replying to [@videlec](#comment%3A20):
> Replying to [@dimpase](#comment%3A19):
> > Replying to [@videlec](#comment%3A18):
> > > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.

> > This seems to be an entirely different issue - one can 1st canonise the permutation to the standard
> > domain [1..n], and only then compute hash.

>  
> How do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?

By their positions in the list, i.e. as `[1,2,3]`, why not?


> 
> > 
> > ---
> > 
> > Having said this, it's in general a quite bad idea to ignore the nature of the group the element comes from, as it affects the performance of algorithms quite badly. Every permutation group G has a base, a minimal size set B  s.t. g_1(B)\=g_2(B) as soon as g_1\=g_2, and for transitive permutation groups this is in general the quickest test, and |B| is usually very small compared to the degree (it's even possible to quantify what "usually" means here - e.g. for primitive groups 
> > this is governed by [O'Nan-Scott theorem](https://en.wikipedia.org/wiki/O%27Nan%E2%80%93Scott_theorem)).

> 
> Why is this relevent for hashing?

I am inclined to say that one should not hash permutation group elements ignoring their parent group. A workaround, to hash `Permutation(g)` rather than `g` itself, should work, though - although it does not, due to the usual sloppiness of `Permutation`.



---

archive/issue_comments_503328.json:
```json
{
    "body": "<a id='comment:22'></a>\nReplying to [@dimpase](#comment%3A21):\n> Replying to [@videlec](#comment%3A20):\n> > Replying to [@dimpase](#comment%3A19):\n> > > Replying to [@videlec](#comment%3A18):\n> > > > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.\n\n> > > This seems to be an entirely different issue - one can 1st canonise the permutation to the standard\n> > > domain [1..n], and only then compute hash.\n\n> >\n> > How do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?\n\n> By their positions in the list, i.e. as `[1,2,3]`, why not?\n\nBecause it won't work. If you do that with `[pi, 'a', Partition([3,2,1])]` and then `[Partition([3,2,1]), 'a', pi]` for the same permutation, let say the transposition `('a', pi)`, you will obtain two different permutations on `[1,2,3]` with different hashes.\n\nYou could also have read [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro): the order of the elements in the domain should not matter.",
    "created_at": "2021-01-18T17:30:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503328",
    "user": "https://github.com/videlec"
}
```

<a id='comment:22'></a>
Replying to [@dimpase](#comment%3A21):
> Replying to [@videlec](#comment%3A20):
> > Replying to [@dimpase](#comment%3A19):
> > > Replying to [@videlec](#comment%3A18):
> > > > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.

> > > This seems to be an entirely different issue - one can 1st canonise the permutation to the standard
> > > domain [1..n], and only then compute hash.

> >
> > How do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?

> By their positions in the list, i.e. as `[1,2,3]`, why not?

Because it won't work. If you do that with `[pi, 'a', Partition([3,2,1])]` and then `[Partition([3,2,1]), 'a', pi]` for the same permutation, let say the transposition `('a', pi)`, you will obtain two different permutations on `[1,2,3]` with different hashes.

You could also have read [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro): the order of the elements in the domain should not matter.



---

archive/issue_comments_503329.json:
```json
{
    "body": "<a id='comment:23'></a>\nIf you think you have a better way of implementing a hash function, please provide an alternative branch. As far as I tested my branch does solve the issue.",
    "created_at": "2021-01-18T17:31:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503329",
    "user": "https://github.com/videlec"
}
```

<a id='comment:23'></a>
If you think you have a better way of implementing a hash function, please provide an alternative branch. As far as I tested my branch does solve the issue.



---

archive/issue_comments_503330.json:
```json
{
    "body": "<a id='comment:24'></a>\nThere is no issue IMHO.\nIt's an over-zealous wish to mimic Python numeric tower to the point where it does not make sense any more.",
    "created_at": "2021-01-18T18:48:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503330",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:24'></a>
There is no issue IMHO.
It's an over-zealous wish to mimic Python numeric tower to the point where it does not make sense any more.



---

archive/issue_comments_503331.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [@videlec](#comment%3A22):\n> Replying to [@dimpase](#comment%3A21):\n> > Replying to [@videlec](#comment%3A20):\n> > > Replying to [@dimpase](#comment%3A19):\n> > > > Replying to [@videlec](#comment%3A18):\n> > > > > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.\n\n> > > > This seems to be an entirely different issue - one can 1st canonise the permutation to the standard\n> > > > domain [1..n], and only then compute hash.\n\n> > >\n> > > How do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?\n\n> > By their positions in the list, i.e. as `[1,2,3]`, why not?\n\n> \n> Because it won't work. If you do that with `[pi, 'a', Partition([3,2,1])]` and then `[Partition([3,2,1]), 'a', pi]` for the same permutation, let say the transposition `('a', pi)`, you will obtain two different permutations on `[1,2,3]` with different hashes.\n> \n> You could also have read [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro): the order of the elements in the domain should not matter.\n\nAnd this only reinforces my suspision that hashing permutations of different domains should return different answers.\nAs you just demonstrated, there is no canonical way to identify the transposition `('a',pi)` with `(1,2)`, why would the hashes be the same?",
    "created_at": "2021-01-18T18:51:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503331",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:25'></a>
Replying to [@videlec](#comment%3A22):
> Replying to [@dimpase](#comment%3A21):
> > Replying to [@videlec](#comment%3A20):
> > > Replying to [@dimpase](#comment%3A19):
> > > > Replying to [@videlec](#comment%3A18):
> > > > > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.

> > > > This seems to be an entirely different issue - one can 1st canonise the permutation to the standard
> > > > domain [1..n], and only then compute hash.

> > >
> > > How do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?

> > By their positions in the list, i.e. as `[1,2,3]`, why not?

> 
> Because it won't work. If you do that with `[pi, 'a', Partition([3,2,1])]` and then `[Partition([3,2,1]), 'a', pi]` for the same permutation, let say the transposition `('a', pi)`, you will obtain two different permutations on `[1,2,3]` with different hashes.
> 
> You could also have read [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro): the order of the elements in the domain should not matter.

And this only reinforces my suspision that hashing permutations of different domains should return different answers.
As you just demonstrated, there is no canonical way to identify the transposition `('a',pi)` with `(1,2)`, why would the hashes be the same?



---

archive/issue_comments_503332.json:
```json
{
    "body": "<a id='comment:26'></a>\nReplying to [@dimpase](#comment%3A25):\n> Replying to [@videlec](#comment%3A22):\n> > Replying to [@dimpase](#comment%3A21):\n> > > Replying to [@videlec](#comment%3A20):\n> > > > Replying to [@dimpase](#comment%3A19):\n> > > > > Replying to [@videlec](#comment%3A18):\n> > > > > > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.\n\n> > > > > This seems to be an entirely different issue - one can 1st canonise the permutation to the standard\n> > > > > domain [1..n], and only then compute hash.\n\n> > > >\n> > > > How do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?\n\n> > > By their positions in the list, i.e. as `[1,2,3]`, why not?\n\n> > \n> > Because it won't work. If you do that with `[pi, 'a', Partition([3,2,1])]` and then `[Partition([3,2,1]), 'a', pi]` for the same permutation, let say the transposition `('a', pi)`, you will obtain two different permutations on `[1,2,3]` with different hashes.\n> > \n> > You could also have read [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro): the order of the elements in the domain should not matter.\n\n> \n> And this only reinforces my suspision that hashing permutations of different domains should return different answers.\n\nThere is a canonical map from the domain `{1,2}` to the domain `{1,2,3}`. Hence the transposition `(1,2)` on both sets should just be equal. It is trivial to implement a compatible hash function. This is what this ticket is about.\n\n> As you just demonstrated, there is no canonical way to identify the transposition `('a',pi)` with `(1,2)`, why would the hashes be the same?\n\nThe hashes are different.",
    "created_at": "2021-01-18T18:57:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503332",
    "user": "https://github.com/videlec"
}
```

<a id='comment:26'></a>
Replying to [@dimpase](#comment%3A25):
> Replying to [@videlec](#comment%3A22):
> > Replying to [@dimpase](#comment%3A21):
> > > Replying to [@videlec](#comment%3A20):
> > > > Replying to [@dimpase](#comment%3A19):
> > > > > Replying to [@videlec](#comment%3A18):
> > > > > > See [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro) for why this will not work.

> > > > > This seems to be an entirely different issue - one can 1st canonise the permutation to the standard
> > > > > domain [1..n], and only then compute hash.

> > > >
> > > > How do you canonise `[pi, 'a', Partition([3,2,1])]` to `[1, 2, 3]`?

> > > By their positions in the list, i.e. as `[1,2,3]`, why not?

> > 
> > Because it won't work. If you do that with `[pi, 'a', Partition([3,2,1])]` and then `[Partition([3,2,1]), 'a', pi]` for the same permutation, let say the transposition `('a', pi)`, you will obtain two different permutations on `[1,2,3]` with different hashes.
> > 
> > You could also have read [This is the Trac macro *comment:13* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:13-macro): the order of the elements in the domain should not matter.

> 
> And this only reinforces my suspision that hashing permutations of different domains should return different answers.

There is a canonical map from the domain `{1,2}` to the domain `{1,2,3}`. Hence the transposition `(1,2)` on both sets should just be equal. It is trivial to implement a compatible hash function. This is what this ticket is about.

> As you just demonstrated, there is no canonical way to identify the transposition `('a',pi)` with `(1,2)`, why would the hashes be the same?

The hashes are different.



---

archive/issue_comments_503333.json:
```json
{
    "body": "<a id='comment:27'></a>\nIt seems like you have incompatible goals for a hash function.\n\n* It should be as fast as possible to compute for elements of a fixed permutation group.  Dima's suggestion about the base is an interesting idea for a way to compute hashes by only considering a few elements.  But it's clearly not going to be consistent across subgroup relations (including `S_n c S_{n+1}` considered here), and it requires a precomputation for each permutation group (the base).\n* It should depend only on the permutation, not the group.  Yes, there are other parts of Sage where hashing and equality testing are incompatible\n\n```\nsage: mod(1,3) == -2                                                                                                                                                                                                                         \nTrue\nsage: hash(mod(1,3)) == hash(-2)                                                                                                                                                                                                             \nFalse\n```\nbut this compatibility is still a desirable feature of a hash function.\n\nVincent's solution seems like a pretty good way to achieve the second goal.  Dima, if you'd like to argue that we should drop compatibility of hash functions across different permutation groups in the interest of speed, I think that discussion should be taken back to the sage-devel thread.\n\nI wonder if it's reasonable to have a \"hash mode\" option for parents where a user can indicate that they want hashes to be as fast as possible, dropping compatibility across parents.  Maybe this could disable implicit coercions and require explicit conversions?",
    "created_at": "2021-01-19T22:03:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503333",
    "user": "https://github.com/roed314"
}
```

<a id='comment:27'></a>
It seems like you have incompatible goals for a hash function.

* It should be as fast as possible to compute for elements of a fixed permutation group.  Dima's suggestion about the base is an interesting idea for a way to compute hashes by only considering a few elements.  But it's clearly not going to be consistent across subgroup relations (including `S_n c S_{n+1}` considered here), and it requires a precomputation for each permutation group (the base).
* It should depend only on the permutation, not the group.  Yes, there are other parts of Sage where hashing and equality testing are incompatible

```
sage: mod(1,3) == -2                                                                                                                                                                                                                         
True
sage: hash(mod(1,3)) == hash(-2)                                                                                                                                                                                                             
False
```
but this compatibility is still a desirable feature of a hash function.

Vincent's solution seems like a pretty good way to achieve the second goal.  Dima, if you'd like to argue that we should drop compatibility of hash functions across different permutation groups in the interest of speed, I think that discussion should be taken back to the sage-devel thread.

I wonder if it's reasonable to have a "hash mode" option for parents where a user can indicate that they want hashes to be as fast as possible, dropping compatibility across parents.  Maybe this could disable implicit coercions and require explicit conversions?



---

archive/issue_comments_503334.json:
```json
{
    "body": "<a id='comment:28'></a>\nReplying to [@roed314](#comment%3A27):\n> It seems like you have incompatible goals for a hash function.\n> \n> <SNIP>\n\n>\n\nThanks for your input. The branch I provided is a bit slower than the previous code in case the domain is the standard one, ie `{1, 2, ..., n}`\n\n```\nsage: S = SymmetricGroup(10)\nsage: %timeit -r5 for s in S: h = hash(s)\n1.02 s \u00b1 24.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) # old version\n1.32 s \u00b1 11.3 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each) # new version\n```\nThe time difference is plausibly due to the extra call `P._has_natural_domain()` which is here repeated 10 factorial times. I do not have any idea to improve the timing without Cythonizing the parent.\n\nAs expected the code is significatively slower in case the domain is non standard\n\n```\nsage: S = SymmetricGroup(['a','b','c','d','e','f','g','h','i'])\nsage: %timeit -r5 for s in S: h = hash(s)\n109 ms \u00b1 511 \u00b5s per loop (mean \u00b1 std. dev. of 5 runs, 10 loops each) # old version\n3.56 s \u00b1 4.19 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each) # new version\n```\nIf the latter is a problem, it is possible to store the hashes of elements in the domain in a C array inside the parent. Should I do that?",
    "created_at": "2021-01-19T22:24:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503334",
    "user": "https://github.com/videlec"
}
```

<a id='comment:28'></a>
Replying to [@roed314](#comment%3A27):
> It seems like you have incompatible goals for a hash function.
> 
> <SNIP>

>

Thanks for your input. The branch I provided is a bit slower than the previous code in case the domain is the standard one, ie `{1, 2, ..., n}`

```
sage: S = SymmetricGroup(10)
sage: %timeit -r5 for s in S: h = hash(s)
1.02 s ± 24.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) # old version
1.32 s ± 11.3 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) # new version
```
The time difference is plausibly due to the extra call `P._has_natural_domain()` which is here repeated 10 factorial times. I do not have any idea to improve the timing without Cythonizing the parent.

As expected the code is significatively slower in case the domain is non standard

```
sage: S = SymmetricGroup(['a','b','c','d','e','f','g','h','i'])
sage: %timeit -r5 for s in S: h = hash(s)
109 ms ± 511 µs per loop (mean ± std. dev. of 5 runs, 10 loops each) # old version
3.56 s ± 4.19 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) # new version
```
If the latter is a problem, it is possible to store the hashes of elements in the domain in a C array inside the parent. Should I do that?



---

archive/issue_comments_503335.json:
```json
{
    "body": "<a id='comment:29'></a>\nPermutationGroupElement hashes have to be compatible w.r.t. to subgroups of this group (and, by the way, using images of the base - which gets computed as soon as almost any kind of nontrivial computation has to be done - to compute the hash is obviously good here), but I fail to understand why this would be desirable for groups with different domains, and to me domains (1,2,3) and (2,1,3) are different, as different as (1,2,3) and (7,8,9).",
    "created_at": "2021-01-19T22:57:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503335",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:29'></a>
PermutationGroupElement hashes have to be compatible w.r.t. to subgroups of this group (and, by the way, using images of the base - which gets computed as soon as almost any kind of nontrivial computation has to be done - to compute the hash is obviously good here), but I fail to understand why this would be desirable for groups with different domains, and to me domains (1,2,3) and (2,1,3) are different, as different as (1,2,3) and (7,8,9).



---

archive/issue_comments_503336.json:
```json
{
    "body": "<a id='comment:30'></a>\nReplying to [@videlec](#comment%3A28):\n> \n> Thanks for your input. The branch I provided is a bit slower than the previous code in case the domain is the standard one, ie `{1, 2, ..., n}`\n> \n> ```\n> sage: S = SymmetricGroup(10)\n> sage: %timeit -r5 for s in S: h = hash(s)\n> 1.02 s \u00b1 24.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) # old version\n> 1.32 s \u00b1 11.3 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each) # new version\n> ```\n> The time difference is plausibly due to the extra call `P._has_natural_domain()` which is here repeated 10 factorial times. I do not have any idea to improve the timing without Cythonizing the parent.\n\nSince `_has_natural_domain` is cached, it would surprise me a bit if this was the bottleneck.  Maybe try running your code again with that just set to `True`?  I would suspect that the inside of the for loop is just more complicated, yielding a 30% slowdown.  Obviously we'd prefer not to have a slowdown, but I think 30% is acceptable in order to fix the bug.\n\n> As expected the code is significatively slower in case the domain is non standard\n> \n> ```\n> sage: S = SymmetricGroup(['a','b','c','d','e','f','g','h','i'])\n> sage: %timeit -r5 for s in S: h = hash(s)\n> 109 ms \u00b1 511 \u00b5s per loop (mean \u00b1 std. dev. of 5 runs, 10 loops each) # old version\n> 3.56 s \u00b1 4.19 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each) # new version\n> ```\n> If the latter is a problem, it is possible to store the hashes of elements in the domain in a C array inside the parent. Should I do that?\n\nSince the parent isn't Cythonized, where would that array go?  I think speeding up this case would be worthwhile, and recording the domain's hashes seems like a good way to do it.\n\nThe speed comparison I was thinking about, though, wasn't either of these.  Instead, I think Dima was suggesting that we can make a much faster hash function than the current one in the case where `n` is large.  I think speeding things up for large `n` is worthwhile, but there are plenty of cases where Sage is pretty bad.  I think the hash code is fine in comparison:\n\n```\nsage: S = SymmetricGroup(2000)\nsage: %timeit a = S.random_element()\n639 ms \u00b1 15.3 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n\nsage: S = SymmetricGroup(10^8)\nsage: %time hash(a)                                                                                                                                                                                                                          \nCPU times: user 120 ms, sys: 350 \u00b5s, total: 120 ms\nWall time: 120 ms\n```",
    "created_at": "2021-01-19T23:04:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503336",
    "user": "https://github.com/roed314"
}
```

<a id='comment:30'></a>
Replying to [@videlec](#comment%3A28):
> 
> Thanks for your input. The branch I provided is a bit slower than the previous code in case the domain is the standard one, ie `{1, 2, ..., n}`
> 
> ```
> sage: S = SymmetricGroup(10)
> sage: %timeit -r5 for s in S: h = hash(s)
> 1.02 s ± 24.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) # old version
> 1.32 s ± 11.3 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) # new version
> ```
> The time difference is plausibly due to the extra call `P._has_natural_domain()` which is here repeated 10 factorial times. I do not have any idea to improve the timing without Cythonizing the parent.

Since `_has_natural_domain` is cached, it would surprise me a bit if this was the bottleneck.  Maybe try running your code again with that just set to `True`?  I would suspect that the inside of the for loop is just more complicated, yielding a 30% slowdown.  Obviously we'd prefer not to have a slowdown, but I think 30% is acceptable in order to fix the bug.

> As expected the code is significatively slower in case the domain is non standard
> 
> ```
> sage: S = SymmetricGroup(['a','b','c','d','e','f','g','h','i'])
> sage: %timeit -r5 for s in S: h = hash(s)
> 109 ms ± 511 µs per loop (mean ± std. dev. of 5 runs, 10 loops each) # old version
> 3.56 s ± 4.19 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) # new version
> ```
> If the latter is a problem, it is possible to store the hashes of elements in the domain in a C array inside the parent. Should I do that?

Since the parent isn't Cythonized, where would that array go?  I think speeding up this case would be worthwhile, and recording the domain's hashes seems like a good way to do it.

The speed comparison I was thinking about, though, wasn't either of these.  Instead, I think Dima was suggesting that we can make a much faster hash function than the current one in the case where `n` is large.  I think speeding things up for large `n` is worthwhile, but there are plenty of cases where Sage is pretty bad.  I think the hash code is fine in comparison:

```
sage: S = SymmetricGroup(2000)
sage: %timeit a = S.random_element()
639 ms ± 15.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

sage: S = SymmetricGroup(10^8)
sage: %time hash(a)                                                                                                                                                                                                                          
CPU times: user 120 ms, sys: 350 µs, total: 120 ms
Wall time: 120 ms
```



---

archive/issue_comments_503337.json:
```json
{
    "body": "<a id='comment:31'></a>\nReplying to [@dimpase](#comment%3A29):\n> PermutationGroupElement hashes have to be compatible w.r.t. to subgroups of this group (and, by the way, using images of the base - which gets computed as soon as almost any kind of nontrivial computation has to be done - to compute the hash is obviously good here), but I fail to understand why this would be desirable for groups with different domains, and to me domains (1,2,3) and (2,1,3) are different, as different as (1,2,3) and (7,8,9).\n\nI agree that they are different, but Sage currently allows equality testing between them:\n\n```\nsage: S = SymmetricGroup([1,2,3])                                                                                                                                                                                                            \nsage: T = SymmetricGroup([2,3,1])                                                                                                                                                                                                            \nsage: S('(2,1)')                                                                                                                                                                                                                             \n(1,2)\nsage: T('(2,1)')                                                                                                                                                                                                                             \n(2,1)\nsage: T('(2,1)') == S('(2,1)')                                                                                                                                                                                                               \nTrue\n```\nI wouldn't object to prohibiting a coercion map between these parents (as you say, the domains are different since permutations are all about the ordering of domain, not just the labels), but I'd say that should also be discussed more broadly.",
    "created_at": "2021-01-19T23:11:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503337",
    "user": "https://github.com/roed314"
}
```

<a id='comment:31'></a>
Replying to [@dimpase](#comment%3A29):
> PermutationGroupElement hashes have to be compatible w.r.t. to subgroups of this group (and, by the way, using images of the base - which gets computed as soon as almost any kind of nontrivial computation has to be done - to compute the hash is obviously good here), but I fail to understand why this would be desirable for groups with different domains, and to me domains (1,2,3) and (2,1,3) are different, as different as (1,2,3) and (7,8,9).

I agree that they are different, but Sage currently allows equality testing between them:

```
sage: S = SymmetricGroup([1,2,3])                                                                                                                                                                                                            
sage: T = SymmetricGroup([2,3,1])                                                                                                                                                                                                            
sage: S('(2,1)')                                                                                                                                                                                                                             
(1,2)
sage: T('(2,1)')                                                                                                                                                                                                                             
(2,1)
sage: T('(2,1)') == S('(2,1)')                                                                                                                                                                                                               
True
```
I wouldn't object to prohibiting a coercion map between these parents (as you say, the domains are different since permutations are all about the ordering of domain, not just the labels), but I'd say that should also be discussed more broadly.



---

archive/issue_comments_503338.json:
```json
{
    "body": "<a id='comment:32'></a>\nReplying to [@roed314](#comment%3A30):\n> Replying to [@videlec](#comment%3A28):\n> > \n> > Thanks for your input. The branch I provided is a bit slower than the previous code in case the domain is the standard one, ie `{1, 2, ..., n}`\n> > \n> > ```\n> > sage: S = SymmetricGroup(10)\n> > sage: %timeit -r5 for s in S: h = hash(s)\n> > 1.02 s \u00b1 24.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) # old version\n> > 1.32 s \u00b1 11.3 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each) # new version\n> > ```\n> > The time difference is plausibly due to the extra call `P._has_natural_domain()` which is here repeated 10 factorial times. I do not have any idea to improve the timing without Cythonizing the parent.\n\n> \n> Since `_has_natural_domain` is cached, it would surprise me a bit if this was the bottleneck.  Maybe try running your code again with that just set to `True`?\n\n```\nsage: %timeit -r5 for s in S: h = hash(s) # new code without _has_natural_domain call\n1.09 s \u00b1 18.3 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each)\n```",
    "created_at": "2021-01-20T08:16:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503338",
    "user": "https://github.com/videlec"
}
```

<a id='comment:32'></a>
Replying to [@roed314](#comment%3A30):
> Replying to [@videlec](#comment%3A28):
> > 
> > Thanks for your input. The branch I provided is a bit slower than the previous code in case the domain is the standard one, ie `{1, 2, ..., n}`
> > 
> > ```
> > sage: S = SymmetricGroup(10)
> > sage: %timeit -r5 for s in S: h = hash(s)
> > 1.02 s ± 24.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) # old version
> > 1.32 s ± 11.3 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) # new version
> > ```
> > The time difference is plausibly due to the extra call `P._has_natural_domain()` which is here repeated 10 factorial times. I do not have any idea to improve the timing without Cythonizing the parent.

> 
> Since `_has_natural_domain` is cached, it would surprise me a bit if this was the bottleneck.  Maybe try running your code again with that just set to `True`?

```
sage: %timeit -r5 for s in S: h = hash(s) # new code without _has_natural_domain call
1.09 s ± 18.3 ms per loop (mean ± std. dev. of 5 runs, 1 loop each)
```



---

archive/issue_comments_503339.json:
```json
{
    "body": "<a id='comment:33'></a>\nI guess I was wrong.  I also don't see an easy way to make this faster.",
    "created_at": "2021-01-20T12:07:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503339",
    "user": "https://github.com/roed314"
}
```

<a id='comment:33'></a>
I guess I was wrong.  I also don't see an easy way to make this faster.



---

archive/issue_comments_503340.json:
```json
{
    "body": "<a id='comment:34'></a>\nReplying to [@roed314](#comment%3A30):\n> Replying to [@videlec](#comment%3A28):\n> > As expected the code is significatively slower in case the domain is non standard\n> > \n> > ```\n> > sage: S = SymmetricGroup(['a','b','c','d','e','f','g','h','i'])\n> > sage: %timeit -r5 for s in S: h = hash(s)\n> > 109 ms \u00b1 511 \u00b5s per loop (mean \u00b1 std. dev. of 5 runs, 10 loops each) # old version\n> > 3.56 s \u00b1 4.19 ms per loop (mean \u00b1 std. dev. of 5 runs, 1 loop each) # new version\n> > ```\n> > If the latter is a problem, it is possible to store the hashes of elements in the domain in a C array inside the parent. Should I do that?\n\n> \n> Since the parent isn't Cythonized, where would that array go?  I think speeding up this case would be worthwhile, and recording the domain's hashes seems like a good way to do it.\n\nThere is the [Python array object](https://docs.python.org/3/library/array.html) that can store whatever C data you want. We will still suffer from the attribute access to the Python parent. But it will not be a factor x30 as it is currently",
    "created_at": "2021-01-20T13:53:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503340",
    "user": "https://github.com/videlec"
}
```

<a id='comment:34'></a>
Replying to [@roed314](#comment%3A30):
> Replying to [@videlec](#comment%3A28):
> > As expected the code is significatively slower in case the domain is non standard
> > 
> > ```
> > sage: S = SymmetricGroup(['a','b','c','d','e','f','g','h','i'])
> > sage: %timeit -r5 for s in S: h = hash(s)
> > 109 ms ± 511 µs per loop (mean ± std. dev. of 5 runs, 10 loops each) # old version
> > 3.56 s ± 4.19 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) # new version
> > ```
> > If the latter is a problem, it is possible to store the hashes of elements in the domain in a C array inside the parent. Should I do that?

> 
> Since the parent isn't Cythonized, where would that array go?  I think speeding up this case would be worthwhile, and recording the domain's hashes seems like a good way to do it.

There is the [Python array object](https://docs.python.org/3/library/array.html) that can store whatever C data you want. We will still suffer from the attribute access to the Python parent. But it will not be a factor x30 as it is currently



---

archive/issue_comments_503341.json:
```json
{
    "body": "**Changing commit** from \"[3e2994829b5c1ce4ad74c1400015339498240c18](https://github.com/sagemath/sagetrac-mirror/commit/3e2994829b5c1ce4ad74c1400015339498240c18)\" to \"[e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552](https://github.com/sagemath/sagetrac-mirror/commit/e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552)\".",
    "created_at": "2021-01-20T14:22:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503341",
    "user": "https://github.com/sagetrac-git"
}
```

**Changing commit** from "[3e2994829b5c1ce4ad74c1400015339498240c18](https://github.com/sagemath/sagetrac-mirror/commit/3e2994829b5c1ce4ad74c1400015339498240c18)" to "[e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552](https://github.com/sagemath/sagetrac-mirror/commit/e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552)".



---

archive/issue_comments_503342.json:
```json
{
    "body": "<a id='comment:35'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552\">e2e4d1d</a></td><td><code>31236: use a hash array for non standard domains</code></td></tr></table>\n",
    "created_at": "2021-01-20T14:22:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503342",
    "user": "https://github.com/sagetrac-git"
}
```

<a id='comment:35'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e2e4d1d7fdcf87355af69f46e8d90e7e1e69a552">e2e4d1d</a></td><td><code>31236: use a hash array for non standard domains</code></td></tr></table>




---

archive/issue_comments_503343.json:
```json
{
    "body": "<a id='comment:36'></a>\nBetter now\n\n```\nsage: S = SymmetricGroup(['a','b','c','d','e','f','g','h','i'])\nsage: %timeit -r5 for s in S: h = hash(s)\n159 ms \u00b1 1.17 ms per loop (mean \u00b1 std. dev. of 5 runs, 10 loops each)\n```\nComputing a single hash of an element triggers the creation of an array in the parent\n\n```\nsage: S._domain_hash_array\narray('l', [-5034579376873000338, 5819885834672024805, -1342306816048582247, 4154873981948319473, -9080196639829811986, 3487762170233258304, -4059262801740968994, -1410151844174446032, -7454342532774124322])\n```\nThis solution is not ideal as the hash array could be made available on the domain itself and not on the symmetric group. It could end up with many duplications of this array (ie when constructing subgroups).",
    "created_at": "2021-01-20T14:25:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503343",
    "user": "https://github.com/videlec"
}
```

<a id='comment:36'></a>
Better now

```
sage: S = SymmetricGroup(['a','b','c','d','e','f','g','h','i'])
sage: %timeit -r5 for s in S: h = hash(s)
159 ms ± 1.17 ms per loop (mean ± std. dev. of 5 runs, 10 loops each)
```
Computing a single hash of an element triggers the creation of an array in the parent

```
sage: S._domain_hash_array
array('l', [-5034579376873000338, 5819885834672024805, -1342306816048582247, 4154873981948319473, -9080196639829811986, 3487762170233258304, -4059262801740968994, -1410151844174446032, -7454342532774124322])
```
This solution is not ideal as the hash array could be made available on the domain itself and not on the symmetric group. It could end up with many duplications of this array (ie when constructing subgroups).



---

archive/issue_comments_503344.json:
```json
{
    "body": "<a id='comment:37'></a>\nSee #31269",
    "created_at": "2021-01-20T14:58:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503344",
    "user": "https://github.com/videlec"
}
```

<a id='comment:37'></a>
See #31269



---

archive/issue_comments_503345.json:
```json
{
    "body": "<a id='comment:38'></a>\nping",
    "created_at": "2021-01-29T07:49:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503345",
    "user": "https://github.com/videlec"
}
```

<a id='comment:38'></a>
ping



---

archive/issue_comments_503346.json:
```json
{
    "body": "<a id='comment:39'></a>\nI'm happy giving this ticket positive review.  Since Dima originally reviewed it, I'll give him a couple days to respond with an objection and suggestions for how he'd like to proceed.",
    "created_at": "2021-02-08T08:36:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503346",
    "user": "https://github.com/roed314"
}
```

<a id='comment:39'></a>
I'm happy giving this ticket positive review.  Since Dima originally reviewed it, I'll give him a couple days to respond with an objection and suggestions for how he'd like to proceed.



---

archive/issue_comments_503347.json:
```json
{
    "body": "**Changing reviewer** from \"Dima Pasechnik\" to \"Dima Pasechnik, \u200bDavid Roe\".",
    "created_at": "2021-02-08T08:48:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503347",
    "user": "https://github.com/videlec"
}
```

**Changing reviewer** from "Dima Pasechnik" to "Dima Pasechnik, ​David Roe".



---

archive/issue_comments_503348.json:
```json
{
    "body": "<a id='comment:41'></a>\nMy objection is only on the level of documentation. Where the hell these huge constants come from, and why? It's totally unclear.",
    "created_at": "2021-02-08T10:06:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503348",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:41'></a>
My objection is only on the level of documentation. Where the hell these huge constants come from, and why? It's totally unclear.



---

archive/issue_comments_503349.json:
```json
{
    "body": "<a id='comment:42'></a>\nAs their names indicate `mult1`, `mult2` are multipliers (for bit shuffling) and `mask1`, `mask2` are masks so that the hasing of the pair `(i, j)` is non commutative (ie different from the hash of `(j, i)`). These numbers are not big, they are 64 bit integers.",
    "created_at": "2021-02-08T12:09:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503349",
    "user": "https://github.com/videlec"
}
```

<a id='comment:42'></a>
As their names indicate `mult1`, `mult2` are multipliers (for bit shuffling) and `mask1`, `mask2` are masks so that the hasing of the pair `(i, j)` is non commutative (ie different from the hash of `(j, i)`). These numbers are not big, they are 64 bit integers.



---

archive/issue_comments_503350.json:
```json
{
    "body": "<a id='comment:43'></a>\nping",
    "created_at": "2021-02-17T15:28:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503350",
    "user": "https://github.com/videlec"
}
```

<a id='comment:43'></a>
ping



---

archive/issue_comments_503351.json:
```json
{
    "body": "<a id='comment:44'></a>\nSorry, I've been busy.  This looks good to me.",
    "created_at": "2021-03-04T19:26:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503351",
    "user": "https://github.com/roed314"
}
```

<a id='comment:44'></a>
Sorry, I've been busy.  This looks good to me.



---

archive/issue_events_378664.json:
```json
{
    "actor": "https://github.com/roed314",
    "created_at": "2021-03-04T19:26:30Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "008080",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378664"
}
```



---

archive/issue_events_378665.json:
```json
{
    "actor": "https://github.com/roed314",
    "created_at": "2021-03-04T19:26:30Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "008080",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378665"
}
```



---

archive/issue_events_378666.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-03-08T23:53:59Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "008080",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378666"
}
```



---

archive/issue_events_378667.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-03-08T23:53:59Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "008080",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378667"
}
```



---

archive/issue_comments_503352.json:
```json
{
    "body": "<a id='comment:45'></a>\nI got this on Ubuntu 18.04 32 bit\n\n```\n**********************************************************************\nFile \"src/sage/groups/perm_gps/permgroup_element.pyx\", line 1485, in sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__\nFailed example:\n    for n in range(1, 10):\n       G = SymmetricGroup(n)\n       assert hash(G.one()) == 1\n       assert len(set(map(hash, G))) == factorial(n)\nException raised:\n    Traceback (most recent call last):\n      File \"/var/lib/buildbot/slave/sage_git/build/local/lib/python3.9/site-packages/sage/doctest/forker.py\", line 714, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/var/lib/buildbot/slave/sage_git/build/local/lib/python3.9/site-packages/sage/doctest/forker.py\", line 1133, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__[3]>\", line 4, in <module>\n        assert len(set(map(hash, G))) == factorial(n)\n    AssertionError\n**********************************************************************\nFile \"src/sage/groups/perm_gps/permgroup_element.pyx\", line 1493, in sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__\nFailed example:\n    assert len(set(map(hash, A))) == A.cardinality()\nException raised:\n    Traceback (most recent call last):\n      File \"/var/lib/buildbot/slave/sage_git/build/local/lib/python3.9/site-packages/sage/doctest/forker.py\", line 714, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/var/lib/buildbot/slave/sage_git/build/local/lib/python3.9/site-packages/sage/doctest/forker.py\", line 1133, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__[7]>\", line 1, in <module>\n        assert len(set(map(hash, A))) == A.cardinality()\n    AssertionError\n**********************************************************************\n1 item had failures:\n   2 of  35 in sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__\n    [426 tests, 2 failures, 3.64 s]\n\n```\nas a general bit of advice, consider using `assert condition, message` so you learn whats wrong from tracebacks...",
    "created_at": "2021-03-08T23:53:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503352",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:45'></a>
I got this on Ubuntu 18.04 32 bit

```
**********************************************************************
File "src/sage/groups/perm_gps/permgroup_element.pyx", line 1485, in sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__
Failed example:
    for n in range(1, 10):
       G = SymmetricGroup(n)
       assert hash(G.one()) == 1
       assert len(set(map(hash, G))) == factorial(n)
Exception raised:
    Traceback (most recent call last):
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.9/site-packages/sage/doctest/forker.py", line 714, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.9/site-packages/sage/doctest/forker.py", line 1133, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__[3]>", line 4, in <module>
        assert len(set(map(hash, G))) == factorial(n)
    AssertionError
**********************************************************************
File "src/sage/groups/perm_gps/permgroup_element.pyx", line 1493, in sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__
Failed example:
    assert len(set(map(hash, A))) == A.cardinality()
Exception raised:
    Traceback (most recent call last):
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.9/site-packages/sage/doctest/forker.py", line 714, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/var/lib/buildbot/slave/sage_git/build/local/lib/python3.9/site-packages/sage/doctest/forker.py", line 1133, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__[7]>", line 1, in <module>
        assert len(set(map(hash, A))) == A.cardinality()
    AssertionError
**********************************************************************
1 item had failures:
   2 of  35 in sage.groups.perm_gps.permgroup_element.PermutationGroupElement.__hash__
    [426 tests, 2 failures, 3.64 s]

```
as a general bit of advice, consider using `assert condition, message` so you learn whats wrong from tracebacks...



---

archive/issue_events_378668.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-04-02T20:21:54Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378668"
}
```



---

archive/issue_events_378669.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-04-02T20:21:54Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378669"
}
```



---

archive/issue_comments_503353.json:
```json
{
    "body": "<a id='comment:46'></a>\nMoving this ticket to 9.4, as it seems unlikely that it will be merged in 9.3, which is in the release candidate stage",
    "created_at": "2021-04-02T20:21:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503353",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:46'></a>
Moving this ticket to 9.4, as it seems unlikely that it will be merged in 9.3, which is in the release candidate stage



---

archive/issue_events_378670.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T00:44:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378670"
}
```



---

archive/issue_events_378671.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T00:44:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378671"
}
```



---

archive/issue_comments_503354.json:
```json
{
    "body": "<a id='comment:47'></a>\nSetting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/31236#issuecomment-503354",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:47'></a>
Setting a new milestone for this ticket based on a cursory review.



---

archive/issue_events_378672.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378672"
}
```



---

archive/issue_events_378673.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378673"
}
```



---

archive/issue_events_378674.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:19:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378674"
}
```



---

archive/issue_events_378675.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:19:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378675"
}
```



---

archive/issue_events_378676.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378676"
}
```



---

archive/issue_events_378677.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/31236",
    "milestone_number": null,
    "milestone_title": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/31236#event-378677"
}
```
