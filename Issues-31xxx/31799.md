# Issue 31799: From CombinatorialPolyhedron and H-representation to Polyhedron (with double description)

archive/issues_031562.json:
```json
{
    "body": "CC:  @kliem @yuan-zhou @jplab\n\nGiven an (abstract) `CombinatorialPolyhedron` such that **at least one** of H-representation and V-representation are labeled geometrically, the new method `CombinatorialPolyhedron.as_polyhedron` constructs a geometric polyhedron.\n\nIf `check=True` (default), it checks that the result is OK.\n\nWe should be able to efficiently build a polyhedron, avoiding to run the double description method when setting up the polyhedron, for the backends that accept double description input:\n- if both representations are geometric, just pass them to the polyhedron constructor (#26366)\n- if only one representation is geometric, reconstruct the other one from the incidences by equation solving.\n\nIdeally, an optional argument `allow_degeneration` would allow that the given representation data actually gives a degeneration of the given combinatorial polyhedron.\n\nIn the context of #31803, this would be a morphism.\n\nIssue created by migration from https://trac.sagemath.org/ticket/31799\n\n",
    "created_at": "2021-05-09T02:21:48Z",
    "labels": [
        "component: geometry"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "From CombinatorialPolyhedron and H-representation to Polyhedron (with double description)",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31799",
    "user": "https://github.com/mkoeppe"
}
```
CC:  @kliem @yuan-zhou @jplab

Given an (abstract) `CombinatorialPolyhedron` such that **at least one** of H-representation and V-representation are labeled geometrically, the new method `CombinatorialPolyhedron.as_polyhedron` constructs a geometric polyhedron.

If `check=True` (default), it checks that the result is OK.

We should be able to efficiently build a polyhedron, avoiding to run the double description method when setting up the polyhedron, for the backends that accept double description input:
- if both representations are geometric, just pass them to the polyhedron constructor (#26366)
- if only one representation is geometric, reconstruct the other one from the incidences by equation solving.

Ideally, an optional argument `allow_degeneration` would allow that the given representation data actually gives a degeneration of the given combinatorial polyhedron.

In the context of #31803, this would be a morphism.

Issue created by migration from https://trac.sagemath.org/ticket/31799





---

archive/issue_comments_450513.json:
```json
{
    "body": "It only seems to make sense for those backends that allow initialization from both V-representation and H-representation.\n\n(Normaliz somehow allows precomputed data, but it appears that initializing from precomputed data isn't really an advantage in terms of computation time.)\n\nThe method `a_maximal_chain` can be generalized to allow this. Currently it only gives some maximal chain, but we can easily obtain a maximal chain for each facet. This allows computing a unique inequality for each facet (in the non-degenerate case), given the V-representation. `a_maximal_chain` also allows obtaining the equations.\n\nGiven the H-representation we might as well be lazy and just use `CombinatorialPolyhedron.polar` for this.\n\nI'm not exactly sure what you mean by `allow_degeneration`. This is what I think for the case that the V-representation is given:\n- let `d` be the dimension of the affine hull of the V-representation, either `d=0` or for each facet, the corresponding V-representation objects must have affine hull dimension less than `d`\n- if `allow_degeneration=False` than `d` must be the dimension of the `CombinatorialPolyhedron` and the objects corresponding to the facets must have affine hull dimension `d-1` and those affine hulls must be unique for each facet\n- a maximal chain corresponding to a `d-1` dimensional affine hull defines a unique inequality, those inequalities are the computed H-representation\n- if `allow_degeneration=True` the remaining facets must have degenerated to a subset of some proper facet\n- the slack matrix (of the given V-representation and the computed H-representation) must always be non-negative\n- if `allow_degeneration=False` the incidence matrix (of the given V-representation and the computed H-representation) must be the same as the incidence matrix of the combinatorial polyhedron\n\nIt all depends on how much degeneration we allow. Another approach is that `allow_degeneration=True` only allows facets to collaps. So for any face of the combinatorial polyhedron the affine hull dimension of the given V-representation must be as expected.",
    "created_at": "2021-05-10T10:00:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450513",
    "user": "https://github.com/kliem"
}
```

It only seems to make sense for those backends that allow initialization from both V-representation and H-representation.

(Normaliz somehow allows precomputed data, but it appears that initializing from precomputed data isn't really an advantage in terms of computation time.)

The method `a_maximal_chain` can be generalized to allow this. Currently it only gives some maximal chain, but we can easily obtain a maximal chain for each facet. This allows computing a unique inequality for each facet (in the non-degenerate case), given the V-representation. `a_maximal_chain` also allows obtaining the equations.

Given the H-representation we might as well be lazy and just use `CombinatorialPolyhedron.polar` for this.

I'm not exactly sure what you mean by `allow_degeneration`. This is what I think for the case that the V-representation is given:
- let `d` be the dimension of the affine hull of the V-representation, either `d=0` or for each facet, the corresponding V-representation objects must have affine hull dimension less than `d`
- if `allow_degeneration=False` than `d` must be the dimension of the `CombinatorialPolyhedron` and the objects corresponding to the facets must have affine hull dimension `d-1` and those affine hulls must be unique for each facet
- a maximal chain corresponding to a `d-1` dimensional affine hull defines a unique inequality, those inequalities are the computed H-representation
- if `allow_degeneration=True` the remaining facets must have degenerated to a subset of some proper facet
- the slack matrix (of the given V-representation and the computed H-representation) must always be non-negative
- if `allow_degeneration=False` the incidence matrix (of the given V-representation and the computed H-representation) must be the same as the incidence matrix of the combinatorial polyhedron

It all depends on how much degeneration we allow. Another approach is that `allow_degeneration=True` only allows facets to collaps. So for any face of the combinatorial polyhedron the affine hull dimension of the given V-representation must be as expected.



---

archive/issue_comments_450514.json:
```json
{
    "body": "Replying to [comment:3 gh-kliem]:\n> It only seems to make sense for those backends that allow initialization from both V-representation and H-representation.\n\n\nYes, that's right. For the moment I am fine with just creating polyhedra in the `field` backend. In fact, my main application will be for parametric polyhedra (where the coefficient field is a [ParametricRealField](https://github.com/mkoeppe/cutgeneratingfunctionology/blob/master/cutgeneratingfunctionology/igp/parametric.sage#L68)).\n\n> (Normaliz somehow allows precomputed data, but it appears that initializing from precomputed data isn't really an advantage in terms of computation time.)\n\n\nHopefully at some point this can be improved - but it's not the main direction of this ticket.\n\n> The method `a_maximal_chain` can be generalized to allow this. Currently it only gives some maximal chain, but we can easily obtain a maximal chain for each facet. This allows computing a unique inequality for each facet (in the non-degenerate case), given the V-representation. `a_maximal_chain` also allows obtaining the equations.\n> \n> Given the H-representation we might as well be lazy and just use `CombinatorialPolyhedron.polar` for this.\n\n\nSounds great!",
    "created_at": "2021-05-10T17:15:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450514",
    "user": "https://github.com/mkoeppe"
}
```

Replying to [comment:3 gh-kliem]:
> It only seems to make sense for those backends that allow initialization from both V-representation and H-representation.


Yes, that's right. For the moment I am fine with just creating polyhedra in the `field` backend. In fact, my main application will be for parametric polyhedra (where the coefficient field is a [ParametricRealField](https://github.com/mkoeppe/cutgeneratingfunctionology/blob/master/cutgeneratingfunctionology/igp/parametric.sage#L68)).

> (Normaliz somehow allows precomputed data, but it appears that initializing from precomputed data isn't really an advantage in terms of computation time.)


Hopefully at some point this can be improved - but it's not the main direction of this ticket.

> The method `a_maximal_chain` can be generalized to allow this. Currently it only gives some maximal chain, but we can easily obtain a maximal chain for each facet. This allows computing a unique inequality for each facet (in the non-degenerate case), given the V-representation. `a_maximal_chain` also allows obtaining the equations.
> 
> Given the H-representation we might as well be lazy and just use `CombinatorialPolyhedron.polar` for this.


Sounds great!



---

archive/issue_comments_450515.json:
```json
{
    "body": "Replying to [comment:3 gh-kliem]:\n> I'm not exactly sure what you mean by `allow_degeneration`. This is what I think for the case that the V-representation is given: [...]\n\n\n> - the slack matrix (of the given V-representation and the computed H-representation) must always be non-negative\n\n\nYes\n\n> - if `allow_degeneration=False` the incidence matrix (of the given V-representation and the computed H-representation) must be the same as the incidence matrix of the combinatorial polyhedron\n\n\nYes, and for `allow_degeneration=True`, we would just drop this requirement, I think.\n\n> It all depends on how much degeneration we allow.\n\n\nLet's consider the generalized permutahedron as a model. I would like to include its degenerations in full generality.\n\nA related question is how to do recognize degenerations on the level of abstract combinatorial polyhedra (without coordinates). Given two (abstract) combinatorial polyhedra P, Q and a map sending vertices to vertices, can we detect whether Q is a degeneration of P? I don't know how to check this without coordinates.",
    "created_at": "2021-05-10T17:37:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450515",
    "user": "https://github.com/mkoeppe"
}
```

Replying to [comment:3 gh-kliem]:
> I'm not exactly sure what you mean by `allow_degeneration`. This is what I think for the case that the V-representation is given: [...]


> - the slack matrix (of the given V-representation and the computed H-representation) must always be non-negative


Yes

> - if `allow_degeneration=False` the incidence matrix (of the given V-representation and the computed H-representation) must be the same as the incidence matrix of the combinatorial polyhedron


Yes, and for `allow_degeneration=True`, we would just drop this requirement, I think.

> It all depends on how much degeneration we allow.


Let's consider the generalized permutahedron as a model. I would like to include its degenerations in full generality.

A related question is how to do recognize degenerations on the level of abstract combinatorial polyhedra (without coordinates). Given two (abstract) combinatorial polyhedra P, Q and a map sending vertices to vertices, can we detect whether Q is a degeneration of P? I don't know how to check this without coordinates.



---

archive/issue_comments_450516.json:
```json
{
    "body": "In light of #31801 we should probably add an optional argument `verify` with default `True`.",
    "created_at": "2021-05-10T19:46:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450516",
    "user": "https://github.com/kliem"
}
```

In light of #31801 we should probably add an optional argument `verify` with default `True`.



---

archive/issue_comments_450517.json:
```json
{
    "body": "Replying to [comment:5 mkoeppe]:\n> [...]\n> \n> A related question is how to do recognize degenerations on the level of abstract combinatorial polyhedra (without coordinates). Given two (abstract) combinatorial polyhedra P, Q and a map sending vertices to vertices, can we detect whether Q is a degeneration of P? I don't know how to check this without coordinates.\n> \n\n\nAh, ok. From my intuition (which might be wrong as well), the following happens at a degeneration map:\n- There exists a list of disjoint faces, which get contracted (so only one vertex remains for each of those faces).\n- First step is to contract the vertices according to the map and apply a bitwise OR to the (old) coatom incidences.\n- The new coatoms are the inclusion maximal coatoms.\n- Each old coatom should still define a face (I think this holds automatically).\n\nWhat needs to be checked:\n- Whether each equivalence class of vertices corresponds to a face (compute the join of those atoms).\n\nIf this is correct, this ticket should depend on #29683.\n\nWe also need to check that the incidence matrix is correct then, which is quite obvious of course (probably best to check this via the bipartite digraph isomorphism of the vertex-facet graph).\n\nDo we allow degenerations that might be obtained by iteratively degenerating? Might be a bit harder to check.",
    "created_at": "2021-05-10T20:58:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450517",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:5 mkoeppe]:
> [...]
> 
> A related question is how to do recognize degenerations on the level of abstract combinatorial polyhedra (without coordinates). Given two (abstract) combinatorial polyhedra P, Q and a map sending vertices to vertices, can we detect whether Q is a degeneration of P? I don't know how to check this without coordinates.
> 


Ah, ok. From my intuition (which might be wrong as well), the following happens at a degeneration map:
- There exists a list of disjoint faces, which get contracted (so only one vertex remains for each of those faces).
- First step is to contract the vertices according to the map and apply a bitwise OR to the (old) coatom incidences.
- The new coatoms are the inclusion maximal coatoms.
- Each old coatom should still define a face (I think this holds automatically).

What needs to be checked:
- Whether each equivalence class of vertices corresponds to a face (compute the join of those atoms).

If this is correct, this ticket should depend on #29683.

We also need to check that the incidence matrix is correct then, which is quite obvious of course (probably best to check this via the bipartite digraph isomorphism of the vertex-facet graph).

Do we allow degenerations that might be obtained by iteratively degenerating? Might be a bit harder to check.



---

archive/issue_comments_450518.json:
```json
{
    "body": "As for designing the interface, I would like to introduce a method `CombinatorialPolyhedra.hom` to construct the morphism \n(as you suggest, with a `verify` (or `check`?) keyword argument)",
    "created_at": "2021-05-12T19:49:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450518",
    "user": "https://github.com/mkoeppe"
}
```

As for designing the interface, I would like to introduce a method `CombinatorialPolyhedra.hom` to construct the morphism 
(as you suggest, with a `verify` (or `check`?) keyword argument)



---

archive/issue_comments_450519.json:
```json
{
    "body": "Should be a `check` keyword according to `git grep`. `verify` is used (almost) exclusively for `sage_input`.",
    "created_at": "2021-05-12T19:53:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450519",
    "user": "https://github.com/kliem"
}
```

Should be a `check` keyword according to `git grep`. `verify` is used (almost) exclusively for `sage_input`.



---

archive/issue_comments_450520.json:
```json
{
    "body": "So something like this:\n\n```\nclass CombinatorialPolyhedra(UniqueRepresentation, Parent):\n    ...\n    def hom(self, Vrep_dict, codomain=None, check=True, category=None):\n```",
    "created_at": "2021-05-12T20:09:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450520",
    "user": "https://github.com/mkoeppe"
}
```

So something like this:

```
class CombinatorialPolyhedra(UniqueRepresentation, Parent):
    ...
    def hom(self, Vrep_dict, codomain=None, check=True, category=None):
```



---

archive/issue_comments_450521.json:
```json
{
    "body": "... it should return an instance of a class similar to `SimplicialComplexMorphism`",
    "created_at": "2021-05-12T20:11:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450521",
    "user": "https://github.com/mkoeppe"
}
```

... it should return an instance of a class similar to `SimplicialComplexMorphism`



---

archive/issue_comments_450522.json:
```json
{
    "body": "A skeleton of the classes to implement morphisms is now on #31803.",
    "created_at": "2021-05-14T16:51:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450522",
    "user": "https://github.com/mkoeppe"
}
```

A skeleton of the classes to implement morphisms is now on #31803.



---

archive/issue_comments_450523.json:
```json
{
    "body": "New commits:",
    "created_at": "2021-05-26T06:34:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31799#issuecomment-450523",
    "user": "https://github.com/mkoeppe"
}
```

New commits:



---

archive/issue_events_083960.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:16:42Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31799#event-83960"
}
```



---

archive/issue_events_083961.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31799#event-83961"
}
```



---

archive/issue_events_083962.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31799#event-83962"
}
```



---

archive/issue_events_083963.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-02T17:54:54Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31799#event-83963"
}
```



---

archive/issue_events_083964.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-02T17:54:54Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31799#event-83964"
}
```



---

archive/issue_events_083965.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31799#event-83965"
}
```



---

archive/issue_events_083966.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/31799",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/31799#event-83966"
}
```
