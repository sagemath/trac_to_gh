# Issue 20498: Infix mod operator

Issue created by migration from Trac.

Original creator: vbraun

Original creation time: 2016-05-31 15:14:07




---

Comment by vbraun created at 2016-05-31 16:34:54

Changing type from PLEASE CHANGE to enhancement.


---

Comment by vbraun created at 2016-05-31 16:34:54

Changing component from PLEASE CHANGE to user interface.


---

Comment by git created at 2016-05-31 16:35:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2016-05-31 16:38:49

Changing status from new to needs_review.


---

Comment by kcrisman created at 2016-05-31 16:58:00

As you can imagine, this might be useful pedagogically ... how does this look in more complicated expressions?  

If this would really be added, I think it would be unfortunate if it were only mentioned in this obscure location (assuming it fits everyone's needs, isn't averse to any Python style, and is merged, all of which I can't speak to).  What I usually do now is have people do

```
a = mod(25,4)
```

but 

```
a = 25 mod 4
```

could be more useful, but of course only if it's mentioned in places like the tutorial and perhaps some construction or PREP or other documents as "alternate notation".

Anyway, nice idea - what brought it up?


---

Comment by nbruin created at 2016-05-31 20:20:10

Replying to [comment:5 kcrisman]:
> If this would really be added, I think it would be unfortunate if it were only mentioned in this obscure location (assuming it fits everyone's needs, isn't averse to any Python style, and is merged, all of which I can't speak to).  What I usually do now is have people do
> {{{
> a = mod(25,4)
> }}}
> but 
> {{{
> a = 25 mod 4
> }}}
I didn't know about the `mod` function! That looks nice. I foresee problems with preparsing an infix operator: you can't handle parentheses. If we spell it

```
a = 25 * mod(4)
```

we're one operation away from normal mathematics notation (except that the parentheses are mandatory, but quite a few people would write those anyway). For backwards compatibility:

```
def mod(a,M=None):
    if M is None:
        return a.parent().quo(a).one()
    else:
        return M.parent().quo(M)(a)
```


From a mathematical point of view we should be making residue classes by *adding* the residue class of zero, so if we have `nZ(N)=parent(N).quo(N).zero()` then we can write

```
a = 25 + nZ(4)
```

which ideally would be spelled `25 + 4*ZZ`, but then we clash with ideal arithmetic. In any case, I suspect the main audience for these shortcuts would not particularly looking for the "coset" interpretation.


---

Comment by bruno created at 2016-06-01 12:32:35

I am not very much in favor of the proposed new rule for preparsing. Given that one can already use `mod(3,2)` to obtain the desired result, I think that the benefits do not compensate the inconveniences the new rule adds. Among maybe other, I see at least those three problems:

1. There may be a conflict with implicit multiplications if the user defines the variable `mod`. We had the following behavior:


```python
sage: implicit_multiplication(True)
sage: mod = 5
sage: 3 mod 2
30
sage: type(_)
<type 'sage.rings.integer.Integer'>
```


  It becomes:


```python
sage: implicit_multiplication(True)
sage: mod = 5
sage: 3 mod 2
1
sage: type(_)
<type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
sage: 3 mod
15
sage: mod 2
10
```


2. I also wonder whether the following is not misleading for many users:


```python
sage: type(3.mod(2))
<type 'sage.rings.integer.Integer'>
sage: type(3 mod 2)
<type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
```


3. With the current implementation, there are unhandled cases that may be more or less inconvenient. The following examples yield `SyntaxError: invalid syntax`:


```python
sage: 3 mod (1+1) # maybe inoffensive
sage: x = 5; 3 mod x # more serious I guess
```



---

Comment by nbruin created at 2016-06-01 15:19:31

Replying to [comment:7 bruno]:
> 2. I also wonder whether the following is not misleading for many users:
> 
> {{{#!python
> sage: type(3.mod(2))
> <type 'sage.rings.integer.Integer'>
> sage: type(3 mod 2)
> <type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>
> }}}

Ouch. Good find. This is already a problem now. One of the ways in which method notation can be made palatable for mathematicians is by explaining that "really, X.f(Y) is f(X,Y), but for namespace reasons we prefer the former". This goes horribly wrong for "3.mod(2)" versus "mod(3,2)".

This meaning of "mod" is ingrained quite strongly in Sage: `sage.structure.element.CommutativeRingElement.mod` defines the result to lie the ring itself again, and `sage.rings.polynomial.polynomial_element.Polynomial.mod` redefines it to be `__mod__` (as happens on integers). It is strongly suggeted by the fact that the implementation name for `%` is `__mod__` too.

We may have to consider if even keeping the present `mod(...,...)` is desirable.


---

Comment by kedlaya created at 2016-06-02 05:04:39

I don't know if there is any good alternative to the status quo here. `mod(...,...)` is by far the easiest way to construct an element of an `IntegerModRing` if you haven't already defined the ambient ring. On the other hand, `%` for remainder-upon-division is already an operation on Python integers, so it is natural for Sage to mimic that behavior for Sage integers, and by extension for ring elements.

If I had to change anything, I'd change the behavior of `3.mod(2)` to match `mod(3,2)` (returning an element of an `IntegerModRing`), and have `3.rem(2)` return an element of `IntegerRing`; but I fear that way madness lies...


---

Comment by roed created at 2017-08-22 21:26:03

This hasn't had any progress recently; should we close it as won't-fix?  Volker, any comments?


---

Comment by roed created at 2017-09-11 21:30:05

Ping.  I'm changing the milestone to wontfix; if there's disagreement feel free to continue the discussion.


---

Comment by mmezzarobba created at 2018-05-31 07:45:17

Changing status from needs_review to positive_review.


---

Comment by mmezzarobba created at 2018-05-31 07:45:17

No comments for several months after David set the ticket to wontfix...


---

Comment by embray created at 2019-02-26 13:58:00

Presuming these are all correctly reviewed as either duplicate, invalid, or wontfix.


---

Comment by embray created at 2019-02-26 13:58:00

Resolution: invalid
