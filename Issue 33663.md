# Issue 33663: small enhancements to generic discrete logs

Issue created by migration from https://trac.sagemath.org/ticket/33900

Original creator: @k3w1k0d3r

Original creation time: 2022-05-25 04:15:07

CC:  lorenz

Keywords: discrete, logarithm, group theory, generic

Previously, the generic discrete log function wouldn't ever use Pollard's rho. From what I can tell, no generic Pohlig-Hellman implementation existed which used Pollard's rho.

Additionally, discrete log functions did not seem to properly use the custom operation arguments.


---

Comment by @k3w1k0d3r created at 2022-05-25 04:16:03

Set assignee to @k3w1k0d3r.


---

Comment by git created at 2022-05-25 05:38:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @k3w1k0d3r created at 2022-05-25 05:40:38

Changing status from new to needs_review.


---

Comment by git created at 2022-05-25 20:14:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-25 21:35:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2022-05-26 02:44:50

Thanks for the contribution!

One first comment: The `use_rho` keyword argument should be replaced by an `algorithm` argument (with options `"bsgs"`/`"rho"` and a reasonable default choice among these), as is standard practice throughout most of the Sage library. This makes sure the interface doesn't get awkward if someone wants to add another algorithm option later.


---

Comment by git created at 2022-05-26 03:56:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-27 05:20:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2022-05-27 06:15:43

Thanks. Some more comments:

- There's a spurious whitespace change in `build/bin/sage-bootstrap-python`.
- Your `ValueError("unkown algorithm")` contains a typo ("unkown" -> "unknown").
- That same `ValueError` is immediately caught by the function and results in an incorrect "no discrete log" error.
- The logic here:

```python
    mult = op if op is not None else [add, mul][operation in multiplication_names]
    power = [mul, pow][operation in multiplication_names]
    if(op is not None):
        power = lambda x, y: multiple(x, y, operation=operation, identity=identity, inverse=inverse, op=op)
    if ord is None:
        if operation in multiplication_names:
            mult = mul
            power = pow
            try:
                ord = base.multiplicative_order()
            except Exception:
                ord = base.order()
        elif operation in addition_names:
            mult = add
            power = mul
```

is weird. First, it should probably throw an error if `operation` is neither in `addition_names` nor in `multiplication_names`. Second, if `operation` is given but `ord` is not, this sets both `mult` and `power` twice (to the same value). Third, coding style: `if(foo):` should be `if foo:` in Python. Fourth, you use an `if` to set `power`, but the ternary `x if y else z` to set `mult`; this can be streamlined into a single `if`.

- This should probably say "in _the_ group":

```diff
+    - ``op()`` - function of 2 arguments ``x``, ``y`` returning ``x*y`` in group
```



---

Comment by git created at 2022-05-27 06:16:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @k3w1k0d3r created at 2022-05-27 06:18:06

Replying to [comment:11 lorenz]:
> Thanks. Some more comments:
> 
> - There's a spurious whitespace change in `build/bin/sage-bootstrap-python`.
> - Your `ValueError("unkown algorithm")` contains a typo ("unkown" -> "unknown").
> - That same `ValueError` is immediately caught by the function and results in an incorrect "no discrete log" error.
> - The logic here:
> {{{#!python
>     mult = op if op is not None else [add, mul][operation in multiplication_names]
>     power = [mul, pow][operation in multiplication_names]
>     if(op is not None):
>         power = lambda x, y: multiple(x, y, operation=operation, identity=identity, inverse=inverse, op=op)
>     if ord is None:
>         if operation in multiplication_names:
>             mult = mul
>             power = pow
>             try:
>                 ord = base.multiplicative_order()
>             except Exception:
>                 ord = base.order()
>         elif operation in addition_names:
>             mult = add
>             power = mul
> }}}
> is weird. First, it should probably throw an error if `operation` is neither in `addition_names` nor in `multiplication_names`. Second, if `operation` is given but `ord` is not, this sets both `mult` and `power` twice (to the same value). Third, coding style: `if(foo):` should be `if foo:` in Python. Fourth, you use an `if` to set `power`, but the ternary `x if y else z` to set `mult`; this can be streamlined into a single `if`.
> 
> - This should probably say "in _the_ group":
> {{{#!diff
> +    - ``op()`` - function of 2 arguments ``x``, ``y`` returning ``x*y`` in group
> }}}
thanks


---

Comment by git created at 2022-05-27 07:00:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @k3w1k0d3r created at 2022-05-27 07:01:31

I didn't think https://git.sagemath.org/sage.git/commit/?id=f2cc9775d072728a444f0ab19a9349eef2668225 through very well and the tests didn't detect my mistake, I've now undone that change.


---

Comment by @k3w1k0d3r created at 2022-06-08 00:19:54

is it looking better now?


---

Comment by @k3w1k0d3r created at 2022-08-02 19:08:02

is there any update on this?


---

Comment by lorenz created at 2022-08-03 01:55:50

Sorry for the long silence. What's still missing are tests for the new `algorithm` flag: I guess you can just copy some of the existing tests and show that they also work if you pass `algorithm='rho'`.

Once that's done, I think this can be merged â€” while there are still plenty of things I would change in that file, it's certainly better than before.


---

Comment by git created at 2022-08-03 08:11:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2022-08-04 08:01:27

Thanks!


---

Comment by lorenz created at 2022-08-04 08:01:27

Changing status from needs_review to positive_review.


---

Comment by @k3w1k0d3r created at 2022-08-04 21:53:09

thank you! since it's positive review now, what would be the process for making further changes? should I open a new ticket?


---

Comment by @k3w1k0d3r created at 2022-08-05 04:01:19

actually I'm pretty sure the current code has a bug so I should probably update this ticket. before I push, can you confirm that that's what I should do?


---

Comment by lorenz created at 2022-08-05 04:24:43

I'm not sure either what's the preferred way of dealing with this, but I think setting it back to "needs work" for now won't hurt.
(Adding changes to a ticket that is in "positive review" state is discouraged because it makes it difficult to tell which version of the branch gets merged in the end.)

What's the bug you found? Does it break things that used to work previously?


---

Comment by lorenz created at 2022-08-05 04:24:43

Changing status from positive_review to needs_work.


---

Comment by @k3w1k0d3r created at 2022-08-05 04:46:21

it has to do with the stop early CRT optimization.

`CRT_list(l, [pi**ri for pi, ri in f[:len(l)]])`

Since we stop before computing the latter part of `l`, we need to cut off the moduli early as well. The problem is that `l` is initialized with its full length, so this list slicing doesn't do anything. If this part of code got hit then some of the CRT relations would be wrong (unless 0 was the correct result for all remaining factors). The solution is simple, just slice `l` at the number of factors that have been checked.

Since this optimization wasn't in there before, this does break something that used to work.


---

Comment by lorenz created at 2022-08-05 08:05:51

I see, sorry for not catching that. In addition to fixing it, could you please add a test that currently fails because of the bug?

Ideally, we should add more comprehensive (maybe randomized) testing to these functions too, but I suppose that can become part of the "plenty of things I would change in that file" I had alluded to earlier.


---

Comment by git created at 2022-08-05 09:14:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @k3w1k0d3r created at 2022-08-05 09:15:36

the first commit does a bit more than fix the bug because I didn't notice the bug until after doing some other things. I thought it was all related enough to go in one commit.


---

Comment by @k3w1k0d3r created at 2022-08-06 00:01:35

Changing status from needs_work to needs_review.


---

Comment by git created at 2022-08-06 09:06:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-07 07:00:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2022-08-08 02:25:52

Here's an example that still fails:

```sage
discrete_log(Mod(0,4), Mod(2,4), 4, operation='+', algorithm='lambda')
```


From a quick glance it looks like the upper bounds passed to `discrete_log_lambda` might be off by one.

You may want to add the following test to the function to catch things like this in the future:

```diff
--- a/src/sage/groups/generic.py
+++ b/src/sage/groups/generic.py
@@ -833,6 +833,28 @@ def discrete_log(a, base, ord=None, bounds=None, operation='*', identity=None, i
         sage: discrete_log(u,g,algorithm='rho')
         123456789

+    TESTS:
+
+    Random testing::
+
+        sage: G = Zmod(randrange(1, 1000))
+        sage: base = G.random_element()
+        sage: order = base.additive_order()
+        sage: assert order.divides(G.cardinality())
+        sage: sol = randrange(order)
+        sage: elem = sol * base
+        sage: args = (elem, base, order)
+        sage: kwargs = {'operation': '+'}
+        sage: kwargs['algorithm'] = choice(['bsgs', 'rho', 'lambda'])
+        sage: if randrange(2):
+        ....:     lo = randrange(-order, sol+1)
+        ....:     hi = randrange(sol+1, 2*order)
+        ....:     assert lo <= sol < hi
+        ....:     kwargs['bounds'] = (lo, hi)
+        sage: res = discrete_log(*args, **kwargs)
+        sage: res == sol
+        True
+
     AUTHORS:

     - William Stein and David Joyner (2005-01-05)
@@ -845,7 +867,7 @@ def discrete_log(a, base, ord=None, bounds=None, operation='*', identity=None, i
         mult = op
         power = lambda x, y: multiple(x, y, operation=operation, identity=identity, inverse=inverse, op=op)
     if bounds:
-        lb, ub = bounds
+        lb, ub = map(integer_ring.ZZ, bounds)
     if (op is None or identity is None or inverse is None or ord is None) and operation not in addition_names+multiplication_names:
         raise ValueError("ord, op, identity, and inverse must all be specified for this operation")
     if ord is None:
```



---

Comment by lorenz created at 2022-08-08 02:25:52

Changing status from needs_review to needs_work.


---

Comment by @k3w1k0d3r created at 2022-08-08 04:26:52

there seems to be a bug in the lambda algorithm.

notice that the second pass through lambda is the one which fails to find a logarithm. the correct logarithm for that case is 0, and the bounds passed are (0, 2). the logarithm 0 should be found within this range, but it is not. this is incorrect behavior.

the reason for this (I think) is that the pollard lambda algorithm requires inclusive bounds to be sent, but the implementation checks that `c-d<ub` (note the strict comparison) before returning. when this comparison is changed to not be strict, 2 is returned. this is a correct logarithm, albeit not the smallest. I think this change probably should be made, because the prior behavior of failing is certainly incorrect.

the lambda implementation, however, isn't the only thing mistreating the bound inclusivity/exclusivity. with that change made, `discrete_log(Mod(0,4), Mod(2,4), 4, operation='+', algorithm='lambda')` returns 2. this is valid, but not the smallest. this doesn't happen with bsgs because bsgs is guaranteed to find the smallest log in the range. one solution is to mod by pi after getting a result from lambda, but the far cleaner solution is to subtract 1 from temp_bound so that a tighter but still correct bound is passed. these are the changes I'm pushing now.


---

Comment by @k3w1k0d3r created at 2022-08-08 04:53:16

this actually still doesn't work. the reason is that now on the first pass of lambda, the log being calculated is 0 with base 0. any answer would be valid here, and with bounds (0, 2) lambda returns 0 but with bounds (0, 1) lambda returns 1. this leads to the next pass of lambda taking log(2) base 0, which doesn't exist. the reason is that 4 isn't the correct order of 2 (2+2=0), and pohlig-hellman relies on knowing the order of the point.

I'll implement a workaround so we don't need to trust the user to provide a correct order.


---

Comment by lorenz created at 2022-08-08 05:01:15

Oops, sorry, I didn't mean to give an example with incorrect inputs. Here's one with the correct order where it still fails:

```sage
discrete_log(Mod(1,5), Mod(4,5), 5, operation='+', algorithm='lambda')
```


I think trusting the user to provide the correct order is fine.


---

Comment by git created at 2022-08-08 05:09:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @k3w1k0d3r created at 2022-08-08 05:09:56

I haven't yet made the change to map bounds to ZZ, is there any reason for that?


---

Comment by @k3w1k0d3r created at 2022-08-08 05:12:29

sorry I didn't see your comment to not add the workaround, should I undo that change?


---

Comment by @k3w1k0d3r created at 2022-08-08 05:13:12

Changing status from needs_work to needs_review.


---

Comment by git created at 2022-08-08 05:23:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @k3w1k0d3r created at 2022-08-08 06:03:10

okay I just hit the test that shows why the map on bounds is important. it seems fitting if we have the function assume bounds might be python ints that we also assume ord could be a python int, which also messes things up, so I made that change as well.


---

Comment by git created at 2022-08-08 06:04:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2022-08-09 14:57:32

Changing status from needs_review to needs_work.


---

Comment by lorenz created at 2022-08-09 14:57:32

The random doctest currently fails rather frequently when it uses the `lambda` algorithm.

We should also make up our minds whether `discrete_log()` requires the exact order or just a multiple: The documentation says it can be a multiple, but `discrete_log(Mod(20,25), Mod(5,25), 25, operation='+')` now returns `1` which is clearly wrong. (It also doesn't work in Sage 9.6, but there it fails with a `ValueError`...)


---

Comment by @k3w1k0d3r created at 2022-08-09 17:12:41

the wrong  answer happens because of this clearly incorrect line that I wrote `gamma = mult(gamma, power(base, -1))`. It's fixed now, I'll push soon. I haven't yet reproduced the lambda issue so I can't investigate too much but I think it might just be because lambda is probabilistic and has a chance of failing.


---

Comment by @k3w1k0d3r created at 2022-08-09 17:23:38

can you give the failing lambda parameters? I'm running the random test on loop with lambda algorithm only but I'm not seeing any issues.


---

Comment by @k3w1k0d3r created at 2022-08-09 17:35:16

okay I'm pretty sure the failing lambda tests are because of the probabilistic nature of pollard lambda. they all seem to sometimes succeed and sometimes fail. as an example `discrete_log(Mod(656, 956), Mod(698, 956), operation='+', algorithm='lambda')`.


---

Comment by git created at 2022-08-09 17:36:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-09 17:47:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-09 18:04:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-09 19:12:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @k3w1k0d3r created at 2022-08-09 19:13:16

Changing status from needs_work to needs_review.


---

Comment by @k3w1k0d3r created at 2022-08-09 19:13:16

finally got the last bug I've noticed out.


---

Comment by lorenz created at 2022-08-10 03:03:55

Looks good, thank you for all the work.

Now we just need to avoid the doctest failures when `lambda` fails randomly. Maybe like this?


```diff
--- a/src/sage/groups/generic.py
+++ b/src/sage/groups/generic.py
@@ -851,9 +851,14 @@ def discrete_log(a, base, ord=None, bounds=None, operation='*', identity=None, i
         ....:     hi = randrange(sol+1, 2*order)
         ....:     assert lo <= sol <= hi
         ....:     kwargs['bounds'] = (lo, hi)
-        sage: res = discrete_log(*args, **kwargs)
-        sage: res == sol
-        True
+        sage: try:
+        ....:     res = discrete_log(*args, **kwargs)
+        ....: except ValueError:
+        ....:     # lambda can fail randomly
+        ....:     if kwargs['algorithm'] != 'lambda':
+        ....:         raise
+        ....: else:
+        ....:     assert res == sol

     AUTHORS:

```


You may also want to consider adding yourself to the list of authors for the `discrete_log` function.


---

Comment by @k3w1k0d3r created at 2022-08-10 03:27:29

thanks. is there any reason to leave lambda in the random tests if we don't actually check if it worked?


---

Comment by lorenz created at 2022-08-10 03:45:41

We still check `res == sol` in case there is no exception. Thus, the test is not vacuous: It guarantees that _if_ the `lambda` implementation returns something, then it's correct.


---

Comment by git created at 2022-08-10 04:25:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @k3w1k0d3r created at 2022-08-10 04:26:48

thank you!


---

Comment by lorenz created at 2022-08-10 05:06:10

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-08-30 19:04:59

Resolution: fixed
