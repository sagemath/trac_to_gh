# Issue 31216: CombinatorialFreeModule _cartesian_product_of_elements() should support generators

Issue created by migration from https://trac.sagemath.org/ticket/31453

Original creator: mjo

Original creation time: 2021-03-05 12:54:49

CC:  tscrim

This method tries to index into its argument, which can be a generator:


```
sage: from sage.categories.magmatic_algebras import MagmaticAlgebras            
sage: class TrivialCFM(CombinatorialFreeModule): 
....:     def __init__(self): 
....:         c = MagmaticAlgebras(QQ).WithBasis().Unital() 
....:         super().__init__(QQ,[1],category=c) 
....:  
....:     def one(self): 
....:         return self.monomial(0) 
....:                                                                           
sage: c1 = TrivialCFM()                                                         
sage: c1.one()                                                                  
B[0]
sage: CP = cartesian_product([c1,c1])                                           
sage: CP.one()                                                                  
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: 'generator' object is not subscriptable
```



---

Comment by mjo created at 2021-03-05 13:02:43

New commits:


---

Comment by mjo created at 2021-03-05 13:02:43

Changing status from new to needs_review.


---

Comment by mjo created at 2021-03-05 13:06:12

The first commit here is unrelated to the problem. I was digging through the tree to see what type of argument the `_cartesian_product_of_elements()` method is supposed to accept, and noticed the superfluous list in the process.


---

Comment by mkoeppe created at 2021-03-06 01:11:23

The documentation still says that the input should be a tuple.


---

Comment by git created at 2021-03-06 01:48:14

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2021-03-06 01:50:56

Replying to [comment:3 mkoeppe]:
> The documentation still says that the input should be a tuple.

Why yes it does. I copied the updated version that says "iterator" from `src/sage/categories/sets_cat.py` and force-pushed an update.


---

Comment by mkoeppe created at 2021-03-06 02:24:45


```
+        # This implementation relies unfairly on the fact that
+        # _sets_keys are zero-based, unit-increment indices... but so
+        # did the code it replaces, and that code did not support
+        # "elements" being an iterator.
```

It is not useful to talk about a previous version of the code in a code comment.


---

Comment by mkoeppe created at 2021-03-06 02:26:06

Why do you replace the use of `self._sets_keys()` by the `count` generator?
Why not just use `zip(self._sets_keys(), elements)`?


---

Comment by tscrim created at 2021-03-06 03:39:29

Why not just do

```python
return self.sum(self.summand_embedding(i)(elt) for i,elt in enumerate(elements))
```



---

Comment by tscrim created at 2021-03-06 03:40:09

Actually, comment:7 is a better solution as it is more future compatible.


---

Comment by git created at 2021-03-06 13:56:43

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mjo created at 2021-03-06 14:07:33

Replying to [comment:8 tscrim]:
> Why not just do`return self.sum(self.summand_embedding(i)(elt) for i,elt in enumerate(elements))`?

The answer to that question is "because I didn't think of it."

Replying to [comment:7 mkoeppe]:
> Why not just use `zip(self._sets_keys(), elements)`?

Using `_sets_keys` is CFM actually "wrong" and introduces a miniscule performance penalty in any method that (possibly indirectly) references `cartesian_factors()`. The CFM subclass method is,


```python
def cartesian_factors(self):
    return self._sets
```


which puts the factors in "left to right" order, regardless of what order `_sets_keys()` is in. Compare with the superclass method,


```python
def cartesian_factors(self):
    return tuple(self.cartesian_projection(i)
                 for i in self.parent()._sets_keys())
```


which... is at least... trying? to do the right thing?

In any case, using `count(0)` avoids giving the impression that the `sets_keys()` order is actually used for `elements`. I think either `_sets_keys()` should be used everywhere, for consistency, or nowhere, for performance.

In any case, for now I'd just like it to work =)

I've used your code.


---

Comment by mkoeppe created at 2021-03-06 22:13:38

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-03-09 00:01:05

Resolution: fixed
