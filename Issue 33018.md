# Issue 33018: Equal hashes for non-isomorphic bipartite graphs with edge labels

Issue created by migration from https://trac.sagemath.org/ticket/33255

Original creator: @maxale

Original creation time: 2022-01-31 05:18:48

The following code illustrates the problem that two bipartite graph `B1` and `B2` (both canonically labeled) have equal hashes, while they are not isomorphic, let alone equal, as labeled graphs. 

When labels are ignored, these graphs are isomorphic, and so the problem may be caused by `hash()` function somehow ignoring edge labels.



```
B1 = BipartiteGraph( [(0, 11, 2), (0, 12, 1), (0, 14, 1), (0, 16, 1), (1, 10, 1), (1, 13, 1), (1, 14, 2), (1, 16, 1), (2, 10, 2), (2, 11, 1), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True )

B2 = BipartiteGraph( [(0, 11, 1), (0, 12, 1), (0, 14, 2), (0, 16, 1), (1, 10, 2), (1, 13, 1), (1, 14, 1), (1, 16, 1), (2, 10, 1), (2, 11, 2), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True )

print('Same hashes:', hash(B1) == hash(B2) )
print('Isomorphic:', B1.is_isomorphic( B2, edge_labels=True ) )
```



---

Comment by @maxale created at 2022-01-31 05:19:16

Changing component from group theory to graph theory.


---

Comment by @maxale created at 2022-01-31 05:26:03

Changing type from PLEASE CHANGE to defect.


---

Comment by @DaveWitteMorris created at 2022-01-31 06:03:34

The docstring for `Graph.__eq__` says: "... labels of arrows/edges are taken into account if **and only if** the graphs are considered weighted ...".  This means that if you want equality testing to consider the edge labels (i.e., if you want the graphs to be considered as labelled graphs), then you need to make the graphs weighted.

```
sage: B1 = BipartiteGraph( [(0, 11, 2), (0, 12, 1), (0, 14, 1), (0, 16, 1), (1, 10, 1), (1, 13, 1), (1, 14, 2), (1, 16, 1), (2, 10, 2), (2, 11, 1), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True, weighted=True )

sage: B2 = BipartiteGraph( [(0, 11, 1), (0, 12, 1), (0, 14, 2), (0, 16, 1), (1, 10, 2), (1, 13, 1), (1, 14, 1), (1, 16, 1), (2, 10, 1), (2, 11, 2), (2, 15, 1), (2, 16, 1), (3, 10, 1), (3, 12, 1), (3, 16, 2), (3, 17, 1), (4, 11, 1), (4, 13, 1), (4, 15, 2), (4, 17, 1), (5, 9, 2), (5, 14, 1), (5, 15, 1), (5, 17, 1), (6, 9, 1), (6, 13, 2), (6, 16, 1), (6, 17, 1), (7, 9, 1), (7, 10, 1), (7, 11, 1), (7, 12, 2), (7, 14, 1), (8, 9, 1), (8, 12, 1), (8, 13, 1), (8, 15, 1), (8, 17, 2)], immutable=True, weighted=True )

sage: print('Same hashes:', hash(B1) == hash(B2) )
sage: print('Isomorphic:', B1.is_isomorphic( B2, edge_labels=True ) )
sage: print('Equal:', B1 == B2)

Same hashes: False
Isomorphic: False
Equal: False
```

So this is not a bug in the method, but I can see that this could be unexpected behavior.  

Perhaps a warning should be given when edge labels are put on an unweighted graph, or perhaps the documentation should be clarified.


---

Comment by @DaveWitteMorris created at 2022-01-31 06:03:34

Changing type from defect to enhancement.


---

Comment by @DaveWitteMorris created at 2022-01-31 06:03:34

Changing priority from critical to major.


---

Comment by slelievre created at 2022-01-31 10:27:16

Simpler examples:

```
sage: a = [(0, 2, 1), (0, 3, 2), (1, 3, 1)]
sage: b = [(0, 2, 2), (0, 3, 1), (1, 3, 2)]

sage: A = BipartiteGraph(a, immutable=True)
sage: B = BipartiteGraph(b, immutable=True)

sage: print(f'Same hashes: {hash(A) == hash(B)}\n'
....:       f'Isomorphic: {A.is_isomorphic(B, edge_labels=True)}\n'
....:       f'Equal: {A == B}')
Same hashes: True
Isomorphic: False
Equal: True

sage: C = BipartiteGraph(a, immutable=True, weighted=True)
sage: D = BipartiteGraph(b, immutable=True, weighted=True)

sage: print(f'Same hashes: {hash(C) == hash(D)}\n'
....:       f'Isomorphic: {C.is_isomorphic(D, edge_labels=True)}\n'
....:       f'Equal: {C == D}')
Same hashes: False
Isomorphic: False
Equal: False
```



---

Comment by dcoudert created at 2022-01-31 10:46:09

The manipulation of edge labels is not simple since labels might not be hashable. For instance, a label can be a `Graph` or a dictionary.
In general, I prefer when the decision to consider labels is explicit (an argument set to `True` or `False`). 
Do you have any proposal to improve the documentation ?


---

Comment by @maxale created at 2022-01-31 14:09:36

A related issue is the name of this option. What is called `weighted=` in `BipartiteGraph()` in many other methods (like `.is_isomorphic()`, `.canonical_label()`, `.automorphism_group()` etc.) is called `edge_labels=`. 

Should there be consistency in the naming of this option?


---

Comment by @maxale created at 2022-01-31 19:50:21

Documentation says:

    weighted â€“ boolean (default: None); whether graph thinks of itself as weighted or not. See self.weighted()

So, the default value is not `True` or `False`, but `None`. I'd suggest that when `weighted=None` (ie., not specified), it should guessed from the input data. That is, if labels are present in the given data, `BipartiteGraph()` should assume `weighted=True`, otherwise it's `weighted=False`.


---

Comment by @enjeck created at 2022-04-12 17:26:29

I want to clarify what fix is expected for this ticket:
- Either replace `edge_labels` with `weighted` or vice versa for consistency
- When `weighted=None`, assign `True` or `False` to `weighted` after checking the input data for labels. For example, if the input is an edge list, just check if at least one edge is a triple (and the third item is not `None`). 
Is this right?


---

Comment by @maxale created at 2022-04-12 23:00:58

Replying to [comment:9 gh-enjeck]:
> I want to clarify what fix is expected for this ticket:
> - Either replace `edge_labels` with `weighted` or vice versa for consistency
> - When `weighted=None`, assign `True` or `False` to `weighted` after checking the input data for labels. For example, if the input is an edge list, just check if at least one edge is a triple (and the third item is not `None`). 
> Is this right? 

Yes, this would be great!


---

Comment by dcoudert created at 2022-04-13 09:14:49

I disagree with the proposed change of behavior of parameter `weighted`, and observe that it may affect the entire graph library and other modules using graphs.

Parameter `weighted` is an old parameter that is used in some algorithm to specify the default behavior. That is, do computations in a weighted graph instead of unweighted graph. This is for instance the case for `min_spanning_tree`.
We have a long term objective of unifying the use of weights #13112. I'm not sure that parameter `weighted` is well taken into account by all methods that can use edge weights. So, I usually prefer to explicitly set `by_weight=True` to avoid confusion.

May be others have a different opinion ?


---

Comment by @Bruno-TT created at 2022-10-31 17:56:23

Changing status from new to needs_review.


---

Comment by @Bruno-TT created at 2022-10-31 17:56:23

There was never a unanimous consensus on how to handle the weight/labelling logic, so I've implemented a suggestion.

My implementation adds an optional boolean parameter hash_labels to the class constructor, which if left empty will default to None and warn the user upon hash() invocation, and then include labels in the hash.

Let me know what you guys think.

(I'm new to the project so please feel free to give criticism, I'm assuming I've somehow misused trac).


---

Comment by git created at 2022-10-31 17:58:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2022-11-01 08:45:59

Welcome to Sagemath.

To be consistent, you should add parameter `hash_labels` to all (bipartite) (di)graph classes and make sure the parameter is copied when making a copy of the graph.

I disagree with the default `None` value. We usually don't print warnings.
I think it should default to `False` (current behavior) and be set to `True` if either it's the input value or if the graph is weighted.

For the `__hash__` method, please check `Graph.__hash__??`. It's better to use frozenset to avoid sorting. So simply use `left = frozenset(self.left)`.

Finally, please try to use the same coding style as other methods.


---

Comment by nbruin created at 2022-11-01 15:56:12

and try to stick to informative commit messages. If this ticket is merged, the commit messages become a permanent part of the sagemath repository and people who need to investigate the code for later maintenance will bump into them. The way these messages are formulated reflects on you (the author) and on the project as a whole.


---

Comment by git created at 2022-11-01 16:03:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Bruno-TT created at 2022-11-01 16:03:56

Replying to [comment:16 David Coudert]:
> To be consistent, you should add parameter `hash_labels` to all (bipartite) (di)graph classes and make sure the parameter is copied when making a copy of the graph.

Please could you clarify what you mean by this?

> I disagree with the default `None` value. We usually don't print warnings.
> I think it should default to `False` (current behavior) and be set to `True` if either it's the input value or if the graph is weighted.

```
def _use_hash_labels(self):
    return self.weighted() or self.hash_labels
```

Just changed the logic - is this what you mean?

> For the `__hash__` method, please check `Graph.__hash__??`. It's better to use frozenset to avoid sorting. So simply use `left = frozenset(self.left)`.

Cool, thanks for the tip - changed it.

> Finally, please try to use the same coding style as other methods.

I've run autopep8
----
New commits:


---

Comment by dcoudert created at 2022-11-01 16:23:20

Please avoid modifying parts of the code that have nothing to do with the objective of this ticket. It makes the reviewing process very difficult. To improve the coding style of a file, we prefer to open dedicated tickets and to not do it blindly.


Similarly to the `Graph__hash__` method, the `__hash__` method should be something like this (examples and tests are missing).

```
def __hash__(self):
    r"""
    Compute a hash for ``self``, if ``self`` is immutable.

    """
    if self.is_immutable():
        edge_items = self.edge_iterator(labels=self._weighted or self.hash_labels)
        if self.allows_multiple_edges():
            from collections import Counter
            edge_items = Counter(edge_items).items()
        return hash((frozenset(self.left),
                     frozenset(self.right),
                     frozenset(edge_items))
    raise TypeError("This graph is mutable, and thus not hashable. "
                    "Create an immutable copy by `g.copy(immutable=True)`")
```


Now, if we add this parameter to `BipartiteGraph`, it might be better to add it to `Graph`, `DiGraph`, etc. as well. Also, you must ensure that the parameter is copied if you do a copy.


---

Comment by git created at 2022-11-01 17:19:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Bruno-TT created at 2022-11-08 16:54:56

Replying to [comment:20 David Coudert]:
> Please avoid modifying parts of the code that have nothing to do with the objective of this ticket. It makes the reviewing process very difficult. To improve the coding style of a file, we prefer to open dedicated tickets and to not do it blindly.

Apologies for being too eager with the pep8 formatting - I've reverted the commit.


> Similarly to the `Graph__hash__` method, the `__hash__` method should be something like this (examples and tests are missing).
> {{{
> def __hash__(self):
>     r"""
>     Compute a hash for ``self``, if ``self`` is immutable.
> 
>     """
>     if self.is_immutable():
>         edge_items = self.edge_iterator(labels=self._weighted or self.hash_labels)
>         if self.allows_multiple_edges():
>             from collections import Counter
>             edge_items = Counter(edge_items).items()
>         return hash((frozenset(self.left),
>                      frozenset(self.right),
>                      frozenset(edge_items))
>     raise TypeError("This graph is mutable, and thus not hashable. "
>                     "Create an immutable copy by `g.copy(immutable=True)`")
> }}}

I've had a play around with your suggestion, but there is some slightly weird behaviour.

I'm not exactly sure what's going on, but for some reason, hashing a tuple containing an edge_iterator() object gives unreliable results:



```
sage: B1 = BipartiteGraph([(1,2,3)], immutable=True)
sage: hash((B1.edge_iterator(labels=False),))
-4081111260156298028
sage: hash((B1.edge_iterator(labels=False),)) # same line as above
6054870339558346632
```


For now, I'm going to keep using my initial list/tuple_depth implementation since it seems to produce more reliable results

> Now, if we add this parameter to `BipartiteGraph`, it might be better to add it to `Graph`, `DiGraph`, etc. as well. 

Apologies for repeatedly asking for clarification, but are you saying I should add a hash_labels argument to the constructors of every graph class, [and/or _use_hash_labels() logic]?

> Also, you must ensure that the parameter is copied if you do a copy.

How should I go about making sure the parameter is copied?


---

Comment by git created at 2022-11-08 16:55:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2022-11-08 17:34:22

Have your tried the method I proposed to hash a `BipartiteGraph` ? it is very similar to the hash function for `Graph`. It makes a frozenset of the list of edges which prevents ordering issues.

Concerning copy, you must ensure in method copy of `src/sage/graphs/generic_graph.py` that attribute `hash_labels` is copied (if it exists).

If you want to generalize the idea to `Graph`, `DiGraph`, `GenericGraph`, the parameter should be set in the constructor of each of these classes and that the hash method of  `src/sage/graphs/generic_graph.py` should be updated accordingly.


---

Comment by git created at 2022-11-24 14:46:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Bruno-TT created at 2022-11-24 14:50:37

Replying to [comment:24 David Coudert]:
> Have your tried the method I proposed to hash a `BipartiteGraph` ? it is very similar to the hash function for `Graph`. It makes a frozenset of the list of edges which prevents ordering issues.
Done!

> Concerning copy, you must ensure in method copy of `src/sage/graphs/generic_graph.py` that attribute `hash_labels` is copied (if it exists).
Done. Also added a hash_labels parameter to the copy method, although my solution is quite hacky - see my code comment for more info. The feature is fully functional, and I've written some quite comprehensive tests for it, but I also won't take it personally if someone wants to change it or remove it.


> If you want to generalize the idea to `Graph`, `DiGraph`, `GenericGraph`, the parameter should be set in the constructor of each of these classes and that the hash method of  `src/sage/graphs/generic_graph.py` should be updated accordingly.
Done, passing all tests.


---

Comment by dcoudert created at 2022-11-24 15:47:04

There is a merge conflict with the last beta version.


---

Comment by git created at 2022-11-24 18:17:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Bruno-TT created at 2022-11-24 18:18:14

Replying to [comment:27 David Coudert]:
> There is a merge conflict with the last beta version.
think I've resolved it


---

Comment by dcoudert created at 2022-11-26 16:11:37

Some of the text in the commits should be in the ticket to ease the discussion. For instance I agree that returning `self` is not a good idea as one may for instance want to manipulate copies with different embedding.

Also, can you push the branch in public (e.g., `public/graphs/33255`) so that I can push review commits. It's faster for me that listing all the details that must be improved.

Thanks.


---

Comment by @Bruno-TT created at 2022-12-10 14:03:43

Replying to [comment:30 David Coudert]:
> Some of the text in the commits should be in the ticket to ease the discussion. For instance I agree that returning `self` is not a good idea as one may for instance want to manipulate copies with different embedding.

for anyone interested, here is the text he's referring to:

''This is an ugly hack but it works.
This function contains some fairly complex logic, and there is a comment further down that says "Immutable copy of an immutable graph ? return self !", the issue being that if we want to change the hash_labels behaviour, then
returning self is no longer a good option. I'd argue that a copy function
returning self is always bad behaviour, but that's out of the scope for this ticket.
Trying to weaken the if statement to include something like
        


```
and (hash_labels is None or (hash_labels==self._use_labels_for_hash()))
```



_doesn't work, since there is no fallback logic for making an immutable copy of an immutable graph, and my attempts at implementing one caused other tests to break in different bits of the code_

_the hack I've used creates a mutable copy of the graph and then makes an immutable copy of that one. I think this is a fairly unobtrusive implementation, since the function still runs as normally, assuming that they pass nothing into hash_labels, and seems to behave correctly otherwise._

_However, this is obviously not optimal, and could definitely be improved upon by someone who understands the logic better._ 


> Also, can you push the branch in public (e.g., `public/graphs/33255`) so that I can push review commits. It's faster for me that listing all the details that must be improved.
> 
> Thanks.

pushed to `public/graphs/33255`
