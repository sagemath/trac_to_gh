# Issue 23299: Transversal Matroids

Issue created by migration from https://trac.sagemath.org/ticket/23536

Original creator: zgershkoff

Original creation time: 2017-07-25 00:48:26

CC:  stefan rudi yomcat zgershkoff




---

Comment by zgershkoff created at 2017-07-25 01:15:06

The way I have it currently set up, it builds a digraph from the data after taking a matching and orienting it opposite of everything else, and this is used for finding alternating paths and enabling the basis exchange. I'll upload it as soon as I get git-trac working again.


---

Comment by zgershkoff created at 2017-07-25 01:15:06

Changing type from PLEASE CHANGE to enhancement.


---

Comment by zgershkoff created at 2017-07-25 01:15:06

Changing component from PLEASE CHANGE to matroid theory.


---

Comment by zgershkoff created at 2017-07-25 21:59:35

New commits:


---

Comment by git created at 2017-07-31 02:40:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-07-31 03:45:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-01 00:37:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-01 01:14:06

This is behaving in ways I don't understand. If I add an isolated vertex to the ground set side of the bipartite graph, that should be a loop, but right now it will think that the element is in parallel with something, even though `__is_exchange_pair()` is always `False` no matter what you check it with.

In exploring this, I discovered a more serious error.


```
sage: G = Graph([('a', 'b'), ('b', 'c')])
sage: G.add_vertex('d')
sage: from sage.matroids.transversal_matroid import TransversalMatroid
sage: M = TransversalMatroid(G, groundset = ['a', 'c', 'd'])
sage: M.loops()
```


After a long traceback, we get this error:


```
ValueError: vertex '1' is not in the (di)graph
```


Why would it be looking for a vertex '1'?


---

Comment by Stefan created at 2017-08-01 02:21:04

The BasisExchangeMatroid class does an extra round of translation: elements get changed into integers through __pack and __unpack. This ensures elements correspond directly to bits in a bitset.


---

Comment by git created at 2017-08-01 02:34:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-01 02:36:26

I found a hint in the BasisMatroid class that `x` refers to the element `e = self._E[x]`. I guess my previous examples worked because my ground set was in a natural bijection with `range(n)`. Maybe I should rewrite it later using bitset commands, but for now I'm just glad it works.


---

Comment by git created at 2017-08-01 23:39:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-07 02:23:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-07 20:38:35

Changing status from new to needs_review.


---

Comment by zgershkoff created at 2017-08-07 20:38:35

I think it's complete enough to be reviewed now. It lacks a method to give a minimal or maximal presentation, but I think getting a set system to work as input through the constructor is a priority, and that belongs in another ticket.


---

Comment by git created at 2017-08-07 20:39:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-07 20:44:09

Looks like it timed out as I was pushing an update. It's all there now.

Also, this will almost certainly conflict with #23139 in a couple of places like unpickling.pyx.


---

Comment by git created at 2017-08-07 23:06:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-08 03:38:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-08 04:58:41

Actually, let me think about this a little more before it's reviewed.


---

Comment by zgershkoff created at 2017-08-08 04:58:41

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-08-08 21:13:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-08 21:16:44

I can't find a clean algorithmic way to get a minimal presentation, but with `reduce_presentation()`, we at least get a presentation where the number of sets equals the rank.

It should be a little faster now that the basis exchange computations are done in NetworkX.


---

Comment by zgershkoff created at 2017-08-08 21:16:44

Changing status from needs_work to needs_review.


---

Comment by zgershkoff created at 2017-08-08 21:24:02

Also, the reason I let it assume that the larger side of a `BipartiteGraph` is the ground set is that there's no method to switch the sides, so it would be inefficient to have the constructor take a bipartite graph as input, build a new one, and sent it to `__init__()`. I could rewrite `__init__()` to take a set system instead of a graph, but that should be done in a ticket where these are added to the constructor.


---

Comment by git created at 2017-08-08 21:25:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-15 02:27:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-16 00:05:00

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-08-16 00:05:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-16 02:23:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-16 18:44:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-16 18:46:55

Changing status from needs_work to needs_review.


---

Comment by zgershkoff created at 2017-08-16 18:46:55

I think it's ready now.


---

Comment by git created at 2017-08-21 01:14:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-23 03:17:35

I can't fix it now because I'm upgrading sage so maybe the documentation will build, but patchbot says there are a couple of problems. I don't know what "coverage" is (maybe I just need to rebase) but it looks like there's a python3 compatibility problem because `iteritems()` is deprecated for dictionaries, which should mean it won't work for the `Counter` either.


---

Comment by kdilks created at 2017-08-23 04:05:19

"Coverage" is checking to see if the code has sufficient doctests. I'm not seeing any methods that are missing examples/tests, but maybe since you're defining a class you need to run some sort of testsuite to make sure it's done right?

For python3 compatibility, I think you just need to change `d.iteritems() -> iter(d.items())`.


---

Comment by git created at 2017-08-25 16:40:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-08-25 19:15:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2017-08-25 19:16:33

I think it was expecting tests on `__translate_matching()` because it was `cpdef`. I changed it to `cdef` because there's no reason for it to be exposed.


---

Comment by msaaltink created at 2017-09-05 20:12:46

Changing status from needs_review to needs_work.


---

Comment by msaaltink created at 2017-09-05 20:12:46

This looks pretty good, with good documentation and plenty of tests.  Here are a few small issues I noticed:

1. the documentation for the 'matching' parameter is unclear.
1. There are no tests for the 'matching' parameter.  There should be a test with matching provided and set_labels not provided (to provoke the error), and some successful cases.
1. the 'matching' parameter does not seem to be fully checked, e.g.

```
sage: K = TransversalMatroid([[10,11],[10,12]], set_labels=['x1', 'x2'], matching={10:'x1', 11:'x3'})
sage: K
Transversal matroid of rank 2 on 3 elements, with 2 sets.
sage: list(K.bases())
[frozenset({10, 11})]
sage: L = TransversalMatroid([[10,11],[10,12]], set_labels=['x1', 'x2'])
sage: list(L.bases())
[frozenset({10, 11}), frozenset({11, 12}), frozenset({10, 12})]
sage: K == L
True
```

1. The automatic calculation of set_names can create conflicts that go undetected:

```
sage: sets = [['s1', 's2'], ['s1', 's3']]
sage: M = TransversalMatroid(sets); M
Transversal matroid of rank 2 on 3 elements, with 2 sets.
sage: M.sets()
[['s1', 's2'], ['s1', 's3']]
sage: M.set_labels()
['s0', 's1']
sage: M.graph()
NotImplementedError: Non injective relabeling

sage: M.transversal_extension(sets=['s1'])
ValueError: set labels cannot be element labels
```

1. Funny things can happen if the constructor is given "sets" that are not lists - yet being a list is not tested for.  The class documentation says it should be a "list of lists" while the constructor's documentation asks for "an iterable of iterables".  Which is it to be?

```
sage: N = TransversalMatroid(['abc', 'abd', 'cde']); N
Transversal matroid of rank 3 on 5 elements, with 3 sets.
sage: Ne = N.transversal_extension(element='f', sets=['s2'])
TypeError: cannot concatenate 'str' and 'list' objects

sage: N2 = TransversalMatroid(sets=[list('abc'), list('abd'), list('cde')]); N2
Transversal matroid of rank 3 on 5 elements, with 3 sets.
sage: N2e = N2.transversal_extension(element='f', sets=['s2']); N2e
Transversal matroid of rank 3 on 6 elements, with 3 sets.
```

1. `basis_exchange_matroid.pyx` has some documentation "``TransversalMatroid`` (not yet implemented) ..." which should be edited as part of this changeset,
1. The constructor silently drops empty sets from the given list of sets. Consider:

```
sage: TransversalMatroid([[], [1]], set_labels=['x', 'y'])
Transversal matroid of rank 1 on 1 elements, with 1 sets.
sage: M = _
sage: M.sets()
[[1]]
sage: M.set_labels()
['x', 'y']
```

Surely sets and set_labels should have the same length!  And indeed there is trouble in other methods:

```
sage: M.transversal_extension(element=2, sets=['x'])
ValueError: set labels do not match sets
```

1. The tests for '_minor' do not cover all cases, e.g., self.corank(contractions) == 0, or
contractions without deletions.


---

Comment by Stefan created at 2017-09-06 14:45:56

First half of my review:


```
unpickling.pyx:

l. 38 use relative import and cimport, like in the lines above it, for consistency.

transversal_matroid.pyx:

l. 15 iterable of iterables
l. 36 All references for matroids go into matroid.pyx. And really, looking at http://doc.sagemath.org/html/en/developer/coding_basics.html#sage-s-master-bibliography-file , should go into the master file.
l. 103 one missing space, some surplus spaces
l. 117, 118, 128, 145 missing spaces (please do a full search for such instances, I’m not going to list any more)
l. 146 no need for the “verbose=True” argument. Just TestSuite(M).run() will do
l. 159 why do you only keep nonempty sets? I would just keep a list of "sets" and add the "if s" clause to the end of the next line.
l. 162 are you sure this labeling is the same as in BasisExchangeMatroid? To fix this, after l. 156, add

groundset = tuple(groundset)

l. 207, 213, 223: use the self._idx dictionary provided by BasisExchangeMatroid.

The only reason to build your own element_int_map is to ensure uniqueness of vertex labels between groundset and set_labels. You might consider using something like newlabel() for the set labels and not converting to integers.

l. 213 Would it be possible to add all vertices at once? Depending on data structure, reallocating memory for each vertex can be expensive.

l. 217 same question.

l. 223 same question.

l. 247 range(len(sh[:-1])) makes a whole new list, just to count the length. Better:

range(len(sh) - 1)

Or even:

sh_edges = [(sh[i], sh[i + 1]) for i in xrange(len(sh) - 1)]
sh_edges_r = [(sh[i + 1], sh[i]) for i in xrange(len(sh) - 1)]

l. 266 better: len(self._sets_input)

l. 339 Better to compare a frozenset of frozensets. The whole sorted() thing won’t work in Python 3 if the user mixes integers and strings (something I frequently do while working with matroids)

l. 346 Explain how you implemented this.

l. 371 iteritems (and, for that matter, self._E) will assume an ordering of the elements that has no bearing on the underlying matroid. Better to put each in a frozenset so we get set comparisons.
```



---

Comment by Stefan created at 2017-09-11 15:00:40

Second half:


```
l. 456 Better: "A transversal matroid can be represented as a set system, or as a bipartite graph, with one color class corresponding to the ground set and the other to the sets of the set system. This method returns that bipartite graph."

l. 490 I don't think I see the problems that msaaltink pointed out for _minor.

l. 531 can use self._corank for slight speedup

l. 549 You should call N._minor for speed. The set contractions is already known to be independent and a subset of the groundset.

l. 587 add "nonempty"

l. 626 move into else clause

l. 632 use _minor for speed. The "delete" method will actually call _minor with an independent set to contract and a coindependent set to delete.

In any case, this method will change once you stop discarding empty sets, so I'll skip it for now.

l. 644 in light of this function, I strongly suggest not discarding empty sets. People might want to build their transversal matroid one element at a time, and have the final
rank in mind already.

l. 730 I'm not happy with the condition that set labels and groundset labels be different. This relabeling really gets in the way of people doing matroid extensions. Since you're already keeping a translation between the input set labels and internal set labels (see l. 179), just allow any collection of set labels as input. That also gets rid of the exception in l. 140.

l. 738 isinstance(newset, bool)

l. 743 The point is moot since you're (hopefully) dropping the requirement on set labels, but you're not using your labels_map here.

l. 805 Is there a reason you made this into a list?
```



---

Comment by git created at 2018-04-24 23:33:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-25 00:06:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2018-04-25 01:08:14

I addressed everything in [comment:36]. Here are some notes before I forget.

The matching parameter is like the basis parameter of `BasisExchangeMatroid`. It's there for speed, and as such, it's not strictly necessary to use, and there are no checks for bad input. Giving it just saves a little processing time finding one. The real purpose of having it there is compatibility with the rest of the matroid module. So I'm not really sure what else I should do to document or test it.

The documentation for basis exchange matroid should be updated, but it's best to do that when this class is exposed in #23628.

I have changed it so empty sets are kept in the constructor. If a user doesn't like it, they can run `reduce_presentation()`, which will remove them.

For comparison, I took out `sorted` so there aren't issues mixing strings and numbers, but having a frozenset of frozensets would ignore repeated sets, so I used the `Counter` object instead. This is identical to `self._sets`, although Cython probably wouldn't like it if I tried to call those directly.


---

Comment by git created at 2018-04-25 01:08:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by msaaltink created at 2018-05-01 18:46:35

There are still a few issues from #comment:35 that should be addressed:

* The `matching` parameter.  You wrote
> The matching parameter is like the basis parameter of BasisExchangeMatroid. It's there for speed, and as such, it's not strictly necessary to use, and there are no checks for bad input. Giving it just saves a little processing time finding one. The real purpose of having it there is compatibility with the rest of the matroid module. So I'm not really sure what else I should do to document or test it. 
It may be there just for speed, but can badly affect the answers you get.  I think the documentation should at least clarify that the matching must be a **maximal** matching, or things will not work out.  For example

```
sage: from sage.matroids.transversal_matroid import TransversalMatroid
sage: M = TransversalMatroid([range(5)] * 4, set_labels='abcd', matching={0:'a', 1:'c'})
sage: N = TransversalMatroid([range(5)] * 4, set_labels='abcd')
sage: M == N
True
sage: M.full_rank()
2
sage: N.full_rank()
4
sage: M.rank([0,1,2])
2
sage: N.rank([0,1,2])
3
```

It is perplexing that `M` and `N` compare as equal but have different ranks, and ascribe different ranks to the same set!  I would argue that the results for `M` are mathematically incorrect and therefore dangerous.  If it cannot be tested that the given matching is maximal, at least it should be documented that there is a potential for error here.  I am thinking of a situation where someone has written some code using this constructor, then later edits it without remembering to fix the matching.  They can then be silently getting bad answers.

As for additional test cases, the sort of thing I was suggesting is like this:

```
sage: TransversalMatroid(sets=[[0,1],[0,2]], matching={0:'s1'})
...
ValueError: set labels must be provided if matching is provided
```

that ensures the error of not providing set labels is indeed detected.  If you are shooting for full code coverage in your tests, things like this are needed.

* Iterables vs. lists.  This still seems wrong to me.  The constructor does what the documentation asks, giving an iterable of iterables, but then some functions raise exceptions.  Perhaps the given iterables should be coerced into lists internally?

```
N = TransversalMatroid(['abc', 'abd', 'cde']); N
Transversal matroid of rank 3 on 5 elements, with 3 sets.
sage: Ne = N.transversal_extension(element='f', sets=['s2'])
TypeError: cannot concatenate 'str' and 'list' objects
```



---

Comment by zgershkoff created at 2018-05-02 17:47:08

Thank you, msaaltink. I didn't mean to ignore you! I was going to work through comments 36 and 37, and then see what was still unresolved from 35.


---

Comment by git created at 2018-05-05 02:38:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2018-05-05 03:26:24

Good points about the matching. I'm not sure how to fix it but I agree it needs more tests.

Replying to [comment:37 Stefan]: 
> l. 730 I'm not happy with the condition that set labels and groundset labels be different. This relabeling really gets in the way of people doing matroid extensions. Since you're already keeping a translation between the input set labels and internal set labels (see l. 179), just allow any collection of set labels as input. That also gets rid of the exception in l. 140.

If the labels are the same, it becomes impossible to graph, since vertex labellings have to be injective. What should I do so the user can still graph their matroid?

> l. 743 The point is moot since you're (hopefully) dropping the requirement on set labels, but you're not using your labels_map here.

It appears that I don't use labels_map anywhere, so I guess I should remove that part of the code.


---

Comment by git created at 2018-05-05 03:26:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2018-06-10 19:00:48

Replying to [comment:43 msaaltink]:
> {{{
> sage: from sage.matroids.transversal_matroid import TransversalMatroid
> sage: M = TransversalMatroid([range(5)] * 4, set_labels='abcd', matching={0:'a', 1:'c'})
> sage: N = TransversalMatroid([range(5)] * 4, set_labels='abcd')
> sage: M == N
> True
> sage: M.full_rank()
> 2
> sage: N.full_rank()
> 4
> sage: M.rank([0,1,2])
> 2
> sage: N.rank([0,1,2])
> 3
> }}}
> It is perplexing that `M` and `N` compare as equal but have different ranks, and ascribe different ranks to the same set!  I would argue that the results for `M` are mathematically incorrect and therefore dangerous.  If it cannot be tested that the given matching is maximal, at least it should be documented that there is a potential for error here.  I am thinking of a situation where someone has written some code using this constructor, then later edits it without remembering to fix the matching.  They can then be silently getting bad answers.

That is perplexing, and it seems worse than the behavior of `BasisExchangeMatroid`, which can correct itself if the input is inconsistent. I can't think of a clean way to check if the matching provided actually gives the full rank, or indeed that it is a matching, without calling some computation-heavy graph methods.


```
sage: from sage.matroids.basis_exchange_matroid import *
sage: B = BasisExchangeMatroid([0,1], [0], 2)
sage: C = BasisExchangeMatroid([0,1], [0,1], 2)
sage: B == C
False
sage: B.rank()
1
sage: D = BasisExchangeMatroid([0,1], [0,1], 3)
sage: C == D
True
```



---

Comment by zgershkoff created at 2018-06-11 15:58:38

Here's one course of action: leave matching as it is without checks in __init__(), but override is_valid() to check that the matching in memory is indeed a maximal matching. Then have the comparison methods use is_valid(), returning true if they have the same ground set and sets and they're both valid, and false otherwise. (I think it's okay to have two of the same invalid matroids compare as false-- no one should be working with them on purpose.)


---

Comment by Stefan created at 2018-06-11 21:16:26

Overriding is_valid is a good idea in any case. The default implementation will check the basis exchange axioms in full, whereas for transversal matroids we only need to know that the basis size corresponds to a maximal transversal!

Would it suffice in the comparison to just check the ranks, rather than running is_valid? Or does that still leave the door open to other incorrect input, e.g. if both "matroids" have a non-maximal matching?


---

Comment by git created at 2018-06-18 06:56:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-18 14:32:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2018-06-18 16:03:59

Replying to [comment:50 Stefan]:
> Overriding is_valid is a good idea in any case. The default implementation will check the basis exchange axioms in full, whereas for transversal matroids we only need to know that the basis size corresponds to a maximal transversal!
> 
> Would it suffice in the comparison to just check the ranks, rather than running is_valid? Or does that still leave the door open to other incorrect input, e.g. if both "matroids" have a non-maximal matching?
There are three things that can go wrong with the "matching": It's not maximal, it's not actually a matching, or it's not in the set system. The rank only catches the former, so an invalid matroid can still have full rank but the same ground set and sets as a valid matroid. So I think I really do need comparison to test all of these.

I found a bug in the way matching input is handled, so thanks, msaaltink, for your thoroughness. Test coverage should be complete now.

I'll set it to needs review since I've made all of the suggested changes. There remains the issue of letting the element and set labels overlap, but I'm not sure how to let that happen without compromising graph functionality, or if it's worth it.


---

Comment by zgershkoff created at 2018-06-18 16:03:59

Changing status from needs_work to needs_review.


---

Comment by zgershkoff created at 2018-06-18 16:08:02

Sorry, I just noticed a whitespace issue that I need to fix later.


---

Comment by zgershkoff created at 2018-06-18 16:08:02

Changing status from needs_review to needs_work.


---

Comment by git created at 2018-06-19 03:04:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zgershkoff created at 2018-06-19 03:06:44

Changing status from needs_work to needs_review.


---

Comment by git created at 2018-06-22 03:45:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-09-18 03:03:08

I've mostly made my way though this, and overall it seemed good. However, there was a serious bug in `_translate_matching` that I fixed about how the matching was handled. The input for `matching` was expecting a dict whose values where elements of `set_labels`, not the normalized `self._set_labels`. So when pickling, it was raising an error.

I've tweaked the doc in a few places for Sage's convention and tried to improve the speed by using a bunch of Cython tricks I've learned. I did not run any specific timings, but the C code generally looks cleaner.
----
New commits:


---

Comment by chapoton created at 2018-12-01 15:06:39

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2018-12-01 15:06:39

branch is red
