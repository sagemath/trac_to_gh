# Issue 19225: LinearCode.is_projective

Issue created by migration from Trac.

Original creator: ncohen

Original creation time: 2015-10-23 12:21:30

CC:  jsrn dlucas dimpase

As the title says, this branch adds a very short function to LinearCode.

Nathann


---

Comment by ncohen created at 2015-10-23 12:22:00

New commits:


---

Comment by ncohen created at 2015-10-23 12:22:00

Changing status from new to needs_review.


---

Comment by was created at 2015-10-23 18:28:43

Typo in this line: "[BS11] E, Byrne and A. Sneyd,".  It should be "[BS11] E. Byrne and A. Sneyd"


---

Comment by git created at 2015-10-23 18:35:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-10-23 19:45:30

One simplification: Since your matrix has coefficient in a field, you can always normalize the rows. For each of them, choose the first coefficient which is nonzero, let say `a` and multiply your row by `1/a`. It gives a canonical representative of the row. Then, you just have to check that your normalized columns are distinct.

There might be already some code to do that somewhere... let me check.


---

Comment by ncohen created at 2015-10-23 19:46:29

> One simplification: Since your matrix has coefficient in a field

Why could I assume that the base ring is a field?

Nathann


---

Comment by vdelecroix created at 2015-10-23 19:49:41

Until you review #6452, they will be...


---

Comment by ncohen created at 2015-10-23 19:57:58

I do not understand, could you say explicitly why we may be allowed to assume that the base ring is a field?


---

Comment by vdelecroix created at 2015-10-23 20:01:46

Currently in Sage you can only build linear codes over finite fields. The only tentative to generalize it (though only to the rings `ZZ/nZZ`) is #6452. Note that this ticket not add directly a new linear code function but rather focuses on having a nice class for submodules of `(ZZ/nZZ)^r` which is exactly what linear codes are about.

And [wikipedia](https://en.wikipedia.org/wiki/Linear_code) says that linear code are over finite fields.

EDIT: until the last paragraph where it is mentioned that some authors used linear code for code over rings.


---

Comment by vdelecroix created at 2015-10-23 20:05:14

Anyway, you can do

```
if not self.base_ring() in Fields():
    raise NotImplementedError
```

And if your field is `GF(2)` it should even be faster.

Could you also add an example of *non* projective code?


---

Comment by ncohen created at 2015-10-23 20:05:46

The reason why I want to managed general rings is because the paper from which I took the definition (a link appears in the branch) explicitly mention rings. Thus I saw no reason to assume more.

Also, if we do assume that we have fields won't your patch -- that enables general rings for codes -- make this code invalid?

Nathann


---

Comment by ncohen created at 2015-10-23 20:07:07

> Anyway, you can do
> {{{
> if not self.base_ring() in Fields():
>     raise NotImplementedError
> }}}
> And if your field is `GF(2)` it should even be faster.

Why on earth would you ask me to degrade my code to manage fields only, when it is meant to handle general rings and *you* tell me that rings will be supported by LinearCode eventually?

> Could you also add an example of *non* projective code?

If you want.. I have to find one though...

Nathann


---

Comment by vdelecroix created at 2015-10-23 20:10:24

Replying to [comment:11 ncohen]:
> > Anyway, you can do
> > {{{
> > if not self.base_ring() in Fields():
> >     raise NotImplementedError
> > }}}
> > And if your field is `GF(2)` it should even be faster.
> 
> Why on earth would you ask me to degrade my code to manage fields only, when it is meant to handle general rings and *you* tell me that rings will be supported by LinearCode eventually?

Because checking duplicates in a list of size `|size of the field| x nrows` is longer than in a list of size `nrows`.

I have no idea whether linear code over rings will be one day supported... ticket #6452 is just a first step. And I was just mentioning it to make some advertisement. But nobody cares.


---

Comment by ncohen created at 2015-10-23 20:14:24

> Because checking duplicates in a list of size `|size of the field| x nrows` is longer than in a list of size `nrows`.

This is a good justification for a field-specific version of this 5-lines algorithm. Not a justification for not supporting rings at all.

> I have no idea whether linear code over rings will be one day supported... ticket #6452 is just a first step. And I was just mentioning it to make some advertisement. But nobody cares.

I have no idea either, but unless it is written somewhere that we can assume fields only, you won't see me adding a code that assumes more than it should.

Nathann


---

Comment by ncohen created at 2015-10-23 20:28:28

> And I was just mentioning it to make some advertisement. But nobody cares.

Try to advertise it to people who you think should care. I review patches in less than three years, but on the other hand my field is graph theory. I forgot all I ever knew about rings.

About this ticket: it seems that some part of the code 'assumes' that the ring is a field indeed:


```
sage: LinearCode(matrix.ones(IntegerModRing(6),5))
...
NotImplementedError: Echelon form not implemented over 'Ring of integers modulo 6'.
```


Though that is apparently because the 'rank' function is only implemented on fields. This notion exists on rings too, doesn't it? Though I expect that the definition would be pretty nasty `:-/`

'on the paper', however:


```
sage: LinearCode(matrix.ones(IntegerModRing(3),5))
Linear code of length 5, dimension 1 over Ring of integers modulo 3
```


That's cheating, however, for


```
sage: IntegerModRing(3).is_field()
True
```


Nathann


---

Comment by ncohen created at 2015-10-23 20:30:26

All of a sudden, however, I wonder about something... Given that the generator matrix is automatically replaced by a generator matrix with full rank, can this function return anything but 'True'?

Nathann


---

Comment by vdelecroix created at 2015-10-23 21:05:44

Replying to [comment:15 ncohen]:
> All of a sudden, however, I wonder about something... Given that the generator matrix is automatically replaced by a generator matrix with full rank, can this function return anything but 'True'?

Anyway, you should return

```
return len(set(RM)) == M.nrows()
```

to fit with the definition in the paper.


---

Comment by vdelecroix created at 2015-10-23 21:07:40

And then

```
sage: sage: C = codes.LinearCode(matrix(GF(2),[[1,0,1],[1,1,1]]))
sage: sage: C.is_projective()
False
```



---

Comment by ncohen created at 2015-10-23 21:10:29

True. That got lost in the successive workaround of this mutable/immutable mess `>_<`

Nathann


---

Comment by git created at 2015-10-23 21:13:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-10-23 21:40:37

dedicated version for fields at `public/19462-bis`.


---

Comment by jsrn created at 2015-10-23 21:41:12

`LinearCode` is beyond broken for rings. That the object cannot even be constructed is only the tip of the iceberg. The `ZZ/pZZ`-modules that Vincent implemented can form a base of a type of code over ring later on, but that will not inherit from `LinearCode` or `AbstractLinearCode` since there field assumption is everywhere. I don't know how much code sharing will be possible, but I doubt too much non-trivial code.

Also, I don't think it's high on anyone's list of priorities...

I've also been discussing with David to change `LinearCode` so it doesn't
mention rings anymore. It's stupid since they're clearly not supported.

So I agree with Vincent that it's nicer to have code run in linear time rather than quadratic.

Moreover, I don't even think your code is correct over rings. Consider the
following generator matrix over ZZ mod 6:

    [ 1  2  0 ]
    [ 1  2  1 ]

This is clearly not projective since 2*c1 = c2.
But your code would compare

    set([ c1 * (ZZ mod 6) ]) = { (0,0), (1, 1), (2,2), ..., (5,5) }
    set([ c2 * (ZZ mod 6) ]) = { (0,0), (2,2), (4,4) }

Thus the check at the end would succeed, and you return `True`.


---

Comment by vdelecroix created at 2015-10-23 21:49:07

Replying to [comment:21 jsrn]:
> This is clearly not projective since 2*c1 = c2.

In the definition given in reference by Nathann, the condition is that `R c1 != R c2`... but of course, the definition is non-ambiguous over a field.

Vincent


---

Comment by jsrn created at 2015-10-23 22:09:34

Ah, I see. Ok, so the code seems correct then :-)

But that's not what's usually understood by "linearly independent", I believe. If you, Nathann, insist on retaining the ring stuff, I suggest the definition be written out in full in the docstring (noone is going to look up a definition he believes he knows from high school).

Best,
Johan


---

Comment by dimpase created at 2015-10-23 22:51:36

Replying to [comment:23 jsrn]:
> Ah, I see. Ok, so the code seems correct then :-)
> 
> But that's not what's usually understood by "linearly independent", I believe. If you, Nathann, insist on retaining the ring stuff, I suggest the definition be written out in full in the docsring (noone is going to look up a definition he believes he knows from high school).

yeah, I agree - even if one's high school linear algebra virginity has been lost to irresistible charms of commutative algebra, it's still quite unusual definition.


---

Comment by git created at 2015-10-24 05:32:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-10-24 12:26:08

And actually in the reference Nathann gave, they consider codes over non-commutative finite rings! Which is indeed infinitely more general.

Nathann, for this version of the code, since you switched to a field implementation, could you adapt the documentation?


---

Comment by git created at 2015-10-25 07:37:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-25 07:38:37

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2015-10-29 12:24:54

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2015-10-29 12:24:54

Good to go!


---

Comment by ncohen created at 2015-10-29 12:26:50

Thanks,

Nathann


---

Comment by vbraun created at 2015-10-29 16:34:57

Resolution: fixed
