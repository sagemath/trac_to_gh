# Issue 11302: Elliptic curves should be unique parent structures

archive/issues_011302.json:
```json
{
    "body": "Assignee: @JohnCremona\n\nCC:  @JohnCremona @defeo sbesnier jpflori\n\nKeywords: unique parent\n\nWhile elliptic curves are derived from `sage.structure.parent.Parent`, they violate the \"unique parent\" condition:\n\n```\nsage: K = GF(1<<50,'t')\nsage: j = K.random_element()\nsage: from sage.structure.parent import Parent\nsage: isinstance(EllipticCurve(j=j),Parent)\nTrue\nsage: EllipticCurve(j=j) is EllipticCurve(j=j)\nFalse\nsage: EllipticCurve(j=j) == EllipticCurve(j=j)\nTrue \n```\n\nPeople on [sage-nt](http://groups.google.com/group/sage-nt/browse_thread/thread/ec8d0ad14a819082) seem to agree that it is a bug.\n\nIssue created by migration from https://trac.sagemath.org/ticket/11474\n\n",
    "created_at": "2011-06-14T06:43:14Z",
    "labels": [
        "component: elliptic curves",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.3",
    "title": "Elliptic curves should be unique parent structures",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11302",
    "user": "https://github.com/simon-king-jena"
}
```
Assignee: @JohnCremona

CC:  @JohnCremona @defeo sbesnier jpflori

Keywords: unique parent

While elliptic curves are derived from `sage.structure.parent.Parent`, they violate the "unique parent" condition:

```
sage: K = GF(1<<50,'t')
sage: j = K.random_element()
sage: from sage.structure.parent import Parent
sage: isinstance(EllipticCurve(j=j),Parent)
True
sage: EllipticCurve(j=j) is EllipticCurve(j=j)
False
sage: EllipticCurve(j=j) == EllipticCurve(j=j)
True 
```

People on [sage-nt](http://groups.google.com/group/sage-nt/browse_thread/thread/ec8d0ad14a819082) seem to agree that it is a bug.

Issue created by migration from https://trac.sagemath.org/ticket/11474





---

archive/issue_comments_124456.json:
```json
{
    "body": "My approach is:\n\nA) Let `EllipticCurve_generic` inherit from `UniqueRepresentation`. If I am not mistaken, every other elliptic curve inherits from that, so, that should be fine.\n\nB) The `__init__` methods should be uniform: *All* `__init__` methods should accept precisely one argument, namely an immutable sequence \"ainvs\" (in particular, the underlying field can be obtained from ainvs).\n\nC) By `__classcall__` methods, make sure that the existing ways of constructing an elliptic curve will still work. In particular, it will create the immutable sequence \"ainv\".\n\nOne detail to consider: Sometimes an elliptic curve is taken from the Cremona database (see `sage.schemes.elliptic_curves.ell_rational_field`). The database provides certain attributes. It is possible that an elliptic curve *with the same a-invariant* is already in the cache, ignorant of the additional attributes.\n\nBut the classcall method could very well assign those additional attributes to an elliptic curve found in the cache before returning it. So, it should still work.",
    "created_at": "2011-06-14T09:01:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124456",
    "user": "https://github.com/simon-king-jena"
}
```

My approach is:

A) Let `EllipticCurve_generic` inherit from `UniqueRepresentation`. If I am not mistaken, every other elliptic curve inherits from that, so, that should be fine.

B) The `__init__` methods should be uniform: *All* `__init__` methods should accept precisely one argument, namely an immutable sequence "ainvs" (in particular, the underlying field can be obtained from ainvs).

C) By `__classcall__` methods, make sure that the existing ways of constructing an elliptic curve will still work. In particular, it will create the immutable sequence "ainv".

One detail to consider: Sometimes an elliptic curve is taken from the Cremona database (see `sage.schemes.elliptic_curves.ell_rational_field`). The database provides certain attributes. It is possible that an elliptic curve *with the same a-invariant* is already in the cache, ignorant of the additional attributes.

But the classcall method could very well assign those additional attributes to an elliptic curve found in the cache before returning it. So, it should still work.



---

archive/issue_comments_124457.json:
```json
{
    "body": "Or should perhaps `ProjectiveCurve_generic` already be a unique parent? That's what elliptic curves derive from. Or even `AlgebraicScheme_subscheme`?  How far should one go?",
    "created_at": "2011-06-14T09:04:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124457",
    "user": "https://github.com/simon-king-jena"
}
```

Or should perhaps `ProjectiveCurve_generic` already be a unique parent? That's what elliptic curves derive from. Or even `AlgebraicScheme_subscheme`?  How far should one go?



---

archive/issue_comments_124458.json:
```json
{
    "body": "Make elliptic curves unique parents -- doesn't work yet",
    "created_at": "2011-06-15T13:22:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124458",
    "user": "https://github.com/simon-king-jena"
}
```

Make elliptic curves unique parents -- doesn't work yet



---

archive/issue_comments_124459.json:
```json
{
    "body": "Attachment [trac11474_unique_elliptic_curves.patch](tarball://root/attachments/some-uuid/ticket11474/trac11474_unique_elliptic_curves.patch) by @simon-king-jena created at 2011-06-15 13:22:58\n\ndoctest log",
    "created_at": "2011-06-15T13:22:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124459",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac11474_unique_elliptic_curves.patch](tarball://root/attachments/some-uuid/ticket11474/trac11474_unique_elliptic_curves.patch) by @simon-king-jena created at 2011-06-15 13:22:58

doctest log



---

archive/issue_comments_124460.json:
```json
{
    "body": "Attachment [test11474.log](tarball://root/attachments/some-uuid/ticket11474/test11474.log) by @simon-king-jena created at 2011-06-15 13:33:13\n\nThe discussion on [sage-nt](http://groups.google.com/group/sage-nt/browse_thread/thread/ec8d0ad14a819082) shows that it is even not clear whether we want elliptic curves to be unique parents (yet).\n\nAnyway, I posted a preliminary patch. There are some doctest failures -- a test log is attached as well.\n\nSome of the errors are easy to understand: Previously, one had a \"Generic morphism\", but with unique parents one has a \"Generic endomorphism\". Others seem more tricky. For example one gets\n\n```\nsage -t  devel/sage/sage/schemes/elliptic_curves/ell_field.py\n// ** nInitExp failed: using Z/2^2\n**********************************************************************\nFile \"/mnt/local/king/SAGE/sage-4.7.rc2/devel/sage-main/sage/schemes/elliptic_curves/ell_field.py\", line 1038\n:\n    sage: E.weierstrass_p(prec=8, algorithm='pari')\nException raised:\n    Traceback (most recent call last):\n      File \"/mnt/local/king/SAGE/sage-4.7.rc2/local/bin/ncadoctest.py\", line 1231, in run_one_test\n        self.run_one_example(test, example, filename, compileflags)\n      File \"/mnt/local/king/SAGE/sage-4.7.rc2/local/bin/sagedoctest.py\", line 38, in run_one_example\n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/mnt/local/king/SAGE/sage-4.7.rc2/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_14[7]>\", line 1, in <module>\n        E.weierstrass_p(prec=Integer(8), algorithm='pari')###line 1038:\n    sage: E.weierstrass_p(prec=8, algorithm='pari')\n      File \"/mnt/local/king/SAGE/sage-4.7.rc2/local/lib/python/site-packages/sage/schemes/elliptic_curves/ell\n_field.py\", line 1064, in weierstrass_p\n        return weierstrass_p(self, prec=prec, algorithm=algorithm)\n      File \"/mnt/local/king/SAGE/sage-4.7.rc2/local/lib/python/site-packages/sage/schemes/elliptic_curves/ell_wp.py\", line 141, in weierstrass_p\n        wp = compute_wp_pari(E, prec)\n      File \"/mnt/local/king/SAGE/sage-4.7.rc2/local/lib/python/site-packages/sage/schemes/elliptic_curves/ell_wp.py\", line 168, in compute_wp_pari\n        wpp = ep.ellwp(n=prec)\n    AttributeError: 'dict' object has no attribute 'ellwp'\n```\n\nHence, first there is a (warning or error?) message \"`// ** nInitExp failed: using Z/2^2`\", and then something is a dict that ought to be a completely different object.\n\nOn the bright side, one has the following.\n\nElliptic curves are unique, even when they are created in different ways:\n\n```\nsage: E = EllipticCurve('5077a'); E\nElliptic Curve defined by y^2 + y = x^3 - 7*x + 6 over Rational Field\nsage: E is EllipticCurve('5077a') is EllipticCurve(QQ, E.a_invariants()) is EllipticCurve(j = E.j_invariant())\nTrue\n```\n\nIf an elliptic curve is provided with some custom attribute and the \"same\" curve is found in the database with different attributes, then one has no uniqueness of parents; this is in order to prevent the database from overriding stuff that the user has computed:\n\n```\nsage: E = EllipticCurve([0, 1, 1, -2, 0])\nsage: E is EllipticCurve('389a')\nTrue\nsage: E._EllipticCurve_rational_field__cremona_label = 'bogus'\nsage: E is EllipticCurve('389a')\nFalse\nsage: E.label()\n'bogus'\nsage: EllipticCurve('389a').label()\n'389a1'\n```\n\nHowever, if the custom attribute is removed, then the data from the database are used to provide a value for that attribute:\n\n```\nsage: del E._EllipticCurve_rational_field__cremona_label\nsage: E is EllipticCurve('389a') # uniqueness of parents again\nTrue\n# The label has implicitly been updated\nsage: E._EllipticCurve_rational_field__cremona_label\n'389 a 1'\n```",
    "created_at": "2011-06-15T13:33:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124460",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [test11474.log](tarball://root/attachments/some-uuid/ticket11474/test11474.log) by @simon-king-jena created at 2011-06-15 13:33:13

The discussion on [sage-nt](http://groups.google.com/group/sage-nt/browse_thread/thread/ec8d0ad14a819082) shows that it is even not clear whether we want elliptic curves to be unique parents (yet).

Anyway, I posted a preliminary patch. There are some doctest failures -- a test log is attached as well.

Some of the errors are easy to understand: Previously, one had a "Generic morphism", but with unique parents one has a "Generic endomorphism". Others seem more tricky. For example one gets

```
sage -t  devel/sage/sage/schemes/elliptic_curves/ell_field.py
// ** nInitExp failed: using Z/2^2
**********************************************************************
File "/mnt/local/king/SAGE/sage-4.7.rc2/devel/sage-main/sage/schemes/elliptic_curves/ell_field.py", line 1038
:
    sage: E.weierstrass_p(prec=8, algorithm='pari')
Exception raised:
    Traceback (most recent call last):
      File "/mnt/local/king/SAGE/sage-4.7.rc2/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/mnt/local/king/SAGE/sage-4.7.rc2/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/mnt/local/king/SAGE/sage-4.7.rc2/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_14[7]>", line 1, in <module>
        E.weierstrass_p(prec=Integer(8), algorithm='pari')###line 1038:
    sage: E.weierstrass_p(prec=8, algorithm='pari')
      File "/mnt/local/king/SAGE/sage-4.7.rc2/local/lib/python/site-packages/sage/schemes/elliptic_curves/ell
_field.py", line 1064, in weierstrass_p
        return weierstrass_p(self, prec=prec, algorithm=algorithm)
      File "/mnt/local/king/SAGE/sage-4.7.rc2/local/lib/python/site-packages/sage/schemes/elliptic_curves/ell_wp.py", line 141, in weierstrass_p
        wp = compute_wp_pari(E, prec)
      File "/mnt/local/king/SAGE/sage-4.7.rc2/local/lib/python/site-packages/sage/schemes/elliptic_curves/ell_wp.py", line 168, in compute_wp_pari
        wpp = ep.ellwp(n=prec)
    AttributeError: 'dict' object has no attribute 'ellwp'
```

Hence, first there is a (warning or error?) message "`// ** nInitExp failed: using Z/2^2`", and then something is a dict that ought to be a completely different object.

On the bright side, one has the following.

Elliptic curves are unique, even when they are created in different ways:

```
sage: E = EllipticCurve('5077a'); E
Elliptic Curve defined by y^2 + y = x^3 - 7*x + 6 over Rational Field
sage: E is EllipticCurve('5077a') is EllipticCurve(QQ, E.a_invariants()) is EllipticCurve(j = E.j_invariant())
True
```

If an elliptic curve is provided with some custom attribute and the "same" curve is found in the database with different attributes, then one has no uniqueness of parents; this is in order to prevent the database from overriding stuff that the user has computed:

```
sage: E = EllipticCurve([0, 1, 1, -2, 0])
sage: E is EllipticCurve('389a')
True
sage: E._EllipticCurve_rational_field__cremona_label = 'bogus'
sage: E is EllipticCurve('389a')
False
sage: E.label()
'bogus'
sage: EllipticCurve('389a').label()
'389a1'
```

However, if the custom attribute is removed, then the data from the database are used to provide a value for that attribute:

```
sage: del E._EllipticCurve_rational_field__cremona_label
sage: E is EllipticCurve('389a') # uniqueness of parents again
True
# The label has implicitly been updated
sage: E._EllipticCurve_rational_field__cremona_label
'389 a 1'
```



---

archive/issue_comments_124461.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2011-06-15T13:33:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124461",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_info.



---

archive/issue_events_029848.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11302#event-29848"
}
```



---

archive/issue_events_029849.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11302#event-29849"
}
```



---

archive/issue_events_029850.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11302#event-29850"
}
```



---

archive/issue_comments_124462.json:
```json
{
    "body": "I think this would still be good to fix.  The consensus seems to be that an `EllipticCurve` object should be defined uniquely by its base ring and the coefficients *a*<sub>*i*</sub>, and nothing else.  The datum consisting of the base ring and the Weierstrass coefficients is \"enough\" in the sense that if these are identical for two given elliptic curves, then there is a canonical isomorphism between them.\n\nHowever, in the `sage-nt` discussion linked to above, there was some discussion about situations like the following.  The user creates an elliptic curve *E* (say over **Q**) without using Cremona's database, and computes generators for its Mordell-Weil group.  Now he later tries to load the same curve from the database, but the generators don't agree.  Should the two curves be identical or not?\n\nIntuitively, I would say they *should* be identical; the fact that there is no canonical basis for the MW group does not justify breaking the unique parents convention (equality of parents, as determined by some defining data, implies identity).\n\nOn the question of whether the generators from the database should override the ones computed by the user, I think the answer is no.  The database provides a convenient way to avoid a possibly long computation, but the basis returned by it has no mathematical property that makes it preferred over any other one.\n\nCompare to `NumberField`: it seems strange to call two number fields non-identical if they agree in all respects except that different bases for the unit group have been computed.  (Actually, `NumberField` may be a bad example because the current implementation also uses various other parameters to decide whether to construct a new instance.  The point is that it does *not* take any basis for the unit group into account.)",
    "created_at": "2014-04-07T10:26:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124462",
    "user": "https://github.com/pjbruin"
}
```

I think this would still be good to fix.  The consensus seems to be that an `EllipticCurve` object should be defined uniquely by its base ring and the coefficients *a*<sub>*i*</sub>, and nothing else.  The datum consisting of the base ring and the Weierstrass coefficients is "enough" in the sense that if these are identical for two given elliptic curves, then there is a canonical isomorphism between them.

However, in the `sage-nt` discussion linked to above, there was some discussion about situations like the following.  The user creates an elliptic curve *E* (say over **Q**) without using Cremona's database, and computes generators for its Mordell-Weil group.  Now he later tries to load the same curve from the database, but the generators don't agree.  Should the two curves be identical or not?

Intuitively, I would say they *should* be identical; the fact that there is no canonical basis for the MW group does not justify breaking the unique parents convention (equality of parents, as determined by some defining data, implies identity).

On the question of whether the generators from the database should override the ones computed by the user, I think the answer is no.  The database provides a convenient way to avoid a possibly long computation, but the basis returned by it has no mathematical property that makes it preferred over any other one.

Compare to `NumberField`: it seems strange to call two number fields non-identical if they agree in all respects except that different bases for the unit group have been computed.  (Actually, `NumberField` may be a bad example because the current implementation also uses various other parameters to decide whether to construct a new instance.  The point is that it does *not* take any basis for the unit group into account.)



---

archive/issue_comments_124463.json:
```json
{
    "body": "There is also the related question on whether an elliptic curve *E* itself or the Abelian group of rational points of *E* should be regarded as the parent of the rational points of *E*.  Same question for the (co)domain of isogenies; see #12880.",
    "created_at": "2014-04-07T10:30:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124463",
    "user": "https://github.com/pjbruin"
}
```

There is also the related question on whether an elliptic curve *E* itself or the Abelian group of rational points of *E* should be regarded as the parent of the rational points of *E*.  Same question for the (co)domain of isogenies; see #12880.



---

archive/issue_comments_124464.json:
```json
{
    "body": "Replying to [comment:8 pbruin]:\n> There is also the related question on whether an elliptic curve *E* itself or the Abelian group of rational points of *E* should be regarded as the parent of the rational points of *E*.  Same question for the (co)domain of isogenies; see #12880.\n\n\nWhat happened to the idea of having the MW group as an object different from the elliptic curve? Possibly attaching different representations of it to the same curve? The sage-nt discussion mentions it, but I don't see any trace of it in the patch.\n\nI really like the idea, as I like the general idea of having the Abelian group of (rational?) points as a separate object.\n\nS\u00e9bastien (cc-ed) is working on this (and the related questions with isogenies) for its masters' thesis. If there is a consensus on having a separate object for the Abelian group, I think he will be happy (or at least his advisor will :) to do it and finalize this ticket.",
    "created_at": "2014-04-11T22:45:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124464",
    "user": "https://github.com/defeo"
}
```

Replying to [comment:8 pbruin]:
> There is also the related question on whether an elliptic curve *E* itself or the Abelian group of rational points of *E* should be regarded as the parent of the rational points of *E*.  Same question for the (co)domain of isogenies; see #12880.


What happened to the idea of having the MW group as an object different from the elliptic curve? Possibly attaching different representations of it to the same curve? The sage-nt discussion mentions it, but I don't see any trace of it in the patch.

I really like the idea, as I like the general idea of having the Abelian group of (rational?) points as a separate object.

Sébastien (cc-ed) is working on this (and the related questions with isogenies) for its masters' thesis. If there is a consensus on having a separate object for the Abelian group, I think he will be happy (or at least his advisor will :) to do it and finalize this ticket.



---

archive/issue_comments_124465.json:
```json
{
    "body": "I also like the idea of having a separate object for the group of points.  Then for an elliptic curve E defined over K one could have different point groups for E(K) and for E(L) for extensions L of K.  Magma did that a few years ago and it was very convenient.  I have not thought at all about how to implement it though.\n\nAbout isogeny (c)domains it is not so clear to me.  An isogeny is both a map from one curve to another (preserving the base point), and also a group homomorphism.  If we are going to separate out the curve E from its group(s) E(K), E(L), then should we not keep these separate for isogenies too?",
    "created_at": "2014-04-12T08:20:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124465",
    "user": "https://github.com/JohnCremona"
}
```

I also like the idea of having a separate object for the group of points.  Then for an elliptic curve E defined over K one could have different point groups for E(K) and for E(L) for extensions L of K.  Magma did that a few years ago and it was very convenient.  I have not thought at all about how to implement it though.

About isogeny (c)domains it is not so clear to me.  An isogeny is both a map from one curve to another (preserving the base point), and also a group homomorphism.  If we are going to separate out the curve E from its group(s) E(K), E(L), then should we not keep these separate for isogenies too?



---

archive/issue_comments_124466.json:
```json
{
    "body": "Replying to [comment:11 cremona]:\n> I also like the idea of having a separate object for the group of points.  Then for an elliptic curve E defined over K one could have different point groups for E(K) and for E(L) for extensions L of K.  Magma did that a few years ago and it was very convenient.  I have not thought at all about how to implement it though.\n\nThere is already a very basic class in `sage.schemes.projective_homset`; you can do\n\n```\nsage: E=EllipticCurve('37a1')\nsage: K.<a>=QuadraticField(57)\nsage: E(K)\nAbelian group of points on Elliptic Curve defined by y^2 + y = x^3 + (-1)*x over Number Field in a with defining polynomial x^2 - 57\nsage: type(E(K))\n<class 'sage.schemes.projective.projective_homset.SchemeHomset_points_abelian_variety_field_with_category'>\nsage: P=(0,0)\nsage: E(P) == E(QQ)(P)\nTrue\n```\nWe could create a subclass of `SchemeHomset_points_abelian_variety` for groups of points of elliptic curves, and then separate subclasses of that for  different base fields (rationals, general number fields, finite fields, maybe the complex field, etc.)  Then we could start moving functionality so that `E.rank()` is defined as `E.group_of_points(E.base_field()).rank()`, etc.\n\n(In the above example it looks as if `E(K)` is interpreted as the group of `K`-points of `E.base_extend(K)` rather than as the group of `K`-points of `E`, but this could probably be changed.)\n\n> About isogeny (c)domains it is not so clear to me.  An isogeny is both a map from one curve to another (preserving the base point), and also a group homomorphism.  If we are going to separate out the curve E from its group(s) E(K), E(L), then should we not keep these separate for isogenies too?\n\nYes, I think we should.  To rephrase your point, an isogeny *is* a map f: E -> E' between elliptic curves over a field K (preserving 0), and *induces* group homomorphisms f(L): E(L) -> E'(L) for every extension L/K.  (In categorical language, E determines a functor from K-algebras to Abelian groups, and f determines a morphism [natural transformation] between two such functors.)\n\nOf course, as a Sage user you should still be able to construct a point P from its coordinates (u, v) by typing `P = E(u, v)` as an alternative for `P = E(K)(u, v)`, and likewise you should be able to apply an isogeny f to P by typing either `f(P)` or `f(K)(P)`.",
    "created_at": "2014-04-12T09:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124466",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:11 cremona]:
> I also like the idea of having a separate object for the group of points.  Then for an elliptic curve E defined over K one could have different point groups for E(K) and for E(L) for extensions L of K.  Magma did that a few years ago and it was very convenient.  I have not thought at all about how to implement it though.

There is already a very basic class in `sage.schemes.projective_homset`; you can do

```
sage: E=EllipticCurve('37a1')
sage: K.<a>=QuadraticField(57)
sage: E(K)
Abelian group of points on Elliptic Curve defined by y^2 + y = x^3 + (-1)*x over Number Field in a with defining polynomial x^2 - 57
sage: type(E(K))
<class 'sage.schemes.projective.projective_homset.SchemeHomset_points_abelian_variety_field_with_category'>
sage: P=(0,0)
sage: E(P) == E(QQ)(P)
True
```
We could create a subclass of `SchemeHomset_points_abelian_variety` for groups of points of elliptic curves, and then separate subclasses of that for  different base fields (rationals, general number fields, finite fields, maybe the complex field, etc.)  Then we could start moving functionality so that `E.rank()` is defined as `E.group_of_points(E.base_field()).rank()`, etc.

(In the above example it looks as if `E(K)` is interpreted as the group of `K`-points of `E.base_extend(K)` rather than as the group of `K`-points of `E`, but this could probably be changed.)

> About isogeny (c)domains it is not so clear to me.  An isogeny is both a map from one curve to another (preserving the base point), and also a group homomorphism.  If we are going to separate out the curve E from its group(s) E(K), E(L), then should we not keep these separate for isogenies too?

Yes, I think we should.  To rephrase your point, an isogeny *is* a map f: E -> E' between elliptic curves over a field K (preserving 0), and *induces* group homomorphisms f(L): E(L) -> E'(L) for every extension L/K.  (In categorical language, E determines a functor from K-algebras to Abelian groups, and f determines a morphism [natural transformation] between two such functors.)

Of course, as a Sage user you should still be able to construct a point P from its coordinates (u, v) by typing `P = E(u, v)` as an alternative for `P = E(K)(u, v)`, and likewise you should be able to apply an isogeny f to P by typing either `f(P)` or `f(K)(P)`.



---

archive/issue_comments_124467.json:
```json
{
    "body": "So, if I make it short:\n\n* the idea  would be to generalize the \"abelian_group\" method which is currently only avaible for EC on Galois fields to all the EC in order to have an actual \"AbelianGroup\" in the sage category system (in addition with \"Scheme\"). Hence, the \"non-uniqueness of set of generators\" problem is moved into this \"new\" class of \"Abelian Group of points on EC...\" and it is easy to make EC unique.\n* Moreover, it would be nice to do the same separation between isogenies seen as scheme-morphim and isogenis seen as group-morphim.\n\nAm I right? May I begin to refactoring the code in this way?\n\nI've disscussed today with Luca today and he thinks that would be good to create a new category \"AbelianVarieties\" which require to implement this \"abelian_group\" method. What do you think about that ?",
    "created_at": "2014-04-14T19:06:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124467",
    "user": "https://trac.sagemath.org/admin/accounts/users/sbesnier"
}
```

So, if I make it short:

* the idea  would be to generalize the "abelian_group" method which is currently only avaible for EC on Galois fields to all the EC in order to have an actual "AbelianGroup" in the sage category system (in addition with "Scheme"). Hence, the "non-uniqueness of set of generators" problem is moved into this "new" class of "Abelian Group of points on EC..." and it is easy to make EC unique.
* Moreover, it would be nice to do the same separation between isogenies seen as scheme-morphim and isogenis seen as group-morphim.

Am I right? May I begin to refactoring the code in this way?

I've disscussed today with Luca today and he thinks that would be good to create a new category "AbelianVarieties" which require to implement this "abelian_group" method. What do you think about that ?



---

archive/issue_comments_124468.json:
```json
{
    "body": "Replying to [comment:13 sbesnier]:\n> So, if I make it short:\n> \n> * the idea  would be to generalize the \"abelian_group\" method which is currently only avaible for EC on Galois fields to all the EC in order to have an actual \"AbelianGroup\" in the sage category system (in addition with \"Scheme\"). Hence, the \"non-uniqueness of set of generators\" problem is moved into this \"new\" class of \"Abelian Group of points on EC...\" and it is easy to make EC unique.\n> * Moreover, it would be nice to do the same separation between isogenies seen as scheme-morphim and isogenis seen as group-morphim.\n> \n> Am I right? May I begin to refactoring the code in this way?\n\nI think this sounds like a good plan.  It does have a certain the risk of becoming a big project, so be careful to split it into well-defined steps and to proceed one step at a time.\n\nJust some thoughts about the first of your two points for now.  Before doing any coding, I would say it is essential to have a clear picture of both the mathematical objects and the Sage (or Python) objects representing them, and of the relations between them.  Currently, given an elliptic curve *E* over a field *K*, there are at least three kinds of objects to consider:\n- the Sage object `E` representing the curve itself as a scheme (type `EllipticCurve_rational_field` or similar);\n- the group of points `E(K)` (or more generally `E(L)` for an extension `L` of `K`), which does not care about the group structure but is the parent of (the Sage objects representing the) *K*-rational points of *E* (type `SchemeHomset_points_abelian_variety_field`);\n- if *K* is a finite field, there is also `E.abelian_group()`, which returns an object of type `AdditiveAbelianGroupWrapper`.  This represents the group structure of `E(K)` concretely by returning a product of at most two finite cyclic groups and an embedding of this product into the \"abstract\" group `E(K)` (which in this case is an isomorphism).\nThis looks like the right framework for elliptic curves over number fields as well, since the group of *K*-points is finitely generated.  For general fields (e.g. **C**), it only makes sense to have the first two kinds of objects.  So writing a variant of `E.abelian_group()` for elliptic curves over number fields could be a logical first step.\n\nIn general it is important to find out what functionality is already available, and how much of it you can use.  (Remember that a guiding principle of Sage is \"building the car, not reinventing the wheel\".  This originally refers to the fact that Sage builds on many other pieces of software, but it is also a good general slogan.)\n\n> I've disscussed today with Luca today and he thinks that would be good to create a new category \"AbelianVarieties\" which require to implement this \"abelian_group\" method. What do you think about that ?\n\n\nIt would indeed be nice to have a category of Abelian varieties, but this is probably largely independent of the rest of what you want to do.  The current implementation of `EllipticCurve_finite_field.abelian_group()` does not refer to categories either.  I would guess it is easiest to do the other things first without involving a category of Abelian varieties (in the code; you can of course always keep it in mind as the place where things live mathematically).  If you need to specify a category somewhere, `Schemes(K)` will probably be good enough for now, since this is the category in which elliptic curves over *K* currently live.",
    "created_at": "2014-04-15T22:53:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124468",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:13 sbesnier]:
> So, if I make it short:
> 
> * the idea  would be to generalize the "abelian_group" method which is currently only avaible for EC on Galois fields to all the EC in order to have an actual "AbelianGroup" in the sage category system (in addition with "Scheme"). Hence, the "non-uniqueness of set of generators" problem is moved into this "new" class of "Abelian Group of points on EC..." and it is easy to make EC unique.
> * Moreover, it would be nice to do the same separation between isogenies seen as scheme-morphim and isogenis seen as group-morphim.
> 
> Am I right? May I begin to refactoring the code in this way?

I think this sounds like a good plan.  It does have a certain the risk of becoming a big project, so be careful to split it into well-defined steps and to proceed one step at a time.

Just some thoughts about the first of your two points for now.  Before doing any coding, I would say it is essential to have a clear picture of both the mathematical objects and the Sage (or Python) objects representing them, and of the relations between them.  Currently, given an elliptic curve *E* over a field *K*, there are at least three kinds of objects to consider:
- the Sage object `E` representing the curve itself as a scheme (type `EllipticCurve_rational_field` or similar);
- the group of points `E(K)` (or more generally `E(L)` for an extension `L` of `K`), which does not care about the group structure but is the parent of (the Sage objects representing the) *K*-rational points of *E* (type `SchemeHomset_points_abelian_variety_field`);
- if *K* is a finite field, there is also `E.abelian_group()`, which returns an object of type `AdditiveAbelianGroupWrapper`.  This represents the group structure of `E(K)` concretely by returning a product of at most two finite cyclic groups and an embedding of this product into the "abstract" group `E(K)` (which in this case is an isomorphism).
This looks like the right framework for elliptic curves over number fields as well, since the group of *K*-points is finitely generated.  For general fields (e.g. **C**), it only makes sense to have the first two kinds of objects.  So writing a variant of `E.abelian_group()` for elliptic curves over number fields could be a logical first step.

In general it is important to find out what functionality is already available, and how much of it you can use.  (Remember that a guiding principle of Sage is "building the car, not reinventing the wheel".  This originally refers to the fact that Sage builds on many other pieces of software, but it is also a good general slogan.)

> I've disscussed today with Luca today and he thinks that would be good to create a new category "AbelianVarieties" which require to implement this "abelian_group" method. What do you think about that ?


It would indeed be nice to have a category of Abelian varieties, but this is probably largely independent of the rest of what you want to do.  The current implementation of `EllipticCurve_finite_field.abelian_group()` does not refer to categories either.  I would guess it is easiest to do the other things first without involving a category of Abelian varieties (in the code; you can of course always keep it in mind as the place where things live mathematically).  If you need to specify a category somewhere, `Schemes(K)` will probably be good enough for now, since this is the category in which elliptic curves over *K* currently live.



---

archive/issue_comments_124469.json:
```json
{
    "body": "> - the group of points `E(K)` (or more generally `E(L)` for an extension `L` of `K`), which does not care about the group structure but is the parent of (the Sage objects representing the) *K*-rational points of *E* (type `SchemeHomset_points_abelian_variety_field`);\n> - if *K* is a finite field, there is also `E.abelian_group()`, which returns an object of type `AdditiveAbelianGroupWrapper`. \n\n\nI haven't dug enough into the way Sage represents groups, but do these two objects need to be different\u202f? If groups in Sage need to have explicitly set generators, then obviously yes: we don't want to compute generators unless the user asks us to.\n\nBut if a group can be represented abstractly (by its elements and an algorithm for the group operation), then it seems to me that these two should be the same, with the generators computed lazily when the user asks for them.",
    "created_at": "2014-04-15T23:05:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124469",
    "user": "https://github.com/defeo"
}
```

> - the group of points `E(K)` (or more generally `E(L)` for an extension `L` of `K`), which does not care about the group structure but is the parent of (the Sage objects representing the) *K*-rational points of *E* (type `SchemeHomset_points_abelian_variety_field`);
> - if *K* is a finite field, there is also `E.abelian_group()`, which returns an object of type `AdditiveAbelianGroupWrapper`. 


I haven't dug enough into the way Sage represents groups, but do these two objects need to be different ? If groups in Sage need to have explicitly set generators, then obviously yes: we don't want to compute generators unless the user asks us to.

But if a group can be represented abstractly (by its elements and an algorithm for the group operation), then it seems to me that these two should be the same, with the generators computed lazily when the user asks for them.



---

archive/issue_comments_124470.json:
```json
{
    "body": "Replying to [comment:15 defeo]:\n> > - the group of points `E(K)` (or more generally `E(L)` for an extension `L` of `K`), which does not care about the group structure but is the parent of (the Sage objects representing the) *K*-rational points of *E* (type `SchemeHomset_points_abelian_variety_field`);\n> > - if *K* is a finite field, there is also `E.abelian_group()`, which returns an object of type `AdditiveAbelianGroupWrapper`. \n \n> \n> I haven't dug enough into the way Sage represents groups, but do these two objects need to be different\u202f? If groups in Sage need to have explicitly set generators, then obviously yes: we don't want to compute generators unless the user asks us to.\n> But if a group can be represented abstractly (by its elements and an algorithm for the group operation), then it seems to me that these two should be the same, with the generators computed lazily when the user asks for them.\n\nBut don't you then run into the same difficulty with unique representation that we now have for elliptic curves, namely caching non-canonical data inside a canonical object?  If you keep the two objects (i.e. the abstract group vs. the generators) separate, then it is clear that the way for the user to remember a choice of generators is to store the result of `E.abelian_group()` as opposed to the result of `E(K)`.\n\nAlso, I would say it is conceptually better to keep them separate, since the `AdditiveAbelianGroupWrapper` is actually not a group at all, but a homomorphism from some \"standard\" Abelian group (product of cyclic groups) to another group, in this case `E(K)`.",
    "created_at": "2014-04-15T23:31:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124470",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:15 defeo]:
> > - the group of points `E(K)` (or more generally `E(L)` for an extension `L` of `K`), which does not care about the group structure but is the parent of (the Sage objects representing the) *K*-rational points of *E* (type `SchemeHomset_points_abelian_variety_field`);
> > - if *K* is a finite field, there is also `E.abelian_group()`, which returns an object of type `AdditiveAbelianGroupWrapper`. 
 
> 
> I haven't dug enough into the way Sage represents groups, but do these two objects need to be different ? If groups in Sage need to have explicitly set generators, then obviously yes: we don't want to compute generators unless the user asks us to.
> But if a group can be represented abstractly (by its elements and an algorithm for the group operation), then it seems to me that these two should be the same, with the generators computed lazily when the user asks for them.

But don't you then run into the same difficulty with unique representation that we now have for elliptic curves, namely caching non-canonical data inside a canonical object?  If you keep the two objects (i.e. the abstract group vs. the generators) separate, then it is clear that the way for the user to remember a choice of generators is to store the result of `E.abelian_group()` as opposed to the result of `E(K)`.

Also, I would say it is conceptually better to keep them separate, since the `AdditiveAbelianGroupWrapper` is actually not a group at all, but a homomorphism from some "standard" Abelian group (product of cyclic groups) to another group, in this case `E(K)`.



---

archive/issue_comments_124471.json:
```json
{
    "body": "I agree with Peter here (we have been discussing these issues in our common room in Warwick).\n\nI particularly want to emphasize that what you have in mind is quite a large project, which needs to be done step by step, with plenty of input from other experienced Sage users who will be greatly affected by such changes (e.g. me!).  Also, be careful that the improved design will not be accompanied by a decrease in efficiency.\n\nSome of what is being proposed here would have been done a lot earlier, but Sage's support for f.g. abelian groups was not good enough in the early days.  As soon as it became good enough it was applied to the simplest of these cases, namely the group of points of an e.c. over a finite field.\n\nWe want to keep separate the abstract abelian group from the concrete realization of it as a set of points, so that we can use generaic abelian group functionality to (for example) compute kernels.  And as well as the easy map from the abstract group to the concrete point set (using known generators) we must also provide the harder map in the reverse direction, which is a form of elliptic logarithm.  This is actually easier in the number field case since we can use canonical heights to express a point as a linear combination of the generators.",
    "created_at": "2014-04-16T08:10:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124471",
    "user": "https://github.com/JohnCremona"
}
```

I agree with Peter here (we have been discussing these issues in our common room in Warwick).

I particularly want to emphasize that what you have in mind is quite a large project, which needs to be done step by step, with plenty of input from other experienced Sage users who will be greatly affected by such changes (e.g. me!).  Also, be careful that the improved design will not be accompanied by a decrease in efficiency.

Some of what is being proposed here would have been done a lot earlier, but Sage's support for f.g. abelian groups was not good enough in the early days.  As soon as it became good enough it was applied to the simplest of these cases, namely the group of points of an e.c. over a finite field.

We want to keep separate the abstract abelian group from the concrete realization of it as a set of points, so that we can use generaic abelian group functionality to (for example) compute kernels.  And as well as the easy map from the abstract group to the concrete point set (using known generators) we must also provide the harder map in the reverse direction, which is a form of elliptic logarithm.  This is actually easier in the number field case since we can use canonical heights to express a point as a linear combination of the generators.



---

archive/issue_comments_124472.json:
```json
{
    "body": "Considering the EC part, we already have almost what we want isn't it?\n\nLet `E=EllipticCurve(whatever)`, we \"only\" have to:\n* make `E` unique : it is already almost done by Simon's patch, although this patch maintains the gens in `E`. Meanwhile, the files had been edited for other reasons; will nevertheless the automatic tools work or might I manually edit the files thanks to the diff in order to reuse Simon's work?\n* turn `E(K)` into an actual group\n* extend the support of `E.abelian_group(K)` when K is a number field (and move the method in E(K)?)\n* move `.rank()`, `.gens()` and other non-canonical methods/attribute to `E.abelian_group(K)\n\nJohn wrote:\n>And as well as the easy map from the abstract group to the concrete point set (using known generators) we must also provide the harder map in the reverse direction, which is a form of elliptic logarithm.\n\n\nI'm not sure to see the point. You would like to have the map `E(K) -> E.abelian_group()` which calculate calculate the generators, and also the map `E.abelian_group() -> E (or E(K)?)` which calculates the a-invariants of E (or anything which determines E uniquely) from the generators?",
    "created_at": "2014-04-16T19:10:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124472",
    "user": "https://trac.sagemath.org/admin/accounts/users/sbesnier"
}
```

Considering the EC part, we already have almost what we want isn't it?

Let `E=EllipticCurve(whatever)`, we "only" have to:
* make `E` unique : it is already almost done by Simon's patch, although this patch maintains the gens in `E`. Meanwhile, the files had been edited for other reasons; will nevertheless the automatic tools work or might I manually edit the files thanks to the diff in order to reuse Simon's work?
* turn `E(K)` into an actual group
* extend the support of `E.abelian_group(K)` when K is a number field (and move the method in E(K)?)
* move `.rank()`, `.gens()` and other non-canonical methods/attribute to `E.abelian_group(K)

John wrote:
>And as well as the easy map from the abstract group to the concrete point set (using known generators) we must also provide the harder map in the reverse direction, which is a form of elliptic logarithm.


I'm not sure to see the point. You would like to have the map `E(K) -> E.abelian_group()` which calculate calculate the generators, and also the map `E.abelian_group() -> E (or E(K)?)` which calculates the a-invariants of E (or anything which determines E uniquely) from the generators?



---

archive/issue_comments_124473.json:
```json
{
    "body": "Replying to [comment:18 sbesnier]:\n> Considering the EC part, we already have almost what we want isn't it?\n> \n> Let `E=EllipticCurve(whatever)`, we \"only\" have to:\n> * make `E` unique : it is already almost done by Simon's patch, although this patch maintains the gens in `E`. Meanwhile, the files had been edited for other reasons; will nevertheless the automatic tools work or might I manually edit the files thanks to the diff in order to reuse Simon's work?\n\n\nDon't use the patch as it is: for a start Sage no longer uses patches but git branches, and also as the patch is 3 years old it certainly will not apply cleanly.  What will be needed is a new git branch based on the current development branch (also known as version 6.2.beta8) onto which the same changes as made by the patch are applied.  You can try to use Sage's methods for converting patches to git branches, but it would be a miracle if that worked on a 3-year-old patch!  If you are nervous, someone else might do this step for you.  Then after committing Simon's changes in the new branch you can add your changes, make a new commit, and everyone will be able to try it out.\n\n>  * turn `E(K)` into an actual group\n>  * extend the support of `E.abelian_group(K)` when K is a number field (and move the method in E(K)?)\n>  * move `.rank()`, `.gens()` and other non-canonical methods/attribute to `E.abelian_group(K)\n \n> \n> John wrote:\n> >And as well as the easy map from the abstract group to the concrete point set (using known generators) we must also provide the harder map in the reverse direction, which is a form of elliptic logarithm.\n\n> \n> I'm not sure to see the point. You would like to have the map `E(K) -> E.abelian_group()` which calculate calculate the generators, and also the map `E.abelian_group() -> E (or E(K)?)` which calculates the a-invariants of E (or anything which determines E uniquely) from the generators?\n\n\nMy point is that somewhere there has to be code which, given a point and known generators, expresses that point as a Z-linear combination of the generators.  Assuming that E.abelian_group was an abstract abelian group, this code would be used in mapping from E(K) to it.\n\n>",
    "created_at": "2014-04-16T19:44:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124473",
    "user": "https://github.com/JohnCremona"
}
```

Replying to [comment:18 sbesnier]:
> Considering the EC part, we already have almost what we want isn't it?
> 
> Let `E=EllipticCurve(whatever)`, we "only" have to:
> * make `E` unique : it is already almost done by Simon's patch, although this patch maintains the gens in `E`. Meanwhile, the files had been edited for other reasons; will nevertheless the automatic tools work or might I manually edit the files thanks to the diff in order to reuse Simon's work?


Don't use the patch as it is: for a start Sage no longer uses patches but git branches, and also as the patch is 3 years old it certainly will not apply cleanly.  What will be needed is a new git branch based on the current development branch (also known as version 6.2.beta8) onto which the same changes as made by the patch are applied.  You can try to use Sage's methods for converting patches to git branches, but it would be a miracle if that worked on a 3-year-old patch!  If you are nervous, someone else might do this step for you.  Then after committing Simon's changes in the new branch you can add your changes, make a new commit, and everyone will be able to try it out.

>  * turn `E(K)` into an actual group
>  * extend the support of `E.abelian_group(K)` when K is a number field (and move the method in E(K)?)
>  * move `.rank()`, `.gens()` and other non-canonical methods/attribute to `E.abelian_group(K)
 
> 
> John wrote:
> >And as well as the easy map from the abstract group to the concrete point set (using known generators) we must also provide the harder map in the reverse direction, which is a form of elliptic logarithm.

> 
> I'm not sure to see the point. You would like to have the map `E(K) -> E.abelian_group()` which calculate calculate the generators, and also the map `E.abelian_group() -> E (or E(K)?)` which calculates the a-invariants of E (or anything which determines E uniquely) from the generators?


My point is that somewhere there has to be code which, given a point and known generators, expresses that point as a Z-linear combination of the generators.  Assuming that E.abelian_group was an abstract abelian group, this code would be used in mapping from E(K) to it.

>



---

archive/issue_comments_124474.json:
```json
{
    "body": "One remark about the approach to follow to make elliptic curves satisfy unique representation: it turns out that there is an important problem with using `UniqueRepresentation` (which Simon's patch introduces) together with caching (which is certainly used by `EllipticCurve`), see https://groups.google.com/forum/#!topic/sage-devel/q5uy_lI11jg.  If I remember correctly, for non-trivial parents it is recommended  to use a `UniqueFactory`, which gives more flexibility than `UniqueRepresentation`.  (I personally also understand `UniqueFactory` better than the `__classcall__()` magic of Simon's patch, but that may be simply because I am too familiar with this part of the internals of Sage.)  Maybe Simon or someone else can elaborate on this point?",
    "created_at": "2014-04-16T22:09:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124474",
    "user": "https://github.com/pjbruin"
}
```

One remark about the approach to follow to make elliptic curves satisfy unique representation: it turns out that there is an important problem with using `UniqueRepresentation` (which Simon's patch introduces) together with caching (which is certainly used by `EllipticCurve`), see https://groups.google.com/forum/#!topic/sage-devel/q5uy_lI11jg.  If I remember correctly, for non-trivial parents it is recommended  to use a `UniqueFactory`, which gives more flexibility than `UniqueRepresentation`.  (I personally also understand `UniqueFactory` better than the `__classcall__()` magic of Simon's patch, but that may be simply because I am too familiar with this part of the internals of Sage.)  Maybe Simon or someone else can elaborate on this point?



---

archive/issue_comments_124475.json:
```json
{
    "body": "I'm trying to gitify Simon's code, but I get heaps of errors when I doctest. They all seem to be the same:\n\n```\n      File \"/home/dfl/sage/local/lib/python2.7/site-packages/sage/databases/cremona.py\", line 873, in elliptic_curve\n        F = EllipticCurve_rational_field.__new__(EllipticCurve_rational_field)\n    TypeError: sage.misc.fast_methods.WithEqualityById.__new__(EllipticCurve_rational_field) is not safe, use sage.structure.parent.Parent.__new__()\n```\n\nDoes anyone understand it?",
    "created_at": "2014-04-18T13:41:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124475",
    "user": "https://github.com/defeo"
}
```

I'm trying to gitify Simon's code, but I get heaps of errors when I doctest. They all seem to be the same:

```
      File "/home/dfl/sage/local/lib/python2.7/site-packages/sage/databases/cremona.py", line 873, in elliptic_curve
        F = EllipticCurve_rational_field.__new__(EllipticCurve_rational_field)
    TypeError: sage.misc.fast_methods.WithEqualityById.__new__(EllipticCurve_rational_field) is not safe, use sage.structure.parent.Parent.__new__()
```

Does anyone understand it?



---

archive/issue_comments_124476.json:
```json
{
    "body": "Replying to [comment:22 defeo]:\n> I'm trying to gitify Simon's code, but I get heaps of errors when I doctest. They all seem to be the same:\n> \n> \n> ```\n>       File \"/home/dfl/sage/local/lib/python2.7/site-packages/sage/databases/cremona.py\", line 873, in elliptic_curve\n>         F = EllipticCurve_rational_field.__new__(EllipticCurve_rational_field)\n>     TypeError: sage.misc.fast_methods.WithEqualityById.__new__(EllipticCurve_rational_field) is not safe, use sage.structure.parent.Parent.__new__()\n> ```\n> \n> Does anyone understand it?\n\n\nNot really, but what it is doing at that point of sage/databases/cremona.py is constructing an elliptic curve from some data such as the label, which causes it to look that up in the database.  What is the state of your local/share/cremona/cremona_mini.db file?  Is it 8537088 bytes?  If not, you could try sage -f elliptic_curves.",
    "created_at": "2014-04-18T14:16:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124476",
    "user": "https://github.com/JohnCremona"
}
```

Replying to [comment:22 defeo]:
> I'm trying to gitify Simon's code, but I get heaps of errors when I doctest. They all seem to be the same:
> 
> 
> ```
>       File "/home/dfl/sage/local/lib/python2.7/site-packages/sage/databases/cremona.py", line 873, in elliptic_curve
>         F = EllipticCurve_rational_field.__new__(EllipticCurve_rational_field)
>     TypeError: sage.misc.fast_methods.WithEqualityById.__new__(EllipticCurve_rational_field) is not safe, use sage.structure.parent.Parent.__new__()
> ```
> 
> Does anyone understand it?


Not really, but what it is doing at that point of sage/databases/cremona.py is constructing an elliptic curve from some data such as the label, which causes it to look that up in the database.  What is the state of your local/share/cremona/cremona_mini.db file?  Is it 8537088 bytes?  If not, you could try sage -f elliptic_curves.



---

archive/issue_comments_124477.json:
```json
{
    "body": "> Not really, but what it is doing at that point of sage/databases/cremona.py is constructing an elliptic curve from some data such as the label, which causes it to look that up in the database.  What is the state of your local/share/cremona/cremona_mini.db file?  Is it 8537088 bytes?  If not, you could try sage -f elliptic_curves.\n\n\nMy cremona_mini.db is up to date. The error doesn't seem related to the database. In a sage shell\n\n```\nsage: from sage.schemes.elliptic_curves.ell_rational_field import EllipticCurve_rational_field\nsage: EllipticCurve_rational_field.__new__(EllipticCurve_rational_field)\n---------------------------------------------------------------------------\n...\nAttributeError: 'EllipticCurve_rational_field' object has no attribute '_EllipticCurve_generic__ainvs'\n```\n\nWith Simon's patch applied (using the `__classcall__` magic all over the place).\n\n```\nsage: from sage.schemes.elliptic_curves.ell_rational_field import EllipticCurve_rational_field\nsage: EllipticCurve_rational_field.__new__(EllipticCurve_rational_field)\n---------------------------------------------------------------------------\n...\nTypeError: sage.misc.fast_methods.WithEqualityById.__new__(EllipticCurve_rational_field) is not safe, use sage.structure.parent.Parent.__new__()\nsage: Parent.__new__(EllipticCurve_rational_field)\n---------------------------------------------------------------------------\n...\nAttributeError: 'EllipticCurve_rational_field' object has no attribute sage: '_EllipticCurve_generic__ainvs'\n```\n\nEither way, I don't understand how this line is supposed to work. I think we need help from Simon, if we want to resurrect his patch.",
    "created_at": "2014-04-18T14:27:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124477",
    "user": "https://github.com/defeo"
}
```

> Not really, but what it is doing at that point of sage/databases/cremona.py is constructing an elliptic curve from some data such as the label, which causes it to look that up in the database.  What is the state of your local/share/cremona/cremona_mini.db file?  Is it 8537088 bytes?  If not, you could try sage -f elliptic_curves.


My cremona_mini.db is up to date. The error doesn't seem related to the database. In a sage shell

```
sage: from sage.schemes.elliptic_curves.ell_rational_field import EllipticCurve_rational_field
sage: EllipticCurve_rational_field.__new__(EllipticCurve_rational_field)
---------------------------------------------------------------------------
...
AttributeError: 'EllipticCurve_rational_field' object has no attribute '_EllipticCurve_generic__ainvs'
```

With Simon's patch applied (using the `__classcall__` magic all over the place).

```
sage: from sage.schemes.elliptic_curves.ell_rational_field import EllipticCurve_rational_field
sage: EllipticCurve_rational_field.__new__(EllipticCurve_rational_field)
---------------------------------------------------------------------------
...
TypeError: sage.misc.fast_methods.WithEqualityById.__new__(EllipticCurve_rational_field) is not safe, use sage.structure.parent.Parent.__new__()
sage: Parent.__new__(EllipticCurve_rational_field)
---------------------------------------------------------------------------
...
AttributeError: 'EllipticCurve_rational_field' object has no attribute sage: '_EllipticCurve_generic__ainvs'
```

Either way, I don't understand how this line is supposed to work. I think we need help from Simon, if we want to resurrect his patch.



---

archive/issue_comments_124478.json:
```json
{
    "body": "pbruin wrote:\n>One remark about the approach to follow to make elliptic curves satisfy unique representation: it turns out that there is an important problem with using UniqueRepresentation (which Simon's patch introduces) together with caching (which is certainly used by EllipticCurve), see \u200bhttps://groups.google.com/forum/#!topic/sage-devel/q5uy_lI11jg. If I remember correctly, for non-trivial parents it is recommended to use a UniqueFactory, which gives more flexibility than UniqueRepresentation. (I personally also understand UniqueFactory better than the __classcall__() magic of Simon's patch, but that may be simply because I am too familiar with this part of the internals of Sage.) Maybe Simon or someone else can elaborate on this point?\n\n\nIf I correctly understand Nils position, it would be better to use a UniqueFactory isn't it and not the UniqueRepresentation ? In that case, is it usefull to gitify this UniqueRepresentation patch ?",
    "created_at": "2014-04-18T14:31:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124478",
    "user": "https://trac.sagemath.org/admin/accounts/users/sbesnier"
}
```

pbruin wrote:
>One remark about the approach to follow to make elliptic curves satisfy unique representation: it turns out that there is an important problem with using UniqueRepresentation (which Simon's patch introduces) together with caching (which is certainly used by EllipticCurve), see ​https://groups.google.com/forum/#!topic/sage-devel/q5uy_lI11jg. If I remember correctly, for non-trivial parents it is recommended to use a UniqueFactory, which gives more flexibility than UniqueRepresentation. (I personally also understand UniqueFactory better than the __classcall__() magic of Simon's patch, but that may be simply because I am too familiar with this part of the internals of Sage.) Maybe Simon or someone else can elaborate on this point?


If I correctly understand Nils position, it would be better to use a UniqueFactory isn't it and not the UniqueRepresentation ? In that case, is it usefull to gitify this UniqueRepresentation patch ?



---

archive/issue_comments_124479.json:
```json
{
    "body": "> If I correctly understand Nils position, it would be better to use a UniqueFactory isn't it and not the UniqueRepresentation ? In that case, is it usefull to gitify this UniqueRepresentation patch ?\n\n\nProbably not. Anyway, I gitified it, thus I'm pushing it, even if it doesn't work. At least, it will be easier to read Simon's proposed changes.\n\nThere were conflicts with #10999 (which is another bug related to uniqueness) in `ell_rational_field.py`. I hopefully merged them correctly.\n\n---\nNew commits:",
    "created_at": "2014-04-18T15:08:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124479",
    "user": "https://github.com/defeo"
}
```

> If I correctly understand Nils position, it would be better to use a UniqueFactory isn't it and not the UniqueRepresentation ? In that case, is it usefull to gitify this UniqueRepresentation patch ?


Probably not. Anyway, I gitified it, thus I'm pushing it, even if it doesn't work. At least, it will be easier to read Simon's proposed changes.

There were conflicts with #10999 (which is another bug related to uniqueness) in `ell_rational_field.py`. I hopefully merged them correctly.

---
New commits:



---

archive/issue_comments_124480.json:
```json
{
    "body": "For what it's worth, there was a similar __new__ issue a long time ago:\n* http://osdir.com/ml/mathematics.sage.devel/2006-09/msg00229.html",
    "created_at": "2014-04-18T15:30:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124480",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

For what it's worth, there was a similar __new__ issue a long time ago:
* http://osdir.com/ml/mathematics.sage.devel/2006-09/msg00229.html



---

archive/issue_comments_124481.json:
```json
{
    "body": "Replying to [comment:20 pbruin]:\n> If I remember correctly, for non-trivial parents it is recommended  to use a `UniqueFactory`, which gives more flexibility than `UniqueRepresentation`.  (I personally also understand `UniqueFactory` better than the `__classcall__()` magic of Simon's patch, but that may be simply because I am too familiar with this part of the internals of Sage.)  Maybe Simon or someone else can elaborate on this point?\n\n\nI don't recall what I did in this patch, and I do not have the bandwith to look at it right now. So, for now I can only try to explain my general point of view to factory versus `CachedRepresentation` versus `UniqueRepresentation` versus `WithEqualityById`.\n\nIf one uses a factory, then one can rather cleanly separate the creation of the cache key from the input data, additional data used to create the object (without being relevant to the cache) and the creation of the object to be returned. What it returns is **not** a unique parent, because comparison and hash is (and can not) be taken care of by the factory. Drawbacks:\n- One needs to write the factory code. At least in trivial cases, `CachedRepresentation` involves less manual work.\n- Suppose you used to have a factory for some parents, but later decide to remove the factory. If you remove the factory from Sage, then old pickles will break, since they rely on the factory being available. This is in contrast to `CachedRepresentation`, where you just need that the class name is preserved: If you remove `CachedRepresentation` from the base classes, then old pickles can still be opened.\n- I think it is not nice that one has to do `MyFancyStuff(args)` to create an object, but then the resulting object is not an instance of `MyFancyStuff`. But that might be a matter of taste.\n\n`CachedRepresentation` is essentially equivalent to using a factory. In particular, it does **not** result in unique parents. Drawbacks:\n- It can not be used on extension classes, since a metaclass is involved (which is not supported by Cython).\n- It does not cleanly separate creation of the cache, additional arguments and object creation. You can write `__classcall(_private)__` so that it does exactly the same as a factory, it can look up stuff in a database, and so on. But the code is less clean and thus more error prone.\n\nSo, at this point, we have some kind of factory, but no uniqueness of parents. In order to add unique parent behaviour, one can simply add `WithEqualityById` to the list of base classes (and make sure that hash and comparison will not be overridden in the sub-class).\n\n`UniqueRepresentation` simply is a ready-made combination of `CachedRepresentation` and `WithEqualityById`, there is nothing more to it.\n\nI hope that these remarks help to assess whether it would be better to use a factory PLUS `WithEqualityById` on elliptic curves, or \"simply\" use `UniqueRepresentation`.",
    "created_at": "2014-04-18T15:32:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124481",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:20 pbruin]:
> If I remember correctly, for non-trivial parents it is recommended  to use a `UniqueFactory`, which gives more flexibility than `UniqueRepresentation`.  (I personally also understand `UniqueFactory` better than the `__classcall__()` magic of Simon's patch, but that may be simply because I am too familiar with this part of the internals of Sage.)  Maybe Simon or someone else can elaborate on this point?


I don't recall what I did in this patch, and I do not have the bandwith to look at it right now. So, for now I can only try to explain my general point of view to factory versus `CachedRepresentation` versus `UniqueRepresentation` versus `WithEqualityById`.

If one uses a factory, then one can rather cleanly separate the creation of the cache key from the input data, additional data used to create the object (without being relevant to the cache) and the creation of the object to be returned. What it returns is **not** a unique parent, because comparison and hash is (and can not) be taken care of by the factory. Drawbacks:
- One needs to write the factory code. At least in trivial cases, `CachedRepresentation` involves less manual work.
- Suppose you used to have a factory for some parents, but later decide to remove the factory. If you remove the factory from Sage, then old pickles will break, since they rely on the factory being available. This is in contrast to `CachedRepresentation`, where you just need that the class name is preserved: If you remove `CachedRepresentation` from the base classes, then old pickles can still be opened.
- I think it is not nice that one has to do `MyFancyStuff(args)` to create an object, but then the resulting object is not an instance of `MyFancyStuff`. But that might be a matter of taste.

`CachedRepresentation` is essentially equivalent to using a factory. In particular, it does **not** result in unique parents. Drawbacks:
- It can not be used on extension classes, since a metaclass is involved (which is not supported by Cython).
- It does not cleanly separate creation of the cache, additional arguments and object creation. You can write `__classcall(_private)__` so that it does exactly the same as a factory, it can look up stuff in a database, and so on. But the code is less clean and thus more error prone.

So, at this point, we have some kind of factory, but no uniqueness of parents. In order to add unique parent behaviour, one can simply add `WithEqualityById` to the list of base classes (and make sure that hash and comparison will not be overridden in the sub-class).

`UniqueRepresentation` simply is a ready-made combination of `CachedRepresentation` and `WithEqualityById`, there is nothing more to it.

I hope that these remarks help to assess whether it would be better to use a factory PLUS `WithEqualityById` on elliptic curves, or "simply" use `UniqueRepresentation`.



---

archive/issue_events_029851.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11302#event-29851"
}
```



---

archive/issue_events_029852.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11302#event-29852"
}
```



---

archive/issue_comments_124482.json:
```json
{
    "body": "There seem to be a lot of other tickets waiting for this one.  It is tagged \"needs info\": what info, and from whom?  What is the status of the branch & commits listed?",
    "created_at": "2014-05-31T14:11:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124482",
    "user": "https://github.com/JohnCremona"
}
```

There seem to be a lot of other tickets waiting for this one.  It is tagged "needs info": what info, and from whom?  What is the status of the branch & commits listed?



---

archive/issue_comments_124483.json:
```json
{
    "body": "I have put \"needs_info\" at some point, because it has not been clear whether we actually want unique parent behaviour for elliptic curves. Peter Bruin has replied something on that question, but I think we never came to a real conclusion.",
    "created_at": "2014-05-31T14:26:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124483",
    "user": "https://github.com/simon-king-jena"
}
```

I have put "needs_info" at some point, because it has not been clear whether we actually want unique parent behaviour for elliptic curves. Peter Bruin has replied something on that question, but I think we never came to a real conclusion.



---

archive/issue_comments_124484.json:
```json
{
    "body": "Thanks.  We need to reach a conclusion while there are other \"needs review\" tickets claiming to depend on this.  I used to know what that meant, but now... it may or may not mean that the branches asking for review include the unreviewed commits here.  For example #12880.",
    "created_at": "2014-05-31T16:26:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124484",
    "user": "https://github.com/JohnCremona"
}
```

Thanks.  We need to reach a conclusion while there are other "needs review" tickets claiming to depend on this.  I used to know what that meant, but now... it may or may not mean that the branches asking for review include the unreviewed commits here.  For example #12880.



---

archive/issue_comments_124485.json:
```json
{
    "body": "Replying to [comment:33 cremona]:\n> Thanks.  We need to reach a conclusion while there are other \"needs review\" tickets claiming to depend on this.  I used to know what that meant, but now... it may or may not mean that the branches asking for review include the unreviewed commits here.  For example #12880.\n  \nI think the other tickets depend on this one in the sense that they need elliptic curves to be unique parents, not in the sense that they already include commits that belong to this ticket.\n\nIn my opinion we should definitely make elliptic curves unique parents.  The question is whether we should use `UniqueRepresentation` or `UniqueFactory` (or a custom cache, but I don't see why that would be needed).  I would personally prefer a `UniqueFactory`, mostly because I think it is more natural and uses less black magic than `UniqueRepresentation` + `__classcall__`, and hence will be easier to understand/extend for other developers.\n\nThe idea is that the `UniqueFactory` is the place where we do all the work related to converting various input data into the 5-tuple of *a*-coefficients.  There are *many* possible input data, for example:\n- *a*-coefficients\n- base ring + *a*-coefficients\n- *c*-coefficients\n- Cremona label\n- base ring + Cremona label\n- *j*-invariant\nThe logic of converting any of these input data into *a*-coefficients is very similar for the various base rings, so it seems best to do it all in one place.  I imagine that the future `UniqueFactory` would do the work of the current (user-level) function `sage.schemes.elliptic_curves.EllipticCurve` plus the handling of Cremona labels, which is currently duplicated [triplicated?] in `EllipticCurve_rational_field`, `EllipticCurve_number_field` and `EllipticCurve_padic_field`.\n\nOf course, whoever implements this in the end has to make the choice how to do it.  Unfortunately I am currently a bit too busy with some research things and don't have a lot of time for it at the moment.",
    "created_at": "2014-05-31T17:46:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124485",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:33 cremona]:
> Thanks.  We need to reach a conclusion while there are other "needs review" tickets claiming to depend on this.  I used to know what that meant, but now... it may or may not mean that the branches asking for review include the unreviewed commits here.  For example #12880.
  
I think the other tickets depend on this one in the sense that they need elliptic curves to be unique parents, not in the sense that they already include commits that belong to this ticket.

In my opinion we should definitely make elliptic curves unique parents.  The question is whether we should use `UniqueRepresentation` or `UniqueFactory` (or a custom cache, but I don't see why that would be needed).  I would personally prefer a `UniqueFactory`, mostly because I think it is more natural and uses less black magic than `UniqueRepresentation` + `__classcall__`, and hence will be easier to understand/extend for other developers.

The idea is that the `UniqueFactory` is the place where we do all the work related to converting various input data into the 5-tuple of *a*-coefficients.  There are *many* possible input data, for example:
- *a*-coefficients
- base ring + *a*-coefficients
- *c*-coefficients
- Cremona label
- base ring + Cremona label
- *j*-invariant
The logic of converting any of these input data into *a*-coefficients is very similar for the various base rings, so it seems best to do it all in one place.  I imagine that the future `UniqueFactory` would do the work of the current (user-level) function `sage.schemes.elliptic_curves.EllipticCurve` plus the handling of Cremona labels, which is currently duplicated [triplicated?] in `EllipticCurve_rational_field`, `EllipticCurve_number_field` and `EllipticCurve_padic_field`.

Of course, whoever implements this in the end has to make the choice how to do it.  Unfortunately I am currently a bit too busy with some research things and don't have a lot of time for it at the moment.



---

archive/issue_comments_124486.json:
```json
{
    "body": "Replying to [comment:34 pbruin]:\n> In my opinion we should definitely make elliptic curves unique parents.  The question is whether we should use `UniqueRepresentation` or `UniqueFactory` (or a custom cache, but I don't see why that would be needed).  I would personally prefer a `UniqueFactory`, mostly because I think it is more natural and uses less black magic than `UniqueRepresentation` + `__classcall__`, and hence will be easier to understand/extend for other developers.\n\n\n... except for the fact that `UniqueFactory` *alone* is not enough to create a unique parent. You need to additionally adapt `__cmp__` etc, and this is what inheritance from `UniqueRepresentation` does on top of `__classcall__`.\n\n> The idea is that the `UniqueFactory` is the place where we do all the work related to converting various input data into the 5-tuple of *a*-coefficients.  There are *many* possible input data, for example:\n> - *a*-coefficients\n> - base ring + *a*-coefficients\n> - *c*-coefficients\n> - Cremona label\n> - base ring + Cremona label\n> - *j*-invariant\n\n\nThis I consider a valid argument for using a factory. But a tad more needs to be done.",
    "created_at": "2014-05-31T17:54:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124486",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:34 pbruin]:
> In my opinion we should definitely make elliptic curves unique parents.  The question is whether we should use `UniqueRepresentation` or `UniqueFactory` (or a custom cache, but I don't see why that would be needed).  I would personally prefer a `UniqueFactory`, mostly because I think it is more natural and uses less black magic than `UniqueRepresentation` + `__classcall__`, and hence will be easier to understand/extend for other developers.


... except for the fact that `UniqueFactory` *alone* is not enough to create a unique parent. You need to additionally adapt `__cmp__` etc, and this is what inheritance from `UniqueRepresentation` does on top of `__classcall__`.

> The idea is that the `UniqueFactory` is the place where we do all the work related to converting various input data into the 5-tuple of *a*-coefficients.  There are *many* possible input data, for example:
> - *a*-coefficients
> - base ring + *a*-coefficients
> - *c*-coefficients
> - Cremona label
> - base ring + Cremona label
> - *j*-invariant


This I consider a valid argument for using a factory. But a tad more needs to be done.



---

archive/issue_comments_124487.json:
```json
{
    "body": "Replying to [comment:35 SimonKing]:\n> Replying to [comment:34 pbruin]:\n> > I would personally prefer a `UniqueFactory`, mostly because I think it is more natural and uses less black magic than `UniqueRepresentation` + `__classcall__`, and hence will be easier to understand/extend for other developers.\n\n> \n> ... except for the fact that `UniqueFactory` *alone* is not enough to create a unique parent. You need to additionally adapt `__cmp__` etc, and this is what inheritance from `UniqueRepresentation` does on top of `__classcall__`.\n  \nSomething that I think you recently clarified to me elsewhere, and which might be worth emphasising here too, is that \"unique parents\" really refers to *two* conditions:\n- equivalent input data (in the sense that we regard the resulting objects as being \"the same\", e.g. *a*-coefficients vs. Cremona label corresponding to the same curve) should result in identical parents;\n- parents should compare equal if and only if they are identical.\nI was thinking about the first point, which is the more difficult one here.  If we end up solving this by implementing a `UniqueFactory`, then the second point can be solved by simply inheriting from `WithEqualityById`, right?",
    "created_at": "2014-05-31T18:27:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124487",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:35 SimonKing]:
> Replying to [comment:34 pbruin]:
> > I would personally prefer a `UniqueFactory`, mostly because I think it is more natural and uses less black magic than `UniqueRepresentation` + `__classcall__`, and hence will be easier to understand/extend for other developers.

> 
> ... except for the fact that `UniqueFactory` *alone* is not enough to create a unique parent. You need to additionally adapt `__cmp__` etc, and this is what inheritance from `UniqueRepresentation` does on top of `__classcall__`.
  
Something that I think you recently clarified to me elsewhere, and which might be worth emphasising here too, is that "unique parents" really refers to *two* conditions:
- equivalent input data (in the sense that we regard the resulting objects as being "the same", e.g. *a*-coefficients vs. Cremona label corresponding to the same curve) should result in identical parents;
- parents should compare equal if and only if they are identical.
I was thinking about the first point, which is the more difficult one here.  If we end up solving this by implementing a `UniqueFactory`, then the second point can be solved by simply inheriting from `WithEqualityById`, right?



---

archive/issue_comments_124488.json:
```json
{
    "body": "Replying to [comment:36 pbruin]:\n> - equivalent input data (in the sense that we regard the resulting objects as being \"the same\", e.g. *a*-coefficients vs. Cremona label corresponding to the same curve) should result in identical parents;\n> - parents should compare equal if and only if they are identical.\n> I was thinking about the first point, which is the more difficult one here.  If we end up solving this by implementing a `UniqueFactory`, then the second point can be solved by simply inheriting from `WithEqualityById`, right?\n\n\nYes.",
    "created_at": "2014-05-31T19:08:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124488",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:36 pbruin]:
> - equivalent input data (in the sense that we regard the resulting objects as being "the same", e.g. *a*-coefficients vs. Cremona label corresponding to the same curve) should result in identical parents;
> - parents should compare equal if and only if they are identical.
> I was thinking about the first point, which is the more difficult one here.  If we end up solving this by implementing a `UniqueFactory`, then the second point can be solved by simply inheriting from `WithEqualityById`, right?


Yes.



---

archive/issue_comments_124489.json:
```json
{
    "body": "Sounds like quite a big job, needing people who know enough about elliptic curves and also enough about UniqueFactories.   Perhaps we can recruit Nils Bruin to help?",
    "created_at": "2014-05-31T19:21:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124489",
    "user": "https://github.com/JohnCremona"
}
```

Sounds like quite a big job, needing people who know enough about elliptic curves and also enough about UniqueFactories.   Perhaps we can recruit Nils Bruin to help?



---

archive/issue_comments_124490.json:
```json
{
    "body": "I have been working on a branch that makes elliptic curves unique using `UniqueFactory`.  It simultaneously cleans up the elliptic curve construction code and the relation of Sage elliptic curves to the data in Cremona's database.\n\nMy approach removes the need for a separate \"database curve\" attached to an elliptic curve over **Q**.  With my branch, an elliptic curve constructed from the database is *identical* to the same curve constructed using Weierstrass coefficients.  Moreover, the curves returned by `E.database_curve()` and `E.minimal_model()` are now identical, and both of them are identical to *E* if *E* is already in canonical minimal form.\n\nI have to add some documentation and will upload my branch soon.  There are unfortunately two remaining doctest failures, which are manifestations of #10665 and #16317.",
    "created_at": "2014-06-23T11:30:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124490",
    "user": "https://github.com/pjbruin"
}
```

I have been working on a branch that makes elliptic curves unique using `UniqueFactory`.  It simultaneously cleans up the elliptic curve construction code and the relation of Sage elliptic curves to the data in Cremona's database.

My approach removes the need for a separate "database curve" attached to an elliptic curve over **Q**.  With my branch, an elliptic curve constructed from the database is *identical* to the same curve constructed using Weierstrass coefficients.  Moreover, the curves returned by `E.database_curve()` and `E.minimal_model()` are now identical, and both of them are identical to *E* if *E* is already in canonical minimal form.

I have to add some documentation and will upload my branch soon.  There are unfortunately two remaining doctest failures, which are manifestations of #10665 and #16317.



---

archive/issue_comments_124491.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2014-06-25T09:38:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124491",
    "user": "https://github.com/pjbruin"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_124492.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-07-16T19:48:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124492",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_124493.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-07-17T13:57:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124493",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_029853.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-07-17T13:57:32Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11302#event-29853"
}
```



---

archive/issue_comments_124494.json:
```json
{
    "body": "Follow-up: #17415.",
    "created_at": "2014-11-28T14:43:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11302#issuecomment-124494",
    "user": "https://github.com/jdemeyer"
}
```

Follow-up: #17415.
