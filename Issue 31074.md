# Issue 31074: Update doc for finitely generated groups: Warn about not normalizing

archive/issues_031074.json:
```json
{
    "body": "CC:  mmarco darij\n\nElements of finitely generated groups may surprise\nan unsuspecting user. Add a warning and workaround the documentation.\n\nrelated ticket\n#31203\n\nIssue created by migration from https://trac.sagemath.org/ticket/31311\n\n",
    "created_at": "2021-01-31T10:42:51Z",
    "labels": [
        "documentation",
        "minor",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Update doc for finitely generated groups: Warn about not normalizing",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31074",
    "user": "guenterrote"
}
```
CC:  mmarco darij

Elements of finitely generated groups may surprise
an unsuspecting user. Add a warning and workaround the documentation.

related ticket
#31203

Issue created by migration from https://trac.sagemath.org/ticket/31311





---

archive/issue_comments_443804.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2021-01-31T10:47:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443804",
    "user": "guenterrote"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_443805.json:
```json
{
    "body": "New commits:",
    "created_at": "2021-01-31T10:47:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443805",
    "user": "guenterrote"
}
```

New commits:



---

archive/issue_comments_443806.json:
```json
{
    "body": "This warning:\n\n```\n.. WARNING::\n\n    Sage does not completely \"normalize\" elements\n    of finitely generated groups.\n    Thus, trying to put group elements into a set or to use them\n    as keys for a dictionary may lead to trouble.\n```\n\nis in contradiction to the warning just before it. If you could normalize the elements, you would have a solution to the word problem. However, the comment suggests that it is possible to do such a normalization.\n\nI would recommend tightening up your explanation of the hash and `==` being inconsistent. In particular, I would just give two elements that are equal and then their hashes being unequal. The \"2\" element set example is also good. Your conclusion, as stated on #31203, that the multiplication table fails because of this is incorrect.\n\nI don't necessarily agree with an explicit recommendation to convert to a permutation group as that only applies when the group is finite. If something is to be written, which I am not sure I think it should be, then I would instead state that instead of a `set` or `dict`, one needs to use a `list`.",
    "created_at": "2021-02-01T01:26:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443806",
    "user": "tscrim"
}
```

This warning:

```
.. WARNING::

    Sage does not completely "normalize" elements
    of finitely generated groups.
    Thus, trying to put group elements into a set or to use them
    as keys for a dictionary may lead to trouble.
```

is in contradiction to the warning just before it. If you could normalize the elements, you would have a solution to the word problem. However, the comment suggests that it is possible to do such a normalization.

I would recommend tightening up your explanation of the hash and `==` being inconsistent. In particular, I would just give two elements that are equal and then their hashes being unequal. The "2" element set example is also good. Your conclusion, as stated on #31203, that the multiplication table fails because of this is incorrect.

I don't necessarily agree with an explicit recommendation to convert to a permutation group as that only applies when the group is finite. If something is to be written, which I am not sure I think it should be, then I would instead state that instead of a `set` or `dict`, one needs to use a `list`.



---

archive/issue_comments_443807.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2021-02-01T01:26:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443807",
    "user": "tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_443808.json:
```json
{
    "body": "Replying to [comment:3 tscrim]:\n> This warning:\n> {{{\n> .. WARNING::\n> \n>     Sage does not completely \"normalize\" elements\n>     of finitely generated groups.\n>     Thus, trying to put group elements into a set or to use them\n>     as keys for a dictionary may lead to trouble.\n> }}}\n> is in contradiction to the warning just before it.\n\nHow about this:\n\n```\n.. WARNING::\n\n    Even if Sage can recognize that the group is finite, it does not\n    completely \"normalize\" elements\n    of finitely generated groups.\n    Thus, trying to put such group elements into a set or to use them\n    as keys for a dictionary may lead to trouble.\n```\n\n\n\n> \n> Your conclusion, as stated on #31203, that the multiplication table fails because of this is incorrect.\n> \n\nThe multiplication table seems to be fixed, so that remark is obsolete.\n\n> I don't necessarily agree with an explicit recommendation to convert to a permutation group as that only applies when the group is finite. If something is to be written, which I am not sure I think it should be, then I would instead state that instead of a `set` or `dict`, one needs to use a `list`.\n\nBut a list is not a replacement for a set or dict, if a set or dict is what I need.\nYes indeed, the recommendation should be conditional on finiteness.\n\nMaybe it should even be explicitly highlighted that elements of the permutation group can be converted back to the free group? This is very useful. Is it already written somewhere?",
    "created_at": "2021-02-02T00:27:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443808",
    "user": "guenterrote"
}
```

Replying to [comment:3 tscrim]:
> This warning:
> {{{
> .. WARNING::
> 
>     Sage does not completely "normalize" elements
>     of finitely generated groups.
>     Thus, trying to put group elements into a set or to use them
>     as keys for a dictionary may lead to trouble.
> }}}
> is in contradiction to the warning just before it.

How about this:

```
.. WARNING::

    Even if Sage can recognize that the group is finite, it does not
    completely "normalize" elements
    of finitely generated groups.
    Thus, trying to put such group elements into a set or to use them
    as keys for a dictionary may lead to trouble.
```



> 
> Your conclusion, as stated on #31203, that the multiplication table fails because of this is incorrect.
> 

The multiplication table seems to be fixed, so that remark is obsolete.

> I don't necessarily agree with an explicit recommendation to convert to a permutation group as that only applies when the group is finite. If something is to be written, which I am not sure I think it should be, then I would instead state that instead of a `set` or `dict`, one needs to use a `list`.

But a list is not a replacement for a set or dict, if a set or dict is what I need.
Yes indeed, the recommendation should be conditional on finiteness.

Maybe it should even be explicitly highlighted that elements of the permutation group can be converted back to the free group? This is very useful. Is it already written somewhere?



---

archive/issue_comments_443809.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-07T02:50:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443809",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_443810.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-07T02:53:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443810",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_443811.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2021-02-07T02:55:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443811",
    "user": "guenterrote"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_443812.json:
```json
{
    "body": "Sorry for taking a while to get to this. I think we are getting close.\n\nReplying to [comment:4 guenterrote]:\n> Replying to [comment:3 tscrim]:\n> > This warning:\n> > {{{\n> > .. WARNING::\n> > \n> >     Sage does not completely \"normalize\" elements\n> >     of finitely generated groups.\n> >     Thus, trying to put group elements into a set or to use them\n> >     as keys for a dictionary may lead to trouble.\n> > }}}\n> > is in contradiction to the warning just before it.\n> \n> How about this:\n> {{{\n> .. WARNING::\n> \n>     Even if Sage can recognize that the group is finite, it does not\n>     completely \"normalize\" elements\n>     of finitely generated groups.\n>     Thus, trying to put such group elements into a set or to use them\n>     as keys for a dictionary may lead to trouble.\n> }}}\n\nThis is better, but I don't really care for it too much. I guess with a confluent rewriting system, you can definite a normalization of an element. However, the finiteness of the group is not the deciding factor, it is that Sage can sometimes recognize when two elements are equal, even in an infinite group:\n\n```\nsage: F.<a,b,c> = FreeGroup() \nsage: G = F / [a^2,b^2,c^2,a*b*c*a*b*c] \nsage: G(a*b*c*a*b*c) == G.one()                                                                                   \nTrue\n```\n\nSo I would rather see something like\n\n```\n.. WARNING::\n\n    Sage can sometimes recognize when two words represent the same\n    element in a finitely presented group. However, there is typically\n    no way to canonically represent the elements. Thus, the hash\n    functions of two elements ``a`` and ``b`` may not be equal even\n    though ``a == b``. Therefore, there could be issues with the\n    elements being used in a `set` or keys of a `dict`.\n```\n\n\n> > I don't necessarily agree with an explicit recommendation to convert to a permutation group as that only applies when the group is finite. If something is to be written, which I am not sure I think it should be, then I would instead state that instead of a `set` or `dict`, one needs to use a `list`.\n> \n> But a list is not a replacement for a set or dict, if a set or dict is what I need.\n> Yes indeed, the recommendation should be conditional on finiteness.\n\nThey can be used to replace them, but you do loose (a lot of) speed. Now that it explicitly says finite groups to use permutation groups, I am happier with it. Since you want to include this (again, I don't think this is necessary), you should also include something to cover infinite groups and state that they can still be used in lists.\n\n> Maybe it should even be explicitly highlighted that elements of the permutation group can be converted back to the free group? This is very useful. Is it already written somewhere?\n\nThat would be something for the permutation group or free group code, not the FPG code.\n\nI think this is an obvious mathematical fact:\n\n```\n+Beware that this conversion to the free group ``F`` is\n+not a one-to-one operation::\n```\n\nSo I don't see the point in including those tests. (It is possible that the FPG is a free group too.)\n\nAlso, please undo this change:\n\n```diff\n-\"\"\"\n-Finitely Presented Groups\n+\"\"\"Finitely Presented Groups\n```\n\nSage's convention is to start on the next line after a `\"\"\"`.\n\nA typo here `regognizes` -> `recognizes`.",
    "created_at": "2021-02-08T00:10:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443812",
    "user": "tscrim"
}
```

Sorry for taking a while to get to this. I think we are getting close.

Replying to [comment:4 guenterrote]:
> Replying to [comment:3 tscrim]:
> > This warning:
> > {{{
> > .. WARNING::
> > 
> >     Sage does not completely "normalize" elements
> >     of finitely generated groups.
> >     Thus, trying to put group elements into a set or to use them
> >     as keys for a dictionary may lead to trouble.
> > }}}
> > is in contradiction to the warning just before it.
> 
> How about this:
> {{{
> .. WARNING::
> 
>     Even if Sage can recognize that the group is finite, it does not
>     completely "normalize" elements
>     of finitely generated groups.
>     Thus, trying to put such group elements into a set or to use them
>     as keys for a dictionary may lead to trouble.
> }}}

This is better, but I don't really care for it too much. I guess with a confluent rewriting system, you can definite a normalization of an element. However, the finiteness of the group is not the deciding factor, it is that Sage can sometimes recognize when two elements are equal, even in an infinite group:

```
sage: F.<a,b,c> = FreeGroup() 
sage: G = F / [a^2,b^2,c^2,a*b*c*a*b*c] 
sage: G(a*b*c*a*b*c) == G.one()                                                                                   
True
```

So I would rather see something like

```
.. WARNING::

    Sage can sometimes recognize when two words represent the same
    element in a finitely presented group. However, there is typically
    no way to canonically represent the elements. Thus, the hash
    functions of two elements ``a`` and ``b`` may not be equal even
    though ``a == b``. Therefore, there could be issues with the
    elements being used in a `set` or keys of a `dict`.
```


> > I don't necessarily agree with an explicit recommendation to convert to a permutation group as that only applies when the group is finite. If something is to be written, which I am not sure I think it should be, then I would instead state that instead of a `set` or `dict`, one needs to use a `list`.
> 
> But a list is not a replacement for a set or dict, if a set or dict is what I need.
> Yes indeed, the recommendation should be conditional on finiteness.

They can be used to replace them, but you do loose (a lot of) speed. Now that it explicitly says finite groups to use permutation groups, I am happier with it. Since you want to include this (again, I don't think this is necessary), you should also include something to cover infinite groups and state that they can still be used in lists.

> Maybe it should even be explicitly highlighted that elements of the permutation group can be converted back to the free group? This is very useful. Is it already written somewhere?

That would be something for the permutation group or free group code, not the FPG code.

I think this is an obvious mathematical fact:

```
+Beware that this conversion to the free group ``F`` is
+not a one-to-one operation::
```

So I don't see the point in including those tests. (It is possible that the FPG is a free group too.)

Also, please undo this change:

```diff
-"""
-Finitely Presented Groups
+"""Finitely Presented Groups
```

Sage's convention is to start on the next line after a `"""`.

A typo here `regognizes` -> `recognizes`.



---

archive/issue_comments_443813.json:
```json
{
    "body": "Replying to [comment:8 tscrim]:\n> I think this is an obvious mathematical fact:\n> {{{\n> +Beware that this conversion to the free group ``F`` is\n> +not a one-to-one operation::\n> }}}\n> So I don't see the point in including those tests. (It is possible that the FPG is a free group too.)\n> \nBut the previous example, which was there before, performs such a conversion (I only changed the group because otherwise the test `==G.one()` took too long):\n\n\n```\nsage: F(rst_G) == r*s/t\nTrue\n```\n\n\nSo what IS the conversion to F? What is this example trying to show? Is the result `True` merely a coincidence?\n\nOr are elements of finitely generated groups internally represented as elements of the corresponding free groups? And F(..) merely brings out this representation.",
    "created_at": "2021-02-08T01:18:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443813",
    "user": "guenterrote"
}
```

Replying to [comment:8 tscrim]:
> I think this is an obvious mathematical fact:
> {{{
> +Beware that this conversion to the free group ``F`` is
> +not a one-to-one operation::
> }}}
> So I don't see the point in including those tests. (It is possible that the FPG is a free group too.)
> 
But the previous example, which was there before, performs such a conversion (I only changed the group because otherwise the test `==G.one()` took too long):


```
sage: F(rst_G) == r*s/t
True
```


So what IS the conversion to F? What is this example trying to show? Is the result `True` merely a coincidence?

Or are elements of finitely generated groups internally represented as elements of the corresponding free groups? And F(..) merely brings out this representation.



---

archive/issue_comments_443814.json:
```json
{
    "body": "\n```\nsage: F.<r,s,t> = FreeGroup()\nsage: G = F / (r^2, s^3, t^3, r*s*t) # the tetrahedral group\nsage: rr = G([1,1])                                                             \nsage: rr == r*r                                                                 \nFalse\nsage: {rr , r*r}                                                                \n{r^2, r^2}\nsage: hash(rr)                                                                  \n8389048192121911274\nsage: hash(r*r)                                                                 \n8389048192121911274\n```\n\nNow I am totally confused. same hash values but distinct!",
    "created_at": "2021-02-08T01:32:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443814",
    "user": "guenterrote"
}
```


```
sage: F.<r,s,t> = FreeGroup()
sage: G = F / (r^2, s^3, t^3, r*s*t) # the tetrahedral group
sage: rr = G([1,1])                                                             
sage: rr == r*r                                                                 
False
sage: {rr , r*r}                                                                
{r^2, r^2}
sage: hash(rr)                                                                  
8389048192121911274
sage: hash(r*r)                                                                 
8389048192121911274
```

Now I am totally confused. same hash values but distinct!



---

archive/issue_comments_443815.json:
```json
{
    "body": "Replying to [comment:10 guenterrote]:\n> {{{\n> sage: F.<r,s,t> = FreeGroup()\n> sage: G = F / (r^2, s^3, t^3, r*s*t) # the tetrahedral group\n> sage: rr = G([1,1])                                                             \n> sage: rr == r*r                                                                 \n> False\n> sage: {rr , r*r}                                                                \n> {r^2, r^2}\n> sage: hash(rr)                                                                  \n> 8389048192121911274\n> sage: hash(r*r)                                                                 \n> 8389048192121911274\n> }}}\n> Now I am totally confused. same hash values but distinct!\n\nThere is no coercion from F -> G, so the equality cannot be computed:\n\n```\nsage: rr * r\n...\nTypeError: unsupported operand parent(s) for *: 'Finitely presented group < r, s, t | r^2, s^3, t^3, r*s*t >' and 'Free Group on generators {r, s, t}'\n```\n\nI think there should be a coercion from the free group down to the quotient, but that is a separate issue.",
    "created_at": "2021-02-08T01:39:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443815",
    "user": "tscrim"
}
```

Replying to [comment:10 guenterrote]:
> {{{
> sage: F.<r,s,t> = FreeGroup()
> sage: G = F / (r^2, s^3, t^3, r*s*t) # the tetrahedral group
> sage: rr = G([1,1])                                                             
> sage: rr == r*r                                                                 
> False
> sage: {rr , r*r}                                                                
> {r^2, r^2}
> sage: hash(rr)                                                                  
> 8389048192121911274
> sage: hash(r*r)                                                                 
> 8389048192121911274
> }}}
> Now I am totally confused. same hash values but distinct!

There is no coercion from F -> G, so the equality cannot be computed:

```
sage: rr * r
...
TypeError: unsupported operand parent(s) for *: 'Finitely presented group < r, s, t | r^2, s^3, t^3, r*s*t >' and 'Free Group on generators {r, s, t}'
```

I think there should be a coercion from the free group down to the quotient, but that is a separate issue.



---

archive/issue_comments_443816.json:
```json
{
    "body": "Replying to [comment:9 guenterrote]:\n> Replying to [comment:8 tscrim]:\n> > I think this is an obvious mathematical fact:\n> > {{{\n> > +Beware that this conversion to the free group ``F`` is\n> > +not a one-to-one operation::\n> > }}}\n> > So I don't see the point in including those tests. (It is possible that the FPG is a free group too.)\n> > \n> But the previous example, which was there before, performs such a conversion (I only changed the group because otherwise the test `==G.one()` took too long):\n> \n> {{{\n> sage: F(rst_G) == r*s/t\n> True\n> }}}\n> \n> So what IS the conversion to F? What is this example trying to show? Is the result `True` merely a coincidence?\n\nThe conversion to `F` is just treat it like an element in the free group with that word. This example is showing that is what actually happens, that we can make the round trip (as conversions), and that the elements are treated as completely different objects. This is different than showing the conversion is not injective.\n\n> Or are elements of finitely generated groups internally represented as elements of the corresponding free groups? And F(..) merely brings out this representation.\n\nKind of. I would say `F(...)` changes the meaning of that representation; that the word is not in the FPG but the ambient free group.",
    "created_at": "2021-02-08T01:49:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443816",
    "user": "tscrim"
}
```

Replying to [comment:9 guenterrote]:
> Replying to [comment:8 tscrim]:
> > I think this is an obvious mathematical fact:
> > {{{
> > +Beware that this conversion to the free group ``F`` is
> > +not a one-to-one operation::
> > }}}
> > So I don't see the point in including those tests. (It is possible that the FPG is a free group too.)
> > 
> But the previous example, which was there before, performs such a conversion (I only changed the group because otherwise the test `==G.one()` took too long):
> 
> {{{
> sage: F(rst_G) == r*s/t
> True
> }}}
> 
> So what IS the conversion to F? What is this example trying to show? Is the result `True` merely a coincidence?

The conversion to `F` is just treat it like an element in the free group with that word. This example is showing that is what actually happens, that we can make the round trip (as conversions), and that the elements are treated as completely different objects. This is different than showing the conversion is not injective.

> Or are elements of finitely generated groups internally represented as elements of the corresponding free groups? And F(..) merely brings out this representation.

Kind of. I would say `F(...)` changes the meaning of that representation; that the word is not in the FPG but the ambient free group.



---

archive/issue_comments_443817.json:
```json
{
    "body": "Replying to [comment:10 guenterrote]:\n> {{{\n> sage: F.<r,s,t> = FreeGroup()\n> sage: G = F / (r^2, s^3, t^3, r*s*t) # the tetrahedral group\n> sage: rr = G([1,1])                                                             \n> sage: rr == r*r                                                                 \n> False\n> sage: {rr , r*r}                                                                \n> {r^2, r^2}\n> sage: hash(rr)                                                                  \n> 8389048192121911274\n> sage: hash(r*r)                                                                 \n> 8389048192121911274\n> }}}\n> Now I am totally confused. same hash values but distinct!\n\nAh. Same hash is only a necessary condition for being regarded as equal\nin a set. Of course, a `==` test is always performed when there is a hash collision.",
    "created_at": "2021-02-08T01:52:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443817",
    "user": "guenterrote"
}
```

Replying to [comment:10 guenterrote]:
> {{{
> sage: F.<r,s,t> = FreeGroup()
> sage: G = F / (r^2, s^3, t^3, r*s*t) # the tetrahedral group
> sage: rr = G([1,1])                                                             
> sage: rr == r*r                                                                 
> False
> sage: {rr , r*r}                                                                
> {r^2, r^2}
> sage: hash(rr)                                                                  
> 8389048192121911274
> sage: hash(r*r)                                                                 
> 8389048192121911274
> }}}
> Now I am totally confused. same hash values but distinct!

Ah. Same hash is only a necessary condition for being regarded as equal
in a set. Of course, a `==` test is always performed when there is a hash collision.



---

archive/issue_comments_443818.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-08T02:28:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443818",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_443819.json:
```json
{
    "body": "Replying to [comment:8 tscrim]:\n> > But a list is not a replacement for a set or dict, if a set or dict is what I need.\n> \n> They can be used to replace them, but you do loose (a lot of) speed.\n\nAnd I have to program \"by hand\" things that are automatic for sets and dicts.\n\n> Now that it explicitly says finite groups to use permutation groups, I am happier with it. Since you want to include this (again, I don't think this is necessary), you should also include something to cover infinite groups and state that they can still be used in lists.\n\n**Anything** can be put in a list. So I would not dwell on that.",
    "created_at": "2021-02-08T02:36:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443819",
    "user": "guenterrote"
}
```

Replying to [comment:8 tscrim]:
> > But a list is not a replacement for a set or dict, if a set or dict is what I need.
> 
> They can be used to replace them, but you do loose (a lot of) speed.

And I have to program "by hand" things that are automatic for sets and dicts.

> Now that it explicitly says finite groups to use permutation groups, I am happier with it. Since you want to include this (again, I don't think this is necessary), you should also include something to cover infinite groups and state that they can still be used in lists.

**Anything** can be put in a list. So I would not dwell on that.



---

archive/issue_comments_443820.json:
```json
{
    "body": "Replying to [comment:15 guenterrote]:\n> Replying to [comment:8 tscrim]:\n> > > But a list is not a replacement for a set or dict, if a set or dict is what I need.\n> > \n> > They can be used to replace them, but you do loose (a lot of) speed.\n> \n> And I have to program \"by hand\" things that are automatic for sets and dicts.\n> \n\nmaybe there should be a `SlowSet` and `SlowDict` that is based on `==` tests. (But that would be another ticket.)",
    "created_at": "2021-02-08T02:39:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443820",
    "user": "guenterrote"
}
```

Replying to [comment:15 guenterrote]:
> Replying to [comment:8 tscrim]:
> > > But a list is not a replacement for a set or dict, if a set or dict is what I need.
> > 
> > They can be used to replace them, but you do loose (a lot of) speed.
> 
> And I have to program "by hand" things that are automatic for sets and dicts.
> 

maybe there should be a `SlowSet` and `SlowDict` that is based on `==` tests. (But that would be another ticket.)



---

archive/issue_comments_443821.json:
```json
{
    "body": "Replying to [comment:15 guenterrote]:\n> Replying to [comment:8 tscrim]:\n> > > But a list is not a replacement for a set or dict, if a set or dict is what I need.\n> > \n> > They can be used to replace them, but you do loose (a lot of) speed.\n> \n> And I have to program \"by hand\" things that are automatic for sets and dicts.\n\nMost of these are all fairly simple things to implement IMO (and some are already there by default). While there is a code smell from this, there is a mathematical block that cannot be worked around. There is no such thing as a free lunch, but there are multiple kinds of workarounds depending on the use-case.\n\n> > Now that it explicitly says finite groups to use permutation groups, I am happier with it. Since you want to include this (again, I don't think this is necessary), you should also include something to cover infinite groups and state that they can still be used in lists.\n> \n> **Anything** can be put in a list. So I would not dwell on that.\n\nYou are missing the points about `==` and a `list` working as a container object. The point is you can hold a set of objects and check if another element already belongs to it.\n\nI think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary. Here, that is not the case. Instead, it is a manifestation of the fact there is no canonical way to normalize elements. So it is good point out that they may look the same and we can convert back to the free group (which doesn't have to depend on the internal representation of the element), they are otherwise different objects.",
    "created_at": "2021-02-08T03:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443821",
    "user": "tscrim"
}
```

Replying to [comment:15 guenterrote]:
> Replying to [comment:8 tscrim]:
> > > But a list is not a replacement for a set or dict, if a set or dict is what I need.
> > 
> > They can be used to replace them, but you do loose (a lot of) speed.
> 
> And I have to program "by hand" things that are automatic for sets and dicts.

Most of these are all fairly simple things to implement IMO (and some are already there by default). While there is a code smell from this, there is a mathematical block that cannot be worked around. There is no such thing as a free lunch, but there are multiple kinds of workarounds depending on the use-case.

> > Now that it explicitly says finite groups to use permutation groups, I am happier with it. Since you want to include this (again, I don't think this is necessary), you should also include something to cover infinite groups and state that they can still be used in lists.
> 
> **Anything** can be put in a list. So I would not dwell on that.

You are missing the points about `==` and a `list` working as a container object. The point is you can hold a set of objects and check if another element already belongs to it.

I think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary. Here, that is not the case. Instead, it is a manifestation of the fact there is no canonical way to normalize elements. So it is good point out that they may look the same and we can convert back to the free group (which doesn't have to depend on the internal representation of the element), they are otherwise different objects.



---

archive/issue_comments_443822.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2021-02-08T03:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443822",
    "user": "tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_443823.json:
```json
{
    "body": "> \n> I think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary. Here, that is not the case. Instead, it is a manifestation of the fact there is no canonical way to normalize elements. So it is good point out that they may look the same and we can convert back to the free group (which doesn't have to depend on the internal representation of the element), they are otherwise different objects.\n\nI agree that talking about internals should be avoided, but I don't agree that the result does not depend on the internal representation.\n\nThe conversion from \"G\" to \"F\" (referring to the current example) exists in Sage. It is mentioned in one of the examples that are already in the documentation. It is indeed a  triviality that it cannot be a uniquely defined operation in the mathematical sense, but then: What **IS** this conversion?\n\nI think it should be **specified** what F(x) is when x is an element of G, more precisely than saying \"convert from one parent to the other\". Can this be done without talking about the representation?\n\nI am inclined to reinsert the example of F(..) not being one-to-one. Sage *does* provide this conversion even though it\nis mathematically unsound (in the sense that the result depends on the internal representation), and the user should\nbe warned.\n\n(BTW, already the current doc talks about the representation: \"Notice that, even if they are represented in the same way\". In some earlier attempt at \"improving\" the documentation, I changed \"represented\" to \"displayed\", precisely for the reason to avoid talking about the internal representation.",
    "created_at": "2021-02-08T10:49:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443823",
    "user": "guenterrote"
}
```

> 
> I think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary. Here, that is not the case. Instead, it is a manifestation of the fact there is no canonical way to normalize elements. So it is good point out that they may look the same and we can convert back to the free group (which doesn't have to depend on the internal representation of the element), they are otherwise different objects.

I agree that talking about internals should be avoided, but I don't agree that the result does not depend on the internal representation.

The conversion from "G" to "F" (referring to the current example) exists in Sage. It is mentioned in one of the examples that are already in the documentation. It is indeed a  triviality that it cannot be a uniquely defined operation in the mathematical sense, but then: What **IS** this conversion?

I think it should be **specified** what F(x) is when x is an element of G, more precisely than saying "convert from one parent to the other". Can this be done without talking about the representation?

I am inclined to reinsert the example of F(..) not being one-to-one. Sage *does* provide this conversion even though it
is mathematically unsound (in the sense that the result depends on the internal representation), and the user should
be warned.

(BTW, already the current doc talks about the representation: "Notice that, even if they are represented in the same way". In some earlier attempt at "improving" the documentation, I changed "represented" to "displayed", precisely for the reason to avoid talking about the internal representation.



---

archive/issue_comments_443824.json:
```json
{
    "body": "Replying to [comment:17 tscrim]:\n> I think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary.\n\nFor that very reason, I don't want to mention hashes. They ought to be internal details about which the user doesn't have to worry. The user rather worries about sets not working as they should.",
    "created_at": "2021-02-08T11:09:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443824",
    "user": "guenterrote"
}
```

Replying to [comment:17 tscrim]:
> I think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary.

For that very reason, I don't want to mention hashes. They ought to be internal details about which the user doesn't have to worry. The user rather worries about sets not working as they should.



---

archive/issue_comments_443825.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-08T12:15:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443825",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_443826.json:
```json
{
    "body": "Replying to [comment:19 guenterrote]:\n> Replying to [comment:17 tscrim]:\n> > I think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary.\n> \n> For that very reason, I don't want to mention hashes. They ought to be internal details about which the user doesn't have to worry. The user rather worries about sets not working as they should.\n\nHashing is not an (internal) implementation detail but a feature and an important aspect of the code (as your example explicitly points out).",
    "created_at": "2021-02-08T23:18:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443826",
    "user": "tscrim"
}
```

Replying to [comment:19 guenterrote]:
> Replying to [comment:17 tscrim]:
> > I think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary.
> 
> For that very reason, I don't want to mention hashes. They ought to be internal details about which the user doesn't have to worry. The user rather worries about sets not working as they should.

Hashing is not an (internal) implementation detail but a feature and an important aspect of the code (as your example explicitly points out).



---

archive/issue_comments_443827.json:
```json
{
    "body": "Replying to [comment:18 guenterrote]:\n> \n> > \n> > I think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary. Here, that is not the case. Instead, it is a manifestation of the fact there is no canonical way to normalize elements. So it is good point out that they may look the same and we can convert back to the free group (which doesn't have to depend on the internal representation of the element), they are otherwise different objects.\n> \n> I agree that talking about internals should be avoided, but I don't agree that the result does not depend on the internal representation.\n\nThere is a difference between mathematical equality (`==`) and identity (Python `is`). So in `<t|t^2>`, the elements `t^2` and `1` are distinct but equal. Also another subtle point is the difference between the *internal* representation and that instances of elements of a FPG are representatives of some element in the FPG. See also the next paragraph.\n\n> The conversion from \"G\" to \"F\" (referring to the current example) exists in Sage. It is mentioned in one of the examples that are already in the documentation. It is indeed a  triviality that it cannot be a uniquely defined operation in the mathematical sense, but then: What **IS** this conversion?\n\nPerhaps a more formal perspective will help sort this out. We have a set of all words `G` in an (finite) alphabet `A` representing the generators of a free group. A FPG is `G` along with an equivalence relation `==`. Thus the conversion is the natural map from `G -> F` that simply forgets about the equivalence relation.\n\n> I think it should be **specified** what F(x) is when x is an element of G, more precisely than saying \"convert from one parent to the other\". Can this be done without talking about the representation?\n\nOf course, we really want to think of `G` as the quotient, elements up to the equivalence relation. However, we cannot implement it in that way in general. We could rework the implementation for finite groups, but I might be slightly worried about efficiency.\n\n> I am inclined to reinsert the example of F(..) not being one-to-one. Sage *does* provide this conversion even though it\n> is mathematically unsound (in the sense that the result depends on the internal representation), and the user should\n> be warned.\n\nIt does not depend on the *internal* representation, but on the element, which is some word that represents some element in the FPG. Internally we could store the element as a list, a free group element, a `Sequence`, an integer, etc., but that doesn't change that it is a word representing some element in a FPG.\n\n> (BTW, already the current doc talks about the representation: \"Notice that, even if they are represented in the same way\". In some earlier attempt at \"improving\" the documentation, I changed \"represented\" to \"displayed\", precisely for the reason to avoid talking about the internal representation.\n\nI think that actually gets a bit further from the model that is implemented.",
    "created_at": "2021-02-08T23:39:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443827",
    "user": "tscrim"
}
```

Replying to [comment:18 guenterrote]:
> 
> > 
> > I think it is bad practice to talk about the internal implementations in documentation unless it very explicitly is necessary. Here, that is not the case. Instead, it is a manifestation of the fact there is no canonical way to normalize elements. So it is good point out that they may look the same and we can convert back to the free group (which doesn't have to depend on the internal representation of the element), they are otherwise different objects.
> 
> I agree that talking about internals should be avoided, but I don't agree that the result does not depend on the internal representation.

There is a difference between mathematical equality (`==`) and identity (Python `is`). So in `<t|t^2>`, the elements `t^2` and `1` are distinct but equal. Also another subtle point is the difference between the *internal* representation and that instances of elements of a FPG are representatives of some element in the FPG. See also the next paragraph.

> The conversion from "G" to "F" (referring to the current example) exists in Sage. It is mentioned in one of the examples that are already in the documentation. It is indeed a  triviality that it cannot be a uniquely defined operation in the mathematical sense, but then: What **IS** this conversion?

Perhaps a more formal perspective will help sort this out. We have a set of all words `G` in an (finite) alphabet `A` representing the generators of a free group. A FPG is `G` along with an equivalence relation `==`. Thus the conversion is the natural map from `G -> F` that simply forgets about the equivalence relation.

> I think it should be **specified** what F(x) is when x is an element of G, more precisely than saying "convert from one parent to the other". Can this be done without talking about the representation?

Of course, we really want to think of `G` as the quotient, elements up to the equivalence relation. However, we cannot implement it in that way in general. We could rework the implementation for finite groups, but I might be slightly worried about efficiency.

> I am inclined to reinsert the example of F(..) not being one-to-one. Sage *does* provide this conversion even though it
> is mathematically unsound (in the sense that the result depends on the internal representation), and the user should
> be warned.

It does not depend on the *internal* representation, but on the element, which is some word that represents some element in the FPG. Internally we could store the element as a list, a free group element, a `Sequence`, an integer, etc., but that doesn't change that it is a word representing some element in a FPG.

> (BTW, already the current doc talks about the representation: "Notice that, even if they are represented in the same way". In some earlier attempt at "improving" the documentation, I changed "represented" to "displayed", precisely for the reason to avoid talking about the internal representation.

I think that actually gets a bit further from the model that is implemented.



---

archive/issue_comments_443828.json:
```json
{
    "body": "Replying to [comment:22 tscrim]:\n> There is a difference between mathematical equality (`==`) and identity (Python `is`). So in `<t|t^2>`, the elements `t^2` and `1` are distinct but equal.\n\nThis is yet another, completely different story:\n\n\n```\nsage: F = FreeGroup(1)                                                         \nsage: F([1])==F([1])                                                            \nTrue\nsage: F([1]) is F([1])                                                          \nFalse\n```\n\n\nThe Python \"`is`\" comparison is an object-oriented programming-language thing, and nobody expects mathematically meaningful properties from it. That is why Python allows to redefine `__equals__` (or `==`).",
    "created_at": "2021-02-13T12:00:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443828",
    "user": "guenterrote"
}
```

Replying to [comment:22 tscrim]:
> There is a difference between mathematical equality (`==`) and identity (Python `is`). So in `<t|t^2>`, the elements `t^2` and `1` are distinct but equal.

This is yet another, completely different story:


```
sage: F = FreeGroup(1)                                                         
sage: F([1])==F([1])                                                            
True
sage: F([1]) is F([1])                                                          
False
```


The Python "`is`" comparison is an object-oriented programming-language thing, and nobody expects mathematically meaningful properties from it. That is why Python allows to redefine `__equals__` (or `==`).



---

archive/issue_comments_443829.json:
```json
{
    "body": "Replying to [comment:22 tscrim]:\n> > The conversion from \"G\" to \"F\" (referring to the current example) exists in Sage. It is mentioned in one of the examples that are already in the documentation. It is indeed a  triviality that it cannot be a uniquely defined operation in the mathematical sense, but then: What **IS** this conversion?\n> \n> Perhaps a more formal perspective will help sort this out. We have a set of all words `G` in an (finite) alphabet `A` representing the generators of a free group. A FPG is `G` along with an equivalence relation `==`. Thus the conversion is the natural map from `G -> F` that simply forgets about the equivalence relation.\n> \n> > I think it should be **specified** what F(x) is when x is an element of G, more precisely than saying \"convert from one parent to the other\". Can this be done without talking about the representation?\n> \n> Of course, we really want to think of `G` as the quotient, elements up to the equivalence relation. However, we cannot implement it in that way in general. We could rework the implementation for finite groups, but I might be slightly worried about efficiency.\n> \n\n1.) I am not at all proposing to change the implementation. I am proposing to bring the documentation in line with what Sage does.\n\n\n2.) There are several levels of implementation details. a) An element may be represented as a word, and b) a word may be internally represented as a tuple or list or whatever.\n\nThe lower level is indeed irrelevant for the specification, but the first level is important, in this case.\n\n3.) Maybe to some people it is obvious that the elements of an FPG **are** words over the generators (modulo the trivial reductions a<sup>i</sup>*a<sup>j</sup>=a<sup>i+j</sup> and a<sup>0</sup>=1), and the relations are something extra. To other people,  elements of the group **are** equivalence classes of words.\n\nThe `==` test brings out the second interpretation.\n\nSuch different interpretations might cause people to fall into a trap (like me or the original implementors of the `multiplication_table` function), and therefore I find it important to address this in the documentation.\n\nI will try to find some formulations.",
    "created_at": "2021-02-13T12:22:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443829",
    "user": "guenterrote"
}
```

Replying to [comment:22 tscrim]:
> > The conversion from "G" to "F" (referring to the current example) exists in Sage. It is mentioned in one of the examples that are already in the documentation. It is indeed a  triviality that it cannot be a uniquely defined operation in the mathematical sense, but then: What **IS** this conversion?
> 
> Perhaps a more formal perspective will help sort this out. We have a set of all words `G` in an (finite) alphabet `A` representing the generators of a free group. A FPG is `G` along with an equivalence relation `==`. Thus the conversion is the natural map from `G -> F` that simply forgets about the equivalence relation.
> 
> > I think it should be **specified** what F(x) is when x is an element of G, more precisely than saying "convert from one parent to the other". Can this be done without talking about the representation?
> 
> Of course, we really want to think of `G` as the quotient, elements up to the equivalence relation. However, we cannot implement it in that way in general. We could rework the implementation for finite groups, but I might be slightly worried about efficiency.
> 

1.) I am not at all proposing to change the implementation. I am proposing to bring the documentation in line with what Sage does.


2.) There are several levels of implementation details. a) An element may be represented as a word, and b) a word may be internally represented as a tuple or list or whatever.

The lower level is indeed irrelevant for the specification, but the first level is important, in this case.

3.) Maybe to some people it is obvious that the elements of an FPG **are** words over the generators (modulo the trivial reductions a<sup>i</sup>*a<sup>j</sup>=a<sup>i+j</sup> and a<sup>0</sup>=1), and the relations are something extra. To other people,  elements of the group **are** equivalence classes of words.

The `==` test brings out the second interpretation.

Such different interpretations might cause people to fall into a trap (like me or the original implementors of the `multiplication_table` function), and therefore I find it important to address this in the documentation.

I will try to find some formulations.



---

archive/issue_comments_443830.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-02-13T19:51:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443830",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_443831.json:
```json
{
    "body": "I took the occasion to eliminate a few references to `self` from the documentation",
    "created_at": "2021-02-13T19:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443831",
    "user": "guenterrote"
}
```

I took the occasion to eliminate a few references to `self` from the documentation



---

archive/issue_comments_443832.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2021-02-13T19:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443832",
    "user": "guenterrote"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_443833.json:
```json
{
    "body": "Moving to 9.4, as 9.3 has been released.",
    "created_at": "2021-05-10T17:42:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443833",
    "user": "mkoeppe"
}
```

Moving to 9.4, as 9.3 has been released.



---

archive/issue_comments_443834.json:
```json
{
    "body": "Sorry for not being able to work on this recently. Here is a version where I incorporated a number of your changes, but I reworded a few things to try to remove some ambiguities and deal with different perspectives. I also added some things I wanted to see included.\n\nThere is a non-documentation change: I added the coercion from the ambient free group as a way to help remove issues with accidentally not working in the FPG. I am not convinced this actually helps because it blurs the line more between the two groups. Yet, it is in line with polynomial rings:\n\n```\nsage: R.<x,y> = ZZ[]\nsage: Q = R.quo([x^2+y^2])\nsage: Q.has_coerce_map_from(R)\nTrue\n```\n\n----\nNew commits:",
    "created_at": "2021-05-25T00:23:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443834",
    "user": "tscrim"
}
```

Sorry for not being able to work on this recently. Here is a version where I incorporated a number of your changes, but I reworded a few things to try to remove some ambiguities and deal with different perspectives. I also added some things I wanted to see included.

There is a non-documentation change: I added the coercion from the ambient free group as a way to help remove issues with accidentally not working in the FPG. I am not convinced this actually helps because it blurs the line more between the two groups. Yet, it is in line with polynomial rings:

```
sage: R.<x,y> = ZZ[]
sage: Q = R.quo([x^2+y^2])
sage: Q.has_coerce_map_from(R)
True
```

----
New commits:



---

archive/issue_comments_443835.json:
```json
{
    "body": "Setting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443835",
    "user": "mkoeppe"
}
```

Setting a new milestone for this ticket based on a cursory review.



---

archive/issue_comments_443836.json:
```json
{
    "body": "Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.",
    "created_at": "2021-12-18T19:53:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31074",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31074#issuecomment-443836",
    "user": "mkoeppe"
}
```

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.
