# Issue 23640: allow bypassing checks in setpartition

Issue created by migration from https://trac.sagemath.org/ticket/23877

Original creator: mantepse

Original creation time: 2017-09-18 07:26:56




---

Comment by mantepse created at 2017-09-18 07:33:02

Changing type from PLEASE CHANGE to enhancement.


---

Comment by mantepse created at 2017-09-18 07:33:02

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by mantepse created at 2017-09-18 07:33:02

Changing status from new to needs_review.


---

Comment by mantepse created at 2017-09-18 07:37:40

I must admit that I am not at all happy with the speedup, but most of the time is now spent in creating the sets, more precisely, in `Set_object.__init__`.  I am not sure whether this is necessary:

```
sage: l = [D.to_noncrossing_partition() for D in DyckWords(9)]
sage: %prun [SetPartition(p, check=False) for p in l]
         388963 function calls in 5.327 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    24310    3.269    0.000    4.352    0.000 set.py:255(__init__)
    24310    0.726    0.000    0.726    0.000 {hasattr}
    24310    0.232    0.000    0.245    0.000 dynamic_class.py:127(dynamic_class)
    24310    0.206    0.000    4.797    0.000 set.py:88(Set)
    24310    0.173    0.000    4.525    0.000 set.py:733(__init__)
    97240    0.134    0.000    0.134    0.000 {isinstance}
        1    0.109    0.109    5.327    5.327 <string>:1(<module>)
     4862    0.105    0.000    0.239    0.000 {sorted}
     4862    0.063    0.000    4.859    0.001 {map}
    24310    0.057    0.000    0.070    0.000 set.py:864(set)
     4862    0.053    0.000    5.151    0.001 set_partition.py:134(__init__)
    24310    0.052    0.000    0.134    0.000 set.py:796(__iter__)
    24310    0.048    0.000    0.774    0.000 sets_cat.py:950(_element_constructor_)
     4862    0.044    0.000    5.217    0.001 set_partition.py:119(__classcall_private__)
     4862    0.022    0.000    0.022    0.000 set_partition.py:1328(__classcall_private__)
    24310    0.013    0.000    0.013    0.000 {iter}
    24310    0.012    0.000    0.012    0.000 set.py:696(object)
    24310    0.009    0.000    0.009    0.000 {sage.rings.integer.is_Integer}
        1    0.000    0.000    0.000    0.000 vt100_input.py:275(_input_parser_generator)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
```



---

Comment by mantepse created at 2017-09-18 07:40:44

Here is the profile for `Set_object.__init__` - I don't know what `Parent.__init__` is doing:

```
sage: %lprun -f sage.sets.set.Set_object.__init__ [SetPartition(p, check=False) for p in l]
Timer unit: 1e-06 s

Total time: 4.54096 s
File: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/sets/set.py
Function: __init__ at line 255

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   255                                               def __init__(self, X, category=None):
   ...
   278     24310       365197     15.0      8.0          from sage.rings.integer import is_Integer
   279     24310       141019      5.8      3.1          if isinstance(X, integer_types) or is_Integer(X):
   280                                                       # The coercion model will try to call Set_object(0)
   281                                                       raise ValueError('underlying object cannot be an integer')
   282                                           
   283     24310        52419      2.2      1.2          if category is None:
   284                                                       category = Sets()
   285     24310      3897130    160.3     85.8          Parent.__init__(self, category=category)
   286     24310        85191      3.5      1.9          self.__object = X
sage: 
```



---

Comment by SimonKing created at 2017-09-18 08:49:04

If I understand your example correctly, you are creating many parents of a very similar kind. Problem: `Parent.__init__` involves `self._init_category_(category)`, which involves creating the parent class. Granted, it is a dynamic class and thus cached. Looking up the dynamic class in the cache involves formatting a string. It is very little time per parent. But perhaps that's the culprit? The lines

```
    24310    3.269    0.000    4.352    0.000 set.py:255(__init__)
    24310    0.726    0.000    0.726    0.000 {hasattr}
    24310    0.232    0.000    0.245    0.000 dynamic_class.py:127(dynamic_class)
```

seem to indicate it. By the way, can you tell me where `hasattr` is called? It contributes a substantial amount of time, but I cannot locate it.

It could be a solution to create *one* parent, store its class, and then create all new SetPartition instances using `.__new__()` and imitating the other actions of `__init__` (assigning the category to the attribute `._category`, assigning to the attribute `._base` if there is any, assign the generator names if there are any, set the element constructor). Don't forget to take into account `__init_extra__`. And of course it is under the assumption that all parents belong to the same category, otherwise the parent classes were different.


---

Comment by SimonKing created at 2017-09-18 09:39:01

I tried to use `trace("SetPartition([[2,3],[1]], check=False)")` but after few steps trace showed me 
**nothing**! That has never occurred before. Explanation: After the first "s" in the following session, I was hitting return repeatedly, thus, trace should keep stepping through the code.

```
sage: trace("SetPartition([[2,3],[1]], check=False)")
> <string>(1)<module>()

ipdb> 
ipdb> s
--Call--
> /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/combinat/set_partition.py(119)__classcall_private__()
    117         Set partitions
    118     """
--> 119     @staticmethod
    120     def __classcall_private__(cls, parts, check=True):
    121         """

ipdb> 
> /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/combinat/set_partition.py(131)__classcall_private__()
    129             Set partitions
    130         """
--> 131         P = SetPartitions()
    132         return P.element_class(P, parts)
    133 

ipdb> 
--Call--
> /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/combinat/set_partition.py(1328)__classcall_private__()
   1326     - :wikipedia:`Partition_of_a_set`
   1327     """
-> 1328     @staticmethod
   1329     def __classcall_private__(cls, s=None, part=None):
   1330         """

ipdb> 
ipdb> 
ipdb> 
ipdb> 
ipdb> 
ipdb> 
ipdb> quit
```


So, I still don't know in what place "hasattr" is used.


---

Comment by mantepse created at 2017-09-18 10:31:30

Possibly the tracer is confused because `s` denotes a local variable in `__classcall_private__`.  Using `step` instead I find that `hasattr` is used in `ParentMethods._element_constructor_` (line 974 of `sets_cat.py`).

But maybe it's better to profile just `Set([1,2,3])`?


---

Comment by mantepse created at 2017-09-18 10:40:45

Indeed, the profile of just calling `Set` looks very similar:

```
sage: S = Subsets(range(10))
sage: l = [list(S.random_element()) for i in range(1000)]
sage: %prun [Set(b) for b in l]
         11003 function calls in 0.643 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     1000    0.471    0.000    0.583    0.001 set.py:255(__init__)
     1000    0.076    0.000    0.076    0.000 {hasattr}
     1000    0.023    0.000    0.024    0.000 dynamic_class.py:127(dynamic_class)
     1000    0.022    0.000    0.631    0.001 set.py:88(Set)
     1000    0.019    0.000    0.602    0.001 set.py:733(__init__)
     4000    0.014    0.000    0.014    0.000 {isinstance}
        1    0.012    0.012    0.643    0.643 <string>:1(<module>)
     1000    0.005    0.000    0.081    0.000 sets_cat.py:950(_element_constructor_)
     1000    0.001    0.000    0.001    0.000 {sage.rings.integer.is_Integer}
        1    0.000    0.000    0.000    0.000 vt100_input.py:275(_input_parser_generator)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
```



---

Comment by SimonKing created at 2017-09-18 11:02:04

Thank you. I suppose the comment right in front of the parent method should be taken into account: We should find a way to simplify the logic.

Currently, we have for Parent:

```python
    def __init__(...):
        ...
        if element_constructor is None:
            self._set_element_constructor()
        else:
            self._element_constructor = element_constructor
            self._element_init_pass_parent = guess_pass_parent(self, element_constructor)
```

and

```python
    def _set_element_constructor(self):
        """
        This function is used in translating from the old to the new coercion model.
        """
        try: #if hasattr(self, '_element_constructor_'):
            _element_constructor_ = self._element_constructor_
        except (AttributeError, TypeError):
            # Remark: A TypeError can actually occur;
            # it is a possible reason for "hasattr" to return False
            return
        assert callable(_element_constructor_)
        self._element_constructor = _element_constructor_
        self._element_init_pass_parent = guess_pass_parent(self, self._element_constructor)
```

and in the parent methods of `Sets()` we have

```python
        @lazy_attribute
        def _element_constructor_(self):
            if hasattr(self, "element_class"):
                return self._element_constructor_from_element_class
            else:
                return NotImplemented
```

That's quite contorted. `__init__` calls `set_element_constructor` (after initialisation of the category framework, by the way), which tries whether self has the attribute `_element_constructor_`. By virtue of the category framework, self actually has `_element_constructor_ `; if it has this attribute, then it assigns this attribute to an attribute `_element_constructor` without trailing underscore. And the lazy attribute `_element_constructor_` inherited from the categories tries whether self has an `element_class`. This, in turn, is a lazy attribute that (in its default implementation) depends on whether self has the attribute `Element`.

Bizarre. I guess it would be a good idea to open a ticket for it.

By the way: It is simply not true that `_set_element_constructor` "is used in translating from the old to the new coercion model". It is called unless the argument `element_constructor` is passed to `Parent.__init__`, which I guess is very rarely the case.


---

Comment by mantepse created at 2017-09-18 11:10:16

I'm afraid this is now going beyond my skills.  I wouldn't even know how to call the ticket...

I noticed the following in `Parent._init_category_` - no idea whether it's relevant:

```
    def _init_category_(self, category):
        """
        Initialize the category framework

        Most parents initialize their category upon construction, and
        this is the recommended behavior. For example, this happens
        when the constructor calls :meth:`Parent.__init__` directly or
        indirectly. However, some parents defer this for performance
        reasons. For example,
        :mod:`sage.matrix.matrix_space.MatrixSpace` does not.

```


Finally, I just prepared a profile of `dynamic_class`, maybe that's helpful, too:

```
File: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/structure/dynamic_class.py
Function: dynamic_class at line 127

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   127                                           def dynamic_class(name, bases, cls=None, reduction=None, doccls=None,
   128                                                             prepend_cls_bases=True, cache=True):
   ...
   311     10000        90562      9.1     19.0      bases = tuple(bases)
   312                                               #assert(len(bases) > 0 )
   313     10000        46540      4.7      9.8      try:
   314     10000        70064      7.0     14.7          name = str(name)
   315                                               except UnicodeEncodeError:
   316                                                   pass
   317     10000        64202      6.4     13.5      assert(isinstance(name, str))
   318                                               #    assert(cls is None or issubtype(type(cls), type) or type(cls) is classobj)
   319     10000        48504      4.9     10.2      if cache is True:
   320     10000       157171     15.7     32.9          return dynamic_class_internal(name, bases, cls, reduction, doccls, prepend_cls_bases)
   321                                               elif cache is False:
   322                                                   # bypass the cached method
   323                                                   return dynamic_class_internal.f(name, bases, cls, reduction, doccls, prepend_cls_bases)
   324                                               else: # cache = "ignore_reduction"
   325                                                   result = dynamic_class_internal(name, bases, cls, False, doccls, prepend_cls_bases)
   326                                                   if result._reduction is False:
   327                                                       result._reduction = reduction
   328                                                   return result
```



---

Comment by SimonKing created at 2017-09-18 11:16:41

Replying to [comment:10 mantepse]:
> I'm afraid this is now going beyond my skills.  I wouldn't even know how to call the ticket...

That would be for a different ticket. Actually I'd be happy with the speedup you are getting here (50%).


---

Comment by mantepse created at 2017-09-18 11:48:18

OK, could you open the other ticket?  I'll then make #23873 depend of that other ticket...


---

Comment by mantepse created at 2017-09-18 12:12:08

Simon opened #23880 following up the discussion above.


---

Comment by git created at 2017-09-18 13:15:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-09-29 02:09:18

I added the same thing to `_element_constructor_` (the removal of the other case is because it would never happen because of the coercion framework). If my changes look good, then positive review.
----
New commits:


---

Comment by mantepse created at 2017-09-29 07:37:30

Thank you!


---

Comment by mantepse created at 2017-09-29 07:37:30

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-10-01 00:19:01

Resolution: fixed
