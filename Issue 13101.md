# Issue 13101: extension of sage.numerical.optimize.find_fit

Issue created by migration from https://trac.sagemath.org/ticket/13273

Original creator: hackstein

Original creation time: 2012-07-19 15:00:10

Assignee: jason, jkantor

Keywords: fitting, interpolation, two-dimensional

There is no routine in Sage to interpolate points ((x,y),(f_1,f_2))\in\mathbb{R}^{2} \times \mathbb{R}^{2} by an arbitrary class of functions f\colon\mathbb{R}^{2}\to \mathbb{R}^{2} other than splines. Until now, a similar routine exists only for interpolating functions \mathbb{R}^{k} \to \mathbb{R}, called sage.numerical.optimize.find_fit. It seems to me as one could extend the routine "find_fit" to the two-dimensional case with not too much work as the underlying routine scipy.optimize.leastsq (see line 645/655) is not restricted to the one-dimensional case. The new "model" (cp. line 527 ff.) should be a pair of symbolic expressions, of symbolic functions, or of python functions. model has to be a function of the variables '(x_1, x_2)` and free parameters `(a_1, a_2, \ldots, a_l)'.  Thus I want to propose to extend the routine find_fit to the two-dimensional case.


---

Comment by hackstein created at 2012-07-19 15:02:38

Changing assignee from jason, jkantor to hackstein.


---

Comment by hackstein created at 2012-07-24 10:29:30

A first attempt would be the following, but it still needs careful review:

```
def find_fit2dim(data, model, initial_guess = None, parameters = None, variables = None, solution_dict = False):
 r"""
 Finds numerical estimates for the parameters of the two dimensional function model to
 give a best fit to data.


INPUT:

 - ``data`` -- A four dimensional table of floating point numbers of the
 form `[[x_{1,1}, x_{1,2},f_{1,1}, f_{1,2}],
 [x_{2,1}, x_{2,2}, f_{2,1},f_{2,2}],
 \ldots,
 [x_{n,1}, x_{n,2},f_{n,1},f_{n,2}]]` given as a
 numpy array.

 - ``model`` -- Either a pair of symbolic expressions, of symbolic functions, or of
 Python functions. ``model`` has to be a pair of functions of the variables
 `(x_1, x_2, \ldots, x_k)` and free parameters
 `(a_1, a_2, \ldots, a_l)`.

 - ``initial_guess`` -- (default: ``None``) Initial estimate for the
 parameters `(a_1, a_2, \ldots, a_l)`, given as either a list, tuple,
 vector or numpy array. If ``None``, the default estimate for each
 parameter is `1`.

 - ``parameters`` -- (default: ``None``) A list of the parameters
 `(a_1, a_2, \ldots, a_l)`. If model is a symbolic function it is
 ignored, and the free parameters of the symbolic function are used.

 - ``variables`` -- (default: ``None``) A list of the variables
 `(x_1, x_2, \ldots, x_k)`. If model is a symbolic function it is
 ignored, and the variables of the symbolic function are used.

 - ``solution_dict`` -- (default: ``False``) if ``True``, return the
 solution as a dictionary rather than an equation.


EXAMPLES:


ALGORITHM:

Uses ``scipy.optimize.leastsq`` which in turn uses MINPACK's lmdif and
lmder algorithms.
 """
import numpy

 if not isinstance(data, numpy.ndarray):
 try:
data = numpy.array(data, dtype = float)
except (ValueError, TypeError):
 raise TypeError, "data has to be a numpy array"
 elif data.dtype == object:
 raise ValueError, "the entries of data have to be of type float"

 if data.ndim != 4:
 raise ValueError, "data has to be a four dimensional table of floating point numbers"

 from sage.symbolic.expression import Expression

if isinstance(model[1], Expression) and if isinstance(model[2],Expression):
if variables is None:
variables = list(x_1,x_2)
if parameters is None:
parameters = list(Set(list(model[1].variables())+list(model[2].variables())))
for v in variables:
parameters.remove(v)

 if data.shape[1] != len(variables) + 2:
raise ValueError, "each row of data needs %d entries, only %d entries given" % (len(variables) + 2, data.shape[1])

 if parameters is None or len(parameters) == 0 or \
 variables is None or len(variables) == 0:
 raise ValueError, "no variables given"

if initial_guess == None:
initial_guess = len(parameters) * [1]

 if not isinstance(initial_guess, numpy.ndarray):
 try:
initial_guess = numpy.array(initial_guess, dtype = float)
except (ValueError, TypeError):
raise TypeError, "initial_guess has to be a list, tuple, or numpy array"
 elif initial_guess.dtype == object:
 raise ValueError, "the entries of initial_guess have to be of type float"

 if len(initial_guess) != len(parameters):
 raise ValueError, "length of initial_guess does not coincide with the number of parameters"

 if isinstance(model[1], Expression) and if isinstance(model[2], Expression):
 var_list = variables + parameters
var_names = map(str, var_list)
 func = model._fast_float_(*var_names)
else:
func = model

def function(x_data, params):
result = numpy.zeros(len(x_data))
for row in xrange(len(x_data)):
fparams = numpy.hstack((x_data[row], params)).tolist()
result[row] = func(*fparams)
return result

def error_function(params, x_data, y1_data, y2_data):
result = numpy.zeros(len(x_data))
for row in xrange(len(x_data)):
fparams = x_data[row].tolist() + params.tolist()
result[row] = func(*fparams)
return np.array([result[:,-2] - y1_data,result[:,.1]-y2_data])

x_data = data[:, 0:len(variables)]
y1_data = data[:, -2]
y2_data=data[:,-1]

from scipy.optimize import leastsq
estimated_params, d = leastsq(error_function, initial_guess, args = (x_data, y1_data,y2_data))

 if isinstance(estimated_params, float):
estimated_params = [estimated_params]
else:
estimated_params = estimated_params.tolist()

if solution_dict:
dict = {}
for item in zip(parameters, estimated_params):
dict[item[0]] = item[1]
return dict

return [item[0] == item[1] for item in zip(parameters, estimated_params)]
```



---

Comment by hackstein created at 2012-07-25 11:01:41

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2012-07-27 20:39:04

Please fill in your real name as Author.


---

Comment by hackstein created at 2012-07-30 16:28:39

I fixed some errors (see the updated code below), but it still don't fit together with the leastsq routine. Thus any comments and improvement would be highly appreciated as it is my first ticket.

```
def find_fit2dim(data, model, initial_guess=None, parameters=None, variables=None, solution_dict=False):
    r"""
    Finds numerical estimates for the parameters of the two-dimensional function model to
    give a best fit to data.


    INPUT:

    - ``data`` -- A two dimensional table of floating point numbers of the
      form `[[x_{1,1}, x_{1,2},  f_{1,1}, f_{1,2}],
      [x_{2,1}, x_{2,2}, f_{2,1}, f_{2,2}],
      \ldots,
      [x_{n,1}, x_{n,2}, f_{n,1}, f_{n,2}]]` given as either a 
      numpy array.

    - ``model`` -- Either a pair of symbolic expressions, of symbolic functions, or 
      of Python function. ``model`` has to be a function of the variables
      `(x_1, x_2, \ldots, x_k)` and free parameters
      `(a_1, a_2, \ldots, a_l)`.

    - ``initial_guess`` -- (default: ``None``) Initial estimate for the
      parameters `(a_1, a_2, \ldots, a_l)`, given as either a list, tuple,
      vector or numpy array. If ``None``, the default estimate for each
      parameter is `1`.

    - ``parameters`` -- (default: ``None``) A list of the parameters
      `(a_1, a_2, \ldots, a_l)`. If model is a symbolic function it is
      ignored, and the free parameters of the symbolic function are used.

    - ``variables`` -- (default: ``None``) A list of the variables
      `(x_1, x_2, \ldots, x_k)`. If model is a symbolic function it is
      ignored, and the variables of the symbolic function are used.

    - ``solution_dict`` -- (default: ``False``) if ``True``, return the
      solution as a dictionary rather than an equation.


    EXAMPLES:

    

    ALGORITHM: 

    Uses ``scipy.optimize.leastsq`` which in turn uses MINPACK's lmdif and
    lmder algorithms.
    """
    
    import numpy

    if not isinstance(data, numpy.ndarray):
        try:
            data = numpy.array(data, dtype = float)
        except (ValueError, TypeError):
            raise TypeError, "data has to be a numpy array"
    elif data.dtype == object:
        raise ValueError, "the entries of data have to be of type float"

    if data.ndim != 2:
        raise ValueError, "data has to be a two dimensional table of floating point numbers"

    from sage.symbolic.expression import Expression

    if isinstance(model[0], Expression) and isinstance(model[1],Expression):
        if variables is None:
            variables = list(model[0].arguments())
        if parameters is None:
            L=list(model[0].variables())
            M=list(model[1].variables())
            for v in L:
                if v in M:
                    M.remove(v)
            parameters=L+M
    for v in variables:
            parameters.remove(v)

    if data.shape[1] != len(variables) + 2:
        raise ValueError, "each row of data needs %d entries, only %d entries given" % (len(variables) + 2, data.shape[1])

    if parameters is None or len(parameters) == 0 or \
       variables is None or len(variables) == 0:
        raise ValueError, "no variables given"

    if initial_guess == None:
        initial_guess = len(parameters) * [1]

    if not isinstance(initial_guess, numpy.ndarray):
        try:
            initial_guess = numpy.array(initial_guess, dtype = float)
        except (ValueError, TypeError):
            raise TypeError, "initial_guess has to be a list, tuple, or numpy array"
    elif initial_guess.dtype == object:
        raise ValueError, "the entries of initial_guess have to be of type float"

    if len(initial_guess) != len(parameters):
        raise ValueError, "length of initial_guess does not coincide with the number of parameters"

    if isinstance(model[0], Expression) and isinstance(model[1],Expression):
        var_list = variables + parameters
        var_names = map(str, var_list)
        func = (model[0]._fast_float_(*var_names), model[1]._fast_float_(*var_names))
    else:
        func = model

    def function(x1_data, x2_data, params):
        s=(len(x1_data), 2)
        result = numpy.zeros(s)
        for row in xrange(len(x1_data)):
            fparams = numpy.hstack((x1_data[row], x2_data[row],params)).tolist()
            result[row] = (func[0](*fparams),func[1](*fparams))
        return result

    def error_function(params, x1_data, x2_data, y1_data, y2_data):
        t=(len(x1_data),2)
        result = numpy.zeros(t)
        for row in xrange(len(x1_data)):
            fparams = [x1_data[row], x2_data[row]]+ params.tolist()
            result[row]= (func[0](*fparams), func[1](*fparams))
        return numpy.array([result[:,-2] - y1_data, result[:,-1] - y2_data])

    x1_data = data[:, -4]
    x2_data = data[:, -3]  
    y1_data = data[:, -2]
    y2_data = data[:,-1]

    from scipy.optimize import leastsq
    estimated_params, d = leastsq(error_function, initial_guess, args = (x1_data, x2_data, y1_data, y2_data))

    if isinstance(estimated_params, float):
        estimated_params = [estimated_params]
    else:
        estimated_params = estimated_params.tolist()

    if solution_dict:
       dict = {}
       for item in zip(parameters, estimated_params):
           dict[item[0]] = item[1]
       return dict

    return [item[0] == item[1] for item in zip(parameters, estimated_params)]
```



---

Comment by hackstein created at 2012-07-31 16:17:47

It runs through now, but it still needs careful review. Any comments and improvements are very welcome.

```
def find_fit2dim(data, model, initial_guess=None, parameters=None, variables=None, solution_dict=False):
    r"""
    Finds numerical estimates for the parameters of the two-dimensional function model to
    give a best fit to data.


    INPUT:

    - ``data`` -- A two dimensional table of floating point numbers of the
      form `[[x_{1,1}, x_{1,2},  f_{1,1}, f_{1,2}],
      [x_{2,1}, x_{2,2}, f_{2,1}, f_{2,2}],
      \ldots,
      [x_{n,1}, x_{n,2}, f_{n,1}, f_{n,2}]]` given as either a 
      numpy array.

    - ``model`` -- Either a pair of symbolic expressions, of symbolic functions, or 
      of Python function. ``model`` has to be a function of the variables
      `(x_1, x_2, \ldots, x_k)` and free parameters
      `(a_1, a_2, \ldots, a_l)`.

    - ``initial_guess`` -- (default: ``None``) Initial estimate for the
      parameters `(a_1, a_2, \ldots, a_l)`, given as either a list, tuple,
      vector or numpy array. If ``None``, the default estimate for each
      parameter is `1`.

    - ``parameters`` -- (default: ``None``) A list of the parameters
      `(a_1, a_2, \ldots, a_l)`. If model is a symbolic function it is
      ignored, and the free parameters of the symbolic function are used.

    - ``variables`` -- (default: ``None``) A list of the variables
      `(x_1, x_2, \ldots, x_k)`. If model is a symbolic function it is
      ignored, and the variables of the symbolic function are used.

    - ``solution_dict`` -- (default: ``False``) if ``True``, return the
      solution as a dictionary rather than an equation.


    EXAMPLES:
    
    First we create some data points of a function f \colon\R^{2}\to\R^{2}. Let f(x,y)=(x-1,3*y+2)
    
    sage: data=np.array([[1,0,0,2],[1,1,0,5],[2,1,1,5],[2,3,1,11]])
    
    We define a function with free parameters  "a" and "b":    
    sage: model(x,y)=(a+x,b+3*y)
    
    We search for the parameters that give the best fit to the data:
    find_fit2dim(data,model)
    [a == -1.0000000064095422, b == 1.9999999999999998]

    ALGORITHM: 

    Uses ``scipy.optimize.leastsq`` which in turn uses MINPACK's lmdif and
    lmder algorithms.
    """
    
    import numpy

    if not isinstance(data, numpy.ndarray):
        try:
            data = numpy.array(data, dtype = float)
        except (ValueError, TypeError):
            raise TypeError, "data has to be a numpy array"
    elif data.dtype == object:
        raise ValueError, "the entries of data have to be of type float"

    if data.ndim != 2:
        raise ValueError, "data has to be a two dimensional table of floating point numbers"

    from sage.symbolic.expression import Expression

    if isinstance(model[0], Expression) and isinstance(model[1],Expression):
        if variables is None:
            variables = list(model[0].arguments())
        if parameters is None:
            L=list(model[0].variables())
            M=list(model[1].variables())
            for v in L:
                if v in M:
                    M.remove(v)
            parameters=L+M
    for v in variables:
            parameters.remove(v)

    if data.shape[1] != len(variables) + 2:
        raise ValueError, "each row of data needs %d entries, only %d entries given" % (len(variables) + 2, data.shape[1])

    if parameters is None or len(parameters) == 0 or \
       variables is None or len(variables) == 0:
        raise ValueError, "no variables given"

    if initial_guess == None:
        initial_guess = len(parameters) * [1]

    if not isinstance(initial_guess, numpy.ndarray):
        try:
            initial_guess = numpy.array(initial_guess, dtype = float)
        except (ValueError, TypeError):
            raise TypeError, "initial_guess has to be a list, tuple, or numpy array"
    elif initial_guess.dtype == object:
        raise ValueError, "the entries of initial_guess have to be of type float"

    if len(initial_guess) != len(parameters):
        raise ValueError, "length of initial_guess does not coincide with the number of parameters"

    if isinstance(model[0], Expression) and isinstance(model[1],Expression):
        var_list = variables + parameters
        var_names = map(str, var_list)
        func = (model[0]._fast_float_(*var_names), model[1]._fast_float_(*var_names))
    else:
        func = model

    def function(x1_data, x2_data, params):
        s=(len(x1_data), 2)
        result = numpy.zeros(s)
        for row in xrange(len(x1_data)):
            fparams = numpy.hstack((x1_data[row], x2_data[row],params)).tolist()
            result[row] = (func[0](*fparams),func[1](*fparams))
        return result

    def error_function(params, x1_data, x2_data, y1_data, y2_data):
        t=(len(x1_data),2)
        result = numpy.zeros(t)
        result2 = numpy.zeros(len(x1_data))
        for row in xrange(len(x1_data)):
            fparams = [x1_data[row], x2_data[row]]+ params.tolist()
            result[row]= (func[0](*fparams), func[1](*fparams))
            result2[row]=(result[row,-2] - y1_data[row])*(result[row,-2] - y1_data[row])+ (result[row,-1] - y2_data[row])*(result[row,-1] - y2_data[row])
        return result2

    x1_data = data[:, -4]
    x2_data = data[:, -3]  
    y1_data = data[:, -2]
    y2_data = data[:,-1]

    from scipy.optimize import leastsq
    estimated_params, d = leastsq(error_function, initial_guess, args = (x1_data, x2_data, y1_data, y2_data))

    if isinstance(estimated_params, float):
        estimated_params = [estimated_params]
    else:
        estimated_params = estimated_params.tolist()

    if solution_dict:
       dict = {}
       for item in zip(parameters, estimated_params):
           dict[item[0]] = item[1]
       return dict

    return [item[0] == item[1] for item in zip(parameters, estimated_params)]
```



---

Comment by hackstein created at 2012-07-31 16:17:47

Remove assignee hackstein.


---

Comment by knsam created at 2013-02-20 16:18:06

Changing status from needs_review to needs_work.


---

Comment by knsam created at 2013-02-20 16:18:06

As of now, this ticket `needs_work`, as there is still no patch for reviewing. Of course, there is this code, which should be made into mercurial patch, before this can be merged into Sage. I might make a patch with  this code after two weeks or so... when I have more time to play around with. 

~KnS


---

Comment by mkoeppe created at 2021-07-22 01:05:21

Changing status from needs_work to needs_review.


---

Comment by dimpase created at 2021-12-03 09:37:14

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2021-12-03 18:41:01

Resolution: invalid
