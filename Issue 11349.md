# Issue 11349: Memleak when resolving the action of Integers on an Elliptic Curve

archive/issues_011349.json:
```json
{
    "body": "Assignee: @rlmill\n\nCC:  jpflori @nthiery\n\nThe following piece of code leaks memory. \n \n sage: K = GF(1<<55,'t') \n sage: a = K.random_element() \n sage: while 1: \n ....: \u00a0 \u00a0 E = EllipticCurve(j=a); P = E.random_point(); 2*P; \n\nThe problem seems to occur while resolving the action of ZZ on E. \n\nIt does not happen if:\n\n- one does not change the curve in the loop\n\n- does P+P instead of a multiplication\n\nIssue created by migration from https://trac.sagemath.org/ticket/11521\n\n",
    "created_at": "2011-06-18T13:35:27Z",
    "labels": [
        "component: memleak",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.5",
    "title": "Memleak when resolving the action of Integers on an Elliptic Curve",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11349",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```
Assignee: @rlmill

CC:  jpflori @nthiery

The following piece of code leaks memory. 
 
 sage: K = GF(1<<55,'t') 
 sage: a = K.random_element() 
 sage: while 1: 
 ....:     E = EllipticCurve(j=a); P = E.random_point(); 2*P; 

The problem seems to occur while resolving the action of ZZ on E. 

It does not happen if:

- one does not change the curve in the loop

- does P+P instead of a multiplication

Issue created by migration from https://trac.sagemath.org/ticket/11521





---

archive/issue_comments_125215.json:
```json
{
    "body": "After looking at #10548, I might have a better idea of the culprit:\n\n\n```\nsage: import gc\nsage: from sage.schemes.elliptic_curves.ell_finite_field import EllipticCurve_finite_field\nsage: K = GF(1<<60,'t')\nsage: j = K.random_element()\nsage: for i in xrange(100):\n....:     E = EllipticCurve(j=j); P = E.random_point(); 2*P;\n....:     \nsage: gc.collect()\n440\nsage: len([x for x in gc.get_objects() if  isinstance(x,EllipticCurve_finite_field)])\n100\n```\n",
    "created_at": "2011-07-01T10:28:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125215",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

After looking at #10548, I might have a better idea of the culprit:


```
sage: import gc
sage: from sage.schemes.elliptic_curves.ell_finite_field import EllipticCurve_finite_field
sage: K = GF(1<<60,'t')
sage: j = K.random_element()
sage: for i in xrange(100):
....:     E = EllipticCurve(j=j); P = E.random_point(); 2*P;
....:     
sage: gc.collect()
440
sage: len([x for x in gc.get_objects() if  isinstance(x,EllipticCurve_finite_field)])
100
```




---

archive/issue_comments_125216.json:
```json
{
    "body": "Changing assignee from @rlmill to @robertwb.",
    "created_at": "2011-07-01T10:35:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125216",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Changing assignee from @rlmill to @robertwb.



---

archive/issue_comments_125217.json:
```json
{
    "body": "Changing component from memleak to coercion.",
    "created_at": "2011-07-01T10:35:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125217",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Changing component from memleak to coercion.



---

archive/issue_comments_125218.json:
```json
{
    "body": "So this could be just #715 .",
    "created_at": "2011-07-01T10:35:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125218",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

So this could be just #715 .



---

archive/issue_comments_125219.json:
```json
{
    "body": "This is definitely #715.\n\nResetting the coercion cache and calling gc.collect() deletes the cached elements.\n\nI guess weak refs should be used in the different TripleDict objects of CoercionModel_cache_maps.\n\nSo this should be closed as duplicate/won't fix.",
    "created_at": "2011-07-01T13:29:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125219",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

This is definitely #715.

Resetting the coercion cache and calling gc.collect() deletes the cached elements.

I guess weak refs should be used in the different TripleDict objects of CoercionModel_cache_maps.

So this should be closed as duplicate/won't fix.



---

archive/issue_comments_125220.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2011-09-13T12:56:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125220",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_125221.json:
```json
{
    "body": "Jean-Pierre, why did you change the status to \"needs review\"? There is no patch to review.\n\nAlso, how to you reset the coercion cache? I would be interested if you have a workaround for the\nmemory leak in:\n\n```\nfor p in prime_range(10^8):\n   k = GF(p)\n```\n\nPaul",
    "created_at": "2011-10-13T11:17:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125221",
    "user": "https://github.com/zimmermann6"
}
```

Jean-Pierre, why did you change the status to "needs review"? There is no patch to review.

Also, how to you reset the coercion cache? I would be interested if you have a workaround for the
memory leak in:

```
for p in prime_range(10^8):
   k = GF(p)
```

Paul



---

archive/issue_comments_125222.json:
```json
{
    "body": "As far as I'm concerned, this is nothing but a concrete example of the vague #715.\nSo I guess I put it to \"needs review\" so that it could be closed as \"duplicate/won't fix\".\nNot sure it was the right way to do it.\n\nI seem to remember that I had some workarounds to delete some parts of the cache (so that I could perform my computations), but not all of them.\nIn fact there are several dictionnaries hidden in different places.\nIt was quite a while ago, but I'll have another look at it at some point.\nAnyway, using weak references for all these dictionnaries seems to be a quite non trivial task.\nMoreover it should also not slow things down too much to be viable...",
    "created_at": "2011-10-13T11:26:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125222",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

As far as I'm concerned, this is nothing but a concrete example of the vague #715.
So I guess I put it to "needs review" so that it could be closed as "duplicate/won't fix".
Not sure it was the right way to do it.

I seem to remember that I had some workarounds to delete some parts of the cache (so that I could perform my computations), but not all of them.
In fact there are several dictionnaries hidden in different places.
It was quite a while ago, but I'll have another look at it at some point.
Anyway, using weak references for all these dictionnaries seems to be a quite non trivial task.
Moreover it should also not slow things down too much to be viable...



---

archive/issue_comments_125223.json:
```json
{
    "body": "for the computations I need to perform, which need to create about 200000 prime fields, this\nmemory leak makes it impossible to perform it with Sage, which eats all the available memory.\n\nI would be satisfied if I had a magic command to type to explicitly free the memory used by\nevery `k=GF(p)`.\n\nPaul",
    "created_at": "2011-10-13T11:30:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125223",
    "user": "https://github.com/zimmermann6"
}
```

for the computations I need to perform, which need to create about 200000 prime fields, this
memory leak makes it impossible to perform it with Sage, which eats all the available memory.

I would be satisfied if I had a magic command to type to explicitly free the memory used by
every `k=GF(p)`.

Paul



---

archive/issue_comments_125224.json:
```json
{
    "body": "I'm having a look at your problem right now. Here are some hints to study the problem, mostly stolen from [#10548](http://trac.sagemath.org/sage_trac/search/opensearch?q=ticket%3A10548).\n\nI put it here for the record, and so that i can go faster next time.\n\nFirst, if I only create the finite fields and do nothing with them, I do not seem to get a memleak. Some fields are not garbage collected immediately, but calling gc.collect() does the trick.\n\n\n```\nsage: import gc\nsage: for p in prime_range(10**5):\n....:    k = GF(p)\n....:\nsage: del p, k\nsage: gc.collect()\n1265\nsage: from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn as FF\nsage: L = [x for x in gc.get_objects() if isinstance(x, FF)]\nsage: len(L)\n1\nsage: L\n[Finite Field of size 2]\n\n```\n\nOf course I guess you actually do something with your finite fields.\n\nSo here is a small example causing the fields to stay cached.\n\n\n```\nsage: import gc\nsage: for p in prime_range(10**5):\n....:    k = GF(p)\n....:\nsage: del p, k\nsage: gc.collect()\n0\n\n```\n\nThe zero here is bad and indeed\n\n\n```\nsage: from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn as FF\nsage: L = [x for x in gc.get_objects() if isinstance(x, FF)]\nsage: len(L)\n9592 \n\n```\n\nIf you want to know where it comes from you can use the objgraph python module (on my debian I just installed the python-objgraph package, updated sys.path in Sage to include '/usr/lib/python2.6/dist-packages')\n\n\n```\nsage: sys.path.append('/usr/lib/python2.6/dist-packages')\nsage: import inspect, objgraph\nsage: objgraph.show_backrefs(L[-1],filename='/home/jp/br.png',extra_ignore=[id(L)])\n\n```\n\nAnd look at the png or use\n\n\n```\nsage: brc = objgraph.find_backref_chain(L[-1],inspect.ismodule,max_depth=15,extra_ignore=[id(L)])\nsage: map(type,brc)\n[<type 'module'>, <type 'dict'>, <type 'dict'>,...\nsage: brc[0]\n<module 'sage.categories.homset'...\n\n```\n\nSo the culprit is \"_cache\" in sage.categories.homset which has a direct reference to the finite fields in its keys.\n\nThe clean solution woul be to used weakref in the keys (let's say something as WeakKeyDirectory in python).\n\nHowever, resetting cache should be a (potentially partial) workaround (and could kill your Sage?).\n\n\n```\nsage: sage.categories.homset.cache = {}\nsage: gc.collect()\n376595\n\n```\n\nIt also seems to be enough if I do \"a = k.random_element(); a = a+a\" in the for loop, but not if I add \"a = 47*a+3\".\n\nI'm currently investigating that last case.",
    "created_at": "2011-10-14T12:52:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125224",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I'm having a look at your problem right now. Here are some hints to study the problem, mostly stolen from [#10548](http://trac.sagemath.org/sage_trac/search/opensearch?q=ticket%3A10548).

I put it here for the record, and so that i can go faster next time.

First, if I only create the finite fields and do nothing with them, I do not seem to get a memleak. Some fields are not garbage collected immediately, but calling gc.collect() does the trick.


```
sage: import gc
sage: for p in prime_range(10**5):
....:    k = GF(p)
....:
sage: del p, k
sage: gc.collect()
1265
sage: from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn as FF
sage: L = [x for x in gc.get_objects() if isinstance(x, FF)]
sage: len(L)
1
sage: L
[Finite Field of size 2]

```

Of course I guess you actually do something with your finite fields.

So here is a small example causing the fields to stay cached.


```
sage: import gc
sage: for p in prime_range(10**5):
....:    k = GF(p)
....:
sage: del p, k
sage: gc.collect()
0

```

The zero here is bad and indeed


```
sage: from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn as FF
sage: L = [x for x in gc.get_objects() if isinstance(x, FF)]
sage: len(L)
9592 

```

If you want to know where it comes from you can use the objgraph python module (on my debian I just installed the python-objgraph package, updated sys.path in Sage to include '/usr/lib/python2.6/dist-packages')


```
sage: sys.path.append('/usr/lib/python2.6/dist-packages')
sage: import inspect, objgraph
sage: objgraph.show_backrefs(L[-1],filename='/home/jp/br.png',extra_ignore=[id(L)])

```

And look at the png or use


```
sage: brc = objgraph.find_backref_chain(L[-1],inspect.ismodule,max_depth=15,extra_ignore=[id(L)])
sage: map(type,brc)
[<type 'module'>, <type 'dict'>, <type 'dict'>,...
sage: brc[0]
<module 'sage.categories.homset'...

```

So the culprit is "_cache" in sage.categories.homset which has a direct reference to the finite fields in its keys.

The clean solution woul be to used weakref in the keys (let's say something as WeakKeyDirectory in python).

However, resetting cache should be a (potentially partial) workaround (and could kill your Sage?).


```
sage: sage.categories.homset.cache = {}
sage: gc.collect()
376595

```

It also seems to be enough if I do "a = k.random_element(); a = a+a" in the for loop, but not if I add "a = 47*a+3".

I'm currently investigating that last case.



---

archive/issue_comments_125225.json:
```json
{
    "body": "For info, using \"k(47)*a+k(3)\" is solved,\u00a0 so the problem left really comes from coercion and action of integers.\n\n\n```\nsage: cm = sage.structure. get_coercion_model()\nsage: cm.reset_cache()\n\n```\n\ndoes not help.",
    "created_at": "2011-10-14T13:12:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125225",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

For info, using "k(47)*a+k(3)" is solved,  so the problem left really comes from coercion and action of integers.


```
sage: cm = sage.structure. get_coercion_model()
sage: cm.reset_cache()

```

does not help.



---

archive/issue_comments_125226.json:
```json
{
    "body": "First, the second example above is missing the line \"k(1);\" in the for loop, otherwise it does nothing more than the first example.\n\nSecond, I guess the remaining references to the finite fields are in the different lists and dictionnaries of the integer ring named _coerce_from_list, _convert_from_list etc.\n\nYou can not directly access them from Python level, but there a function _introspect_coerce() (defined in parent.pyx) which returns them.",
    "created_at": "2011-10-14T15:02:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125226",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

First, the second example above is missing the line "k(1);" in the for loop, otherwise it does nothing more than the first example.

Second, I guess the remaining references to the finite fields are in the different lists and dictionnaries of the integer ring named _coerce_from_list, _convert_from_list etc.

You can not directly access them from Python level, but there a function _introspect_coerce() (defined in parent.pyx) which returns them.



---

archive/issue_comments_125227.json:
```json
{
    "body": "In fact, everything is in _*_hash.\n\nAnd to conclude, I'd say that right now you can not directly delete entries in this dictionaries from the Python level.\n\nSo for minimum changes, you should eitheir avoid coercion, or make the dictionaries \"cdef public\" in parent.pxd to be able to explicitely delete every created entries (be aware that it could be written in different places for example in ZZ but also in QQ and CC and I don't know where...).\n\nAnd I could also have missed other dictionaries used by Sage.",
    "created_at": "2011-10-14T15:48:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125227",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

In fact, everything is in _*_hash.

And to conclude, I'd say that right now you can not directly delete entries in this dictionaries from the Python level.

So for minimum changes, you should eitheir avoid coercion, or make the dictionaries "cdef public" in parent.pxd to be able to explicitely delete every created entries (be aware that it could be written in different places for example in ZZ but also in QQ and CC and I don't know where...).

And I could also have missed other dictionaries used by Sage.



---

archive/issue_comments_125228.json:
```json
{
    "body": "Jean-Pierre, I cannot reproduce that:\n\n```\nsage: sys.path.append('/usr/lib/python2.6/dist-packages')\nsage: import inspect, objgraph\n---------------------------------------------------------------------------\nImportError                               Traceback (most recent call last)\n\n/users/caramel/zimmerma/Adm/Strass/SED/2011/<ipython console> in <module>()\n\nImportError: No module named objgraph\n```\n\nPaul",
    "created_at": "2011-10-14T15:51:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125228",
    "user": "https://github.com/zimmermann6"
}
```

Jean-Pierre, I cannot reproduce that:

```
sage: sys.path.append('/usr/lib/python2.6/dist-packages')
sage: import inspect, objgraph
---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)

/users/caramel/zimmerma/Adm/Strass/SED/2011/<ipython console> in <module>()

ImportError: No module named objgraph
```

Paul



---

archive/issue_comments_125229.json:
```json
{
    "body": "Did you \"apt-get install python-objgraph\" on your system?\n\nIf yes, is it a version for python 2.6 ?",
    "created_at": "2011-10-14T15:54:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125229",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Did you "apt-get install python-objgraph" on your system?

If yes, is it a version for python 2.6 ?



---

archive/issue_comments_125230.json:
```json
{
    "body": "The path I gave above might also be different on your system...\n\nAs the package manager.",
    "created_at": "2011-10-14T15:56:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125230",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

The path I gave above might also be different on your system...

As the package manager.



---

archive/issue_comments_125231.json:
```json
{
    "body": "Any progress on your side?\n\nIf you found any other dicitonaries leading to cahing problems, it would be great to mention them here for the record.\n\nHence the day someone will finally decide to tackle ticket #715, it will speed up the search of the culprit.",
    "created_at": "2011-11-07T09:28:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125231",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Any progress on your side?

If you found any other dicitonaries leading to cahing problems, it would be great to mention them here for the record.

Hence the day someone will finally decide to tackle ticket #715, it will speed up the search of the culprit.



---

archive/issue_comments_125232.json:
```json
{
    "body": "Replying to [comment:15 jpflori]:\n> Any progress on your side?\n\nno time so far. I will look at this during the SageFlint days in December, unless someone else has\nsome time before.\n\nPaul",
    "created_at": "2011-11-07T09:37:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125232",
    "user": "https://github.com/zimmermann6"
}
```

Replying to [comment:15 jpflori]:
> Any progress on your side?

no time so far. I will look at this during the SageFlint days in December, unless someone else has
some time before.

Paul



---

archive/issue_comments_125233.json:
```json
{
    "body": "Replying to [comment:6 jpflori]:\n> As far as I'm concerned, this is nothing but a concrete example of the vague #715.\n> So I guess I put it to \"needs review\" so that it could be closed as \"duplicate/won't fix\".\n> Not sure it was the right way to do it.\n> \nIf you think it should be closed, then I think you should set the milestone to duplicate/wontfix.  Otherwise, it is probably better to change the status back to 'new'.",
    "created_at": "2011-11-14T16:34:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125233",
    "user": "https://trac.sagemath.org/admin/accounts/users/johanbosman"
}
```

Replying to [comment:6 jpflori]:
> As far as I'm concerned, this is nothing but a concrete example of the vague #715.
> So I guess I put it to "needs review" so that it could be closed as "duplicate/won't fix".
> Not sure it was the right way to do it.
> 
If you think it should be closed, then I think you should set the milestone to duplicate/wontfix.  Otherwise, it is probably better to change the status back to 'new'.



---

archive/issue_comments_125234.json:
```json
{
    "body": "with Sage 4.7.2 I get the following:\n\n```\nsage: for p in prime_range(10^5):\n....:     K = GF(p)\n....:     a = K(0)\n....:     \nsage: import gc\nsage: gc.collect()\n0\nsage: from sage.rings.finite_rings.finite_field_prime_modn import \\\n....: FiniteField_prime_modn as FF\nsage: L = [x for x in gc.get_objects() if isinstance(x, FF)]\nsage: len(L), L[0], L[len(L)-1]\n(9592, Finite Field of size 2, Finite Field of size 99767)\n```\n\nthus whenever we use the finite field we get a memleak.\n(If I remove the `a=K(0)` line, I get only two elements in L, for p=2 and p=99991.)\n\nPaul",
    "created_at": "2011-12-18T16:22:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125234",
    "user": "https://github.com/zimmermann6"
}
```

with Sage 4.7.2 I get the following:

```
sage: for p in prime_range(10^5):
....:     K = GF(p)
....:     a = K(0)
....:     
sage: import gc
sage: gc.collect()
0
sage: from sage.rings.finite_rings.finite_field_prime_modn import \
....: FiniteField_prime_modn as FF
sage: L = [x for x in gc.get_objects() if isinstance(x, FF)]
sage: len(L), L[0], L[len(L)-1]
(9592, Finite Field of size 2, Finite Field of size 99767)
```

thus whenever we use the finite field we get a memleak.
(If I remove the `a=K(0)` line, I get only two elements in L, for p=2 and p=99991.)

Paul



---

archive/issue_comments_125235.json:
```json
{
    "body": "I confirm (cf comment [comment:8]) that if I comment out the line \n\n```\n    _cache[(X, Y, category)] = weakref.ref(H)\n```\n\nin categories/homset.py, then the memory leak from comment [comment:18] disappears.\n\nPaul",
    "created_at": "2011-12-18T19:18:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125235",
    "user": "https://github.com/zimmermann6"
}
```

I confirm (cf comment [comment:8]) that if I comment out the line 

```
    _cache[(X, Y, category)] = weakref.ref(H)
```

in categories/homset.py, then the memory leak from comment [comment:18] disappears.

Paul



---

archive/issue_comments_125236.json:
```json
{
    "body": "I think we have a different problem here.\n\nThe finite fields themselves should be cached. The cache (see `GF._cache`) uses weak references, which should be fine.\n\nAlso, there are special methods `zero_element` and `one_element` which should do caching, because zero and one are frequently used and should not be created over and over again.\n\nHowever, it seems that *all* elements of a finite field are cached - and that's bad!\n\n```\nsage: K = GF(5)\nsage: K(2) is K(2)\nTrue\nsage: K.<a> = GF(17^2)\nsage: K(5) is K(5)\nTrue\n```\n\n\nI see absolutely no reason why all `17^2` elements should be cached.\n\nFortunately, we have no caching for larger finite fields:\n\n```\nsage: K.<a> = GF(17^10)\nsage: K(5) is K(5)\nFalse\n```\n",
    "created_at": "2011-12-19T09:41:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125236",
    "user": "https://github.com/simon-king-jena"
}
```

I think we have a different problem here.

The finite fields themselves should be cached. The cache (see `GF._cache`) uses weak references, which should be fine.

Also, there are special methods `zero_element` and `one_element` which should do caching, because zero and one are frequently used and should not be created over and over again.

However, it seems that *all* elements of a finite field are cached - and that's bad!

```
sage: K = GF(5)
sage: K(2) is K(2)
True
sage: K.<a> = GF(17^2)
sage: K(5) is K(5)
True
```


I see absolutely no reason why all `17^2` elements should be cached.

Fortunately, we have no caching for larger finite fields:

```
sage: K.<a> = GF(17^10)
sage: K(5) is K(5)
False
```




---

archive/issue_comments_125237.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2011-12-19T09:58:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125237",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_125238.json:
```json
{
    "body": "In the following example, there is no memory leak that would be caused by the `sage.categories.homset` cache:\n\n```\nsage: len(sage.categories.homset._cache.keys())\n100\nsage: for p in prime_range(10^5):\n....:     K = GF(p)\n....:     \nsage: len(sage.categories.homset._cache.keys())\n100\n```\n\n\nHowever, when you do a conversion `K(...)` then a convert map is created, and apparently is cached:\n\n```\nsage: for p in prime_range(10^5):\n....:     K = GF(p)\n....:     a = K(0)\n....:\nsage: len(sage.categories.homset._cache.keys())\n9692\n```\n\n\nThe homset cache does use weak references. Hence, it is surprising that the unused stuff can not be garbage collected. Apparently there is some direct reference involved at some point.\n\nI am very stronglyagainst removing the cache of `sage.categories.homset`. Namely, elliptic curve code uses finite fields and maps involving finite fields *a lot*, and killing the cache is likely to cause a massive regression.\n\nHowever, since we actually have coercion maps (not just any odd map), I expect that the direct reference comes from the coercion model. I suggest to look into the coercion code and use weak references there.\n\nBy the way, I don't know why the status is \"needs review\". I think it clearly is \"needs work\".",
    "created_at": "2011-12-19T09:58:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125238",
    "user": "https://github.com/simon-king-jena"
}
```

In the following example, there is no memory leak that would be caused by the `sage.categories.homset` cache:

```
sage: len(sage.categories.homset._cache.keys())
100
sage: for p in prime_range(10^5):
....:     K = GF(p)
....:     
sage: len(sage.categories.homset._cache.keys())
100
```


However, when you do a conversion `K(...)` then a convert map is created, and apparently is cached:

```
sage: for p in prime_range(10^5):
....:     K = GF(p)
....:     a = K(0)
....:
sage: len(sage.categories.homset._cache.keys())
9692
```


The homset cache does use weak references. Hence, it is surprising that the unused stuff can not be garbage collected. Apparently there is some direct reference involved at some point.

I am very stronglyagainst removing the cache of `sage.categories.homset`. Namely, elliptic curve code uses finite fields and maps involving finite fields *a lot*, and killing the cache is likely to cause a massive regression.

However, since we actually have coercion maps (not just any odd map), I expect that the direct reference comes from the coercion model. I suggest to look into the coercion code and use weak references there.

By the way, I don't know why the status is "needs review". I think it clearly is "needs work".



---

archive/issue_comments_125239.json:
```json
{
    "body": "Replying to [comment:8 jpflori]:\n> So the culprit is \"_cache\" in sage.categories.homset which has a direct reference to the finite fields in its keys.\n\nOops, that could indeed be the problem! Namely, the homset cache uses weak references to its values, but uses direct references to its keys! Perhaps using weak references as keys would work?",
    "created_at": "2011-12-19T10:02:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125239",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:8 jpflori]:
> So the culprit is "_cache" in sage.categories.homset which has a direct reference to the finite fields in its keys.

Oops, that could indeed be the problem! Namely, the homset cache uses weak references to its values, but uses direct references to its keys! Perhaps using weak references as keys would work?



---

archive/issue_comments_125240.json:
```json
{
    "body": "it seems the complete caching of field elements only occurs for p < 500:\n\n```\nsage: K=GF(499)\nsage: K(5) is K(5)\nTrue\nsage: K=GF(503)\nsage: K(5) is K(5)\nFalse\n```\n\n\nA workaround to this memory leak is to free the cache from time to time (thanks Simon):\n\n```\nsage: sage.categories.homset._cache.clear()\n```\n\nPaul",
    "created_at": "2011-12-19T10:21:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125240",
    "user": "https://github.com/zimmermann6"
}
```

it seems the complete caching of field elements only occurs for p < 500:

```
sage: K=GF(499)
sage: K(5) is K(5)
True
sage: K=GF(503)
sage: K(5) is K(5)
False
```


A workaround to this memory leak is to free the cache from time to time (thanks Simon):

```
sage: sage.categories.homset._cache.clear()
```

Paul



---

archive/issue_comments_125241.json:
```json
{
    "body": "On the other hand, it could be that using weak keys in the homset cache will not work: The keys are triples: domain, codomain and category.\n\nWhat we want is: If either the domain or the codomain or the category have no strong reference, then the homset can be garbage collected.\n\nHence: Why don't we use a dictionary of dictionaries of dictionaries?\n\nWhat I mean is:\n\n* The keys of sage.categories.homset._cache should be weak references to the domain\n* The values of sage.categories.homset._cache should be dictionaries whose keys are weak references to the codomain.\n* The keys of these dictionaries should be weak references to the category, and the value a weak reference to the homset.\n\nHence, if there is no strong reference to either domain or codomain or category, then the homset can be deallocated.",
    "created_at": "2011-12-19T10:26:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125241",
    "user": "https://github.com/simon-king-jena"
}
```

On the other hand, it could be that using weak keys in the homset cache will not work: The keys are triples: domain, codomain and category.

What we want is: If either the domain or the codomain or the category have no strong reference, then the homset can be garbage collected.

Hence: Why don't we use a dictionary of dictionaries of dictionaries?

What I mean is:

* The keys of sage.categories.homset._cache should be weak references to the domain
* The values of sage.categories.homset._cache should be dictionaries whose keys are weak references to the codomain.
* The keys of these dictionaries should be weak references to the category, and the value a weak reference to the homset.

Hence, if there is no strong reference to either domain or codomain or category, then the homset can be deallocated.



---

archive/issue_comments_125242.json:
```json
{
    "body": "The idea sketched in the previous comment seems to work!!!\n\nWith it, after running\n\n```\nsage: for p in prime_range(10^5):\n....:     K = GF(p)\n....:     a = K(0)\n....:     print get_memory_usage()\n```\n\nends with printing 825.45703125\n\nWithout it, it ends with printing 902.8125\n\nI don't know if we should ban caching of field elements?\n\nHow could fixing that memory leak be demonstrated by a doc test?\n\nAnyway, I will post a preliminary patch in a few minutes (so that you can see if it fixes at least part of the problem for you), while I am running `sage -tp 2 devel/sage`.",
    "created_at": "2011-12-19T10:49:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125242",
    "user": "https://github.com/simon-king-jena"
}
```

The idea sketched in the previous comment seems to work!!!

With it, after running

```
sage: for p in prime_range(10^5):
....:     K = GF(p)
....:     a = K(0)
....:     print get_memory_usage()
```

ends with printing 825.45703125

Without it, it ends with printing 902.8125

I don't know if we should ban caching of field elements?

How could fixing that memory leak be demonstrated by a doc test?

Anyway, I will post a preliminary patch in a few minutes (so that you can see if it fixes at least part of the problem for you), while I am running `sage -tp 2 devel/sage`.



---

archive/issue_comments_125243.json:
```json
{
    "body": "Patch's up!",
    "created_at": "2011-12-19T10:51:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125243",
    "user": "https://github.com/simon-king-jena"
}
```

Patch's up!



---

archive/issue_comments_125244.json:
```json
{
    "body": "Hm. There seems to be a problem.\n\n```\nsage -t  devel/sage/doc/en/constructions/linear_codes.rst\nThe doctested process was killed by signal 11\n```\n\n\nWhat is signal 11?",
    "created_at": "2011-12-19T10:56:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125244",
    "user": "https://github.com/simon-king-jena"
}
```

Hm. There seems to be a problem.

```
sage -t  devel/sage/doc/en/constructions/linear_codes.rst
The doctested process was killed by signal 11
```


What is signal 11?



---

archive/issue_comments_125245.json:
```json
{
    "body": "signal 11 is Segmentation Fault\n\nPaul",
    "created_at": "2011-12-19T11:01:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125245",
    "user": "https://github.com/zimmermann6"
}
```

signal 11 is Segmentation Fault

Paul



---

archive/issue_comments_125246.json:
```json
{
    "body": "Indeed it is a segfault. And it is triggered by\n\n```\nsage: w = vector([1,1,-4])\n```\n",
    "created_at": "2011-12-19T11:06:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125246",
    "user": "https://github.com/simon-king-jena"
}
```

Indeed it is a segfault. And it is triggered by

```
sage: w = vector([1,1,-4])
```




---

archive/issue_comments_125247.json:
```json
{
    "body": "Monique van Beek just pointed me to the fact that the error occurs even earlier:\n\n```\nsage: is_Ring(None)\n<BOOOOOM>\n```\n",
    "created_at": "2011-12-19T11:14:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125247",
    "user": "https://github.com/simon-king-jena"
}
```

Monique van Beek just pointed me to the fact that the error occurs even earlier:

```
sage: is_Ring(None)
<BOOOOOM>
```




---

archive/issue_comments_125248.json:
```json
{
    "body": "Moreover,\n\n```\nsage: None in Rings()\n<BOOOOOOM>\n```\n",
    "created_at": "2011-12-19T11:16:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125248",
    "user": "https://github.com/simon-king-jena"
}
```

Moreover,

```
sage: None in Rings()
<BOOOOOOM>
```




---

archive/issue_comments_125249.json:
```json
{
    "body": "That said: I am not working on top of vanilla sage, but I use some patches. In particular, I use #11900, which introduces so called `Category_singleton`, which has a specialised and very fast containment test.\n\nI would not like to change #11900, but prefer to change my patch from here so that it works on top of #11900.",
    "created_at": "2011-12-19T11:19:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125249",
    "user": "https://github.com/simon-king-jena"
}
```

That said: I am not working on top of vanilla sage, but I use some patches. In particular, I use #11900, which introduces so called `Category_singleton`, which has a specialised and very fast containment test.

I would not like to change #11900, but prefer to change my patch from here so that it works on top of #11900.



---

archive/issue_comments_125250.json:
```json
{
    "body": "It turns out that indeed the bug is in #11900. So, I *have* to fix it there.",
    "created_at": "2011-12-19T11:32:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125250",
    "user": "https://github.com/simon-king-jena"
}
```

It turns out that indeed the bug is in #11900. So, I *have* to fix it there.



---

archive/issue_comments_125251.json:
```json
{
    "body": "Cc to Nicolas, since it concerns categories:\n\nDo we want that `Hom(1,1)` is still supported?\n\nI think it does not make sense at all to talk about the homomorphisms of the number 1 to the number 1. The problem (for my patch as it is posted here) is the fact that one can't create a weak reference to the number 1.",
    "created_at": "2011-12-19T14:43:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125251",
    "user": "https://github.com/simon-king-jena"
}
```

Cc to Nicolas, since it concerns categories:

Do we want that `Hom(1,1)` is still supported?

I think it does not make sense at all to talk about the homomorphisms of the number 1 to the number 1. The problem (for my patch as it is posted here) is the fact that one can't create a weak reference to the number 1.



---

archive/issue_comments_125252.json:
```json
{
    "body": "Sorry, I forgot to update the Cc field.\n\nNicolas, please read my previous comment.",
    "created_at": "2011-12-19T14:44:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125252",
    "user": "https://github.com/simon-king-jena"
}
```

Sorry, I forgot to update the Cc field.

Nicolas, please read my previous comment.



---

archive/issue_comments_125253.json:
```json
{
    "body": "With my patch, applied on top of #11900, I get\n\n```\n        sage -t  devel/sage-main/sage/structure/parent.pyx # 2 doctests failed\n        sage -t  devel/sage-main/sage/structure/category_object.pyx # 2 doctests failed\n        sage -t  devel/sage-main/sage/rings/polynomial/polynomial_singular_interface.py # 1 doctests failed\n        sage -t  devel/sage-main/sage/rings/polynomial/multi_polynomial_ring.py # 36 doctests failed\n        sage -t  devel/sage-main/sage/structure/parent_base.pyx # 2 doctests failed\n```\n\n\nAt least some of the errors are like\n\n```\n    sage: n = 5; Hom(n,7)\nException raised:\n    Traceback (most recent call last):\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1231, in run_one_test\n        self.run_one_example(test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py\", line 38, in run_one_example\n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_3[4]>\", line 1, in <module>\n        n = Integer(5); Hom(n,Integer(7))###line 108:\n    sage: n = 5; Hom(n,7)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py\", line 159, in Hom\n        cache2 = _cache[X]\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py\", line 243, in __getitem__\n        return self.data[ref(key)]\n    TypeError: cannot create weak reference to 'sage.rings.integer.Integer' object\n```\n\nand I really don't see why this should be considered a bug.",
    "created_at": "2011-12-19T14:49:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125253",
    "user": "https://github.com/simon-king-jena"
}
```

With my patch, applied on top of #11900, I get

```
        sage -t  devel/sage-main/sage/structure/parent.pyx # 2 doctests failed
        sage -t  devel/sage-main/sage/structure/category_object.pyx # 2 doctests failed
        sage -t  devel/sage-main/sage/rings/polynomial/polynomial_singular_interface.py # 1 doctests failed
        sage -t  devel/sage-main/sage/rings/polynomial/multi_polynomial_ring.py # 36 doctests failed
        sage -t  devel/sage-main/sage/structure/parent_base.pyx # 2 doctests failed
```


At least some of the errors are like

```
    sage: n = 5; Hom(n,7)
Exception raised:
    Traceback (most recent call last):
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_3[4]>", line 1, in <module>
        n = Integer(5); Hom(n,Integer(7))###line 108:
    sage: n = 5; Hom(n,7)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py", line 159, in Hom
        cache2 = _cache[X]
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py", line 243, in __getitem__
        return self.data[ref(key)]
    TypeError: cannot create weak reference to 'sage.rings.integer.Integer' object
```

and I really don't see why this should be considered a bug.



---

archive/issue_comments_125254.json:
```json
{
    "body": "At least one of the errors in polynomial rings is due to a wrong order of initialising things: There is some information missing, and by consequence a weak reference can't be created.\n\nI fixed this problem in the new patch version.\n\nI put it as \"needs info\", because of my question on whether or not we want to consider an integer as object in a category.",
    "created_at": "2011-12-19T16:12:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125254",
    "user": "https://github.com/simon-king-jena"
}
```

At least one of the errors in polynomial rings is due to a wrong order of initialising things: There is some information missing, and by consequence a weak reference can't be created.

I fixed this problem in the new patch version.

I put it as "needs info", because of my question on whether or not we want to consider an integer as object in a category.



---

archive/issue_comments_125255.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2011-12-19T16:12:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125255",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_125256.json:
```json
{
    "body": "I was told by Mike Hansen why weak references to integers and rationals do not work.\n\nI see three options:\n\n#. Drop the support for `Hom(1,1)` (which I'd prefer)\n#. Add a cdef'd attribute `__weakref__` to `sage.structure.element.Element`, which would create an overhead for garbage collection for elements, and also a memory overhead.\n#. Use two category.homset caches in parallel: One (the default) that uses weak references, and another one that uses \"normal\" references if weak references fail.",
    "created_at": "2011-12-19T16:45:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125256",
    "user": "https://github.com/simon-king-jena"
}
```

I was told by Mike Hansen why weak references to integers and rationals do not work.

I see three options:

#. Drop the support for `Hom(1,1)` (which I'd prefer)
#. Add a cdef'd attribute `__weakref__` to `sage.structure.element.Element`, which would create an overhead for garbage collection for elements, and also a memory overhead.
#. Use two category.homset caches in parallel: One (the default) that uses weak references, and another one that uses "normal" references if weak references fail.



---

archive/issue_comments_125257.json:
```json
{
    "body": "FWIW:\n\nWith the latest patch, the tests in polynomial_singular_interface and in multi_polynomial_ring pass.\n\nThere remain the following problems:\n\n\n```\nsage -t  \"devel/sage-main/sage/structure/parent.pyx\"        \n**********************************************************************\nFile \"/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/parent.pyx\", line 1410:\n    sage: n = 5; Hom(n,7)\nException raised:\n    Traceback (most recent call last):\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1231, in run_one_test\n        self.run_one_example(test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py\", line 38, in run_one_example\n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_33[4]>\", line 1, in <module>\n        n = Integer(5); Hom(n,Integer(7))###line 1410:\n    sage: n = 5; Hom(n,7)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py\", line 159, in Hom\n        cache2 = _cache[X]\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py\", line 243, in __getitem__\n        return self.data[ref(key)]\n    TypeError: cannot create weak reference to 'sage.rings.integer.Integer' object\n**********************************************************************\nFile \"/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/parent.pyx\", line 1412:\n    sage: z=(2/3); Hom(z,8/1)                                                                            \nException raised:                                                                                        \n    Traceback (most recent call last):                                                                   \n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1231, in run_one_test        \n        self.run_one_example(test, example, filename, compileflags)                                      \n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py\", line 38, in run_one_example      \n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_33[5]>\", line 1, in <module>\n        z=(Integer(2)/Integer(3)); Hom(z,Integer(8)/Integer(1))###line 1412:\n    sage: z=(2/3); Hom(z,8/1)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py\", line 159, in Hom\n        cache2 = _cache[X]\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py\", line 243, in __getitem__\n        return self.data[ref(key)]\n    TypeError: cannot create weak reference to 'sage.rings.rational.Rational' object\n**********************************************************************\n1 items had failures:\n   2 of   8 in __main__.example_33\n***Test Failed*** 2 failures.\nFor whitespace errors, see the file /home/simon/.sage//tmp/parent_2986.py\n         [11.6 s]\n```\n\nand\n\n```\nsage -t  \"devel/sage-main/sage/structure/category_object.pyx\"\n**********************************************************************\nFile \"/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/category_object.pyx\", line 590:\n    sage: n = 5; Hom(n,7)\nException raised:\n    Traceback (most recent call last):\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1231, in run_one_test\n        self.run_one_example(test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py\", line 38, in run_one_example\n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_17[4]>\", line 1, in <module>\n        n = Integer(5); Hom(n,Integer(7))###line 590:\n    sage: n = 5; Hom(n,7)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py\", line 159, in Hom\n        cache2 = _cache[X]\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py\", line 243, in __getitem__\n        return self.data[ref(key)]\n    TypeError: cannot create weak reference to 'sage.rings.integer.Integer' object\n**********************************************************************\nFile \"/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/category_object.pyx\", line 592:\n    sage: z=(2/3); Hom(z,8/1)\nException raised:\n    Traceback (most recent call last):\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1231, in run_one_test\n        self.run_one_example(test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py\", line 38, in run_one_example\n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_17[5]>\", line 1, in <module>\n        z=(Integer(2)/Integer(3)); Hom(z,Integer(8)/Integer(1))###line 592:\n    sage: z=(2/3); Hom(z,8/1)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py\", line 159, in Hom\n        cache2 = _cache[X]\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py\", line 243, in __getitem__\n        return self.data[ref(key)]\n    TypeError: cannot create weak reference to 'sage.rings.rational.Rational' object\n**********************************************************************\n1 items had failures:\n   2 of   8 in __main__.example_17\n***Test Failed*** 2 failures.\nFor whitespace errors, see the file /home/simon/.sage//tmp/category_object_3050.py\n         [2.7 s]\n```\n\nand\n\n```\nsage -t  \"devel/sage-main/sage/structure/parent_base.pyx\"   \n**********************************************************************\nFile \"/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/parent_base.pyx\", line 108:\n    sage: n = 5; Hom(n,7)\nException raised:\n    Traceback (most recent call last):\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1231, in run_one_test\n        self.run_one_example(test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py\", line 38, in run_one_example\n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_3[4]>\", line 1, in <module>\n        n = Integer(5); Hom(n,Integer(7))###line 108:\n    sage: n = 5; Hom(n,7)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py\", line 159, in Hom\n        cache2 = _cache[X]\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py\", line 243, in __getitem__\n        return self.data[ref(key)]\n    TypeError: cannot create weak reference to 'sage.rings.integer.Integer' object\n**********************************************************************\nFile \"/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/parent_base.pyx\", line 110:\n    sage: z=(2/3); Hom(z,8/1)\nException raised:\n    Traceback (most recent call last):\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1231, in run_one_test\n        self.run_one_example(test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py\", line 38, in run_one_example\n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_3[5]>\", line 1, in <module>\n        z=(Integer(2)/Integer(3)); Hom(z,Integer(8)/Integer(1))###line 110:\n    sage: z=(2/3); Hom(z,8/1)\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py\", line 159, in Hom\n        cache2 = _cache[X]\n      File \"/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py\", line 243, in __getitem__\n        return self.data[ref(key)]\n    TypeError: cannot create weak reference to 'sage.rings.rational.Rational' object\n**********************************************************************\n1 items had failures:\n   2 of   8 in __main__.example_3\n***Test Failed*** 2 failures.\nFor whitespace errors, see the file /home/simon/.sage//tmp/parent_base_3078.py\n         [2.6 s]\n```\n\n\nSo, essentially this is just a single test that comes in two versions and is repeated three times - and I would actually say that *not* raising an error was a bug.\n\nIt seems that `Hom(1/2,2/3)` and similar nonsense is not used in Sage. Hence, I think these tests should be removed. I'll ask sage-devel.",
    "created_at": "2011-12-19T21:09:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125257",
    "user": "https://github.com/simon-king-jena"
}
```

FWIW:

With the latest patch, the tests in polynomial_singular_interface and in multi_polynomial_ring pass.

There remain the following problems:


```
sage -t  "devel/sage-main/sage/structure/parent.pyx"        
**********************************************************************
File "/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/parent.pyx", line 1410:
    sage: n = 5; Hom(n,7)
Exception raised:
    Traceback (most recent call last):
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_33[4]>", line 1, in <module>
        n = Integer(5); Hom(n,Integer(7))###line 1410:
    sage: n = 5; Hom(n,7)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py", line 159, in Hom
        cache2 = _cache[X]
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py", line 243, in __getitem__
        return self.data[ref(key)]
    TypeError: cannot create weak reference to 'sage.rings.integer.Integer' object
**********************************************************************
File "/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/parent.pyx", line 1412:
    sage: z=(2/3); Hom(z,8/1)                                                                            
Exception raised:                                                                                        
    Traceback (most recent call last):                                                                   
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1231, in run_one_test        
        self.run_one_example(test, example, filename, compileflags)                                      
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py", line 38, in run_one_example      
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_33[5]>", line 1, in <module>
        z=(Integer(2)/Integer(3)); Hom(z,Integer(8)/Integer(1))###line 1412:
    sage: z=(2/3); Hom(z,8/1)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py", line 159, in Hom
        cache2 = _cache[X]
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py", line 243, in __getitem__
        return self.data[ref(key)]
    TypeError: cannot create weak reference to 'sage.rings.rational.Rational' object
**********************************************************************
1 items had failures:
   2 of   8 in __main__.example_33
***Test Failed*** 2 failures.
For whitespace errors, see the file /home/simon/.sage//tmp/parent_2986.py
         [11.6 s]
```

and

```
sage -t  "devel/sage-main/sage/structure/category_object.pyx"
**********************************************************************
File "/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/category_object.pyx", line 590:
    sage: n = 5; Hom(n,7)
Exception raised:
    Traceback (most recent call last):
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_17[4]>", line 1, in <module>
        n = Integer(5); Hom(n,Integer(7))###line 590:
    sage: n = 5; Hom(n,7)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py", line 159, in Hom
        cache2 = _cache[X]
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py", line 243, in __getitem__
        return self.data[ref(key)]
    TypeError: cannot create weak reference to 'sage.rings.integer.Integer' object
**********************************************************************
File "/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/category_object.pyx", line 592:
    sage: z=(2/3); Hom(z,8/1)
Exception raised:
    Traceback (most recent call last):
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_17[5]>", line 1, in <module>
        z=(Integer(2)/Integer(3)); Hom(z,Integer(8)/Integer(1))###line 592:
    sage: z=(2/3); Hom(z,8/1)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py", line 159, in Hom
        cache2 = _cache[X]
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py", line 243, in __getitem__
        return self.data[ref(key)]
    TypeError: cannot create weak reference to 'sage.rings.rational.Rational' object
**********************************************************************
1 items had failures:
   2 of   8 in __main__.example_17
***Test Failed*** 2 failures.
For whitespace errors, see the file /home/simon/.sage//tmp/category_object_3050.py
         [2.7 s]
```

and

```
sage -t  "devel/sage-main/sage/structure/parent_base.pyx"   
**********************************************************************
File "/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/parent_base.pyx", line 108:
    sage: n = 5; Hom(n,7)
Exception raised:
    Traceback (most recent call last):
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_3[4]>", line 1, in <module>
        n = Integer(5); Hom(n,Integer(7))###line 108:
    sage: n = 5; Hom(n,7)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py", line 159, in Hom
        cache2 = _cache[X]
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py", line 243, in __getitem__
        return self.data[ref(key)]
    TypeError: cannot create weak reference to 'sage.rings.integer.Integer' object
**********************************************************************
File "/home/simon/SAGE/sage-4.8.alpha3/devel/sage-main/sage/structure/parent_base.pyx", line 110:
    sage: z=(2/3); Hom(z,8/1)
Exception raised:
    Traceback (most recent call last):
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_3[5]>", line 1, in <module>
        z=(Integer(2)/Integer(3)); Hom(z,Integer(8)/Integer(1))###line 110:
    sage: z=(2/3); Hom(z,8/1)
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python/site-packages/sage/categories/homset.py", line 159, in Hom
        cache2 = _cache[X]
      File "/home/simon/SAGE/sage-4.8.alpha3/local/lib/python2.6/weakref.py", line 243, in __getitem__
        return self.data[ref(key)]
    TypeError: cannot create weak reference to 'sage.rings.rational.Rational' object
**********************************************************************
1 items had failures:
   2 of   8 in __main__.example_3
***Test Failed*** 2 failures.
For whitespace errors, see the file /home/simon/.sage//tmp/parent_base_3078.py
         [2.6 s]
```


So, essentially this is just a single test that comes in two versions and is repeated three times - and I would actually say that *not* raising an error was a bug.

It seems that `Hom(1/2,2/3)` and similar nonsense is not used in Sage. Hence, I think these tests should be removed. I'll ask sage-devel.



---

archive/issue_comments_125258.json:
```json
{
    "body": "Without the patch:\n\n```\nsage: def test():\n....:     for p in prime_range(10^5):\n....:         K = GF(p)\n....:         a = K(0)\n....:         \nsage: m0 = get_memory_usage()\nsage: %time test()\nCPU times: user 7.75 s, sys: 0.08 s, total: 7.83 s\nWall time: 7.84 s\nsage: get_memory_usage() - m0\n80.234375\n```\n\n\nWith the patch:\n\n```\nsage: def test():\n....:     for p in prime_range(10^5):\n....:         K = GF(p)\n....:         a = K(0)\n....:         \nsage: m0 = get_memory_usage()\nsage: %time test()\nCPU times: user 7.59 s, sys: 0.01 s, total: 7.60 s\nWall time: 7.61 s\nsage: get_memory_usage() - m0\n8.53515625\n```\n\n\nSo, the memory does mildly increase, but it seems that most of the leak is fixed.\n\nI think that a test of the kind\n\n```\nsage: get_memory_usage() - -m0 < 10\nTrue\n```\n\nmight be used as a doc test.",
    "created_at": "2011-12-19T21:43:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125258",
    "user": "https://github.com/simon-king-jena"
}
```

Without the patch:

```
sage: def test():
....:     for p in prime_range(10^5):
....:         K = GF(p)
....:         a = K(0)
....:         
sage: m0 = get_memory_usage()
sage: %time test()
CPU times: user 7.75 s, sys: 0.08 s, total: 7.83 s
Wall time: 7.84 s
sage: get_memory_usage() - m0
80.234375
```


With the patch:

```
sage: def test():
....:     for p in prime_range(10^5):
....:         K = GF(p)
....:         a = K(0)
....:         
sage: m0 = get_memory_usage()
sage: %time test()
CPU times: user 7.59 s, sys: 0.01 s, total: 7.60 s
Wall time: 7.61 s
sage: get_memory_usage() - m0
8.53515625
```


So, the memory does mildly increase, but it seems that most of the leak is fixed.

I think that a test of the kind

```
sage: get_memory_usage() - -m0 < 10
True
```

might be used as a doc test.



---

archive/issue_comments_125259.json:
```json
{
    "body": "Replying to [comment:34 SimonKing]:\n> Cc to Nicolas, since it concerns categories:\n> \n> Do we want that `Hom(1,1)` is still supported?\n> \n> I think it does not make sense at all to talk about the homomorphisms of the number 1 to the number 1. The problem (for my patch as it is posted here) is the fact that one can't create a weak reference to the number 1.\n\nI don't see much point either. We had a similar discussion a while ago about whether elements should be objects in a category, and as far as I remember, the answer was no by default (Element does not inherit from CategoryObject). So +1 on my side to kill this dubious feature. You might want to double check on sage-algebra just to make sure.",
    "created_at": "2011-12-19T22:18:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125259",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:34 SimonKing]:
> Cc to Nicolas, since it concerns categories:
> 
> Do we want that `Hom(1,1)` is still supported?
> 
> I think it does not make sense at all to talk about the homomorphisms of the number 1 to the number 1. The problem (for my patch as it is posted here) is the fact that one can't create a weak reference to the number 1.

I don't see much point either. We had a similar discussion a while ago about whether elements should be objects in a category, and as far as I remember, the answer was no by default (Element does not inherit from CategoryObject). So +1 on my side to kill this dubious feature. You might want to double check on sage-algebra just to make sure.



---

archive/issue_comments_125260.json:
```json
{
    "body": "Simon, you can also use the test suggested by Jean-Pierre Flori (see comment [comment:18] for an\nexample).\n\nPaul",
    "created_at": "2011-12-20T08:53:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125260",
    "user": "https://github.com/zimmermann6"
}
```

Simon, you can also use the test suggested by Jean-Pierre Flori (see comment [comment:18] for an
example).

Paul



---

archive/issue_comments_125261.json:
```json
{
    "body": "Hi Paul,\n\nReplying to [comment:42 zimmerma]:\n> Simon, you can also use the test suggested by Jean-Pierre Flori (see comment [comment:18] for an\n> example).\n\nYes, that looks good. With my patch, the test would be like\n\n```\nsage: for p in prime_range(10^5):\n....:     K = GF(p)\n....:     a = K(0)\n....:     \nsage: import gc\nsage: gc.collect()\n1881                                                                                                     \nsage: from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn as FF           \nsage: L = [x for x in gc.get_objects() if isinstance(x, FF)]\nsage: len(L), L[0], L[len(L)-1]\n(2, Finite Field of size 2, Finite Field of size 99991)\n```\n\n\nThe people at sage-devel somehow seem to agree that objects of a category should be instances of `CategoryObject` (which elements aren't!), and that we should thus drop the `Hom(2/3,8/1)` test.\n\nIn addition to that, I suggest to provide a better error message, something like\n\n```\nsage: Hom(2/3, 8/1)\nTraceback (most recent call last):\n...\nTypeError: Objects of categories must be instances of <type 'sage.structure.category_object.CategoryObject'>, but 2/3 isn't.\n```\n\n\nCheers,\n\nSimon",
    "created_at": "2011-12-20T09:16:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125261",
    "user": "https://github.com/simon-king-jena"
}
```

Hi Paul,

Replying to [comment:42 zimmerma]:
> Simon, you can also use the test suggested by Jean-Pierre Flori (see comment [comment:18] for an
> example).

Yes, that looks good. With my patch, the test would be like

```
sage: for p in prime_range(10^5):
....:     K = GF(p)
....:     a = K(0)
....:     
sage: import gc
sage: gc.collect()
1881                                                                                                     
sage: from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn as FF           
sage: L = [x for x in gc.get_objects() if isinstance(x, FF)]
sage: len(L), L[0], L[len(L)-1]
(2, Finite Field of size 2, Finite Field of size 99991)
```


The people at sage-devel somehow seem to agree that objects of a category should be instances of `CategoryObject` (which elements aren't!), and that we should thus drop the `Hom(2/3,8/1)` test.

In addition to that, I suggest to provide a better error message, something like

```
sage: Hom(2/3, 8/1)
Traceback (most recent call last):
...
TypeError: Objects of categories must be instances of <type 'sage.structure.category_object.CategoryObject'>, but 2/3 isn't.
```


Cheers,

Simon



---

archive/issue_comments_125262.json:
```json
{
    "body": "One bad detail: I'd like to add the test to the documentation of sage.categories.homset. However, if I insert it in the appropriate place, there will be a conflict with both #9138 and #11900.\n\nI could try to insert the test in a less logical place, in order to avoid to have a dependency.",
    "created_at": "2011-12-20T09:22:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125262",
    "user": "https://github.com/simon-king-jena"
}
```

One bad detail: I'd like to add the test to the documentation of sage.categories.homset. However, if I insert it in the appropriate place, there will be a conflict with both #9138 and #11900.

I could try to insert the test in a less logical place, in order to avoid to have a dependency.



---

archive/issue_comments_125263.json:
```json
{
    "body": "Changing keywords from \"\" to \"sd35\".",
    "created_at": "2011-12-20T09:22:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125263",
    "user": "https://github.com/simon-king-jena"
}
```

Changing keywords from "" to "sd35".



---

archive/issue_comments_125264.json:
```json
{
    "body": "I am very much afraid that I have not been able to make my patch independent of #11900. This is not just because of the documentation, but also because of some details in the choice of the homset's category.\n\nAnyway, it needs review (and so does the most recent version of #11900, by the way)!",
    "created_at": "2011-12-20T09:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125264",
    "user": "https://github.com/simon-king-jena"
}
```

I am very much afraid that I have not been able to make my patch independent of #11900. This is not just because of the documentation, but also because of some details in the choice of the homset's category.

Anyway, it needs review (and so does the most recent version of #11900, by the way)!



---

archive/issue_comments_125265.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2011-12-20T09:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125265",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_125266.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2011-12-20T12:04:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125266",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_125267.json:
```json
{
    "body": "I did try the new doctests in sage/categories/homset.py. However, with other patches applied, the number returned by `gc.collect()` changes.\n\nSo, for stability, I suggest to simplify the test, so that only the number of finite fields remaining in the cache is tested.",
    "created_at": "2011-12-20T12:04:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125267",
    "user": "https://github.com/simon-king-jena"
}
```

I did try the new doctests in sage/categories/homset.py. However, with other patches applied, the number returned by `gc.collect()` changes.

So, for stability, I suggest to simplify the test, so that only the number of finite fields remaining in the cache is tested.



---

archive/issue_comments_125268.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2011-12-20T14:05:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125268",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_125269.json:
```json
{
    "body": "I updated the patch.\n\nDifference to the previous patch: The number of objects collect by gc is marked as random (indeed, it will change with #11115 applied). What we are really interested in is the number of finite fields that remains in the cache after garbage collection. This number is two and is not random. Thus, that test is preserved.",
    "created_at": "2011-12-20T14:05:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125269",
    "user": "https://github.com/simon-king-jena"
}
```

I updated the patch.

Difference to the previous patch: The number of objects collect by gc is marked as random (indeed, it will change with #11115 applied). What we are really interested in is the number of finite fields that remains in the cache after garbage collection. This number is two and is not random. Thus, that test is preserved.



---

archive/issue_comments_125270.json:
```json
{
    "body": "I think I need help with debugging.\n\nWhen I have sage-4.8.alpha3 with #9138, #11900, #715 and #11115, then all doctests pass.\n\nWhen I also have #11521, then the test sage/rings/number_field/number_field_rel.py segfaults. When I run the tests in verbose mode, then all tests seem to pass, but in the very end it says\n\n```\n4 items had no tests:\n    __main__\n    __main__.change_warning_output\n    __main__.check_with_tolerance\n    __main__.warning_function\n69 items passed all tests:\n...\n660 tests in 73 items.\n660 passed and 0 failed.\nTest passed.\nThe doctested process was killed by signal 11\n         [15.0 s]\n```\n\nSo, could it be that not one of the tests was killed, but the test *process* itself?\n\nWhat is even more confusing: When I run the tests with the option -randorder, then most of the time the tests pass without a problem.\n\nCan you give me any pointer on how those things could possibly be debugged?",
    "created_at": "2011-12-25T15:13:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125270",
    "user": "https://github.com/simon-king-jena"
}
```

I think I need help with debugging.

When I have sage-4.8.alpha3 with #9138, #11900, #715 and #11115, then all doctests pass.

When I also have #11521, then the test sage/rings/number_field/number_field_rel.py segfaults. When I run the tests in verbose mode, then all tests seem to pass, but in the very end it says

```
4 items had no tests:
    __main__
    __main__.change_warning_output
    __main__.check_with_tolerance
    __main__.warning_function
69 items passed all tests:
...
660 tests in 73 items.
660 passed and 0 failed.
Test passed.
The doctested process was killed by signal 11
         [15.0 s]
```

So, could it be that not one of the tests was killed, but the test *process* itself?

What is even more confusing: When I run the tests with the option -randorder, then most of the time the tests pass without a problem.

Can you give me any pointer on how those things could possibly be debugged?



---

archive/issue_comments_125271.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2011-12-25T15:13:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125271",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_125272.json:
```json
{
    "body": "It sometimes happen that the sage session itself crash on exit. This is probably one of these. Last time I got one it was related to singular I think. It is quite difficult to corner these with gdb. The best you can hope is start a sage session with gdb and then try the last doctest sequence and quit sage, it may lead to the crash in which case you may have some luck with gdb. But this is one of these case where gdb itself may be interfering. I don't think I have time to look into this right now but I'll put it into my \"To do\" list in case it isn't solved when i have time to spare.",
    "created_at": "2011-12-25T22:45:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125272",
    "user": "https://github.com/kiwifb"
}
```

It sometimes happen that the sage session itself crash on exit. This is probably one of these. Last time I got one it was related to singular I think. It is quite difficult to corner these with gdb. The best you can hope is start a sage session with gdb and then try the last doctest sequence and quit sage, it may lead to the crash in which case you may have some luck with gdb. But this is one of these case where gdb itself may be interfering. I don't think I have time to look into this right now but I'll put it into my "To do" list in case it isn't solved when i have time to spare.



---

archive/issue_comments_125273.json:
```json
{
    "body": "Use weak references for the keys of the homset cache. If weak references are not supported, then raise an error, pointing out that category objects should be `CategoryObject`s.",
    "created_at": "2011-12-26T18:31:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125273",
    "user": "https://github.com/simon-king-jena"
}
```

Use weak references for the keys of the homset cache. If weak references are not supported, then raise an error, pointing out that category objects should be `CategoryObject`s.



---

archive/issue_comments_125274.json:
```json
{
    "body": "Attachment [trac11521_new_homset_cache.patch](tarball://root/attachments/some-uuid/ticket11521/trac11521_new_homset_cache.patch) by @simon-king-jena created at 2011-12-26 18:44:32\n\nI have attached a new patch version. It fixes the segfault I mentioned. However, it also does *not* fix the memory leak.\n\nThe difference between the two versions is: The new patch still uses weak references to the key of the cache, but a strong reference to the value (i.e., the homset).\n\nThe homset has a reference to domain and codomain, which constitute the cache key. Thus, I expected that it does not make any difference whether one has a strong or a weak reference to the homset. But I stand corrected. That needs to be investigated more deeply.",
    "created_at": "2011-12-26T18:44:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125274",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac11521_new_homset_cache.patch](tarball://root/attachments/some-uuid/ticket11521/trac11521_new_homset_cache.patch) by @simon-king-jena created at 2011-12-26 18:44:32

I have attached a new patch version. It fixes the segfault I mentioned. However, it also does *not* fix the memory leak.

The difference between the two versions is: The new patch still uses weak references to the key of the cache, but a strong reference to the value (i.e., the homset).

The homset has a reference to domain and codomain, which constitute the cache key. Thus, I expected that it does not make any difference whether one has a strong or a weak reference to the homset. But I stand corrected. That needs to be investigated more deeply.



---

archive/issue_comments_125275.json:
```json
{
    "body": "Dear Simon,\n\nThanks a lot for taking care of all of this !\n\nI'm just back from vacation and will have a look at all your patches in the following days.\n\n\nI must point out that even if the memory leak was small, it did still mater because I used a LOT of them and after several hours of computations it ate all the available memory the piece of code in the ticket description is just a minimal example, in my actual code I used different curves and similar simple computations on them)...\n\nAnd to make things clear, I must say I put that ticket as need review in order to get it closed as wont fix/duplicate because I thought it could be seen as a concrete example of ticket [ticket:715] and all the work could be done there.\n\nOf course youre the one currently doing all the wok, so do as you want :)\n\nCheers,\n\nJP",
    "created_at": "2011-12-26T20:28:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125275",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Dear Simon,

Thanks a lot for taking care of all of this !

I'm just back from vacation and will have a look at all your patches in the following days.


I must point out that even if the memory leak was small, it did still mater because I used a LOT of them and after several hours of computations it ate all the available memory the piece of code in the ticket description is just a minimal example, in my actual code I used different curves and similar simple computations on them)...

And to make things clear, I must say I put that ticket as need review in order to get it closed as wont fix/duplicate because I thought it could be seen as a concrete example of ticket [ticket:715] and all the work could be done there.

Of course youre the one currently doing all the wok, so do as you want :)

Cheers,

JP



---

archive/issue_comments_125276.json:
```json
{
    "body": "Hi Jean-Pierre,\n\nReplying to [comment:51 jpflori]:\n> I must point out that even if the memory leak was small, \n\nIt isn't small.\n\n> And to make things clear, I must say I put that ticket as need review in order to get it closed as wont fix/duplicate because I thought it could be seen as a concrete example of ticket [ticket:715] and all the work could be done there.\n\nI am not sure whether it would be good to do everything on one ticket, as the topics are related, but clearly disting: #715 is about weak \"`TripleDict`\" for coercion, #12215 is about a weak version of cached_function, and the ticket here is about the cache of homsets.\n\nOn the other hand: I am about to post a new patch here, with #715 as a dependency. It will use the new version of `TripleDict` from #715. So, one could argue that there is a common tool for both tickets, and they belong together.\n\nAnyway. The new patch will fix the leak, but it will not suffer from the segfaults.\n\nCheers,\n\nSimon",
    "created_at": "2011-12-26T20:39:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125276",
    "user": "https://github.com/simon-king-jena"
}
```

Hi Jean-Pierre,

Replying to [comment:51 jpflori]:
> I must point out that even if the memory leak was small, 

It isn't small.

> And to make things clear, I must say I put that ticket as need review in order to get it closed as wont fix/duplicate because I thought it could be seen as a concrete example of ticket [ticket:715] and all the work could be done there.

I am not sure whether it would be good to do everything on one ticket, as the topics are related, but clearly disting: #715 is about weak "`TripleDict`" for coercion, #12215 is about a weak version of cached_function, and the ticket here is about the cache of homsets.

On the other hand: I am about to post a new patch here, with #715 as a dependency. It will use the new version of `TripleDict` from #715. So, one could argue that there is a common tool for both tickets, and they belong together.

Anyway. The new patch will fix the leak, but it will not suffer from the segfaults.

Cheers,

Simon



---

archive/issue_comments_125277.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2011-12-26T20:57:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125277",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_125278.json:
```json
{
    "body": "I have attached another patch under a new name, using a new approach: The weak `TripleDict`, that I introduce at #715, is an appropriate tool for the cache of homsets. The key is the triple `(domain, codomain, category)`, and the value is a weak reference to the corresponding homset.\n\nThere is a new test (the same as in the other patch), showing that the leak is fixed. And all tests in sage/schemes, sage/rings, sage/categories and sage/structure pass.\n\nHence: Needs review!\n\nApply trac11521_triple_homset.patch",
    "created_at": "2011-12-26T20:57:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125278",
    "user": "https://github.com/simon-king-jena"
}
```

I have attached another patch under a new name, using a new approach: The weak `TripleDict`, that I introduce at #715, is an appropriate tool for the cache of homsets. The key is the triple `(domain, codomain, category)`, and the value is a weak reference to the corresponding homset.

There is a new test (the same as in the other patch), showing that the leak is fixed. And all tests in sage/schemes, sage/rings, sage/categories and sage/structure pass.

Hence: Needs review!

Apply trac11521_triple_homset.patch



---

archive/issue_comments_125279.json:
```json
{
    "body": "In fact *all* tests pass for me, with #9138, #11900, #11115, #715 and [attachment:trac11521_triple_homset.patch] applied on top of sage-4.8.alpha3.",
    "created_at": "2011-12-27T00:33:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125279",
    "user": "https://github.com/simon-king-jena"
}
```

In fact *all* tests pass for me, with #9138, #11900, #11115, #715 and [attachment:trac11521_triple_homset.patch] applied on top of sage-4.8.alpha3.



---

archive/issue_comments_125280.json:
```json
{
    "body": "Applied all patches mentionned in the previous comment without problems on sage-4.8.alpha5 and \"make ptestlong\" passed all tests.\nI'll try to check that the memory leaks actually disappeared :) today and have a look at your patches to give them positive reviews as well.",
    "created_at": "2011-12-28T08:09:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125280",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Applied all patches mentionned in the previous comment without problems on sage-4.8.alpha5 and "make ptestlong" passed all tests.
I'll try to check that the memory leaks actually disappeared :) today and have a look at your patches to give them positive reviews as well.



---

archive/issue_comments_125281.json:
```json
{
    "body": "It depends on what you call \"the\" leak.\n\nAt least, the patch fixes *one* leak, namely the one that is doctested against. I am not sure whether it is enough to fix the leak exposed in the ticket description:\n\n```\nsage: K = GF(1<<55,'t')\nsage: a = K.random_element()\nsage: get_memory_usage()\n872.26171875\nsage: while 1:\n....:     E = EllipticCurve(j=a)\n....:     P = E.random_point()\n....:     Q = 2*P;\n....:     print get_memory_usage()\n```\n\nThe memory usage does climb, but it climbs a lot slower than, for example, in sage-4.6.2.",
    "created_at": "2011-12-28T09:27:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125281",
    "user": "https://github.com/simon-king-jena"
}
```

It depends on what you call "the" leak.

At least, the patch fixes *one* leak, namely the one that is doctested against. I am not sure whether it is enough to fix the leak exposed in the ticket description:

```
sage: K = GF(1<<55,'t')
sage: a = K.random_element()
sage: get_memory_usage()
872.26171875
sage: while 1:
....:     E = EllipticCurve(j=a)
....:     P = E.random_point()
....:     Q = 2*P;
....:     print get_memory_usage()
```

The memory usage does climb, but it climbs a lot slower than, for example, in sage-4.6.2.



---

archive/issue_comments_125282.json:
```json
{
    "body": "PS: I just tested that even #12215 (which is a lot more aggressive in using weak references and fixes a gaping leak) is not enough to totally fix the example from the ticket description. Hence, I think that, for now, we should be happy with a partial fix and investigate the remaining problems on different tickets.",
    "created_at": "2011-12-28T09:36:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125282",
    "user": "https://github.com/simon-king-jena"
}
```

PS: I just tested that even #12215 (which is a lot more aggressive in using weak references and fixes a gaping leak) is not enough to totally fix the example from the ticket description. Hence, I think that, for now, we should be happy with a partial fix and investigate the remaining problems on different tickets.



---

archive/issue_comments_125283.json:
```json
{
    "body": "After running the example for a couple of minutes, interrupting and doing garbage collection, I find:\n\n```\nsage: from sage.schemes.elliptic_curves.ell_finite_field import EllipticCurve_finite_field\nsage: LE = [x for x in gc.get_objects() if  isinstance(x,EllipticCurve_finite_field)]\nsage: len(LE)\n632\nsage: import objgraph\nsage: from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn as FF\nsage: LF = [x for x in gc.get_objects() if isinstance(x, FF)]\nsage: len(LF)\n1\n```\n\n\nLF shows that one leak is fixed. However, the curves in LE, which are all defined over the same finite field, can not be collected.",
    "created_at": "2011-12-28T09:43:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125283",
    "user": "https://github.com/simon-king-jena"
}
```

After running the example for a couple of minutes, interrupting and doing garbage collection, I find:

```
sage: from sage.schemes.elliptic_curves.ell_finite_field import EllipticCurve_finite_field
sage: LE = [x for x in gc.get_objects() if  isinstance(x,EllipticCurve_finite_field)]
sage: len(LE)
632
sage: import objgraph
sage: from sage.rings.finite_rings.finite_field_prime_modn import FiniteField_prime_modn as FF
sage: LF = [x for x in gc.get_objects() if isinstance(x, FF)]
sage: len(LF)
1
```


LF shows that one leak is fixed. However, the curves in LE, which are all defined over the same finite field, can not be collected.



---

archive/issue_comments_125284.json:
```json
{
    "body": "Using objgraph, I found that the remaining leak seem to be related with `sage.schemes.generic.homset.SchemeHomsetModule_abelian_variety_coordinates_field_with_category`. Since this is another homset, it would make sense to try and fix it *here*.",
    "created_at": "2011-12-28T10:56:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125284",
    "user": "https://github.com/simon-king-jena"
}
```

Using objgraph, I found that the remaining leak seem to be related with `sage.schemes.generic.homset.SchemeHomsetModule_abelian_variety_coordinates_field_with_category`. Since this is another homset, it would make sense to try and fix it *here*.



---

archive/issue_comments_125285.json:
```json
{
    "body": "Aha!!\n\nI found that we have many *equal* instances of these scheme homsets:\n\n```\nsage: LE = [x for x in gc.get_objects() if isinstance(x,SchemeHomsetModule_abelian_variety_coordinates_field)]\nsage: LE[100] == LE[150]\nTrue\n```\n\n\nSo, I guess we should fix the memory leak by using `UniqueRepresentation` or `UniqueFactory`!",
    "created_at": "2011-12-28T11:03:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125285",
    "user": "https://github.com/simon-king-jena"
}
```

Aha!!

I found that we have many *equal* instances of these scheme homsets:

```
sage: LE = [x for x in gc.get_objects() if isinstance(x,SchemeHomsetModule_abelian_variety_coordinates_field)]
sage: LE[100] == LE[150]
True
```


So, I guess we should fix the memory leak by using `UniqueRepresentation` or `UniqueFactory`!



---

archive/issue_comments_125286.json:
```json
{
    "body": "My 2 cents: Isn't it somehow related to the fact that elliptic curves are not unique parents?\nIn some of my original tests, I used different curves and depending on the cache where they were stored \"equality\" testing was made either with \"is\" or with \"==\".\nIn the former case, the \"same\" elliptic curve would be stored several times making the \"leak\" even bigger.",
    "created_at": "2011-12-28T11:30:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125286",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

My 2 cents: Isn't it somehow related to the fact that elliptic curves are not unique parents?
In some of my original tests, I used different curves and depending on the cache where they were stored "equality" testing was made either with "is" or with "==".
In the former case, the "same" elliptic curve would be stored several times making the "leak" even bigger.



---

archive/issue_comments_125287.json:
```json
{
    "body": "OK. Then why not reduce the non-uniqueness? `EllipticCurve` could easily be turned into a cached function, which would mean that two elliptic curves became identical if they are defined by equal data. That is *not* enough to be a unique parent (there could be equal elliptic curves defined by different data), but it could be a step forward. And with #12215, it could then actually be turned into a *weak* cached function.",
    "created_at": "2011-12-28T12:22:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125287",
    "user": "https://github.com/simon-king-jena"
}
```

OK. Then why not reduce the non-uniqueness? `EllipticCurve` could easily be turned into a cached function, which would mean that two elliptic curves became identical if they are defined by equal data. That is *not* enough to be a unique parent (there could be equal elliptic curves defined by different data), but it could be a step forward. And with #12215, it could then actually be turned into a *weak* cached function.



---

archive/issue_comments_125288.json:
```json
{
    "body": "Yes, using a cached function would indeed fix the leak that is cause by the useless creation of creating an elliptic curve with the same basic data over and over again. In particular, it would fix the leak from the ticket description (#12215 is not needed for that).\n\nI am preparing a new patch (it requires do tests and stuff), so, it is \"needs work\" for now.",
    "created_at": "2011-12-28T12:32:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125288",
    "user": "https://github.com/simon-king-jena"
}
```

Yes, using a cached function would indeed fix the leak that is cause by the useless creation of creating an elliptic curve with the same basic data over and over again. In particular, it would fix the leak from the ticket description (#12215 is not needed for that).

I am preparing a new patch (it requires do tests and stuff), so, it is "needs work" for now.



---

archive/issue_comments_125289.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2011-12-28T12:32:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125289",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_125290.json:
```json
{
    "body": "It is definitely not easy. It seems that the elliptic curve code relies on the non-uniqueness of elliptic curves: I get loads of errors.",
    "created_at": "2011-12-28T12:40:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125290",
    "user": "https://github.com/simon-king-jena"
}
```

It is definitely not easy. It seems that the elliptic curve code relies on the non-uniqueness of elliptic curves: I get loads of errors.



---

archive/issue_comments_125291.json:
```json
{
    "body": "Ah! Tuples of elements of different rings can be equal, but the corresponding elliptic curves would be different. So, the ring needs to be part of the description.",
    "created_at": "2011-12-28T12:47:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125291",
    "user": "https://github.com/simon-king-jena"
}
```

Ah! Tuples of elements of different rings can be equal, but the corresponding elliptic curves would be different. So, the ring needs to be part of the description.



---

archive/issue_comments_125292.json:
```json
{
    "body": "I am undecided what we should do:\n\nWe could argue that my patch does fix some memory leak, and leave it like that (modulo comments of the reviewer, of course). In order to fix the memory leak exposed by the example from the ticket description, we have no chance but to have some kind of uniqueness for elliptic curves. But that is a different topic and should thus be dealt with on a different ticket (perhaps such ticket already exists?).\n\nOr we could argue that this ticket is about fixing the memory leak that is exposed in the description. Hence, we should do all necessary steps *here*.\n\nAnd then, there is still the question whether the number theorists really want the elliptic curves be \"weakly unique\" (i.e., identical if the given data are equal). In addition, we might want that the elliptic curve cache is weak - which might imply that we have to wait for #12215.\n\nWhat do you think?\n\nI guess I'll also ask on sage-nt.",
    "created_at": "2011-12-28T15:46:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125292",
    "user": "https://github.com/simon-king-jena"
}
```

I am undecided what we should do:

We could argue that my patch does fix some memory leak, and leave it like that (modulo comments of the reviewer, of course). In order to fix the memory leak exposed by the example from the ticket description, we have no chance but to have some kind of uniqueness for elliptic curves. But that is a different topic and should thus be dealt with on a different ticket (perhaps such ticket already exists?).

Or we could argue that this ticket is about fixing the memory leak that is exposed in the description. Hence, we should do all necessary steps *here*.

And then, there is still the question whether the number theorists really want the elliptic curves be "weakly unique" (i.e., identical if the given data are equal). In addition, we might want that the elliptic curve cache is weak - which might imply that we have to wait for #12215.

What do you think?

I guess I'll also ask on sage-nt.



---

archive/issue_comments_125293.json:
```json
{
    "body": "I think we can go your way and stop working on this ticket now (or rather once I've taken the time to go through your patches to properly review them).\nThus we can already some non negligible improvements merged.\n\nAnyway the problem of uniqueness of elliptic curve is highly non trivial and deserves its own ticket.\nI guess #11474 would be a right place to treat that problem.\nAn alternative would be to make this ticket depend on #11474.",
    "created_at": "2011-12-28T15:56:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125293",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I think we can go your way and stop working on this ticket now (or rather once I've taken the time to go through your patches to properly review them).
Thus we can already some non negligible improvements merged.

Anyway the problem of uniqueness of elliptic curve is highly non trivial and deserves its own ticket.
I guess #11474 would be a right place to treat that problem.
An alternative would be to make this ticket depend on #11474.



---

archive/issue_comments_125294.json:
```json
{
    "body": "Hi Jean-Pierre,\n\nindeed, you found the correct ticket.\n\nAnd there is no need to ask on sage-nt, since I already did before opening #11474: [Sage-nt](http://groups.google.com/group/sage-nt/browse_thread/thread/ec8d0ad14a819082/049bfad6fd0680d1) first seemed to agree that uniqueness is good, so I opened the ticket. But then, they became convinced that much of the elliptic curve stuff depends on choices (generators), so that we should consider elliptic curves to be mutable objects, for which we wouldn't like to have uniqueness.\n\nConsidering the discussion on sage-nt, #11474 probably is \"wontfix\".",
    "created_at": "2011-12-28T16:05:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125294",
    "user": "https://github.com/simon-king-jena"
}
```

Hi Jean-Pierre,

indeed, you found the correct ticket.

And there is no need to ask on sage-nt, since I already did before opening #11474: [Sage-nt](http://groups.google.com/group/sage-nt/browse_thread/thread/ec8d0ad14a819082/049bfad6fd0680d1) first seemed to agree that uniqueness is good, so I opened the ticket. But then, they became convinced that much of the elliptic curve stuff depends on choices (generators), so that we should consider elliptic curves to be mutable objects, for which we wouldn't like to have uniqueness.

Considering the discussion on sage-nt, #11474 probably is "wontfix".



---

archive/issue_comments_125295.json:
```json
{
    "body": "I am not sure whether we should really stop work right there. After all, it is still not 100% clear to me why the elliptic curve E, that is created in the loop in an increasing number of copies, can not be garbage collected.\n\nFirst, E is created, and some coercion into it is created. The coercion is cached. By #715, some key of the cache provides a weak reference to E. In addition, the coerce map refers to a homset, and the homset refers to its codomain, which is E. I wonder whether there is a chain of strong references from E to the homset (one could try to find out using objgraph, I guess). If there is, then we would have a reference cycle. If that was the case, then we needed to find a `__del__` method that prevents the cycle from being garbage collected.",
    "created_at": "2011-12-28T16:11:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125295",
    "user": "https://github.com/simon-king-jena"
}
```

I am not sure whether we should really stop work right there. After all, it is still not 100% clear to me why the elliptic curve E, that is created in the loop in an increasing number of copies, can not be garbage collected.

First, E is created, and some coercion into it is created. The coercion is cached. By #715, some key of the cache provides a weak reference to E. In addition, the coerce map refers to a homset, and the homset refers to its codomain, which is E. I wonder whether there is a chain of strong references from E to the homset (one could try to find out using objgraph, I guess). If there is, then we would have a reference cycle. If that was the case, then we needed to find a `__del__` method that prevents the cycle from being garbage collected.



---

archive/issue_comments_125296.json:
```json
{
    "body": "Objgraph only shows a reference left as _codomain in a dict in a SchemeHomsetModule_a_v_c_f (defined in sage.schemes.generic.homset).",
    "created_at": "2011-12-28T16:30:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125296",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Objgraph only shows a reference left as _codomain in a dict in a SchemeHomsetModule_a_v_c_f (defined in sage.schemes.generic.homset).



---

archive/issue_comments_125297.json:
```json
{
    "body": "The homset of points of the ab. group of the curve is itself reference by an IntegerMulAction, the point at infinity on the curve (no idea when it gets created) and a dict with 11 elements.\nI guess the problem might be that in addition to the _cache in sage.categories.homset the homset of points is directly link within the Action object ?\nThat could also be nonsense.",
    "created_at": "2011-12-28T17:13:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125297",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

The homset of points of the ab. group of the curve is itself reference by an IntegerMulAction, the point at infinity on the curve (no idea when it gets created) and a dict with 11 elements.
I guess the problem might be that in addition to the _cache in sage.categories.homset the homset of points is directly link within the Action object ?
That could also be nonsense.



---

archive/issue_comments_125298.json:
```json
{
    "body": "The `IntegerMulAction` should be fine, as it is stored in a `TripleDict` (hence, weakly, by #715). Where does the dict occur?",
    "created_at": "2011-12-28T18:47:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125298",
    "user": "https://github.com/simon-king-jena"
}
```

The `IntegerMulAction` should be fine, as it is stored in a `TripleDict` (hence, weakly, by #715). Where does the dict occur?



---

archive/issue_comments_125299.json:
```json
{
    "body": "I am a bit puzzled.\n\nI see that there are a couple of cycles, involving an elliptic curve, a `SchemeHomsetModule...`, an `IntegerMulAction`, and an `EllipticPoint_finit_field`. However, none of them has a `__del__` method, thus, the garbage collection should be able to collect the cycles.\n\nBut the backref graph also shows something that I don't understand: Apparently there is a top level dict with three items that points to the elliptic curve. Where is it?",
    "created_at": "2011-12-28T19:04:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125299",
    "user": "https://github.com/simon-king-jena"
}
```

I am a bit puzzled.

I see that there are a couple of cycles, involving an elliptic curve, a `SchemeHomsetModule...`, an `IntegerMulAction`, and an `EllipticPoint_finit_field`. However, none of them has a `__del__` method, thus, the garbage collection should be able to collect the cycles.

But the backref graph also shows something that I don't understand: Apparently there is a top level dict with three items that points to the elliptic curve. Where is it?



---

archive/issue_comments_125300.json:
```json
{
    "body": "I got it!!\n\nBy #715, both the keys and the value of `sage.structure.coerce_dict.TripleDict` are by weak reference -- if possible. If the value does not allow for a weak reference, then (to simplify code) a constant function is used instead.\n\nActions are stored in such `TripleDict`s. However, an `IntegerMulAction` can not be weakly referenced. Hence, there is a strong reference, and no garbage collection can occur (the value points back to the keys, hence, they can't be collected either).\n\nSolution: Make `IntegerMulAction` weakly referenceable! That should suffice.",
    "created_at": "2011-12-28T21:18:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125300",
    "user": "https://github.com/simon-king-jena"
}
```

I got it!!

By #715, both the keys and the value of `sage.structure.coerce_dict.TripleDict` are by weak reference -- if possible. If the value does not allow for a weak reference, then (to simplify code) a constant function is used instead.

Actions are stored in such `TripleDict`s. However, an `IntegerMulAction` can not be weakly referenced. Hence, there is a strong reference, and no garbage collection can occur (the value points back to the keys, hence, they can't be collected either).

Solution: Make `IntegerMulAction` weakly referenceable! That should suffice.



---

archive/issue_comments_125301.json:
```json
{
    "body": "It does not suffice. But I think it is a step to the right direction.",
    "created_at": "2011-12-28T21:22:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125301",
    "user": "https://github.com/simon-king-jena"
}
```

It does not suffice. But I think it is a step to the right direction.



---

archive/issue_comments_125302.json:
```json
{
    "body": "Apparently the weak reference to the value is not used in the `TripleDict`! So, I have to look at #715, perhaps I forgot to implement something there.",
    "created_at": "2011-12-28T21:39:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125302",
    "user": "https://github.com/simon-king-jena"
}
```

Apparently the weak reference to the value is not used in the `TripleDict`! So, I have to look at #715, perhaps I forgot to implement something there.



---

archive/issue_comments_125303.json:
```json
{
    "body": "Aha, I was mistaken: At #715 I only took care for weak references to the keys of `TripleDict`. The big question is whether we additionally want weak references to the values. I am somehow against doing this at #715.",
    "created_at": "2011-12-28T21:42:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125303",
    "user": "https://github.com/simon-king-jena"
}
```

Aha, I was mistaken: At #715 I only took care for weak references to the keys of `TripleDict`. The big question is whether we additionally want weak references to the values. I am somehow against doing this at #715.



---

archive/issue_comments_125304.json:
```json
{
    "body": "My point was that it seemed to me that there was some (not weak!) reference in the dictionary ZZ._action_hash pointing to the IntegerMulAction itself pointing to the curve and I thought it could prevent garbage collection.\n\nSo I added a cpdef function to be able to clear that dictionary and see if garbage collection occurs once it is emptied, however it is a the C level so kind of the whole Sage library had to be rebuilt and I had to go back home before rebuilding was finished...\n\nAnyway, I'll have a look at it tomorrow :)\n\nBy the way, have you any idea if dictionaries declared at the C level such as ZZ._action_hash are detected by objgraph ?",
    "created_at": "2011-12-28T21:54:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125304",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

My point was that it seemed to me that there was some (not weak!) reference in the dictionary ZZ._action_hash pointing to the IntegerMulAction itself pointing to the curve and I thought it could prevent garbage collection.

So I added a cpdef function to be able to clear that dictionary and see if garbage collection occurs once it is emptied, however it is a the C level so kind of the whole Sage library had to be rebuilt and I had to go back home before rebuilding was finished...

Anyway, I'll have a look at it tomorrow :)

By the way, have you any idea if dictionaries declared at the C level such as ZZ._action_hash are detected by objgraph ?



---

archive/issue_comments_125305.json:
```json
{
    "body": "Hi Jean-Pierre,\n\nThe thing with the _action_hash is a good finding. I thought it would be a `TripleDict`, but it is just a usual dict. And this could indeed be a problem. I don't know if this is visible to objgraph.\n\nBut also I think that in addition we have the problem of strong references to the values of `TripleDict`. In principle, one could use weak references for not only the keys but also to the values -- perhaps this could be done in #715.\n\nOr one could leave `TripleDict` as it is currently in #715, but explicitly use weak references to functors for coercion (which needs to be enabled first). _action_hash then has to use weak references as well.\n\nThere might be a speed problem, though.",
    "created_at": "2011-12-28T23:09:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125305",
    "user": "https://github.com/simon-king-jena"
}
```

Hi Jean-Pierre,

The thing with the _action_hash is a good finding. I thought it would be a `TripleDict`, but it is just a usual dict. And this could indeed be a problem. I don't know if this is visible to objgraph.

But also I think that in addition we have the problem of strong references to the values of `TripleDict`. In principle, one could use weak references for not only the keys but also to the values -- perhaps this could be done in #715.

Or one could leave `TripleDict` as it is currently in #715, but explicitly use weak references to functors for coercion (which needs to be enabled first). _action_hash then has to use weak references as well.

There might be a speed problem, though.



---

archive/issue_comments_125306.json:
```json
{
    "body": "For info, resetting ZZ._action_hash to {} is not sufficient to let the IntegerMulAction be garbage collected.\n\nObjgraph shows 3 objects pointing to the abelian group of points of the curve (itself pointing to the curve):\n- the IntegerMulAction\n- the point at infinity (?)\n- a dict of size 11 which is in fact an attribute (_Scheme__ring_point_homset) of the curve (as a scheme) itself.\n\nI'd be happy to test a weakref for values version of your patch regardless of the spedd impact.",
    "created_at": "2011-12-29T09:23:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125306",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

For info, resetting ZZ._action_hash to {} is not sufficient to let the IntegerMulAction be garbage collected.

Objgraph shows 3 objects pointing to the abelian group of points of the curve (itself pointing to the curve):
- the IntegerMulAction
- the point at infinity (?)
- a dict of size 11 which is in fact an attribute (_Scheme__ring_point_homset) of the curve (as a scheme) itself.

I'd be happy to test a weakref for values version of your patch regardless of the spedd impact.



---

archive/issue_comments_125307.json:
```json
{
    "body": "I guess you're solution should be the right one because resetting the coercion cache solves the problem, so dealing with it should be enough for the example in the ticket description.\n\nOnly one copy gets cached in _action_hash because the curves are equal (==) but not identical (is). However, if one uses (really) different curves, one of each gets also cached in _action_hash\n\nHere is\u00a0 small piece of code to test the effect of clearing different caches (the code to clear the ZZ cache is left as an exercise, anyway we should use weakrefs there):\n\n\n```\nsage: import gc, inspect\nsage: load /usr/share/shared/objgraph.py # or whatever you should type to use objgraph\nsage: from sage.schemes.elliptic_curves.ell_finite_field import EllipticCurve_finite_field\nsage: K = GF(1<<60, 't')\nsage: j = K.random_element()\nsage: for i in xrange(100):\n....:     E = EllipticCurve(j=j); P = E.random_point(); 2*P; del P; del E;\n....:\nsage: gc.collect()\n68\nsage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]\nsage: len(L)\n100\nsage: del L\nsage: get_coercion_model().reset_cache()\nsage: gc.collect()\n6172\nsage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]\nsage: len(L)\n1\nsage: del L\nsage: ZZ.del_hash()\nsage: gc.collect()\n56\nsage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]\nsage: len(L)\n0\nsage: del L\nsage: for i in xrange(100):\n....:     E = EllipticCurve(j=K.random_element()); P = E.random_point(); 2*P; del P; del E;\n....:\nsage: gc.collect()\n174\nsage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]\nsage: len(L)\n100\nsage: del L\nsage: get_coercion_model().reset_cache()\nsage: gc.collect()\n738\nsage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]\nsage: len(L) # _action_hash\n100\nsage: del L\nsage: ZZ.del_hash()\nsage: gc.collect()\n5742\nsage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]\nsage: len(L) # mmm got one left!!! not sure where it comes from yet...\n1\n```\n",
    "created_at": "2011-12-29T10:11:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125307",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I guess you're solution should be the right one because resetting the coercion cache solves the problem, so dealing with it should be enough for the example in the ticket description.

Only one copy gets cached in _action_hash because the curves are equal (==) but not identical (is). However, if one uses (really) different curves, one of each gets also cached in _action_hash

Here is  small piece of code to test the effect of clearing different caches (the code to clear the ZZ cache is left as an exercise, anyway we should use weakrefs there):


```
sage: import gc, inspect
sage: load /usr/share/shared/objgraph.py # or whatever you should type to use objgraph
sage: from sage.schemes.elliptic_curves.ell_finite_field import EllipticCurve_finite_field
sage: K = GF(1<<60, 't')
sage: j = K.random_element()
sage: for i in xrange(100):
....:     E = EllipticCurve(j=j); P = E.random_point(); 2*P; del P; del E;
....:
sage: gc.collect()
68
sage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]
sage: len(L)
100
sage: del L
sage: get_coercion_model().reset_cache()
sage: gc.collect()
6172
sage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]
sage: len(L)
1
sage: del L
sage: ZZ.del_hash()
sage: gc.collect()
56
sage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]
sage: len(L)
0
sage: del L
sage: for i in xrange(100):
....:     E = EllipticCurve(j=K.random_element()); P = E.random_point(); 2*P; del P; del E;
....:
sage: gc.collect()
174
sage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]
sage: len(L)
100
sage: del L
sage: get_coercion_model().reset_cache()
sage: gc.collect()
738
sage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]
sage: len(L) # _action_hash
100
sage: del L
sage: ZZ.del_hash()
sage: gc.collect()
5742
sage: L = [x for x in gc.get_objects() if isintance(x, EllipticCurve_finite_field)]
sage: len(L) # mmm got one left!!! not sure where it comes from yet...
1
```




---

archive/issue_comments_125308.json:
```json
{
    "body": "Hi Jean-Pierre,\n\nReplying to [comment:81 jpflori]:\n> I guess you're solution should be the right one because resetting the coercion cache solves the problem, so dealing with it should be enough for the example in the ticket description.\n\nBut it is not so easy because...\n\n> Only one copy gets cached in _action_hash because the curves are equal (==) but not identical (is).\n\n... elliptic curves are not unique parents.\n\n\nI think it would be a mistake to use a weak reference to the value of `TripleDict`. I tried and got many errors - and I think this was because some important data (homsets, actions, ...) was garbage collected even though there was still a strong reference to domain and codomain. In that situation, the value must not be garbage collected.\n\n> sage: len(L) # mmm got one left!!! not sure where it comes from yet...\n\nDon't forget the last copy of E that was defined in the loop!\n\nSince I think that a weak reference to the values of `TripleDict` won't work: What else could one do? Or perhaps I should try again: It could be that the errors came from the wrong choice of a callback function.",
    "created_at": "2011-12-29T14:44:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125308",
    "user": "https://github.com/simon-king-jena"
}
```

Hi Jean-Pierre,

Replying to [comment:81 jpflori]:
> I guess you're solution should be the right one because resetting the coercion cache solves the problem, so dealing with it should be enough for the example in the ticket description.

But it is not so easy because...

> Only one copy gets cached in _action_hash because the curves are equal (==) but not identical (is).

... elliptic curves are not unique parents.


I think it would be a mistake to use a weak reference to the value of `TripleDict`. I tried and got many errors - and I think this was because some important data (homsets, actions, ...) was garbage collected even though there was still a strong reference to domain and codomain. In that situation, the value must not be garbage collected.

> sage: len(L) # mmm got one left!!! not sure where it comes from yet...

Don't forget the last copy of E that was defined in the loop!

Since I think that a weak reference to the values of `TripleDict` won't work: What else could one do? Or perhaps I should try again: It could be that the errors came from the wrong choice of a callback function.



---

archive/issue_comments_125309.json:
```json
{
    "body": "Replying to [comment:82 SimonKing]:\n\n> Hi Jean-Pierre, Replying to [comment:81 jpflori]:\n> > I guess you're solution should be the right one because resetting the coercion cache solves the problem, so dealing with it should be enough for the example in the ticket description.\n> But it is not so easy because...\n> > Only one copy gets cached in _action_hash because the curves are equal (==) but not identical (is).\n> ... elliptic curves are not unique parents. \nYep :)\n>I think it would be a mistake to use a weak reference to the value of `TripleDict`. I tried and got many errors - and I think this was because some important data (homsets, actions, ...) was garbage collected even though there was still a strong reference to domain and codomain. In that situation, the value must not be garbage collected.\nI see...\n> > sage: len(L) # mmm got one left!!! not sure where it comes from yet...\n> Don't forget the last copy of E that was defined in the loop! \nIn the new code I posted I explicitely added \"del P; del E;\" to the loop so no copy should be left.\nWhat's even stranger is that this remaining copy appears after the second loop (with random j invariants so different curves) but not after the first one (with constant j invariant so only one curve)!\n>Since I think that a weak reference to the values of `TripleDict` won't work: What else could one do? Or perhaps I should try again: It could be that the errors came from the wrong choice of a callback function.\nMmm, have to think more about all of that...",
    "created_at": "2011-12-29T14:50:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125309",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Replying to [comment:82 SimonKing]:

> Hi Jean-Pierre, Replying to [comment:81 jpflori]:
> > I guess you're solution should be the right one because resetting the coercion cache solves the problem, so dealing with it should be enough for the example in the ticket description.
> But it is not so easy because...
> > Only one copy gets cached in _action_hash because the curves are equal (==) but not identical (is).
> ... elliptic curves are not unique parents. 
Yep :)
>I think it would be a mistake to use a weak reference to the value of `TripleDict`. I tried and got many errors - and I think this was because some important data (homsets, actions, ...) was garbage collected even though there was still a strong reference to domain and codomain. In that situation, the value must not be garbage collected.
I see...
> > sage: len(L) # mmm got one left!!! not sure where it comes from yet...
> Don't forget the last copy of E that was defined in the loop! 
In the new code I posted I explicitely added "del P; del E;" to the loop so no copy should be left.
What's even stranger is that this remaining copy appears after the second loop (with random j invariants so different curves) but not after the first one (with constant j invariant so only one curve)!
>Since I think that a weak reference to the values of `TripleDict` won't work: What else could one do? Or perhaps I should try again: It could be that the errors came from the wrong choice of a callback function.
Mmm, have to think more about all of that...



---

archive/issue_comments_125310.json:
```json
{
    "body": "I think I should describe the problem in more detail.\n\nCurrently,\n\n* There is a strong reference from `__main__` to the action and coercion caches that are stored in the coercion model. That's fine.\n* Parents store actions as well. Some of these parents (the integer ring, for example) will always stay in memory.\n* There is a strong reference from any action and homset back to domain and codomain, which are used as keys in the cache. I think that's fine: If a homset is alive then its domain and codomain must remain alive as well.\n* The action and coercion caches have a strong reference to the values.\n* There is no direct reference from domain and codomain to the homset.\n\nHence, if an action is stored in the action cache, then there will always be a chain of strong references from `__main__` via the cache to the action, and further to domain and codomain, so that it can not be collected.\n\nOn the other hand, if weak references to the values of the action and coercion caches are used, then an action or a coercion could die even when domain and codomain were still alive. That's probably not good. To the very least, it would imply that actions would be needed to be re-created over and over again.\n\nHow could that be solved?",
    "created_at": "2011-12-29T15:24:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125310",
    "user": "https://github.com/simon-king-jena"
}
```

I think I should describe the problem in more detail.

Currently,

* There is a strong reference from `__main__` to the action and coercion caches that are stored in the coercion model. That's fine.
* Parents store actions as well. Some of these parents (the integer ring, for example) will always stay in memory.
* There is a strong reference from any action and homset back to domain and codomain, which are used as keys in the cache. I think that's fine: If a homset is alive then its domain and codomain must remain alive as well.
* The action and coercion caches have a strong reference to the values.
* There is no direct reference from domain and codomain to the homset.

Hence, if an action is stored in the action cache, then there will always be a chain of strong references from `__main__` via the cache to the action, and further to domain and codomain, so that it can not be collected.

On the other hand, if weak references to the values of the action and coercion caches are used, then an action or a coercion could die even when domain and codomain were still alive. That's probably not good. To the very least, it would imply that actions would be needed to be re-created over and over again.

How could that be solved?



---

archive/issue_comments_125311.json:
```json
{
    "body": "If I understand correctly, the keys to all these dictionaries are triples and what you've done is that ift elements in that triple are weakrefs to non strongly refed objects, the key-value pair gets deleted so that garbage collection occur for these only weakrefed objects?\n\nTherefore, if ZZ._action_hash gets deleted, only weakrefs to the abelian groups of points of the curve should be left in the coercion model (in the second triple dict _action_maps) and it should not prevent garbage collection...",
    "created_at": "2011-12-29T16:12:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125311",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

If I understand correctly, the keys to all these dictionaries are triples and what you've done is that ift elements in that triple are weakrefs to non strongly refed objects, the key-value pair gets deleted so that garbage collection occur for these only weakrefed objects?

Therefore, if ZZ._action_hash gets deleted, only weakrefs to the abelian groups of points of the curve should be left in the coercion model (in the second triple dict _action_maps) and it should not prevent garbage collection...



---

archive/issue_comments_125312.json:
```json
{
    "body": "Maybe the problem is that the value in that last dict corresponding to the triple with a (abelian group of points of a) curve is a (weakref to unless not weakreferrable) the IntegerMulAction which itself has a strong ref to the curve which would prevent the curve to get collected?",
    "created_at": "2011-12-29T16:16:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125312",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Maybe the problem is that the value in that last dict corresponding to the triple with a (abelian group of points of a) curve is a (weakref to unless not weakreferrable) the IntegerMulAction which itself has a strong ref to the curve which would prevent the curve to get collected?



---

archive/issue_comments_125313.json:
```json
{
    "body": "This is basically what you concluded in [comment:74 Comment 74], so a solution could be to allow Functors to be weakreferreable or make them use weak refs for their [co]domains?\nYou posted that making making IntegerMulAction weak referrable is not enough, could you post a patch applying these ideas so that I can play with it?",
    "created_at": "2011-12-29T16:25:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125313",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

This is basically what you concluded in [comment:74 Comment 74], so a solution could be to allow Functors to be weakreferreable or make them use weak refs for their [co]domains?
You posted that making making IntegerMulAction weak referrable is not enough, could you post a patch applying these ideas so that I can play with it?



---

archive/issue_comments_125314.json:
```json
{
    "body": "Experimental patch using weak references for actions",
    "created_at": "2011-12-29T17:06:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125314",
    "user": "https://github.com/simon-king-jena"
}
```

Experimental patch using weak references for actions



---

archive/issue_comments_125315.json:
```json
{
    "body": "Attachment [weak_ref_to_functor.patch](tarball://root/attachments/some-uuid/ticket11521/weak_ref_to_functor.patch) by @simon-king-jena created at 2011-12-29 17:09:15\n\nI was mistaken: Using weak references to the actions (on top of the other patch) does fix the leak - see the experimental patch that I have just posted.\n\nI did not run any doctests on it, yet. But I tested that only one `SchemeHomsetModule...` survives the garbage collection (and I did not delete E).",
    "created_at": "2011-12-29T17:09:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125315",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [weak_ref_to_functor.patch](tarball://root/attachments/some-uuid/ticket11521/weak_ref_to_functor.patch) by @simon-king-jena created at 2011-12-29 17:09:15

I was mistaken: Using weak references to the actions (on top of the other patch) does fix the leak - see the experimental patch that I have just posted.

I did not run any doctests on it, yet. But I tested that only one `SchemeHomsetModule...` survives the garbage collection (and I did not delete E).



---

archive/issue_comments_125316.json:
```json
{
    "body": "I confirm the leak is fixed with your last patch, just launched a ptestlong.",
    "created_at": "2011-12-29T17:24:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125316",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I confirm the leak is fixed with your last patch, just launched a ptestlong.



---

archive/issue_comments_125317.json:
```json
{
    "body": "My first impression from some tests is that the additional patch causes a massive slow-down.",
    "created_at": "2011-12-29T17:41:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125317",
    "user": "https://github.com/simon-king-jena"
}
```

My first impression from some tests is that the additional patch causes a massive slow-down.



---

archive/issue_comments_125318.json:
```json
{
    "body": "I ran the sage test suite on the same pc, on a 4.8.alpha5 with patches and a 4.7.2 without patches, just on the schemes directory and got 1512 vs 1060 sec... some files required between 2 and 3 times more time (e.g. hyperelliptic_padic_field, heegner and ell_number_field which are already quite long, i'd say most of the file already long), others did not change at all.",
    "created_at": "2011-12-29T18:28:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125318",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I ran the sage test suite on the same pc, on a 4.8.alpha5 with patches and a 4.7.2 without patches, just on the schemes directory and got 1512 vs 1060 sec... some files required between 2 and 3 times more time (e.g. hyperelliptic_padic_field, heegner and ell_number_field which are already quite long, i'd say most of the file already long), others did not change at all.



---

archive/issue_comments_125319.json:
```json
{
    "body": "Replying to [comment:91 jpflori]:\n> I ran the sage test suite on the same pc, on a 4.8.alpha5 with patches and a 4.7.2 without patches, just on the schemes directory and got 1512 vs 1060 sec...\n\nThat is not half as bad as I thought! However, it is far from good.\n\nDo you also have the time with only the first patch, resp. with #715 only? After all, #715 uses weak references and may thus be responsible for some slow-down.",
    "created_at": "2011-12-29T19:03:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125319",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:91 jpflori]:
> I ran the sage test suite on the same pc, on a 4.8.alpha5 with patches and a 4.7.2 without patches, just on the schemes directory and got 1512 vs 1060 sec...

That is not half as bad as I thought! However, it is far from good.

Do you also have the time with only the first patch, resp. with #715 only? After all, #715 uses weak references and may thus be responsible for some slow-down.



---

archive/issue_comments_125320.json:
```json
{
    "body": "I have slightly modifies [attachment:trac11521_triple_homset.patch]: In the old version, I had created a `TripleDict(50)`, but meanwhile I learnt that the parameter of the `TripleDict` should not be even and should best be a prime number. In the new version, it is prime...\n\nConcerning the weak references: Why exactly is the experimental patch so slow? Is it because the access to the weakly referenced actions is so slow? Or is it because the actions are garbage collected even if their domain/codomain is still alive, so that the actions are uselessly created over and over again? I suspect it is the latter.",
    "created_at": "2011-12-29T22:38:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125320",
    "user": "https://github.com/simon-king-jena"
}
```

I have slightly modifies [attachment:trac11521_triple_homset.patch]: In the old version, I had created a `TripleDict(50)`, but meanwhile I learnt that the parameter of the `TripleDict` should not be even and should best be a prime number. In the new version, it is prime...

Concerning the weak references: Why exactly is the experimental patch so slow? Is it because the access to the weakly referenced actions is so slow? Or is it because the actions are garbage collected even if their domain/codomain is still alive, so that the actions are uselessly created over and over again? I suspect it is the latter.



---

archive/issue_comments_125321.json:
```json
{
    "body": "I guess you're right.\n\nHere is a piece of code emphasizing the problem.\n\n\n```\nsage: K = GF(1<<60, 't')\nsage: a = K.random_element()\nsage: E = EllipticCurve([1, 0, 0, 0, a])\nsage: P = E.random_point()\nsage: 2*P\n...\nsage: ZZ._introspect_coerce()['_action_hash']\n{(<type 'list'>, ...} # No Abelian group of points of the curve!!!\nsage: get_coercion_model().get_cache()[1]\n{(Integer Ring, Abelian group of points on Elliptic Curve defined by ..., <built-in function mul>): <weakref at ...; dead>, ...} # the \"dead\" are bad\n\n```\n\nIndeed, has all the dicts for coercion caches have weakrefs to their values, the actions get garbage collected. That becomes kind of tricky...\n\nAs pointed before, the problem is that if we let strong reference to the actions in the values of the dict, these action themselves have strong refs to the domain and codomain and so prevent the whole garbage collection to occur. Is it sensible to use weakrefs for [co]domains in Functors? Hence garbage collection can occur in the cache dicts, but if someone actually use functors directly, he must be sure to have some strong references to its domain and codomain somewhere to avoid garbage collection...\n\nAnother question: why not use a TripleDict in the parent class for the _action_hash dict rather that a WeakValueDict with three keys? That could somehow unify the approach taken here!",
    "created_at": "2011-12-30T09:14:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125321",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I guess you're right.

Here is a piece of code emphasizing the problem.


```
sage: K = GF(1<<60, 't')
sage: a = K.random_element()
sage: E = EllipticCurve([1, 0, 0, 0, a])
sage: P = E.random_point()
sage: 2*P
...
sage: ZZ._introspect_coerce()['_action_hash']
{(<type 'list'>, ...} # No Abelian group of points of the curve!!!
sage: get_coercion_model().get_cache()[1]
{(Integer Ring, Abelian group of points on Elliptic Curve defined by ..., <built-in function mul>): <weakref at ...; dead>, ...} # the "dead" are bad

```

Indeed, has all the dicts for coercion caches have weakrefs to their values, the actions get garbage collected. That becomes kind of tricky...

As pointed before, the problem is that if we let strong reference to the actions in the values of the dict, these action themselves have strong refs to the domain and codomain and so prevent the whole garbage collection to occur. Is it sensible to use weakrefs for [co]domains in Functors? Hence garbage collection can occur in the cache dicts, but if someone actually use functors directly, he must be sure to have some strong references to its domain and codomain somewhere to avoid garbage collection...

Another question: why not use a TripleDict in the parent class for the _action_hash dict rather that a WeakValueDict with three keys? That could somehow unify the approach taken here!



---

archive/issue_comments_125322.json:
```json
{
    "body": "Replying to [comment:94 jpflori]:\n> Indeed, has all the dicts for coercion caches have weakrefs to their values, the actions get garbage collected. That becomes kind of tricky...\n\nYes, and note that we have two locations for storing the actions:\n\n* in the coercion model\n* in the attribute `_action_hash` of parents.\n\nI found that having weak references in the coercion model is enough for fixing the leak - even if one has strong references in `_action_hash`. That is something I don't fully understand. In the example of the ticket description, we have an action of `ZZ`. `ZZ` is not subject to garbage collection, hence, having a strong reference in `ZZ._action_hash` should keep the action alive, and thus the elliptic curve (namely the different copies of E that are created in the loop). \n\nAnyway, even in that case we would see the drastic slow-down.\n \n> As pointed before, the problem is that if we let strong reference to the actions in the values of the dict, these action themselves have strong refs to the domain and codomain and so prevent the whole garbage collection to occur. Is it sensible to use weakrefs for [co]domains in Functors? Hence garbage collection can occur in the cache dicts, but if someone actually use functors directly, he must be sure to have some strong references to its domain and codomain somewhere to avoid garbage collection...\n\nIndeed that would be the consequence. I think that would not be acceptable: If the user keeps an action, then s/he can rightfully expect that domain and codomain are automatically kept alive.\n\n> Another question: why not use a TripleDict in the parent class for the _action_hash dict rather that a WeakValueDict with three keys? That could somehow unify the approach taken here!\n\nI was thinking of that, too. However, in addition to `_action_hash`, the parent also has a `_action_list`. And that might be a bigger problem.",
    "created_at": "2011-12-30T09:47:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125322",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:94 jpflori]:
> Indeed, has all the dicts for coercion caches have weakrefs to their values, the actions get garbage collected. That becomes kind of tricky...

Yes, and note that we have two locations for storing the actions:

* in the coercion model
* in the attribute `_action_hash` of parents.

I found that having weak references in the coercion model is enough for fixing the leak - even if one has strong references in `_action_hash`. That is something I don't fully understand. In the example of the ticket description, we have an action of `ZZ`. `ZZ` is not subject to garbage collection, hence, having a strong reference in `ZZ._action_hash` should keep the action alive, and thus the elliptic curve (namely the different copies of E that are created in the loop). 

Anyway, even in that case we would see the drastic slow-down.
 
> As pointed before, the problem is that if we let strong reference to the actions in the values of the dict, these action themselves have strong refs to the domain and codomain and so prevent the whole garbage collection to occur. Is it sensible to use weakrefs for [co]domains in Functors? Hence garbage collection can occur in the cache dicts, but if someone actually use functors directly, he must be sure to have some strong references to its domain and codomain somewhere to avoid garbage collection...

Indeed that would be the consequence. I think that would not be acceptable: If the user keeps an action, then s/he can rightfully expect that domain and codomain are automatically kept alive.

> Another question: why not use a TripleDict in the parent class for the _action_hash dict rather that a WeakValueDict with three keys? That could somehow unify the approach taken here!

I was thinking of that, too. However, in addition to `_action_hash`, the parent also has a `_action_list`. And that might be a bigger problem.



---

archive/issue_comments_125323.json:
```json
{
    "body": "Replying to [comment:95 SimonKing]:\n> Yes, and note that we have two locations for storing the actions: * in the coercion model * in the attribute `_action_hash` of parents. I found that having weak references in the coercion model is enough for fixing the leak - even if one has strong references in `_action_hash`. That is something I don't fully understand.\nAs I posted above in ZZ._action_hash equality is tested with \"==\" (rather than identity with \"is\") so in the code of the ticket description where only \"one\" curve is used, only one curve gets stored in _action_hash.\nIf you try the code posted some comments above where (really) different curves are used, you'll see that the leak is not fixed if you dont use a similar approach for _action_hash as for the coercion model.\n>In the example of the ticket description, we have an action of `ZZ`. `ZZ` is not subject to garbage collection, hence, having a strong reference in `ZZ._action_hash` should keep the action alive, and thus the elliptic curve (namely the different copies of E that are created in the loop).  Anyway, even in that case we would see the drastic slow-down.\n> Indeed that would be the consequence. I think that would not be acceptable: If the user keeps an action, then s/he can rightfully expect that domain and codomain are automatically kept alive.\nThe weakref domain and codomain in functors problem could be tackled by adding an optional parameter for the use of weakref.\n\nBy default, the behavior of functors would be as before with strong refs (and the option to false).\n\nFor the coercion models we would set the option to True and use weakref whenever possible.",
    "created_at": "2011-12-30T09:53:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125323",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Replying to [comment:95 SimonKing]:
> Yes, and note that we have two locations for storing the actions: * in the coercion model * in the attribute `_action_hash` of parents. I found that having weak references in the coercion model is enough for fixing the leak - even if one has strong references in `_action_hash`. That is something I don't fully understand.
As I posted above in ZZ._action_hash equality is tested with "==" (rather than identity with "is") so in the code of the ticket description where only "one" curve is used, only one curve gets stored in _action_hash.
If you try the code posted some comments above where (really) different curves are used, you'll see that the leak is not fixed if you dont use a similar approach for _action_hash as for the coercion model.
>In the example of the ticket description, we have an action of `ZZ`. `ZZ` is not subject to garbage collection, hence, having a strong reference in `ZZ._action_hash` should keep the action alive, and thus the elliptic curve (namely the different copies of E that are created in the loop).  Anyway, even in that case we would see the drastic slow-down.
> Indeed that would be the consequence. I think that would not be acceptable: If the user keeps an action, then s/he can rightfully expect that domain and codomain are automatically kept alive.
The weakref domain and codomain in functors problem could be tackled by adding an optional parameter for the use of weakref.

By default, the behavior of functors would be as before with strong refs (and the option to false).

For the coercion models we would set the option to True and use weakref whenever possible.



---

archive/issue_comments_125324.json:
```json
{
    "body": "Replying to [comment:96 jpflori]:\n> As I posted above in ZZ._action_hash equality is tested with \"==\" (rather than identity with \"is\") so in the code of the ticket description where only \"one\" curve is used, only one curve gets stored in _action_hash.\n\nYes, but then I don't understand why there is no error: In some places, the coercion model tests for identity, and raises a big fat \"coercion BUG\" otherwise.\n\n> The weakref domain and codomain in functors problem could be tackled by adding an optional parameter for the use of weakref.\n> \n> By default, the behavior of functors would be as before with strong refs (and the option to false).\n> \n> For the coercion models we would set the option to True and use weakref whenever possible.\n\nAgain, I believe that it must not be up to the user: \"Evidently\" (for a human), the different copies of E in the while loop can be garbage collected. It is our job to hammer the \"evidence\" into Sage. We shouldn't simply say \"let the user decide\" whether he wants a leak or a potential disaster: I would call it a disaster if one has an action and suddenly its codomain is gone.",
    "created_at": "2011-12-30T10:13:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125324",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:96 jpflori]:
> As I posted above in ZZ._action_hash equality is tested with "==" (rather than identity with "is") so in the code of the ticket description where only "one" curve is used, only one curve gets stored in _action_hash.

Yes, but then I don't understand why there is no error: In some places, the coercion model tests for identity, and raises a big fat "coercion BUG" otherwise.

> The weakref domain and codomain in functors problem could be tackled by adding an optional parameter for the use of weakref.
> 
> By default, the behavior of functors would be as before with strong refs (and the option to false).
> 
> For the coercion models we would set the option to True and use weakref whenever possible.

Again, I believe that it must not be up to the user: "Evidently" (for a human), the different copies of E in the while loop can be garbage collected. It is our job to hammer the "evidence" into Sage. We shouldn't simply say "let the user decide" whether he wants a leak or a potential disaster: I would call it a disaster if one has an action and suddenly its codomain is gone.



---

archive/issue_comments_125325.json:
```json
{
    "body": "Replying to [comment:97 SimonKing]:\n\n> Yes, but then I don't understand why there is no error: In some places, the coercion model tests for identity, and raises a big fat \"coercion BUG\" otherwise.\nI'll have a look at it, I'm not completely up to what the coercion model actually does :)\nI guess the doc could also be extended on that :)\n> \n> > The weakref domain and codomain in functors problem could be tackled by adding an optional parameter for the use of weakref.\n> > \n> > By default, the behavior of functors would be as before with strong refs (and the option to false).\n> > \n> > For the coercion models we would set the option to True and use weakref whenever possible.\n> \n> Again, I believe that it must not be up to the user: \"Evidently\" (for a human), the different copies of E in the while loop can be garbage collected. It is our job to hammer the \"evidence\" into Sage. We shouldn't simply say \"let the user decide\" whether he wants a leak or a potential disaster: I would call it a disaster if one has an action and suddenly its codomain is gone.\nThat would not really be up to the user if by default the functor does not use weakref, but if we change this behavior for the coercion model by switching the option. \nIt would be fatly documented not to set the option to True for general use, so normal use would not lead to problems.\nOf course it all depends on what you mean by \"up to the user\".\nOne could still intentionally set the option to true, and then cry that its codomain disappeared...",
    "created_at": "2011-12-30T10:34:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125325",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Replying to [comment:97 SimonKing]:

> Yes, but then I don't understand why there is no error: In some places, the coercion model tests for identity, and raises a big fat "coercion BUG" otherwise.
I'll have a look at it, I'm not completely up to what the coercion model actually does :)
I guess the doc could also be extended on that :)
> 
> > The weakref domain and codomain in functors problem could be tackled by adding an optional parameter for the use of weakref.
> > 
> > By default, the behavior of functors would be as before with strong refs (and the option to false).
> > 
> > For the coercion models we would set the option to True and use weakref whenever possible.
> 
> Again, I believe that it must not be up to the user: "Evidently" (for a human), the different copies of E in the while loop can be garbage collected. It is our job to hammer the "evidence" into Sage. We shouldn't simply say "let the user decide" whether he wants a leak or a potential disaster: I would call it a disaster if one has an action and suddenly its codomain is gone.
That would not really be up to the user if by default the functor does not use weakref, but if we change this behavior for the coercion model by switching the option. 
It would be fatly documented not to set the option to True for general use, so normal use would not lead to problems.
Of course it all depends on what you mean by "up to the user".
One could still intentionally set the option to true, and then cry that its codomain disappeared...



---

archive/issue_comments_125326.json:
```json
{
    "body": "In the verify_action of the coerce model there is a PY_TYPE_CHECK(action, IntegerMulAction) that might explain the absence of fat BUG.",
    "created_at": "2011-12-30T11:59:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125326",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

In the verify_action of the coerce model there is a PY_TYPE_CHECK(action, IntegerMulAction) that might explain the absence of fat BUG.



---

archive/issue_comments_125327.json:
```json
{
    "body": "Anyway, it does not make much sense to me that the _action_hash dict in the Parent class uses \"==\" rather than \"is\", especially since the TripleDict of the coercion model do.\nWhat do yo think? Have you any good reason to justify such a choice that I might have missed?",
    "created_at": "2011-12-30T12:53:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125327",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Anyway, it does not make much sense to me that the _action_hash dict in the Parent class uses "==" rather than "is", especially since the TripleDict of the coercion model do.
What do yo think? Have you any good reason to justify such a choice that I might have missed?



---

archive/issue_comments_125328.json:
```json
{
    "body": "Replying to [comment:100 jpflori]:\n> Anyway, it does not make much sense to me that the _action_hash dict in the Parent class uses \"==\" rather than \"is\", especially since the TripleDict of the coercion model do.\n\nThe old `TripleDict` didn't - I changed that only in #715. Perhaps it is debatable whether that change is fine. But:\n\n> What do yo think? Have you any good reason to justify such a choice that I might have missed?\n\nSee sage/structure/coerce.pyx:\n\n```\n            if y_mor is not None:\n                all.append(\"Coercion on right operand via\")\n                all.append(y_mor)\n                if res is not None and res is not y_mor.codomain():\n                    raise RuntimeError, (\"BUG in coercion model: codomains not equal!\", x_mor, y_mor)\n```\n\n\nThat is why I think one should test for identity, not equality.\n\nOn the other hand, we also have\n\n```\n        # Make sure the domains are correct\n        if R_map.domain() is not R:\n            if fix:\n                connecting = R_map.domain().coerce_map_from(R)\n                if connecting is not None:\n                    R_map = R_map * connecting\n            if R_map.domain() is not R:\n                raise RuntimeError, (\"BUG in coercion model, left domain must be original parent\", R, R_map)\n        if S_map is not None and S_map.domain() is not S:\n            if fix:\n                connecting = S_map.domain().coerce_map_from(S)\n                if connecting is not None:\n                    S_map = S_map * connecting\n            if S_map.domain() is not S:\n                raise RuntimeError, (\"BUG in coercion model, right domain must be original parent\", S, S_map)\n```\n\nin the same file. These lines apparently cope with the fact that there are non-unique parents, and they suggest that `==` is the right thing to do in the coerce caches.\n\nBut I think this is a discussion that belongs to #715.",
    "created_at": "2011-12-30T13:21:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125328",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:100 jpflori]:
> Anyway, it does not make much sense to me that the _action_hash dict in the Parent class uses "==" rather than "is", especially since the TripleDict of the coercion model do.

The old `TripleDict` didn't - I changed that only in #715. Perhaps it is debatable whether that change is fine. But:

> What do yo think? Have you any good reason to justify such a choice that I might have missed?

See sage/structure/coerce.pyx:

```
            if y_mor is not None:
                all.append("Coercion on right operand via")
                all.append(y_mor)
                if res is not None and res is not y_mor.codomain():
                    raise RuntimeError, ("BUG in coercion model: codomains not equal!", x_mor, y_mor)
```


That is why I think one should test for identity, not equality.

On the other hand, we also have

```
        # Make sure the domains are correct
        if R_map.domain() is not R:
            if fix:
                connecting = R_map.domain().coerce_map_from(R)
                if connecting is not None:
                    R_map = R_map * connecting
            if R_map.domain() is not R:
                raise RuntimeError, ("BUG in coercion model, left domain must be original parent", R, R_map)
        if S_map is not None and S_map.domain() is not S:
            if fix:
                connecting = S_map.domain().coerce_map_from(S)
                if connecting is not None:
                    S_map = S_map * connecting
            if S_map.domain() is not S:
                raise RuntimeError, ("BUG in coercion model, right domain must be original parent", S, S_map)
```

in the same file. These lines apparently cope with the fact that there are non-unique parents, and they suggest that `==` is the right thing to do in the coerce caches.

But I think this is a discussion that belongs to #715.



---

archive/issue_comments_125329.json:
```json
{
    "body": "My suggestion at #715 is to use a different way of comparison in the case of actions respectively coerce maps. This complies with existing defaults in sage/structure/coerce.pyx",
    "created_at": "2011-12-30T14:01:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125329",
    "user": "https://github.com/simon-king-jena"
}
```

My suggestion at #715 is to use a different way of comparison in the case of actions respectively coerce maps. This complies with existing defaults in sage/structure/coerce.pyx



---

archive/issue_comments_125330.json:
```json
{
    "body": "I agree to move the discussion for \"==\" and \"is\" to #715 (and also agree with your solution).\n\nSo, what about the original problem here and your thoughts about moving the weakref from the action itself to its domains and codomains?\n\nIf you really dislike the idea of having an option switched off by default (and a priori only on in the coercion model and not outside it unless one knows what he is doing), we could mimick what you wanna do with the TripleDict and have the usual Functor and a Functor_weakref version (or you can go the other way around and add an extra arg to the TripleDict constructor taking the equality operator as argument :) rather than having two classes)?",
    "created_at": "2011-12-30T14:11:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125330",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I agree to move the discussion for "==" and "is" to #715 (and also agree with your solution).

So, what about the original problem here and your thoughts about moving the weakref from the action itself to its domains and codomains?

If you really dislike the idea of having an option switched off by default (and a priori only on in the coercion model and not outside it unless one knows what he is doing), we could mimick what you wanna do with the TripleDict and have the usual Functor and a Functor_weakref version (or you can go the other way around and add an extra arg to the TripleDict constructor taking the equality operator as argument :) rather than having two classes)?



---

archive/issue_comments_125331.json:
```json
{
    "body": "Interestingly, the experimental patch for #715 that I have not submitted yet (need more tests) seems to be almost enough to fix the memory leak from the ticket description!\n\nNamely:\n\n```\nsage: <the usual loop>\nTraceback\n...\nKeyboardInterrupt: \nsage: import gc\nsage: gc.collect()\n585\nsage: from sage.schemes.generic.homset import SchemeHomsetModule_abelian_variety_coordinates_field\nsage: LE = [x for x in gc.get_objects() if  isinstance(x,SchemeHomsetModule_abelian_variety_coordinates_field)]\nsage: len(LE)\n2\n```\n\n\nAnd the experimental patch is *not* using weak references to the values of the `TripleDict` - only to the keys! Perhaps this ticket will eventually be a duplicate of #715?\n\nAnyway, I need more tests and will probably submit the patch to #715 later today.",
    "created_at": "2011-12-30T15:20:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125331",
    "user": "https://github.com/simon-king-jena"
}
```

Interestingly, the experimental patch for #715 that I have not submitted yet (need more tests) seems to be almost enough to fix the memory leak from the ticket description!

Namely:

```
sage: <the usual loop>
Traceback
...
KeyboardInterrupt: 
sage: import gc
sage: gc.collect()
585
sage: from sage.schemes.generic.homset import SchemeHomsetModule_abelian_variety_coordinates_field
sage: LE = [x for x in gc.get_objects() if  isinstance(x,SchemeHomsetModule_abelian_variety_coordinates_field)]
sage: len(LE)
2
```


And the experimental patch is *not* using weak references to the values of the `TripleDict` - only to the keys! Perhaps this ticket will eventually be a duplicate of #715?

Anyway, I need more tests and will probably submit the patch to #715 later today.



---

archive/issue_comments_125332.json:
```json
{
    "body": "If you used \"==\" for equality testing for actions in the coercion model (as in the parent caches) and let \"j=j\" in the \"usual piece of code\", this is not surprising because for \"==\" all the curves are equal, so there will be no duplication nor memory leak.\n\nTo perform a better test, you should replace j=j by j=K.random_element() in the constructor of the elliptic curve (as I did a few tickets up) to get really different curves (i.e. for \"is\" and for \"==\").\nI fear the memory leak is still there with this second example...",
    "created_at": "2011-12-30T15:25:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125332",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

If you used "==" for equality testing for actions in the coercion model (as in the parent caches) and let "j=j" in the "usual piece of code", this is not surprising because for "==" all the curves are equal, so there will be no duplication nor memory leak.

To perform a better test, you should replace j=j by j=K.random_element() in the constructor of the elliptic curve (as I did a few tickets up) to get really different curves (i.e. for "is" and for "==").
I fear the memory leak is still there with this second example...



---

archive/issue_comments_125333.json:
```json
{
    "body": "Experimental: Have to versions of `TripleDict`, using \"==\" or \"is\" for comparison",
    "created_at": "2011-12-30T23:18:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125333",
    "user": "https://github.com/simon-king-jena"
}
```

Experimental: Have to versions of `TripleDict`, using "==" or "is" for comparison



---

archive/issue_comments_125334.json:
```json
{
    "body": "Attachment [trac715_two_tripledicts.patch](tarball://root/attachments/some-uuid/ticket11521/trac715_two_tripledicts.patch) by @simon-king-jena created at 2011-12-30 23:26:52\n\nSorry, I have just posted a patch to the wrong ticket. The new patch belongs to #715, not to here. Just ignore it.",
    "created_at": "2011-12-30T23:26:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125334",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac715_two_tripledicts.patch](tarball://root/attachments/some-uuid/ticket11521/trac715_two_tripledicts.patch) by @simon-king-jena created at 2011-12-30 23:26:52

Sorry, I have just posted a patch to the wrong ticket. The new patch belongs to #715, not to here. Just ignore it.



---

archive/issue_comments_125335.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2012-01-03T11:08:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125335",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_125336.json:
```json
{
    "body": "Concerning \"wrong ticket\": Shouldn't we consider this ticket a duplicate of #715? After all, the examples from the two ticket descriptions are almost identical.",
    "created_at": "2012-01-03T11:08:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125336",
    "user": "https://github.com/simon-king-jena"
}
```

Concerning "wrong ticket": Shouldn't we consider this ticket a duplicate of #715? After all, the examples from the two ticket descriptions are almost identical.



---

archive/issue_comments_125337.json:
```json
{
    "body": "That's what I originally suggested :)\nSee the first comments on this ticket.\n\nWhen I found about ticket #715 I copied the description from here to there (I must have introduced some typographical difference in the way) because I thought the problem belonged there and the original description of ticket #715 was non-existent.",
    "created_at": "2012-01-03T11:12:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125337",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

That's what I originally suggested :)
See the first comments on this ticket.

When I found about ticket #715 I copied the description from here to there (I must have introduced some typographical difference in the way) because I thought the problem belonged there and the original description of ticket #715 was non-existent.



---

archive/issue_comments_125338.json:
```json
{
    "body": "Replying to [comment:108 jpflori]:\n> That's what I originally suggested :)\n> See the first comments on this ticket.\n> \n> When I found about ticket #715 I copied the description from here to there (I must have introduced some typographical difference in the way) because I thought the problem belonged there and the original description of ticket #715 was non-existent.\n\nI see. And I also found that I was originally responsible for not making it a duplicate.\n\nThe reason was that I found another leak: It is the strong cache for the homsets, and that is not addressed in #715.\n\nSo (question to the release manager), what shall we do? Mark this as a duplicate and open a different ticket for the cache of homsets? Or change the ticket description such that it is only about homsets, not about elliptic curves?",
    "created_at": "2012-01-03T11:48:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125338",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:108 jpflori]:
> That's what I originally suggested :)
> See the first comments on this ticket.
> 
> When I found about ticket #715 I copied the description from here to there (I must have introduced some typographical difference in the way) because I thought the problem belonged there and the original description of ticket #715 was non-existent.

I see. And I also found that I was originally responsible for not making it a duplicate.

The reason was that I found another leak: It is the strong cache for the homsets, and that is not addressed in #715.

So (question to the release manager), what shall we do? Mark this as a duplicate and open a different ticket for the cache of homsets? Or change the ticket description such that it is only about homsets, not about elliptic curves?



---

archive/issue_comments_125339.json:
```json
{
    "body": "before tagging that ticket as a duplicate of #715, I'd like to check the leak is indeed\nfixed with the (upcoming) patch of #715.\n\nPaul",
    "created_at": "2012-01-03T15:51:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125339",
    "user": "https://github.com/zimmermann6"
}
```

before tagging that ticket as a duplicate of #715, I'd like to check the leak is indeed
fixed with the (upcoming) patch of #715.

Paul



---

archive/issue_comments_125340.json:
```json
{
    "body": "I fear the work on #715 is far from being finished...",
    "created_at": "2012-01-03T15:56:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125340",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I fear the work on #715 is far from being finished...



---

archive/issue_comments_125341.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2012-01-04T16:11:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125341",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_125342.json:
```json
{
    "body": "The original example of this ticket is in fact fixed with #715, but I think the other problem should be dealt with here, namely by using a weak cache for homsets.",
    "created_at": "2012-01-04T16:13:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125342",
    "user": "https://github.com/simon-king-jena"
}
```

The original example of this ticket is in fact fixed with #715, but I think the other problem should be dealt with here, namely by using a weak cache for homsets.



---

archive/issue_comments_125343.json:
```json
{
    "body": "Note that with the patch applied on top of #715, the memleak is fixed:\n\n```\nsage: for p in prime_range(10^5):\n....:     K = GF(p)\n....:     a = K(0)\n....:     \nsage: import gc\nsage: gc.collect()\n8320\nsage: LE = [x for x in gc.get_objects() if  isinstance(x,type(K))]\nsage: len(LE)\n2\nsage: LE\n[Finite Field of size 2, Finite Field of size 99991]\n```\n\n\nLater today, I'll run doctests.",
    "created_at": "2012-01-04T16:36:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125343",
    "user": "https://github.com/simon-king-jena"
}
```

Note that with the patch applied on top of #715, the memleak is fixed:

```
sage: for p in prime_range(10^5):
....:     K = GF(p)
....:     a = K(0)
....:     
sage: import gc
sage: gc.collect()
8320
sage: LE = [x for x in gc.get_objects() if  isinstance(x,type(K))]
sage: len(LE)
2
sage: LE
[Finite Field of size 2, Finite Field of size 99991]
```


Later today, I'll run doctests.



---

archive/issue_comments_125344.json:
```json
{
    "body": "Note that the patch was written before the latest version of the patch from #715 was created. In particular, it uses `TripleDict`, but should better use `TripleDictById` (which hasn't been there when I wrote the patch).",
    "created_at": "2012-01-04T16:37:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125344",
    "user": "https://github.com/simon-king-jena"
}
```

Note that the patch was written before the latest version of the patch from #715 was created. In particular, it uses `TripleDict`, but should better use `TripleDictById` (which hasn't been there when I wrote the patch).



---

archive/issue_comments_125345.json:
```json
{
    "body": "Not bad: `make ptest` results in only one error with the patch and its dependencies applied on top of sage-5.0.prealpha0:\n\n```\nsage -t -force_lib \"devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx\"\nException AttributeError: 'PolynomialRing_field_with_category' object has no attribute '_modulus' in  ignored\nException AttributeError: 'PolynomialRing_field_with_category' object has no attribute '_modulus' in  ignored\n**********************************************************************\nFile \"/home/simon/SAGE/sage-5.0.prealpha0/devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx\", line 418:\n    sage: len(ring_refcount_dict) == n\nExpected:\n    True\nGot:\n    False\n**********************************************************************\n1 items had failures:\n   1 of  18 in __main__.example_4\n***Test Failed*** 1 failures.\nFor whitespace errors, see the file /home/simon/.sage//tmp/multi_polynomial_libsingular_6755.py\n         [3.6 s]\n \n----------------------------------------------------------------------\nThe following tests failed:\n\n\n        sage -t -force_lib \"devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx\"\nTotal time for all tests: 3.6 seconds\n```\n",
    "created_at": "2012-01-04T19:26:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125345",
    "user": "https://github.com/simon-king-jena"
}
```

Not bad: `make ptest` results in only one error with the patch and its dependencies applied on top of sage-5.0.prealpha0:

```
sage -t -force_lib "devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx"
Exception AttributeError: 'PolynomialRing_field_with_category' object has no attribute '_modulus' in  ignored
Exception AttributeError: 'PolynomialRing_field_with_category' object has no attribute '_modulus' in  ignored
**********************************************************************
File "/home/simon/SAGE/sage-5.0.prealpha0/devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx", line 418:
    sage: len(ring_refcount_dict) == n
Expected:
    True
Got:
    False
**********************************************************************
1 items had failures:
   1 of  18 in __main__.example_4
***Test Failed*** 1 failures.
For whitespace errors, see the file /home/simon/.sage//tmp/multi_polynomial_libsingular_6755.py
         [3.6 s]
 
----------------------------------------------------------------------
The following tests failed:


        sage -t -force_lib "devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx"
Total time for all tests: 3.6 seconds
```




---

archive/issue_comments_125346.json:
```json
{
    "body": "It turns out that the failing test had in fact a wrong design. It was:\n\n```\n            sage: import gc\n            sage: from sage.rings.polynomial.multi_polynomial_libsingular import MPolynomialRing_libsingular\n            sage: from sage.libs.singular.ring import ring_refcount_dict\n            sage: n = len(ring_refcount_dict)\n            sage: R = MPolynomialRing_libsingular(GF(547), 2, ('x', 'y'), TermOrder('degrevlex', 2))\n            sage: len(ring_refcount_dict) == n + 1\n            True\n\n            sage: Q = copy(R)   # indirect doctest\n            sage: p = R.gen(0) ^2+R.gen(1)^2\n            sage: q = copy(p)\n            sage: del R\n            sage: del Q\n            sage: del p\n            sage: del q\n            sage: gc.collect() # random output\n            sage: len(ring_refcount_dict) == n   \n            True\n```\n\n\nHence, before n is defined, no garbage collection takes place. This is, of course, not correct: The ring_refcount_dict may contain references to a ring created in another doctest, that is only garbage collected in the line before `len(ring_refcount_dict)==n`.\n\nIn other words: The test did not fail *because* there was a memory leak.\n\nWhen I insert a garbage collection right before the definition of n, the test works, and in addition the warning about `AttributeError` being ignored vanishes.\n\nThe patch fixes the memory leak caused by a strong homset cache (which was not addressed by #715):\n\n```\nsage: for p in prime_range(10^3):\n....:     K = GF(p)\n....:     a = K(0)\n....:     \nsage: import gc\nsage: gc.collect()\n3128\nsage: LE = [x for x in gc.get_objects() if  isinstance(x,type(K))]\nsage: LE\n[Finite Field of size 2, Finite Field of size 997]\n```\n\nThe patch adds a new doctest demonstrating that it is fixed.\n\nNeeds review!",
    "created_at": "2012-01-05T12:12:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125346",
    "user": "https://github.com/simon-king-jena"
}
```

It turns out that the failing test had in fact a wrong design. It was:

```
            sage: import gc
            sage: from sage.rings.polynomial.multi_polynomial_libsingular import MPolynomialRing_libsingular
            sage: from sage.libs.singular.ring import ring_refcount_dict
            sage: n = len(ring_refcount_dict)
            sage: R = MPolynomialRing_libsingular(GF(547), 2, ('x', 'y'), TermOrder('degrevlex', 2))
            sage: len(ring_refcount_dict) == n + 1
            True

            sage: Q = copy(R)   # indirect doctest
            sage: p = R.gen(0) ^2+R.gen(1)^2
            sage: q = copy(p)
            sage: del R
            sage: del Q
            sage: del p
            sage: del q
            sage: gc.collect() # random output
            sage: len(ring_refcount_dict) == n   
            True
```


Hence, before n is defined, no garbage collection takes place. This is, of course, not correct: The ring_refcount_dict may contain references to a ring created in another doctest, that is only garbage collected in the line before `len(ring_refcount_dict)==n`.

In other words: The test did not fail *because* there was a memory leak.

When I insert a garbage collection right before the definition of n, the test works, and in addition the warning about `AttributeError` being ignored vanishes.

The patch fixes the memory leak caused by a strong homset cache (which was not addressed by #715):

```
sage: for p in prime_range(10^3):
....:     K = GF(p)
....:     a = K(0)
....:     
sage: import gc
sage: gc.collect()
3128
sage: LE = [x for x in gc.get_objects() if  isinstance(x,type(K))]
sage: LE
[Finite Field of size 2, Finite Field of size 997]
```

The patch adds a new doctest demonstrating that it is fixed.

Needs review!



---

archive/issue_comments_125347.json:
```json
{
    "body": "I'll this patch as soon as 715 is finally closed.\n\nI think the ticket title also needs to be changed to reflect the issue addressed, namely that when homset are created, a strong ref is kept forever in sage.???.homset.",
    "created_at": "2012-01-05T17:20:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125347",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I'll this patch as soon as 715 is finally closed.

I think the ticket title also needs to be changed to reflect the issue addressed, namely that when homset are created, a strong ref is kept forever in sage.???.homset.



---

archive/issue_comments_125348.json:
```json
{
    "body": "When applying the new patch from #715, all tests pass. But when also applying the patch from here, `make ptest` results in\n\n```\nsage -t  -force_lib devel/sage/sage/libs/singular/ring.pyx # 6 doctests failed\n```\n\n\nThe failing tests concern `ring_refcount_dict` - and it is perhaps not surprising that a patch enabling garbage collection of rings has an influence on refcount, such as:\n\n```\n   sage: ring_ptr = set(ring_refcount_dict.keys()).difference(prev_rings).pop()\nException raised:\n    Traceback (most recent call last):\n      File \"/home/simon/SAGE/sage-5.0.prealpha0/local/bin/ncadoctest.py\", line 1231, in run_one_test\n        self.run_one_example(test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-5.0.prealpha0/local/bin/sagedoctest.py\", line 38, in run_one_example\n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/home/simon/SAGE/sage-5.0.prealpha0/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_8[9]>\", line 1, in <module>\n        ring_ptr = set(ring_refcount_dict.keys()).difference(prev_rings).pop()###line 452:\n    sage: ring_ptr = set(ring_refcount_dict.keys()).difference(prev_rings).pop()\n    KeyError: 'pop from an empty set'\n```\n\n\nAnyway, I need to analyse what happens, and provide a new patch after catching some sleep.\n\nJean-Pierre, I hope you like the new ticket title!",
    "created_at": "2012-01-09T23:43:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125348",
    "user": "https://github.com/simon-king-jena"
}
```

When applying the new patch from #715, all tests pass. But when also applying the patch from here, `make ptest` results in

```
sage -t  -force_lib devel/sage/sage/libs/singular/ring.pyx # 6 doctests failed
```


The failing tests concern `ring_refcount_dict` - and it is perhaps not surprising that a patch enabling garbage collection of rings has an influence on refcount, such as:

```
   sage: ring_ptr = set(ring_refcount_dict.keys()).difference(prev_rings).pop()
Exception raised:
    Traceback (most recent call last):
      File "/home/simon/SAGE/sage-5.0.prealpha0/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-5.0.prealpha0/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/simon/SAGE/sage-5.0.prealpha0/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_8[9]>", line 1, in <module>
        ring_ptr = set(ring_refcount_dict.keys()).difference(prev_rings).pop()###line 452:
    sage: ring_ptr = set(ring_refcount_dict.keys()).difference(prev_rings).pop()
    KeyError: 'pop from an empty set'
```


Anyway, I need to analyse what happens, and provide a new patch after catching some sleep.

Jean-Pierre, I hope you like the new ticket title!



---

archive/issue_comments_125349.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-01-09T23:43:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125349",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_125350.json:
```json
{
    "body": "Yes, better title !\n\nI've not have any time to have a look at these cache tickets in the last few days, but be sure I'll have a look soon.",
    "created_at": "2012-01-10T06:54:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125350",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Yes, better title !

I've not have any time to have a look at these cache tickets in the last few days, but be sure I'll have a look soon.



---

archive/issue_comments_125351.json:
```json
{
    "body": "Use the weak `TripleDict` from #715 for the cache of homsets",
    "created_at": "2012-01-10T08:26:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125351",
    "user": "https://github.com/simon-king-jena"
}
```

Use the weak `TripleDict` from #715 for the cache of homsets



---

archive/issue_comments_125352.json:
```json
{
    "body": "Attachment [trac11521_triple_homset.patch](tarball://root/attachments/some-uuid/ticket11521/trac11521_triple_homset.patch) by @simon-king-jena created at 2012-01-10 08:30:45\n\nThe doctest problem was easy enough to solve: When starting the example with a garbage collection, then things work. Actually I am surprised that the doctest framework does not do a garbage collection at the beginning of each example, in order to bring the system in a defined state - I'll ask on sage-devel.\n\nAnyway, since the problem is solved and the patch updated, stuff is now ready for review!\n\nApply trac11521_triple_homset.patch",
    "created_at": "2012-01-10T08:30:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125352",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac11521_triple_homset.patch](tarball://root/attachments/some-uuid/ticket11521/trac11521_triple_homset.patch) by @simon-king-jena created at 2012-01-10 08:30:45

The doctest problem was easy enough to solve: When starting the example with a garbage collection, then things work. Actually I am surprised that the doctest framework does not do a garbage collection at the beginning of each example, in order to bring the system in a defined state - I'll ask on sage-devel.

Anyway, since the problem is solved and the patch updated, stuff is now ready for review!

Apply trac11521_triple_homset.patch



---

archive/issue_comments_125353.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-01-10T08:30:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125353",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_125354.json:
```json
{
    "body": "Ive look at the patch and has nothing to say except for weakref being imported twice, I'll provided a reviewer patch for that.\n\nHa, maybe we should mention the caching system in the doc as well, I'm ready to do that in a reviewer patch as well.\n\nHowever, I'll wait for #715 to be closed before positive reviewing this one, just in case the changes there have consequences here (which should not be the case).",
    "created_at": "2012-01-24T13:42:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125354",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Ive look at the patch and has nothing to say except for weakref being imported twice, I'll provided a reviewer patch for that.

Ha, maybe we should mention the caching system in the doc as well, I'm ready to do that in a reviewer patch as well.

However, I'll wait for #715 to be closed before positive reviewing this one, just in case the changes there have consequences here (which should not be the case).



---

archive/issue_comments_125355.json:
```json
{
    "body": "Replying to [comment:122 jpflori]:\n> Ha, maybe we should mention the caching system in the doc as well, I'm ready to do that in a reviewer patch as well.\n\nOops, you are right! I thought I had add to the docs, but I just added a doctest, no elaborate explanation.",
    "created_at": "2012-01-24T15:12:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125355",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:122 jpflori]:
> Ha, maybe we should mention the caching system in the doc as well, I'm ready to do that in a reviewer patch as well.

Oops, you are right! I thought I had add to the docs, but I just added a doctest, no elaborate explanation.



---

archive/issue_comments_125356.json:
```json
{
    "body": "While finally looking at this ticket seriously and adding some doc, I remarked that if you run\n\n\n```\nsage: V = VectorSpace(QQ,3)\nsage: H = Hom(V,V)\nsage: H is Hom(V,V)\nFalse\n\n```\n\nWith this tickets patches but also WITHOUT them.\n\nIs this a consequence of #9138 ?\n\nWhat's strange is that V does not break the unique parent assumption:\n\n\n```\nsage: V is VectorSpace(QQ, 3)\nTrue\n\n```\n\nIs that intended because there is a ? It does not look very right to me.\n\nThe same \"problem\" occurs playing for example with finite fields...\n\nWith more classical stuff, the cache seems to work as intended\n\n\n```\nsage: H = Hom(ZZ, QQ)\nsage: H is Hom(ZZ, QQ)\nTrue\n\n```\n\nThis last point let me think that we can discuss and fix the VectorSpace situation elsewhere if this is indeed a problem.\n\nMy concern here is that it's hard to provide a \"smart\" example where the hom set is cached and where it can be garbage collected when its domainand codomain are.\n\nId on't think deleting ZZ and QQ is a good idea :) (and they would be refed elsewhere anyway)",
    "created_at": "2012-03-21T09:15:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125356",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

While finally looking at this ticket seriously and adding some doc, I remarked that if you run


```
sage: V = VectorSpace(QQ,3)
sage: H = Hom(V,V)
sage: H is Hom(V,V)
False

```

With this tickets patches but also WITHOUT them.

Is this a consequence of #9138 ?

What's strange is that V does not break the unique parent assumption:


```
sage: V is VectorSpace(QQ, 3)
True

```

Is that intended because there is a ? It does not look very right to me.

The same "problem" occurs playing for example with finite fields...

With more classical stuff, the cache seems to work as intended


```
sage: H = Hom(ZZ, QQ)
sage: H is Hom(ZZ, QQ)
True

```

This last point let me think that we can discuss and fix the VectorSpace situation elsewhere if this is indeed a problem.

My concern here is that it's hard to provide a "smart" example where the hom set is cached and where it can be garbage collected when its domainand codomain are.

Id on't think deleting ZZ and QQ is a good idea :) (and they would be refed elsewhere anyway)



---

archive/issue_comments_125357.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2012-03-21T09:15:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125357",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_125358.json:
```json
{
    "body": "My bad, in fact the \"issue\" seems to be that X._Hom_(Y, category) succeeds but returns non identical results.",
    "created_at": "2012-03-21T09:37:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125358",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

My bad, in fact the "issue" seems to be that X._Hom_(Y, category) succeeds but returns non identical results.



---

archive/issue_comments_125359.json:
```json
{
    "body": "Attachment [trac_11521-reviewer.patch](tarball://root/attachments/some-uuid/ticket11521/trac_11521-reviewer.patch) by jpflori created at 2012-03-21 10:18:42\n\nReviewer patch; added doc",
    "created_at": "2012-03-21T10:18:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125359",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Attachment [trac_11521-reviewer.patch](tarball://root/attachments/some-uuid/ticket11521/trac_11521-reviewer.patch) by jpflori created at 2012-03-21 10:18:42

Reviewer patch; added doc



---

archive/issue_comments_125360.json:
```json
{
    "body": "Here is a reviewer patch added a little doc.\n\nI hope you will find it satisfactory.\n\nIf so, feel free to set the ticket to positive review, I personnally feel happy with youre code.\n\nMy above rant, if it should be addressed, should be elsewhere.",
    "created_at": "2012-03-21T10:21:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125360",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Here is a reviewer patch added a little doc.

I hope you will find it satisfactory.

If so, feel free to set the ticket to positive review, I personnally feel happy with youre code.

My above rant, if it should be addressed, should be elsewhere.



---

archive/issue_comments_125361.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2012-03-21T10:21:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125361",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_125362.json:
```json
{
    "body": "To reiterate what I just posted at #715, I've just successfully run doctests against 5.0.beta10 with qseries\n\n```\ntrac715_one_triple_dict.patch\ntrac_715-reviewer.patch\ntrac_715-rebase_11599.patch\ntrac11521_triple_homset.patch\ntrac_11521-reviewer.patch\n```\n\n\nThe reviewer patch from jpflori looks fine to me. Is this ready to go now?",
    "created_at": "2012-03-26T13:25:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125362",
    "user": "https://github.com/loefflerd"
}
```

To reiterate what I just posted at #715, I've just successfully run doctests against 5.0.beta10 with qseries

```
trac715_one_triple_dict.patch
trac_715-reviewer.patch
trac_715-rebase_11599.patch
trac11521_triple_homset.patch
trac_11521-reviewer.patch
```


The reviewer patch from jpflori looks fine to me. Is this ready to go now?



---

archive/issue_comments_125363.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-03-26T13:28:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125363",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_125364.json:
```json
{
    "body": "The reviewer patch looks fine to me. Sorry that I did not react a few days ago. Since Jean-Pierre said I should set it to positive review, I am now doing so.",
    "created_at": "2012-03-26T13:28:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125364",
    "user": "https://github.com/simon-king-jena"
}
```

The reviewer patch looks fine to me. Sorry that I did not react a few days ago. Since Jean-Pierre said I should set it to positive review, I am now doing so.



---

archive/issue_comments_125365.json:
```json
{
    "body": "Attachment [trac_11521_homset_weakcache_combined.patch](tarball://root/attachments/some-uuid/ticket11521/trac_11521_homset_weakcache_combined.patch) by @simon-king-jena created at 2012-04-14 12:03:36\n\nUse the weak TripleDict from #715 for the cache of homsets. Includes the reviewer patch",
    "created_at": "2012-04-14T12:03:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125365",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_11521_homset_weakcache_combined.patch](tarball://root/attachments/some-uuid/ticket11521/trac_11521_homset_weakcache_combined.patch) by @simon-king-jena created at 2012-04-14 12:03:36

Use the weak TripleDict from #715 for the cache of homsets. Includes the reviewer patch



---

archive/issue_comments_125366.json:
```json
{
    "body": "I have created a combined patch, by folding the two patches (i.e., mine and Jean-Pierre's reviewer patch).\n\nWith #715 and this patch, all doctests pass on my machine. So, from my perspective, it is a positive review, but we should wait for Jean-Pierre's results on 32 bit.\n\nFor the patchbot:\n\nApply trac_11521_homset_weakcache_combined.patch",
    "created_at": "2012-04-14T12:05:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125366",
    "user": "https://github.com/simon-king-jena"
}
```

I have created a combined patch, by folding the two patches (i.e., mine and Jean-Pierre's reviewer patch).

With #715 and this patch, all doctests pass on my machine. So, from my perspective, it is a positive review, but we should wait for Jean-Pierre's results on 32 bit.

For the patchbot:

Apply trac_11521_homset_weakcache_combined.patch



---

archive/issue_comments_125367.json:
```json
{
    "body": "I'm just confirming that applying this patch & that at #715 to 5.0-beta13 on a 32-bit linux machine, all tests pass.",
    "created_at": "2012-04-17T19:05:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125367",
    "user": "https://github.com/JohnCremona"
}
```

I'm just confirming that applying this patch & that at #715 to 5.0-beta13 on a 32-bit linux machine, all tests pass.



---

archive/issue_events_011432.json:
```json
{
    "actor": "@jdemeyer",
    "created_at": "2012-05-06T12:14:48Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11349#event-11432"
}
```



---

archive/issue_comments_125368.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2012-05-06T12:14:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125368",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_comments_125369.json:
```json
{
    "body": "Unmerged because unmerging #12313 while keeping #11521 gives on OS X 10.6:\n\n```\n$ ./sage -t --verbose devel/sage/sage/misc/cachefunc.pyx\n[...]\nTrying:\n    P = QQ['a, b, c, d']; (a, b, c, d,) = P._first_ngens(4)###line 1038:_sage_    >>> P.<a,b,c,d> = QQ[]\nExpecting nothing\n\n------------------------------------------------------------------------\nUnhandled SIGSEGV: A segmentation fault occurred in Sage.\nThis probably occurred because a *compiled* component of Sage has a bug\nin it and is not properly wrapped with sig_on(), sig_off(). You might\nwant to run Sage under gdb with 'sage -gdb' to debug this.\nSage will now terminate.\n------------------------------------------------------------------------\n```\n",
    "created_at": "2012-07-05T08:37:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125369",
    "user": "https://github.com/jdemeyer"
}
```

Unmerged because unmerging #12313 while keeping #11521 gives on OS X 10.6:

```
$ ./sage -t --verbose devel/sage/sage/misc/cachefunc.pyx
[...]
Trying:
    P = QQ['a, b, c, d']; (a, b, c, d,) = P._first_ngens(4)###line 1038:_sage_    >>> P.<a,b,c,d> = QQ[]
Expecting nothing

------------------------------------------------------------------------
Unhandled SIGSEGV: A segmentation fault occurred in Sage.
This probably occurred because a *compiled* component of Sage has a bug
in it and is not properly wrapped with sig_on(), sig_off(). You might
want to run Sage under gdb with 'sage -gdb' to debug this.
Sage will now terminate.
------------------------------------------------------------------------
```




---

archive/issue_comments_125370.json:
```json
{
    "body": "Resolution changed from fixed to ",
    "created_at": "2012-07-05T08:37:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125370",
    "user": "https://github.com/jdemeyer"
}
```

Resolution changed from fixed to 



---

archive/issue_comments_125371.json:
```json
{
    "body": "Changing status from closed to new.",
    "created_at": "2012-07-05T08:37:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125371",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from closed to new.



---

archive/issue_events_011433.json:
```json
{
    "actor": "@jdemeyer",
    "created_at": "2012-07-05T08:37:08Z",
    "event": "reopened",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11349#event-11433"
}
```



---

archive/issue_comments_125372.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2012-07-13T11:52:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125372",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_125373.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-07-13T11:52:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125373",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_125374.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-07-23T14:54:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125374",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_125375.json:
```json
{
    "body": "I found that all tests pass on bsd.math, with\n\n```\ntrac12969_fix_coercion_cache.patch\ntrac12215_weak_cached_function-sk.patch\ntrac12215_segfault_fixes.patch\ntrac_715_combined.patch\ntrac_11521_homset_weakcache_combined.patch\ntrac_12313-mono_dict-combined-random-sk.patch\n```\n\napplied on top of sage-5.2.rc0. I think this justifies returning to needs_review. Or what is the work issue?",
    "created_at": "2012-07-23T14:54:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125375",
    "user": "https://github.com/simon-king-jena"
}
```

I found that all tests pass on bsd.math, with

```
trac12969_fix_coercion_cache.patch
trac12215_weak_cached_function-sk.patch
trac12215_segfault_fixes.patch
trac_715_combined.patch
trac_11521_homset_weakcache_combined.patch
trac_12313-mono_dict-combined-random-sk.patch
```

applied on top of sage-5.2.rc0. I think this justifies returning to needs_review. Or what is the work issue?



---

archive/issue_comments_125376.json:
```json
{
    "body": "I guess it main l'y lot of testing. Th\u00e9 code looked fine to me. But there were these random bugs potentially caused by \u00e0 bad interaction with another part of the code. Hopefully you fixed this with your latest conntributions.",
    "created_at": "2012-07-23T17:50:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125376",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I guess it main l'y lot of testing. Thé code looked fine to me. But there were these random bugs potentially caused by à bad interaction with another part of the code. Hopefully you fixed this with your latest conntributions.



---

archive/issue_comments_125377.json:
```json
{
    "body": "Replying to [comment:142 jpflori]:\n> I guess it main l'y lot of testing. Th\u00e9 code looked fine to me. But there were these random bugs potentially caused by \u00e0 bad interaction with another part of the code. Hopefully you fixed this with your latest conntributions.\n\nI think at some point #12969 must be used (which has fixed an error that depends on the order in which tests are executed), so, I made it a dependency. See the list of patches in my previous comment.\n\nWhat sporadic errors did actually occur, and on what system? I did one test run on bsd.math. Since the errors were sporadic, it might be good to test different variants (serially, parallely, with make test or with sage -pt) and multiple times.",
    "created_at": "2012-07-23T20:18:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125377",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:142 jpflori]:
> I guess it main l'y lot of testing. Thé code looked fine to me. But there were these random bugs potentially caused by à bad interaction with another part of the code. Hopefully you fixed this with your latest conntributions.

I think at some point #12969 must be used (which has fixed an error that depends on the order in which tests are executed), so, I made it a dependency. See the list of patches in my previous comment.

What sporadic errors did actually occur, and on what system? I did one test run on bsd.math. Since the errors were sporadic, it might be good to test different variants (serially, parallely, with make test or with sage -pt) and multiple times.



---

archive/issue_comments_125378.json:
```json
{
    "body": "I have run the tests on bsd.math in different ways. There has been no error.\n\nAccording to old logs of the patch bot,\n\n```\nsage -t  -force_lib \"devel/sage/sage/schemes/elliptic_curves/ell_number_field.py\"\n```\n\nused to crash sometimes. I repeated that test about 20 times both on my `OpenSuse` laptop and on bsd.math. Everything was fine.\n\nHence, I am confident that #12969 is indeed enough to solve the problems that were revealed by the other bunch of patches (#12215, #715, #11521, #12313).",
    "created_at": "2012-07-24T06:17:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125378",
    "user": "https://github.com/simon-king-jena"
}
```

I have run the tests on bsd.math in different ways. There has been no error.

According to old logs of the patch bot,

```
sage -t  -force_lib "devel/sage/sage/schemes/elliptic_curves/ell_number_field.py"
```

used to crash sometimes. I repeated that test about 20 times both on my `OpenSuse` laptop and on bsd.math. Everything was fine.

Hence, I am confident that #12969 is indeed enough to solve the problems that were revealed by the other bunch of patches (#12215, #715, #11521, #12313).



---

archive/issue_comments_125379.json:
```json
{
    "body": "**sage/categories/homset.py**:\n\n```\n_cache = TripleDict(53)\n```\n\nI guess this 53 is a tuned parameter. Can you comment on the choice?\n\nline 214\n\n```\n    try:\n        H = _cache[key]()\n    except KeyError:\n        H = None\n    if H:\n```\n\nCould it happen that bool(H) is false if H is not None? Perhaps safer to test\n`H is not None`? I'm not saying that you should. Just comment please.\n\nline 247 (same thing)\n\nline 263\n\n```\n    _cache[key] = weakref.ref(H)\n```\n\nCan you clarify the following: The way I read this is that H will not be\nprotected against GC (good!), but that `_cache` will be be storing a strong(?)\nreference to `key`, meaning that the entry in `_cache` under `key` will linger\nwith a dead weakref afterwards. Shouldn't there be a callback registered here\nwith the weakref that contacts `_cache` to remove the `key` entry when `H` gets\ncollected? It may be that your #715 changes already make `_cache` into essentially a\n`WeakKeyDict`, but it seems to me that `_cache` should still have a callback\nregistered on the `weakref` to `H` as well, to remove the entry if `H` gets GCd.\n\nI haven't done extensive testing myself, but you have and the bot happy, so I don't think me running tests would change much.",
    "created_at": "2012-08-15T20:01:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125379",
    "user": "https://github.com/nbruin"
}
```

**sage/categories/homset.py**:

```
_cache = TripleDict(53)
```

I guess this 53 is a tuned parameter. Can you comment on the choice?

line 214

```
    try:
        H = _cache[key]()
    except KeyError:
        H = None
    if H:
```

Could it happen that bool(H) is false if H is not None? Perhaps safer to test
`H is not None`? I'm not saying that you should. Just comment please.

line 247 (same thing)

line 263

```
    _cache[key] = weakref.ref(H)
```

Can you clarify the following: The way I read this is that H will not be
protected against GC (good!), but that `_cache` will be be storing a strong(?)
reference to `key`, meaning that the entry in `_cache` under `key` will linger
with a dead weakref afterwards. Shouldn't there be a callback registered here
with the weakref that contacts `_cache` to remove the `key` entry when `H` gets
collected? It may be that your #715 changes already make `_cache` into essentially a
`WeakKeyDict`, but it seems to me that `_cache` should still have a callback
registered on the `weakref` to `H` as well, to remove the entry if `H` gets GCd.

I haven't done extensive testing myself, but you have and the bot happy, so I don't think me running tests would change much.



---

archive/issue_comments_125380.json:
```json
{
    "body": "Replying to [comment:145 nbruin]:\n> **sage/categories/homset.py**:\n> {{{\n> _cache = TripleDict(53)\n> }}}\n> I guess this 53 is a tuned parameter. Can you comment on the choice?\n\nMy patch in #715 is, of course, based on old code. In the old code, there were comments on the choice of the parameter, that I summarise here. The parameter gives the initial number of buckets in a `TripleDict`. Thus, in order to ensure a good distribution of the items into the buckets, the parameter should be prime and should certainly not be even; there actually is a doc test that shows what happens if the parameter is even. It should not be too big, because it determines the number of empty buckets that are created during initialisation of the `TripleDict`. And it should not be too small, because otherwise the `TripleDict` would soon be resized (which is a costly operation).\n\nI thought that 53 is a good choice, given these comments. However, it is not tuned by experiments.\n\n> line 214 ...\n> Could it happen that bool(H) is false if H is not None? Perhaps safer to test\n> `H is not None`? I'm not saying that you should. Just comment please.\n\nThat line is old code that has not been introduced by my patch, right? I think one *should* test `H is not None` - mainly for speed, but also for preventing that bool(H) is false even though H is not None.\n\n> line 247 (same thing)\n> \n> line 263\n> {{{\n>     _cache[key] = weakref.ref(H)\n> }}}\n> Can you clarify the following: The way I read this is that H will not be\n> protected against GC (good!), but that `_cache` will be be storing a strong(?)\n> reference to `key`, meaning that the entry in `_cache` under `key` will linger\n> with a dead weakref afterwards.\n\nCorrect, at least theoretically.\n\nThe reason for the code was that at some point one needed to break a chain of strong references. In the memory leak fixed here, there was a reference from H back to the keys under which H is stored in the `TripleDict`. Hence, practically, when H gets collected, the item in the `TripleDict` becomes collectable as well. Hence, the dead weakref will soon vanish.\n\nAt least, that's what *should* happen. But:\n\n> Shouldn't there be a callback registered here\n> with the weakref that contacts `_cache` to remove the `key` entry when `H` gets\n> collected? It may be that your #715 changes already make `_cache` into essentially a\n> `WeakKeyDict`,\n\nYes. A `WeakKeyDict`, but not a `WeakValueDict`. That's why I am using a weak reference to H.\n\n> but it seems to me that `_cache` should still have a callback\n> registered on the `weakref` to `H` as well, to remove the entry if `H` gets GCd.\n\nRecall that each `TripleDict` has an eraser. I think, at least with the new patch at #715 that I have posted today, such a callback would be easily possible.\n\n> I haven't done extensive testing myself, but you have and the bot happy, so I don't think me running tests would change much.\n\nWell, in an ideal world, a different brain will be able to invent different stress tests, thus, find different bugs...\n\nAnyway. I think I should turn `if H:` into `if H is not None:` and should introduce a callback to the weak reference.",
    "created_at": "2012-08-16T14:57:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125380",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:145 nbruin]:
> **sage/categories/homset.py**:
> {{{
> _cache = TripleDict(53)
> }}}
> I guess this 53 is a tuned parameter. Can you comment on the choice?

My patch in #715 is, of course, based on old code. In the old code, there were comments on the choice of the parameter, that I summarise here. The parameter gives the initial number of buckets in a `TripleDict`. Thus, in order to ensure a good distribution of the items into the buckets, the parameter should be prime and should certainly not be even; there actually is a doc test that shows what happens if the parameter is even. It should not be too big, because it determines the number of empty buckets that are created during initialisation of the `TripleDict`. And it should not be too small, because otherwise the `TripleDict` would soon be resized (which is a costly operation).

I thought that 53 is a good choice, given these comments. However, it is not tuned by experiments.

> line 214 ...
> Could it happen that bool(H) is false if H is not None? Perhaps safer to test
> `H is not None`? I'm not saying that you should. Just comment please.

That line is old code that has not been introduced by my patch, right? I think one *should* test `H is not None` - mainly for speed, but also for preventing that bool(H) is false even though H is not None.

> line 247 (same thing)
> 
> line 263
> {{{
>     _cache[key] = weakref.ref(H)
> }}}
> Can you clarify the following: The way I read this is that H will not be
> protected against GC (good!), but that `_cache` will be be storing a strong(?)
> reference to `key`, meaning that the entry in `_cache` under `key` will linger
> with a dead weakref afterwards.

Correct, at least theoretically.

The reason for the code was that at some point one needed to break a chain of strong references. In the memory leak fixed here, there was a reference from H back to the keys under which H is stored in the `TripleDict`. Hence, practically, when H gets collected, the item in the `TripleDict` becomes collectable as well. Hence, the dead weakref will soon vanish.

At least, that's what *should* happen. But:

> Shouldn't there be a callback registered here
> with the weakref that contacts `_cache` to remove the `key` entry when `H` gets
> collected? It may be that your #715 changes already make `_cache` into essentially a
> `WeakKeyDict`,

Yes. A `WeakKeyDict`, but not a `WeakValueDict`. That's why I am using a weak reference to H.

> but it seems to me that `_cache` should still have a callback
> registered on the `weakref` to `H` as well, to remove the entry if `H` gets GCd.

Recall that each `TripleDict` has an eraser. I think, at least with the new patch at #715 that I have posted today, such a callback would be easily possible.

> I haven't done extensive testing myself, but you have and the bot happy, so I don't think me running tests would change much.

Well, in an ideal world, a different brain will be able to invent different stress tests, thus, find different bugs...

Anyway. I think I should turn `if H:` into `if H is not None:` and should introduce a callback to the weak reference.



---

archive/issue_comments_125381.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-08-16T14:57:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125381",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_125382.json:
```json
{
    "body": "Another comment: I use a weak reference to H (the homset) on the one hand, and a weak reference to the category C as the third argument to the `TripleDict`, on the other hand (see line 212). Since the keys of a `TripleDict` are compared by identity and not by equality, I can not use a callback function in the weak reference to C. Namely, weakref.ref(C) is identical with weakref.ref(C), whereas two weak references with callback are equal but not identical.\n\nIn conclusion, I will use a callback in the weak reference to H, so that the dictionary item gets collected as soon as H gets collected. But I think I can not use a callback in the weak reference to C. Anyway, a callback for C is not needed: If H is alive, it has a reference to C and keeps C alive. If H dies, then the callback for the weak reference to H will remove the item, and thus C can be collected as well.",
    "created_at": "2012-08-16T15:13:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125382",
    "user": "https://github.com/simon-king-jena"
}
```

Another comment: I use a weak reference to H (the homset) on the one hand, and a weak reference to the category C as the third argument to the `TripleDict`, on the other hand (see line 212). Since the keys of a `TripleDict` are compared by identity and not by equality, I can not use a callback function in the weak reference to C. Namely, weakref.ref(C) is identical with weakref.ref(C), whereas two weak references with callback are equal but not identical.

In conclusion, I will use a callback in the weak reference to H, so that the dictionary item gets collected as soon as H gets collected. But I think I can not use a callback in the weak reference to C. Anyway, a callback for C is not needed: If H is alive, it has a reference to C and keeps C alive. If H dies, then the callback for the weak reference to H will remove the item, and thus C can be collected as well.



---

archive/issue_comments_125383.json:
```json
{
    "body": "Now I wonder: Why did I explicitly put a weak reference to the category as a key for the `TripleDict`? Would the `TripleDict` not use weak references to *all three* parts of the key?\n\nI think the reason for the \"weakref.ref(category)\" was that in older versions of `TripleDict` I did indeed not use a weak reference to the third part of the key.",
    "created_at": "2012-08-16T17:35:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125383",
    "user": "https://github.com/simon-king-jena"
}
```

Now I wonder: Why did I explicitly put a weak reference to the category as a key for the `TripleDict`? Would the `TripleDict` not use weak references to *all three* parts of the key?

I think the reason for the "weakref.ref(category)" was that in older versions of `TripleDict` I did indeed not use a weak reference to the third part of the key.



---

archive/issue_comments_125384.json:
```json
{
    "body": "Attachment [trac_11521_callback.patch](tarball://root/attachments/some-uuid/ticket11521/trac_11521_callback.patch) by @simon-king-jena created at 2012-08-16 17:48:04\n\nUse a callback, to make sure that items in the homset cache are deleted if the homset is garbage collected",
    "created_at": "2012-08-16T17:48:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125384",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_11521_callback.patch](tarball://root/attachments/some-uuid/ticket11521/trac_11521_callback.patch) by @simon-king-jena created at 2012-08-16 17:48:04

Use a callback, to make sure that items in the homset cache are deleted if the homset is garbage collected



---

archive/issue_comments_125385.json:
```json
{
    "body": "OK, the additional patch has been posted. It removes the explicit weak reference to the category (`TripleDict` uses a weak reference anyway), adds a callback to the weak reference to the homset, so that an item of the homset cache gets deleted if the homset is garbage collected, and it replaces \"if H:\" by \"if H is not None:\".\n\nI doctested sage/schemes/ (heuristics: Most bugs I ever authored resulted in a segfault in sage/schemes :), sage/structure/ and sage/categories/homset.py (hence, the memory leak remains fixed).\n\nApply #715 trac_11521_homset_weakcache_combined.patch trac_11521_callback.patch",
    "created_at": "2012-08-16T17:52:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125385",
    "user": "https://github.com/simon-king-jena"
}
```

OK, the additional patch has been posted. It removes the explicit weak reference to the category (`TripleDict` uses a weak reference anyway), adds a callback to the weak reference to the homset, so that an item of the homset cache gets deleted if the homset is garbage collected, and it replaces "if H:" by "if H is not None:".

I doctested sage/schemes/ (heuristics: Most bugs I ever authored resulted in a segfault in sage/schemes :), sage/structure/ and sage/categories/homset.py (hence, the memory leak remains fixed).

Apply #715 trac_11521_homset_weakcache_combined.patch trac_11521_callback.patch



---

archive/issue_comments_125386.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-08-16T17:52:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125386",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_125387.json:
```json
{
    "body": "Good to go! (Note that the patchbot being happy here shows that #715 is fine too. Tickets apparently cannot have post-dependencies)",
    "created_at": "2012-08-16T22:08:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125387",
    "user": "https://github.com/nbruin"
}
```

Good to go! (Note that the patchbot being happy here shows that #715 is fine too. Tickets apparently cannot have post-dependencies)



---

archive/issue_comments_125388.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-08-16T22:08:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125388",
    "user": "https://github.com/nbruin"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_125389.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2012-08-20T20:27:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125389",
    "user": "https://github.com/nbruin"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_125390.json:
```json
{
    "body": "Aw, this weakref caching stuff is very headache-inducing. My sincere apologies. I'm afraid I have to withdraw my positive review due to a previous failure in my logic. As I see it now, the current patch reduces the caching of coercion maps to near uselessness. The fact that it DOES seem to work to some extent might give a lead to why other things are going wrong. Let me try:\n\nIgnoring the weakref on H for now, the coercion cache here consists of a TripleDict, stored on Y, indexing\n\n```\n(X,Y,C) : H\n```\n\nor\n\n```\n(X,Y,C): None\n```\n\nHere `H` is a map from `X` to `Y` wrt to the category `C`, so it stores strong references to `X`,`Y`,`C`. That means that as long as `H` is alive, no component of the key will die, so the fact that this is stored in a `TripleDict` is irrelevant: The value `H` would keep the key alive anyway. The only exception is the value `None`. There the `TripleDict` does exactly what it should.\n\nThis cycle problem is fixed by weakreffing `H`. But the whole point of the cache is to keep `H` alive as long as all of `X`, `Y` and `C` exist, so that we can look it up. Since the normal use for coercion would be to discover the coercion map and forget about it as soon as it has been applied, one would expect the cache to be empty all the time!\n\nI don't immediately see a canonical way to solve this problem. Here are some ideas that may mitigate it:\n\nWe're caching coercions on the codomain, which I think is the right place for the following reason. Long-lived parents such as `ZZ` tend to have a lot of coercions *to* other parents, but very few *from*. As observed above, we are caching the absense of coercions, but those don't involve an `H` that might keep the codomain alive. So, we could cache the absense of coercions in a `TripleDict`. In fact, we could make that a `TripleSet` if we really want.\n\nThe PRESENCE of a coercion should probably be cached with a strong reference to the coercion. That's the point of caching the thing!\nThis should be keyed on `(X,C)` (the `Y` is implied by the cache we're looking in). Storing the key weakly has no effect with the present design of coercion.\n\nThat means that discovering those impose a memory cost on Y. However, usually there tend to not be too many of those (is that true in the p-adics with all those different precisions floating around? Still, that should be managable relative to creating all finite fields up to size 10<sup>9</sup> and storing strong references on `ZZ` to them to record the absence of a coercion from them, which I think was the problem in the example that started this ticket)\n\nFor permanent objects with coercions *from* lots of objects (like the symbolic ring, real/complex fields, [number fields with declared embeddings], `QQbar` [number fields again]) we have a big problem.\n\nOne solution would be to turn off caching for those (which needs infrastructure ... I guess a flag `Y.no_coercion_caching_on_me_please=True`, which needs checking any time you're about to cache something. Or, if that is too drastic, an optional parent method\n`Y.is_this_a_coercion_cachable_domain(X)` or`Y.is_this_a_coercion_cachable_domain_type(type(X))`\n\nAnother would be to warn people that mixing parents makes the \"larger\" parent remember the \"smaller\" one, so if you let lots of \"smaller\" parent interact with a \"larger\" one, you'll be using memory for the lifetime of that \"larger\" one.\n\nThe \"proper\" solutions below would force coercion maps to be different from normal homomorphisms, fit for users. That's because if a user keeps a reference `h` to an element of `Hom(X,Y)`, he/she rightfully expects that to keep `X` and `Y` alive. \n\nwe'd have to weakly key the cache, but still strongly store the coercion map.\n\nThe \"proper\" (but possibly too expensive) option is to not store `X` on coercion maps. If we have `H=Y.coercion_map_from(X)` and `H` is used correctly, then `H(x)` can get access to X via `x.parent()` anyway, so `H` doesn't strictly need a reference to `X`.\n\nSo the object we store in the cache could be a map-like object `cH` that doesn't store its domain. Upon calling `Y.coercion_map_from(X)` we could wrap `cH` into a proper `Hom(X,Y)` member that does have a strong reference to X. This might be too expensive for something so fundamental as coercion.\n\n**TL;DR**: Do not store a `KeyedRef` to `H` but store `H` itself in the cache. We won't solve the leak completely, but at least we're not leaking on the *absence* of coercions as we were before.",
    "created_at": "2012-08-20T20:27:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125390",
    "user": "https://github.com/nbruin"
}
```

Aw, this weakref caching stuff is very headache-inducing. My sincere apologies. I'm afraid I have to withdraw my positive review due to a previous failure in my logic. As I see it now, the current patch reduces the caching of coercion maps to near uselessness. The fact that it DOES seem to work to some extent might give a lead to why other things are going wrong. Let me try:

Ignoring the weakref on H for now, the coercion cache here consists of a TripleDict, stored on Y, indexing

```
(X,Y,C) : H
```

or

```
(X,Y,C): None
```

Here `H` is a map from `X` to `Y` wrt to the category `C`, so it stores strong references to `X`,`Y`,`C`. That means that as long as `H` is alive, no component of the key will die, so the fact that this is stored in a `TripleDict` is irrelevant: The value `H` would keep the key alive anyway. The only exception is the value `None`. There the `TripleDict` does exactly what it should.

This cycle problem is fixed by weakreffing `H`. But the whole point of the cache is to keep `H` alive as long as all of `X`, `Y` and `C` exist, so that we can look it up. Since the normal use for coercion would be to discover the coercion map and forget about it as soon as it has been applied, one would expect the cache to be empty all the time!

I don't immediately see a canonical way to solve this problem. Here are some ideas that may mitigate it:

We're caching coercions on the codomain, which I think is the right place for the following reason. Long-lived parents such as `ZZ` tend to have a lot of coercions *to* other parents, but very few *from*. As observed above, we are caching the absense of coercions, but those don't involve an `H` that might keep the codomain alive. So, we could cache the absense of coercions in a `TripleDict`. In fact, we could make that a `TripleSet` if we really want.

The PRESENCE of a coercion should probably be cached with a strong reference to the coercion. That's the point of caching the thing!
This should be keyed on `(X,C)` (the `Y` is implied by the cache we're looking in). Storing the key weakly has no effect with the present design of coercion.

That means that discovering those impose a memory cost on Y. However, usually there tend to not be too many of those (is that true in the p-adics with all those different precisions floating around? Still, that should be managable relative to creating all finite fields up to size 10<sup>9</sup> and storing strong references on `ZZ` to them to record the absence of a coercion from them, which I think was the problem in the example that started this ticket)

For permanent objects with coercions *from* lots of objects (like the symbolic ring, real/complex fields, [number fields with declared embeddings], `QQbar` [number fields again]) we have a big problem.

One solution would be to turn off caching for those (which needs infrastructure ... I guess a flag `Y.no_coercion_caching_on_me_please=True`, which needs checking any time you're about to cache something. Or, if that is too drastic, an optional parent method
`Y.is_this_a_coercion_cachable_domain(X)` or`Y.is_this_a_coercion_cachable_domain_type(type(X))`

Another would be to warn people that mixing parents makes the "larger" parent remember the "smaller" one, so if you let lots of "smaller" parent interact with a "larger" one, you'll be using memory for the lifetime of that "larger" one.

The "proper" solutions below would force coercion maps to be different from normal homomorphisms, fit for users. That's because if a user keeps a reference `h` to an element of `Hom(X,Y)`, he/she rightfully expects that to keep `X` and `Y` alive. 

we'd have to weakly key the cache, but still strongly store the coercion map.

The "proper" (but possibly too expensive) option is to not store `X` on coercion maps. If we have `H=Y.coercion_map_from(X)` and `H` is used correctly, then `H(x)` can get access to X via `x.parent()` anyway, so `H` doesn't strictly need a reference to `X`.

So the object we store in the cache could be a map-like object `cH` that doesn't store its domain. Upon calling `Y.coercion_map_from(X)` we could wrap `cH` into a proper `Hom(X,Y)` member that does have a strong reference to X. This might be too expensive for something so fundamental as coercion.

**TL;DR**: Do not store a `KeyedRef` to `H` but store `H` itself in the cache. We won't solve the leak completely, but at least we're not leaking on the *absence* of coercions as we were before.



---

archive/issue_comments_125391.json:
```json
{
    "body": "I'm not sure I completely follow you.\nDid you consider the fact that maps are also stored in the parent themselves? not only in the coercion model?",
    "created_at": "2012-08-20T20:38:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125391",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

I'm not sure I completely follow you.
Did you consider the fact that maps are also stored in the parent themselves? not only in the coercion model?



---

archive/issue_comments_125392.json:
```json
{
    "body": "In particular, please have a look at #12313.",
    "created_at": "2012-08-20T20:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125392",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

In particular, please have a look at #12313.



---

archive/issue_comments_125393.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2012-08-20T21:33:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125393",
    "user": "https://github.com/nbruin"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_125394.json:
```json
{
    "body": "OK, I retract my concern for *this patch*. No coercions are stored here! In particular, any `H` occurring here is a homset, not a map. This cache is simply ensuring that `Hom(X,Y)` is unique. So indeed, this cache should not be preventing `H` from being collected. The `KeyedRef` is entirely in place.\n\nI `was` looking at #12313 when this struck me and I think the discussion above has relevance to that case. Once a coercion `h: X -> Y` is discovered, a strong reference to `h` is stored in `self._coerce_from_hash`. Since `h` stores a strong reference to `X` we now have ensured that the life time of `X` is bounded below by the life time of `Y`. So the weak caching there only helps for `X` that do not coerce into `Y`.\n\nHow eagerly does the system use the `self._convert_from_hash`? It is quite likely that even with #12313 in place,\n\n```python\nfor p in prime_range(1,1000):\n    k=GF(p)\n    a=k(1)\n    b=ZZ(a)\n```\n\nwould still leak, due to the conversion `GF(p)->ZZ` being cached on `ZZ`.\nThat would make me believe we should probably not cache conversions. There are too many of them, so it's too easy to let sage discover enough of them that all objects in memory are in one connected component.\n\nFor coercion things are a little brighter because objects with lots of inbound arrows (near-universal codomains?) are rarer.",
    "created_at": "2012-08-20T21:33:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125394",
    "user": "https://github.com/nbruin"
}
```

OK, I retract my concern for *this patch*. No coercions are stored here! In particular, any `H` occurring here is a homset, not a map. This cache is simply ensuring that `Hom(X,Y)` is unique. So indeed, this cache should not be preventing `H` from being collected. The `KeyedRef` is entirely in place.

I `was` looking at #12313 when this struck me and I think the discussion above has relevance to that case. Once a coercion `h: X -> Y` is discovered, a strong reference to `h` is stored in `self._coerce_from_hash`. Since `h` stores a strong reference to `X` we now have ensured that the life time of `X` is bounded below by the life time of `Y`. So the weak caching there only helps for `X` that do not coerce into `Y`.

How eagerly does the system use the `self._convert_from_hash`? It is quite likely that even with #12313 in place,

```python
for p in prime_range(1,1000):
    k=GF(p)
    a=k(1)
    b=ZZ(a)
```

would still leak, due to the conversion `GF(p)->ZZ` being cached on `ZZ`.
That would make me believe we should probably not cache conversions. There are too many of them, so it's too easy to let sage discover enough of them that all objects in memory are in one connected component.

For coercion things are a little brighter because objects with lots of inbound arrows (near-universal codomains?) are rarer.



---

archive/issue_comments_125395.json:
```json
{
    "body": "You definitely already had a look at #12313, sorry about that.\n\nTrying to summarize the action of the different coercion patches, here is what I remember:\n* in #715, see http://trac.sagemath.org/sage_trac/ticket/715#comment:75 and http://trac.sagemath.org/sage_trac/ticket/715#comment:86\n  * we now store weakref to the set acted upon in Actions.\n  * parents use a TripleDict for _action_hash where the Actions they implement are stored with a strong ref.\n  * there is another TripleDict _action_maps in the coercion model with a strong ref as well.\n  * so if a parent acted upon dies, it will only be weakrefed in the Action itself and in the TripleDicts so that it will get garbage collected with the Action as well, but as long as both of them are alive, there should be no garbage collection.\n\n* but then #11521 comes in because we also have a global cache for homset which prevented parents to die. So only there the tripl dicts store weakrefs to Action to enable gc back again. (just saw you just posted...)",
    "created_at": "2012-08-20T21:34:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125395",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

You definitely already had a look at #12313, sorry about that.

Trying to summarize the action of the different coercion patches, here is what I remember:
* in #715, see http://trac.sagemath.org/sage_trac/ticket/715#comment:75 and http://trac.sagemath.org/sage_trac/ticket/715#comment:86
  * we now store weakref to the set acted upon in Actions.
  * parents use a TripleDict for _action_hash where the Actions they implement are stored with a strong ref.
  * there is another TripleDict _action_maps in the coercion model with a strong ref as well.
  * so if a parent acted upon dies, it will only be weakrefed in the Action itself and in the TripleDicts so that it will get garbage collected with the Action as well, but as long as both of them are alive, there should be no garbage collection.

* but then #11521 comes in because we also have a global cache for homset which prevented parents to die. So only there the tripl dicts store weakrefs to Action to enable gc back again. (just saw you just posted...)



---

archive/issue_comments_125396.json:
```json
{
    "body": "Replying to [comment:155 nbruin]:\nrelevance to that case. Once a coercion `h: X -> Y` is discovered, a strong reference to `h` is stored in `self._coerce_from_hash`. Since `h` stores a strong reference to `X` we now have ensured that the life time of `X` is bounded below by the life time of `Y`. So the weak caching there only helps for `X` that do not coerce into `Y`.\n> \n> How eagerly does the system use the `self._convert_from_hash`? It is quite likely that even with #12313 in place,\n> {{{#!python\n> for p in prime_range(1,1000):\n>     k=GF(p)\n>     a=k(1)\n>     b=ZZ(a)\n> }}}\nI see the problem.\nAnother solution may be to use TripleDicts there as well rather than MonoDicts.\nOr DuoDicts!",
    "created_at": "2012-08-20T21:43:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125396",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Replying to [comment:155 nbruin]:
relevance to that case. Once a coercion `h: X -> Y` is discovered, a strong reference to `h` is stored in `self._coerce_from_hash`. Since `h` stores a strong reference to `X` we now have ensured that the life time of `X` is bounded below by the life time of `Y`. So the weak caching there only helps for `X` that do not coerce into `Y`.
> 
> How eagerly does the system use the `self._convert_from_hash`? It is quite likely that even with #12313 in place,
> {{{#!python
> for p in prime_range(1,1000):
>     k=GF(p)
>     a=k(1)
>     b=ZZ(a)
> }}}
I see the problem.
Another solution may be to use TripleDicts there as well rather than MonoDicts.
Or DuoDicts!



---

archive/issue_comments_125397.json:
```json
{
    "body": "Disregard my above comment.\nThe point of #12313 is exactly to let k be garbage collected, as the elliptic curves in #12313 description.",
    "created_at": "2012-08-20T21:49:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125397",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Disregard my above comment.
The point of #12313 is exactly to let k be garbage collected, as the elliptic curves in #12313 description.



---

archive/issue_comments_125398.json:
```json
{
    "body": "I this post, I clarify some notions and explain why the weak reference to a homset introduced here does *not* imply that the homset will immediately be garbage collected. Sorry, while I wrote that post, you clarified things for yourself, making my post redundant. Anyway, here it goes...\n\nReplying to [comment:152 nbruin]:\n> Here `H` is a map from `X` to `Y` wrt to the category `C`,\n> so it stores strong references to `X`,`Y`,`C`. \n\nNo, it is a homset. But yes, it has strong references to X,Y,C.\n\n> The PRESENCE of a coercion should probably be cached with a strong reference to the coercion. That's the point of caching the thing!\n\nYes. But that should happen in a way that domain and codomain remain collectable. And that is a problem; see below.\n\nBut I think there is a lot of confusion now between coercion, homset, `TripleDict` post and prior to #715, and the way how coercion maps are cached. Let me try to straighten things a bit:\n\nThe original purpose of `TripleDict` was to store ACTIONS (not coercions). When you have an action of X on Y, then you would store the action in an attribute of X, addressed by the key triple that is formed by Y, the information what operation is considered (+ or *), and the information whether the action is on the left or on the right.\n\nThe original `TripleDict` did so by strong references to both keys and values. By #715, `TripleDict` got changed so that one has weak references to the keys.\n\nBefore #11521, that was the *only* application of `TripleDict`. But here, I suggest a second application, namely: Use it to store homsets. A \"homset\" from X to Y in the category C is the parent that contains all morphisms from X to Y in the category C (regardless whether these morphisms are coercion maps or conversion maps or anything else).\n\nLet me emphasize again that #715, #12215 and #11521 do not change the way coercions are stored.\n\nHow are coercions stored? Before #12313, the coercions from X to Y were stored in a strong dictionary in Y, strongly keyed with X. Hence, as long as Y survives, there would be a strong reference to X. But with #12313, a weak dictionary is introduced for that purpose. Hence, even if Y persists and a coercion has been cached from X to Y, X remains collectable.\n\nNow, back to caching `H = Hom(X,Y,category=C)` (H is a set of maps). You are right, having just a weak reference to H sounds like it would be immediately collected. If I recall correctly, my reasoning for introducing the weak reference to H has been as follows:\n\n* Let T be the cache for the Hom function. T is a `TripleDict`. and T is in fact available under sage.categories.homset._cache. Hence, we have a strong permanent reference to T.\n* T provides some buckets, and of course T has strong references to its buckets.\n* With #715, the buckets contain some memory addresses representing the keys, and then strong references to the values.\n\nBy consequence, defining T[X,Y,C]=H means that we have a chain of strong references, starting with T (T is permanent), from T to its buckets, from the buckets to H, and from H to X, Y and C. Hence, X,Y and C will never be garbage collected, even though T itself only has weak references to X,Y and C.\n\nNow, only define T[X,Y,C]=weakref.ref(H) (or any other kind of weak reference to H). Why is H *not* immediately garbage collected, in usual applications?\n\nUsual application means: You will not just create H, but you will also create an element of H, say, phi. We have a strong reference from phi to H, because H is the parent of phi. If you do not store phi, then H remains collectable. But in a usual application, you would store phi, say, because it is a coerce map from X to Y.\n\nBy now, we assume that phi is a coercion, which is cached in Y. To be precise, we have Y._coerce_from_hash[X] = phi.\n\nPrior to #12313, Y._coerce_from_hash is a usual dict. Hence, the existence of Y keeps X, phi and thus H alive.\n\nWith #12313, Y._coerce_from_hash is a `MonoDict`, which only has a weak reference to X. However, Y._coerce_from_hash has a strong reference to its buckets, the buckets have a strong reference to phi, phi has a strong reference to its parent H, and H has a strong reference to X. Hence, we have the reference cycle (with -> weak and => strong references)\n\n```\n* => T -> H\n\n   Y -> X\n   Y => phi => H => X\n               H => Y\n               H => C\n```\n\n\nIn conclusion, an external reference to Y will keep X alive (which is bad). But if there is no external reference to Y nor to X, then Y,X,H and C remain collectable (assuming that no `__del__` method makes the cyclic garbage collection impossible), which is good enough to fix a memleak.\n\n**__Summary__**\n\n* If H=Hom(X,Y,C) and the homset cache keeps a strong reference to H, then H, X, Y and C will never be collectable. That's why I introduce the weak reference, strange as it may look.\n* If H=Hom(X,Y,C) is created as the parent of a coercion or conversion map phi, which is stored in Y._coerce_from_cache, then:\n   - An external strong reference to Y keeps phi, thus H, thus X and C alive (*).\n   - An external strong reference to X does *not* prevent Y, H or C from being collected.\n\nIn an ideal world, (*) would be improved: An external strong reference to Y would *not* be enough to keep X alive. Do you have any idea how this can be implemented?",
    "created_at": "2012-08-20T22:56:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125398",
    "user": "https://github.com/simon-king-jena"
}
```

I this post, I clarify some notions and explain why the weak reference to a homset introduced here does *not* imply that the homset will immediately be garbage collected. Sorry, while I wrote that post, you clarified things for yourself, making my post redundant. Anyway, here it goes...

Replying to [comment:152 nbruin]:
> Here `H` is a map from `X` to `Y` wrt to the category `C`,
> so it stores strong references to `X`,`Y`,`C`. 

No, it is a homset. But yes, it has strong references to X,Y,C.

> The PRESENCE of a coercion should probably be cached with a strong reference to the coercion. That's the point of caching the thing!

Yes. But that should happen in a way that domain and codomain remain collectable. And that is a problem; see below.

But I think there is a lot of confusion now between coercion, homset, `TripleDict` post and prior to #715, and the way how coercion maps are cached. Let me try to straighten things a bit:

The original purpose of `TripleDict` was to store ACTIONS (not coercions). When you have an action of X on Y, then you would store the action in an attribute of X, addressed by the key triple that is formed by Y, the information what operation is considered (+ or *), and the information whether the action is on the left or on the right.

The original `TripleDict` did so by strong references to both keys and values. By #715, `TripleDict` got changed so that one has weak references to the keys.

Before #11521, that was the *only* application of `TripleDict`. But here, I suggest a second application, namely: Use it to store homsets. A "homset" from X to Y in the category C is the parent that contains all morphisms from X to Y in the category C (regardless whether these morphisms are coercion maps or conversion maps or anything else).

Let me emphasize again that #715, #12215 and #11521 do not change the way coercions are stored.

How are coercions stored? Before #12313, the coercions from X to Y were stored in a strong dictionary in Y, strongly keyed with X. Hence, as long as Y survives, there would be a strong reference to X. But with #12313, a weak dictionary is introduced for that purpose. Hence, even if Y persists and a coercion has been cached from X to Y, X remains collectable.

Now, back to caching `H = Hom(X,Y,category=C)` (H is a set of maps). You are right, having just a weak reference to H sounds like it would be immediately collected. If I recall correctly, my reasoning for introducing the weak reference to H has been as follows:

* Let T be the cache for the Hom function. T is a `TripleDict`. and T is in fact available under sage.categories.homset._cache. Hence, we have a strong permanent reference to T.
* T provides some buckets, and of course T has strong references to its buckets.
* With #715, the buckets contain some memory addresses representing the keys, and then strong references to the values.

By consequence, defining T[X,Y,C]=H means that we have a chain of strong references, starting with T (T is permanent), from T to its buckets, from the buckets to H, and from H to X, Y and C. Hence, X,Y and C will never be garbage collected, even though T itself only has weak references to X,Y and C.

Now, only define T[X,Y,C]=weakref.ref(H) (or any other kind of weak reference to H). Why is H *not* immediately garbage collected, in usual applications?

Usual application means: You will not just create H, but you will also create an element of H, say, phi. We have a strong reference from phi to H, because H is the parent of phi. If you do not store phi, then H remains collectable. But in a usual application, you would store phi, say, because it is a coerce map from X to Y.

By now, we assume that phi is a coercion, which is cached in Y. To be precise, we have Y._coerce_from_hash[X] = phi.

Prior to #12313, Y._coerce_from_hash is a usual dict. Hence, the existence of Y keeps X, phi and thus H alive.

With #12313, Y._coerce_from_hash is a `MonoDict`, which only has a weak reference to X. However, Y._coerce_from_hash has a strong reference to its buckets, the buckets have a strong reference to phi, phi has a strong reference to its parent H, and H has a strong reference to X. Hence, we have the reference cycle (with -> weak and => strong references)

```
* => T -> H

   Y -> X
   Y => phi => H => X
               H => Y
               H => C
```


In conclusion, an external reference to Y will keep X alive (which is bad). But if there is no external reference to Y nor to X, then Y,X,H and C remain collectable (assuming that no `__del__` method makes the cyclic garbage collection impossible), which is good enough to fix a memleak.

**__Summary__**

* If H=Hom(X,Y,C) and the homset cache keeps a strong reference to H, then H, X, Y and C will never be collectable. That's why I introduce the weak reference, strange as it may look.
* If H=Hom(X,Y,C) is created as the parent of a coercion or conversion map phi, which is stored in Y._coerce_from_cache, then:
   - An external strong reference to Y keeps phi, thus H, thus X and C alive (*).
   - An external strong reference to X does *not* prevent Y, H or C from being collected.

In an ideal world, (*) would be improved: An external strong reference to Y would *not* be enough to keep X alive. Do you have any idea how this can be implemented?



---

archive/issue_comments_125399.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2012-08-21T08:18:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125399",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_125400.json:
```json
{
    "body": "See my comment at [13370](http://trac.sagemath.org/sage_trac/ticket/13370#comment:17): To be on the safe side, i.e., in order to avoid that a key is deallocated but its callback function isn't called, one could/should first look at the memory address, and then (if the addresses coincide) test whether the stored weak reference is still active. Namely, if it isn't then the new key is *really* new, even though using an old address.\n\nHence, I'd like to put this and #715 to \"needs work\".",
    "created_at": "2012-08-21T08:18:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125400",
    "user": "https://github.com/simon-king-jena"
}
```

See my comment at [13370](http://trac.sagemath.org/sage_trac/ticket/13370#comment:17): To be on the safe side, i.e., in order to avoid that a key is deallocated but its callback function isn't called, one could/should first look at the memory address, and then (if the addresses coincide) test whether the stored weak reference is still active. Namely, if it isn't then the new key is *really* new, even though using an old address.

Hence, I'd like to put this and #715 to "needs work".



---

archive/issue_comments_125401.json:
```json
{
    "body": "Ooops, the \"needs work\" should have been #715 and #12313...",
    "created_at": "2012-08-21T08:35:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125401",
    "user": "https://github.com/simon-king-jena"
}
```

Ooops, the "needs work" should have been #715 and #12313...



---

archive/issue_comments_125402.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-08-21T08:35:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125402",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_125403.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-08-24T23:10:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125403",
    "user": "https://github.com/nbruin"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_125404.json:
```json
{
    "body": "SInce these tickets have caused some trouble in the past, I prefer to merge them only in a .beta0 (to maximize the testing), hence the milestone bump.",
    "created_at": "2012-09-23T16:15:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125404",
    "user": "https://github.com/jdemeyer"
}
```

SInce these tickets have caused some trouble in the past, I prefer to merge them only in a .beta0 (to maximize the testing), hence the milestone bump.



---

archive/issue_comments_125405.json:
```json
{
    "body": "Is it still true that this needs to be merged with #13447?  If yes, then #715 still depends on #13447.",
    "created_at": "2012-09-23T16:33:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125405",
    "user": "https://github.com/jdemeyer"
}
```

Is it still true that this needs to be merged with #13447?  If yes, then #715 still depends on #13447.



---

archive/issue_comments_125406.json:
```json
{
    "body": "No, we do not need that merge. We should absolutely not add any more dependencies to these tickets. They are good to go as is (modulo nasty surprises). We can improve things afterwards. The bump to 5.5 is already unfortunate, because that means we've already unnecessarily missed one sailing.\n\n**EDIT:** With *unfortunate* I do not mean to imply unwise. I fully respect the judgement of the release manager on this issue.",
    "created_at": "2012-09-23T20:32:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125406",
    "user": "https://github.com/nbruin"
}
```

No, we do not need that merge. We should absolutely not add any more dependencies to these tickets. They are good to go as is (modulo nasty surprises). We can improve things afterwards. The bump to 5.5 is already unfortunate, because that means we've already unnecessarily missed one sailing.

**EDIT:** With *unfortunate* I do not mean to imply unwise. I fully respect the judgement of the release manager on this issue.



---

archive/issue_comments_125407.json:
```json
{
    "body": "Replying to [comment:168 nbruin]:\n> The bump to 5.5 is already unfortunate.\nI understand your feelings, but given that these kind of tickets have caused wierd not-always-reproducible bugs in the past, I think we should go for maximum testing coverage.  That means, merging in some .beta0 instead of now in sage-5.4.beta2.",
    "created_at": "2012-09-24T08:15:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125407",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:168 nbruin]:
> The bump to 5.5 is already unfortunate.
I understand your feelings, but given that these kind of tickets have caused wierd not-always-reproducible bugs in the past, I think we should go for maximum testing coverage.  That means, merging in some .beta0 instead of now in sage-5.4.beta2.



---

archive/issue_comments_125408.json:
```json
{
    "body": "I am not sure: Is #13447 needed? Or does the strong cache for polynomial rings is agreed upon?",
    "created_at": "2012-10-01T12:58:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125408",
    "user": "https://github.com/simon-king-jena"
}
```

I am not sure: Is #13447 needed? Or does the strong cache for polynomial rings is agreed upon?



---

archive/issue_comments_125409.json:
```json
{
    "body": "Personally, I'd say merge this with the strong cache, (merge #12313 if possible in between) and (finally) include #13447 when it's ready.",
    "created_at": "2012-10-01T13:01:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125409",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Personally, I'd say merge this with the strong cache, (merge #12313 if possible in between) and (finally) include #13447 when it's ready.



---

archive/issue_comments_125410.json:
```json
{
    "body": "Yes, Jean-Pierre, I agree that *if* it is possible that start with a strong polynomial cache, and postpone the proper fix at #13447, because for now it isn't ready.\n\nBut perhaps the reviewers can cross-verify that #715 (including a *strong* cache for polynomial rings) plus #11521 is indeed fine without #13447? Do the tests all pass?",
    "created_at": "2012-10-01T13:06:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125410",
    "user": "https://github.com/simon-king-jena"
}
```

Yes, Jean-Pierre, I agree that *if* it is possible that start with a strong polynomial cache, and postpone the proper fix at #13447, because for now it isn't ready.

But perhaps the reviewers can cross-verify that #715 (including a *strong* cache for polynomial rings) plus #11521 is indeed fine without #13447? Do the tests all pass?



---

archive/issue_comments_125411.json:
```json
{
    "body": "Replying to [comment:172 SimonKing]:\n> But perhaps the reviewers can cross-verify that #715 (including a *strong* cache for polynomial rings) plus #11521 is indeed fine without #13447? Do the tests all pass?\n\nI have always tested these tickets together. Plus, we *know* why a strong cache prevents the problems observed.",
    "created_at": "2012-10-01T15:05:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125411",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:172 SimonKing]:
> But perhaps the reviewers can cross-verify that #715 (including a *strong* cache for polynomial rings) plus #11521 is indeed fine without #13447? Do the tests all pass?

I have always tested these tickets together. Plus, we *know* why a strong cache prevents the problems observed.



---

archive/issue_comments_125412.json:
```json
{
    "body": "Replying to [comment:173 nbruin]:\n> Replying to [comment:172 SimonKing]:\n> > But perhaps the reviewers can cross-verify that #715 (including a *strong* cache for polynomial rings) plus #11521 is indeed fine without #13447? Do the tests all pass?\n> \n> I have always tested these tickets together. \nThis is not completely clear, do you mean:\n* #715 without the strong cache + #11521 (which is highly unprobable because of the bsd segfault, but let's mention this solution)?\n* #715 with strong cache + #11521?\n* #715 + #11521 + #13447 (assuming the strong cache is removed either from #715 directly or by means of a second reverse patch in #13447)?\n> Plus, we *know* why a strong cache prevents the problems observed.\nI guess you mean the bsd bug.\nNot the memory leaks problems these tickets try to tackle, is that right?",
    "created_at": "2012-10-01T15:12:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125412",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Replying to [comment:173 nbruin]:
> Replying to [comment:172 SimonKing]:
> > But perhaps the reviewers can cross-verify that #715 (including a *strong* cache for polynomial rings) plus #11521 is indeed fine without #13447? Do the tests all pass?
> 
> I have always tested these tickets together. 
This is not completely clear, do you mean:
* #715 without the strong cache + #11521 (which is highly unprobable because of the bsd segfault, but let's mention this solution)?
* #715 with strong cache + #11521?
* #715 + #11521 + #13447 (assuming the strong cache is removed either from #715 directly or by means of a second reverse patch in #13447)?
> Plus, we *know* why a strong cache prevents the problems observed.
I guess you mean the bsd bug.
Not the memory leaks problems these tickets try to tackle, is that right?



---

archive/issue_comments_125413.json:
```json
{
    "body": "Replying to [comment:174 jpflori]:\n> > I have always tested these tickets together. \n> This is not completely clear, do you mean:\n> * #715 without the strong cache + #11521 (which is highly unprobable because of the bsd segfault, but let's mention this solution)?\n\nThis isn't a solution, because of the segfault.\n\n> * #715 with strong cache + #11521?\n\nYes. Do the tests pass in that setting?\n\n> * #715 + #11521 + #13447 (assuming the strong cache is removed either from #715 directly or by means of a second reverse patch in #13447)?\n\nThat would be the long term aim, from my perspective. But getting the refcount right turned out to be trickier than I originally thought. Hence, for now (again: *IF* the tests pass) I'd prefer #715+#11521 with the ugly strong cache for polynomial rings.\n\n> > Plus, we *know* why a strong cache prevents the problems observed.\n> I guess you mean the bsd bug.\n> Not the memory leaks problems these tickets try to tackle, is that right?\n\nYes and no. A strong cache for polynomial rings would mean that my current Sage applications would eat too much memory - hence, yes, a strong cache is opposite to the spirit of these tickets. However, for all other parents, the tickets would still fix some memory leaks.",
    "created_at": "2012-10-01T15:27:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125413",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:174 jpflori]:
> > I have always tested these tickets together. 
> This is not completely clear, do you mean:
> * #715 without the strong cache + #11521 (which is highly unprobable because of the bsd segfault, but let's mention this solution)?

This isn't a solution, because of the segfault.

> * #715 with strong cache + #11521?

Yes. Do the tests pass in that setting?

> * #715 + #11521 + #13447 (assuming the strong cache is removed either from #715 directly or by means of a second reverse patch in #13447)?

That would be the long term aim, from my perspective. But getting the refcount right turned out to be trickier than I originally thought. Hence, for now (again: *IF* the tests pass) I'd prefer #715+#11521 with the ugly strong cache for polynomial rings.

> > Plus, we *know* why a strong cache prevents the problems observed.
> I guess you mean the bsd bug.
> Not the memory leaks problems these tickets try to tackle, is that right?

Yes and no. A strong cache for polynomial rings would mean that my current Sage applications would eat too much memory - hence, yes, a strong cache is opposite to the spirit of these tickets. However, for all other parents, the tickets would still fix some memory leaks.



---

archive/issue_comments_125414.json:
```json
{
    "body": "Thanks, Simon.\nI just hope (and expect) Nils to give a similar clarification.\n\nI'm aware that the strong cache does induce (or prevents solving) leaks,\nso obviously #13447 is the next issue to tackle, especially for your own work as it seems.\n\nAs far as tests are concerned, all tests used to pass on my machines without the strong cache for polynomial.\nIf Nils reconfirms that (i assumee that's what he meant earlier), maybe correcting the ticket desciption by removind the reference to #13447 and helping the patchbots to apply the patches correctly and letting them do their job should be enough now?",
    "created_at": "2012-10-01T15:33:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125414",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Thanks, Simon.
I just hope (and expect) Nils to give a similar clarification.

I'm aware that the strong cache does induce (or prevents solving) leaks,
so obviously #13447 is the next issue to tackle, especially for your own work as it seems.

As far as tests are concerned, all tests used to pass on my machines without the strong cache for polynomial.
If Nils reconfirms that (i assumee that's what he meant earlier), maybe correcting the ticket desciption by removind the reference to #13447 and helping the patchbots to apply the patches correctly and letting them do their job should be enough now?



---

archive/issue_comments_125415.json:
```json
{
    "body": "Replying to [comment:176 jpflori]:\n> As far as tests are concerned, all tests used to pass on my machines without the strong cache for polynomial.\n\nYes, for me as well (except on bsd.math, of course). The question is: Is there a test (perhaps introduced at #12313) that relies on a *weak* polynomial ring cache?\n\n> If Nils reconfirms that (i assumee that's what he meant earlier), maybe correcting the ticket desciption by removind the reference to #13447 and helping the patchbots to apply the patches correctly and letting them do their job should be enough now?\n\nSounds like a plan...",
    "created_at": "2012-10-01T16:38:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125415",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:176 jpflori]:
> As far as tests are concerned, all tests used to pass on my machines without the strong cache for polynomial.

Yes, for me as well (except on bsd.math, of course). The question is: Is there a test (perhaps introduced at #12313) that relies on a *weak* polynomial ring cache?

> If Nils reconfirms that (i assumee that's what he meant earlier), maybe correcting the ticket desciption by removind the reference to #13447 and helping the patchbots to apply the patches correctly and letting them do their job should be enough now?

Sounds like a plan...



---

archive/issue_comments_125416.json:
```json
{
    "body": "Replying to [comment:175 SimonKing]:\n> > * #715 with strong cache + #11521?\n> \n> Yes. Do the tests pass in that setting?\nAs far as I know, they do.\n\nTo be clear, the strong cache there is supposed to make things *not worse* for Singular rings. It's simply reinstating strong references that #715+#11521 removes (that's the idea at least), until we figure out how to properly collaborate with singular's (lack of) ref counting.\n\nAs it stands, this should make things *better* for many other parents. At this point the most important bit is to get to a point where parent deallocation code actually does get excercised.",
    "created_at": "2012-10-01T17:35:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125416",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:175 SimonKing]:
> > * #715 with strong cache + #11521?
> 
> Yes. Do the tests pass in that setting?
As far as I know, they do.

To be clear, the strong cache there is supposed to make things *not worse* for Singular rings. It's simply reinstating strong references that #715+#11521 removes (that's the idea at least), until we figure out how to properly collaborate with singular's (lack of) ref counting.

As it stands, this should make things *better* for many other parents. At this point the most important bit is to get to a point where parent deallocation code actually does get excercised.



---

archive/issue_comments_125417.json:
```json
{
    "body": "Sorry to spoil the party, but with sage-5.4.rc0 + #715 + #11521, I get\n\n```\nsage -t  \"devel/sage/sage/libs/singular/ring.pyx\"\n**********************************************************************\nFile \"/release/merger/sage-5.5.beta0/devel/sage/sage/libs/singular/ring.pyx\", line 490:\n    sage: ring_ptr in ring_refcount_dict\nExpected:\n    False\nGot:\n    True\n**********************************************************************\n1 items had failures:\n   1 of  22 in __main__.example_8\n***Test Failed*** 1 failures.\nFor whitespace errors, see the file /home/jdemeyer/.sage//tmp/ring_18750.py\n         [3.4 s]\nsage -t  \"devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx\"\nException AttributeError: AttributeError('PolynomialRing_field_with_category' object has no attribute '_modulus',) in  ignored\nException AttributeError: AttributeError('PolynomialRing_field_with_category' object has no attribute '_modulus',) in  ignored\n**********************************************************************\nFile \"/release/merger/sage-5.5.beta0/devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx\", line 423:\n    sage: len(ring_refcount_dict) == n\nExpected:\n    True\nGot:\n    False\n**********************************************************************\n1 items had failures:\n   1 of  19 in __main__.example_4\n***Test Failed*** 1 failures.\nFor whitespace errors, see the file /home/jdemeyer/.sage//tmp/multi_polynomial_libsingular_19160.py\n         [5.8 s]\n```\n\nSo perhaps this does require #13447?",
    "created_at": "2012-10-05T13:48:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125417",
    "user": "https://github.com/jdemeyer"
}
```

Sorry to spoil the party, but with sage-5.4.rc0 + #715 + #11521, I get

```
sage -t  "devel/sage/sage/libs/singular/ring.pyx"
**********************************************************************
File "/release/merger/sage-5.5.beta0/devel/sage/sage/libs/singular/ring.pyx", line 490:
    sage: ring_ptr in ring_refcount_dict
Expected:
    False
Got:
    True
**********************************************************************
1 items had failures:
   1 of  22 in __main__.example_8
***Test Failed*** 1 failures.
For whitespace errors, see the file /home/jdemeyer/.sage//tmp/ring_18750.py
         [3.4 s]
sage -t  "devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx"
Exception AttributeError: AttributeError('PolynomialRing_field_with_category' object has no attribute '_modulus',) in  ignored
Exception AttributeError: AttributeError('PolynomialRing_field_with_category' object has no attribute '_modulus',) in  ignored
**********************************************************************
File "/release/merger/sage-5.5.beta0/devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx", line 423:
    sage: len(ring_refcount_dict) == n
Expected:
    True
Got:
    False
**********************************************************************
1 items had failures:
   1 of  19 in __main__.example_4
***Test Failed*** 1 failures.
For whitespace errors, see the file /home/jdemeyer/.sage//tmp/multi_polynomial_libsingular_19160.py
         [5.8 s]
```

So perhaps this does require #13447?



---

archive/issue_comments_125418.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2012-10-05T14:02:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125418",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_125419.json:
```json
{
    "body": "Replying to [comment:179 jdemeyer]:\n> Sorry to spoil the party, but with sage-5.4.rc0 + #715 + #11521, I get\n> {{{\n> sage -t  \"devel/sage/sage/libs/singular/ring.pyx\"\n> **********************************************************************\n> File \"/release/merger/sage-5.5.beta0/devel/sage/sage/libs/singular/ring.pyx\", line 490:\n>     sage: ring_ptr in ring_refcount_dict\n> Expected:\n>     False\n> Got:\n>     True\n}}}\n\nI guess this is expected, because of the newly introduced strong cache for polynomial rings at the latest version of #715.\n\n> **********************************************************************\n> File \"/release/merger/sage-5.5.beta0/devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx\", line 423:\n>     sage: len(ring_refcount_dict) == n\n> Expected:\n>     True\n> Got:\n>     False\n\nSame as above: This test was supposed to show that garbage collection for polynomial rings happens, but it doesn't, with a strong cache.\n\n> **********************************************************************\n> sage -t  \"devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx\"\n> Exception AttributeError: AttributeError('PolynomialRing_field_with_category' object has no attribute '_modulus',) in  ignored\n> Exception AttributeError: AttributeError('PolynomialRing_field_with_category' object has no attribute '_modulus',) in  ignored\n\nI guess that is more serious. IIRC, it comes from code in polynomial_template.\n\nAnyway. If that kind of problems persist, then I guess we need #13447.",
    "created_at": "2012-10-05T14:12:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125419",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:179 jdemeyer]:
> Sorry to spoil the party, but with sage-5.4.rc0 + #715 + #11521, I get
> {{{
> sage -t  "devel/sage/sage/libs/singular/ring.pyx"
> **********************************************************************
> File "/release/merger/sage-5.5.beta0/devel/sage/sage/libs/singular/ring.pyx", line 490:
>     sage: ring_ptr in ring_refcount_dict
> Expected:
>     False
> Got:
>     True
}}}

I guess this is expected, because of the newly introduced strong cache for polynomial rings at the latest version of #715.

> **********************************************************************
> File "/release/merger/sage-5.5.beta0/devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx", line 423:
>     sage: len(ring_refcount_dict) == n
> Expected:
>     True
> Got:
>     False

Same as above: This test was supposed to show that garbage collection for polynomial rings happens, but it doesn't, with a strong cache.

> **********************************************************************
> sage -t  "devel/sage/sage/rings/polynomial/multi_polynomial_libsingular.pyx"
> Exception AttributeError: AttributeError('PolynomialRing_field_with_category' object has no attribute '_modulus',) in  ignored
> Exception AttributeError: AttributeError('PolynomialRing_field_with_category' object has no attribute '_modulus',) in  ignored

I guess that is more serious. IIRC, it comes from code in polynomial_template.

Anyway. If that kind of problems persist, then I guess we need #13447.



---

archive/issue_comments_125420.json:
```json
{
    "body": "Attachment [trac_11521_doctestfix.patch](tarball://root/attachments/some-uuid/ticket11521/trac_11521_doctestfix.patch) by @nbruin created at 2012-10-05 22:39:49\n\nsmall fixes",
    "created_at": "2012-10-05T22:39:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125420",
    "user": "https://github.com/nbruin"
}
```

Attachment [trac_11521_doctestfix.patch](tarball://root/attachments/some-uuid/ticket11521/trac_11521_doctestfix.patch) by @nbruin created at 2012-10-05 22:39:49

small fixes



---

archive/issue_comments_125421.json:
```json
{
    "body": "OK, I've adapted two doctests to reflect that polynomial rings still are not garbage collected. Furthermore, I backported two changes from #13447:\n\n- A change to a doctest for modular forms spaces, which depended on previously cached computation. Since these things do get collected now, the caching was lost. The rewrite forces recomputation, so the dependence on things not getting deleted is removed\n\n- The ignored `AttributeError` (which doesn't cause a doctest failure, by the way. The warning is only visible because it happened near a doctest that failed for another reason). Since we found where this ignore was happening anyway [http://trac.sagemath.org/sage_trac/ticket/13447#comment:30](http://trac.sagemath.org/sage_trac/ticket/13447#comment:30) we might as well fix it now. It's a side-effect of things getting collected, but the change itself doesn't depend on the proper refcounting details that #13447 itself is hanging on.\n\nAll doctests pass for me with this, so back to positive review.",
    "created_at": "2012-10-05T22:47:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125421",
    "user": "https://github.com/nbruin"
}
```

OK, I've adapted two doctests to reflect that polynomial rings still are not garbage collected. Furthermore, I backported two changes from #13447:

- A change to a doctest for modular forms spaces, which depended on previously cached computation. Since these things do get collected now, the caching was lost. The rewrite forces recomputation, so the dependence on things not getting deleted is removed

- The ignored `AttributeError` (which doesn't cause a doctest failure, by the way. The warning is only visible because it happened near a doctest that failed for another reason). Since we found where this ignore was happening anyway [http://trac.sagemath.org/sage_trac/ticket/13447#comment:30](http://trac.sagemath.org/sage_trac/ticket/13447#comment:30) we might as well fix it now. It's a side-effect of things getting collected, but the change itself doesn't depend on the proper refcounting details that #13447 itself is hanging on.

All doctests pass for me with this, so back to positive review.



---

archive/issue_comments_125422.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2012-10-05T22:47:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125422",
    "user": "https://github.com/nbruin"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_125423.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2012-10-06T09:23:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125423",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_125424.json:
```json
{
    "body": "Replying to [comment:182 nbruin]:\n> All doctests pass for me with this, so back to positive review.\nI think somebody needs to review that patch.  Simon, can you do that?",
    "created_at": "2012-10-06T09:23:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125424",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:182 nbruin]:
> All doctests pass for me with this, so back to positive review.
I think somebody needs to review that patch.  Simon, can you do that?



---

archive/issue_comments_125425.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-10-06T09:23:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125425",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_125426.json:
```json
{
    "body": "Replying to [comment:183 jdemeyer]:\n> Replying to [comment:182 nbruin]:\n> > All doctests pass for me with this, so back to positive review.\n> I think somebody needs to review that patch.  Simon, can you do that?\n\n[attachment:trac_11521_doctestfix.patch] looks fine to me. I'll try to build the latest Sage prerelease on bsd.math with these changes and do tests.",
    "created_at": "2012-10-06T11:22:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125426",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:183 jdemeyer]:
> Replying to [comment:182 nbruin]:
> > All doctests pass for me with this, so back to positive review.
> I think somebody needs to review that patch.  Simon, can you do that?

[attachment:trac_11521_doctestfix.patch] looks fine to me. I'll try to build the latest Sage prerelease on bsd.math with these changes and do tests.



---

archive/issue_comments_125427.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-10-06T16:16:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125427",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_125428.json:
```json
{
    "body": "It works! All tests pass on bsd.math, and I also did `sage -t devel/sage/sage/rings/polynomial/` separately, to verify that the ignored attribute error does not occur.\n\nThe new patch looks fine. Hence, it is a positive review.",
    "created_at": "2012-10-06T16:16:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125428",
    "user": "https://github.com/simon-king-jena"
}
```

It works! All tests pass on bsd.math, and I also did `sage -t devel/sage/sage/rings/polynomial/` separately, to verify that the ignored attribute error does not occur.

The new patch looks fine. Hence, it is a positive review.



---

archive/issue_comments_125429.json:
```json
{
    "body": "I confirm that doctests pass.",
    "created_at": "2012-10-06T20:44:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125429",
    "user": "https://github.com/jdemeyer"
}
```

I confirm that doctests pass.



---

archive/issue_comments_125430.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2012-10-17T20:58:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125430",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_011434.json:
```json
{
    "actor": "@jdemeyer",
    "created_at": "2012-10-17T20:58:51Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11349#event-11434"
}
```



---

archive/issue_comments_125431.json:
```json
{
    "body": "Sorry to bring bad news, but a trial sage-5.5.beta1 caused a Segmentation Fault in `sage/schemes/elliptic_curves/ell_number_field.py` on OS X 10.4 PPC.  Removing #715 and #11521 made the problem go away.  This really feels like a d\u00e9j\u00e0 vu, but I'm afraid I need to remove the patch from sage-5.5.beta0.",
    "created_at": "2012-11-03T17:36:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125431",
    "user": "https://github.com/jdemeyer"
}
```

Sorry to bring bad news, but a trial sage-5.5.beta1 caused a Segmentation Fault in `sage/schemes/elliptic_curves/ell_number_field.py` on OS X 10.4 PPC.  Removing #715 and #11521 made the problem go away.  This really feels like a déjà vu, but I'm afraid I need to remove the patch from sage-5.5.beta0.



---

archive/issue_comments_125432.json:
```json
{
    "body": "Changing status from closed to new.",
    "created_at": "2012-11-03T17:36:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125432",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from closed to new.



---

archive/issue_events_011435.json:
```json
{
    "actor": "@jdemeyer",
    "created_at": "2012-11-03T17:36:16Z",
    "event": "reopened",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11349#event-11435"
}
```



---

archive/issue_comments_125433.json:
```json
{
    "body": "Resolution changed from fixed to ",
    "created_at": "2012-11-03T17:36:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125433",
    "user": "https://github.com/jdemeyer"
}
```

Resolution changed from fixed to 



---

archive/issue_events_011436.json:
```json
{
    "actor": "@jdemeyer",
    "created_at": "2012-11-04T08:37:35Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11349#event-11436"
}
```



---

archive/issue_comments_125434.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2012-11-04T08:37:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11349",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11349#issuecomment-125434",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed
