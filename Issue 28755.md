# Issue 28755: Introduce a "scale factor" to Laurent series

archive/issues_028755.json:
```json
{
    "body": "CC:  @tscrim @videlec\n\nKeywords: Laurent series\n\nThe implementation of Laurent series in [OSCAR](https://oscar.computeralgebra.de/) (more explicitly in [NEMO](http://nemocas.org/)) uses a \"scale factor\" in order to compensate the inflation of its degree by the ramification index of Puiseux series. The aim of this ticket is to implement something similar for Sage Laurent series in order to reduce memory usage of our upcoming Puiseux series (see comment ticket:4618#comment:42 of #4618).\n\nInspiration can be taken form [fmpz_laurent_series](https://github.com/Nemocas/Nemo.jl/blob/master/src/flint/fmpz_laurent_series.jl)\n\n\nThis ticket should introduce the \"scale factor\" in the method `verschiebung` of #4618. As soon this is done the new code will run against the doctests of #4618.\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/28992\n\n",
    "created_at": "2020-01-12T08:16:32Z",
    "labels": [
        "commutative algebra",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Introduce a \"scale factor\" to Laurent series",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/28755",
    "user": "@soehms"
}
```
CC:  @tscrim @videlec

Keywords: Laurent series

The implementation of Laurent series in [OSCAR](https://oscar.computeralgebra.de/) (more explicitly in [NEMO](http://nemocas.org/)) uses a "scale factor" in order to compensate the inflation of its degree by the ramification index of Puiseux series. The aim of this ticket is to implement something similar for Sage Laurent series in order to reduce memory usage of our upcoming Puiseux series (see comment ticket:4618#comment:42 of #4618).

Inspiration can be taken form [fmpz_laurent_series](https://github.com/Nemocas/Nemo.jl/blob/master/src/flint/fmpz_laurent_series.jl)


This ticket should introduce the "scale factor" in the method `verschiebung` of #4618. As soon this is done the new code will run against the doctests of #4618.



Issue created by migration from https://trac.sagemath.org/ticket/28992





---

archive/issue_comments_406101.json:
```json
{
    "body": "First, it should be clarified which is the best place to implement such a factor. Concerning code-structure a better place would be in the classes of power series or even polynomials.\n\nFor example, factorization of polynomials could profit from such a factor, too. Thus, FLINT uses functions `nmod_poly_inflate`, `nmod_poly_deflate` and `nmod_poly_deflation` in that context, realizing the usage of a scale factor, as well.\n\nBut, if a realization of the scale factor for polynomials is considered, it must be done carefully, in order not to slowdown performance with respect to current applications.",
    "created_at": "2020-01-28T20:37:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28755",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28755#issuecomment-406101",
    "user": "@soehms"
}
```

First, it should be clarified which is the best place to implement such a factor. Concerning code-structure a better place would be in the classes of power series or even polynomials.

For example, factorization of polynomials could profit from such a factor, too. Thus, FLINT uses functions `nmod_poly_inflate`, `nmod_poly_deflate` and `nmod_poly_deflation` in that context, realizing the usage of a scale factor, as well.

But, if a realization of the scale factor for polynomials is considered, it must be done carefully, in order not to slowdown performance with respect to current applications.



---

archive/issue_comments_406102.json:
```json
{
    "body": "I would not do that at the level of polynomials as most of them rely on low-level implementations (via flint, NTL, ...). And you don't want to interfere with the datastructure here.\n\nTo my mind, we should have a single meta-object for all of\n- power series\n- Laurent polynomials/power series\n- Newton polynomial/power series\n- Newton-Laurent polynomial/series\nthat would rely on polynomials. Most of the code is just \"pass appropriately the call to polynomials\". And this is where I would try to stick this \"scale factor\".",
    "created_at": "2020-01-28T21:01:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28755",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28755#issuecomment-406102",
    "user": "@videlec"
}
```

I would not do that at the level of polynomials as most of them rely on low-level implementations (via flint, NTL, ...). And you don't want to interfere with the datastructure here.

To my mind, we should have a single meta-object for all of
- power series
- Laurent polynomials/power series
- Newton polynomial/power series
- Newton-Laurent polynomial/series
that would rely on polynomials. Most of the code is just "pass appropriately the call to polynomials". And this is where I would try to stick this "scale factor".



---

archive/issue_comments_406103.json:
```json
{
    "body": "Replying to [comment:2 vdelecroix]:\n> I would not do that at the level of polynomials as most of them rely on low-level implementations (via flint, NTL, ...). And you don't want to interfere with the datastructure here.\n> \n\nI agree (see my according comment in #4618).\n\n> To my mind, we should have a single meta-object for all of\n> - power series\n> - Laurent polynomials/power series\n> - Newton polynomial/power series\n> - Newton-Laurent polynomial/series\n> that would rely on polynomials. Most of the code is just \"pass appropriately the call to polynomials\". And this is where I would try to stick this \"scale factor\".\n\nThat is a good idea! But let us see, if  I understood it correctly: Do you mean to implement a new class `PolynomialCovering`, say and than declare the polynomial class attached to power series (for instance) by\n\n\n```\ndynamic_class('%s_covering' %self.__f.__class__.__name__, (self.__f.__class__, PolynomialCovering)) ?\n```\n\n\nThis new class should possess the attributes `covering_index` (the scale factor) and `polynomial_preimage` (the deflated polynomial as an instance of the bases class) and overload the arithmetic operations.  Is that correct?\n\nWhat are you referring to by //Newton// polynomial and //Newton-Laurent// polynomial*?",
    "created_at": "2020-01-30T08:23:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28755",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28755#issuecomment-406103",
    "user": "@soehms"
}
```

Replying to [comment:2 vdelecroix]:
> I would not do that at the level of polynomials as most of them rely on low-level implementations (via flint, NTL, ...). And you don't want to interfere with the datastructure here.
> 

I agree (see my according comment in #4618).

> To my mind, we should have a single meta-object for all of
> - power series
> - Laurent polynomials/power series
> - Newton polynomial/power series
> - Newton-Laurent polynomial/series
> that would rely on polynomials. Most of the code is just "pass appropriately the call to polynomials". And this is where I would try to stick this "scale factor".

That is a good idea! But let us see, if  I understood it correctly: Do you mean to implement a new class `PolynomialCovering`, say and than declare the polynomial class attached to power series (for instance) by


```
dynamic_class('%s_covering' %self.__f.__class__.__name__, (self.__f.__class__, PolynomialCovering)) ?
```


This new class should possess the attributes `covering_index` (the scale factor) and `polynomial_preimage` (the deflated polynomial as an instance of the bases class) and overload the arithmetic operations.  Is that correct?

What are you referring to by //Newton// polynomial and //Newton-Laurent// polynomial*?



---

archive/issue_comments_406104.json:
```json
{
    "body": "Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28755",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28755#issuecomment-406104",
    "user": "@mkoeppe"
}
```

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_comments_406105.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28755",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28755#issuecomment-406105",
    "user": "@mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
