# Issue 28755: Introduce a "scale factor" to Laurent series

Issue created by migration from https://trac.sagemath.org/ticket/28992

Original creator: soehms

Original creation time: 2020-01-12 08:16:32

CC:  tscrim vdelecroix

Keywords: Laurent series

The implementation of Laurent series in [OSCAR](https://oscar.computeralgebra.de/) (more explicitly in [NEMO](http://nemocas.org/)) uses a "scale factor" in order to compensate the inflation of its degree by the ramification index of Puiseux series. The aim of this ticket is to implement something similar for Sage Laurent series in order to reduce memory usage of our upcoming Puiseux series (see comment ticket:4618#comment:42 of #4618).

Inspiration can be taken form [fmpz_laurent_series](https://github.com/Nemocas/Nemo.jl/blob/master/src/flint/fmpz_laurent_series.jl)


This ticket should introduce the "scale factor" in the method `verschiebung` of #4618. As soon this is done the new code will run against the doctests of #4618.




---

Comment by soehms created at 2020-01-28 20:37:54

First, it should be clarified which is the best place to implement such a factor. Concerning code-structure a better place would be in the classes of power series or even polynomials.

For example, factorization of polynomials could profit from such a factor, too. Thus, FLINT uses functions `nmod_poly_inflate`, `nmod_poly_deflate` and `nmod_poly_deflation` in that context, realizing the usage of a scale factor, as well.

But, if a realization of the scale factor for polynomials is considered, it must be done carefully, in order not to slowdown performance with respect to current applications.


---

Comment by vdelecroix created at 2020-01-28 21:01:09

I would not do that at the level of polynomials as most of them rely on low-level implementations (via flint, NTL, ...). And you don't want to interfere with the datastructure here.

To my mind, we should have a single meta-object for all of
- power series
- Laurent polynomials/power series
- Newton polynomial/power series
- Newton-Laurent polynomial/series
that would rely on polynomials. Most of the code is just "pass appropriately the call to polynomials". And this is where I would try to stick this "scale factor".


---

Comment by soehms created at 2020-01-30 08:23:30

Replying to [comment:2 vdelecroix]:
> I would not do that at the level of polynomials as most of them rely on low-level implementations (via flint, NTL, ...). And you don't want to interfere with the datastructure here.
> 

I agree (see my according comment in #4618).

> To my mind, we should have a single meta-object for all of
> - power series
> - Laurent polynomials/power series
> - Newton polynomial/power series
> - Newton-Laurent polynomial/series
> that would rely on polynomials. Most of the code is just "pass appropriately the call to polynomials". And this is where I would try to stick this "scale factor".

That is a good idea! But let us see, if  I understood it correctly: Do you mean to implement a new class `PolynomialCovering`, say and than declare the polynomial class attached to power series (for instance) by


```
dynamic_class('%s_covering' %self.__f.__class__.__name__, (self.__f.__class__, PolynomialCovering)) ?
```


This new class should possess the attributes `covering_index` (the scale factor) and `polynomial_preimage` (the deflated polynomial as an instance of the bases class) and overload the arithmetic operations.  Is that correct?

What are you referring to by //Newton// polynomial and //Newton-Laurent// polynomial*?


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
