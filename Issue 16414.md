# Issue 16414: NumberField to SymbolicRing: rational but still approximate

Issue created by migration from Trac.

Original creator: gagern

Original creation time: 2014-07-12 22:15:53

CC:  kcrisman

I noticed this in comment:18:ticket:14239.


```
sage: poly = QQ[x](x^7 - x - 1)
sage: root = sorted(poly.roots(QQbar, False), key=imag)[0]
sage: root
-0.3636235193291805? - 0.9525611952610331?*I
sage: nf = NumberField(poly, "y", embedding=CC(root))
sage: z = SR(nf.gen()); z
-3775/3963*I - 2573/7076
sage: poly(QQbar(z)).is_zero()
False
```


The problem here for me as a user is the fact that when I see rational numbers in some expression, I expect them to be accurate. But the conversion to SR here uses `solve(to_poly_solve=True)`, which according to its documentation may yield approximate solutions. I'm still surprised that these approximate solutions may take the form of elements from ℚ[I]. I guess some code further down the line might get confused as well, since these conversions look as if they were exact.


---

Comment by gagern created at 2014-07-13 01:55:11

Cc-ing kcrisman since his commit [3278794](http://git.sagemath.org/sage.git/commit/?id=3278794b9a63e706b9ccef52435575a79f9a64ce) for #6642 introduced the use of `to_poly_solve=True` for `NumberFieldElement`, without any example of when this might be of use. Can you give an example of when this would be useful?

I've written code for #14239 to suite my perceived needs there. Including a fallback from `to_poly_solve=False` to `to_poly_solve=True` for which I don't have a test case either. It might turn out that we went very similar things in both these places, and we want to factor them out into some common function. For the moment I felt that having separate code might increase chances that my code gets a positive review, since new code is less likely to break expectations than tinkering with existing code.


---

Comment by vbraun created at 2014-07-15 02:52:20

New commits:


---

Comment by vbraun created at 2014-07-15 02:52:20

Changing component from number fields to symbolics.


---

Comment by vbraun created at 2014-07-15 03:00:46

Changing status from new to needs_review.


---

Comment by git created at 2014-07-15 04:01:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2014-07-15 04:01:43

Doctests all pass now...


---

Comment by gagern created at 2014-07-15 08:47:06

I guess it might be next week before I find the time to have a closer look at this. And I don't know the code in this area, and have little experience with Maxima itself either. In any case, would I be correct to assume that `options='algexact:true'` is the critical point here?

Notes to self or any other reviewer:
* Omitting `multiplicities` in the condition makes sense, since `to_poly_solve=True, multiplicities=True` would already raise a `NotImplementedException` earlier on.
* Not messing around with `repr(x) in …` is certainly a good thing.
* The move from `Y = ….sage()` to `T = string_to_list_of_solutions(repr(s))` I don't understand yet. Need a closer look.
* The rationale behind `ignore_exceptions` I don't understand either yet.

A lot of this appears to be drive-by-fixes which make sense but are not immediately related to this bug here. Is that correct? Can you come up with doctests for the things these fix, if it's more than code simplification? For example I suppose that having one variable name as a substring of another might confuse this `repr(x)` hackery.

I would prefer changing the `while todo: ex = todo.pop()` back to `for eq in todo:`. As it stands now, the idiom suggests that you might be adding stuff to the list within the loop. This even had me concerned about infinite loops for a moment. But you don't do that, you simply iterate over the list.


---

Comment by git created at 2014-07-15 12:50:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vbraun created at 2014-07-15 12:55:36

Thanks, I switched to the while because the original code did add/remove stuff. But that was all wrong, and I forgot to switch it back. 

The main bug of the entire logic was that `X` was being iterated over and modified at the same time, so some solutions were skipped while other solutions were ran twice through Maxima. The first call to Maxima yielded a floating-point answer, and in the subsequent call Maxima converted the floating-point number to a rational.

There was a similar bug when solve originally found no solution, causing maxima `to_poly_solve` to be called twice. I fixed that, too.

The main doctest is the one you gave where some numerical solutions were incorrectly returned as rational.


---

Comment by vbraun created at 2014-07-15 19:06:28

Btw the `options='algexact:true'` is suggested by the maximal manual. It makes it more likely to find an exact solution.


---

Comment by kcrisman created at 2014-07-17 02:44:05

> Cc-ing kcrisman since his commit [3278794](http://git.sagemath.org/sage.git/commit/?id=3278794b9a63e706b9ccef52435575a79f9a64ce) for #6642 introduced the use of `to_poly_solve=True` for `NumberFieldElement`, without any example of when this might be of use. Can you give an example of when this would be useful?

This was because of comment:7:ticket:6642.  Basically, the problem is that Barton's `to_poly_solve` stuff depends on `algsys` which does not guarantee exact solutions, though it very often gives them.  But in order for that doctest to work we made that change, as you can see by reading the full set of comments on the ticket.

But I'm very happy if someone cleans up whatever code I contributed so long ago - I wrangled over that in various ways to make sure that if somebody really wanted a solution they would get one, but it was certainly just to get things done.  Thanks for looking into it!


---

Comment by gagern created at 2014-07-17 07:16:37

Replying to [comment:12 kcrisman]:
> This was because of comment:7:ticket:6642.  Basically, the problem is that Barton's `to_poly_solve` stuff depends on `algsys` which does not guarantee exact solutions, though it very often gives them.  But in order for that doctest to work we made that change, as you can see by reading the full set of comments on the ticket.

Must have been asleep when reading that ticket, sorry. So the way I understand it now, the `to_poly_solve=True` was introduced specifically to allow for approximate solutions. There is no example of a polynomial equation where `to_poly_solve=True` would find an _exact_ solution that `to_poly_solve=False` missed, right?

In that case, I might as well remove the whole `to_poly_solve=True` stuff from my commit for #14239, since I'd filter out inexact solutions in any case.

(Sorry, had to edit this comment; I hadn't realized we were not talking on #14239 already.)


---

Comment by gagern created at 2014-07-17 07:32:46

For `NumberFieldElement` I wonder whether it would be better to not use an approximate solution, but instead convert to `QQbar` and then embed that into `SR`. Only if there exists no radical solution, to be sure. Visually it would look the same: numbers get printed as an approximation. Mathematically, though, things would be exact.

There might be downsides, of course. Some computations might fail because they aren't defined for algebraic numbers. Some others might take considerably longer. And there would be no reasonable way to deprecate current behavior, because we have to return one or the other, there seems to be no reasonable way in between. How would one go about discussing a possible change like this?

In any case, that would be a different ticket, since this one here is about the incorrect rationals, which I'll try to review this weekend. Converting to `QQbar` would also require #5355 to be addressed first.


---

Comment by vbraun created at 2014-07-17 14:22:44

Considering that there is only so much that you can do for a univariate polyonomial, I guess its true that you don't benefit from `to_poly_solve=True` in #14239.

If you have fundamental questions about `NumberFieldElement` you should post to sage-devel. None of its original authors will read this ticket.


---

Comment by kcrisman created at 2014-07-18 14:05:23

> > This was because of comment:7:ticket:6642.  Basically, the problem is that Barton's `to_poly_solve` stuff depends on `algsys` which does not guarantee exact solutions, though it very often gives them.  But in order for that doctest to work we made that change, as you can see by reading the full set of comments on the ticket.
> 
> Must have been asleep when reading that ticket, sorry. So the way I understand it now, the `to_poly_solve=True` was introduced specifically to allow for approximate solutions. There is no example of a polynomial equation where `to_poly_solve=True` would find an _exact_ solution that `to_poly_solve=False` missed, right?

Absolutely not.  `to_poly_solve` was added to get lots more exact solution.  As a byproduct of that, occasionally inexact solutions are returned.  See the documentation for `solve?` or `x.solve?` for lots of examples.


---

Comment by vbraun created at 2014-07-18 14:33:46

Replying to [comment:16 kcrisman]:
> Absolutely not.  `to_poly_solve` was added to get lots more exact solution. 

But the cases where you do get more exact solutions are not univariate polynomials.


---

Comment by kcrisman created at 2014-08-15 11:14:23

> > Absolutely not.  `to_poly_solve` was added to get lots more exact solution. 
> 
> But the cases where you do get more exact solutions are not univariate polynomials.
Hmm, that is most likely true, since the point is to solve things that are not polynomials (you convert them to polys), though I'm not 100% sure - I would want to confirm that with Barton.


---

Comment by kcrisman created at 2014-08-27 16:47:33

The only thing like that I could find in the documentation was

```
to_poly_solve(x^(2*a) + x^a + 1,x);
```

but that's for a generic variable `a`.


---

Comment by rws created at 2014-09-01 08:47:13

Changing status from needs_review to positive_review.


---

Comment by rws created at 2014-09-01 08:47:13

The buildbot error is unrelated, the changes look good. I just removed some pidgin fom the text.
----
New commits:


---

Comment by kcrisman created at 2014-09-02 12:26:21

If you're going to fix language that didn't need fixing ("the use" isn't necessary, imo, but the fix is fine too), then one should fix
* 

```
``force``
``'force'``
```

* 

```
an univariate
a univariate
```



---

Comment by vbraun created at 2014-09-06 11:02:58

Resolution: fixed
