# Issue 21705: Cheeger constant

Issue created by migration from Trac.

Original creator: pelegm

Original creation time: 2016-11-23 10:08:51

CC:  vdelecroix jepperlein slelievre

Keywords: cheeger,isoperimetric,random walk,days79

I have implemented an algorithm to find the so-called Cheeger constant of a graph.  There are various definitions for this constant, I have chosen one which is sometimes also called **transition isoperimetric number**.

It would be nice to add an alias method `self.transition_isoperimetric_number`, but I am not sure what is the right way of doing this.

I plan to add an implementation for other isoperimetric numbers, such as the **edge isoperimetric number** (sometimes simply called **isoperimetric number**) and the **vertex isoperimetric number** (sometimes called the **magnifying constant**).

Note that the implemented Cheeger constant is also the **conductance** of the simple random walk on the graph.


---

Comment by pelegm created at 2016-11-23 10:10:11

New commits:


---

Comment by pelegm created at 2016-11-23 10:10:11

Set assignee to pelegm.


---

Comment by git created at 2016-11-23 12:55:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-11-23 13:14:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pelegm created at 2016-11-23 13:15:20

Changing status from new to needs_review.


---

Comment by pelegm created at 2016-11-23 16:01:44

Will rebase to `develop`.


---

Comment by pelegm created at 2016-11-24 12:48:28

Changing status from needs_review to needs_work.


---

Comment by pelegm created at 2016-11-24 12:48:28

`@`vdelecroix, perhaps we can work on this together on some notebook on the cloud or somewhere else?


---

Comment by jmantysalo created at 2016-11-29 21:50:31

I know nothing about those functions. However, two general notes:

- One-sentence descriptions will be used in the toc and they should really be just one sentence. It is kind of dull to have "Return the edge-isoperimetric number of a graph." when the name is `edge_isoperimetric_number()`, but there is no good alternative. (When there is no real one-line description like for example `size()` has.)

- Please test for empty graphs. See #21741 for bugs we already have had.


---

Comment by pelegm created at 2016-11-30 11:44:59

Thanks for the feedback. I am currently testing a better algorithm, based on gray codes. I will also modify the docstrings appropriately, and test/fix the method for empty graphs (and, in general, for graphs with no edges).


---

Comment by pelegm created at 2016-11-30 16:55:58

There is no consensus about the definition of Cheeger constants for the empty graph and the graph with 1 vertex. I suggest that we will raise an exception if the graph is empty, and return infinity if the graph contains a single vertex (so that usual lower bounds on the mixing time of the random walk on the graph will not fail).

The Cheeger constant of a disconnected graph is 0.  I should add that as a heuristic at the beginning of each of the methods.


---

Comment by dcoudert created at 2016-12-01 08:08:04

You could do the following to reduce overall computation time:

```
for k in range(1, self.order()//2):
    for s in Subsets(self.vertices(), k):
         ....
```

and of course start methods testing the trivial cases.


---

Comment by vdelecroix created at 2016-12-01 08:31:02

I strongly believe that the best way to go is a C backtracker implemented on sparse C graphs. It will be at least 100x faster. With the current code it is not even possible to make computation with graphs with 20 vertices.


---

Comment by pelegm created at 2016-12-01 08:51:11

>  You could do the following to reduce overall computation time: 
Well, this will not do for the Cheeger constant, but might help the isoperimetric numbers.

> I strongly believe that the best way to go is a C backtracker implemented on sparse C graphs. It will be at least 100x faster. With the current code it is not even possible to make computation with graphs with 20 vertices.

You are right: it is very slow. However, I must say that I have no idea how to implement stuff in C. About the backtracker you've offered: do you think that we should simply use a gray code which traverses the entire lattice, or should we really think of something smarter that traverses (mostly) only the relevant subsets? This is probably just a matter of a X2 speed factor, I believe (probably even much less).


---

Comment by vdelecroix created at 2016-12-01 08:56:17

Let me try it now.


---

Comment by git created at 2016-12-01 10:05:06

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by pelegm created at 2016-12-01 10:06:20

In the meanwhile, I have rebased to 7.5beta4 and added some heuristics.


---

Comment by git created at 2016-12-01 17:39:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by pelegm created at 2016-12-01 17:41:58

I am considering changing the doc index from //Algorithmically hard stuff// to //Expansion properties//.  What do you think?


---

Comment by jmantysalo created at 2016-12-02 07:22:44

Replying to [comment:18 pelegm]:
> I am considering changing the doc index from //Algorithmically hard stuff// to //Expansion properties//.  What do you think?

Whole idea of //Algorithmically hard stuff// as a TOC headear is odd. To compare, posets have //Properties of the poset//, even when `height` is trivial, `width` is harder but polynomial and `dimension` is proven to not be in `P`.

So yes, please do that.


---

Comment by vdelecroix created at 2016-12-02 08:02:32

I push a C implementation at `u/vdelecroix/cheeger` which seems to coincide with the one here ;-)

```
sage: from sage.graphs.isoperimetric_inequalities import cheeger
sage: G = graphs.CubeGraph(4)
sage: %time G.cheeger_constant()
CPU times: user 4.12 s, sys: 52 ms, total: 4.18 s
Wall time: 4.1 s
1/4
sage: %time cheeger(G)
CPU times: user 0 ns, sys: 0 ns, total: 0 ns
Wall time: 1.97 ms
1/4
```



---

Comment by vdelecroix created at 2016-12-02 08:09:42

but not all ;-(

```
sage: G = graphs.FibonacciTree(6)
sage: %time G.cheeger_constant()
CPU times: user 1min 3s, sys: 28 ms, total: 1min 3s
Wall time: 1min 3s
1/15
sage: %time cheeger(G)
CPU times: user 16 ms, sys: 0 ns, total: 16 ms
Wall time: 14.5 ms
1/13
```

I can not work on it right now. I will debug later.


---

Comment by pelegm created at 2016-12-02 09:15:10

I will verify my algorithm for the Fibonacci tree, and if it looks fine I will have a look at your code. Thanks!


---

Comment by vdelecroix created at 2016-12-02 09:18:12

I believe that mine is wrong. Anyway it is worth to look at the code. In particular are there situations were we can perform cheap branch cut?


---

Comment by pelegm created at 2016-12-02 09:26:21

Well, I guess that at least for trees the algorithm can be vastly improved.


---

Comment by pelegm created at 2016-12-02 11:28:03

This paper: http://ac.els-cdn.com/0095895689900294/1-s2.0-0095895689900294-main.pdf?_tid=c92aa55e-b880-11e6-a64e-00000aab0f02&acdnat=1480677575_44a9c4d6e1d9a6be9b2770c5d14f7ecf claims there is a linear algorithm for calculating the edge isoperimetric number of trees.
It is a corollary of a more general statement, according to which for every connected graph there exists a partition of its vertex set to **X** and **Y** such that the subgraphs induced by these sets are both connected and the (edge) isoperimetric number equals **|E(X,Y)|/min{|X|,|Y|}**.


---

Comment by vdelecroix created at 2016-12-02 12:44:55

Indeed, if we can restrict to connected X and Y in the parition then it is much better! I was not expecting something that strong. However I do not see linearity coming in. There are many partitions X,Y of the vertices so that both induced graphs are connected.


---

Comment by vdelecroix created at 2016-12-02 13:36:27

The algorithm works in general and is linear on trees!


---

Comment by pelegm created at 2016-12-02 14:00:55

I think the following algorithm works for trees:

https://github.com/pelegm/iso


---

Comment by pelegm created at 2016-12-02 14:30:46

The algorithm now also finds Cheeger constant (and not only edge isoperimetric number) of trees.


---

Comment by git created at 2016-12-04 19:00:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-12-07 21:57:31

1) You should test the case with 1 vertex.

2) I fixed the backtracker in C. It is still available at `u/vdelecroix/cheeger`. It would be easy to adapt to the other constants.


---

Comment by vdelecroix created at 2018-05-28 15:34:00

rebased on 8.3.beta3
----
New commits:


---

Comment by vdelecroix created at 2018-05-28 15:35:46

TODO:

- implement the backtracker for the 3 versions
- use branch and bound (ie cut branches)


---

Comment by git created at 2018-05-28 15:55:05

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-05-28 21:39:17

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2018-05-28 21:39:47

Changing keywords from "cheeger,isoperimetric,random walk,days79" to "cheeger, MathExp2018".


---

Comment by vdelecroix created at 2018-05-28 21:39:47

Changing status from needs_work to needs_review.


---

Comment by pelegm created at 2018-05-29 08:03:29

Thanks for all your work on this!

The code looks fine, testing a couple of cases on my machine works great, however, I cannot build the docs, but it seems like the issue is not with your new code (I get `[graphs   ] OSError: [graphs   ] /media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage/combinat/designs/incidence_structures.py:docstring of sage.combinat.designs.incidence_structures.IncidenceStructure.is_generalized_quadrangle:3: WARNING: citation not found: BH12`).

Would you call it a positive review?


---

Comment by vdelecroix created at 2018-05-30 15:07:16

Replying to [comment:39 pelegm]: 
> The code looks fine, testing a couple of cases on my machine works great, however, I cannot build the docs, but it seems like the issue is not with your new code (I get `[graphs   ] OSError: [graphs   ] /media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage/combinat/designs/incidence_structures.py:docstring of sage.combinat.designs.incidence_structures.IncidenceStructure.is_generalized_quadrangle:3: WARNING: citation not found: BH12`).

It might be something on your computer. It looks fine with the patchbot as well as on my computer. Did you do a `make doc-clean` before building the doc?


---

Comment by pelegm created at 2018-05-31 05:18:45

This is how it looks like:

```
peleg`@`etti:develop:~/sage$ git fetch trac u/vdelecroix/21942
From git://trac.sagemath.org/sage
 * branch                  u/vdelecroix/21942 -> FETCH_HEAD
peleg`@`etti:develop:~/sage$ git checkout -b 21942 FETCH_HEAD 
Switched to a new branch '21942'
peleg`@`etti:21942:~/sage$ make doc-clean

...

Sage build/upgrade complete!
peleg`@`etti:21942:~/sage$ sage --docbuild reference/graphs html

...

[graphs   ] /media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage/combinat/designs/incidence_structures.py:docstring of sage.combinat.designs.incidence_structures.IncidenceStructure.is_generalized_quadrangle:3: WARNING: citation not found: BH12

...

[graphs   ] WARNING: Error building the documentation.
[graphs   ] Traceback (most recent call last):
[graphs   ]   File "/media/peleg/peleg/sage/local/lib/python2.7/runpy.py", line 174, in _run_module_as_main
[graphs   ]     "__main__", fname, loader, pkg_name)
[graphs   ]   File "/media/peleg/peleg/sage/local/lib/python2.7/runpy.py", line 72, in _run_code
[graphs   ]     exec code in run_globals
[graphs   ]   File "/media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage_setup/docbuild/__main__.py", line 2, in <module>
[graphs   ]     main()
[graphs   ]   File "/media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage_setup/docbuild/__init__.py", line 1713, in main
[graphs   ]     builder()
[graphs   ]   File "/media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage_setup/docbuild/__init__.py", line 749, in _wrapper
[graphs   ]     getattr(DocBuilder, build_type)(self, *args, **kwds)
[graphs   ]   File "/media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage_setup/docbuild/__init__.py", line 130, in f
[graphs   ]     runsphinx()
[graphs   ]   File "/media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage_setup/docbuild/sphinxbuild.py", line 276, in runsphinx
[graphs   ]     sys.stderr.raise_errors()
[graphs   ]   File "/media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage_setup/docbuild/sphinxbuild.py", line 216, in raise_errors
[graphs   ]     raise OSError(self._error)
[graphs   ] OSError: [graphs   ] /media/peleg/peleg/sage/local/lib/python2.7/site-packages/sage/combinat/designs/incidence_structures.py:docstring of sage.combinat.designs.incidence_structures.IncidenceStructure.is_generalized_quadrangle:3: WARNING: citation not found: BH12
```



---

Comment by vdelecroix created at 2018-05-31 07:27:03

After `make doc-clean` you should be using `make doc`.


---

Comment by pelegm created at 2018-05-31 12:59:45

Works, thanks (took 2.5 hours, though...).

Some minor suggestions:
- In the cheeger constant docs, I'd replace `S(X)` with `Vol(X)` (it's a more common notation)
- I'd add "SEE ALSO" sections from each of the isoperimetric constants to the others.

Other than that, everything looks great. You may switch to positive review after you apply the suggestions, or if you decide not to apply them.


---

Comment by git created at 2018-05-31 14:09:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2018-05-31 14:10:28

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2018-05-31 14:10:28

Done!


---

Comment by vbraun created at 2018-05-31 18:12:15

Reviewer name?


---

Comment by vbraun created at 2018-05-31 18:12:15

Changing status from positive_review to needs_work.


---

Comment by vdelecroix created at 2018-06-01 07:09:27

Sorry


---

Comment by vdelecroix created at 2018-06-01 07:09:27

Changing status from needs_work to positive_review.


---

Comment by pelegm created at 2018-06-01 08:15:24

Hi, I apologize for yet another late response, but just wanted to ask: for graphs without edges (and at least 2 vertices) you set the Cheeger constant to be 1.

It is correct that the constant is not well defined for graphs without edges, but still I would maybe set it to be 0, to be consistent with the general idea that larger Cheeger constant means higher connectivity, and the specific idea that non-connected graphs have Cheeger constant 0.

In fact, if you agree with this then we may add a quick heuristic at the beginning of the method, which checks whether the graph is connected, and returns 0 otherwise.


---

Comment by vdelecroix created at 2018-06-01 08:18:10

Changing status from positive_review to needs_work.


---

Comment by dcoudert created at 2018-06-02 09:11:11

I also agree that you should test that the input graph is connected.

Some remarks:
* Why not cythonizing method `vertex_isoperimetric_number` ? 

* in file `index.rst`, I think that the first initial of a ref needs a `\`, like in `.. [ADKF1970] \V. Arlazarov`

* At the top of file `isoperimetric_inequalities.pyx`, you should add some words on the kind of methods that are in this file.

* in `graph.py`, method `vertex_isoperimetric_number`: `and the sum is taken over the subsets` -> `and the minimum is taken over the subsets`

* in method `cheeger_constant`, please add definition of `\partial X`
* similarly, in `edge_isoperimetric_number`, please define `\partial S`


---

Comment by dcoudert created at 2018-06-02 10:13:33

`    from sage.rings import infinity` -> `    from sage.rings.infinity import Infinity` or `    from sage.rings.infinity import infinity`, I don't know which is best.


---

Comment by dcoudert created at 2018-06-02 10:57:15

For `vertex_isoperimetric_number`, it is not realistic to try to compute this value for large graphs. For up to 31 vertices, you can do in Cython:

```
from sage.graphs.graph_decompositions.fast_digraph cimport FastDigraph, compute_out_neighborhood_cardinality, popcount32
from sage.rings.integer cimport Integer

def vertex_isoperimetric_number_fast(self):
    """
    """
    cdef FastDigraph FG = FastDigraph(self)

    cdef int card, boundary, S
    cdef int mc = FG.n // 2
    cdef int p = FG.n
    cdef int q = 0
    
    for S in range(1, 2**FG.n):
        card = popcount32(S)
        if card <= mc:
            boundary = compute_out_neighborhood_cardinality(FG, S)
            if boundary * q < p * card:
                p = boundary
                q = card

    return Integer(p) / Integer(q)
```

it iterates over all the non-empty subsets of vertices. `popcount32(S)` counts the number of `1`'s and so of vertices in the current subset `S`, and `compute_out_neighborhood_cardinality` computes the number of vertices in `N(S)\S`.


```
sage: %time vertex_isoperimetric_number(G) # your method
CPU times: user 4.36 ms, sys: 1.76 ms, total: 6.13 ms
Wall time: 9.11 ms
3/2
sage: G = graphs.CompleteGraph(5)
sage: %time vertex_isoperimetric_number_fast(G)
CPU times: user 83 µs, sys: 5 µs, total: 88 µs
Wall time: 88.9 µs
3/2

sage: G = graphs.CycleGraph(10)
sage: %time vertex_isoperimetric_number_fast(G)
CPU times: user 114 µs, sys: 17 µs, total: 131 µs
Wall time: 117 µs
2/5
sage: G = graphs.CycleGraph(20)
sage: %time vertex_isoperimetric_number_fast(G)
CPU times: user 34.7 ms, sys: 90 µs, total: 34.8 ms
Wall time: 34.8 ms
1/5
sage: G = graphs.CycleGraph(30)
sage: %time vertex_isoperimetric_number_fast(G)
CPU times: user 33.3 s, sys: 121 ms, total: 33.4 s
Wall time: 33.9 s
2/15
```

We can certainly do something similar for the other methods. We just need a smart way to compute `|\partial X| / |Vol(X)|` and `|E(X)|` (which is not properly defined in the method) and `|\partial S| / |S|`.

It is of course possible to add a parameter `k` to compute the value only over all subsets of order `k` (see https://en.wikipedia.org/wiki/Isoperimetric_inequality)


---

Comment by vdelecroix created at 2018-06-03 09:50:57

I am not 100% convinced by `FastDigraph`:

- why `FastDiagraph` is not merged with `base/static_dense_graph`? Both uses a bitset matrix and binary matrices are not limited to 32 vertices. Of course, if you have one limb you can perform some optimization but it would be nicer to have the same API (and use the same directory).

- Using `int` might not be the best option. The library stdint proposes a `uint_fast32_t` that is exactly what you want here.

- Many processors offer a `popcount` that `popcount32` is just ignoring.


---

Comment by vdelecroix created at 2018-06-03 09:59:06

With dense representation and bit operations one can indeed remove the inner loops from the already cythonized  `cheeger_constant` and `edge_isoperimetric_number`. On the other hand, these methods

- perform incremental step in the construction of the subsets (so that updating volume/boundary is cheap)
- do not go through all subsets but only through the one relevant to the definition (this is only a factor x2)


---

Comment by git created at 2018-06-03 10:05:17

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2018-06-03 10:06:48

rebased on 8.3.beta4 + extra commit taking care of some of the remarks of David.


---

Comment by vdelecroix created at 2018-06-03 10:06:48

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2018-06-03 11:01:47

I'm not claiming that `FastDigraph` is perfect. It was useful for implementing vertex separation and cutwidth. It can certainly be cleaned/improved/etc. (e.g., using `__builtin_popcount` and `uint_fast32_t`). However, for such algorithms, the extra cost of using bitsets is not justified since we can hardly go above 32 nodes: huge computation time and memory usage.\\
Here, if you think it is possible to compute the `vertex_isoperimetric_number` on larger graphs, then you can use `binary_matrix`. Another idea could be to use `short_digraph` and the same structure as for other methods, and maintain the vertices in the boundary (e.g., use an array to store the number of edges from `S` to each vertex outside `S`, and increase/decrease `vol` each time a cell becomes non-zero/zero).

I did some tests using `static_dense_graph`, and so `binary_matrix`, for `cheeger_constant` and `edge_isoperimetric_number`. My code is slightly faster for dense graphs but slower for sparse graphs. Not so interesting here.

There are a small improvements you can do:
- to update `vol` in `cheeger_constant`: use an array to store the degree of vertices, and then, instead of doing `vol += 1` inside the for loop, do `vol += degree[u]` outside.
- add definition of `E(S)`. 
- have you tried maintaining the value `E(S)` ?
- you use a bitset to maintain the set of vertices in the subgraph. Wouldn't it be faster to use an array of `bint` ? You don't use bitset operations here, and memory usage is clearly not an issue.


---

Comment by git created at 2018-06-03 11:05:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2018-06-03 11:37:29

I agree with your suggestions. Though, a much more needed improvement would be to be able to iterate through subsets `S` of vertices with `S` and `V \ S` connected.


---

Comment by git created at 2018-06-03 11:42:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-06-03 14:45:26

An algorithm for iterating over connected subgraphs is described here https://stackoverflow.com/questions/15658245/efficiently-find-all-connected-induced-subgraphs. May be we can adapt it...

At least, it is possible to avoid the recursion and so to have a connected subgraph iterator. Not clear how to get an efficient implementation. I'll think about it.


---

Comment by dcoudert created at 2018-06-03 18:24:16

I have implemented an iterator over connected subgraphs is Cython. It is reasonably fast. I should open a ticket for it, but I don't know yet in which file to add it. Any suggestion ?

It can certainly help improving this ticket, although current implementations are quite good.


---

Comment by vdelecroix created at 2018-06-03 18:33:42

Replying to [comment:62 dcoudert]:
> I have implemented an iterator over connected subgraphs in Cython. It is reasonably fast. I should open a ticket for it, but I don't know yet in which file to add it. Any suggestion ?

`connected_subgraphs_iterator.pyx`? Please, cc me.

> It can certainly help improving this ticket, although current implementations are quite good. 

To improve even more the computation of Cheeger constant, there should be an iterator over connected subgraph so that the complement is also connected! I can comment on this when your ticket is open.

Are you ok setting this ticket in positive review as it is? It will serve as a base for further improvements.


---

Comment by vdelecroix created at 2018-06-03 18:38:06

Note that I can easily factor `cheeger_constant` and `edge_isoperimetric_number` (exact same computation except the small difference for `vol`). It might be worth not duplicating code.


---

Comment by vdelecroix created at 2018-06-03 18:44:13

Replying to [comment:64 vdelecroix]:
> Note that I can easily factor `cheeger_constant` and `edge_isoperimetric_number` (exact same computation except the small difference for `vol`). It might be worth not duplicating code.

What let me hesitate is that we can cut branches in the backtracking and when to cut will differ. What do you think?


---

Comment by dcoudert created at 2018-06-03 19:06:33

Do you plan to add cuts in a near future ? and is the current structure of the code appropriate to add cuts ? if not, you can factor the code.


---

Comment by vdelecroix created at 2018-06-03 19:14:14

Replying to [comment:66 dcoudert]:
> Do you plan to add cuts in a near future ? and is the current structure of the code appropriate to add cuts ? if not, you can factor the code.

As my answers are "no" and "no" let me factor and add a note.


---

Comment by vdelecroix created at 2018-06-03 19:17:38

I spoke too fast: there are already two different cuts! By the definition of Cheeger constant, you cut when `Vol(s) > m` while for the isoperimetric number you cut `2*|S| > n` (where `m` and `n` are as usual number of edges and number of vertices).


---

Comment by dcoudert created at 2018-06-03 21:58:01

Right.

Don't forget to add `sig_on` `sig_off` so that we can kill computation if needed.


---

Comment by git created at 2018-06-03 22:14:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2018-06-04 14:31:39

I have a much better implementation for `vertex_isoperimetric_number` using the ideas from https://stackoverflow.com/questions/15658245/efficiently-find-all-connected-induced-subgraphs. You can use it on a multigraph with loops. No limit on the number of vertices, but of course the time complexity remains. 

Roughly, it uses a non-recursive version of the algorithm to generate all connected subgraphs of order at most `n/2`. I'm therefore using a binary matrix as a stack of bitsets.


```
from sage.rings.rational_field import QQ
from sage.rings.infinity import Infinity
from cysignals.signals cimport sig_on, sig_off

include "sage/data_structures/binary_matrix.pxi"
from sage.graphs.base.static_dense_graph cimport dense_graph_init

def vertex_isoperimetric_number_iter(G):
    """
    """
    if G.is_directed():
        raise ValueError("vertex-isoperimetric number is only defined on non-oriented graph")
    if G.order() == 0:
        raise ValueError("vertex-isoperimetric number not defined for the empty graph")
    elif G.order() == 1:
        return Infinity
    elif not G.is_connected():
        return QQ((0,1))

    # We convert the graph to a static dense graph
    cdef binary_matrix_t DG
    dense_graph_init(DG, G)
    cdef int n = G.order()
    cdef int k = n / 2   # maximum size of a subset

    sig_on()

    # We use a stack of bitsets. For that, we need 3 bitsets per level with at
    # most n/2 + 1 levels, so 3 * (n / 2) + 3 bitsets. We also need 1 bitset that
    # we create at the same time, so so overall 3 * (n / 2) + 4 bitsets
    cdef binary_matrix_t stack
    binary_matrix_init(stack, 3 * (n / 2) + 4, n)

    cdef bitset_t candidates = stack.rows[3 * (n / 2) + 3]
    cdef bitset_t left     # vertices not yet explored
    cdef bitset_t current  # vertices in the current subset
    cdef bitset_t boundary # union of neighbors of vertices in current subset

    cdef int l = 0
    cdef int p = n
    cdef int q = 0
    cdef int c, b, v

    # We initialize the first level
    for v in range(3):
        bitset_clear(stack.rows[v])
    bitset_complement(stack.rows[0], stack.rows[0])

    while l >= 0:

        # We take the values at the top of the stack
        left = stack.rows[l]
        current = stack.rows[l + 1]
        boundary = stack.rows[l + 2]

        if bitset_isempty(current):
            bitset_copy(candidates, left)
        else:
            bitset_and(candidates, left, boundary)

        if bitset_isempty(candidates):
            # We decrease l to pop the stack
            l -= 3

            # If the current set if non empty, we update the lower bound
            c = bitset_len(current)
            if c:
                bitset_difference(boundary, boundary, current)
                b = bitset_len(boundary)
                if b * q < p * c:
                    p = b
                    q = c

        else:
            # Choose a candidate vertex v
            v = bitset_first(candidates)
            bitset_discard(left, v)

            # Since we have not modified l, the bitsets for iterating without v
            # in the subset current are now at the top of the stack, with 
            # correct values

            if bitset_len(current) < k:
                # We continue with v in the subset current
                l += 3
                bitset_copy(stack.rows[l], left)
                bitset_copy(stack.rows[l + 1], current)
                bitset_add(stack.rows[l + 1], v)
                bitset_union(stack.rows[l + 2], boundary, DG.rows[v])

    binary_matrix_free(stack)
    binary_matrix_free(DG)
    sig_off()

    return QQ((p, q))
```



---

Comment by vdelecroix created at 2018-08-03 19:20:18

update milestone 8.3 -> 8.4


---

Comment by dkrenn created at 2019-03-28 08:50:26

Does not apply anymore.


---

Comment by dkrenn created at 2019-03-28 08:51:06

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2019-03-28 10:05:10

Note that we now have a connected subgraph iterator #25553.


---

Comment by git created at 2019-03-31 17:33:27

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2019-03-31 17:33:54

(just a rebase, need to adapt the code to use the connected subgraph iterator)


---

Comment by vdelecroix created at 2019-03-31 17:45:59

`@`dcoudert: I would be happy to use the subgraph iterator from #25553 however
- it is only implemented for dense graphs
- the iterator carries many information that would be extremely useful for implementing isoperimetric constants (such as boundary)
- passing around lists of vertices (the output of the iterator) is a big waste

One possible way to proceed is to make a proper Cython class for the subgraph iterator so that we can grab information (at C level) at each step of the iteration.

What do you think?


---

Comment by dcoudert created at 2019-03-31 18:39:16

Replying to [comment:79 vdelecroix]:
> `@`dcoudert: I would be happy to use the subgraph iterator from #25553 however
> - it is only implemented for dense graphs

It's reasonably fast this way :P But of course we could implement a sparse graph counter part.

> - the iterator carries many information that would be extremely useful for implementing isoperimetric constants (such as boundary)
> - passing around lists of vertices (the output of the iterator) is a big waste
> One possible way to proceed is to make a proper Cython class for the subgraph iterator so that we can grab information (at C level) at each step of the iteration.
> 
> What do you think?

We can certainly add such a class if it's needed. However, you have to be very careful if you want to access extra data. May be it's easier to copy/paste the code of the iterator, so that you can use the information you want safely at the time you need it.
The advantage of the class is to silently switch between sparse and dense representations.


---

Comment by embray created at 2019-06-14 14:50:27

Tickets still needing working or clarification should be moved to the next release milestone at the soonest (please feel free to revert if you think the ticket is close to being resolved).


---

Comment by dcoudert created at 2019-10-07 10:22:06

Moving to 9.0. We can also work on a proper cython class for subgraph iterator if useful.


---

Comment by embray created at 2020-01-06 14:10:03

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by chapoton created at 2020-07-11 06:21:15

There is some interest for this code : https://ask.sagemath.org/question/52410/edge-isoperimetric-number/

I have rebased the branch
----
New commits:


---

Comment by git created at 2020-07-11 06:26:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-07-11 09:34:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-07-11 09:39:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-07-11 09:45:43

I changed the code of vertex isoperimetric number. The new code is way faster on sparse graphs and can handle (multi-) graphs of any size. Of course, the running time can be significant on large graphs.


```
sage: G = graphs.Grid2dGraph(5,6)
sage: %time G.vertex_isoperimetric_number()
CPU times: user 328 ms, sys: 712 µs, total: 329 ms
Wall time: 329 ms
1/3
sage: G = graphs.Grid2dGraph(6, 6)
sage: %time G.vertex_isoperimetric_number()
CPU times: user 9.25 s, sys: 24.6 ms, total: 9.28 s
Wall time: 9.28 s
1/3
sage: G = graphs.CompleteGraph(10)
sage: %time G.vertex_isoperimetric_number()
CPU times: user 254 µs, sys: 4 µs, total: 258 µs
Wall time: 264 µs
1
sage: G = graphs.CompleteGraph(20)
sage: %time G.vertex_isoperimetric_number()
CPU times: user 32.3 ms, sys: 185 µs, total: 32.5 ms
Wall time: 32.5 ms
1
sage: G = graphs.CompleteGraph(30)
sage: %time G.vertex_isoperimetric_number()
CPU times: user 31.8 s, sys: 111 ms, total: 31.9 s
Wall time: 32 s
1
```



---

Comment by chapoton created at 2020-07-11 09:54:43

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2020-07-11 10:18:23

For me this patch is good to go as is and we can let possible improvements for future tickets like:
- algorithms for specific graph classes such as trees (#comment:28) or cliques
- make a class for connected subgraphs iterator and use it to speed up / simplify some parts (#comment:59)

I'm a bit lost in who should be in authors or reviewers or both...


---

Comment by chapoton created at 2020-07-13 06:51:19

On peut faire comme ça, par exemple. Tu peux te rajouter comme rapporteur si tu veux.


---

Comment by chapoton created at 2020-07-13 06:51:19

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2020-07-13 08:12:52

C'est très bien comme ça. Thanks.


---

Comment by vbraun created at 2020-07-19 07:24:34

Resolution: fixed
