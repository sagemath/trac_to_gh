# Issue 22137: {c,sparse}_graph: systematically turn integer-like vertices into ints

archive/issues_022137.json:
```json
{
    "body": "CC:  @dcoudert\n\nInstead of doing it or not depending on the phase of the moon:\n    \n\n```\n    sage: g = DiGraph([[1..12],lambda i,j: i!=j and i.divides(j)])\n    sage: [type(v) for v in g.vertices()]\n    [<type 'int'>,\n     <type 'int'>,\n     <type 'int'>,\n     <type 'int'>,\n     <type 'int'>,\n     <type 'int'>,\n     <type 'int'>,\n     <type 'int'>,\n     <type 'int'>,\n     <type 'sage.rings.integer.Integer'>,\n     <type 'int'>,\n     <type 'int'>]\n```\n\n    \nLeaving the vertices alone would be a better fix in principle. Unfortunately, it would break compatibility too badly: for example, people clearly expect to be able to create graphs in library code, using Python ints as labels, and then access the vertices using Sage integers.\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/22374\n\n",
    "created_at": "2017-02-12T18:01:45Z",
    "labels": [
        "component: graph theory",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.6",
    "title": "{c,sparse}_graph: systematically turn integer-like vertices into ints",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22137",
    "user": "https://github.com/jdemeyer"
}
```
CC:  @dcoudert

Instead of doing it or not depending on the phase of the moon:
    

```
    sage: g = DiGraph([[1..12],lambda i,j: i!=j and i.divides(j)])
    sage: [type(v) for v in g.vertices()]
    [<type 'int'>,
     <type 'int'>,
     <type 'int'>,
     <type 'int'>,
     <type 'int'>,
     <type 'int'>,
     <type 'int'>,
     <type 'int'>,
     <type 'int'>,
     <type 'sage.rings.integer.Integer'>,
     <type 'int'>,
     <type 'int'>]
```

    
Leaving the vertices alone would be a better fix in principle. Unfortunately, it would break compatibility too badly: for example, people clearly expect to be able to create graphs in library code, using Python ints as labels, and then access the vertices using Sage integers.


Issue created by migration from https://trac.sagemath.org/ticket/22374





---

archive/issue_comments_307098.json:
```json
{
    "body": "See #22029 for the context where this came up. I was trying to fix code that I frankly don't understand, comments or improvements from someone more familiar with `sage.graphs` would be very welcome.\n----\nNew commits:",
    "created_at": "2017-02-12T19:53:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307098",
    "user": "https://github.com/mezzarobba"
}
```

See #22029 for the context where this came up. I was trying to fix code that I frankly don't understand, comments or improvements from someone more familiar with `sage.graphs` would be very welcome.
----
New commits:



---

archive/issue_comments_307099.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-02-12T19:53:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307099",
    "user": "https://github.com/mezzarobba"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_307100.json:
```json
{
    "body": "Replying to [ticket:22374 jdemeyer]:\n> Leaving the vertices alone would be a better fix in principle. Unfortunately, it would break compatibility too badly: for example, people clearly expect to be able to create graphs in library code, using Python ints as labels, and then access the vertices using Sage integers.\n\nI agree that \"Leaving the vertices alone would be a better fix\".\n\nBut I don't understand why you don't just do that. You say that you want to access the vertices using Sage integers, but isn't that possible regardless of whether the vertices are internally stored as `int` or `Integer`?",
    "created_at": "2017-02-13T07:05:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307100",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [ticket:22374 jdemeyer]:
> Leaving the vertices alone would be a better fix in principle. Unfortunately, it would break compatibility too badly: for example, people clearly expect to be able to create graphs in library code, using Python ints as labels, and then access the vertices using Sage integers.

I agree that "Leaving the vertices alone would be a better fix".

But I don't understand why you don't just do that. You say that you want to access the vertices using Sage integers, but isn't that possible regardless of whether the vertices are internally stored as `int` or `Integer`?



---

archive/issue_comments_307101.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2017-02-13T09:56:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307101",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_307102.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2017-02-14T18:47:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307102",
    "user": "https://github.com/mezzarobba"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_307103.json:
```json
{
    "body": "If I remember right, generic graphs internally store their vertices as ints, and keep a separate mapping between those ints and the public labels, which can be more or less arbitrary objects. As an (apparently crucial?) optimization, public labels that are (small?) integers are used as internal labels, bypassing this translation layer. Storing Integer vertex labels as Integers would mean using the indirect representation. This would be fine if graph vertices were compared by identity rather than by equality, but while this might have been a saner design, that's clearly not what people expect from the existing code. If however we want to keep the ability to add and access integer vertices indifferently by passing integers of any type, then it seems more reasonable to me to stick to a single representation whenever possible. And in any case, I really don't understand the graphs code well enough to have anything else to suggest.",
    "created_at": "2017-02-14T18:47:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307103",
    "user": "https://github.com/mezzarobba"
}
```

If I remember right, generic graphs internally store their vertices as ints, and keep a separate mapping between those ints and the public labels, which can be more or less arbitrary objects. As an (apparently crucial?) optimization, public labels that are (small?) integers are used as internal labels, bypassing this translation layer. Storing Integer vertex labels as Integers would mean using the indirect representation. This would be fine if graph vertices were compared by identity rather than by equality, but while this might have been a saner design, that's clearly not what people expect from the existing code. If however we want to keep the ability to add and access integer vertices indifferently by passing integers of any type, then it seems more reasonable to me to stick to a single representation whenever possible. And in any case, I really don't understand the graphs code well enough to have anything else to suggest.



---

archive/issue_comments_307104.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-06-02T13:17:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307104",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_307105.json:
```json
{
    "body": "Don't break this doctest:\n\n```diff\ndiff --git a/src/sage/graphs/generic_graph.py b/src/sage/graphs/generic_graph.py\nindex a3fec74..26b2c83 100644\n--- a/src/sage/graphs/generic_graph.py\n+++ b/src/sage/graphs/generic_graph.py\n@@ -20161,7 +20161,7 @@ class GenericGraph(GenericGraph_pyx):\n         Relabeling using a dictionary. Note that the dictionary does not define\n         the new label of vertex `0`::\n \n-            sage: G.relabel({1:2,2:1}, inplace=False).am()\n+            sage: G.relabel({int(1):2,int(2):1}, inplace=False).am()\n             [0 0 1]\n             [0 0 1]\n             [1 1 0]\n```\n",
    "created_at": "2017-06-02T13:17:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307105",
    "user": "https://github.com/jdemeyer"
}
```

Don't break this doctest:

```diff
diff --git a/src/sage/graphs/generic_graph.py b/src/sage/graphs/generic_graph.py
index a3fec74..26b2c83 100644
--- a/src/sage/graphs/generic_graph.py
+++ b/src/sage/graphs/generic_graph.py
@@ -20161,7 +20161,7 @@ class GenericGraph(GenericGraph_pyx):
         Relabeling using a dictionary. Note that the dictionary does not define
         the new label of vertex `0`::
 
-            sage: G.relabel({1:2,2:1}, inplace=False).am()
+            sage: G.relabel({int(1):2,int(2):1}, inplace=False).am()
             [0 0 1]
             [0 0 1]
             [1 1 0]
```




---

archive/issue_comments_307106.json:
```json
{
    "body": "Replying to [comment:6 mmezzarobba]:\n> As an (apparently crucial?) optimization, public labels that are (small?) integers are used as internal labels, bypassing this translation layer.\n\nDo you know where this is implemented? Maybe we can just fix that to support Sage Integers too.",
    "created_at": "2017-06-02T13:18:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307106",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:6 mmezzarobba]:
> As an (apparently crucial?) optimization, public labels that are (small?) integers are used as internal labels, bypassing this translation layer.

Do you know where this is implemented? Maybe we can just fix that to support Sage Integers too.



---

archive/issue_comments_307107.json:
```json
{
    "body": "Replying to [comment:8 jdemeyer]:\n> Replying to [comment:6 mmezzarobba]:\n> > As an (apparently crucial?) optimization, public labels that are (small?) integers are used as internal labels, bypassing this translation layer.\n> \n> Do you know where this is implemented? Maybe we can just fix that to support Sage Integers too.\n\nI think part of it happens in `CGraphBackend.get_vertex()` and `CGraphBackend.check_labelled_vertex()`. But I really don't know more than what I guessed when working on the comparison stuff that led me to the present issue; I was hoping that someone who understands this code could help.",
    "created_at": "2017-06-02T14:28:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307107",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:8 jdemeyer]:
> Replying to [comment:6 mmezzarobba]:
> > As an (apparently crucial?) optimization, public labels that are (small?) integers are used as internal labels, bypassing this translation layer.
> 
> Do you know where this is implemented? Maybe we can just fix that to support Sage Integers too.

I think part of it happens in `CGraphBackend.get_vertex()` and `CGraphBackend.check_labelled_vertex()`. But I really don't know more than what I guessed when working on the comparison stuff that led me to the present issue; I was hoping that someone who understands this code could help.



---

archive/issue_comments_307108.json:
```json
{
    "body": "Ccing you in case there would be something to salvage from here, since you've apparently be doing lots of related work recently.",
    "created_at": "2018-12-19T16:00:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307108",
    "user": "https://github.com/mezzarobba"
}
```

Ccing you in case there would be something to salvage from here, since you've apparently be doing lots of related work recently.



---

archive/issue_comments_307109.json:
```json
{
    "body": "To the best of my understanding (this code is not easy):\n- `c_graph` uses 2 mappings: `vertex_ints` that associates the name of a vertex to the integer used in the internal representation, and `vertex_labels` that associates the integer from the internal representation to the vertex name.\n- So even is a vertex name is a small int, the integer used for the internal representation might be different.\n\nThis said, I don't understand why we have that\n\n```\nsage: g = DiGraph()\nsage: g.add_vertices([9..12])\nsage: [(v, type(v)) for v in g.vertices()]\n[(9, <type 'int'>),\n (10, <type 'sage.rings.integer.Integer'>),\n (11, <type 'sage.rings.integer.Integer'>),\n (12, <type 'sage.rings.integer.Integer'>)]\n```\n\nRequires more investigation...",
    "created_at": "2018-12-19T18:16:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307109",
    "user": "https://github.com/dcoudert"
}
```

To the best of my understanding (this code is not easy):
- `c_graph` uses 2 mappings: `vertex_ints` that associates the name of a vertex to the integer used in the internal representation, and `vertex_labels` that associates the integer from the internal representation to the vertex name.
- So even is a vertex name is a small int, the integer used for the internal representation might be different.

This said, I don't understand why we have that

```
sage: g = DiGraph()
sage: g.add_vertices([9..12])
sage: [(v, type(v)) for v in g.vertices()]
[(9, <type 'int'>),
 (10, <type 'sage.rings.integer.Integer'>),
 (11, <type 'sage.rings.integer.Integer'>),
 (12, <type 'sage.rings.integer.Integer'>)]
```

Requires more investigation...



---

archive/issue_comments_307110.json:
```json
{
    "body": "When you create an empty digraph using, `DiGraph()`, the `SparseGraph` constructor initializes the data structures for 10 vertices (`int extra_vertices = 10`). This is the initial size of the bitset `active_vertices`. Then, as mentioned above, when adding a vertex `u` whose label is an integer:\n1. if `u` is smaller than the current size of `active_vertices`, and that no previously added vertex `v` has been associated to an integer equals to `u`, then vertex `u` is marked as active but not added to mappings `vertex_ints` and `vertex_labels`.\n2. if `u` is smaller than the current size of `active_vertices`, but that a previously added vertex `v` has been associated to an integer equals to `u`, then `u` is associated to the first available integer `u_int` in range `0..|active_vertices|-1`, marked as active and added to the mappings `vertex_ints` and `vertex_labels`.\n3. if `u` is larger than the current size of `active_vertices`, we map it to the first available integer `u_int` in range `0..|active_vertices|-1`, mark `u_int` as active and add `u` and `u_int` to the mappings\n4. when all slots in `active_vertices` are used, we double it's size before adding a new vertex\n\nConsider the following example:\n\n```python\nsage: g = DiGraph()\nsage: g.add_vertices([9, 10, 0])\nsage: [(v, type(v)) for v in g]\n[(0, <type 'sage.rings.integer.Integer'>),\n (10, <type 'sage.rings.integer.Integer'>),\n (9, <type 'int'>)]\n```\n\nWhen adding vertex `9`, we are in case 1, and so `9` is not added to the mappings. Then, when adding vertex `10`, we are in case 3 so we map it to the first available integer (here 0) and  add it to the mappings. Hence, 10 keeps it's type (here `sage.rings.integer.Integer`), while 9 is of type `int`.\nNow, when we add vertex `0`, we are in case 2, and so it will be mapped to 1 and it's type will be `sage.rings.integer.Integer`. It will be the same if we now add vertex `1`...\n\n\nThe motivation of this optimization is to save space and few tests when the user creates vertices in the right order. But above example shows how easy it is to loose this optimization. \n\nShouldn't we should simplify the code and use mappings for all vertices ?\nIt could ease the resolution of issues like in #27037.",
    "created_at": "2019-01-12T13:17:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22137",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22137#issuecomment-307110",
    "user": "https://github.com/dcoudert"
}
```

When you create an empty digraph using, `DiGraph()`, the `SparseGraph` constructor initializes the data structures for 10 vertices (`int extra_vertices = 10`). This is the initial size of the bitset `active_vertices`. Then, as mentioned above, when adding a vertex `u` whose label is an integer:
1. if `u` is smaller than the current size of `active_vertices`, and that no previously added vertex `v` has been associated to an integer equals to `u`, then vertex `u` is marked as active but not added to mappings `vertex_ints` and `vertex_labels`.
2. if `u` is smaller than the current size of `active_vertices`, but that a previously added vertex `v` has been associated to an integer equals to `u`, then `u` is associated to the first available integer `u_int` in range `0..|active_vertices|-1`, marked as active and added to the mappings `vertex_ints` and `vertex_labels`.
3. if `u` is larger than the current size of `active_vertices`, we map it to the first available integer `u_int` in range `0..|active_vertices|-1`, mark `u_int` as active and add `u` and `u_int` to the mappings
4. when all slots in `active_vertices` are used, we double it's size before adding a new vertex

Consider the following example:

```python
sage: g = DiGraph()
sage: g.add_vertices([9, 10, 0])
sage: [(v, type(v)) for v in g]
[(0, <type 'sage.rings.integer.Integer'>),
 (10, <type 'sage.rings.integer.Integer'>),
 (9, <type 'int'>)]
```

When adding vertex `9`, we are in case 1, and so `9` is not added to the mappings. Then, when adding vertex `10`, we are in case 3 so we map it to the first available integer (here 0) and  add it to the mappings. Hence, 10 keeps it's type (here `sage.rings.integer.Integer`), while 9 is of type `int`.
Now, when we add vertex `0`, we are in case 2, and so it will be mapped to 1 and it's type will be `sage.rings.integer.Integer`. It will be the same if we now add vertex `1`...


The motivation of this optimization is to save space and few tests when the user creates vertices in the right order. But above example shows how easy it is to loose this optimization. 

Shouldn't we should simplify the code and use mappings for all vertices ?
It could ease the resolution of issues like in #27037.
