# Issue 25125: Inefficient code in matrix/matrix_space.py

Issue created by migration from Trac.

Original creator: @mr-infty

Original creation time: 2018-05-14 14:12:32

matrix/matrix_space.py (and maybe other modules) use a very inefficient way to check for the presence of object attributes, using try/except. For example, in change_ring you will find:

        try:
            return self.__change_ring[R]
        except AttributeError:
            self.__change_ring = {}
        except KeyError:
            pass

Checking for presence via hasattr() is about 3 times faster, and more idiomatic:

        if hasattr(self, '__change_ring'):
            if R in self.__change_ring:
                return self.__change_ring[R]
        else:
            self.__change_ring = {}


---

Comment by nbruin created at 2018-05-15 00:23:08

The author should probably back this up with an explicit report on how these results were obtained.
For

```
class T(object):
    def __init__(self,a=None,b=None):
        if not(a is None):
            self.a=a
        if not(b is None):
            self.b=b
    def lookup1(self):
        try:
            return self.a
        except AttributeError:
            return self.b
    def lookup2(self):
        if hasattr(self,'a'):
            return self.a
        else:
            return self.b
A=T(a=1)
B=T(b=1)
```

I'm finding:

```
%timeit A.lookup1()
10000000 loops, best of 3: 149 ns per loop
%timeit A.lookup2()
1000000 loops, best of 3: 221 ns per loop
%timeit B.lookup1()
1000000 loops, best of 3: 1.27 Âµs per loop
%timeit B.lookup2()
1000000 loops, best of 3: 550 ns per loop
```

So while the `hasattr` approach is faster than the `try/except` approach for a "miss", the "try/except" wins quite significantly for the "hit". I'm pretty sure the code in question purposefully tries to optimize that scenario.


---

Comment by jdemeyer created at 2018-05-15 05:42:13

I agree. The code in `matrix_space.py` is really doing some kind of caching, where you want to optimize for the case that the object is in the cache.


---

Comment by @mr-infty created at 2018-05-15 13:35:28

sage: class A:
     def f(self, n):
         if hasattr(self, 'l'):
             if n in self.l:
                 return self.l[n]
         else:
             self.l = {}
         self.l[n] = n
         return self.l[n]

sage: class B:
     def f(self, n):
         try:
             return self.l[n]
         except AttributeError:
             self.l = {}
         except KeyError:
             pass
         self.l[n] = n
         return self.l[n]

sage: def test_A():
     a = A()
     for i in range(100000):
         a.f(i)

sage: def test_B():
     b = B()
     for i in range(100000):
         b.f(i)
 
sage: %prun test_A()
         200004 function calls in 0.137 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   100000    0.079    0.000    0.093    0.000 <ipython-input-16-20981c460d4c>:2(f)
        1    0.038    0.038    0.135    0.135 <ipython-input-19-d6eb64cf0a99>:1(test_A)
   100000    0.015    0.000    0.015    0.000 {hasattr}
        1    0.003    0.003    0.003    0.003 {range}
        1    0.002    0.002    0.137    0.137 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

sage: %prun test_B()
         100004 function calls in 0.344 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   100000    0.209    0.000    0.209    0.000 <ipython-input-9-2f6a05f55343>:2(f)
        1    0.130    0.130    0.341    0.341 <ipython-input-18-b50c2c739b46>:1(test_B)
        1    0.003    0.003    0.344    0.344 <string>:1(<module>)
        1    0.003    0.003    0.003    0.003 {range}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}


---

Comment by nbruin created at 2018-05-15 17:11:37

Changing status from new to needs_review.


---

Comment by nbruin created at 2018-05-15 17:11:37

OK, that confirms what I thought. The basic observation mentioned in the ticket is true in one situation: in case of a miss, it's faster to check for the attribute first. However, for the code in question it's more important to optimize for the case of a hit, where try/except wins.

We're thankful to the reporter to look critically at the code. Doing so can uncover problems. In this case it didn't.

If additional data surfaces we can revert the status of this ticket.


---

Comment by vdelecroix created at 2018-05-17 07:12:42

Concerning the ticket, I don't understand why `__change_ring` is not created in the constructor of matrix spaces!

As for your comment, using `try/except` is much faster in case of success than a double lookup with `hasattr`.


---

Comment by vdelecroix created at 2018-05-17 07:12:42

Changing status from needs_review to needs_info.


---

Comment by chapoton created at 2019-09-01 15:55:56

Changing component from PLEASE CHANGE to linear algebra.


---

Comment by chapoton created at 2019-09-01 15:55:56

Changing keywords from "" to "matrix".


---

Comment by nbruin created at 2019-09-01 19:28:03

Replying to [comment:6 vdelecroix]:
> Concerning the ticket, I don't understand why `__change_ring` is not created in the constructor of matrix spaces!

I don't know if it's justified as an optimization, but not allocating and initializing the `__change_ring` attribute [which would probably be a dictionary access, but it could be a slot] saves time when creating matrix spaces. Many matrix spaces never undergo changering operations, so it may well make sense to avoid the initialization overhead in general, at the expense of the special case. Matrices get used A LOT and need to be fast. They also get created of all kinds of different sizes, so creating the parents might happen more than is typical for parents in general.

So: if you want to investigate if it's worth changing this, go ahead, but I'd be very cautious in changing it.
