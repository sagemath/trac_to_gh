# Issue 21211: Avoid underscored arithmetic methods in Python

Issue created by migration from Trac.

Original creator: jdemeyer

Original creation time: 2016-09-08 09:58:33

CC:  nthiery

In plain Python, there is almost never a reason to write `x._add_(y)` since `x + y` is a faster alternative.


---

Comment by jdemeyer created at 2016-09-08 10:30:32

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2016-09-08 10:30:32

Last 10 new commits:


---

Comment by tscrim created at 2016-09-08 14:01:03

This is counterintuitive to me:

> In categories, it is better to write x + y instead of x._add_(y) since the latter can be a lot slower if _add_ is implemented in Cython.

I would think that avoiding the additional call to `__add__` (which does some additional checks) would result in a speed gain. Does this have to do with how cpdef functions are implemented in Cython?


---

Comment by jdemeyer created at 2016-09-08 14:05:49

Rule number 1 of optimizing Python: a method is slow. Almost anything is faster than a method lookup.


---

Comment by jdemeyer created at 2016-09-08 14:13:47

And the call of `x + y` to `x.__add__(y)` is optimized by Python, so it is reasonably fast. Compare:

```
sage: timeit('a + a', number=10^6, repeat=20)
1000000 loops, best of 20: 62.3 ns per loop
sage: timeit('a._add_(a)', number=10^6, repeat=20)
1000000 loops, best of 20: 115 ns per loop
sage: timeit('a.__add__(a)', number=10^6, repeat=20)
1000000 loops, best of 20: 162 ns per loop
```


I don't really have an explanation of why `__add__` is slower than `_add_`, I would have expected them to be equally slow.


---

Comment by jdemeyer created at 2016-09-08 14:15:12

On the topic of methods being slow, note the difference between:

```
sage: a = 1
sage: timeit('parent(a)', number=10^6, repeat=20)
1000000 loops, best of 20: 74.6 ns per loop
sage: timeit('a.parent()', number=10^6, repeat=20)
1000000 loops, best of 20: 93.5 ns per loop
```



---

Comment by nthiery created at 2016-09-08 14:22:24

I checked the diff and it does what the ticket claims.

Just for a complete confirmation, could you post it a new benchmark where the code to be benchmarked is called 100 times in a loop inside a function? Just to make sure that there is no interference from the fact that we are timing at very low granularity.

Once confirmed, you can set a positive review on my behalf.

Thanks!


---

Comment by tscrim created at 2016-09-08 15:03:30

Thank you for the explanations Jeroen!


---

Comment by jdemeyer created at 2016-09-09 08:44:02

I made a benchmark which should be close to possible real-life usage. The conclusion:

With `_add_`: `5 loops, best of 3: 85.2 ms per loop`

With `+`: `5 loops, best of 3: 78.1 ms per loop`


---

Comment by jdemeyer created at 2016-09-09 08:44:17

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2016-09-09 08:45:26

Note that the benchmark also shows that implementing arithmetic in the category is really slow:

With `_add_` implemented in Cython: `125 loops, best of 3: 5.57 ms per loop`

With `_sub_` implemented in the category: `5 loops, best of 3: 78.1 ms per loop`


---

Comment by jdemeyer created at 2016-09-09 08:45:41

Benchmark


---

Comment by vbraun created at 2016-10-03 22:41:46

Resolution: fixed


---

Attachment
