# Issue 27432: fixing an error in shortest_path in c_graph

Issue created by migration from https://trac.sagemath.org/ticket/27669

Original creator: @rajat1433

Original creation time: 2019-04-15 13:16:21

CC:  dcoudert

The algorithm broke many time due to the presence of following bug which is fixed by this ticket.

> {{{#!diff
> -                        next_current.append(v)
> +                        next_temporary.append(v)
>}}}


---

Comment by @rajat1433 created at 2019-04-15 13:19:02

Set assignee to @rajat1433.


---

Comment by git created at 2019-04-15 13:19:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-04-15 13:36:06

can you give an example raising an error ?


---

Comment by @rajat1433 created at 2019-04-15 13:54:48

It will not give wrong results as the next_current list will keep on populating till we reach the target node in bfs but the problem is it will not be the bidirectional bfs as claimed by this method. I used the word broke in ticket description because I was doing some changes and it broke due to this bug. Maybe I will need to modify the ticket description.


---

Comment by dcoudert created at 2019-04-15 14:00:01

Yes, you must explain what's going on and why is this change needed.


---

Comment by @rajat1433 created at 2019-04-15 14:02:17

Changing status from new to needs_review.


---

Comment by dcoudert created at 2019-04-15 14:24:41

Another issue is that list `next_current` is modified inside a `for u in next_current:` loop (see copy/paste below). Clearly not good. So I agree with this change.


```
            for u in next_current:
                if out == 1:
                    neighbors = self._cg.out_neighbors(u)
                elif self._cg_rev is not None: # Sparse
                    neighbors = self._cg_rev.out_neighbors(u)
                else: # Dense
                    neighbors = self._cg.in_neighbors(u)
                for v in neighbors:
                    # If the neighbor is new, updates the distances and adds
                    # to the list.
                    if v not in dist_current:
                        dist_current[v] = dist_current[u] + 1
                        if not distance_flag:
                            pred_current[v] = u
                        next_current.append(v)
```



---

Comment by dcoudert created at 2019-04-15 14:24:41

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2019-04-16 21:20:25

Resolution: fixed
