# Issue 24383: singular fails to build on SunOS

Issue created by migration from https://trac.sagemath.org/ticket/24620

Original creator: jdemeyer

Original creation time: 2018-01-31 06:30:50

CC:  dimpase


```
libtool: compile:  g++ -DHAVE_CONFIG_H -I. -I.. -I.. -I.. -I/var/export/home/jeroen/sage/local/var/tmp/sage/build/singular-4.1.0p3.p1/src -I/var/export/home/jeroen/sage/local/var/tmp/sage/build/singular-4.1.0p3.p1/src/factory/include -I/var/export/home/jeroen/sage/local/var/tmp/sage/build/singular-4.1.0p3.p1/src -I/var/export/home/jeroen/sage/local/var/tmp/sage/build/singular-4.1.0p3.p1/src -I/var/export/home/jeroen/sage/local/include -I/var/export/home/jeroen/sage/local/include -O2 -g -m64 -O2 -g -D_XPG6 -pipe -fno-common -O3 -Wno-unused-function -Wno-trigraphs -Wno-unused-parameter -Wunknown-pragmas -Wno-unused-variable -fomit-frame-pointer -fwrapv -fvisibility=default -finline-functions -fno-exceptions -fno-rtti -fno-threadsafe-statics -fno-enforce-eh-specs -fconserve-space -funroll-loops -fno-delete-null-pointer-checks -MT ffields.lo -MD -MP -MF .deps/ffields.Tpo -c ffields.cc  -fPIC -DPIC -o .libs/ffields.o
ffields.cc: In function 'BOOLEAN nfCoeffIsEqual(coeffs, n_coeffType, void*)':
ffields.cc:809:40: error: call of overloaded 'pow(int&, int&)' is ambiguous
     int c = pow (p->GFChar, p->GFDegree);
                                        ^
In file included from /usr/include/math.h:17:0,
                 from ffields.cc:21:
/usr/include/iso/math_iso.h:199:21: note: candidate: long double std::pow(long double, int)
  inline long double pow(long double __X, int __Y) { return
                     ^
/usr/include/iso/math_iso.h:197:21: note: candidate: long double std::pow(long double, long double)
  inline long double pow(long double __X, long double __Y) { return
                     ^
/usr/include/iso/math_iso.h:166:15: note: candidate: float std::pow(float, int)
  inline float pow(float __X, int __Y) { return
               ^
/usr/include/iso/math_iso.h:161:15: note: candidate: float std::pow(float, float)
  inline float pow(float __X, float __Y) { return __powf(__X, __Y); }
               ^
/usr/include/iso/math_iso.h:141:16: note: candidate: double std::pow(double, int)
  inline double pow(double __X, int __Y) { return
                ^  
/usr/include/iso/math_iso.h:64:15: note: candidate: double std::pow(double, double)
 extern double pow __P((double, double));
```



---

Comment by dimpase created at 2018-01-31 07:51:26

This is interesting; it would be good to understand why I am not seeing this `pow` errors any more...


---

Comment by dimpase created at 2018-01-31 08:09:59

I guess you must be using `gas`, misnamed as `as`. Make sure that the real Sun`as` is first in your path.


---

Comment by jdemeyer created at 2018-01-31 09:08:00

Replying to [comment:3 dimpase]:
> I guess you must be using `gas`, misnamed as `as`. Make sure that the real Sun`as` is first in your path.

Why would the assembler interfere with the compilation of `pow()`? That makes no sense to me.


---

Comment by dimpase created at 2018-01-31 09:10:16

sorry, I meant `ld`...
Anyhow, could you show what you have in $PATH, and in $LD_LIBRARY_PATH.


---

Comment by jdemeyer created at 2018-01-31 09:17:31

Replying to [comment:5 dimpase]:
> sorry, I meant `ld`...

Same comment... Why would the linker interfere with the compilation of `pow()`? That makes no sense to me.


---

Comment by dimpase created at 2018-01-31 09:27:23

There is some kind of caching involved. I just logged in, and (with Solaris `ld`, whether it's relevant or not), it worked:

```
// t.cc
#include <cmath>
int main()
{
// using namespace std;
int i,j,k;
i = 2;
j = 10;
k = pow(i,j);
return k;
}
```

and `g++ t.cc` worked.

But then

```
$ PATH=/opt/csw/gnu:$PATH ld --version
GNU ld (GNU Binutils) 2.24
...
$ PATH=/opt/csw/gnu:$PATH g++ t.cc
t.cc: In function ‘int main()’:
t.cc:8:12: error: call of overloaded ‘pow(int&, int&)’ is ambiguous
...
```


And now going back to the correct linker does not help either.

Anyhow, I have managed to build Singular without any changes to the C++ source few times in row (it needed the linking fixes, but that's another story).


---

Comment by jdemeyer created at 2018-01-31 10:02:47

Replying to [comment:7 dimpase]:
> There is some kind of caching involved.

That would be really surprising.

> I just logged in, and (with Solaris `ld`, whether it's relevant or not), it worked:
> {{{
> // t.cc
> #include <cmath>
> int main()
> {
> // using namespace std;
> int i,j,k;
> i = 2;
> j = 10;
> k = pow(i,j);
> return k;
> }
> }}}
> and `g++ t.cc` worked.

This never worked for me. I get

```
t.cc: In function ‘int main()’:
t.cc:8:12: error: call of overloaded ‘pow(int&, int&)’ is ambiguous
 k = pow(i,j);
            ^
In file included from /usr/include/math.h:17:0,
                 from /usr/gcc/5/include/c++/5.4.0/cmath:44,
                 from t.cc:1:
/usr/include/iso/math_iso.h:199:21: note: candidate: long double std::pow(long double, int)
  inline long double pow(long double __X, int __Y) { return
                     ^
/usr/include/iso/math_iso.h:197:21: note: candidate: long double std::pow(long double, long double)
  inline long double pow(long double __X, long double __Y) { return
                     ^
/usr/include/iso/math_iso.h:166:15: note: candidate: float std::pow(float, int)
  inline float pow(float __X, int __Y) { return
               ^
/usr/include/iso/math_iso.h:161:15: note: candidate: float std::pow(float, float)
  inline float pow(float __X, float __Y) { return __powf(__X, __Y); }
               ^
/usr/include/iso/math_iso.h:141:16: note: candidate: double std::pow(double, int)
  inline double pow(double __X, int __Y) { return
                ^
/usr/include/iso/math_iso.h:64:15: note: candidate: double std::pow(double, double)
 extern double pow __P((double, double));
```



---

Comment by jdemeyer created at 2018-01-31 10:07:04

Replacing `pow` by `std::pow` does work though.


---

Comment by dimpase created at 2018-01-31 10:07:41

One possible explanation is LTO optimisation, coupled (perhaps) with ccache.
You try to compile the example above, and you manage, say, by adding `std::` to `pow`.
This get stored in ccache, and used by the compiler next time to compile the code without that `std::`...


---

Comment by dimpase created at 2018-01-31 10:10:42

Yes, sure, it does work (or `using namespace std;` works too). The real question is whether Singular is adhering to c++11 (or so) standard, or it relies on an old behaviour of C++ which is platform-dependent.


---

Comment by dimpase created at 2018-01-31 10:24:58

Note that http://en.cppreference.com/w/cpp/numeric/math/pow specifically talks about `std::pow`. Without `std::` of `using namespace std;` all bets are off, at least it looks like this to me.


---

Comment by jdemeyer created at 2018-01-31 10:32:53

Replying to [comment:10 dimpase]:
> One possible explanation is LTO optimisation

This error happens before linking. I really don't see how linking could have anything to do with it.

> coupled (perhaps) with ccache.

Are you explicitly using `ccache`? I don't think that it's enabled by default on that machine.

> This get stored in ccache, and used by the compiler next time to compile the code without that `std::`...

ccache wouldn't just ignore "`std::`". The sources with and without `std::` are obviously different.


---

Comment by jdemeyer created at 2018-01-31 10:38:43

Resolution: duplicate


---

Comment by jdemeyer created at 2018-01-31 10:38:43

I'm folding this in #24611.


---

Comment by dimpase created at 2018-01-31 10:44:41

I'm not using `ccache` globally, I'm using it as a Sage package. 

Note that the error messages  `...note: candidate: long double std::pow(...)`, so perhaps it'd willing to consider `int std::pow(...)` if it was in `ccache`.
And it could be that some tests I did where at Sage prompt, thus using `ccache`. (This is just a conjecture of course).
