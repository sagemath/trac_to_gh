# Issue 27121: Memory leak in automorphism groups of abelian groups

Issue created by migration from https://trac.sagemath.org/ticket/27358

Original creator: sbrandhorst

Original creation time: 2019-02-26 10:46:45

CC:  tscrim nbruin jdemeyer


```
sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
....: G = AbelianGroupGap([2,3,4,5])
....: 
sage: aut = G.automorphism_group()
sage: for k in range(100):
....:     s = aut.subgroup([aut.random_element() for k in range(3)])
....:     
sage: st = type(s)
sage: del s,aut,G
sage: import gc
sage: gc.collect()
56
sage: len([v for v in gc.get_objects() if type(v) == st])
100
```



---

Comment by sbrandhorst created at 2019-02-26 10:54:31

After removing `UniqueRepresentation` the memory leak is fixed.

```
sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGr
....: oupGap
....: G = AbelianGroupGap([2,3,4,5])
....: 
sage: aut = G.automorphism_group()
sage: for k in range(100):
....:     s = aut.subgroup([aut.random_element() for k in range(3)])
....:     
sage: st = type(s)
sage: del s,aut,G
sage: import gc
sage: gc.collect()
167
sage: [v for v in gc.get_objects() if type(v) == st]
[]
```


I think that automorphism groups and especially their subgroups
are too complex objects for unique representations. For Abelian groups that may be okay
but certainly in the non-commutative world unique representation does not work and has too little benefit.


---

Comment by sbrandhorst created at 2019-02-26 10:54:52

Changing status from new to needs_review.


---

Comment by sbrandhorst created at 2019-02-26 11:29:49

This comes at the price of pickling. It does not work anymore.
Respectively, unpickling would just create isomorphic objects.
From my point of view we can sacrifice pickling.
With the memory leak the class is unusable for any serious computation.


---

Comment by tscrim created at 2019-02-27 05:16:10

So there is not a memory leak as there is a small cache (I think it is an LRU cache) that goes on that stores 128 objects. If you run it with 200 elements, you will get

```
sage: len([v for v in gc.get_objects() if type(v) == st])
128
```


We can see that there is no memory leak in the code because there is no ``@`cached_method` being used and the data being passed is all 1 directional (i.e., no strong reference cycles). At least, this is my understanding of how things are working.


---

Comment by tscrim created at 2019-02-27 05:16:38

So I am proposing closing this.


---

Comment by sbrandhorst created at 2019-02-27 08:59:50

So an `@`cached_method together with a unique representation would cause memory leaks?


---

Comment by tscrim created at 2019-02-27 09:56:55

Not a ``@`cached_method` in a subclass of `UniqueRepresentation`. But I am pretty sure a ``@`cached_method` that creates a `UniqueRepresentation` `UR` whose input includes `self` ends up being a memory leak (because then `self` is a strong global reference as a key to `UR`, but `UR` has a strong reference being the output of ``@`cached_method`). (This also has a code smell because of the double-caching anyways.)

In some sense a `UniqueRepresentation` and ``@`cached_method` are the same as they use the same mechanism as ``@`cached_function` to store data.


---

Comment by sbrandhorst created at 2019-02-27 10:38:50

thank you for your time. I think I have located my memory leak now:

```
sage: import gc
sage: for k in range(2,400):
....:     m = matrix.diagonal([1,k])
....:     L = IntegralLattice(m)
....:     D = L.discriminant_group()
....:     g = L.orthogonal_group().gen(0)
....:     tmp = D.gen(0)*g;
....:     
sage: gc.collect()
2182
sage: len([v for v in gc.get_objects() if type(v) == type(D)])
514
```

It could be related to the cached method discriminant_group. But the memleak only happens with the action. Maybe I programmed things a bit smelly :-/ .


---

Comment by sbrandhorst created at 2019-02-27 10:54:36

Okay the root cause seems to be somewhere in the coercion system.
And I found a way to release the memory however it seems to me like a bug.

```
sage: for k in range(2,10000):
....:     m = matrix.diagonal([1,k])
....:     L = IntegralLattice(m)
....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)
....:     tmp = L.an_element()*g
sage: import gc
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
9893
sage: gc.collect()
35563
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
9892
sage: cm = sage.structure.element.get_coercion_model()
sage: cm.reset_cache()
sage: gc.collect()
2630471
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
130
```



---

Comment by tscrim created at 2019-02-27 11:07:24

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2019-02-27 11:07:24

Okay, we need to recycle this ticket.

Nils, I am cc-ing you on this ticket because of the memory leak. Jeroen because it might involve the coercion framework.

I wonder if it has something to do with having an action, non-unique parents, but discriminant group being a ``@`cached_method`. It is too late here (Australia) for me to figure out a more minimal example and nothing obvious jumps out at me.


---

Comment by sbrandhorst created at 2019-02-27 16:03:50

It has to do with the action.


---

Comment by sbrandhorst created at 2019-02-27 17:03:02

Here is a fix. 
However, it involves calling the internal method
`sage.structure.parent.Parent._unset_coercions_used`
to be able to register an action. I am unsure of the consequences here.
Is there a better way to tell the coercion model about the action?
----
New commits:


---

Comment by nbruin created at 2019-02-27 20:47:12

You can get a graphical representation of the backref graph:

```
for k in range(2,200):
    m = matrix.diagonal([1,k])
    L = IntegralLattice(m)
    G = L.orthogonal_group([matrix.identity(2)])
    g = G.0
    if k == 2:
        ID=id(G)
    tmp = L.an_element()*g
import gc
gc.collect()
import objgraph #that's a useful package for hunting memory leaks
objgraph.show_backrefs([g for  g in gc.get_objects() if id(g) == ID],max_depth=7).save("graph.dot")
```


It seems that the objects of type `FreeQuadraticModule_integer_symmetric` and `TorsionQuadraticModule` have strong references between each other. Furthermore, the parent of `g` of type`GroupOfIsometries` refers to them via strong links. It also seems that GroupOfIsometries is a construction parameter of some `UniqueRepresentation` object.

There do seem to be reference cycles:
`GroupOfIsometries`->`TripleDict`->`GroupActionOnSubmodule`->`Groupoid_with_category`->`dict`->(back)

The groupoid object is a `UniqueRepresentation` object, so that explains that ref. Since `GroupOfIsometries` ends up having a strong reference to the groupoid, this would nail things in memory: The `GroupOfIsometries` object is kept alive for as long as the groupoid exists because it's a construction parameter for it. The groupoid object is kept alive by the `GroupOfIsometries`. Hence a memory leak. There could be other, but this is definitely one.


---

Comment by tscrim created at 2019-02-27 22:44:42

Thank you for the analysis Nils and the `objgraph` example (I didn't know about that...or I forgot `>_<`).

Most of that reference cycle feels completely natural. We want the groupoid to be the category for the action and it makes sense for that to be a unique representation. The groupoid has to refer back to the set it acts on. The `GroupOfIsometries` `G` creates the `GroupActionOnSubmodule`, which has to refer to `G`, but that is an arrow going in the opposite direction. I believe that `TripleDict` ref inserted in there is coming from the coercion model via a call to `_get_action_`, which seems to be the cause of the problem. At least, I do not see where in `groups/matrix_gps/isometries.py` that would come from otherwise.


---

Comment by tscrim created at 2019-02-27 22:57:28

I really do not see where the strong reference `GroupOfIsometries`->`TripleDict` comes from. I understand the `TripleDict` is the `_action_maps` in the coercion model, which has `GroupOfIsometries` as a key, so the ref should go the other direction and break the cycle. Althou ingh even if it did go the other way, there would still be a strong ref to `GroupOfIsometries` that would not be able to be removed, which would keep it as a key in the `TripleDict`.

Actually, I do not see how this is not a problem for _any_ `Action`.


---

Comment by nbruin created at 2019-02-28 00:26:04

There's another `TripleDict()`: an attribute `_action_hash` on `Parent` objects. That's the only candidate for the link `GroupOfIsometries -> TripleDict`.

It is indeed the case that actions tend to tie together lifetimes of objects involved. That's indeed not unnatural. Normally, if both group and acted-up-set lose all references, the cyclic garbage collector would be able to discard the cycle. The problem I see is that the `UniqueRepresentation` cache maintains an outside reference to the cycle: to the `GroupOfIsometries` object to be precise. This cache is guarded by a weakref to the groupoid object. However, the groupoid object is kept alive because the `_action_hash` on `GroupOfIsometries` linking to it.

If the `UniqueRepresentation` cache were not keyed by the `GroupOfIsometries` object, this cycle would not cause a memory leak.

Another way would be to not cache the groupoid on `GroupOfIsometries`. This groupoid can be recovered from the `GroupOfIsometries` via the `UniqueRepresentation` cache, after all. I expect that would be very detrimental to performance, though. Plus, while we have identified this one cycle here, there could easily be another one.

It is a little strange that `search_src("_action_hash")` doesn't find any lines where the attribute actually gets used. Do we not use this anymore for action discovery?


---

Comment by tscrim created at 2019-02-28 01:39:29

Ah, I missed that on `Parent`, good catch. I agree with you about the `_action_hash` being strange outright, but on a second thought and this comment in `parent.pxd`, I think it serves a purpose:

```
    # Write-only hashtable of all actions discovered using this parent.
    # This is only needed to keep a strong reference to actions, to
    # prevent them being garbage collected prematurely.
    cdef TripleDict _action_hash
```

Mainly without it, the action object (e.g., `GroupActionOnSubmodule`) would have no strong reference to it, so the action would be garbage collected, which means the corresponding key in `_action_maps` would then go too.

Interestingly, merely asking for the action is not causing a memory leak:

```
sage: for k in range(2,1000):
....:     m = matrix.diagonal([1,k])
....:     L = IntegralLattice(m)
....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)
....:     A = coercion_model.discover_action(L, g.parent(), operator.mul)
....:     
sage: import gc
sage: gc.collect()
29408
sage: gc.collect()
7
sage: len([v for v in gc.get_objects() if type(v) == type(A)])
2
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
122
```



---

Comment by tscrim created at 2019-02-28 01:48:21

My understanding is that by creating the action, we are creating that cycle. So it is still apparently able to be collected. It is only when we actually multiply the elements that something changes. Maybe something also with checking for coercions?


---

Comment by tscrim created at 2019-02-28 01:49:36

Also, explicitly invoking `A.act(g, L.an_element())` does not nail things in memory.


---

Comment by tscrim created at 2019-02-28 02:01:19

The test I wrote in comment:19 does is slightly different as `coercion_model.get_action` runs `Parent.get_action`, which does not put the action into the `_action_maps` `TripleDict`. Although I do believe the cycle mentioned in comment:15 is getting created, and it is that `coercion_model._action_maps` that nails it in memory.


---

Comment by tscrim created at 2019-02-28 02:08:14

Here is another example of the same memory leak with `Action`:

```sage
for p in primes(10000):
   F = GF(p)
   M = MatrixSpace(F, 2)
   V = F^2
    _ = M.one() * V.zero()
```


```
sage: import gc
sage: gc.collect()
14
sage: gc.collect()
7
sage: len([v for v in gc.get_objects() if type(v) == type(V)])
1229
sage: len(list(primes(10000)))
1229
```

So it is a much more pervasive problem than in this particular example (really any nontrivial `Action`).


---

Comment by tscrim created at 2019-02-28 02:20:05

Hmm...the leak in comment:23 might be a different issue as when I run

```
sage: for p in primes(10000):
....:     F = GF(p)
....:     M = MatrixSpace(F, 2)
....:     V = F^2
....:     A = coercion_model.discover_action(V, M, operator.mul)
sage: import gc
sage: gc.collect()
116
sage: gc.collect()
7
sage: len([v for v in gc.get_objects() if type(v) == type(F)])
1229
sage: coercion_model._action_maps[M, V, operator.mul]
...
Key Error: ...
```


Then again, this might be an (the?) underlying problem as the for the matrix group goes through this...


---

Comment by sbrandhorst created at 2019-03-05 23:50:51

commenting out  

```
#self._action_hash.set(S, op, self_on_left, action)
```

and using

```
sage: cm = sage.structure.element.get_coercion_model()
sage: cm.reset_cache()
```

allows things to be collected.


---

Comment by tscrim created at 2019-03-07 02:36:32

Thinking more about this, there are two separate issues.

1 - Mathematical: An action of a  does not have to form a groupoid (i.e., they are not invertible in general). So technically actions should be endofunctors on a small category. However, this is not a technical challenge, just an (slight) abuse of terminology.

2 - Reference cycles: I looked at comment:24 with `objgraph`, and it is fundamentally the same cycle, just a bit tighter: `MatrixSpace` -> `VectorMatrixAction` -> `Groupoid` -> `dict` -> back. Now even if we fix 1 (which could be as simple as changing the name of the `Groupoid` class), that still leaves us with this extremely natural reference cycle. So perhaps the most natural way out is to make the category not a `UniqueRepresentation`. Another thought would be for a `Groupoid` to only hold a weak references to its defining group (both as `self.__G` and in its construction key). Even doing that, there still is a problem of `VectorMatrixAction` -> `MatrixSpace` -> `TripleDict` -> back.

I do not get why actions are treated differently than coercions. Coercions only keep their codomains as strong references (the reasoning as I understand it is that if you are acting by something in the domain, you likely have that domain as an explicit reference). So why are we having a strong reference to the actor (analogous to the domain) and not the set (the codomain)? Perhaps for actions in general, the proper thing to do is have weak references to both the actor and the set.

I suspect we need to take this discussion to sage-devel as this might involve a major change in how we handle references with actions, as well as caching parameters for categories.


---

Comment by sbrandhorst created at 2019-03-08 09:16:13

Go ahead.


---

Comment by mkoeppe created at 2020-05-01 04:28:42

Moving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
