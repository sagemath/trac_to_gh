# Issue 18796: RIF/CIF: search and subintervals by a bisection-algorithm

Issue created by migration from https://trac.sagemath.org/ticket/19033

Original creator: dkrenn

Original creation time: 2015-08-14 14:17:10

CC:  cheuberg

This ticket implements a bisection algorithm used with interval field elements.


---

Comment by dkrenn created at 2015-08-14 14:17:46

New commits:


---

Comment by dkrenn created at 2015-08-14 14:17:46

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2015-08-14 15:03:35

Hello Daniel,

This is cool!

I guess that the line

```
verbose('iteration %s with results in %s of %s cells' %
   (iteration, len(result), len(open)), level=2)
```

is quite bad for performances. The string formatting is done whatever the verbose function is doing. Did you do some profiling?

Just for curiosity, do you know how good is `fast_callable` with interval fields? It looks pretty bad on the following example

```
sage: f(x) = log(exp(x*sin(x)) + exp(x*cos(x)))
sage: F = fast_callable(f, domain=RIF)
sage: r = RIF(0.1,0.2)
sage: %timeit F(r)
10000 loops, best of 3: 54.6 µs per loop
sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()
10000 loops, best of 3: 32.8 µs per loop
```

compared to reals

```
sage: F = fast_callable(f, domain=RR)
sage: r = 0.1
sage: %timeit F(r)
100000 loops, best of 3: 12.4 µs per loop
sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()
10000 loops, best of 3: 16.5 µs per loop
```


Vincent


---

Comment by dkrenn created at 2015-08-14 15:09:32

Hi Vincent,

Replying to [comment:3 vdelecroix]:
> I guess that the line
> {{{
> verbose('iteration %s with results in %s of %s cells' %
>    (iteration, len(result), len(open)), level=2)
> }}}
> is quite bad for performances. The string formatting is done whatever the verbose function is doing. > Did you do some profiling?

No, I didn't do any with this line included (I did on my old code, which used if and print für debugging).

> Just for curiosity, do you know how good is `fast_callable` with interval fields? 

Don't know. I used it with some larger symbolic expressions, and what I remember, I had a significant speedup there.

> It looks pretty bad on the following example
> {{{
> sage: f(x) = log(exp(x*sin(x)) + exp(x*cos(x)))
> sage: F = fast_callable(f, domain=RIF)
> sage: r = RIF(0.1,0.2)
> sage: %timeit F(r)
> 10000 loops, best of 3: 54.6 µs per loop
> sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()
> 10000 loops, best of 3: 32.8 µs per loop
> }}}
> compared to reals
> {{{
> sage: F = fast_callable(f, domain=RR)
> sage: r = 0.1
> sage: %timeit F(r)
> 100000 loops, best of 3: 12.4 µs per loop
> sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()
> 10000 loops, best of 3: 16.5 µs per loop
> }}}

Not so good...

Any suggestions on the bisect-code using fast_callable?

Daniel


---

Comment by vdelecroix created at 2015-08-14 15:49:31

Replying to [comment:4 dkrenn]:
> Hi Vincent,
> 
> Replying to [comment:3 vdelecroix]:
> > I guess that the line
> > {{{
> > verbose('iteration %s with results in %s of %s cells' %
> >    (iteration, len(result), len(open)), level=2)
> > }}}
> > is quite bad for performances. The string formatting is done whatever the verbose function is doing. > Did you do some profiling?
> 
> No, I didn't do any with this line included (I did on my old code, which used if and print für debugging).

If you really want these verbose you should use lazy formatting. I do not remember what is the state of the art, but you can have a look at `sage.misc.lazy_string` and `sage.misc.lazy_format`. But you are really creating a string within the critical loop. I do find it not very reasonable (the other is fine though).

> > Just for curiosity, do you know how good is `fast_callable` with interval fields? 
> 
> Don't know. I used it with some larger symbolic expressions, and what I remember, I had a significant speedup there.

I am pretty sure that `fast_callable` is better than symbolic and you seem to confirm that. However, you can see in my small snippet above that `fast_callable` looks worse than using Python. I should try on a larger expression but then you have to translate into an object call oriented expression and I am lazy...

> Any suggestions on the bisect-code using fast_callable?

Check what `fast_callable` is doing with `domain=RIF` and `domain=CIF` (quickly looking at `ext/fast_callable.pyx` I would say nothing). It can be done independently of this ticket.

Other comments:

- What is your variable `result` for?

- did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.


---

Comment by git created at 2015-08-15 10:29:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-08-15 10:42:40

Replying to [comment:5 vdelecroix]:
> - What is your variable `result` for?

It collects the already finished cells. I've rewritten the code and introduced a new option (this was already there in a pre-version of this code).


---

Comment by chapoton created at 2015-09-01 08:49:19

Bad syntax for `INPUT::`, it should be `INPUT:`


---

Comment by git created at 2015-09-02 14:00:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-09-02 14:02:04

Replying to [comment:5 vdelecroix]:
> If you really want these verbose you should use lazy formatting. I do not remember what is the state of the art, but you can have a look at `sage.misc.lazy_string` and `sage.misc.lazy_format`. But you are really creating a string within the critical loop. I do find it not very reasonable (the other is fine though).

LazyFormat did not bring something on the performance. Now checking verbosity level directly; this is faster now.


---

Comment by dkrenn created at 2015-09-02 14:02:45

Replying to [comment:5 vdelecroix]:
> - did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.

Done. Is faster now.


---

Comment by dkrenn created at 2015-09-02 14:03:28

Replying to [comment:8 chapoton]:
> Bad syntax for `INPUT::`, it should be `INPUT:`

Corrected. Also fixed some broken links in the files (in existing code).

Again, needs_review :)


---

Comment by jdemeyer created at 2015-10-14 11:39:58

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2015-10-14 11:39:58

Unless I'm missing something, the case `f is None` is completely undocumented and untested.


---

Comment by jdemeyer created at 2015-10-14 11:41:01

Also, I guess the test is meant to satisfy the assumption that if an interval `A` passes, any interval containing `A` should also pass. This should be documented.


---

Comment by jdemeyer created at 2015-10-14 13:15:28

Another detail: you can replace

```
from sage.rings.real_mpfi import bisect
return bisect(f, self, test, **kwds)
```

by

```
return real_mpfi.bisect(f, self, test, **kwds)
```



---

Comment by jdemeyer created at 2015-10-14 13:34:35

Replying to [comment:5 vdelecroix]:
> - did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.

I agree, there should be a lot more typing. All variables which are boolean should be typed `bint` and all integers a suitable integer type (`Py_ssize_t` for lengths).


---

Comment by git created at 2015-10-18 11:38:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-10-18 11:39:19

Replying to [comment:13 jdemeyer]:
> Unless I'm missing something, the case `f is None` is completely undocumented and untested.

Is now removed (since not needed).


---

Comment by dkrenn created at 2015-10-18 11:39:36

Replying to [comment:14 jdemeyer]:
> Also, I guess the test is meant to satisfy the assumption that if an interval `A` passes, any interval containing `A` should also pass. This should be documented.

I've added a note block explaining this.


---

Comment by dkrenn created at 2015-10-18 11:39:56

Replying to [comment:15 jdemeyer]:
> Another detail: you can replace
> {{{
> from sage.rings.real_mpfi import bisect
> return bisect(f, self, test, **kwds)
> }}}
> by
> {{{
> return real_mpfi.bisect(f, self, test, **kwds)
> }}}

Done.


---

Comment by dkrenn created at 2015-10-18 11:41:49

Replying to [comment:16 jdemeyer]:
> Replying to [comment:5 vdelecroix]:
> > - did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.
> 
> I agree, there should be a lot more typing. All variables which are boolean should be typed `bint` and all integers a suitable integer type (`Py_ssize_t` for lengths).

I've added `cdef bint success`; this saves about 5 percent in time in my tested examples. I've tried to add `Py_ssize_t` and other `bint`...it does not seem that this brought something. Maybe I am using it wrong...


---

Comment by dkrenn created at 2015-10-18 11:43:15

I've also merged in 6.9 (I am sorry for this, since it was not needed, but I didn't have the previous version available and did not want to want until it was compiled).

Set it back to needs_review.


---

Comment by dkrenn created at 2015-10-18 11:43:15

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2015-10-18 15:50:43

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2015-10-18 15:50:43

one failing doctest


---

Comment by git created at 2015-10-18 16:28:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-18 16:30:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-10-18 16:35:43

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2015-10-18 16:35:43

Replying to [comment:23 chapoton]:
> one failing doctest

Was not there on 6.9.

Merged 6.10.beta0 and reverted the changes from comment 15 of this ticket (change of imports). Back to needs_review.


---

Comment by git created at 2016-02-16 08:45:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2016-02-16 08:45:50

Merged 7.1.beta3.


---

Comment by chapoton created at 2016-02-23 08:38:01

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2016-02-23 08:38:01

does not apply


---

Comment by git created at 2016-02-23 09:06:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2016-02-23 09:06:58

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2016-02-23 09:06:58

Replying to [comment:29 chapoton]:
> does not apply

Merged in 7.1.beta4.


---

Comment by chapoton created at 2018-02-19 07:10:55

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2018-02-19 07:10:55

does not apply


---

Comment by vdelecroix created at 2018-02-19 07:36:24

Note that arb already offers a bissection/newton scheme for root finding of analytic functions, see [arb_calc](http://arblib.org/arb_calc.html).


---

Comment by git created at 2019-03-27 16:54:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2019-03-27 16:54:45

Replying to [comment:33 vdelecroix]:
> Note that arb already offers a bissection/newton scheme for root finding of analytic functions, see [arb_calc](http://arblib.org/arb_calc.html).

Good to know, thanks.


---

Comment by dkrenn created at 2019-03-27 16:57:22

Merged in 8.6, so back to needs review again.

When I see this correctly, all comments given on this ticket so far have been incorporated or answered, but noone gave a positive review three years ago.....I guess, however, we are close to a positive review after all. Can someone have a look again, please.


---

Comment by dkrenn created at 2019-03-27 16:57:22

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2019-03-31 16:51:39

[comment:15] is not addressed. `real_mpfi` is already globally cimported in `complex_interval.pyx`.


---

Comment by vdelecroix created at 2019-03-31 17:08:58

I don't think that "bisection on success"/"bisection on failure" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:
- prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)
- prove that a cell does not contain a zero (if `f(cell)` does not contain zero)
In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.

I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.

Also, isolating roots in an example such as

```
sage: def contains_zero(fct, cell):
....:     return fct(cell).contains_zero()
sage: result = bisect(lambda x: x^3-4*x+2, RIF(-10, 10), contains_zero)
```

would be faster since you would not refine the already valid cells.


---

Comment by vdelecroix created at 2019-03-31 17:11:39

(for all this, you should have a look at `arb_calc_isolate_roots` that was already mentioned)


---

Comment by vdelecroix created at 2019-03-31 17:13:00

The following is a big waste.

```
if join_neighboring_cells:
     verbose('joining neighboring cells...', level=1)
     cells = result
     result = []

     while len(cells) > 0:
         joined = cells.pop(0)
         k = 0
         while k < len(cells):
             try:
                 joined.intersection(cells[k])
             except ValueError:
                 k += 1
             else:
                 joined = joined.union(cells.pop(k))
         result.append(joined)
```

The intervals should be stored in order (a binary tree seems the most appropriate).


---

Comment by vdelecroix created at 2019-03-31 17:13:35

Changing status from needs_review to needs_work.


---

Comment by dkrenn created at 2019-04-02 13:13:33

Replying to [comment:38 vdelecroix]:
> [comment:15] is not addressed. `real_mpfi` is already globally cimported in `complex_interval.pyx`.

Doesn't work:

```
        return real_mpfi.bisect(f, self, test, **kwds)
                       ^
------------------------------------------------------------

sage/rings/complex_interval.pyx:2201:24: cimported module has no attribute 'bisect'
```



---

Comment by dkrenn created at 2019-04-02 13:32:23

Replying to [comment:39 vdelecroix]:
> I don't think that "bisection on success"/"bisection on failure" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:
> - prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)
> - prove that a cell does not contain a zero (if `f(cell)` does not contain zero)
> In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.
> 
> I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.

I agree that at some point this would be an extension to do. However, I think that it should not be now and that the current implementation has its advantages:

- The test at the moment is compatible and in the sense as comparisons etc. work in RIF/CIF:
  {{{
  sage: RIF(1,3) < RIF(2,4)
  False
  }}}
  returns `True/False` and not unknown. I think there were a lot of discussions going on about this during Py3 comparison discussions. Apparently this is still so in SageMath, so this should be done consistently in all of the module.

- It is easy to use in the sense what the input test-function should be/return and what the result of `bisect` will be. Therefore this function is suitable for the end user; one main goal of this function.

- The proposed change has a different result; see below.

> Also, isolating roots in an example such as
> {{{
> sage: def contains_zero(fct, cell):
> ....:     return fct(cell).contains_zero()
> sage: result = bisect(lambda x: x^3-4*x+2, RIF(-10, 10), contains_zero)
> }}}
> would be faster since you would not refine the already valid cells.

Faster yes, but gives a different result. The current implementation results in small intervals that satisfy the condition, whereas your proposed solution would find some possible large intervals. One could, of course, do this by the proposed functionality, but rather complicated by searching for the inverse and then inverting the result again, which speaks against the simplicity in usage.


---

Comment by dkrenn created at 2019-04-02 13:33:45

Replying to [comment:41 vdelecroix]:
> The following is a big waste.
> {{{
> if join_neighboring_cells:
>      verbose('joining neighboring cells...', level=1)
>      cells = result
>      result = []
> 
>      while len(cells) > 0:
>          joined = cells.pop(0)
>          k = 0
>          while k < len(cells):
>              try:
>                  joined.intersection(cells[k])
>              except ValueError:
>                  k += 1
>              else:
>                  joined = joined.union(cells.pop(k))
>          result.append(joined)
> }}}
> The intervals should be stored in order (a binary tree seems the most appropriate).

This can only be simplified if we talk about real intervals, but not if we talk about complex intervals, or do I miss something here?


---

Comment by dkrenn created at 2019-04-02 13:33:51

Changing status from needs_work to needs_info.


---

Comment by vdelecroix created at 2019-04-02 13:52:24

Replying to [comment:45 dkrenn]:
> Replying to [comment:41 vdelecroix]:
> > The following is a big waste.
> > {{{
> > if join_neighboring_cells:
> >      verbose('joining neighboring cells...', level=1)
> >      cells = result
> >      result = []
> > 
> >      while len(cells) > 0:
> >          joined = cells.pop(0)
> >          k = 0
> >          while k < len(cells):
> >              try:
> >                  joined.intersection(cells[k])
> >              except ValueError:
> >                  k += 1
> >              else:
> >                  joined = joined.union(cells.pop(k))
> >          result.append(joined)
> > }}}
> > The intervals should be stored in order (a binary tree seems the most appropriate).
> 
> This can only be simplified if we talk about real intervals, but not if we talk about complex intervals, or do I miss something here?

Indeed. For complex intervals you want a quad-tree not a binary tree.


---

Comment by vdelecroix created at 2019-04-02 14:01:37

Replying to [comment:44 dkrenn]:
> Replying to [comment:39 vdelecroix]:
> > I don't think that "bisection on success"/"bisection on failure" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:
> > - prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)
> > - prove that a cell does not contain a zero (if `f(cell)` does not contain zero)
> > In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.
> > 
> > I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.
> 
> I agree that at some point this would be an extension to do.

Good. Then it shoud be clear that all the functionalities will be forward compatible.

> However, I think that it should not be now and that the current implementation has its advantages:
> 
> - The test at the moment is compatible and in the sense as comparisons etc. work in RIF/CIF:
>   {{{
>   sage: RIF(1,3) < RIF(2,4)
>   False
>   }}}
>   returns `True/False` and not unknown. I think there were a lot of discussions going on about this during Py3 comparison discussions. Apparently this is still so in SageMath, so this should be done consistently in all of the module.

The workaround is very simple

```
sage: def is_really_less_than(a,b):
....:     if a < b: return True
....:     elif b <= a: return False
....:     else: return Unknown
sage: is_really_less_than(RIF(1,2), RIF(3,4))
True
sage: is_really_less_than(RIF(1,3), RIF(2,4))
Unknown
```


> - It is easy to use in the sense what the input test-function should be/return and what the result of `bisect` will be. Therefore this function is suitable for the end user; one main goal of this function.
> 
> - The proposed change has a different result; see below.
> 
> > Also, isolating roots in an example such as
> > {{{
> > sage: def contains_zero(fct, cell):
> > ....:     return fct(cell).contains_zero()
> > sage: result = bisect(lambda x: x^3-4*x+2, RIF(-10, 10), contains_zero)
> > }}}
> > would be faster since you would not refine the already valid cells.
> 
> Faster yes, but gives a different result. The current implementation results in small intervals that satisfy the condition, whereas your proposed solution would find some possible large intervals. One could, of course, do this by the proposed functionality, but rather complicated by searching for the inverse and then inverting the result again, which speaks against the simplicity in usage.

When roots are isolated you typically switch to something else. If you know that f has a unique root in [0,1] you would not implement the bisection the way this function proceed. Moreover, if you want really small intervals, Newton method is better suited. So the fact that the code in the current branch does more than the minimum amount of work is a downside to me.


---

Comment by dkrenn created at 2019-04-02 14:13:19

Replying to [comment:48 vdelecroix]:
> Replying to [comment:44 dkrenn]:
> > Faster yes, but gives a different result. The current implementation results in small intervals that satisfy the condition, whereas your proposed solution would find some possible large intervals. One could, of course, do this by the proposed functionality, but rather complicated by searching for the inverse and then inverting the result again, which speaks against the simplicity in usage.
> 
> When roots are isolated you typically switch to something else. If you know that f has a unique root in [0,1] you would not implement the bisection the way this function proceed. Moreover, if you want really small intervals, Newton method is better suited. So the fact that the code in the current branch does more than the minimum amount of work is a downside to me.

Newton can only be done if the function is differentiable, which is not assumed by the current implementation.


---

Comment by dkrenn created at 2019-04-02 14:37:45

Replying to [comment:47 vdelecroix]:
> Replying to [comment:45 dkrenn]:
> > Replying to [comment:41 vdelecroix]:
> > > The following is a big waste.
> > > {{{
> > > if join_neighboring_cells:
> > >      verbose('joining neighboring cells...', level=1)
> > >      cells = result
> > >      result = []
> > > 
> > >      while len(cells) > 0:
> > >          joined = cells.pop(0)
> > >          k = 0
> > >          while k < len(cells):
> > >              try:
> > >                  joined.intersection(cells[k])
> > >              except ValueError:
> > >                  k += 1
> > >              else:
> > >                  joined = joined.union(cells.pop(k))
> > >          result.append(joined)
> > > }}}
> > > The intervals should be stored in order (a binary tree seems the most appropriate).
> > 
> > This can only be simplified if we talk about real intervals, but not if we talk about complex intervals, or do I miss something here?
> 
> Indeed. For complex intervals you want a quad-tree not a binary tree.

Follow-up ticket #27595.


---

Comment by dkrenn created at 2019-04-02 14:41:39

Replying to [comment:48 vdelecroix]:
> Replying to [comment:44 dkrenn]:
> > Replying to [comment:39 vdelecroix]:
> > > I don't think that "bisection on success"/"bisection on failure" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:
> > > - prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)
> > > - prove that a cell does not contain a zero (if `f(cell)` does not contain zero)
> > > In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.
> > > 
> > > I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.
> > 
> > I agree that at some point this would be an extension to do.
> 
> Good. Then it shoud be clear that all the functionalities will be forward compatible.

After all, this might be difficult, as already the output and the desired functionality seems to be different in our two cases. Do you have something particular in mind here?


---

Comment by embray created at 2019-06-14 14:50:27

Tickets still needing working or clarification should be moved to the next release milestone at the soonest (please feel free to revert if you think the ticket is close to being resolved).


---

Comment by embray created at 2019-12-30 14:48:17

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by mkoeppe created at 2021-12-18 19:53:12

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.
