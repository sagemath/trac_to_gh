# Issue 18796: RIF/CIF: search and subintervals by a bisection-algorithm

archive/issues_018796.json:
```json
{
    "body": "CC:  @cheuberg\n\nThis ticket implements a bisection algorithm used with interval field elements.\n\nIssue created by migration from https://trac.sagemath.org/ticket/19033\n\n",
    "created_at": "2015-08-14T14:17:10Z",
    "labels": [
        "numerical",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "RIF/CIF: search and subintervals by a bisection-algorithm",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18796",
    "user": "@dkrenn"
}
```
CC:  @cheuberg

This ticket implements a bisection algorithm used with interval field elements.

Issue created by migration from https://trac.sagemath.org/ticket/19033





---

archive/issue_comments_256967.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-08-14T14:17:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256967",
    "user": "@dkrenn"
}
```

New commits:



---

archive/issue_comments_256968.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-08-14T14:17:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256968",
    "user": "@dkrenn"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_256969.json:
```json
{
    "body": "Hello Daniel,\n\nThis is cool!\n\nI guess that the line\n\n```\nverbose('iteration %s with results in %s of %s cells' %\n   (iteration, len(result), len(open)), level=2)\n```\n\nis quite bad for performances. The string formatting is done whatever the verbose function is doing. Did you do some profiling?\n\nJust for curiosity, do you know how good is `fast_callable` with interval fields? It looks pretty bad on the following example\n\n```\nsage: f(x) = log(exp(x*sin(x)) + exp(x*cos(x)))\nsage: F = fast_callable(f, domain=RIF)\nsage: r = RIF(0.1,0.2)\nsage: %timeit F(r)\n10000 loops, best of 3: 54.6 \u00b5s per loop\nsage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()\n10000 loops, best of 3: 32.8 \u00b5s per loop\n```\n\ncompared to reals\n\n```\nsage: F = fast_callable(f, domain=RR)\nsage: r = 0.1\nsage: %timeit F(r)\n100000 loops, best of 3: 12.4 \u00b5s per loop\nsage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()\n10000 loops, best of 3: 16.5 \u00b5s per loop\n```\n\n\nVincent",
    "created_at": "2015-08-14T15:03:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256969",
    "user": "@videlec"
}
```

Hello Daniel,

This is cool!

I guess that the line

```
verbose('iteration %s with results in %s of %s cells' %
   (iteration, len(result), len(open)), level=2)
```

is quite bad for performances. The string formatting is done whatever the verbose function is doing. Did you do some profiling?

Just for curiosity, do you know how good is `fast_callable` with interval fields? It looks pretty bad on the following example

```
sage: f(x) = log(exp(x*sin(x)) + exp(x*cos(x)))
sage: F = fast_callable(f, domain=RIF)
sage: r = RIF(0.1,0.2)
sage: %timeit F(r)
10000 loops, best of 3: 54.6 µs per loop
sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()
10000 loops, best of 3: 32.8 µs per loop
```

compared to reals

```
sage: F = fast_callable(f, domain=RR)
sage: r = 0.1
sage: %timeit F(r)
100000 loops, best of 3: 12.4 µs per loop
sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()
10000 loops, best of 3: 16.5 µs per loop
```


Vincent



---

archive/issue_comments_256970.json:
```json
{
    "body": "Hi Vincent,\n\nReplying to [comment:3 vdelecroix]:\n> I guess that the line\n> {{{\n> verbose('iteration %s with results in %s of %s cells' %\n>    (iteration, len(result), len(open)), level=2)\n> }}}\n> is quite bad for performances. The string formatting is done whatever the verbose function is doing. > Did you do some profiling?\n\nNo, I didn't do any with this line included (I did on my old code, which used if and print f\u00fcr debugging).\n\n> Just for curiosity, do you know how good is `fast_callable` with interval fields? \n\nDon't know. I used it with some larger symbolic expressions, and what I remember, I had a significant speedup there.\n\n> It looks pretty bad on the following example\n> {{{\n> sage: f(x) = log(exp(x*sin(x)) + exp(x*cos(x)))\n> sage: F = fast_callable(f, domain=RIF)\n> sage: r = RIF(0.1,0.2)\n> sage: %timeit F(r)\n> 10000 loops, best of 3: 54.6 \u00b5s per loop\n> sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()\n> 10000 loops, best of 3: 32.8 \u00b5s per loop\n> }}}\n> compared to reals\n> {{{\n> sage: F = fast_callable(f, domain=RR)\n> sage: r = 0.1\n> sage: %timeit F(r)\n> 100000 loops, best of 3: 12.4 \u00b5s per loop\n> sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()\n> 10000 loops, best of 3: 16.5 \u00b5s per loop\n> }}}\n\nNot so good...\n\nAny suggestions on the bisect-code using fast_callable?\n\nDaniel",
    "created_at": "2015-08-14T15:09:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256970",
    "user": "@dkrenn"
}
```

Hi Vincent,

Replying to [comment:3 vdelecroix]:
> I guess that the line
> {{{
> verbose('iteration %s with results in %s of %s cells' %
>    (iteration, len(result), len(open)), level=2)
> }}}
> is quite bad for performances. The string formatting is done whatever the verbose function is doing. > Did you do some profiling?

No, I didn't do any with this line included (I did on my old code, which used if and print für debugging).

> Just for curiosity, do you know how good is `fast_callable` with interval fields? 

Don't know. I used it with some larger symbolic expressions, and what I remember, I had a significant speedup there.

> It looks pretty bad on the following example
> {{{
> sage: f(x) = log(exp(x*sin(x)) + exp(x*cos(x)))
> sage: F = fast_callable(f, domain=RIF)
> sage: r = RIF(0.1,0.2)
> sage: %timeit F(r)
> 10000 loops, best of 3: 54.6 µs per loop
> sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()
> 10000 loops, best of 3: 32.8 µs per loop
> }}}
> compared to reals
> {{{
> sage: F = fast_callable(f, domain=RR)
> sage: r = 0.1
> sage: %timeit F(r)
> 100000 loops, best of 3: 12.4 µs per loop
> sage: %timeit ((r*r.sin()).exp() + (r*r.cos()).exp()).log()
> 10000 loops, best of 3: 16.5 µs per loop
> }}}

Not so good...

Any suggestions on the bisect-code using fast_callable?

Daniel



---

archive/issue_comments_256971.json:
```json
{
    "body": "Replying to [comment:4 dkrenn]:\n> Hi Vincent,\n> \n> Replying to [comment:3 vdelecroix]:\n> > I guess that the line\n> > {{{\n> > verbose('iteration %s with results in %s of %s cells' %\n> >    (iteration, len(result), len(open)), level=2)\n> > }}}\n> > is quite bad for performances. The string formatting is done whatever the verbose function is doing. > Did you do some profiling?\n> \n> No, I didn't do any with this line included (I did on my old code, which used if and print f\u00fcr debugging).\n\nIf you really want these verbose you should use lazy formatting. I do not remember what is the state of the art, but you can have a look at `sage.misc.lazy_string` and `sage.misc.lazy_format`. But you are really creating a string within the critical loop. I do find it not very reasonable (the other is fine though).\n\n> > Just for curiosity, do you know how good is `fast_callable` with interval fields? \n> \n> Don't know. I used it with some larger symbolic expressions, and what I remember, I had a significant speedup there.\n\nI am pretty sure that `fast_callable` is better than symbolic and you seem to confirm that. However, you can see in my small snippet above that `fast_callable` looks worse than using Python. I should try on a larger expression but then you have to translate into an object call oriented expression and I am lazy...\n\n> Any suggestions on the bisect-code using fast_callable?\n\nCheck what `fast_callable` is doing with `domain=RIF` and `domain=CIF` (quickly looking at `ext/fast_callable.pyx` I would say nothing). It can be done independently of this ticket.\n\nOther comments:\n\n- What is your variable `result` for?\n\n- did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.",
    "created_at": "2015-08-14T15:49:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256971",
    "user": "@videlec"
}
```

Replying to [comment:4 dkrenn]:
> Hi Vincent,
> 
> Replying to [comment:3 vdelecroix]:
> > I guess that the line
> > {{{
> > verbose('iteration %s with results in %s of %s cells' %
> >    (iteration, len(result), len(open)), level=2)
> > }}}
> > is quite bad for performances. The string formatting is done whatever the verbose function is doing. > Did you do some profiling?
> 
> No, I didn't do any with this line included (I did on my old code, which used if and print für debugging).

If you really want these verbose you should use lazy formatting. I do not remember what is the state of the art, but you can have a look at `sage.misc.lazy_string` and `sage.misc.lazy_format`. But you are really creating a string within the critical loop. I do find it not very reasonable (the other is fine though).

> > Just for curiosity, do you know how good is `fast_callable` with interval fields? 
> 
> Don't know. I used it with some larger symbolic expressions, and what I remember, I had a significant speedup there.

I am pretty sure that `fast_callable` is better than symbolic and you seem to confirm that. However, you can see in my small snippet above that `fast_callable` looks worse than using Python. I should try on a larger expression but then you have to translate into an object call oriented expression and I am lazy...

> Any suggestions on the bisect-code using fast_callable?

Check what `fast_callable` is doing with `domain=RIF` and `domain=CIF` (quickly looking at `ext/fast_callable.pyx` I would say nothing). It can be done independently of this ticket.

Other comments:

- What is your variable `result` for?

- did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.



---

archive/issue_comments_256972.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-15T10:29:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256972",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256973.json:
```json
{
    "body": "Replying to [comment:5 vdelecroix]:\n> - What is your variable `result` for?\n\nIt collects the already finished cells. I've rewritten the code and introduced a new option (this was already there in a pre-version of this code).",
    "created_at": "2015-08-15T10:42:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256973",
    "user": "@dkrenn"
}
```

Replying to [comment:5 vdelecroix]:
> - What is your variable `result` for?

It collects the already finished cells. I've rewritten the code and introduced a new option (this was already there in a pre-version of this code).



---

archive/issue_comments_256974.json:
```json
{
    "body": "Bad syntax for `INPUT::`, it should be `INPUT:`",
    "created_at": "2015-09-01T08:49:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256974",
    "user": "@fchapoton"
}
```

Bad syntax for `INPUT::`, it should be `INPUT:`



---

archive/issue_comments_256975.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-02T14:00:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256975",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256976.json:
```json
{
    "body": "Replying to [comment:5 vdelecroix]:\n> If you really want these verbose you should use lazy formatting. I do not remember what is the state of the art, but you can have a look at `sage.misc.lazy_string` and `sage.misc.lazy_format`. But you are really creating a string within the critical loop. I do find it not very reasonable (the other is fine though).\n\nLazyFormat did not bring something on the performance. Now checking verbosity level directly; this is faster now.",
    "created_at": "2015-09-02T14:02:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256976",
    "user": "@dkrenn"
}
```

Replying to [comment:5 vdelecroix]:
> If you really want these verbose you should use lazy formatting. I do not remember what is the state of the art, but you can have a look at `sage.misc.lazy_string` and `sage.misc.lazy_format`. But you are really creating a string within the critical loop. I do find it not very reasonable (the other is fine though).

LazyFormat did not bring something on the performance. Now checking verbosity level directly; this is faster now.



---

archive/issue_comments_256977.json:
```json
{
    "body": "Replying to [comment:5 vdelecroix]:\n> - did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.\n\nDone. Is faster now.",
    "created_at": "2015-09-02T14:02:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256977",
    "user": "@dkrenn"
}
```

Replying to [comment:5 vdelecroix]:
> - did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.

Done. Is faster now.



---

archive/issue_comments_256978.json:
```json
{
    "body": "Replying to [comment:8 chapoton]:\n> Bad syntax for `INPUT::`, it should be `INPUT:`\n\nCorrected. Also fixed some broken links in the files (in existing code).\n\nAgain, needs_review :)",
    "created_at": "2015-09-02T14:03:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256978",
    "user": "@dkrenn"
}
```

Replying to [comment:8 chapoton]:
> Bad syntax for `INPUT::`, it should be `INPUT:`

Corrected. Also fixed some broken links in the files (in existing code).

Again, needs_review :)



---

archive/issue_comments_256979.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-10-14T11:39:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256979",
    "user": "@jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_256980.json:
```json
{
    "body": "Unless I'm missing something, the case `f is None` is completely undocumented and untested.",
    "created_at": "2015-10-14T11:39:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256980",
    "user": "@jdemeyer"
}
```

Unless I'm missing something, the case `f is None` is completely undocumented and untested.



---

archive/issue_comments_256981.json:
```json
{
    "body": "Also, I guess the test is meant to satisfy the assumption that if an interval `A` passes, any interval containing `A` should also pass. This should be documented.",
    "created_at": "2015-10-14T11:41:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256981",
    "user": "@jdemeyer"
}
```

Also, I guess the test is meant to satisfy the assumption that if an interval `A` passes, any interval containing `A` should also pass. This should be documented.



---

archive/issue_comments_256982.json:
```json
{
    "body": "Another detail: you can replace\n\n```\nfrom sage.rings.real_mpfi import bisect\nreturn bisect(f, self, test, **kwds)\n```\n\nby\n\n```\nreturn real_mpfi.bisect(f, self, test, **kwds)\n```\n",
    "created_at": "2015-10-14T13:15:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256982",
    "user": "@jdemeyer"
}
```

Another detail: you can replace

```
from sage.rings.real_mpfi import bisect
return bisect(f, self, test, **kwds)
```

by

```
return real_mpfi.bisect(f, self, test, **kwds)
```




---

archive/issue_comments_256983.json:
```json
{
    "body": "Replying to [comment:5 vdelecroix]:\n> - did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.\n\nI agree, there should be a lot more typing. All variables which are boolean should be typed `bint` and all integers a suitable integer type (`Py_ssize_t` for lengths).",
    "created_at": "2015-10-14T13:34:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256983",
    "user": "@jdemeyer"
}
```

Replying to [comment:5 vdelecroix]:
> - did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.

I agree, there should be a lot more typing. All variables which are boolean should be typed `bint` and all integers a suitable integer type (`Py_ssize_t` for lengths).



---

archive/issue_comments_256984.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-18T11:38:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256984",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256985.json:
```json
{
    "body": "Replying to [comment:13 jdemeyer]:\n> Unless I'm missing something, the case `f is None` is completely undocumented and untested.\n\nIs now removed (since not needed).",
    "created_at": "2015-10-18T11:39:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256985",
    "user": "@dkrenn"
}
```

Replying to [comment:13 jdemeyer]:
> Unless I'm missing something, the case `f is None` is completely undocumented and untested.

Is now removed (since not needed).



---

archive/issue_comments_256986.json:
```json
{
    "body": "Replying to [comment:14 jdemeyer]:\n> Also, I guess the test is meant to satisfy the assumption that if an interval `A` passes, any interval containing `A` should also pass. This should be documented.\n\nI've added a note block explaining this.",
    "created_at": "2015-10-18T11:39:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256986",
    "user": "@dkrenn"
}
```

Replying to [comment:14 jdemeyer]:
> Also, I guess the test is meant to satisfy the assumption that if an interval `A` passes, any interval containing `A` should also pass. This should be documented.

I've added a note block explaining this.



---

archive/issue_comments_256987.json:
```json
{
    "body": "Replying to [comment:15 jdemeyer]:\n> Another detail: you can replace\n> {{{\n> from sage.rings.real_mpfi import bisect\n> return bisect(f, self, test, **kwds)\n> }}}\n> by\n> {{{\n> return real_mpfi.bisect(f, self, test, **kwds)\n> }}}\n\nDone.",
    "created_at": "2015-10-18T11:39:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256987",
    "user": "@dkrenn"
}
```

Replying to [comment:15 jdemeyer]:
> Another detail: you can replace
> {{{
> from sage.rings.real_mpfi import bisect
> return bisect(f, self, test, **kwds)
> }}}
> by
> {{{
> return real_mpfi.bisect(f, self, test, **kwds)
> }}}

Done.



---

archive/issue_comments_256988.json:
```json
{
    "body": "Replying to [comment:16 jdemeyer]:\n> Replying to [comment:5 vdelecroix]:\n> > - did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.\n> \n> I agree, there should be a lot more typing. All variables which are boolean should be typed `bint` and all integers a suitable integer type (`Py_ssize_t` for lengths).\n\nI've added `cdef bint success`; this saves about 5 percent in time in my tested examples. I've tried to add `Py_ssize_t` and other `bint`...it does not seem that this brought something. Maybe I am using it wrong...",
    "created_at": "2015-10-18T11:41:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256988",
    "user": "@dkrenn"
}
```

Replying to [comment:16 jdemeyer]:
> Replying to [comment:5 vdelecroix]:
> > - did you try to more typing. In other words `open = [] -> cdef list open = []` and `iteration = 0 -> cdef size_t iteration = 0`, etc. Cython does good job with Python list when it knows that these are lists.
> 
> I agree, there should be a lot more typing. All variables which are boolean should be typed `bint` and all integers a suitable integer type (`Py_ssize_t` for lengths).

I've added `cdef bint success`; this saves about 5 percent in time in my tested examples. I've tried to add `Py_ssize_t` and other `bint`...it does not seem that this brought something. Maybe I am using it wrong...



---

archive/issue_comments_256989.json:
```json
{
    "body": "I've also merged in 6.9 (I am sorry for this, since it was not needed, but I didn't have the previous version available and did not want to want until it was compiled).\n\nSet it back to needs_review.",
    "created_at": "2015-10-18T11:43:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256989",
    "user": "@dkrenn"
}
```

I've also merged in 6.9 (I am sorry for this, since it was not needed, but I didn't have the previous version available and did not want to want until it was compiled).

Set it back to needs_review.



---

archive/issue_comments_256990.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-10-18T11:43:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256990",
    "user": "@dkrenn"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_256991.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-10-18T15:50:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256991",
    "user": "@fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_256992.json:
```json
{
    "body": "one failing doctest",
    "created_at": "2015-10-18T15:50:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256992",
    "user": "@fchapoton"
}
```

one failing doctest



---

archive/issue_comments_256993.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-18T16:28:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256993",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256994.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-18T16:30:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256994",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256995.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-10-18T16:35:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256995",
    "user": "@dkrenn"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_256996.json:
```json
{
    "body": "Replying to [comment:23 chapoton]:\n> one failing doctest\n\nWas not there on 6.9.\n\nMerged 6.10.beta0 and reverted the changes from comment 15 of this ticket (change of imports). Back to needs_review.",
    "created_at": "2015-10-18T16:35:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256996",
    "user": "@dkrenn"
}
```

Replying to [comment:23 chapoton]:
> one failing doctest

Was not there on 6.9.

Merged 6.10.beta0 and reverted the changes from comment 15 of this ticket (change of imports). Back to needs_review.



---

archive/issue_comments_256997.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-16T08:45:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256997",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256998.json:
```json
{
    "body": "Merged 7.1.beta3.",
    "created_at": "2016-02-16T08:45:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256998",
    "user": "@dkrenn"
}
```

Merged 7.1.beta3.



---

archive/issue_comments_256999.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-02-23T08:38:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-256999",
    "user": "@fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_257000.json:
```json
{
    "body": "does not apply",
    "created_at": "2016-02-23T08:38:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257000",
    "user": "@fchapoton"
}
```

does not apply



---

archive/issue_comments_257001.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-23T09:06:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257001",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257002.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-02-23T09:06:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257002",
    "user": "@dkrenn"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_257003.json:
```json
{
    "body": "Replying to [comment:29 chapoton]:\n> does not apply\n\nMerged in 7.1.beta4.",
    "created_at": "2016-02-23T09:06:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257003",
    "user": "@dkrenn"
}
```

Replying to [comment:29 chapoton]:
> does not apply

Merged in 7.1.beta4.



---

archive/issue_comments_257004.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-02-19T07:10:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257004",
    "user": "@fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_257005.json:
```json
{
    "body": "does not apply",
    "created_at": "2018-02-19T07:10:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257005",
    "user": "@fchapoton"
}
```

does not apply



---

archive/issue_comments_257006.json:
```json
{
    "body": "Note that arb already offers a bissection/newton scheme for root finding of analytic functions, see [arb_calc](http://arblib.org/arb_calc.html).",
    "created_at": "2018-02-19T07:36:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257006",
    "user": "@videlec"
}
```

Note that arb already offers a bissection/newton scheme for root finding of analytic functions, see [arb_calc](http://arblib.org/arb_calc.html).



---

archive/issue_comments_257007.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-03-27T16:54:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257007",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_257008.json:
```json
{
    "body": "Replying to [comment:33 vdelecroix]:\n> Note that arb already offers a bissection/newton scheme for root finding of analytic functions, see [arb_calc](http://arblib.org/arb_calc.html).\n\nGood to know, thanks.",
    "created_at": "2019-03-27T16:54:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257008",
    "user": "@dkrenn"
}
```

Replying to [comment:33 vdelecroix]:
> Note that arb already offers a bissection/newton scheme for root finding of analytic functions, see [arb_calc](http://arblib.org/arb_calc.html).

Good to know, thanks.



---

archive/issue_comments_257009.json:
```json
{
    "body": "Merged in 8.6, so back to needs review again.\n\nWhen I see this correctly, all comments given on this ticket so far have been incorporated or answered, but noone gave a positive review three years ago.....I guess, however, we are close to a positive review after all. Can someone have a look again, please.",
    "created_at": "2019-03-27T16:57:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257009",
    "user": "@dkrenn"
}
```

Merged in 8.6, so back to needs review again.

When I see this correctly, all comments given on this ticket so far have been incorporated or answered, but noone gave a positive review three years ago.....I guess, however, we are close to a positive review after all. Can someone have a look again, please.



---

archive/issue_comments_257010.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-03-27T16:57:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257010",
    "user": "@dkrenn"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_257011.json:
```json
{
    "body": "[comment:15] is not addressed. `real_mpfi` is already globally cimported in `complex_interval.pyx`.",
    "created_at": "2019-03-31T16:51:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257011",
    "user": "@videlec"
}
```

[comment:15] is not addressed. `real_mpfi` is already globally cimported in `complex_interval.pyx`.



---

archive/issue_comments_257012.json:
```json
{
    "body": "I don't think that \"bisection on success\"/\"bisection on failure\" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:\n- prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)\n- prove that a cell does not contain a zero (if `f(cell)` does not contain zero)\nIn this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.\n\nI think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.\n\nAlso, isolating roots in an example such as\n\n```\nsage: def contains_zero(fct, cell):\n....:     return fct(cell).contains_zero()\nsage: result = bisect(lambda x: x^3-4*x+2, RIF(-10, 10), contains_zero)\n```\n\nwould be faster since you would not refine the already valid cells.",
    "created_at": "2019-03-31T17:08:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257012",
    "user": "@videlec"
}
```

I don't think that "bisection on success"/"bisection on failure" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:
- prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)
- prove that a cell does not contain a zero (if `f(cell)` does not contain zero)
In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.

I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.

Also, isolating roots in an example such as

```
sage: def contains_zero(fct, cell):
....:     return fct(cell).contains_zero()
sage: result = bisect(lambda x: x^3-4*x+2, RIF(-10, 10), contains_zero)
```

would be faster since you would not refine the already valid cells.



---

archive/issue_comments_257013.json:
```json
{
    "body": "(for all this, you should have a look at `arb_calc_isolate_roots` that was already mentioned)",
    "created_at": "2019-03-31T17:11:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257013",
    "user": "@videlec"
}
```

(for all this, you should have a look at `arb_calc_isolate_roots` that was already mentioned)



---

archive/issue_comments_257014.json:
```json
{
    "body": "The following is a big waste.\n\n```\nif join_neighboring_cells:\n     verbose('joining neighboring cells...', level=1)\n     cells = result\n     result = []\n\n     while len(cells) > 0:\n         joined = cells.pop(0)\n         k = 0\n         while k < len(cells):\n             try:\n                 joined.intersection(cells[k])\n             except ValueError:\n                 k += 1\n             else:\n                 joined = joined.union(cells.pop(k))\n         result.append(joined)\n```\n\nThe intervals should be stored in order (a binary tree seems the most appropriate).",
    "created_at": "2019-03-31T17:13:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257014",
    "user": "@videlec"
}
```

The following is a big waste.

```
if join_neighboring_cells:
     verbose('joining neighboring cells...', level=1)
     cells = result
     result = []

     while len(cells) > 0:
         joined = cells.pop(0)
         k = 0
         while k < len(cells):
             try:
                 joined.intersection(cells[k])
             except ValueError:
                 k += 1
             else:
                 joined = joined.union(cells.pop(k))
         result.append(joined)
```

The intervals should be stored in order (a binary tree seems the most appropriate).



---

archive/issue_comments_257015.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-03-31T17:13:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257015",
    "user": "@videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_257016.json:
```json
{
    "body": "Replying to [comment:38 vdelecroix]:\n> [comment:15] is not addressed. `real_mpfi` is already globally cimported in `complex_interval.pyx`.\n\nDoesn't work:\n\n```\n        return real_mpfi.bisect(f, self, test, **kwds)\n                       ^\n------------------------------------------------------------\n\nsage/rings/complex_interval.pyx:2201:24: cimported module has no attribute 'bisect'\n```\n",
    "created_at": "2019-04-02T13:13:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257016",
    "user": "@dkrenn"
}
```

Replying to [comment:38 vdelecroix]:
> [comment:15] is not addressed. `real_mpfi` is already globally cimported in `complex_interval.pyx`.

Doesn't work:

```
        return real_mpfi.bisect(f, self, test, **kwds)
                       ^
------------------------------------------------------------

sage/rings/complex_interval.pyx:2201:24: cimported module has no attribute 'bisect'
```




---

archive/issue_comments_257017.json:
```json
{
    "body": "Replying to [comment:39 vdelecroix]:\n> I don't think that \"bisection on success\"/\"bisection on failure\" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:\n> - prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)\n> - prove that a cell does not contain a zero (if `f(cell)` does not contain zero)\n> In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.\n> \n> I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.\n\nI agree that at some point this would be an extension to do. However, I think that it should not be now and that the current implementation has its advantages:\n\n- The test at the moment is compatible and in the sense as comparisons etc. work in RIF/CIF:\n  {{{\n  sage: RIF(1,3) < RIF(2,4)\n  False\n  }}}\n  returns `True/False` and not unknown. I think there were a lot of discussions going on about this during Py3 comparison discussions. Apparently this is still so in SageMath, so this should be done consistently in all of the module.\n\n- It is easy to use in the sense what the input test-function should be/return and what the result of `bisect` will be. Therefore this function is suitable for the end user; one main goal of this function.\n\n- The proposed change has a different result; see below.\n\n> Also, isolating roots in an example such as\n> {{{\n> sage: def contains_zero(fct, cell):\n> ....:     return fct(cell).contains_zero()\n> sage: result = bisect(lambda x: x^3-4*x+2, RIF(-10, 10), contains_zero)\n> }}}\n> would be faster since you would not refine the already valid cells.\n\nFaster yes, but gives a different result. The current implementation results in small intervals that satisfy the condition, whereas your proposed solution would find some possible large intervals. One could, of course, do this by the proposed functionality, but rather complicated by searching for the inverse and then inverting the result again, which speaks against the simplicity in usage.",
    "created_at": "2019-04-02T13:32:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257017",
    "user": "@dkrenn"
}
```

Replying to [comment:39 vdelecroix]:
> I don't think that "bisection on success"/"bisection on failure" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:
> - prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)
> - prove that a cell does not contain a zero (if `f(cell)` does not contain zero)
> In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.
> 
> I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.

I agree that at some point this would be an extension to do. However, I think that it should not be now and that the current implementation has its advantages:

- The test at the moment is compatible and in the sense as comparisons etc. work in RIF/CIF:
  {{{
  sage: RIF(1,3) < RIF(2,4)
  False
  }}}
  returns `True/False` and not unknown. I think there were a lot of discussions going on about this during Py3 comparison discussions. Apparently this is still so in SageMath, so this should be done consistently in all of the module.

- It is easy to use in the sense what the input test-function should be/return and what the result of `bisect` will be. Therefore this function is suitable for the end user; one main goal of this function.

- The proposed change has a different result; see below.

> Also, isolating roots in an example such as
> {{{
> sage: def contains_zero(fct, cell):
> ....:     return fct(cell).contains_zero()
> sage: result = bisect(lambda x: x^3-4*x+2, RIF(-10, 10), contains_zero)
> }}}
> would be faster since you would not refine the already valid cells.

Faster yes, but gives a different result. The current implementation results in small intervals that satisfy the condition, whereas your proposed solution would find some possible large intervals. One could, of course, do this by the proposed functionality, but rather complicated by searching for the inverse and then inverting the result again, which speaks against the simplicity in usage.



---

archive/issue_comments_257018.json:
```json
{
    "body": "Replying to [comment:41 vdelecroix]:\n> The following is a big waste.\n> {{{\n> if join_neighboring_cells:\n>      verbose('joining neighboring cells...', level=1)\n>      cells = result\n>      result = []\n> \n>      while len(cells) > 0:\n>          joined = cells.pop(0)\n>          k = 0\n>          while k < len(cells):\n>              try:\n>                  joined.intersection(cells[k])\n>              except ValueError:\n>                  k += 1\n>              else:\n>                  joined = joined.union(cells.pop(k))\n>          result.append(joined)\n> }}}\n> The intervals should be stored in order (a binary tree seems the most appropriate).\n\nThis can only be simplified if we talk about real intervals, but not if we talk about complex intervals, or do I miss something here?",
    "created_at": "2019-04-02T13:33:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257018",
    "user": "@dkrenn"
}
```

Replying to [comment:41 vdelecroix]:
> The following is a big waste.
> {{{
> if join_neighboring_cells:
>      verbose('joining neighboring cells...', level=1)
>      cells = result
>      result = []
> 
>      while len(cells) > 0:
>          joined = cells.pop(0)
>          k = 0
>          while k < len(cells):
>              try:
>                  joined.intersection(cells[k])
>              except ValueError:
>                  k += 1
>              else:
>                  joined = joined.union(cells.pop(k))
>          result.append(joined)
> }}}
> The intervals should be stored in order (a binary tree seems the most appropriate).

This can only be simplified if we talk about real intervals, but not if we talk about complex intervals, or do I miss something here?



---

archive/issue_comments_257019.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2019-04-02T13:33:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257019",
    "user": "@dkrenn"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_257020.json:
```json
{
    "body": "Replying to [comment:45 dkrenn]:\n> Replying to [comment:41 vdelecroix]:\n> > The following is a big waste.\n> > {{{\n> > if join_neighboring_cells:\n> >      verbose('joining neighboring cells...', level=1)\n> >      cells = result\n> >      result = []\n> > \n> >      while len(cells) > 0:\n> >          joined = cells.pop(0)\n> >          k = 0\n> >          while k < len(cells):\n> >              try:\n> >                  joined.intersection(cells[k])\n> >              except ValueError:\n> >                  k += 1\n> >              else:\n> >                  joined = joined.union(cells.pop(k))\n> >          result.append(joined)\n> > }}}\n> > The intervals should be stored in order (a binary tree seems the most appropriate).\n> \n> This can only be simplified if we talk about real intervals, but not if we talk about complex intervals, or do I miss something here?\n\nIndeed. For complex intervals you want a quad-tree not a binary tree.",
    "created_at": "2019-04-02T13:52:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257020",
    "user": "@videlec"
}
```

Replying to [comment:45 dkrenn]:
> Replying to [comment:41 vdelecroix]:
> > The following is a big waste.
> > {{{
> > if join_neighboring_cells:
> >      verbose('joining neighboring cells...', level=1)
> >      cells = result
> >      result = []
> > 
> >      while len(cells) > 0:
> >          joined = cells.pop(0)
> >          k = 0
> >          while k < len(cells):
> >              try:
> >                  joined.intersection(cells[k])
> >              except ValueError:
> >                  k += 1
> >              else:
> >                  joined = joined.union(cells.pop(k))
> >          result.append(joined)
> > }}}
> > The intervals should be stored in order (a binary tree seems the most appropriate).
> 
> This can only be simplified if we talk about real intervals, but not if we talk about complex intervals, or do I miss something here?

Indeed. For complex intervals you want a quad-tree not a binary tree.



---

archive/issue_comments_257021.json:
```json
{
    "body": "Replying to [comment:44 dkrenn]:\n> Replying to [comment:39 vdelecroix]:\n> > I don't think that \"bisection on success\"/\"bisection on failure\" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:\n> > - prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)\n> > - prove that a cell does not contain a zero (if `f(cell)` does not contain zero)\n> > In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.\n> > \n> > I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.\n> \n> I agree that at some point this would be an extension to do.\n\nGood. Then it shoud be clear that all the functionalities will be forward compatible.\n\n> However, I think that it should not be now and that the current implementation has its advantages:\n> \n> - The test at the moment is compatible and in the sense as comparisons etc. work in RIF/CIF:\n>   {{{\n>   sage: RIF(1,3) < RIF(2,4)\n>   False\n>   }}}\n>   returns `True/False` and not unknown. I think there were a lot of discussions going on about this during Py3 comparison discussions. Apparently this is still so in SageMath, so this should be done consistently in all of the module.\n\nThe workaround is very simple\n\n```\nsage: def is_really_less_than(a,b):\n....:     if a < b: return True\n....:     elif b <= a: return False\n....:     else: return Unknown\nsage: is_really_less_than(RIF(1,2), RIF(3,4))\nTrue\nsage: is_really_less_than(RIF(1,3), RIF(2,4))\nUnknown\n```\n\n\n> - It is easy to use in the sense what the input test-function should be/return and what the result of `bisect` will be. Therefore this function is suitable for the end user; one main goal of this function.\n> \n> - The proposed change has a different result; see below.\n> \n> > Also, isolating roots in an example such as\n> > {{{\n> > sage: def contains_zero(fct, cell):\n> > ....:     return fct(cell).contains_zero()\n> > sage: result = bisect(lambda x: x^3-4*x+2, RIF(-10, 10), contains_zero)\n> > }}}\n> > would be faster since you would not refine the already valid cells.\n> \n> Faster yes, but gives a different result. The current implementation results in small intervals that satisfy the condition, whereas your proposed solution would find some possible large intervals. One could, of course, do this by the proposed functionality, but rather complicated by searching for the inverse and then inverting the result again, which speaks against the simplicity in usage.\n\nWhen roots are isolated you typically switch to something else. If you know that f has a unique root in [0,1] you would not implement the bisection the way this function proceed. Moreover, if you want really small intervals, Newton method is better suited. So the fact that the code in the current branch does more than the minimum amount of work is a downside to me.",
    "created_at": "2019-04-02T14:01:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257021",
    "user": "@videlec"
}
```

Replying to [comment:44 dkrenn]:
> Replying to [comment:39 vdelecroix]:
> > I don't think that "bisection on success"/"bisection on failure" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:
> > - prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)
> > - prove that a cell does not contain a zero (if `f(cell)` does not contain zero)
> > In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.
> > 
> > I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.
> 
> I agree that at some point this would be an extension to do.

Good. Then it shoud be clear that all the functionalities will be forward compatible.

> However, I think that it should not be now and that the current implementation has its advantages:
> 
> - The test at the moment is compatible and in the sense as comparisons etc. work in RIF/CIF:
>   {{{
>   sage: RIF(1,3) < RIF(2,4)
>   False
>   }}}
>   returns `True/False` and not unknown. I think there were a lot of discussions going on about this during Py3 comparison discussions. Apparently this is still so in SageMath, so this should be done consistently in all of the module.

The workaround is very simple

```
sage: def is_really_less_than(a,b):
....:     if a < b: return True
....:     elif b <= a: return False
....:     else: return Unknown
sage: is_really_less_than(RIF(1,2), RIF(3,4))
True
sage: is_really_less_than(RIF(1,3), RIF(2,4))
Unknown
```


> - It is easy to use in the sense what the input test-function should be/return and what the result of `bisect` will be. Therefore this function is suitable for the end user; one main goal of this function.
> 
> - The proposed change has a different result; see below.
> 
> > Also, isolating roots in an example such as
> > {{{
> > sage: def contains_zero(fct, cell):
> > ....:     return fct(cell).contains_zero()
> > sage: result = bisect(lambda x: x^3-4*x+2, RIF(-10, 10), contains_zero)
> > }}}
> > would be faster since you would not refine the already valid cells.
> 
> Faster yes, but gives a different result. The current implementation results in small intervals that satisfy the condition, whereas your proposed solution would find some possible large intervals. One could, of course, do this by the proposed functionality, but rather complicated by searching for the inverse and then inverting the result again, which speaks against the simplicity in usage.

When roots are isolated you typically switch to something else. If you know that f has a unique root in [0,1] you would not implement the bisection the way this function proceed. Moreover, if you want really small intervals, Newton method is better suited. So the fact that the code in the current branch does more than the minimum amount of work is a downside to me.



---

archive/issue_comments_257022.json:
```json
{
    "body": "Replying to [comment:48 vdelecroix]:\n> Replying to [comment:44 dkrenn]:\n> > Faster yes, but gives a different result. The current implementation results in small intervals that satisfy the condition, whereas your proposed solution would find some possible large intervals. One could, of course, do this by the proposed functionality, but rather complicated by searching for the inverse and then inverting the result again, which speaks against the simplicity in usage.\n> \n> When roots are isolated you typically switch to something else. If you know that f has a unique root in [0,1] you would not implement the bisection the way this function proceed. Moreover, if you want really small intervals, Newton method is better suited. So the fact that the code in the current branch does more than the minimum amount of work is a downside to me.\n\nNewton can only be done if the function is differentiable, which is not assumed by the current implementation.",
    "created_at": "2019-04-02T14:13:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257022",
    "user": "@dkrenn"
}
```

Replying to [comment:48 vdelecroix]:
> Replying to [comment:44 dkrenn]:
> > Faster yes, but gives a different result. The current implementation results in small intervals that satisfy the condition, whereas your proposed solution would find some possible large intervals. One could, of course, do this by the proposed functionality, but rather complicated by searching for the inverse and then inverting the result again, which speaks against the simplicity in usage.
> 
> When roots are isolated you typically switch to something else. If you know that f has a unique root in [0,1] you would not implement the bisection the way this function proceed. Moreover, if you want really small intervals, Newton method is better suited. So the fact that the code in the current branch does more than the minimum amount of work is a downside to me.

Newton can only be done if the function is differentiable, which is not assumed by the current implementation.



---

archive/issue_comments_257023.json:
```json
{
    "body": "Replying to [comment:47 vdelecroix]:\n> Replying to [comment:45 dkrenn]:\n> > Replying to [comment:41 vdelecroix]:\n> > > The following is a big waste.\n> > > {{{\n> > > if join_neighboring_cells:\n> > >      verbose('joining neighboring cells...', level=1)\n> > >      cells = result\n> > >      result = []\n> > > \n> > >      while len(cells) > 0:\n> > >          joined = cells.pop(0)\n> > >          k = 0\n> > >          while k < len(cells):\n> > >              try:\n> > >                  joined.intersection(cells[k])\n> > >              except ValueError:\n> > >                  k += 1\n> > >              else:\n> > >                  joined = joined.union(cells.pop(k))\n> > >          result.append(joined)\n> > > }}}\n> > > The intervals should be stored in order (a binary tree seems the most appropriate).\n> > \n> > This can only be simplified if we talk about real intervals, but not if we talk about complex intervals, or do I miss something here?\n> \n> Indeed. For complex intervals you want a quad-tree not a binary tree.\n\nFollow-up ticket #27595.",
    "created_at": "2019-04-02T14:37:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257023",
    "user": "@dkrenn"
}
```

Replying to [comment:47 vdelecroix]:
> Replying to [comment:45 dkrenn]:
> > Replying to [comment:41 vdelecroix]:
> > > The following is a big waste.
> > > {{{
> > > if join_neighboring_cells:
> > >      verbose('joining neighboring cells...', level=1)
> > >      cells = result
> > >      result = []
> > > 
> > >      while len(cells) > 0:
> > >          joined = cells.pop(0)
> > >          k = 0
> > >          while k < len(cells):
> > >              try:
> > >                  joined.intersection(cells[k])
> > >              except ValueError:
> > >                  k += 1
> > >              else:
> > >                  joined = joined.union(cells.pop(k))
> > >          result.append(joined)
> > > }}}
> > > The intervals should be stored in order (a binary tree seems the most appropriate).
> > 
> > This can only be simplified if we talk about real intervals, but not if we talk about complex intervals, or do I miss something here?
> 
> Indeed. For complex intervals you want a quad-tree not a binary tree.

Follow-up ticket #27595.



---

archive/issue_comments_257024.json:
```json
{
    "body": "Replying to [comment:48 vdelecroix]:\n> Replying to [comment:44 dkrenn]:\n> > Replying to [comment:39 vdelecroix]:\n> > > I don't think that \"bisection on success\"/\"bisection on failure\" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:\n> > > - prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)\n> > > - prove that a cell does not contain a zero (if `f(cell)` does not contain zero)\n> > > In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.\n> > > \n> > > I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.\n> > \n> > I agree that at some point this would be an extension to do.\n> \n> Good. Then it shoud be clear that all the functionalities will be forward compatible.\n\nAfter all, this might be difficult, as already the output and the desired functionality seems to be different in our two cases. Do you have something particular in mind here?",
    "created_at": "2019-04-02T14:41:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257024",
    "user": "@dkrenn"
}
```

Replying to [comment:48 vdelecroix]:
> Replying to [comment:44 dkrenn]:
> > Replying to [comment:39 vdelecroix]:
> > > I don't think that "bisection on success"/"bisection on failure" is enough. In many instances you have better than a boolean test. Let me consider the situation where you want to isolate all roots of the function `f` (e.g. a square-free polynomial). Interval arithmetic allows you to:
> > > - prove that a cell contains a single zero (if `f(left)` and `f(right)` have different signs and `f'(cell)` does not vanish)
> > > - prove that a cell does not contain a zero (if `f(cell)` does not contain zero)
> > > In this situation, you want to perform bisection if the two above certificate failed. It is a `True/False/Unknown` situation.
> > > 
> > > I think that the bisection should be general enough to handle this search because it does provide a proof of what you are looking for. The return value would be a pairs of lists: the one you are interested in and the pieces for which bisection failed to determinate their status.
> > 
> > I agree that at some point this would be an extension to do.
> 
> Good. Then it shoud be clear that all the functionalities will be forward compatible.

After all, this might be difficult, as already the output and the desired functionality seems to be different in our two cases. Do you have something particular in mind here?



---

archive/issue_comments_257025.json:
```json
{
    "body": "Tickets still needing working or clarification should be moved to the next release milestone at the soonest (please feel free to revert if you think the ticket is close to being resolved).",
    "created_at": "2019-06-14T14:50:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257025",
    "user": "@embray"
}
```

Tickets still needing working or clarification should be moved to the next release milestone at the soonest (please feel free to revert if you think the ticket is close to being resolved).



---

archive/issue_comments_257026.json:
```json
{
    "body": "Ticket retargeted after milestone closed",
    "created_at": "2019-12-30T14:48:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257026",
    "user": "@embray"
}
```

Ticket retargeted after milestone closed



---

archive/issue_comments_257027.json:
```json
{
    "body": "Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257027",
    "user": "@mkoeppe"
}
```

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_comments_257028.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-15T22:07:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257028",
    "user": "@mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_257029.json:
```json
{
    "body": "Setting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257029",
    "user": "@mkoeppe"
}
```

Setting a new milestone for this ticket based on a cursory review.



---

archive/issue_comments_257030.json:
```json
{
    "body": "Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.",
    "created_at": "2021-12-18T19:53:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18796",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18796#issuecomment-257030",
    "user": "@mkoeppe"
}
```

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.
