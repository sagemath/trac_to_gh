# Issue 24954: Stronger references in CachedRepresentation

archive/issues_024717.json:
```json
{
    "body": "There is some very bad behaviour related to `CachedRepresentation` caching that I'm observing on #24742 (but this is otherwise unrelated to that ticket):\n\n```\nsage: timeit('MatrixSpace(ZZ,3,3)')\n625 loops, best of 3: 117 \u00b5s per loop\n```\nNow, we try again but we first create a strong reference:\n\n```\nsage: S = MatrixSpace(ZZ,3,3)\nsage: timeit('MatrixSpace(ZZ,3,3)')\n625 loops, best of 3: 4.13 \u00b5s per loop\n```\nThis is much faster the second time! In the first example, the caching \nof `CachedRepresentation.__classcall__` is pointless since there is no \nstrong reference to the entry in the cache, so it gets deleted \nimmediately whenever the `MatrixSpace(ZZ,3,3)` is deleted.\n\nThis is just the usual `Py_DECREF` of Python objects, it has nothing to do with the cyclic garbage collector: the behaviour remains the same even \nwith `gc.disable()`.\n\nThis makes me think that we might need to change `CachedRepresentation` \nto use semi-strong references: these would only be deleted by the \ncyclic garbage collector but not by a simple `Py_DECREF()`.\n\n**Branch/Commit:** [a802f12aee11f3b100f82108aacd151e6aad3c80](https://github.com/sagemath/sagetrac-mirror/commit/a802f12aee11f3b100f82108aacd151e6aad3c80)\n\n**Reviewer:** Marc Mezzarobba\n\n**Author:** Jeroen Demeyer\n\nIssue created by migration from https://trac.sagemath.org/ticket/24954\n\n",
    "closed_at": "2018-05-12T11:47:43Z",
    "created_at": "2018-03-12T10:57:22Z",
    "labels": [
        "component: misc",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-8.2",
    "title": "Stronger references in CachedRepresentation",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/24954",
    "user": "https://github.com/jdemeyer"
}
```
There is some very bad behaviour related to `CachedRepresentation` caching that I'm observing on #24742 (but this is otherwise unrelated to that ticket):

```
sage: timeit('MatrixSpace(ZZ,3,3)')
625 loops, best of 3: 117 µs per loop
```
Now, we try again but we first create a strong reference:

```
sage: S = MatrixSpace(ZZ,3,3)
sage: timeit('MatrixSpace(ZZ,3,3)')
625 loops, best of 3: 4.13 µs per loop
```
This is much faster the second time! In the first example, the caching 
of `CachedRepresentation.__classcall__` is pointless since there is no 
strong reference to the entry in the cache, so it gets deleted 
immediately whenever the `MatrixSpace(ZZ,3,3)` is deleted.

This is just the usual `Py_DECREF` of Python objects, it has nothing to do with the cyclic garbage collector: the behaviour remains the same even 
with `gc.disable()`.

This makes me think that we might need to change `CachedRepresentation` 
to use semi-strong references: these would only be deleted by the 
cyclic garbage collector but not by a simple `Py_DECREF()`.

**Branch/Commit:** [a802f12aee11f3b100f82108aacd151e6aad3c80](https://github.com/sagemath/sagetrac-mirror/commit/a802f12aee11f3b100f82108aacd151e6aad3c80)

**Reviewer:** Marc Mezzarobba

**Author:** Jeroen Demeyer

Issue created by migration from https://trac.sagemath.org/ticket/24954





---

archive/issue_comments_382475.json:
```json
{
    "body": "<a id='comment:1'></a>\nIdea: SemiWeakValueDictionary will initially create a strong reference to each value (say, by means of a class attribute holding a list containing the items), and gc.collect() will be monkey-patched so that it first removes all strong references kept by SemiWeakValueDictionary before doing the cyclic collection.\n\nIn that way, the values of SemiWeakValueDictionary would be permanent till the next cyclic garbage collection occurs.\n\nWould that work?",
    "created_at": "2018-03-12T12:12:41Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382475",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Idea: SemiWeakValueDictionary will initially create a strong reference to each value (say, by means of a class attribute holding a list containing the items), and gc.collect() will be monkey-patched so that it first removes all strong references kept by SemiWeakValueDictionary before doing the cyclic collection.

In that way, the values of SemiWeakValueDictionary would be permanent till the next cyclic garbage collection occurs.

Would that work?



---

archive/issue_comments_382476.json:
```json
{
    "body": "<a id='comment:2'></a>\nProof of concept:\n\n```\nsage: from weakref import WeakValueDictionary\nsage: from gc import collect\nsage: import gc\nsage: class MyThing(object):\n....:     def __del__(self):\n....:         print \"<{}> gone\".format(id(self))\n....:     def __init__(self, n):\n....:         print \"new thing for {}\".format(n)\n....:         \nsage: class MyWVD(object):\n....:     refs = []\n....:     def __init__(self):\n....:         self.D = WeakValueDictionary()\n....:     def __getitem__(self, k):\n....:         return self.D[k]\n....:     def __setitem__(self, k, v):\n....:         self.D[k] = v\n....:         MyWVD.refs.append(v)\n....:         \nsage: D = MyWVD()\nsage: def my_collect(generation=None):\n....:     MyWVD.refs = []\n....:     if generation is not None:\n....:         collect(generation)\n....:     else:\n....:         collect()\n....:         \nsage: gc.collect = my_collect\nsage: a = D[1] = MyThing(1); del a\nnew thing for 1\nsage: a = D[2] = MyThing(2); del a\nnew thing for 2\nsage: gc.collect()\n<140253944715856> gone\n<140253944736848> gone\n```",
    "created_at": "2018-03-12T12:28:04Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382476",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Proof of concept:

```
sage: from weakref import WeakValueDictionary
sage: from gc import collect
sage: import gc
sage: class MyThing(object):
....:     def __del__(self):
....:         print "<{}> gone".format(id(self))
....:     def __init__(self, n):
....:         print "new thing for {}".format(n)
....:         
sage: class MyWVD(object):
....:     refs = []
....:     def __init__(self):
....:         self.D = WeakValueDictionary()
....:     def __getitem__(self, k):
....:         return self.D[k]
....:     def __setitem__(self, k, v):
....:         self.D[k] = v
....:         MyWVD.refs.append(v)
....:         
sage: D = MyWVD()
sage: def my_collect(generation=None):
....:     MyWVD.refs = []
....:     if generation is not None:
....:         collect(generation)
....:     else:
....:         collect()
....:         
sage: gc.collect = my_collect
sage: a = D[1] = MyThing(1); del a
new thing for 1
sage: a = D[2] = MyThing(2); del a
new thing for 2
sage: gc.collect()
<140253944715856> gone
<140253944736848> gone
```



---

archive/issue_comments_382477.json:
```json
{
    "body": "<a id='comment:3'></a>\nTiming:\n\n```\nsage: class MyThing(object):\n....:     pass\n....:         \nsage: D1 = MyWVD()\nsage: D2 = WeakValueDictionary()\nsage: def test1(n):\n....:     try:\n....:         return D1[n]\n....:     except KeyError:\n....:         a = D1[n] = MyThing()\n....:         return a\n....:     \nsage: def test2(n):\n....:     try:\n....:         return D2[n]\n....:     except KeyError:\n....:         a = D2[n] = MyThing()\n....:         return a\n....:     \nsage: %timeit test1(5)\nThe slowest run took 54.57 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000000 loops, best of 3: 1.14 \u00b5s per loop\nsage: %timeit test2(5)\nThe slowest run took 15.23 times longer than the fastest. This could mean that an intermediate result is being cached.\n100000 loops, best of 3: 4.87 \u00b5s per loop\n```\nvs.\n\n```\nsage: %timeit test1(5); gc.collect()\n10 loops, best of 3: 60 ms per loop\nsage: %timeit test2(5); gc.collect()\n10 loops, best of 3: 60 ms per loop\n```",
    "created_at": "2018-03-12T12:31:45Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382477",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Timing:

```
sage: class MyThing(object):
....:     pass
....:         
sage: D1 = MyWVD()
sage: D2 = WeakValueDictionary()
sage: def test1(n):
....:     try:
....:         return D1[n]
....:     except KeyError:
....:         a = D1[n] = MyThing()
....:         return a
....:     
sage: def test2(n):
....:     try:
....:         return D2[n]
....:     except KeyError:
....:         a = D2[n] = MyThing()
....:         return a
....:     
sage: %timeit test1(5)
The slowest run took 54.57 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.14 µs per loop
sage: %timeit test2(5)
The slowest run took 15.23 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 3: 4.87 µs per loop
```
vs.

```
sage: %timeit test1(5); gc.collect()
10 loops, best of 3: 60 ms per loop
sage: %timeit test2(5); gc.collect()
10 loops, best of 3: 60 ms per loop
```



---

archive/issue_comments_382478.json:
```json
{
    "body": "<a id='comment:4'></a>\nYou can't \"just\" monkey-patch the `gc` module, since what you can reach from Python are just Python-level wrappers for lower-level C functions used internally by the Python interpreter.  This only changes what happens if one manually calls `gc.collect()` (in which case there's not much point in monkey-patching).",
    "created_at": "2018-03-12T12:47:26Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382478",
    "user": "https://github.com/embray"
}
```

<a id='comment:4'></a>
You can't "just" monkey-patch the `gc` module, since what you can reach from Python are just Python-level wrappers for lower-level C functions used internally by the Python interpreter.  This only changes what happens if one manually calls `gc.collect()` (in which case there's not much point in monkey-patching).



---

archive/issue_comments_382479.json:
```json
{
    "body": "<a id='comment:5'></a>\nReplying to [embray](#comment%3A4):\n> You can't \"just\" monkey-patch the `gc` module, since what you can reach from Python are just Python-level wrappers for lower-level C functions used internally by the Python interpreter.  This only changes what happens if one manually calls `gc.collect()` (in which case there's not much point in monkey-patching).\n\n\nYou're right. Hm. Then one could perhaps construct a guardian that will not be collected unless a cyclic garbage collection happens, with a `__del__` method that triggers weakening of the SemiWeakValueDictionary. I'll try to construct it...",
    "created_at": "2018-03-12T13:08:48Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382479",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
Replying to [embray](#comment%3A4):
> You can't "just" monkey-patch the `gc` module, since what you can reach from Python are just Python-level wrappers for lower-level C functions used internally by the Python interpreter.  This only changes what happens if one manually calls `gc.collect()` (in which case there's not much point in monkey-patching).


You're right. Hm. Then one could perhaps construct a guardian that will not be collected unless a cyclic garbage collection happens, with a `__del__` method that triggers weakening of the SemiWeakValueDictionary. I'll try to construct it...



---

archive/issue_comments_382480.json:
```json
{
    "body": "<a id='comment:6'></a>\nI see two possible implementations, both quite simple:\n\n(A) Keep strong references to the last 100 (or whatever number) values inserted in a `WeakValueDictionary`. Basically a Python list `lastvalues` with a wrapping-aroud counter `i` such that, whenever an item is inserted, it is also inserted as `lastvalues[i]`. This requires changing only `WeakValueDictionary`.\n\n(B) Keep a strong reference from the value to itself (`self.__self = self`) forcing the object to be part of a reference cycle. This way, it can be deleted only by the garbage collector. This requires changing the values, i.e. `CachedRepresentation`.\n\nI'll try to implement (A).",
    "created_at": "2018-03-12T13:17:40Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382480",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:6'></a>
I see two possible implementations, both quite simple:

(A) Keep strong references to the last 100 (or whatever number) values inserted in a `WeakValueDictionary`. Basically a Python list `lastvalues` with a wrapping-aroud counter `i` such that, whenever an item is inserted, it is also inserted as `lastvalues[i]`. This requires changing only `WeakValueDictionary`.

(B) Keep a strong reference from the value to itself (`self.__self = self`) forcing the object to be part of a reference cycle. This way, it can be deleted only by the garbage collector. This requires changing the values, i.e. `CachedRepresentation`.

I'll try to implement (A).



---

archive/issue_comments_382481.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [jdemeyer](#comment%3A6):\n> I see two possible implementations, both quite simple:\n> \n> (A) Keep strong references to the last 100 (or whatever number) values inserted in a `WeakValueDictionary`. Basically a Python list `lastvalues` with a wrapping-aroud counter `i` such that, whenever an item is inserted, it is also inserted as `lastvalues[i]`. This requires changing only `WeakValueDictionary`.\n> \n> (B) Keep a strong reference from the value to itself (`self.__self = self`) forcing the object to be part of a reference cycle. This way, it can be deleted only by the garbage collector. This requires changing the values, i.e. `CachedRepresentation`.\n> \n> I'll try to implement (A).\n\n\nI will try to implement (C), which is:\n\n(C) create a \"guardian\" with a reference to itself (so that it will only be deleted during cyclic garbage collection) and create a weak reference with callback from the class SemiWeakValueDictionary to the guardian. The callback function will both restore the weak reference to the guardian and clears the strong references to the values -- and apparently the callback function is only called when a cyclic collection happens.",
    "created_at": "2018-03-12T13:20:45Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382481",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Replying to [jdemeyer](#comment%3A6):
> I see two possible implementations, both quite simple:
> 
> (A) Keep strong references to the last 100 (or whatever number) values inserted in a `WeakValueDictionary`. Basically a Python list `lastvalues` with a wrapping-aroud counter `i` such that, whenever an item is inserted, it is also inserted as `lastvalues[i]`. This requires changing only `WeakValueDictionary`.
> 
> (B) Keep a strong reference from the value to itself (`self.__self = self`) forcing the object to be part of a reference cycle. This way, it can be deleted only by the garbage collector. This requires changing the values, i.e. `CachedRepresentation`.
> 
> I'll try to implement (A).


I will try to implement (C), which is:

(C) create a "guardian" with a reference to itself (so that it will only be deleted during cyclic garbage collection) and create a weak reference with callback from the class SemiWeakValueDictionary to the guardian. The callback function will both restore the weak reference to the guardian and clears the strong references to the values -- and apparently the callback function is only called when a cyclic collection happens.



---

archive/issue_comments_382482.json:
```json
{
    "body": "<a id='comment:8'></a>\nSo, in practice, the main difference between (A) and (C) is *when* are the strong references cleared? With (A), it would happen after 100 objects have been inserted in a `WeakValueDictionary` and with (C) it would happen upon garbage collection. I have no idea what works best.",
    "created_at": "2018-03-12T13:29:59Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382482",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
So, in practice, the main difference between (A) and (C) is *when* are the strong references cleared? With (A), it would happen after 100 objects have been inserted in a `WeakValueDictionary` and with (C) it would happen upon garbage collection. I have no idea what works best.



---

archive/issue_comments_382483.json:
```json
{
    "body": "<a id='comment:9'></a>\nI thought (C) would work as follows:\n\n```\nsage: from weakref import WeakValueDictionary, ref\nsage: class Guardian(object):\n....:     def __init__(self):\n....:         self._self = self\n....:         \nsage: class SWVD(object):\n....:     @staticmethod\n....:     def collect(*foo):\n....:         print \"collect\"\n....:         SWVD.guard = ref(Guardian(), cls.collect)\n....:         SWVD.refs = []\n....:     refs = []\n....:     guard = ref(Guardian(), collect)\n....:     def __init__(self):\n....:         self.D = WeakValueDictionary()\n....:     def __getitem__(self, k):\n....:         return self.D[k]\n....:     def __setitem__(self, k, v):\n....:         self.D[k] = v\n....:         SWVD.refs.append(v)\n....:         \nsage: class MyThing(object):\n....:     def __del__(self):\n....:         print \"<{}> gone\".format(id(self))\n....:     def __init__(self, n):\n....:         print \"new thing for {}\".format(n)\n....:         \nsage: D = SWVD()\nsage: a = D[2] = MyThing(2); del a\nnew thing for 2\nsage: a = D[2] = MyThing(2); del a\nnew thing for 2\nsage: a = D[2] = MyThing(2); del a\nnew thing for 2\n```\nThat's fine. But something went wrong:\n\n```\nsage: import gc\nsage: gc.collect()\nException TypeError: \"'staticmethod' object is not callable\" in <staticmethod object at 0x7f8cda18b2f0> ignored\n58\n```\nSo, why is the static method not callable? What requirements are made for the callback of a weak reference?",
    "created_at": "2018-03-12T13:47:57Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382483",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
I thought (C) would work as follows:

```
sage: from weakref import WeakValueDictionary, ref
sage: class Guardian(object):
....:     def __init__(self):
....:         self._self = self
....:         
sage: class SWVD(object):
....:     @staticmethod
....:     def collect(*foo):
....:         print "collect"
....:         SWVD.guard = ref(Guardian(), cls.collect)
....:         SWVD.refs = []
....:     refs = []
....:     guard = ref(Guardian(), collect)
....:     def __init__(self):
....:         self.D = WeakValueDictionary()
....:     def __getitem__(self, k):
....:         return self.D[k]
....:     def __setitem__(self, k, v):
....:         self.D[k] = v
....:         SWVD.refs.append(v)
....:         
sage: class MyThing(object):
....:     def __del__(self):
....:         print "<{}> gone".format(id(self))
....:     def __init__(self, n):
....:         print "new thing for {}".format(n)
....:         
sage: D = SWVD()
sage: a = D[2] = MyThing(2); del a
new thing for 2
sage: a = D[2] = MyThing(2); del a
new thing for 2
sage: a = D[2] = MyThing(2); del a
new thing for 2
```
That's fine. But something went wrong:

```
sage: import gc
sage: gc.collect()
Exception TypeError: "'staticmethod' object is not callable" in <staticmethod object at 0x7f8cda18b2f0> ignored
58
```
So, why is the static method not callable? What requirements are made for the callback of a weak reference?



---

archive/issue_comments_382484.json:
```json
{
    "body": "<a id='comment:10'></a>\nOuch, I found the problem: An unreferenced variable \"cls\" in the callback function that shouldn't belong there...\n\nNonetheless, so far, I don't get it to work.",
    "created_at": "2018-03-12T13:57:29Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382484",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:10'></a>
Ouch, I found the problem: An unreferenced variable "cls" in the callback function that shouldn't belong there...

Nonetheless, so far, I don't get it to work.



---

archive/issue_comments_382485.json:
```json
{
    "body": "<a id='comment:11'></a>\nGot it.\n\nProblem: During creation of the class SWVD, I wanted to refer to an attribute of that class. Apparently it didn't work. So, now, I am setting the class attribute during initialisation of the first instance of that class.\n\n```\nsage: from weakref import WeakValueDictionary, ref\nsage: import gc\nsage: class Guardian(object):\n....:     def __init__(self):\n....:         self._self = self\n....:         \nsage: class SWVD(object):\n....:     @classmethod\n....:     def collect(cls, *foo):\n....:         print \"collect\"\n....:         cls.guard = ref(Guardian(), cls.collect)\n....:         cls.refs = []\n....:     refs = []\n....:     guard = None\n....:     def __init__(self):\n....:         if self.__class__.guard is None:\n....:             self.__class__guard = ref(Guardian(), self.__class__.collect)\n....:         self.D = WeakValueDictionary()\n....:     def __getitem__(self, k):\n....:         return self.D[k]\n....:     def __setitem__(self, k, v):\n....:         self.D[k] = v\n....:         SWVD.refs.append(v)\n....:         \nsage: class MyThing(object):\n....:     def __del__(self):\n....:         print \"<{}> gone\".format(id(self))\n....:     def __init__(self, n):\n....:         print \"new thing for {}\".format(n)\n....:         \nsage: D = SWVD()\n```\nElements of a SemiWeakValueDictionary aren't immediately deleted:\n\n```\nsage: a = D[2] = MyThing(2); del a\nnew thing for 2\nsage: a = D[2] = MyThing(2); del a\nnew thing for 2\nsage: a = D[2] = MyThing(2); del a\nnew thing for 2\n```\nBut they *are* deleted when a garbage collection happens:\n\n```\nsage: gc.collect()\ncollect\n<139776980263696> gone\n<139776980313808> gone\n<139776980313104> gone\n71\n```\nI guess the above would basically work, although I would prefer to define `SWVD.guard` during creation of the class and not during creation of its first instance.\n\n**Edit:** I also tested `a = D[2] = MyThing(2); del a` in a loop, and indeed a \"spontaneous\" garbage collection does result in the deletion of the dictionary values, just as it should. So, this time I am not just touching the Python layer of the gc module...",
    "created_at": "2018-03-12T14:15:17Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382485",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'></a>
Got it.

Problem: During creation of the class SWVD, I wanted to refer to an attribute of that class. Apparently it didn't work. So, now, I am setting the class attribute during initialisation of the first instance of that class.

```
sage: from weakref import WeakValueDictionary, ref
sage: import gc
sage: class Guardian(object):
....:     def __init__(self):
....:         self._self = self
....:         
sage: class SWVD(object):
....:     @classmethod
....:     def collect(cls, *foo):
....:         print "collect"
....:         cls.guard = ref(Guardian(), cls.collect)
....:         cls.refs = []
....:     refs = []
....:     guard = None
....:     def __init__(self):
....:         if self.__class__.guard is None:
....:             self.__class__guard = ref(Guardian(), self.__class__.collect)
....:         self.D = WeakValueDictionary()
....:     def __getitem__(self, k):
....:         return self.D[k]
....:     def __setitem__(self, k, v):
....:         self.D[k] = v
....:         SWVD.refs.append(v)
....:         
sage: class MyThing(object):
....:     def __del__(self):
....:         print "<{}> gone".format(id(self))
....:     def __init__(self, n):
....:         print "new thing for {}".format(n)
....:         
sage: D = SWVD()
```
Elements of a SemiWeakValueDictionary aren't immediately deleted:

```
sage: a = D[2] = MyThing(2); del a
new thing for 2
sage: a = D[2] = MyThing(2); del a
new thing for 2
sage: a = D[2] = MyThing(2); del a
new thing for 2
```
But they *are* deleted when a garbage collection happens:

```
sage: gc.collect()
collect
<139776980263696> gone
<139776980313808> gone
<139776980313104> gone
71
```
I guess the above would basically work, although I would prefer to define `SWVD.guard` during creation of the class and not during creation of its first instance.

**Edit:** I also tested `a = D[2] = MyThing(2); del a` in a loop, and indeed a "spontaneous" garbage collection does result in the deletion of the dictionary values, just as it should. So, this time I am not just touching the Python layer of the gc module...



---

archive/issue_comments_382486.json:
```json
{
    "body": "**Branch:** [u/jdemeyer/stronger_references_in_cachedrepresentation](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/stronger_references_in_cachedrepresentation)",
    "created_at": "2018-03-12T14:54:14Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382486",
    "user": "https://github.com/jdemeyer"
}
```

**Branch:** [u/jdemeyer/stronger_references_in_cachedrepresentation](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/stronger_references_in_cachedrepresentation)



---

archive/issue_comments_382487.json:
```json
{
    "body": "<a id='comment:13'></a>\nThis is my proof-of-concept implementation. It simply adds strong references to the last 64 objects added to the `CachedWeakValueDictionary`.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/99717eb55a7833b630e5fd0732dc45b2c0b98d8c\">99717eb</a></td><td><code>CachedWeakValueDictionary with strong references to last values</code></td></tr></table>\n",
    "created_at": "2018-03-12T14:57:18Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382487",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:13'></a>
This is my proof-of-concept implementation. It simply adds strong references to the last 64 objects added to the `CachedWeakValueDictionary`.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/99717eb55a7833b630e5fd0732dc45b2c0b98d8c">99717eb</a></td><td><code>CachedWeakValueDictionary with strong references to last values</code></td></tr></table>




---

archive/issue_comments_382488.json:
```json
{
    "body": "**Commit:** [99717eb55a7833b630e5fd0732dc45b2c0b98d8c](https://github.com/sagemath/sagetrac-mirror/commit/99717eb55a7833b630e5fd0732dc45b2c0b98d8c)",
    "created_at": "2018-03-12T14:57:18Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382488",
    "user": "https://github.com/jdemeyer"
}
```

**Commit:** [99717eb55a7833b630e5fd0732dc45b2c0b98d8c](https://github.com/sagemath/sagetrac-mirror/commit/99717eb55a7833b630e5fd0732dc45b2c0b98d8c)



---

archive/issue_comments_382489.json:
```json
{
    "body": "<a id='comment:14'></a>\nThats the obvious solution, keep a finite-length lru cache around.",
    "created_at": "2018-03-12T21:07:55Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382489",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:14'></a>
Thats the obvious solution, keep a finite-length lru cache around.



---

archive/issue_comments_382490.json:
```json
{
    "body": "**Changing commit** from \"[99717eb55a7833b630e5fd0732dc45b2c0b98d8c](https://github.com/sagemath/sagetrac-mirror/commit/99717eb55a7833b630e5fd0732dc45b2c0b98d8c)\" to \"[bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9](https://github.com/sagemath/sagetrac-mirror/commit/bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9)\".",
    "created_at": "2018-03-12T22:11:33Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382490",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[99717eb55a7833b630e5fd0732dc45b2c0b98d8c](https://github.com/sagemath/sagetrac-mirror/commit/99717eb55a7833b630e5fd0732dc45b2c0b98d8c)" to "[bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9](https://github.com/sagemath/sagetrac-mirror/commit/bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9)".



---

archive/issue_comments_382491.json:
```json
{
    "body": "<a id='comment:15'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9\">bd9e368</a></td><td><code>CachedWeakValueDictionary with strong references to last values</code></td></tr></table>\n",
    "created_at": "2018-03-12T22:11:33Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382491",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:15'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9">bd9e368</a></td><td><code>CachedWeakValueDictionary with strong references to last values</code></td></tr></table>




---

archive/issue_events_221089.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2018-03-12T22:13:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/24954#event-221089"
}
```



---

archive/issue_comments_382492.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [vbraun](#comment%3A14):\n> Thats the obvious solution, keep a finite-length lru cache around.\n\n\nI'm not using a LRU cache, but a much simpler FIFO.",
    "created_at": "2018-03-13T09:06:47Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382492",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:17'></a>
Replying to [vbraun](#comment%3A14):
> Thats the obvious solution, keep a finite-length lru cache around.


I'm not using a LRU cache, but a much simpler FIFO.



---

archive/issue_events_221090.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2018-03-15T10:27:01Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/24954#event-221090"
}
```



---

archive/issue_events_221091.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2018-03-15T10:27:01Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/24954#event-221091"
}
```



---

archive/issue_comments_382493.json:
```json
{
    "body": "<a id='comment:19'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a802f12aee11f3b100f82108aacd151e6aad3c80\">a802f12</a></td><td><code>CachedWeakValueDictionary with strong references to last values</code></td></tr></table>\n",
    "created_at": "2018-03-15T10:46:31Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382493",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:19'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a802f12aee11f3b100f82108aacd151e6aad3c80">a802f12</a></td><td><code>CachedWeakValueDictionary with strong references to last values</code></td></tr></table>




---

archive/issue_comments_382494.json:
```json
{
    "body": "**Changing commit** from \"[bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9](https://github.com/sagemath/sagetrac-mirror/commit/bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9)\" to \"[a802f12aee11f3b100f82108aacd151e6aad3c80](https://github.com/sagemath/sagetrac-mirror/commit/a802f12aee11f3b100f82108aacd151e6aad3c80)\".",
    "created_at": "2018-03-15T10:46:31Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382494",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9](https://github.com/sagemath/sagetrac-mirror/commit/bd9e3685f6c34c1d58cc330a97c3f77be1a4cfe9)" to "[a802f12aee11f3b100f82108aacd151e6aad3c80](https://github.com/sagemath/sagetrac-mirror/commit/a802f12aee11f3b100f82108aacd151e6aad3c80)".



---

archive/issue_events_221092.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2018-03-15T10:48:02Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/24954#event-221092"
}
```



---

archive/issue_events_221093.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2018-03-15T10:48:02Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/24954#event-221093"
}
```



---

archive/issue_comments_382495.json:
```json
{
    "body": "<a id='comment:20'></a>\nFixed a few test failures.",
    "created_at": "2018-03-15T10:48:02Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382495",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:20'></a>
Fixed a few test failures.



---

archive/issue_events_221094.json:
```json
{
    "actor": "https://github.com/mezzarobba",
    "created_at": "2018-03-23T13:37:43Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/24954#event-221094"
}
```



---

archive/issue_events_221095.json:
```json
{
    "actor": "https://github.com/mezzarobba",
    "created_at": "2018-03-23T13:37:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/24954#event-221095"
}
```



---

archive/issue_comments_382496.json:
```json
{
    "body": "<a id='comment:21'></a>\nThis solves the issue (random slowdowns in the test suite of `ore_algebra`) that initially led me to the examples mentioned on #24742. And a way to cache the results of the last few calls to a function is something I was missing for other reasons as well.",
    "created_at": "2018-03-23T13:37:43Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382496",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:21'></a>
This solves the issue (random slowdowns in the test suite of `ore_algebra`) that initially led me to the examples mentioned on #24742. And a way to cache the results of the last few calls to a function is something I was missing for other reasons as well.



---

archive/issue_comments_382497.json:
```json
{
    "body": "**Reviewer:** Marc Mezzarobba",
    "created_at": "2018-03-23T13:37:43Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382497",
    "user": "https://github.com/mezzarobba"
}
```

**Reviewer:** Marc Mezzarobba



---

archive/issue_comments_382498.json:
```json
{
    "body": "**Changing branch** from \"[u/jdemeyer/stronger_references_in_cachedrepresentation](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/stronger_references_in_cachedrepresentation)\" to \"[a802f12aee11f3b100f82108aacd151e6aad3c80](https://github.com/sagemath/sagetrac-mirror/commit/a802f12aee11f3b100f82108aacd151e6aad3c80)\".",
    "created_at": "2018-05-12T11:47:43Z",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/24954#issuecomment-382498",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[u/jdemeyer/stronger_references_in_cachedrepresentation](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/stronger_references_in_cachedrepresentation)" to "[a802f12aee11f3b100f82108aacd151e6aad3c80](https://github.com/sagemath/sagetrac-mirror/commit/a802f12aee11f3b100f82108aacd151e6aad3c80)".



---

archive/issue_events_221096.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-05-12T11:47:43Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/24954#event-221096"
}
```



---

archive/issue_events_221097.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-05-12T11:47:43Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/24954",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/24954#event-221097"
}
```
