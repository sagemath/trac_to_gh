# Issue 24911: Implement ordered multiset partitions

archive/issues_024911.json:
```json
{
    "body": "CC:  @tscrim @darijgr @zabrocki @alauve mshimo @anneschilling @saliola amypang\n\nKeywords: IMA coding sprint, CHAs, sagedays@icerm\n\nAn ordered multiset partition C of a multiset X is a list of subsets of X (not multisets),\ncalled the blocks of C, whose multi-union is X.\n\nThese objects appear in the work of \n* [Haglund, Rhoades, Wilson] - arXiv:1509.07058\n* [Haglund, Rhoades, Shimozono] - arXiv:1609.07575\n* [Benkart, et al] - arXiv:1707.08709v2\n* [Lauve, Mastnak] - arXiv:1803.02691\n\nThis module provides tools for manipulating ordered multiset partitions.\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/25148\n\n",
    "closed_at": "2018-09-22T10:22:41Z",
    "created_at": "2018-04-11T16:33:05Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.4",
    "title": "Implement ordered multiset partitions",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/24911",
    "user": "https://github.com/alauve"
}
```
CC:  @tscrim @darijgr @zabrocki @alauve mshimo @anneschilling @saliola amypang

Keywords: IMA coding sprint, CHAs, sagedays@icerm

An ordered multiset partition C of a multiset X is a list of subsets of X (not multisets),
called the blocks of C, whose multi-union is X.

These objects appear in the work of 
* [Haglund, Rhoades, Wilson] - arXiv:1509.07058
* [Haglund, Rhoades, Shimozono] - arXiv:1609.07575
* [Benkart, et al] - arXiv:1707.08709v2
* [Lauve, Mastnak] - arXiv:1803.02691

This module provides tools for manipulating ordered multiset partitions.


Issue created by migration from https://trac.sagemath.org/ticket/25148





---

archive/issue_comments_349891.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to combinatorics.",
    "created_at": "2018-04-11T16:40:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349891",
    "user": "https://github.com/tscrim"
}
```

Changing component from PLEASE CHANGE to combinatorics.



---

archive/issue_comments_349892.json:
```json
{
    "body": "Changing keywords from \"\" to \"IMA coding sprint, CHAs\".",
    "created_at": "2018-04-11T16:40:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349892",
    "user": "https://github.com/tscrim"
}
```

Changing keywords from "" to "IMA coding sprint, CHAs".



---

archive/issue_comments_349893.json:
```json
{
    "body": "Actually, I have the minimaj crystal implemented if you want to add that to this ticket!?",
    "created_at": "2018-04-11T17:53:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349893",
    "user": "https://github.com/anneschilling"
}
```

Actually, I have the minimaj crystal implemented if you want to add that to this ticket!?



---

archive/issue_comments_349894.json:
```json
{
    "body": "Yes, that would be great. Do you want to add it onto the current code or attach (or email me) the file with the implementation?",
    "created_at": "2018-04-11T17:56:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349894",
    "user": "https://github.com/tscrim"
}
```

Yes, that would be great. Do you want to add it onto the current code or attach (or email me) the file with the implementation?



---

archive/issue_comments_349895.json:
```json
{
    "body": "Here is my code, but I have not recently checked it:\n\n```\ndef multiset_partitions(k,ell,n):\n    \"\"\"\n    Return the set of all multiset partitions with `k` parts\n    of words of length `ell` on the alphabet `[1,2,...,n]`.\n\n    EXAMPLES::\n\n         sage: multiset_partitions(2,3,3)\n         [({1, 2}, {1}),\n         ({1, 2}, {2}),\n         ({1, 2}, {3}),\n         ({1, 3}, {1}),\n         ({1, 3}, {2}),\n         ({1, 3}, {3}),\n         ({2, 3}, {1}),\n         ({2, 3}, {2}),\n         ({2, 3}, {3}),\n         ({1}, {1, 2}),\n         ({1}, {1, 3}),\n         ({1}, {2, 3}),\n         ({2}, {1, 2}),\n         ({2}, {1, 3}),\n         ({2}, {2, 3}),\n         ({3}, {1, 2}),\n         ({3}, {1, 3}),\n         ({3}, {2, 3})]\n    \"\"\"\n    E = range(1,n+1)\n    return DisjointUnionEnumeratedSets(Family(Compositions(ell,length=k),\n                                              lambda I: cartesian_product( [Subsets(E,i) for i in I] ))).list()\n\ndef greedy(b):\n    \"\"\"\n    Return greedy algorithm on `b`.\n\n    EXAMPLES::\n\n        sage: b=multiset_partitions(2,3,3)[0]; b\n        ({1, 2}, {1})\n        sage: greedy(b)\n        [[2, 1], [1]]\n    \"\"\"\n    l = len(b.cartesian_factors())\n    c = tuple([tuple(sorted(b[l-1]))])\n    for i in range(l-2,-1,-1):\n        lower = sorted([j for j in b[i] if j<=c[0][0]])\n        upper = sorted([j for j in b[i] if j>c[0][0]])\n        c = tuple([tuple(upper+lower)])+c\n    return c\n\ndef minimaj_ordering(b):\n    \"\"\"\n    Return minimaj ordering of `b`, where `b` is an element in decreasing order within blocks.\n\n    EXAMPLES::\n\n        sage: b = [[3, 1, 2], [2, 3]]\n        sage: minimaj_ordering(b)\n        [[3, 1, 2], [2, 3]]\n        sage: b=[[2,3],[2],[1,3]]\n        sage: minimaj_ordering(b)\n        ((3, 2), (2,), (1, 3))\n    \"\"\"\n    result = [tuple(sorted(b[-1]))]\n    for i in range(len(b)-2,-1,-1):\n        m = result[0][0]\n        result = [tuple(sorted([j for j in b[i] if j>m])+sorted([j for j in b[i] if j<=m]))] + result\n    return tuple(result)\n\ndef minimaj(b):\n    \"\"\"\n    Return minimaj of `b`.\n\n    EXAMPLES::\n\n        sage: S = crystal_elements(2,5,3)\n        sage: [minimaj(b) for b in S]\n        [2, 2, 1, 1, 1, 2]\n    \"\"\"\n    return Word(flatten(minimaj_ordering(b))).major_index()\n        \n\ndef crystal_elements(k,ell,n):\n    \"\"\"\n    Return list of crystal elements with `ell` letters from alphabet `\\{1,2,...,n\\}`\n    divided into `k` blocks.\n\n    EXAMPLES::\n\n        sage: crystal_elements(2,3,2)\n        (((2, 1), (1,)), ((1, 2), (2,)), ((1,), (1, 2)), ((2,), (1, 2)))\n    \"\"\"\n    M = multiset_partitions(k,ell,n)\n    return tuple([tuple(greedy(b)) for b in M])\n\ndef partial_sum(list):\n    \"\"\"\n    Return partial sums of elements in `list`.\n\n    EXAMPLES::\n\n        sage: list = [1,3,5]\n        sage: partial_sum(list)\n        [0, 1, 4, 9]\n    \"\"\"\n    result = [0]\n    for i in range(len(list)):\n        result += [result[-1]+list[i]]\n    return result\n\ndef which_block(partial, p):\n    \"\"\"\n    Return which block position `p` belongs to.\n\n    EXAMPLES::\n\n        sage: which_block([0,3,5,6],4)\n        1\n        sage: which_block([0,3,5,6],5)\n        2\n        sage: which_block([0,3,5,6],6)\n        2\n    \"\"\"\n    i=0\n    while p >= partial[i+1] and i<len(partial)-2:\n        i += 1\n    return i\n\ndef descents(mu):\n    \"\"\"\n    Return descents of minimaj word ``mu``.\n\n    EXAMPLES::\n\n        sage: mu = ((1,2,4),(4,5),(3,),(4,6,1),(2,3,1),(1,),(2,5))\n        sage: descents(mu)\n        [4, 7, 10]\n    \"\"\"\n    w = flatten(mu)\n    return [i for i in range(len(w)-1) if w[i]>w[i+1]]\n\ndef to_tableau(mu):\n    \"\"\"\n    Return bijection from minimaj words to sequence of tableaux.\n\n    EXAMPLES::\n\n        sage: mu = ((1,2,4),(4,5),(3,),(4,6,1),(2,3,1),(1,),(2,5))\n        sage: to_tableau(mu)\n        [[5, 1], [3, 1], [6], [5, 4, 2], [1, 4, 3, 4, 2, 1, 2]]\n    \"\"\"\n    b = [mu[i][0] for i in range(len(mu))]\n    beginning = partial_sum([len(mu[i]) for i in range(len(mu))])\n    w = flatten(mu)\n    D = [0]+descents(mu)+[len(w)]\n    pieces = [b]\n    for i in range(len(D)-1):\n        p = [w[j] for j in range(D[i]+1,D[i+1]+1) if j not in beginning]\n        pieces = [p[::-1]] + pieces\n    return pieces\n\ndef from_tableau(t):\n    \"\"\"\n    Return minimaj word from sequence of tableaux.\n\n    EXAMPLES::\n\n        sage: all(mu == from_tableau(to_tableau(mu)) for mu in crystal_elements(3,6,3))    \n        True\n    \"\"\"\n    mu = [(i,) for i in t[-1]]\n    breaks = [0]+descents(t[-1])+[len(mu)-1]\n    t = [t[i][::-1] for i in range(len(t)-1)][::-1]\n    for f in range(len(breaks)-1):\n        for j in range(breaks[f],breaks[f+1]+1):\n            mu[j] += tuple(i for i in t[f] if (mu[j][0]<i or j==breaks[f]) and (j==breaks[f+1] or i<=mu[j+1][0]))\n    return tuple(mu)\n\ndef val(k,n,r):\n    \"\"\"\n    Return val polynomials.\n\n    \"\"\"\n    M = MinimajCrystal(k,n,r)\n    H = [t for t in M if t.is_highest_weight()]\n    Sym = SymmetricFunctions(QQ['q'])\n    q = Sym.base_ring().gens()[0]\n    s = Sym.schur()\n    return sum((q**(minimaj(t.value))*s[[flatten(t.value).count(i) for i in range(1,r+1)]] for t in H), Sym.zero())\n    \n\nclass MinimajCrystal(UniqueRepresentation, Parent):\n\n    def __init__(self, k, ell, n):\n        Parent.__init__(self, category = ClassicalCrystals())\n        self.n = n\n        self.k = k\n        self.ell = ell\n        self._cartan_type = CartanType(['A',n-1])\n        self.module_generators = [ self(b) for b in crystal_elements(k,ell,n) ]\n\n    def _repr_(self):\n        \"\"\"\n        EXAMPLES::\n\n            sage: B = MinimajCrystal(2,4,3); B\n            Minimaj Crystal of type A_3 of words of length 4 into 2 blocks\n        \"\"\"\n        return \"Minimaj Crystal of type A_%s of words of length %s into %s blocks\"%(self.n-1, self.ell, self.k)\n\n    # temporary workaround while an_element is overriden by Parent\n    _an_element_ = EnumeratedSets.ParentMethods._an_element_\n\n    class Element(ElementWrapper):\n\n        def e(self,i):\n            t = to_tableau(self.value)\n            B = crystals.Tableaux(['A',self.parent().n-1],shape=[1])\n            T = tensor([B]*self.parent().ell)\n            blocks = [len(h) for h in t]\n            partial = partial_sum(blocks)\n            b = T(*[B(a) for a in flatten(t)])\n            if b.e(i) is None:\n                return None\n            b = b.e(i)\n            b = [[b[a].to_tableau()[0][0] for a in range(partial[j],partial[j+1])] for j in range(len(partial)-1)]\n            return self.parent()(from_tableau(b))\n\n        def f(self,i):\n            \"\"\"\n            Return `f_i` on ``self``.\n\n            EXAMPLES::\n\n                sage: B = MinimajCrystal(2,4,3)\n                sage: b = B.an_element(); b\n                ((2, 3, 1), (1,))\n                sage: b.f(1)\n                ((2, 3), (1, 2))\n            \"\"\"\n            t = to_tableau(self.value)\n            B = crystals.Tableaux(['A',self.parent().n-1],shape=[1])\n            T = tensor([B]*self.parent().ell)\n            blocks = [len(h) for h in t]\n            partial = partial_sum(blocks)\n            b = T(*[B(a) for a in flatten(t)])\n            if b.f(i) is None:\n                return None\n            b = b.f(i)\n            b = [[b[a].to_tableau()[0][0] for a in range(partial[j],partial[j+1])] for j in range(len(partial)-1)]\n            return self.parent()(from_tableau(b))\n```",
    "created_at": "2018-04-11T18:02:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349895",
    "user": "https://github.com/anneschilling"
}
```

Here is my code, but I have not recently checked it:

```
def multiset_partitions(k,ell,n):
    """
    Return the set of all multiset partitions with `k` parts
    of words of length `ell` on the alphabet `[1,2,...,n]`.

    EXAMPLES::

         sage: multiset_partitions(2,3,3)
         [({1, 2}, {1}),
         ({1, 2}, {2}),
         ({1, 2}, {3}),
         ({1, 3}, {1}),
         ({1, 3}, {2}),
         ({1, 3}, {3}),
         ({2, 3}, {1}),
         ({2, 3}, {2}),
         ({2, 3}, {3}),
         ({1}, {1, 2}),
         ({1}, {1, 3}),
         ({1}, {2, 3}),
         ({2}, {1, 2}),
         ({2}, {1, 3}),
         ({2}, {2, 3}),
         ({3}, {1, 2}),
         ({3}, {1, 3}),
         ({3}, {2, 3})]
    """
    E = range(1,n+1)
    return DisjointUnionEnumeratedSets(Family(Compositions(ell,length=k),
                                              lambda I: cartesian_product( [Subsets(E,i) for i in I] ))).list()

def greedy(b):
    """
    Return greedy algorithm on `b`.

    EXAMPLES::

        sage: b=multiset_partitions(2,3,3)[0]; b
        ({1, 2}, {1})
        sage: greedy(b)
        [[2, 1], [1]]
    """
    l = len(b.cartesian_factors())
    c = tuple([tuple(sorted(b[l-1]))])
    for i in range(l-2,-1,-1):
        lower = sorted([j for j in b[i] if j<=c[0][0]])
        upper = sorted([j for j in b[i] if j>c[0][0]])
        c = tuple([tuple(upper+lower)])+c
    return c

def minimaj_ordering(b):
    """
    Return minimaj ordering of `b`, where `b` is an element in decreasing order within blocks.

    EXAMPLES::

        sage: b = [[3, 1, 2], [2, 3]]
        sage: minimaj_ordering(b)
        [[3, 1, 2], [2, 3]]
        sage: b=[[2,3],[2],[1,3]]
        sage: minimaj_ordering(b)
        ((3, 2), (2,), (1, 3))
    """
    result = [tuple(sorted(b[-1]))]
    for i in range(len(b)-2,-1,-1):
        m = result[0][0]
        result = [tuple(sorted([j for j in b[i] if j>m])+sorted([j for j in b[i] if j<=m]))] + result
    return tuple(result)

def minimaj(b):
    """
    Return minimaj of `b`.

    EXAMPLES::

        sage: S = crystal_elements(2,5,3)
        sage: [minimaj(b) for b in S]
        [2, 2, 1, 1, 1, 2]
    """
    return Word(flatten(minimaj_ordering(b))).major_index()
        

def crystal_elements(k,ell,n):
    """
    Return list of crystal elements with `ell` letters from alphabet `\{1,2,...,n\}`
    divided into `k` blocks.

    EXAMPLES::

        sage: crystal_elements(2,3,2)
        (((2, 1), (1,)), ((1, 2), (2,)), ((1,), (1, 2)), ((2,), (1, 2)))
    """
    M = multiset_partitions(k,ell,n)
    return tuple([tuple(greedy(b)) for b in M])

def partial_sum(list):
    """
    Return partial sums of elements in `list`.

    EXAMPLES::

        sage: list = [1,3,5]
        sage: partial_sum(list)
        [0, 1, 4, 9]
    """
    result = [0]
    for i in range(len(list)):
        result += [result[-1]+list[i]]
    return result

def which_block(partial, p):
    """
    Return which block position `p` belongs to.

    EXAMPLES::

        sage: which_block([0,3,5,6],4)
        1
        sage: which_block([0,3,5,6],5)
        2
        sage: which_block([0,3,5,6],6)
        2
    """
    i=0
    while p >= partial[i+1] and i<len(partial)-2:
        i += 1
    return i

def descents(mu):
    """
    Return descents of minimaj word ``mu``.

    EXAMPLES::

        sage: mu = ((1,2,4),(4,5),(3,),(4,6,1),(2,3,1),(1,),(2,5))
        sage: descents(mu)
        [4, 7, 10]
    """
    w = flatten(mu)
    return [i for i in range(len(w)-1) if w[i]>w[i+1]]

def to_tableau(mu):
    """
    Return bijection from minimaj words to sequence of tableaux.

    EXAMPLES::

        sage: mu = ((1,2,4),(4,5),(3,),(4,6,1),(2,3,1),(1,),(2,5))
        sage: to_tableau(mu)
        [[5, 1], [3, 1], [6], [5, 4, 2], [1, 4, 3, 4, 2, 1, 2]]
    """
    b = [mu[i][0] for i in range(len(mu))]
    beginning = partial_sum([len(mu[i]) for i in range(len(mu))])
    w = flatten(mu)
    D = [0]+descents(mu)+[len(w)]
    pieces = [b]
    for i in range(len(D)-1):
        p = [w[j] for j in range(D[i]+1,D[i+1]+1) if j not in beginning]
        pieces = [p[::-1]] + pieces
    return pieces

def from_tableau(t):
    """
    Return minimaj word from sequence of tableaux.

    EXAMPLES::

        sage: all(mu == from_tableau(to_tableau(mu)) for mu in crystal_elements(3,6,3))    
        True
    """
    mu = [(i,) for i in t[-1]]
    breaks = [0]+descents(t[-1])+[len(mu)-1]
    t = [t[i][::-1] for i in range(len(t)-1)][::-1]
    for f in range(len(breaks)-1):
        for j in range(breaks[f],breaks[f+1]+1):
            mu[j] += tuple(i for i in t[f] if (mu[j][0]<i or j==breaks[f]) and (j==breaks[f+1] or i<=mu[j+1][0]))
    return tuple(mu)

def val(k,n,r):
    """
    Return val polynomials.

    """
    M = MinimajCrystal(k,n,r)
    H = [t for t in M if t.is_highest_weight()]
    Sym = SymmetricFunctions(QQ['q'])
    q = Sym.base_ring().gens()[0]
    s = Sym.schur()
    return sum((q**(minimaj(t.value))*s[[flatten(t.value).count(i) for i in range(1,r+1)]] for t in H), Sym.zero())
    

class MinimajCrystal(UniqueRepresentation, Parent):

    def __init__(self, k, ell, n):
        Parent.__init__(self, category = ClassicalCrystals())
        self.n = n
        self.k = k
        self.ell = ell
        self._cartan_type = CartanType(['A',n-1])
        self.module_generators = [ self(b) for b in crystal_elements(k,ell,n) ]

    def _repr_(self):
        """
        EXAMPLES::

            sage: B = MinimajCrystal(2,4,3); B
            Minimaj Crystal of type A_3 of words of length 4 into 2 blocks
        """
        return "Minimaj Crystal of type A_%s of words of length %s into %s blocks"%(self.n-1, self.ell, self.k)

    # temporary workaround while an_element is overriden by Parent
    _an_element_ = EnumeratedSets.ParentMethods._an_element_

    class Element(ElementWrapper):

        def e(self,i):
            t = to_tableau(self.value)
            B = crystals.Tableaux(['A',self.parent().n-1],shape=[1])
            T = tensor([B]*self.parent().ell)
            blocks = [len(h) for h in t]
            partial = partial_sum(blocks)
            b = T(*[B(a) for a in flatten(t)])
            if b.e(i) is None:
                return None
            b = b.e(i)
            b = [[b[a].to_tableau()[0][0] for a in range(partial[j],partial[j+1])] for j in range(len(partial)-1)]
            return self.parent()(from_tableau(b))

        def f(self,i):
            """
            Return `f_i` on ``self``.

            EXAMPLES::

                sage: B = MinimajCrystal(2,4,3)
                sage: b = B.an_element(); b
                ((2, 3, 1), (1,))
                sage: b.f(1)
                ((2, 3), (1, 2))
            """
            t = to_tableau(self.value)
            B = crystals.Tableaux(['A',self.parent().n-1],shape=[1])
            T = tensor([B]*self.parent().ell)
            blocks = [len(h) for h in t]
            partial = partial_sum(blocks)
            b = T(*[B(a) for a in flatten(t)])
            if b.f(i) is None:
                return None
            b = b.f(i)
            b = [[b[a].to_tableau()[0][0] for a in range(partial[j],partial[j+1])] for j in range(len(partial)-1)]
            return self.parent()(from_tableau(b))
```



---

archive/issue_comments_349896.json:
```json
{
    "body": "Thank you.",
    "created_at": "2018-04-11T18:06:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349896",
    "user": "https://github.com/tscrim"
}
```

Thank you.



---

archive/issue_comments_349897.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-04-12T22:49:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349897",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349898.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-04-19T22:57:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349898",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349899.json:
```json
{
    "body": "general query. which is better?:\n\n```\n-    if isinstance(n_or_OMPs, (int, Integer)):\n+    if n_or_OMPs in ZZ:\n```\n\nThe former does not catch `x` in the result of the following block of code.\n\n```\nx = 4\nx = x/3\nx = 6*x\ntype(x)\nisinstance(x, (int, Integer))\nx in ZZ\n```\nBut perhaps there are speed reasons to choose `isinstance`?",
    "created_at": "2018-04-19T23:01:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349899",
    "user": "https://github.com/alauve"
}
```

general query. which is better?:

```
-    if isinstance(n_or_OMPs, (int, Integer)):
+    if n_or_OMPs in ZZ:
```

The former does not catch `x` in the result of the following block of code.

```
x = 4
x = x/3
x = 6*x
type(x)
isinstance(x, (int, Integer))
x in ZZ
```
But perhaps there are speed reasons to choose `isinstance`?



---

archive/issue_comments_349900.json:
```json
{
    "body": "The former does not include `4/2` (which is a `Rational`).",
    "created_at": "2018-04-19T23:10:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349900",
    "user": "https://github.com/tscrim"
}
```

The former does not include `4/2` (which is a `Rational`).



---

archive/issue_comments_349901.json:
```json
{
    "body": "Thanks, Anna.\nfor review purposes, I think it's best to implement crystal structure via a new ticket. (Anyway, you take very different slices than I do in your definition of `multiset_partitions`, so it's not entirely straightforward for me.) Look for a new ticket and branch early next week.\n\nReplying to [comment:7 aschilling]:\n> Here is my code, but I have not recently checked it:\n\n...",
    "created_at": "2018-04-20T04:19:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349901",
    "user": "https://github.com/alauve"
}
```

Thanks, Anna.
for review purposes, I think it's best to implement crystal structure via a new ticket. (Anyway, you take very different slices than I do in your definition of `multiset_partitions`, so it's not entirely straightforward for me.) Look for a new ticket and branch early next week.

Replying to [comment:7 aschilling]:
> Here is my code, but I have not recently checked it:

...



---

archive/issue_comments_349902.json:
```json
{
    "body": "Hi Aaron,\n\nI would be happy to help to get this crystal code into sage. But you think it will be \"easy\" to put it on top of your code for ordered multiset partitions?\n\nBest,\n\nAnne\n\nReplying to [comment:13 alauve]:\n> Thanks, Anna.\n> for review purposes, I think it's best to implement crystal structure via a new ticket. (Anyway, you take very different slices than I do in your definition of `multiset_partitions`, so it's not entirely straightforward for me.) Look for a new ticket and branch early next week.\n> \n> Replying to [comment:7 aschilling]:\n> > Here is my code, but I have not recently checked it:\n\n> ...",
    "created_at": "2018-04-20T13:15:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349902",
    "user": "https://github.com/anneschilling"
}
```

Hi Aaron,

I would be happy to help to get this crystal code into sage. But you think it will be "easy" to put it on top of your code for ordered multiset partitions?

Best,

Anne

Replying to [comment:13 alauve]:
> Thanks, Anna.
> for review purposes, I think it's best to implement crystal structure via a new ticket. (Anyway, you take very different slices than I do in your definition of `multiset_partitions`, so it's not entirely straightforward for me.) Look for a new ticket and branch early next week.
> 
> Replying to [comment:7 aschilling]:
> > Here is my code, but I have not recently checked it:

> ...



---

archive/issue_comments_349903.json:
```json
{
    "body": "I wouldn't say \"easy,\" but feasible. For my ultimate purpose (a free, graded Hopf algebra on finite subsets of NN), it would be nice to have finite dimensional slices. I couldn't think of a better way to do this than grading by total sum of entries. This makes your `e` and `f` operators **not** graded morphisms, but that shouldn't be an issue.\n\nTravis suggested adding `e` and `f` operators and crystal functionality as done in `shifted_primed_tableau.py` specifically, `ShiftedPrimedTableaux_shape`.\n\nGive me a day or two to tackle it.",
    "created_at": "2018-04-20T14:29:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349903",
    "user": "https://github.com/alauve"
}
```

I wouldn't say "easy," but feasible. For my ultimate purpose (a free, graded Hopf algebra on finite subsets of NN), it would be nice to have finite dimensional slices. I couldn't think of a better way to do this than grading by total sum of entries. This makes your `e` and `f` operators **not** graded morphisms, but that shouldn't be an issue.

Travis suggested adding `e` and `f` operators and crystal functionality as done in `shifted_primed_tableau.py` specifically, `ShiftedPrimedTableaux_shape`.

Give me a day or two to tackle it.



---

archive/issue_comments_349904.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-15T17:38:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349904",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349905.json:
```json
{
    "body": "Essentially starting over with this ticket...\n\nIn the use of Benkart, et al., it is natural to call e.g.,\n`OrderedMultisetPartitions([2,4], 3)` or (resp.) `OrderedMultisetPartitions([2,4], 3, length=2)`\nto return the ordered multiset partitions on alphabet {2,4} with 3 total integers used (resp., and with two blocks).\n\nIn the use for a forthcoming combinatorial Hopf algebra, it is natural to call, e.g.,\n`OrderedMultisetPartitions(4)` to return all ordered multiset partitions whose sum (across all blocks) is 4.\n\nIn fact, neither of these make as much sense as as the use\n`OrderedMultisetPartitions([1,1,3,4,4,4])` or (resp.) `OrderedMultisetPartitions([1,1,3,4,4,4], length=3)`\nto return the ordered multiset partitions of the multiset {{1,1,3,4,4,4}} (resp. into two blocks).\n\nSo I have implemented all of these different uses, and added constraints as well, so one can call, e.g.,\n\n```\nsage: OrderedMultisetPartitions([2,3,4], 4, max_length=3)\nsage: OrderedMultisetPartitions(8, alphabet=[2,4], min_length=3, max_order=4)\n```\netc.\n\nI still need to implement the crystal operators from Anne's comment:7.",
    "created_at": "2018-05-15T17:48:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349905",
    "user": "https://github.com/alauve"
}
```

Essentially starting over with this ticket...

In the use of Benkart, et al., it is natural to call e.g.,
`OrderedMultisetPartitions([2,4], 3)` or (resp.) `OrderedMultisetPartitions([2,4], 3, length=2)`
to return the ordered multiset partitions on alphabet {2,4} with 3 total integers used (resp., and with two blocks).

In the use for a forthcoming combinatorial Hopf algebra, it is natural to call, e.g.,
`OrderedMultisetPartitions(4)` to return all ordered multiset partitions whose sum (across all blocks) is 4.

In fact, neither of these make as much sense as as the use
`OrderedMultisetPartitions([1,1,3,4,4,4])` or (resp.) `OrderedMultisetPartitions([1,1,3,4,4,4], length=3)`
to return the ordered multiset partitions of the multiset {{1,1,3,4,4,4}} (resp. into two blocks).

So I have implemented all of these different uses, and added constraints as well, so one can call, e.g.,

```
sage: OrderedMultisetPartitions([2,3,4], 4, max_length=3)
sage: OrderedMultisetPartitions(8, alphabet=[2,4], min_length=3, max_order=4)
```
etc.

I still need to implement the crystal operators from Anne's comment:7.



---

archive/issue_comments_349906.json:
```json
{
    "body": "I have to say I fell down a rabbit hole and may not have worked my way out of it... \n\nIf somebody could comment on how best to handle constraints to a class (e.g., like `max_length` or `max_block_size` for `SetPartitions`) before I get too much farther, I'd appreciate it.",
    "created_at": "2018-05-15T17:54:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349906",
    "user": "https://github.com/alauve"
}
```

I have to say I fell down a rabbit hole and may not have worked my way out of it... 

If somebody could comment on how best to handle constraints to a class (e.g., like `max_length` or `max_block_size` for `SetPartitions`) before I get too much farther, I'd appreciate it.



---

archive/issue_comments_349907.json:
```json
{
    "body": "Hi Aaron,\n\nPerhaps it would help to see how constraints are handled in other classes? See for example `Compositions` or `IntegerVectors`. For example, you can specify various parameters for `IntegerVectors`\n\n```\nsage: IntegerVectors(7,2,min_part=2).list()\n[[5, 2], [4, 3], [3, 4], [2, 5]]\nsage: IntegerVectors(7,min_part=2).list()\n[[7], [5, 2], [4, 3], [3, 4], [3, 2, 2], [2, 5], [2, 3, 2], [2, 2, 3]]\n```\n\nBest,\n\nAnne",
    "created_at": "2018-05-16T16:39:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349907",
    "user": "https://github.com/anneschilling"
}
```

Hi Aaron,

Perhaps it would help to see how constraints are handled in other classes? See for example `Compositions` or `IntegerVectors`. For example, you can specify various parameters for `IntegerVectors`

```
sage: IntegerVectors(7,2,min_part=2).list()
[[5, 2], [4, 3], [3, 4], [2, 5]]
sage: IntegerVectors(7,min_part=2).list()
[[7], [5, 2], [4, 3], [3, 4], [3, 2, 2], [2, 5], [2, 3, 2], [2, 2, 3]]
```

Best,

Anne



---

archive/issue_comments_349908.json:
```json
{
    "body": "Thanks for the `IntegerVectors` tip, Anne. I had looked at `Compositions` but didn't like how it passed things off to `IntegerListsLex` (and wasn't sure I understood everything happening there).\n\nIt looks like wasn't too far off on the basic structure. I should have further by end of weekend.",
    "created_at": "2018-05-16T17:10:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349908",
    "user": "https://github.com/alauve"
}
```

Thanks for the `IntegerVectors` tip, Anne. I had looked at `Compositions` but didn't like how it passed things off to `IntegerListsLex` (and wasn't sure I understood everything happening there).

It looks like wasn't too far off on the basic structure. I should have further by end of weekend.



---

archive/issue_comments_349909.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-16T17:49:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349909",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349910.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-17T13:59:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349910",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349911.json:
```json
{
    "body": "*Remark:* I lot of the commits above are effectively empty because I took \"HEAD\" each time when resolving conflicts while rebasing from current development branch. (One could safely ignore all of the above and wait for me to add `e` and `f` operators later this week before taking a look.)",
    "created_at": "2018-05-17T14:11:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349911",
    "user": "https://github.com/alauve"
}
```

*Remark:* I lot of the commits above are effectively empty because I took "HEAD" each time when resolving conflicts while rebasing from current development branch. (One could safely ignore all of the above and wait for me to add `e` and `f` operators later this week before taking a look.)



---

archive/issue_comments_349912.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-21T19:02:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349912",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349913.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-21T19:30:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349913",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349914.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-21T21:54:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349914",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349915.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-22T01:16:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349915",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349916.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-22T17:39:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349916",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349917.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-22T18:26:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349917",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349918.json:
```json
{
    "body": "Anne,\nCould you have a look at this branch now? I think the crystal code is in decent shape.\n\nAnybody,\nCould you explain why the following two different blocks of code behave differently?\n\n```\n      sage: O1 = OrderedMultisetPartitions(weight=[2,1])\n      sage: list(O1) # maximum recursion depth exceded\n```\n\n```\n      sage: O2 = OrderedMultisetPartitions(weight=[2,0,1])\n      sage: O2.list()\n      [[{1}, {1}, {3}], [{1}, {1,3}], [{1}, {3}, {1}], [{1,3}, {1}], [{3}, {1}, {1}]]\n      sage: list(O2)\n      [[{1}, {1}, {3}], [{1}, {1,3}], [{1}, {3}, {1}], [{1,3}, {1}], [{3}, {1}, {1}]]\n```",
    "created_at": "2018-05-22T18:32:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349918",
    "user": "https://github.com/alauve"
}
```

Anne,
Could you have a look at this branch now? I think the crystal code is in decent shape.

Anybody,
Could you explain why the following two different blocks of code behave differently?

```
      sage: O1 = OrderedMultisetPartitions(weight=[2,1])
      sage: list(O1) # maximum recursion depth exceded
```

```
      sage: O2 = OrderedMultisetPartitions(weight=[2,0,1])
      sage: O2.list()
      [[{1}, {1}, {3}], [{1}, {1,3}], [{1}, {3}, {1}], [{1,3}, {1}], [{3}, {1}, {1}]]
      sage: list(O2)
      [[{1}, {1}, {3}], [{1}, {1,3}], [{1}, {3}, {1}], [{1,3}, {1}], [{3}, {1}, {1}]]
```



---

archive/issue_comments_349919.json:
```json
{
    "body": "I don't know the code well enough, but there is a certain code smell that might well hint at the underlying issue. Here:\n\n```\n+        P = OrderedMultisetPartitions(multiset)\n```\nyou're using the duck-typing factory class `OrderedMultisetPartitions`. Are you sure your `multiset` will actually be understood as a multiset?\nSimilarly, here\n\n```\n+            for alpha in Permutations(multiset):\n```\nyou're using `Permutations`; the right class to use here is `Permutations.mset` from `.permutations`.\n\nAlso, I have the impression that the `multiset` method on your class leaks mutable internal data (namely, `self._multiset` which, contrary to its name, is a list).\n\nFinally, I think \"list of subsets\" should be \"list of nonempty subsets\" everywhere in the doc, or is it not so?",
    "created_at": "2018-05-22T19:18:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349919",
    "user": "https://github.com/darijgr"
}
```

I don't know the code well enough, but there is a certain code smell that might well hint at the underlying issue. Here:

```
+        P = OrderedMultisetPartitions(multiset)
```
you're using the duck-typing factory class `OrderedMultisetPartitions`. Are you sure your `multiset` will actually be understood as a multiset?
Similarly, here

```
+            for alpha in Permutations(multiset):
```
you're using `Permutations`; the right class to use here is `Permutations.mset` from `.permutations`.

Also, I have the impression that the `multiset` method on your class leaks mutable internal data (namely, `self._multiset` which, contrary to its name, is a list).

Finally, I think "list of subsets" should be "list of nonempty subsets" everywhere in the doc, or is it not so?



---

archive/issue_comments_349920.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-22T21:01:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349920",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349921.json:
```json
{
    "body": "Replying to [comment:31 gh-darijgr]:\n> I don't know the code well enough, but there is a certain code smell that might well hint at the underlying issue. Here:\n> \n> ```\n> +        P = OrderedMultisetPartitions(multiset)\n> ```\n> you're using the duck-typing factory class `OrderedMultisetPartitions`. Are you sure your `multiset` will actually be understood as a multiset?\n\n\nPretty sure... not //definite.//\n\n> Similarly, here\n> \n> ```\n> +            for alpha in Permutations(multiset):\n> ```\n> you're using `Permutations`; the right class to use here is `Permutations.mset` from `.permutations`.\n\n\nThanks, Darij\n\n> \n> Also, I have the impression that the `multiset` method on your class leaks mutable internal data (namely, `self._multiset` which, contrary to its name, is a list).\n\n\nUnfortunately, moving things to `tuples` instead of `lists` did not solve the problem. But I suppose tuples are best, so made this change.\n \n> Finally, I think \"list of subsets\" should be \"list of nonempty subsets\" everywhere in the doc, or is it not so?\n\n\nCorrect (and corrected).",
    "created_at": "2018-05-22T21:04:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349921",
    "user": "https://github.com/alauve"
}
```

Replying to [comment:31 gh-darijgr]:
> I don't know the code well enough, but there is a certain code smell that might well hint at the underlying issue. Here:
> 
> ```
> +        P = OrderedMultisetPartitions(multiset)
> ```
> you're using the duck-typing factory class `OrderedMultisetPartitions`. Are you sure your `multiset` will actually be understood as a multiset?


Pretty sure... not //definite.//

> Similarly, here
> 
> ```
> +            for alpha in Permutations(multiset):
> ```
> you're using `Permutations`; the right class to use here is `Permutations.mset` from `.permutations`.


Thanks, Darij

> 
> Also, I have the impression that the `multiset` method on your class leaks mutable internal data (namely, `self._multiset` which, contrary to its name, is a list).


Unfortunately, moving things to `tuples` instead of `lists` did not solve the problem. But I suppose tuples are best, so made this change.
 
> Finally, I think "list of subsets" should be "list of nonempty subsets" everywhere in the doc, or is it not so?


Correct (and corrected).



---

archive/issue_comments_349922.json:
```json
{
    "body": "What happens if you replace\n\n```\nP = OrderedMultisetPartitions(multiset)\n```\nby\n\n```\nP = OrderedMultisetPartitions(weight=multiset)\n```\n?",
    "created_at": "2018-05-22T21:12:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349922",
    "user": "https://github.com/darijgr"
}
```

What happens if you replace

```
P = OrderedMultisetPartitions(multiset)
```
by

```
P = OrderedMultisetPartitions(weight=multiset)
```
?



---

archive/issue_comments_349923.json:
```json
{
    "body": "calling without a keyword:\n\n```\nsage: P1 = OrderedMultisetPartitions([1,1,4]); P1.list()\n[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]\nsage: P2 = OrderedMultisetPartitions({1:2, 4:1}); P2.list()\n[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]\n```\nversus calling with a keyword:\n\n```\nsage: P3 = OrderedMultisetPartitions(weight=[2,0,0,1]); P3.list()\n[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]\nsage: P4 = OrderedMultisetPartitions(weight={1:2, 4:1}); P4.list()\n[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]\nsage: P5 = OrderedMultisetPartitions(weight=((1,2), (4,1))); P5.list()\n[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]\n```\none exception: something that looks like a dictionary but isn't gets treated incorrectly:\n\n```\nsage: P6 = OrderedMultisetPartitions(((1,2), (4,1))); P6.list()\n[[{(1,2)}, {(4,1)}], [{(1,2),(4,1)}], [{(4,1)}, {(1,2)}]]\n```\n\n(but I'm not using syntax like P6 anywhere)",
    "created_at": "2018-05-22T21:24:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349923",
    "user": "https://github.com/alauve"
}
```

calling without a keyword:

```
sage: P1 = OrderedMultisetPartitions([1,1,4]); P1.list()
[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]
sage: P2 = OrderedMultisetPartitions({1:2, 4:1}); P2.list()
[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]
```
versus calling with a keyword:

```
sage: P3 = OrderedMultisetPartitions(weight=[2,0,0,1]); P3.list()
[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]
sage: P4 = OrderedMultisetPartitions(weight={1:2, 4:1}); P4.list()
[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]
sage: P5 = OrderedMultisetPartitions(weight=((1,2), (4,1))); P5.list()
[[{1}, {1}, {4}], [{1}, {1,4}], [{1}, {4}, {1}], [{1,4}, {1}], [{4}, {1}, {1}]]
```
one exception: something that looks like a dictionary but isn't gets treated incorrectly:

```
sage: P6 = OrderedMultisetPartitions(((1,2), (4,1))); P6.list()
[[{(1,2)}, {(4,1)}], [{(1,2),(4,1)}], [{(4,1)}, {(1,2)}]]
```

(but I'm not using syntax like P6 anywhere)



---

archive/issue_comments_349924.json:
```json
{
    "body": "I meant, what if you change the code itself and check for your recursion-depth bug again?",
    "created_at": "2018-05-22T21:26:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349924",
    "user": "https://github.com/darijgr"
}
```

I meant, what if you change the code itself and check for your recursion-depth bug again?



---

archive/issue_comments_349925.json:
```json
{
    "body": "Hmm... well something different happened (including an error!). I'll take a deeper look and report back.",
    "created_at": "2018-05-22T21:38:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349925",
    "user": "https://github.com/alauve"
}
```

Hmm... well something different happened (including an error!). I'll take a deeper look and report back.



---

archive/issue_comments_349926.json:
```json
{
    "body": "Replying to [comment:31 gh-darijgr]:\n> Here:\n> \n> ```\n> +        P = OrderedMultisetPartitions(multiset)\n> ```\n> you're using the duck-typing factory class `OrderedMultisetPartitions`.\n\n\nFor the record, this is *not* duck-typing. This is essentially polymorphism...well, as best as Python supports it. Duck-typing is something like `x.factor()`, where `x` could be either an element of `ZZ`, `QQ`, `QQ['x,y']`, etc. They are completely different classes, but both quack like a duck (have a `factor` method), and so it is a duck (as far as that code is concerned).",
    "created_at": "2018-05-23T04:34:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349926",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:31 gh-darijgr]:
> Here:
> 
> ```
> +        P = OrderedMultisetPartitions(multiset)
> ```
> you're using the duck-typing factory class `OrderedMultisetPartitions`.


For the record, this is *not* duck-typing. This is essentially polymorphism...well, as best as Python supports it. Duck-typing is something like `x.factor()`, where `x` could be either an element of `ZZ`, `QQ`, `QQ['x,y']`, etc. They are completely different classes, but both quack like a duck (have a `factor` method), and so it is a duck (as far as that code is concerned).



---

archive/issue_comments_349927.json:
```json
{
    "body": "Replying to [comment:35 alauve]:\n> one exception: something that looks like a dictionary but isn't gets treated incorrectly:\n> \n> ```\n> sage: P6 = OrderedMultisetPartitions(((1,2), (4,1))); P6.list()\n> [[{(1,2)}, {(4,1)}], [{(1,2),(4,1)}], [{(4,1)}, {(1,2)}]]\n> ```\n> \n> (but I'm not using syntax like P6 anywhere)\n\n\nI would not worry about that. It is not a `dict`, but `list`-like and should behave as such. Basically, I would consider it as garbage-in-garbage-out if you wanted that to behave like a `dict`.",
    "created_at": "2018-05-23T04:36:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349927",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:35 alauve]:
> one exception: something that looks like a dictionary but isn't gets treated incorrectly:
> 
> ```
> sage: P6 = OrderedMultisetPartitions(((1,2), (4,1))); P6.list()
> [[{(1,2)}, {(4,1)}], [{(1,2),(4,1)}], [{(4,1)}, {(1,2)}]]
> ```
> 
> (but I'm not using syntax like P6 anywhere)


I would not worry about that. It is not a `dict`, but `list`-like and should behave as such. Basically, I would consider it as garbage-in-garbage-out if you wanted that to behave like a `dict`.



---

archive/issue_comments_349928.json:
```json
{
    "body": "I don't see why you should have a separate `_iterator_weight` function. It creates the corresponding parent (and their elements anyways), so it would be much more natural to have it be just that parent class's `__iter__` method.",
    "created_at": "2018-05-23T04:42:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349928",
    "user": "https://github.com/tscrim"
}
```

I don't see why you should have a separate `_iterator_weight` function. It creates the corresponding parent (and their elements anyways), so it would be much more natural to have it be just that parent class's `__iter__` method.



---

archive/issue_comments_349929.json:
```json
{
    "body": "Replying to [comment:30 alauve]:\n> Anybody,\n> Could you explain why the following two different blocks of code behave differently?\n> \n> ```\n>       sage: O1 = OrderedMultisetPartitions(weight=[2,1])\n>       sage: list(O1) # maximum recursion depth exceded\n> ```\n> \n> \n> ```\n>       sage: O2 = OrderedMultisetPartitions(weight=[2,0,1])\n>       sage: O2.list()\n>       [[{1}, {1}, {3}], [{1}, {1,3}], [{1}, {3}, {1}], [{1,3}, {1}], [{3}, {1}, {1}]]\n>       sage: list(O2)\n>       [[{1}, {1}, {3}], [{1}, {1,3}], [{1}, {3}, {1}], [{1,3}, {1}], [{3}, {1}, {1}]]\n> ```\n\n\nThis is misleading. The issue is not the added `0` to the weight, but you must call `.list()` first. A better example of the underlying issue is:\n\n```\nsage: from sage.combinat.multiset_partition_ordered import *\nsage: O = OrderedMultisetPartitions(weight=[2,1])\nsage: list(O)\n...\nRuntimeError: maximum recursion depth exceeded while calling a Python object\nsage: O.list()\n[[{1}, {1,2}], [{1}, {1}, {2}], [{1,2}, {1}], [{1}, {2}, {1}], [{2}, {1}, {1}]]\nsage: list(O)\n[[{1}, {1,2}], [{1}, {1}, {2}], [{1,2}, {1}], [{1}, {2}, {1}], [{2}, {1}, {1}]]\n```\nWhat is happening is that `list` is first making sure that the resulting object is finite by:\n\n1. calling `O.__len__`,\n2. which calls `O.cardinality()`,\n3. which calls `len(list(O))`,\n\nand hence the infinite recursion. When you call `O.list()`, it caches the list of objects in `O._list` and changes the `cardinality` method to simply call `len(O._list)`. Hence, there is no infinite recursion.",
    "created_at": "2018-05-23T04:56:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349929",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:30 alauve]:
> Anybody,
> Could you explain why the following two different blocks of code behave differently?
> 
> ```
>       sage: O1 = OrderedMultisetPartitions(weight=[2,1])
>       sage: list(O1) # maximum recursion depth exceded
> ```
> 
> 
> ```
>       sage: O2 = OrderedMultisetPartitions(weight=[2,0,1])
>       sage: O2.list()
>       [[{1}, {1}, {3}], [{1}, {1,3}], [{1}, {3}, {1}], [{1,3}, {1}], [{3}, {1}, {1}]]
>       sage: list(O2)
>       [[{1}, {1}, {3}], [{1}, {1,3}], [{1}, {3}, {1}], [{1,3}, {1}], [{3}, {1}, {1}]]
> ```


This is misleading. The issue is not the added `0` to the weight, but you must call `.list()` first. A better example of the underlying issue is:

```
sage: from sage.combinat.multiset_partition_ordered import *
sage: O = OrderedMultisetPartitions(weight=[2,1])
sage: list(O)
...
RuntimeError: maximum recursion depth exceeded while calling a Python object
sage: O.list()
[[{1}, {1,2}], [{1}, {1}, {2}], [{1,2}, {1}], [{1}, {2}, {1}], [{2}, {1}, {1}]]
sage: list(O)
[[{1}, {1,2}], [{1}, {1}, {2}], [{1,2}, {1}], [{1}, {2}, {1}], [{2}, {1}, {1}]]
```
What is happening is that `list` is first making sure that the resulting object is finite by:

1. calling `O.__len__`,
2. which calls `O.cardinality()`,
3. which calls `len(list(O))`,

and hence the infinite recursion. When you call `O.list()`, it caches the list of objects in `O._list` and changes the `cardinality` method to simply call `len(O._list)`. Hence, there is no infinite recursion.



---

archive/issue_comments_349930.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-23T05:07:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349930",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349931.json:
```json
{
    "body": "Replying to [comment:41 tscrim]:\n> This is misleading. The issue is not the added `0` to the weight, but you must call `.list()` first. \n\n\nYeah, sorry about that. I just wanted to create a new object; knew the 0 had nothing to do with it.\n\n> What is happening is that `list` is first making sure that the resulting object is finite by:\n> \n> 1. calling `O.__len__`,\n> 2. which calls `O.cardinality()`,\n> 3. which calls `len(list(O))`,\n> \n> and hence the infinite recursion. When you call `O.list()`, it caches the list of objects in `O._list` and changes the `cardinality` method to simply call `len(O._list)`. Hence, there is no infinite recursion.\n\n\nAwesome. Thanks, Travis! Caching... duh. Good to learn the difference between `list(x)` and `x.list()`... so the latter just jumps right into `x.__iter__()` and crosses its fingers?\n\nRegarding the `__eq__` method, I was trying to follow the model in `IntegerVectorsConstraints` inside `integer_vector.py`. \nI don't have a good sense for whether or not all of these\n\n```\n        sage: C = OrderedMultisetPartitions(weight=[2,0,1], length=2); repr(C)\n        sage: D1 = OrderedMultisetPartitions(weight={1:2, 3:1}, min_length=2, max_length=2)\n        sage: D2 = OrderedMultisetPartitions({1:2, 3:1}, min_length=2, max_length=2)\n        sage: D3 = OrderedMultisetPartitions(5, weight={1:2, 3:1}, length=2)\n        sage: D4 = OrderedMultisetPartitions([1,3], 3, weight={1:2, 3:1}, length=2)\n        sage: D5 = OrderedMultisetPartitions([1,3], 3, size=5, length=2)\n```\nshould be treated as equal, but they certainly are equal as sets-of-ordered-multiset-partitions.",
    "created_at": "2018-05-23T05:20:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349931",
    "user": "https://github.com/alauve"
}
```

Replying to [comment:41 tscrim]:
> This is misleading. The issue is not the added `0` to the weight, but you must call `.list()` first. 


Yeah, sorry about that. I just wanted to create a new object; knew the 0 had nothing to do with it.

> What is happening is that `list` is first making sure that the resulting object is finite by:
> 
> 1. calling `O.__len__`,
> 2. which calls `O.cardinality()`,
> 3. which calls `len(list(O))`,
> 
> and hence the infinite recursion. When you call `O.list()`, it caches the list of objects in `O._list` and changes the `cardinality` method to simply call `len(O._list)`. Hence, there is no infinite recursion.


Awesome. Thanks, Travis! Caching... duh. Good to learn the difference between `list(x)` and `x.list()`... so the latter just jumps right into `x.__iter__()` and crosses its fingers?

Regarding the `__eq__` method, I was trying to follow the model in `IntegerVectorsConstraints` inside `integer_vector.py`. 
I don't have a good sense for whether or not all of these

```
        sage: C = OrderedMultisetPartitions(weight=[2,0,1], length=2); repr(C)
        sage: D1 = OrderedMultisetPartitions(weight={1:2, 3:1}, min_length=2, max_length=2)
        sage: D2 = OrderedMultisetPartitions({1:2, 3:1}, min_length=2, max_length=2)
        sage: D3 = OrderedMultisetPartitions(5, weight={1:2, 3:1}, length=2)
        sage: D4 = OrderedMultisetPartitions([1,3], 3, weight={1:2, 3:1}, length=2)
        sage: D5 = OrderedMultisetPartitions([1,3], 3, size=5, length=2)
```
should be treated as equal, but they certainly are equal as sets-of-ordered-multiset-partitions.



---

archive/issue_comments_349932.json:
```json
{
    "body": "This fixes the `list(O)` issue by letting the category framework take care of the `cardinality`. I added `OrderedMultisetPartition/s` to the global namespace. I also removed an `__eq__` on the parent because they are all subclasses of `UniqueRepresentation`, which means equality is by `id` and should never be changed.",
    "created_at": "2018-05-23T05:22:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349932",
    "user": "https://github.com/tscrim"
}
```

This fixes the `list(O)` issue by letting the category framework take care of the `cardinality`. I added `OrderedMultisetPartition/s` to the global namespace. I also removed an `__eq__` on the parent because they are all subclasses of `UniqueRepresentation`, which means equality is by `id` and should never be changed.



---

archive/issue_comments_349933.json:
```json
{
    "body": "Working on a few more changes, hold on.",
    "created_at": "2018-05-23T05:23:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349933",
    "user": "https://github.com/tscrim"
}
```

Working on a few more changes, hold on.



---

archive/issue_comments_349934.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-23T05:40:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349934",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349935.json:
```json
{
    "body": "Here is a bunch of general fixes and improvements. I left a few comments in the code of things that I think should be addressed.\n\nI think you are better off implementing the crystal code by adding the corresponding `CrystalOfTableaux` objects to each `MinimajCrystal.Element` instance. Since the crystal is essentially a standalone class (you [currently] cannot access it from `OrderedMultisetPartitions`), it doesn't make sense to constantly go back and forth between the two representations. In many ways, I would argue that it is not worth storing the objects as OMPs, but instead just storing the tableau as a subclass of `ElementWrapper`, writing a new `_repr_`/`_latex_` that converts to the OMP for printing, and having a `to_ordered_multiset_partition` for when you really want to consider it as an OMP.",
    "created_at": "2018-05-23T05:50:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349935",
    "user": "https://github.com/tscrim"
}
```

Here is a bunch of general fixes and improvements. I left a few comments in the code of things that I think should be addressed.

I think you are better off implementing the crystal code by adding the corresponding `CrystalOfTableaux` objects to each `MinimajCrystal.Element` instance. Since the crystal is essentially a standalone class (you [currently] cannot access it from `OrderedMultisetPartitions`), it doesn't make sense to constantly go back and forth between the two representations. In many ways, I would argue that it is not worth storing the objects as OMPs, but instead just storing the tableau as a subclass of `ElementWrapper`, writing a new `_repr_`/`_latex_` that converts to the OMP for printing, and having a `to_ordered_multiset_partition` for when you really want to consider it as an OMP.



---

archive/issue_comments_349936.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-24T04:11:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349936",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349937.json:
```json
{
    "body": "Replying to [comment:47 tscrim]:\n> Here is a bunch of general fixes and improvements. I left a few comments in the code of things that I think should be addressed.\n\n\nThanks, Travis. I'm not sure what \"strong code smell\" means, but I tried to clean up the `__iter__` methods a bit.\n\n.\n\n> I think you are better off implementing the crystal code by adding the corresponding `CrystalOfTableaux` objects to each `MinimajCrystal.Element` instance. Since the crystal is essentially a standalone class (you [currently] cannot access it from `OrderedMultisetPartitions`), it doesn't make sense to constantly go back and forth between the two representations. In many ways, I would argue that it is not worth storing the objects as OMPs, but instead just storing the tableau as a subclass of `ElementWrapper`, writing a new `_repr_`/`_latex_` that converts to the OMP for printing, and having a `to_ordered_multiset_partition` for when you really want to consider it as an OMP.\n\n\nOkay. It looks like the only time I'm really using OMP is in `.to_tableau()` methods within definition of `e` and `f`\nI still need (to be able) to generate all the elements at some point. Would you recommend doing something different than what I've done with this code?:\n\n```\n        self._full_module = OrderedMultisetPartitions(n, ell, length=k)\n```\nAlso, is it really much more overhead to have elements realized as OMPs  instead of tuples of tuples (this is what I'd replace them with, when rewriting `self.module_generators` within the `__init__` method of `MinimajCrystal`)?",
    "created_at": "2018-05-24T04:25:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349937",
    "user": "https://github.com/alauve"
}
```

Replying to [comment:47 tscrim]:
> Here is a bunch of general fixes and improvements. I left a few comments in the code of things that I think should be addressed.


Thanks, Travis. I'm not sure what "strong code smell" means, but I tried to clean up the `__iter__` methods a bit.

.

> I think you are better off implementing the crystal code by adding the corresponding `CrystalOfTableaux` objects to each `MinimajCrystal.Element` instance. Since the crystal is essentially a standalone class (you [currently] cannot access it from `OrderedMultisetPartitions`), it doesn't make sense to constantly go back and forth between the two representations. In many ways, I would argue that it is not worth storing the objects as OMPs, but instead just storing the tableau as a subclass of `ElementWrapper`, writing a new `_repr_`/`_latex_` that converts to the OMP for printing, and having a `to_ordered_multiset_partition` for when you really want to consider it as an OMP.


Okay. It looks like the only time I'm really using OMP is in `.to_tableau()` methods within definition of `e` and `f`
I still need (to be able) to generate all the elements at some point. Would you recommend doing something different than what I've done with this code?:

```
        self._full_module = OrderedMultisetPartitions(n, ell, length=k)
```
Also, is it really much more overhead to have elements realized as OMPs  instead of tuples of tuples (this is what I'd replace them with, when rewriting `self.module_generators` within the `__init__` method of `MinimajCrystal`)?



---

archive/issue_comments_349938.json:
```json
{
    "body": "A question for Anne:\n\nI identify the module generators for the minimaj crystal by iterating through all crystal elements `b` and testing:\n\n```\nall(b.e(i) == None for i in range(1,n))\n```\non each one. Do you know of a characterization of the highest weights so we can avoid this slow step?",
    "created_at": "2018-05-24T04:34:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349938",
    "user": "https://github.com/alauve"
}
```

A question for Anne:

I identify the module generators for the minimaj crystal by iterating through all crystal elements `b` and testing:

```
all(b.e(i) == None for i in range(1,n))
```
on each one. Do you know of a characterization of the highest weights so we can avoid this slow step?



---

archive/issue_comments_349939.json:
```json
{
    "body": "Replying to [comment:49 alauve]:\n> Okay. It looks like the only time I'm really using OMP is in `.to_tableau()` methods within definition of `e` and `f`\n> I still need (to be able) to generate all the elements at some point. Would you recommend doing something different than what I've done with this code?:\n> \n> ```\n>         self._full_module = OrderedMultisetPartitions(n, ell, length=k)\n> ```\n> Also, is it really much more overhead to have elements realized as OMPs  instead of tuples of tuples (this is what I'd replace them with, when rewriting `self.module_generators` within the `__init__` method of `MinimajCrystal`)? \n\n\nThe point mostly is to avoid the round trips through (effectively) `CrystalOfTableaux` to keep the crystal operators fast. So for that initial step, you can just iterate over the corresponding OMPs and convert them to tableaux. Also, since you are essentially iterating through everything, perhaps a better way would be to do:\n\n```\nself.module_generators = self\n```\nand then just define an `__iter__` method. The `module_generators` does not have to be the highest weight elements (e.g., look at the tensor product of crystals).",
    "created_at": "2018-05-24T05:11:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349939",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:49 alauve]:
> Okay. It looks like the only time I'm really using OMP is in `.to_tableau()` methods within definition of `e` and `f`
> I still need (to be able) to generate all the elements at some point. Would you recommend doing something different than what I've done with this code?:
> 
> ```
>         self._full_module = OrderedMultisetPartitions(n, ell, length=k)
> ```
> Also, is it really much more overhead to have elements realized as OMPs  instead of tuples of tuples (this is what I'd replace them with, when rewriting `self.module_generators` within the `__init__` method of `MinimajCrystal`)? 


The point mostly is to avoid the round trips through (effectively) `CrystalOfTableaux` to keep the crystal operators fast. So for that initial step, you can just iterate over the corresponding OMPs and convert them to tableaux. Also, since you are essentially iterating through everything, perhaps a better way would be to do:

```
self.module_generators = self
```
and then just define an `__iter__` method. The `module_generators` does not have to be the highest weight elements (e.g., look at the tensor product of crystals).



---

archive/issue_comments_349940.json:
```json
{
    "body": "More thoughts on comment:47...\n\nIf we store internally as lists of words but display as OMPs, won't this lead to endless bugs and confusion for end-users trying to write elementary code like `list(b)`? \n\nAs it stands, one is best served by storing elements as tableaux (row words, actually) for the `e` and `f` methods, but storing as OMPs (or tuples of tuples) for the `_repr_` and `val` methods.\n\nWhich of these two pairs are used more often? The `to_tableau` and `from_tableau` methods seem pretty cheap. So long as we store things as \"tuples of tuples\" instead of recreating OMPs all over the place, perhaps that's a good enough savings?",
    "created_at": "2018-05-24T23:46:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349940",
    "user": "https://github.com/alauve"
}
```

More thoughts on comment:47...

If we store internally as lists of words but display as OMPs, won't this lead to endless bugs and confusion for end-users trying to write elementary code like `list(b)`? 

As it stands, one is best served by storing elements as tableaux (row words, actually) for the `e` and `f` methods, but storing as OMPs (or tuples of tuples) for the `_repr_` and `val` methods.

Which of these two pairs are used more often? The `to_tableau` and `from_tableau` methods seem pretty cheap. So long as we store things as "tuples of tuples" instead of recreating OMPs all over the place, perhaps that's a good enough savings?



---

archive/issue_comments_349941.json:
```json
{
    "body": "Replying to [comment:50 alauve]:\n> A question for Anne:\n> \n> I identify the module generators for the minimaj crystal by iterating through all crystal elements `b` and testing:\n> \n> ```\n> all(b.e(i) == None for i in range(1,n))\n> ```\n> on each one. Do you know of a characterization of the highest weights so we can avoid this slow step?\n\n\nAs Travis wrote below, you can just take all elements in the crystal as its `module_generators`. The module generators should consist of a set that generates all elements using the `f_i` and `e_i` operators, but in the code the set does not have to be minimal. If you inherit from the highest weight crystal category, then you get the `highest_weight_vectors` method for free.",
    "created_at": "2018-05-25T02:29:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349941",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:50 alauve]:
> A question for Anne:
> 
> I identify the module generators for the minimaj crystal by iterating through all crystal elements `b` and testing:
> 
> ```
> all(b.e(i) == None for i in range(1,n))
> ```
> on each one. Do you know of a characterization of the highest weights so we can avoid this slow step?


As Travis wrote below, you can just take all elements in the crystal as its `module_generators`. The module generators should consist of a set that generates all elements using the `f_i` and `e_i` operators, but in the code the set does not have to be minimal. If you inherit from the highest weight crystal category, then you get the `highest_weight_vectors` method for free.



---

archive/issue_comments_349942.json:
```json
{
    "body": "Replying to [comment:53 aschilling]:\n\n> Replying to [comment:50 alauve]:\n> As Travis wrote below, you can just take all elements in the crystal as its `module_generators`. The module generators should consist of a set that generates all elements using the `f_i` and `e_i` operators, but in the code the set does not have to be minimal. If you inherit from the highest weight crystal category, then you get the `highest_weight_vectors` method for free. \n\n\nOkay. And for the elements of `MinimajCrystal`, how do you feel about what is stored internally (versus what is displayed): OMPs, tuples of tuples, list of words, a tensor product in `CrystalOfLetters`, ...?",
    "created_at": "2018-05-25T02:41:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349942",
    "user": "https://github.com/alauve"
}
```

Replying to [comment:53 aschilling]:

> Replying to [comment:50 alauve]:
> As Travis wrote below, you can just take all elements in the crystal as its `module_generators`. The module generators should consist of a set that generates all elements using the `f_i` and `e_i` operators, but in the code the set does not have to be minimal. If you inherit from the highest weight crystal category, then you get the `highest_weight_vectors` method for free. 


Okay. And for the elements of `MinimajCrystal`, how do you feel about what is stored internally (versus what is displayed): OMPs, tuples of tuples, list of words, a tensor product in `CrystalOfLetters`, ...?



---

archive/issue_comments_349943.json:
```json
{
    "body": "Replying to [comment:52 alauve]:\n> More thoughts on comment:47...\n> \n> If we store internally as lists of words but display as OMPs, won't this lead to endless bugs and confusion for end-users trying to write elementary code like `list(b)`? \n> \n> As it stands, one is best served by storing elements as tableaux (row words, actually) for the `e` and `f` methods, but storing as OMPs (or tuples of tuples) for the `_repr_` and `val` methods.\n\n\nInternally the elements of `CrystalOfTableaux` are stored as words, which I believe was what your parenthetical is saying. However, if you want things like `list(b)` to be treated as OMPs, just add an `__iter__` of the element class that does `return iter(self.to_ordered_multiset_partition())`.\n\nAlso, some simple doc and an example showing the internal structure can mitigate confusion, but generally I dislike saying anything about the internal structure in public docs. Writing boilerplate functions for a consistent public API is the annoying drawbacks of doing an adapter class, but it does mean it will be quick for its purpose (constructing the crystal).\n\n> Which of these two pairs are used more often? The `to_tableau` and `from_tableau` methods seem pretty cheap. So long as we store things as \"tuples of tuples\" instead of recreating OMPs all over the place, perhaps that's a good enough savings?\n\n\nCompared to the crystal operations themselves, they look very expensive (also considering they are implemented in Python). A good way to actually see what works is to do timings. Compare with `crystals.Tableaux`, `crystals.LSPaths`, and `crystals.NakajimaMonomials`.\n\n```\nsage: def test_iteration(B):\n....:     for b in B:\n....:         pass\n\nsage: T = crystals.Tableaux(['A',4], shape=[5,3,3,1])\nsage: T.cardinality()\n1890\nsage: %timeit test_iteration(T)\n10 loops, best of 3: 75.6 ms per loop\n\nsage: La = RootSystem(['A',4]).weight_space().fundamental_weights()\nsage: L = crystals.LSPaths(La[4]+2*La[3]+2*La[1])\nsage: %timeit test_iteration(L)\n1 loop, best of 3: 2.16 s per loop\n\nsage: La = RootSystem(['A',4]).weight_lattice().fundamental_weights()\nsage: M = crystals.NakajimaMonomials(La[4]+2*La[3]+2*La[1])\nsage: %timeit test_iteration(M)\n1 loop, best of 3: 832 ms per loop\n```\n(I really need to get my fast LS path code into Sage...)",
    "created_at": "2018-05-25T03:27:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349943",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:52 alauve]:
> More thoughts on comment:47...
> 
> If we store internally as lists of words but display as OMPs, won't this lead to endless bugs and confusion for end-users trying to write elementary code like `list(b)`? 
> 
> As it stands, one is best served by storing elements as tableaux (row words, actually) for the `e` and `f` methods, but storing as OMPs (or tuples of tuples) for the `_repr_` and `val` methods.


Internally the elements of `CrystalOfTableaux` are stored as words, which I believe was what your parenthetical is saying. However, if you want things like `list(b)` to be treated as OMPs, just add an `__iter__` of the element class that does `return iter(self.to_ordered_multiset_partition())`.

Also, some simple doc and an example showing the internal structure can mitigate confusion, but generally I dislike saying anything about the internal structure in public docs. Writing boilerplate functions for a consistent public API is the annoying drawbacks of doing an adapter class, but it does mean it will be quick for its purpose (constructing the crystal).

> Which of these two pairs are used more often? The `to_tableau` and `from_tableau` methods seem pretty cheap. So long as we store things as "tuples of tuples" instead of recreating OMPs all over the place, perhaps that's a good enough savings?


Compared to the crystal operations themselves, they look very expensive (also considering they are implemented in Python). A good way to actually see what works is to do timings. Compare with `crystals.Tableaux`, `crystals.LSPaths`, and `crystals.NakajimaMonomials`.

```
sage: def test_iteration(B):
....:     for b in B:
....:         pass

sage: T = crystals.Tableaux(['A',4], shape=[5,3,3,1])
sage: T.cardinality()
1890
sage: %timeit test_iteration(T)
10 loops, best of 3: 75.6 ms per loop

sage: La = RootSystem(['A',4]).weight_space().fundamental_weights()
sage: L = crystals.LSPaths(La[4]+2*La[3]+2*La[1])
sage: %timeit test_iteration(L)
1 loop, best of 3: 2.16 s per loop

sage: La = RootSystem(['A',4]).weight_lattice().fundamental_weights()
sage: M = crystals.NakajimaMonomials(La[4]+2*La[3]+2*La[1])
sage: %timeit test_iteration(M)
1 loop, best of 3: 832 ms per loop
```
(I really need to get my fast LS path code into Sage...)



---

archive/issue_comments_349944.json:
```json
{
    "body": "Replying to [comment:55 tscrim]:\n> Replying to [comment:52 alauve]:\n> > More thoughts on comment:47...\n> > \n> > If we store internally as lists of words but display as OMPs, won't this lead to endless bugs and confusion for end-users trying to write elementary code like `list(b)`? \n> > \n> > As it stands, one is best served by storing elements as tableaux (row words, actually) for the `e` and `f` methods, but storing as OMPs (or tuples of tuples) for the `_repr_` and `val` methods.\n\n> \n> Internally the elements of `CrystalOfTableaux` are stored as words, which I believe was what your parenthetical is saying. However, if you want things like `list(b)` to be treated as OMPs, just add an `__iter__` of the element class that does `return iter(self.to_ordered_multiset_partition())`.\n> \n> Also, some simple doc and an example showing the internal structure can mitigate confusion, but generally I dislike saying anything about the internal structure in public docs. Writing boilerplate functions for a consistent public API is the annoying drawbacks of doing an adapter class, but it does mean it will be quick for its purpose (constructing the crystal).\n> \n> > Which of these two pairs are used more often? The `to_tableau` and `from_tableau` methods seem pretty cheap. So long as we store things as \"tuples of tuples\" instead of recreating OMPs all over the place, perhaps that's a good enough savings?\n\n> \n> Compared to the crystal operations themselves, they look very expensive (also considering they are implemented in Python). A good way to actually see what works is to do timings. Compare with `crystals.Tableaux`, `crystals.LSPaths`, and `crystals.NakajimaMonomials`.\n> \n> ```\n> sage: def test_iteration(B):\n> ....:     for b in B:\n> ....:         pass\n> \n> sage: T = crystals.Tableaux(['A',4], shape=[5,3,3,1])\n> sage: T.cardinality()\n> 1890\n> sage: %timeit test_iteration(T)\n> 10 loops, best of 3: 75.6 ms per loop\n> \n> sage: La = RootSystem(['A',4]).weight_space().fundamental_weights()\n> sage: L = crystals.LSPaths(La[4]+2*La[3]+2*La[1])\n> sage: %timeit test_iteration(L)\n> 1 loop, best of 3: 2.16 s per loop\n> \n> sage: La = RootSystem(['A',4]).weight_lattice().fundamental_weights()\n> sage: M = crystals.NakajimaMonomials(La[4]+2*La[3]+2*La[1])\n> sage: %timeit test_iteration(M)\n> 1 loop, best of 3: 832 ms per loop\n> ```\n> (I really need to get my fast LS path code into Sage...)\n\n\nI personally think internally you can use whatever is easiest or fastest for the elements. But for the user all elements should be OMPs.\n\nI think there is some bug in the crystal code though since cardinality does not work:\n\n```\nsage: B=crystals.Minimaj(4,8,3)\nsage: B.cardinality()\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-8-fcb9cf0dbde7> in <module>()\n----> 1 B.cardinality()\n\n/Applications/sage/local/lib/python2.7/site-packages/sage/categories/classical_crystals.pyc in cardinality(self)\n    428             \"\"\"\n    429             return sum(self.weight_lattice_realization().weyl_dimension(x.weight())\n--> 430                        for x in self.highest_weight_vectors())\n    431 \n    432     class ElementMethods:\n\n/Applications/sage/local/lib/python2.7/site-packages/sage/categories/classical_crystals.pyc in <genexpr>((x,))\n    428             \"\"\"\n    429             return sum(self.weight_lattice_realization().weyl_dimension(x.weight())\n--> 430                        for x in self.highest_weight_vectors())\n    431 \n    432     class ElementMethods:\n\n/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/root_system/weight_lattice_realizations.pyc in weyl_dimension(self, highest_weight)\n    867                 <... 'sage.rings.integer.Integer'>\n    868             \"\"\"\n--> 869             highest_weight = self(highest_weight)\n    870             if not highest_weight.is_dominant():\n    871                 raise ValueError(\"the highest weight must be dominant\")\n\n/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/root_system/ambient_space.pyc in __call__(self, v)\n    196             return self._from_dict(dict((i,K(c)) for i,c in enumerate(v) if c))\n    197         else:\n--> 198             return CombinatorialFreeModule.__call__(self, v)\n    199 \n    200 \n\n/Applications/sage/local/lib/python2.7/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9734)()\n    918         if mor is not None:\n    919             if no_extra_args:\n--> 920                 return mor._call_(x)\n    921             else:\n    922                 return mor._call_with_args(x, args, kwds)\n\n/Applications/sage/local/lib/python2.7/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4555)()\n    143                 print(type(C), C)\n    144                 print(type(C._element_constructor), C._element_constructor)\n--> 145             raise\n    146 \n    147     cpdef Element _call_with_args(self, x, args=(), kwds={}):\n\n/Applications/sage/local/lib/python2.7/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4423)()\n    138         cdef Parent C = self._codomain\n    139         try:\n--> 140             return C._element_constructor(x)\n    141         except Exception:\n    142             if print_warnings:\n\n/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/free_module.pyc in _element_constructor_(self, x)\n    686                 except TypeError:\n    687                     pass\n--> 688             raise TypeError(\"do not know how to make x (= %s) an element of self (=%s)\"%(x,self))\n    689 \n    690     def _convert_map_from_(self, S):\n\nTypeError: do not know how to make x (= {1: 4, 2: 2, 3: 2}) an element of self (=Ambient space of the Root system of type ['A', 2])\n```",
    "created_at": "2018-05-25T04:17:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349944",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:55 tscrim]:
> Replying to [comment:52 alauve]:
> > More thoughts on comment:47...
> > 
> > If we store internally as lists of words but display as OMPs, won't this lead to endless bugs and confusion for end-users trying to write elementary code like `list(b)`? 
> > 
> > As it stands, one is best served by storing elements as tableaux (row words, actually) for the `e` and `f` methods, but storing as OMPs (or tuples of tuples) for the `_repr_` and `val` methods.

> 
> Internally the elements of `CrystalOfTableaux` are stored as words, which I believe was what your parenthetical is saying. However, if you want things like `list(b)` to be treated as OMPs, just add an `__iter__` of the element class that does `return iter(self.to_ordered_multiset_partition())`.
> 
> Also, some simple doc and an example showing the internal structure can mitigate confusion, but generally I dislike saying anything about the internal structure in public docs. Writing boilerplate functions for a consistent public API is the annoying drawbacks of doing an adapter class, but it does mean it will be quick for its purpose (constructing the crystal).
> 
> > Which of these two pairs are used more often? The `to_tableau` and `from_tableau` methods seem pretty cheap. So long as we store things as "tuples of tuples" instead of recreating OMPs all over the place, perhaps that's a good enough savings?

> 
> Compared to the crystal operations themselves, they look very expensive (also considering they are implemented in Python). A good way to actually see what works is to do timings. Compare with `crystals.Tableaux`, `crystals.LSPaths`, and `crystals.NakajimaMonomials`.
> 
> ```
> sage: def test_iteration(B):
> ....:     for b in B:
> ....:         pass
> 
> sage: T = crystals.Tableaux(['A',4], shape=[5,3,3,1])
> sage: T.cardinality()
> 1890
> sage: %timeit test_iteration(T)
> 10 loops, best of 3: 75.6 ms per loop
> 
> sage: La = RootSystem(['A',4]).weight_space().fundamental_weights()
> sage: L = crystals.LSPaths(La[4]+2*La[3]+2*La[1])
> sage: %timeit test_iteration(L)
> 1 loop, best of 3: 2.16 s per loop
> 
> sage: La = RootSystem(['A',4]).weight_lattice().fundamental_weights()
> sage: M = crystals.NakajimaMonomials(La[4]+2*La[3]+2*La[1])
> sage: %timeit test_iteration(M)
> 1 loop, best of 3: 832 ms per loop
> ```
> (I really need to get my fast LS path code into Sage...)


I personally think internally you can use whatever is easiest or fastest for the elements. But for the user all elements should be OMPs.

I think there is some bug in the crystal code though since cardinality does not work:

```
sage: B=crystals.Minimaj(4,8,3)
sage: B.cardinality()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-8-fcb9cf0dbde7> in <module>()
----> 1 B.cardinality()

/Applications/sage/local/lib/python2.7/site-packages/sage/categories/classical_crystals.pyc in cardinality(self)
    428             """
    429             return sum(self.weight_lattice_realization().weyl_dimension(x.weight())
--> 430                        for x in self.highest_weight_vectors())
    431 
    432     class ElementMethods:

/Applications/sage/local/lib/python2.7/site-packages/sage/categories/classical_crystals.pyc in <genexpr>((x,))
    428             """
    429             return sum(self.weight_lattice_realization().weyl_dimension(x.weight())
--> 430                        for x in self.highest_weight_vectors())
    431 
    432     class ElementMethods:

/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/root_system/weight_lattice_realizations.pyc in weyl_dimension(self, highest_weight)
    867                 <... 'sage.rings.integer.Integer'>
    868             """
--> 869             highest_weight = self(highest_weight)
    870             if not highest_weight.is_dominant():
    871                 raise ValueError("the highest weight must be dominant")

/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/root_system/ambient_space.pyc in __call__(self, v)
    196             return self._from_dict(dict((i,K(c)) for i,c in enumerate(v) if c))
    197         else:
--> 198             return CombinatorialFreeModule.__call__(self, v)
    199 
    200 

/Applications/sage/local/lib/python2.7/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9734)()
    918         if mor is not None:
    919             if no_extra_args:
--> 920                 return mor._call_(x)
    921             else:
    922                 return mor._call_with_args(x, args, kwds)

/Applications/sage/local/lib/python2.7/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4555)()
    143                 print(type(C), C)
    144                 print(type(C._element_constructor), C._element_constructor)
--> 145             raise
    146 
    147     cpdef Element _call_with_args(self, x, args=(), kwds={}):

/Applications/sage/local/lib/python2.7/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4423)()
    138         cdef Parent C = self._codomain
    139         try:
--> 140             return C._element_constructor(x)
    141         except Exception:
    142             if print_warnings:

/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/free_module.pyc in _element_constructor_(self, x)
    686                 except TypeError:
    687                     pass
--> 688             raise TypeError("do not know how to make x (= %s) an element of self (=%s)"%(x,self))
    689 
    690     def _convert_map_from_(self, S):

TypeError: do not know how to make x (= {1: 4, 2: 2, 3: 2}) an element of self (=Ambient space of the Root system of type ['A', 2])
```



---

archive/issue_comments_349945.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-31T16:56:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349945",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349946.json:
```json
{
    "body": "UPDATES: \n\n* I think I've gotten Minimaj working nicely now. I store a crystal element internally as a pair (word, break_points). In Anne's `e` and `f` code, she was moving back and forth between OMPs and such pairs (via row-words of skew-tableau), so now we cut out the back-and-forth. Crystal operators are certainly faster now. \n\n* All tests pass throughout the file, as well.\n\n* I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? \n\nHappy to receive others' comments...",
    "created_at": "2018-05-31T17:08:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349946",
    "user": "https://github.com/alauve"
}
```

UPDATES: 

* I think I've gotten Minimaj working nicely now. I store a crystal element internally as a pair (word, break_points). In Anne's `e` and `f` code, she was moving back and forth between OMPs and such pairs (via row-words of skew-tableau), so now we cut out the back-and-forth. Crystal operators are certainly faster now. 

* All tests pass throughout the file, as well.

* I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? 

Happy to receive others' comments...



---

archive/issue_comments_349947.json:
```json
{
    "body": "Replying to [comment:58 alauve]:\n\n> * I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? \n\n\nNo it will not. You *should* import it directly from the file. It will only give a deprecation if you import/use it in the global namespace. Try it.",
    "created_at": "2018-05-31T17:35:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349947",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:58 alauve]:

> * I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? 


No it will not. You *should* import it directly from the file. It will only give a deprecation if you import/use it in the global namespace. Try it.



---

archive/issue_comments_349948.json:
```json
{
    "body": "Hi Aaron,\n\nThanks for your work on this. There are some failures for the crystal test suite:\n\n```\nsage: B = crystals.Minimaj(2,3,2)\nsage: TestSuite(B).run(verbose=True)\nrunning ._test_an_element() . . . pass\nrunning ._test_cardinality() . . . pass\nrunning ._test_category() . . . pass\nrunning ._test_elements() . . .\n  Running the test suite of self.an_element()\n  running ._test_category() . . . pass\n  running ._test_eq() . . . pass\n  running ._test_new() . . . pass\n  running ._test_not_implemented_methods() . . . pass\n  running ._test_pickling() . . . pass\n  running ._test_stembridge_local_axioms() . . . pass\n  pass\nrunning ._test_elements_eq_reflexive() . . . pass\nrunning ._test_elements_eq_symmetric() . . . pass\nrunning ._test_elements_eq_transitive() . . . pass\nrunning ._test_elements_neq() . . . pass\nrunning ._test_enumerated_set_contains() . . . pass\nrunning ._test_enumerated_set_iter_cardinality() . . . pass\nrunning ._test_enumerated_set_iter_list() . . . pass\nrunning ._test_eq() . . . pass\nrunning ._test_fast_iter() . . . fail\nTraceback (most recent call last):\n  File \"/Applications/sage/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py\", line 294, in run\n    test_method(tester = tester)\n  File \"/Applications/sage/local/lib/python2.7/site-packages/sage/categories/classical_crystals.py\", line 413, in _test_fast_iter\n    SS  = list(Crystals().parent_class.__iter__(self))\n  File \"sage/sets/recursively_enumerated_set.pyx\", line 688, in breadth_first_search_iterator (build/cythonized/sage/sets/recursively_enumerated_set.c:5563)\n    known = set(current_level)\n  File \"sage/structure/element_wrapper.pyx\", line 249, in sage.structure.element_wrapper.ElementWrapper.__hash__ (build/cythonized/sage/structure/element_wrapper.c:3569)\n    return hash(self.value)\nTypeError: unhashable type: 'list'\n------------------------------------------------------------\nrunning ._test_new() . . . pass\nrunning ._test_not_implemented_methods() . . . pass\nrunning ._test_pickling() . . . pass\nrunning ._test_some_elements() . . . pass\nrunning ._test_stembridge_local_axioms() . . . pass\nThe following tests failed: _test_fast_iter\n```\n\nReplying to [comment:58 alauve]:\n> UPDATES: \n> \n> * I think I've gotten Minimaj working nicely now. I store a crystal element internally as a pair (word, break_points). In Anne's `e` and `f` code, she was moving back and forth between OMPs and such pairs (via row-words of skew-tableau), so now we cut out the back-and-forth. Crystal operators are certainly faster now. \n> \n> * All tests pass throughout the file, as well.\n> \n> * I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? \n> \n> Happy to receive others' comments...",
    "created_at": "2018-05-31T21:19:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349948",
    "user": "https://github.com/anneschilling"
}
```

Hi Aaron,

Thanks for your work on this. There are some failures for the crystal test suite:

```
sage: B = crystals.Minimaj(2,3,2)
sage: TestSuite(B).run(verbose=True)
running ._test_an_element() . . . pass
running ._test_cardinality() . . . pass
running ._test_category() . . . pass
running ._test_elements() . . .
  Running the test suite of self.an_element()
  running ._test_category() . . . pass
  running ._test_eq() . . . pass
  running ._test_new() . . . pass
  running ._test_not_implemented_methods() . . . pass
  running ._test_pickling() . . . pass
  running ._test_stembridge_local_axioms() . . . pass
  pass
running ._test_elements_eq_reflexive() . . . pass
running ._test_elements_eq_symmetric() . . . pass
running ._test_elements_eq_transitive() . . . pass
running ._test_elements_neq() . . . pass
running ._test_enumerated_set_contains() . . . pass
running ._test_enumerated_set_iter_cardinality() . . . pass
running ._test_enumerated_set_iter_list() . . . pass
running ._test_eq() . . . pass
running ._test_fast_iter() . . . fail
Traceback (most recent call last):
  File "/Applications/sage/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py", line 294, in run
    test_method(tester = tester)
  File "/Applications/sage/local/lib/python2.7/site-packages/sage/categories/classical_crystals.py", line 413, in _test_fast_iter
    SS  = list(Crystals().parent_class.__iter__(self))
  File "sage/sets/recursively_enumerated_set.pyx", line 688, in breadth_first_search_iterator (build/cythonized/sage/sets/recursively_enumerated_set.c:5563)
    known = set(current_level)
  File "sage/structure/element_wrapper.pyx", line 249, in sage.structure.element_wrapper.ElementWrapper.__hash__ (build/cythonized/sage/structure/element_wrapper.c:3569)
    return hash(self.value)
TypeError: unhashable type: 'list'
------------------------------------------------------------
running ._test_new() . . . pass
running ._test_not_implemented_methods() . . . pass
running ._test_pickling() . . . pass
running ._test_some_elements() . . . pass
running ._test_stembridge_local_axioms() . . . pass
The following tests failed: _test_fast_iter
```

Replying to [comment:58 alauve]:
> UPDATES: 
> 
> * I think I've gotten Minimaj working nicely now. I store a crystal element internally as a pair (word, break_points). In Anne's `e` and `f` code, she was moving back and forth between OMPs and such pairs (via row-words of skew-tableau), so now we cut out the back-and-forth. Crystal operators are certainly faster now. 
> 
> * All tests pass throughout the file, as well.
> 
> * I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? 
> 
> Happy to receive others' comments...



---

archive/issue_comments_349949.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-31T21:29:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349949",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349950.json:
```json
{
    "body": "crystal test suite should pass now.",
    "created_at": "2018-05-31T21:29:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349950",
    "user": "https://github.com/alauve"
}
```

crystal test suite should pass now.



---

archive/issue_comments_349951.json:
```json
{
    "body": "Replying to [comment:58 alauve]:\n> UPDATES: \n> \n> * I think I've gotten Minimaj working nicely now. I store a crystal element internally as a pair (word, break_points). In Anne's `e` and `f` code, she was moving back and forth between OMPs and such pairs (via row-words of skew-tableau), so now we cut out the back-and-forth. Crystal operators are certainly faster now. \n> \n> * All tests pass throughout the file, as well.\n> \n> * I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? \n> \n> Happy to receive others' comments...\n\n\nI am not sure what you mean by \"deprecation warnings\" in this context. That is usually what happens when you remove a functionality in sage. You could just import CrystalOfLetters in the method where you use it instead of for the whole file.",
    "created_at": "2018-05-31T21:36:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349951",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:58 alauve]:
> UPDATES: 
> 
> * I think I've gotten Minimaj working nicely now. I store a crystal element internally as a pair (word, break_points). In Anne's `e` and `f` code, she was moving back and forth between OMPs and such pairs (via row-words of skew-tableau), so now we cut out the back-and-forth. Crystal operators are certainly faster now. 
> 
> * All tests pass throughout the file, as well.
> 
> * I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? 
> 
> Happy to receive others' comments...


I am not sure what you mean by "deprecation warnings" in this context. That is usually what happens when you remove a functionality in sage. You could just import CrystalOfLetters in the method where you use it instead of for the whole file.



---

archive/issue_comments_349952.json:
```json
{
    "body": "> Replying to [comment:58 alauve]:\n> > UPDATES: \n> > \n> > * I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? \n \n> \n> I am not sure what you mean by \"deprecation warnings\" in this context. That is usually what happens when you remove a functionality in sage. You could just import CrystalOfLetters in the method where you use it instead of for the whole file.\n\n\nI got the answer I was looking for from Travis. In testing phase, when I was \"loading\" the .py file into sage, I'd get deprecation warnings on first use of assorted classes. But on a proper rebuild of sage, this didn't happen.",
    "created_at": "2018-05-31T22:19:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349952",
    "user": "https://github.com/alauve"
}
```

> Replying to [comment:58 alauve]:
> > UPDATES: 
> > 
> > * I am afraid the way I'm bringing in CrystalOfLetters will throw deprecation warnings. How does one import classes from the crystal catalog? 
 
> 
> I am not sure what you mean by "deprecation warnings" in this context. That is usually what happens when you remove a functionality in sage. You could just import CrystalOfLetters in the method where you use it instead of for the whole file.


I got the answer I was looking for from Travis. In testing phase, when I was "loading" the .py file into sage, I'd get deprecation warnings on first use of assorted classes. But on a proper rebuild of sage, this didn't happen.



---

archive/issue_comments_349953.json:
```json
{
    "body": "Working on documentation today... \n\nLooking through diagram_algebras.py, I notice a few anomalies that make me wonder about conventions. \n\n1/ Regarding references, I see \n\n```\n    REFERENCES:\n\n    - [BH2017]_\n```\n(with a corresponding entry in `src/doc/en/reference/references/index.rst`) \nas well as\n\n```\n    REFERENCES:\n\n    .. [Naz96] Maxim Nazarov, Young's Orthogonal Form for Brauer's\n       Centralizer Algebra. Journal of Algebra 182 (1996), 664--693.\n```\n\n\n2/ Regarding \":\" Sometimes I see\n\n```\n        EXAMPLES:\n```\n(see also the \"REFERENCES\" in Item 1 above) and sometimes\n\n```\n        EXAMPLES::\n```\n\n\n3/ Regarding uses of `TestSuite`. Sometimes it appears within the main docstring for a class, and sometimes within the `__init__` method for a class. Is the latter preferred, and the former used only when `__init__` is not present?",
    "created_at": "2018-06-01T17:10:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349953",
    "user": "https://github.com/alauve"
}
```

Working on documentation today... 

Looking through diagram_algebras.py, I notice a few anomalies that make me wonder about conventions. 

1/ Regarding references, I see 

```
    REFERENCES:

    - [BH2017]_
```
(with a corresponding entry in `src/doc/en/reference/references/index.rst`) 
as well as

```
    REFERENCES:

    .. [Naz96] Maxim Nazarov, Young's Orthogonal Form for Brauer's
       Centralizer Algebra. Journal of Algebra 182 (1996), 664--693.
```


2/ Regarding ":" Sometimes I see

```
        EXAMPLES:
```
(see also the "REFERENCES" in Item 1 above) and sometimes

```
        EXAMPLES::
```


3/ Regarding uses of `TestSuite`. Sometimes it appears within the main docstring for a class, and sometimes within the `__init__` method for a class. Is the latter preferred, and the former used only when `__init__` is not present?



---

archive/issue_comments_349954.json:
```json
{
    "body": "Replying to [comment:65 alauve]:\n> Working on documentation today... \n> \n> Looking through diagram_algebras.py, I notice a few anomalies that make me wonder about conventions. \n> \n> 1/ Regarding references, I see \n> \n> ```\n>     REFERENCES:\n> \n>     - [BH2017]_\n> ```\n> (with a corresponding entry in `src/doc/en/reference/references/index.rst`) \n> as well as\n> \n> ```\n>     REFERENCES:\n> \n>     .. [Naz96] Maxim Nazarov, Young's Orthogonal Form for Brauer's\n>        Centralizer Algebra. Journal of Algebra 182 (1996), 664--693.\n> ```\n\n\nI think both are ok. If the reference is only used locally in the file, you can\nput it in the file as in the second option. If the reference appears in multiple\nfiles, I think it is preferable to put them in the reference file.\n\n> 2/ Regarding \":\" Sometimes I see\n> \n> ```\n>         EXAMPLES:\n> ```\n> (see also the \"REFERENCES\" in Item 1 above) and sometimes\n> \n> ```\n>         EXAMPLES::\n> ```\n\n\nIf EXAMPLES is followed by code, then you use EXAMPLES:: followed by indentation.\nIf it is followed by an explanation, then you use EXAMPLES: without indentation. Then\nyou use :: after the text and then the code is indented.\n\n\n> 3/ Regarding uses of `TestSuite`. Sometimes it appears within the main docstring for a class, and sometimes within the `__init__` method for a class. Is the latter preferred, and the former used only when `__init__` is not present?\n\n\nAgain, I think it does not matter. But if you have an `__init__`, it is probably\nbest to put it there.\n\nCould you indicate in the crystal code, that you got the initial draft from me?\n\nThank you!\n\nAnne",
    "created_at": "2018-06-02T09:42:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349954",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:65 alauve]:
> Working on documentation today... 
> 
> Looking through diagram_algebras.py, I notice a few anomalies that make me wonder about conventions. 
> 
> 1/ Regarding references, I see 
> 
> ```
>     REFERENCES:
> 
>     - [BH2017]_
> ```
> (with a corresponding entry in `src/doc/en/reference/references/index.rst`) 
> as well as
> 
> ```
>     REFERENCES:
> 
>     .. [Naz96] Maxim Nazarov, Young's Orthogonal Form for Brauer's
>        Centralizer Algebra. Journal of Algebra 182 (1996), 664--693.
> ```


I think both are ok. If the reference is only used locally in the file, you can
put it in the file as in the second option. If the reference appears in multiple
files, I think it is preferable to put them in the reference file.

> 2/ Regarding ":" Sometimes I see
> 
> ```
>         EXAMPLES:
> ```
> (see also the "REFERENCES" in Item 1 above) and sometimes
> 
> ```
>         EXAMPLES::
> ```


If EXAMPLES is followed by code, then you use EXAMPLES:: followed by indentation.
If it is followed by an explanation, then you use EXAMPLES: without indentation. Then
you use :: after the text and then the code is indented.


> 3/ Regarding uses of `TestSuite`. Sometimes it appears within the main docstring for a class, and sometimes within the `__init__` method for a class. Is the latter preferred, and the former used only when `__init__` is not present?


Again, I think it does not matter. But if you have an `__init__`, it is probably
best to put it there.

Could you indicate in the crystal code, that you got the initial draft from me?

Thank you!

Anne



---

archive/issue_comments_349955.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-04T17:01:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349955",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349956.json:
```json
{
    "body": "Afer the above changes, I think this file is ready for review.",
    "created_at": "2018-06-04T17:02:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349956",
    "user": "https://github.com/alauve"
}
```

Afer the above changes, I think this file is ready for review.



---

archive/issue_comments_349957.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-06-04T17:02:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349957",
    "user": "https://github.com/alauve"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_349958.json:
```json
{
    "body": "Quick things:\n\n- Not all (which includes private and special) methods have doc(tests).\n- Functions with latex in the doc should start `r\"\"\"` (for raw-string, so `\\` does not become an escape character, i.e., `\\t` in non-raw becomes a tab).\n- There is no sorting between integers and strings (in Python3, this is now an error IIRC), which causes this test to fail on the patchbot (even though it might [sometimes] pass on your computer):\n  {{{\nsage -t --long src/sage/combinat/multiset_partition_ordered.py\n**********************************************************************\nFile \"src/sage/combinat/multiset_partition_ordered.py\", line 649, in sage.combinat.multiset_partition_ordered.OrderedMultisetPartition.finer\nFailed example:\n    o.finer()\nExpected:\n    {[{'b'}, {'a'}, {1}, {1}], [{'a'}, {'b'}, {1}, {1}], [{'a','b'}, {1}, {1}]}\nGot:\n    {[{1}, {1}, {'a'}, {'b'}], [{1}, {'a'}, {1}, {'b'}], [{1}, {1,'a'}, {'b'}]}\n  }}}\n- Need a blank line here (and some punctuation):\n  {{{#!diff\n         2. If blocks `B_{i+1}, \\ldots, B_k` have been converted to words\n            `W_{i+1}, \\ldots, W_k`, use the letters in `B_i` to make the unique\n            word `W_i` that has a factorization `W_i=(u,v)` satisfying:\n+\n- letters of `u` and `v` appear in increasing order, with `v` possibly empty\n- letters in `vu` appear in increasing order\n- ``v[-1]`` is the largest letter `a \\in B_i` satisfying ``a <= W_{i+1}[0]``\n  }}}\n  Similar for the `.. NOTE::` block in the crystal element class.\n- References should also have 4 number years (and IMO, I prefer them to be in the master ref file, helps reduce the risk of duplicate references).\n- You should not raise an `AssertionError` (these are only for real bugs, not bad input).\n- `if hasattr(x, \"value\"):` is not a good check. In fact, the coercion framework makes it so that `_element_constructor_` is never called when doing `P(x)` if the parent of `x` is `P`. Thus, you can simply remove this.\n- For your `MinimajCrystal.__contains__`, a better check would be `isinstance(x, Element)`.\n- It should be `.. NOTE::`, not `.. NOTES:` and what follows should be indented.\n- IMO, I would add an `AUTHORS:` block to `MinimajCrystal` saying something like\n  {{{\nAUTHORS:\n\n- Anne Schilling: initial draft\n- Aaron Lauve: changed to use `ElementWrapper`\n  }}}\n- I still think you should use the `CrystalOfTableaux` code rather than manually working with a tensor product of letters as it is essentially code duplication.\n- ``ZZ`` -> ``\\ZZ``\n- In terms of speed, it is much better to use Python's `frozenset` instead of Sage's `Set`.\n\nI will probably have some more comments later.",
    "created_at": "2018-06-05T01:26:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349958",
    "user": "https://github.com/tscrim"
}
```

Quick things:

- Not all (which includes private and special) methods have doc(tests).
- Functions with latex in the doc should start `r"""` (for raw-string, so `\` does not become an escape character, i.e., `\t` in non-raw becomes a tab).
- There is no sorting between integers and strings (in Python3, this is now an error IIRC), which causes this test to fail on the patchbot (even though it might [sometimes] pass on your computer):
  {{{
sage -t --long src/sage/combinat/multiset_partition_ordered.py
**********************************************************************
File "src/sage/combinat/multiset_partition_ordered.py", line 649, in sage.combinat.multiset_partition_ordered.OrderedMultisetPartition.finer
Failed example:
    o.finer()
Expected:
    {[{'b'}, {'a'}, {1}, {1}], [{'a'}, {'b'}, {1}, {1}], [{'a','b'}, {1}, {1}]}
Got:
    {[{1}, {1}, {'a'}, {'b'}], [{1}, {'a'}, {1}, {'b'}], [{1}, {1,'a'}, {'b'}]}
  }}}
- Need a blank line here (and some punctuation):
  {{{#!diff
         2. If blocks `B_{i+1}, \ldots, B_k` have been converted to words
            `W_{i+1}, \ldots, W_k`, use the letters in `B_i` to make the unique
            word `W_i` that has a factorization `W_i=(u,v)` satisfying:
+
- letters of `u` and `v` appear in increasing order, with `v` possibly empty
- letters in `vu` appear in increasing order
- ``v[-1]`` is the largest letter `a \in B_i` satisfying ``a <= W_{i+1}[0]``
  }}}
  Similar for the `.. NOTE::` block in the crystal element class.
- References should also have 4 number years (and IMO, I prefer them to be in the master ref file, helps reduce the risk of duplicate references).
- You should not raise an `AssertionError` (these are only for real bugs, not bad input).
- `if hasattr(x, "value"):` is not a good check. In fact, the coercion framework makes it so that `_element_constructor_` is never called when doing `P(x)` if the parent of `x` is `P`. Thus, you can simply remove this.
- For your `MinimajCrystal.__contains__`, a better check would be `isinstance(x, Element)`.
- It should be `.. NOTE::`, not `.. NOTES:` and what follows should be indented.
- IMO, I would add an `AUTHORS:` block to `MinimajCrystal` saying something like
  {{{
AUTHORS:

- Anne Schilling: initial draft
- Aaron Lauve: changed to use `ElementWrapper`
  }}}
- I still think you should use the `CrystalOfTableaux` code rather than manually working with a tensor product of letters as it is essentially code duplication.
- ``ZZ`` -> ``\ZZ``
- In terms of speed, it is much better to use Python's `frozenset` instead of Sage's `Set`.

I will probably have some more comments later.



---

archive/issue_comments_349959.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-06-05T01:26:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349959",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_349960.json:
```json
{
    "body": "Thanks, Travis. Informative and helpful comments, all.\n\nI'll start on them asap... feel free to hold off on your \"more comments later\" until after the next iteration.",
    "created_at": "2018-06-05T03:17:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349960",
    "user": "https://github.com/alauve"
}
```

Thanks, Travis. Informative and helpful comments, all.

I'll start on them asap... feel free to hold off on your "more comments later" until after the next iteration.



---

archive/issue_comments_349961.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-06T02:57:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349961",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349962.json:
```json
{
    "body": "Travis,\n\nI finished implementing most of your suggested changes (plus an additional one). \n\nI'm not quite sure what to do about your `CrystalsOfTableaux` suggestion:\n\n* the elements are not individual instances `crystals.Tableaux(['A', n-1], shape=??)` but rather tensor products of these (so what code are we duplicating?)\n* the constituent shapes (\"??\" above) are not easily predetermined and are not uniform across all ordered multiset partitions of order d and length k\n\nI have left that bit of code alone for now.",
    "created_at": "2018-06-06T03:05:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349962",
    "user": "https://github.com/alauve"
}
```

Travis,

I finished implementing most of your suggested changes (plus an additional one). 

I'm not quite sure what to do about your `CrystalsOfTableaux` suggestion:

* the elements are not individual instances `crystals.Tableaux(['A', n-1], shape=??)` but rather tensor products of these (so what code are we duplicating?)
* the constituent shapes ("??" above) are not easily predetermined and are not uniform across all ordered multiset partitions of order d and length k

I have left that bit of code alone for now.



---

archive/issue_comments_349963.json:
```json
{
    "body": "Sorry, I am currently at a conference, so I am a bit slow. But it seems that there are a lot of docstrings missing:\n\n```\nsage -coverage multiset_partition_ordered.py \n------------------------------------------------------------------------\nSCORE multiset_partition_ordered.py: 57.4% (62 of 108)\n\nMissing doctests:\n     * line 252: def _repr_(self)\n     * line 258: def _repr_normal(self)\n     * line 326: def __ne__(self, y)\n     * line 413: def letters(self)\n     * line 1443: def __init__(self, is_finite=None, **constraints)\n     * line 1507: def _repr_(self)\n     * line 1513: def _constraint_repr_(self, cdict=None)\n     * line 1596: def _has_valid_blocks(self, x)\n     * line 1607: def _satisfies_constraints(self, x)\n     * line 1693: def an_element(self)\n     * line 1819: def _repr_(self)\n     * line 1897: def _has_valid_blocks(self, x)\n     * line 1909: def cardinality(self)\n     * line 1930: def an_element(self)\n     * line 1969: def __iter__(self)\n     * line 1998: def _repr_(self)\n     * line 2007: def _has_valid_blocks(self, x)\n     * line 2048: def _has_valid_blocks(self, x)\n     * line 2058: def cardinality(self)\n     * line 2074: def an_element(self)\n     * line 2125: def __iter__(self)\n     * line 2156: def _repr_(self)\n     * line 2166: def _has_valid_blocks(self, x)\n     * line 2214: def _has_valid_blocks(self, x)\n     * line 2226: def an_element(self)\n     * line 2263: def __iter__(self)\n     * line 2325: def _repr_(self)\n     * line 2336: def _has_valid_blocks(self, x)\n     * line 2343: def an_element(self)\n     * line 2366: def _get_multiset(co)\n     * line 2372: def _get_weight(lst)\n     * line 2381: def _union_of_sets(list_of_sets)\n     * line 2387: def _concatenate(list_of_iters)\n     * line 2396: def _is_finite(constraints)\n     * line 2407: def _base_iterator(constraints)\n     * line 2577: def _descents(w)\n     * line 2583: def _break_at_descents(alpha, weak=True)\n     * line 2613: def _refine_block(S, strong=False)\n     * line 2641: def _is_initial_segment(lst)\n     * line 2647: def _split_block(S, k=2)\n     * line 2779: def an_element(self)\n     * line 2788: def _element_constructor_(self, x)\n     * line 2798: def __contains__(self, x)\n     * line 2873: def _repr_(self)\n     * line 2879: def __iter__(self)\n     * line 2885: def _minimaj_blocks_from_word_pair(self)\n\nPossibly wrong (function name doesn't occur in doctests):\n     * line 2269: def cardinality(self)\n```",
    "created_at": "2018-06-06T07:53:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349963",
    "user": "https://github.com/anneschilling"
}
```

Sorry, I am currently at a conference, so I am a bit slow. But it seems that there are a lot of docstrings missing:

```
sage -coverage multiset_partition_ordered.py 
------------------------------------------------------------------------
SCORE multiset_partition_ordered.py: 57.4% (62 of 108)

Missing doctests:
     * line 252: def _repr_(self)
     * line 258: def _repr_normal(self)
     * line 326: def __ne__(self, y)
     * line 413: def letters(self)
     * line 1443: def __init__(self, is_finite=None, **constraints)
     * line 1507: def _repr_(self)
     * line 1513: def _constraint_repr_(self, cdict=None)
     * line 1596: def _has_valid_blocks(self, x)
     * line 1607: def _satisfies_constraints(self, x)
     * line 1693: def an_element(self)
     * line 1819: def _repr_(self)
     * line 1897: def _has_valid_blocks(self, x)
     * line 1909: def cardinality(self)
     * line 1930: def an_element(self)
     * line 1969: def __iter__(self)
     * line 1998: def _repr_(self)
     * line 2007: def _has_valid_blocks(self, x)
     * line 2048: def _has_valid_blocks(self, x)
     * line 2058: def cardinality(self)
     * line 2074: def an_element(self)
     * line 2125: def __iter__(self)
     * line 2156: def _repr_(self)
     * line 2166: def _has_valid_blocks(self, x)
     * line 2214: def _has_valid_blocks(self, x)
     * line 2226: def an_element(self)
     * line 2263: def __iter__(self)
     * line 2325: def _repr_(self)
     * line 2336: def _has_valid_blocks(self, x)
     * line 2343: def an_element(self)
     * line 2366: def _get_multiset(co)
     * line 2372: def _get_weight(lst)
     * line 2381: def _union_of_sets(list_of_sets)
     * line 2387: def _concatenate(list_of_iters)
     * line 2396: def _is_finite(constraints)
     * line 2407: def _base_iterator(constraints)
     * line 2577: def _descents(w)
     * line 2583: def _break_at_descents(alpha, weak=True)
     * line 2613: def _refine_block(S, strong=False)
     * line 2641: def _is_initial_segment(lst)
     * line 2647: def _split_block(S, k=2)
     * line 2779: def an_element(self)
     * line 2788: def _element_constructor_(self, x)
     * line 2798: def __contains__(self, x)
     * line 2873: def _repr_(self)
     * line 2879: def __iter__(self)
     * line 2885: def _minimaj_blocks_from_word_pair(self)

Possibly wrong (function name doesn't occur in doctests):
     * line 2269: def cardinality(self)
```



---

archive/issue_comments_349964.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-06T08:38:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349964",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349965.json:
```json
{
    "body": "I see. One needs EXAMPLES or TESTS for every function, not just docstring?\nOkay, I'll try to add some this morning.",
    "created_at": "2018-06-06T11:27:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349965",
    "user": "https://github.com/alauve"
}
```

I see. One needs EXAMPLES or TESTS for every function, not just docstring?
Okay, I'll try to add some this morning.



---

archive/issue_comments_349966.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-07T06:06:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349966",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349967.json:
```json
{
    "body": "Well, `sage -coverage` gives me a grade of 90.7% now instead of 57.4%.\nI'll get back to example/test writing soon.",
    "created_at": "2018-06-07T06:08:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349967",
    "user": "https://github.com/alauve"
}
```

Well, `sage -coverage` gives me a grade of 90.7% now instead of 57.4%.
I'll get back to example/test writing soon.



---

archive/issue_comments_349968.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-07T23:42:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349968",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349969.json:
```json
{
    "body": "File in much better shape now (fingers crossed).",
    "created_at": "2018-06-07T23:44:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349969",
    "user": "https://github.com/alauve"
}
```

File in much better shape now (fingers crossed).



---

archive/issue_comments_349970.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-06-07T23:44:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349970",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_349971.json:
```json
{
    "body": "Found some bugs in the `__contains__` method",
    "created_at": "2018-06-08T13:36:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349971",
    "user": "https://github.com/alauve"
}
```

Found some bugs in the `__contains__` method



---

archive/issue_comments_349972.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-06-08T13:36:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349972",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_349973.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-08T14:50:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349973",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349974.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-06-08T14:52:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349974",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_349975.json:
```json
{
    "body": "Bugs in `__contains__` method zapped.",
    "created_at": "2018-06-08T14:52:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349975",
    "user": "https://github.com/alauve"
}
```

Bugs in `__contains__` method zapped.



---

archive/issue_comments_349976.json:
```json
{
    "body": "Branch is red (merge failed).",
    "created_at": "2018-06-08T15:46:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349976",
    "user": "https://github.com/darijgr"
}
```

Branch is red (merge failed).



---

archive/issue_comments_349977.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-09T16:37:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349977",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349978.json:
```json
{
    "body": "I think I should remove the user shorthand for `OrderedMultisetPartition` that uses `OrderedMultisetPartitions.from_list()`.\n\nWhile the shorthand is nice for `OrderedMultisetPartition`, I don't see how to make it play nicely with the `__getitem__()` method for combinatorial free modules over `OrderedMultisetPartitions`.\n\nE.g., in the present state of ticket #25543, these come in correctly:\n\n```\nsage: from sage.combinat.chas.omp_hopf_algebras import HopfAlgebraOnOrderedMultisetPartitions\nsage: H = HopfAlgebraOnOrderedMultisetPartitions(QQ).H()\nsage: H[[1,2],[1,3]]\nH[{1,2}, {1,3}]\nsage: H[[[1,2],[1,3]]]\nH[{1,2}, {1,3}]\n```\nBut this one is problematic (there are two possible intended OMPs):\n\n```\nsage: H[[1,2]]\n```\nShould it be `H(OrderedMultisetPartition([This is the Trac macro *1,2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2-macro)))` or should it be `H(OrderedMultisetPartition([1,2]))`\n\n**NOTE:** A similar shorthand confusion happens for WQSym (e.g., tickets  #25133, #25151). There, I'd say the problem is even more serious due to the \"words\" option that we have allowed for that Hopf algebra. Indeed, perhaps this \"bug\" even merits a new ticket:\n\n```\nsage: M = WordQuasiSymmetricFunctions(QQ).M()\nsage: x = M[[1,3],[2]]; x\nM[{1, 3}, {2}]\nsage: M.options.objects = \"words\"\nsage: x\nM[1, 2, 1]\nsage: M[OrderedSetPartition([1,2,1])]\nM[1, 2, 1]\nsage: M[1,2,1]\nM[1, 1]\nsage: M[[1,2,1]]\nM[1, 1]\n```",
    "created_at": "2018-06-12T15:00:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349978",
    "user": "https://github.com/alauve"
}
```

I think I should remove the user shorthand for `OrderedMultisetPartition` that uses `OrderedMultisetPartitions.from_list()`.

While the shorthand is nice for `OrderedMultisetPartition`, I don't see how to make it play nicely with the `__getitem__()` method for combinatorial free modules over `OrderedMultisetPartitions`.

E.g., in the present state of ticket #25543, these come in correctly:

```
sage: from sage.combinat.chas.omp_hopf_algebras import HopfAlgebraOnOrderedMultisetPartitions
sage: H = HopfAlgebraOnOrderedMultisetPartitions(QQ).H()
sage: H[[1,2],[1,3]]
H[{1,2}, {1,3}]
sage: H[[[1,2],[1,3]]]
H[{1,2}, {1,3}]
```
But this one is problematic (there are two possible intended OMPs):

```
sage: H[[1,2]]
```
Should it be `H(OrderedMultisetPartition([This is the Trac macro *1,2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,2-macro)))` or should it be `H(OrderedMultisetPartition([1,2]))`

**NOTE:** A similar shorthand confusion happens for WQSym (e.g., tickets  #25133, #25151). There, I'd say the problem is even more serious due to the "words" option that we have allowed for that Hopf algebra. Indeed, perhaps this "bug" even merits a new ticket:

```
sage: M = WordQuasiSymmetricFunctions(QQ).M()
sage: x = M[[1,3],[2]]; x
M[{1, 3}, {2}]
sage: M.options.objects = "words"
sage: x
M[1, 2, 1]
sage: M[OrderedSetPartition([1,2,1])]
M[1, 2, 1]
sage: M[1,2,1]
M[1, 1]
sage: M[[1,2,1]]
M[1, 1]
```



---

archive/issue_comments_349979.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-06-12T15:00:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349979",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_events_063105.json:
```json
{
    "actor": "https://github.com/alauve",
    "created_at": "2018-06-12T15:00:22Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "milestone": "sage-8.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/24911#event-63105"
}
```



---

archive/issue_comments_349980.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-13T17:35:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349980",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349981.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-06-13T21:52:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349981",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349982.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-23T16:57:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349982",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349983.json:
```json
{
    "body": "I removed the functionality\n\n```\nsage: OrderedMultisetPartition([1,2,0,1,2,3])\n[{1,2}, {1,2,3}]\n```\nbecause it conflicts with the `__getitem__` method when using `OrderedMultisetPartitions` as index set for combinatorial free modules.\n\nIt still exists as a method for the parent class. That is, \n\n```\nsage: OrderedMultisetPartitions().from_list([1,2,0,1,2,3])\n[{1,2}, {1,2,3}]\n```\nstill works.",
    "created_at": "2018-07-23T17:02:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349983",
    "user": "https://github.com/alauve"
}
```

I removed the functionality

```
sage: OrderedMultisetPartition([1,2,0,1,2,3])
[{1,2}, {1,2,3}]
```
because it conflicts with the `__getitem__` method when using `OrderedMultisetPartitions` as index set for combinatorial free modules.

It still exists as a method for the parent class. That is, 

```
sage: OrderedMultisetPartitions().from_list([1,2,0,1,2,3])
[{1,2}, {1,2,3}]
```
still works.



---

archive/issue_comments_349984.json:
```json
{
    "body": "Hi Aaron,\n\nOverall, the code looks pretty good. Here are some suggestions from the user point of view:\n\n- If the user inputs the wrong data structure, it might be a good idea to give a more informative error message saying what went wrong\n\n```\nsage: p=OrderedMultisetPartition([[5, 3], [1, 3, 3]])\n...\n/Applications/sage/local/lib/python2.7/site-packages/sage/cpython/getattr.pyx in sage.cpython.getattr.getattr_from_other_class (build/cythonized/sage/cpython/getattr.c:2468)()\n    387         dummy_error_message.cls = type(self)\n    388         dummy_error_message.name = name\n--> 389         raise AttributeError(dummy_error_message)\n    390     cdef PyObject* attr = instance_getattr(cls, name)\n    391     if attr is NULL:\n\nAttributeError: 'OrderedMultisetPartitions_X_with_category.element_class' object has no attribute '_n'\n```\n\n- I am not sure one should keep the input with 0's option. For example, the user could do something strange like\n\n```\nsage: P=OrderedMultisetPartitions([0,0,1])\nsage: P.from_list([1,0,0,0,0])\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-23-128db23691d7> in <module>()\n----> 1 P.from_list([Integer(1),Integer(0),Integer(0),Integer(0),Integer(0)])\n\n/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/multiset_partition_ordered.pyc in from_list(self, lst)\n   1685             raise ValueError(\"Something is wrong: `from_list` does not expect to see negative integers; received {}.\".format(str(lst)))\n   1686         if 0 in list(lst) or '0' in list(lst):\n-> 1687             return self._from_zero_list(lst)\n   1688         else:\n   1689             d = [frozenset([x]) for x in lst]\n\n/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/multiset_partition_ordered.pyc in _from_zero_list(self, lst_with_zeros)\n   1732                 return c\n   1733         else:\n-> 1734             raise ValueError(\"ordered multiset partitions do not have repeated entries within blocks (%s received)\"%str(co))\n   1735 \n   1736     def an_element(self):\n\nValueError: ordered multiset partitions do not have repeated entries within blocks ([[1]] received)\n```\n\n- Perhaps use slightly bigger examples for `deconcatenate` and `split`.",
    "created_at": "2018-07-24T14:14:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349984",
    "user": "https://github.com/anneschilling"
}
```

Hi Aaron,

Overall, the code looks pretty good. Here are some suggestions from the user point of view:

- If the user inputs the wrong data structure, it might be a good idea to give a more informative error message saying what went wrong

```
sage: p=OrderedMultisetPartition([[5, 3], [1, 3, 3]])
...
/Applications/sage/local/lib/python2.7/site-packages/sage/cpython/getattr.pyx in sage.cpython.getattr.getattr_from_other_class (build/cythonized/sage/cpython/getattr.c:2468)()
    387         dummy_error_message.cls = type(self)
    388         dummy_error_message.name = name
--> 389         raise AttributeError(dummy_error_message)
    390     cdef PyObject* attr = instance_getattr(cls, name)
    391     if attr is NULL:

AttributeError: 'OrderedMultisetPartitions_X_with_category.element_class' object has no attribute '_n'
```

- I am not sure one should keep the input with 0's option. For example, the user could do something strange like

```
sage: P=OrderedMultisetPartitions([0,0,1])
sage: P.from_list([1,0,0,0,0])
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-23-128db23691d7> in <module>()
----> 1 P.from_list([Integer(1),Integer(0),Integer(0),Integer(0),Integer(0)])

/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/multiset_partition_ordered.pyc in from_list(self, lst)
   1685             raise ValueError("Something is wrong: `from_list` does not expect to see negative integers; received {}.".format(str(lst)))
   1686         if 0 in list(lst) or '0' in list(lst):
-> 1687             return self._from_zero_list(lst)
   1688         else:
   1689             d = [frozenset([x]) for x in lst]

/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/multiset_partition_ordered.pyc in _from_zero_list(self, lst_with_zeros)
   1732                 return c
   1733         else:
-> 1734             raise ValueError("ordered multiset partitions do not have repeated entries within blocks (%s received)"%str(co))
   1735 
   1736     def an_element(self):

ValueError: ordered multiset partitions do not have repeated entries within blocks ([[1]] received)
```

- Perhaps use slightly bigger examples for `deconcatenate` and `split`.



---

archive/issue_comments_349985.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T14:28:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349985",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349986.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T14:37:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349986",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349987.json:
```json
{
    "body": "One more thing that I noticed is that the picture of the crystal is now not displayed using the ordered multisets (which I think it should!), but rather the tableau model, see\n\n```\nsage: B = crystals.Minimaj(2,3,2)\nsage: view(B)\nsage: B.list()\n[((2, 1), (1,)), ((2,), (1, 2)), ((1,), (1, 2)), ((1, 2), (2,))]\n```",
    "created_at": "2018-07-24T14:54:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349987",
    "user": "https://github.com/anneschilling"
}
```

One more thing that I noticed is that the picture of the crystal is now not displayed using the ordered multisets (which I think it should!), but rather the tableau model, see

```
sage: B = crystals.Minimaj(2,3,2)
sage: view(B)
sage: B.list()
[((2, 1), (1,)), ((2,), (1, 2)), ((1,), (1, 2)), ((1, 2), (2,))]
```



---

archive/issue_comments_349988.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T15:31:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349988",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349989.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T15:33:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349989",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349990.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T15:34:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349990",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349991.json:
```json
{
    "body": "Replying to [comment:95 aschilling]:\n> One more thing that I noticed is that the picture of the crystal is now not displayed using the ordered multisets (which I think it should!), but rather the tableau model, see\n> \n> ```\n> sage: B = crystals.Minimaj(2,3,2)\n> sage: view(B)\n> sage: B.list()\n> [((2, 1), (1,)), ((2,), (1, 2)), ((1,), (1, 2)), ((1, 2), (2,))]\n> ```\n\n\nThis might take awhile to track down (though I agree with the sentiment), if anybody knows how, precisely, latex decides what to print for an element of a crystal, please chime in.",
    "created_at": "2018-07-24T19:26:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349991",
    "user": "https://github.com/alauve"
}
```

Replying to [comment:95 aschilling]:
> One more thing that I noticed is that the picture of the crystal is now not displayed using the ordered multisets (which I think it should!), but rather the tableau model, see
> 
> ```
> sage: B = crystals.Minimaj(2,3,2)
> sage: view(B)
> sage: B.list()
> [((2, 1), (1,)), ((2,), (1, 2)), ((1,), (1, 2)), ((1, 2), (2,))]
> ```


This might take awhile to track down (though I agree with the sentiment), if anybody knows how, precisely, latex decides what to print for an element of a crystal, please chime in.



---

archive/issue_comments_349992.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T19:26:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349992",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349993.json:
```json
{
    "body": "I tracked down the latex problem. Try again:\n\n```\nage: B = crystals.Minimaj(2,3,2)\nsage: view(B)\n```",
    "created_at": "2018-07-24T19:45:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349993",
    "user": "https://github.com/alauve"
}
```

I tracked down the latex problem. Try again:

```
age: B = crystals.Minimaj(2,3,2)
sage: view(B)
```



---

archive/issue_comments_349994.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T19:45:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349994",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349995.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-24T19:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349995",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_349996.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-07-24T22:03:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349996",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_349997.json:
```json
{
    "body": "Changing keywords from \"IMA coding sprint, CHAs\" to \"IMA coding sprint, CHAs, sage@icerm\".",
    "created_at": "2018-07-25T01:18:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349997",
    "user": "https://github.com/anneschilling"
}
```

Changing keywords from "IMA coding sprint, CHAs" to "IMA coding sprint, CHAs, sage@icerm".



---

archive/issue_comments_349998.json:
```json
{
    "body": "Now I get a doctest failure\n\n```\nsage -t multiset_partition_ordered.py\n**********************************************************************\nFile \"multiset_partition_ordered.py\", line 2229, in sage.combinat.multiset_partition_ordered.OrderedMultisetPartitions_X.__iter__\nFailed example:\n    sorted([next(it) for _ in range(O.cardinality())], key=str)\nExpected:\n    [[{'a'}, {1}, {1}],\n     [{1,'a'}, {1}],\n     [{1}, {'a'}, {1}],\n     [{1}, {1,'a'}],\n     [{1}, {1}, {'a'}]]\nGot:\n    [[{1,'a'}, {1}],\n     [{1}, {'a'}, {1}],\n     [{1}, {1,'a'}],\n     [{1}, {1}, {'a'}],\n     [{1}, {1}, {'a'}]]\n**********************************************************************\n1 item had failures:\n   1 of   7 in sage.combinat.multiset_partition_ordered.OrderedMultisetPartitions_X.__iter__\n    [556 tests, 1 failure, 24.87 s]\n----------------------------------------------------------------------\nsage -t multiset_partition_ordered.py  # 1 doctest failed\n----------------------------------------------------------------------\n```",
    "created_at": "2018-07-25T01:19:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349998",
    "user": "https://github.com/anneschilling"
}
```

Now I get a doctest failure

```
sage -t multiset_partition_ordered.py
**********************************************************************
File "multiset_partition_ordered.py", line 2229, in sage.combinat.multiset_partition_ordered.OrderedMultisetPartitions_X.__iter__
Failed example:
    sorted([next(it) for _ in range(O.cardinality())], key=str)
Expected:
    [[{'a'}, {1}, {1}],
     [{1,'a'}, {1}],
     [{1}, {'a'}, {1}],
     [{1}, {1,'a'}],
     [{1}, {1}, {'a'}]]
Got:
    [[{1,'a'}, {1}],
     [{1}, {'a'}, {1}],
     [{1}, {1,'a'}],
     [{1}, {1}, {'a'}],
     [{1}, {1}, {'a'}]]
**********************************************************************
1 item had failures:
   1 of   7 in sage.combinat.multiset_partition_ordered.OrderedMultisetPartitions_X.__iter__
    [556 tests, 1 failure, 24.87 s]
----------------------------------------------------------------------
sage -t multiset_partition_ordered.py  # 1 doctest failed
----------------------------------------------------------------------
```



---

archive/issue_comments_349999.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-25T01:35:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-349999",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350000.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-07-25T01:37:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350000",
    "user": "https://github.com/anneschilling"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_350001.json:
```json
{
    "body": "Changing keywords from \"IMA coding sprint, CHAs, sage@icerm\" to \"IMA coding sprint, CHAs, sagedays@icerm\".",
    "created_at": "2018-07-25T01:37:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350001",
    "user": "https://github.com/anneschilling"
}
```

Changing keywords from "IMA coding sprint, CHAs, sage@icerm" to "IMA coding sprint, CHAs, sagedays@icerm".



---

archive/issue_comments_350002.json:
```json
{
    "body": "That doctest is still fucked up; there is a duplicate in the resulting `list(O)`.",
    "created_at": "2018-07-25T01:45:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350002",
    "user": "https://github.com/darijgr"
}
```

That doctest is still fucked up; there is a duplicate in the resulting `list(O)`.



---

archive/issue_comments_350003.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2018-07-25T01:45:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350003",
    "user": "https://github.com/darijgr"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_350004.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-25T03:54:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350004",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350005.json:
```json
{
    "body": "Replaced the iterator algorithm by one I was able to prove. That should fix the doctest. Note that I've changed lots of doctests since the new algorithm yields the partitions in a different order; I hope that the old order wasn't being tacitly relied upon!",
    "created_at": "2018-07-25T03:58:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350005",
    "user": "https://github.com/darijgr"
}
```

Replaced the iterator algorithm by one I was able to prove. That should fix the doctest. Note that I've changed lots of doctests since the new algorithm yields the partitions in a different order; I hope that the old order wasn't being tacitly relied upon!



---

archive/issue_comments_350006.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-07-25T03:59:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350006",
    "user": "https://github.com/darijgr"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_350007.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-07-25T04:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350007",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_350008.json:
```json
{
    "body": "I figured out what was causing the repeats in iteration, and don't like the recursive algorithm Darij decided on.\nI'm reverting back to old iteration method (suitably modified). Please have another look.",
    "created_at": "2018-07-25T04:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350008",
    "user": "https://github.com/alauve"
}
```

I figured out what was causing the repeats in iteration, and don't like the recursive algorithm Darij decided on.
I'm reverting back to old iteration method (suitably modified). Please have another look.



---

archive/issue_comments_350009.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-25T04:35:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350009",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350010.json:
```json
{
    "body": "The new method looks fine as well, but please retract these:\n\n```\n     If key ``weight`` is present, ignore all other constraints\n     (passes to ``_iterator_weight``)::\n+    ::\n```\n\n```\n-    The dictionary ``weight`` may contain values equal to `0`;\n-    the corresponding keys are ignored.\n```\n\n```\n@@ -2827,8 +2812,7 @@ def _iterator_order(A, d, lengths=None):\n \n def _partial_sum(lst):\n     \"\"\"\n-    Return partial sums of elements in ``lst``,\n-    including the empty and the full sum.\n+    Return partial sums of elements in ``lst``.\n \n     EXAMPLES::\n \n@@ -2838,8 +2822,8 @@ def _partial_sum(lst):\n         [0, 1, 4, 9]\n     \"\"\"\n     result = [0]\n-    for i in lst:\n-        result.append(result[-1] + i)\n+    for i in range(len(lst)):\n+        result.append(result[-1]+lst[i])\n     return result\n \n def _descents(w):\n```\n\n(I should have done a better job at separating my edits...)",
    "created_at": "2018-07-25T04:49:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350010",
    "user": "https://github.com/darijgr"
}
```

The new method looks fine as well, but please retract these:

```
     If key ``weight`` is present, ignore all other constraints
     (passes to ``_iterator_weight``)::
+    ::
```

```
-    The dictionary ``weight`` may contain values equal to `0`;
-    the corresponding keys are ignored.
```

```
@@ -2827,8 +2812,7 @@ def _iterator_order(A, d, lengths=None):
 
 def _partial_sum(lst):
     """
-    Return partial sums of elements in ``lst``,
-    including the empty and the full sum.
+    Return partial sums of elements in ``lst``.
 
     EXAMPLES::
 
@@ -2838,8 +2822,8 @@ def _partial_sum(lst):
         [0, 1, 4, 9]
     """
     result = [0]
-    for i in lst:
-        result.append(result[-1] + i)
+    for i in range(len(lst)):
+        result.append(result[-1]+lst[i])
     return result
 
 def _descents(w):
```

(I should have done a better job at separating my edits...)



---

archive/issue_comments_350011.json:
```json
{
    "body": "Okay. I will handle this. And Anne convinced me to but back a troublesome example. So nobody pull/push for awhile please.",
    "created_at": "2018-07-25T13:03:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350011",
    "user": "https://github.com/alauve"
}
```

Okay. I will handle this. And Anne convinced me to but back a troublesome example. So nobody pull/push for awhile please.



---

archive/issue_comments_350012.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-25T13:43:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350012",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350013.json:
```json
{
    "body": "Darij, I don't mention it in the commit memo, but I retracted changes as requested.",
    "created_at": "2018-07-25T13:44:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350013",
    "user": "https://github.com/alauve"
}
```

Darij, I don't mention it in the commit memo, but I retracted changes as requested.



---

archive/issue_comments_350014.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-07-25T13:44:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350014",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_350015.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-25T19:30:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350015",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350016.json:
```json
{
    "body": "Based on what Patchbot has said:\n\nI think there are two docstring EXAMPLES that only have one semicolon instead of two.\n\nThere are complaints that `shuffle.py` imports but doesn't use Compositions, I think because Compositions is used for an example but not any actual code? Not sure if that's an actual issue or not.\n\nThere's some minor Python3 compatibility issues (8 instance of something.iteritems() being used, I think they should all be iteritems(something) now? ).",
    "created_at": "2018-07-25T19:36:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350016",
    "user": "https://github.com/kevindilks"
}
```

Based on what Patchbot has said:

I think there are two docstring EXAMPLES that only have one semicolon instead of two.

There are complaints that `shuffle.py` imports but doesn't use Compositions, I think because Compositions is used for an example but not any actual code? Not sure if that's an actual issue or not.

There's some minor Python3 compatibility issues (8 instance of something.iteritems() being used, I think they should all be iteritems(something) now? ).



---

archive/issue_comments_350017.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-07-25T20:59:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350017",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350018.json:
```json
{
    "body": "It looks good now to me!\n\n---\nNew commits:\n|                                                                                                                                          |                               |\n|------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|\n|[d5c75b0](https://git.sagemath.org/sage.git/commit?id=d5c75b09029c1c4ad0d0d0823abe4080d8fa8433)|`python3 updates re: iteritems`|\n---\nNew commits:",
    "created_at": "2018-07-25T21:04:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350018",
    "user": "https://github.com/anneschilling"
}
```

It looks good now to me!

---
New commits:
|                                                                                                                                          |                               |
|------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|
|[d5c75b0](https://git.sagemath.org/sage.git/commit?id=d5c75b09029c1c4ad0d0d0823abe4080d8fa8433)|`python3 updates re: iteritems`|
---
New commits:



---

archive/issue_comments_350019.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-07-25T21:04:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350019",
    "user": "https://github.com/anneschilling"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_350020.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2018-08-01T08:39:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350020",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_350021.json:
```json
{
    "body": "On 32-bit linux:\n\n```\nFile \"src/sage/combinat/multiset_partition_ordered.py\", line 688, in sage.combinat.multiset_partition_ordered.OrderedMultisetPartition.finer\nFailed example:\n    o.finer()\nExpected:\n    {[{1}, {'b'}, {'a'}, {1}], [{1}, {'a'}, {'b'}, {1}], [{1}, {'a','b'}, {1}]}\nGot:\n    {[{1}, {'b'}, {'a'}, {1}], [{1}, {'a','b'}, {1}], [{1}, {'a'}, {'b'}, {1}]}\n```",
    "created_at": "2018-08-01T08:39:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350021",
    "user": "https://github.com/vbraun"
}
```

On 32-bit linux:

```
File "src/sage/combinat/multiset_partition_ordered.py", line 688, in sage.combinat.multiset_partition_ordered.OrderedMultisetPartition.finer
Failed example:
    o.finer()
Expected:
    {[{1}, {'b'}, {'a'}, {1}], [{1}, {'a'}, {'b'}, {1}], [{1}, {'a','b'}, {1}]}
Got:
    {[{1}, {'b'}, {'a'}, {1}], [{1}, {'a','b'}, {1}], [{1}, {'a'}, {'b'}, {1}]}
```



---

archive/issue_comments_350022.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-01T14:37:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350022",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350023.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-08-01T14:42:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350023",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_350024.json:
```json
{
    "body": "I think I have corrected the problem:\n\nI've added a call to `sorted` in the doctest, since `o.finer()` naturally returns a `Set` object (which seems to have unreliable order of output).",
    "created_at": "2018-08-01T14:42:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350024",
    "user": "https://github.com/alauve"
}
```

I think I have corrected the problem:

I've added a call to `sorted` in the doctest, since `o.finer()` naturally returns a `Set` object (which seems to have unreliable order of output).



---

archive/issue_comments_350025.json:
```json
{
    "body": "One request:\n\nplease avoid `Set` in library code, whenever possible.  Use `set`, it is much faster and more reliable.\n\nFor example, if for some stupid reason `alph` happens to be unhashable, the comparison\n\n```\nlen(Set(alph)) == len(alph))\n```\nwill always yield `True`, without warning.\n\nI would also suggest to return `set`s instead of `Set`s, whenever there is no very good reason to use the latter.",
    "created_at": "2018-08-01T14:51:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350025",
    "user": "https://github.com/mantepse"
}
```

One request:

please avoid `Set` in library code, whenever possible.  Use `set`, it is much faster and more reliable.

For example, if for some stupid reason `alph` happens to be unhashable, the comparison

```
len(Set(alph)) == len(alph))
```
will always yield `True`, without warning.

I would also suggest to return `set`s instead of `Set`s, whenever there is no very good reason to use the latter.



---

archive/issue_comments_350026.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-08-01T15:01:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350026",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_350027.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-01T21:58:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350027",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350028.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-01T22:02:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350028",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350029.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-08-02T01:06:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350029",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_350030.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-08-02T03:12:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350030",
    "user": "https://github.com/anneschilling"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_350031.json:
```json
{
    "body": "Looks good to me.",
    "created_at": "2018-08-02T03:12:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350031",
    "user": "https://github.com/anneschilling"
}
```

Looks good to me.



---

archive/issue_comments_350032.json:
```json
{
    "body": "There are a few places where I would very strongly discourage the use of `Set`.  I'd be grateful for explanation:\n\n* `is_finer`:\n* `_constraint_repr_`: apart from being an internal method (so `Set` is probably not what you want), it's not clear to me whether `cdict[\"alphabet\"]` is even hashable...\n* `_refine_block`: why do you want a set of `Set`s?  Perhaps you want a set of `frozenset`s?\n* `_split_block`: same as for `_refine_block`\n\nIn general, I think it would be wonderful if the internal representation would be compatible with `SetPartition` after #25462",
    "created_at": "2018-08-02T12:12:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350032",
    "user": "https://github.com/mantepse"
}
```

There are a few places where I would very strongly discourage the use of `Set`.  I'd be grateful for explanation:

* `is_finer`:
* `_constraint_repr_`: apart from being an internal method (so `Set` is probably not what you want), it's not clear to me whether `cdict["alphabet"]` is even hashable...
* `_refine_block`: why do you want a set of `Set`s?  Perhaps you want a set of `frozenset`s?
* `_split_block`: same as for `_refine_block`

In general, I think it would be wonderful if the internal representation would be compatible with `SetPartition` after #25462



---

archive/issue_comments_350033.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2018-08-02T12:12:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350033",
    "user": "https://github.com/mantepse"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_350034.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-02T20:12:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350034",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350035.json:
```json
{
    "body": "Replying to [comment:135 mantepse]:\n> There are a few places where I would very strongly discourage the use of `Set`.  I'd be grateful for explanation:\n> \n> * `is_finer`:\n \ndone. no good explanation other than I did an insufficient find-replace.\n\n.\n> * `_constraint_repr_`: apart from being an internal method (so `Set` is probably not what you want), it's not clear to me whether `cdict[\"alphabet\"]` is even hashable...\n \nThe alphabet should be hashable. I suppose I have not explicitly mentioned that anywhere. I also will say the main reason I didn't use `set` here was out of laziness. Let me know if you are happy with the alternative.\n\n.\n> * `_refine_block`: why do you want a set of `Set`s?  Perhaps you want a set of `frozenset`s?\n \nlaziness. corrected.\n\n.\n> * `_split_block`: same as for `_refine_block`\n \nlaziness. corrected.\n\n.\n> In general, I think it would be wonderful if the internal representation would be compatible with `SetPartition` after #25462\n\nI believe I have already done this: both are cloneable arrays with data being lists of frozensets. Please elaborate if you mean something different by this comment.",
    "created_at": "2018-08-02T20:13:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350035",
    "user": "https://github.com/alauve"
}
```

Replying to [comment:135 mantepse]:
> There are a few places where I would very strongly discourage the use of `Set`.  I'd be grateful for explanation:
> 
> * `is_finer`:
 
done. no good explanation other than I did an insufficient find-replace.

.
> * `_constraint_repr_`: apart from being an internal method (so `Set` is probably not what you want), it's not clear to me whether `cdict["alphabet"]` is even hashable...
 
The alphabet should be hashable. I suppose I have not explicitly mentioned that anywhere. I also will say the main reason I didn't use `set` here was out of laziness. Let me know if you are happy with the alternative.

.
> * `_refine_block`: why do you want a set of `Set`s?  Perhaps you want a set of `frozenset`s?
 
laziness. corrected.

.
> * `_split_block`: same as for `_refine_block`
 
laziness. corrected.

.
> In general, I think it would be wonderful if the internal representation would be compatible with `SetPartition` after #25462

I believe I have already done this: both are cloneable arrays with data being lists of frozensets. Please elaborate if you mean something different by this comment.



---

archive/issue_comments_350036.json:
```json
{
    "body": "Here are my current comments (more may follow later):\n\nI don't understand why on, e.g., `deconcatenate` you do not simply return a list. You are constructing it in a deterministic way and lists are easier to manipulate and often faster to work with.\n\nHave you compiled and looked at the documentation? I would suspect `minimaj` is ill-formatted.\n\nSame for the `OrderedMultisetPartitions` doc.\n\nThe doc for`OrderedMultisetPartitions.__classcall_private__` does not need to list the classes. The code says that.\n\nI think a better way to do `_satisfies_constraints` is to implement a `dict` whose keys are the strings and whose values are the individual tests. This is going to have better lookup times (you don't need to check all of the keys 1 by 1).\n\nYou should implement `_an_element_` (so `an_element` is cached). Although I thought the category provided the same one as yours by default?\n\n```diff\n-        - ``size`` -- an integer representing a slice of all ordered\n-                      multiset partitions.\n+        - ``size`` -- an integer representing a slice of all ordered\n+          multiset partitions\n```\n\nYou can kill tests `C == loads(dumps(C))` as the `TestSuite` checks this.\n\nIn `prod`, you do not need to pass a list.\n\nInstead of iterating over all `Compositions(n)`, you can use `omposition_iterator_fast(n)`.\n\nThe `def partspoly_coeff(d): return partspoly[d][0]` seems useless. Just put in the return value.\n\nI would make `_iterator_*` return objects that are not actual elements, but lists of frozensets. That way they can be used elsewhere without having to unwrap your elements (which has resulted in large speedups in other code).\n\nThere already is a `partial_sums` method in `composition.py` and in `abstract_word.py`. This actually is abstracted in the (cython) function `running_total` in `misc/misc_c.pyx`.\n\nI think `to_tableau` should actually output a `(SemiStandard)Tableau` (or an element of the corresponding crystal).",
    "created_at": "2018-08-03T04:13:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350036",
    "user": "https://github.com/tscrim"
}
```

Here are my current comments (more may follow later):

I don't understand why on, e.g., `deconcatenate` you do not simply return a list. You are constructing it in a deterministic way and lists are easier to manipulate and often faster to work with.

Have you compiled and looked at the documentation? I would suspect `minimaj` is ill-formatted.

Same for the `OrderedMultisetPartitions` doc.

The doc for`OrderedMultisetPartitions.__classcall_private__` does not need to list the classes. The code says that.

I think a better way to do `_satisfies_constraints` is to implement a `dict` whose keys are the strings and whose values are the individual tests. This is going to have better lookup times (you don't need to check all of the keys 1 by 1).

You should implement `_an_element_` (so `an_element` is cached). Although I thought the category provided the same one as yours by default?

```diff
-        - ``size`` -- an integer representing a slice of all ordered
-                      multiset partitions.
+        - ``size`` -- an integer representing a slice of all ordered
+          multiset partitions
```

You can kill tests `C == loads(dumps(C))` as the `TestSuite` checks this.

In `prod`, you do not need to pass a list.

Instead of iterating over all `Compositions(n)`, you can use `omposition_iterator_fast(n)`.

The `def partspoly_coeff(d): return partspoly[d][0]` seems useless. Just put in the return value.

I would make `_iterator_*` return objects that are not actual elements, but lists of frozensets. That way they can be used elsewhere without having to unwrap your elements (which has resulted in large speedups in other code).

There already is a `partial_sums` method in `composition.py` and in `abstract_word.py`. This actually is abstracted in the (cython) function `running_total` in `misc/misc_c.pyx`.

I think `to_tableau` should actually output a `(SemiStandard)Tableau` (or an element of the corresponding crystal).



---

archive/issue_comments_350037.json:
```json
{
    "body": "milestone update 8.3 -> 8.4",
    "created_at": "2018-08-03T19:18:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350037",
    "user": "https://github.com/videlec"
}
```

milestone update 8.3 -> 8.4



---

archive/issue_events_063106.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2018-08-03T19:18:42Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "milestone": "sage-8.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/24911#event-63106"
}
```



---

archive/issue_events_063107.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2018-08-03T19:18:42Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "milestone": "sage-8.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/24911#event-63107"
}
```



---

archive/issue_comments_350038.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-11T21:09:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350038",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350039.json:
```json
{
    "body": "I addressed some of Travis' comments. Aaron, could you look at the rest?",
    "created_at": "2018-08-11T21:09:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350039",
    "user": "https://github.com/anneschilling"
}
```

I addressed some of Travis' comments. Aaron, could you look at the rest?



---

archive/issue_comments_350040.json:
```json
{
    "body": "Replying to [comment:141 aschilling]:\n> I addressed some of Travis' comments. Aaron, could you look at the rest?\n\n\nProbably... I've been unable to get the develop branch to compile on my machines lately, but it looks like this branch is compiling just fine. Stay tuned for updates soon.",
    "created_at": "2018-08-12T06:03:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350040",
    "user": "https://github.com/alauve"
}
```

Replying to [comment:141 aschilling]:
> I addressed some of Travis' comments. Aaron, could you look at the rest?


Probably... I've been unable to get the develop branch to compile on my machines lately, but it looks like this branch is compiling just fine. Stay tuned for updates soon.



---

archive/issue_comments_350041.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-21T17:04:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350041",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350042.json:
```json
{
    "body": "Replying to [comment:138 tscrim]:\n> Here are my current comments (more may follow later):\n> \n> I don't understand why on, e.g., `deconcatenate` you do not simply return a list. You are constructing it in a deterministic way and lists are easier to manipulate and often faster to work with.\n\n\n* For `deconcatenate` perhaps a list is appropriate; I have changed this and a couple other methods. But if a user wishes, say, to know if A is finer than B. Won't it be much faster to search through  `B.finer()` if this is a set instead of a list?\n\n.\n> Have you compiled and looked at the documentation? I would suspect `minimaj` is ill-formatted.\n\n\n* Done? I haven't managed to get my documentation to build lately, even on develop.\n\n.\n> Same for the `OrderedMultisetPartitions` doc.\n\n\n* Done? I haven't managed to get my documentation to build lately, even on develop.\n\n.\n> The doc for`OrderedMultisetPartitions.__classcall_private__` does not need to list the classes. The code says that.\n\n\n* Done.\n\n.\n> I think a better way to do `_satisfies_constraints` is to implement a `dict` whose keys are the strings and whose values are the individual tests. This is going to have better lookup times (you don't need to check all of the keys 1 by 1).\n\n\n* Done? Not sure what you had in mind, actually. Not all tests take the same form, so it's not a matter of just going through the key/value pairs without some if-then statements.\n\n.\n> You should implement `_an_element_` (so `an_element` is cached). Although I thought the category provided the same one as yours by default?\n\n\n* Done. It seems I did reimplement the default for the messy cases. (Deleted these and kept the ones for `*_n` and `*_X` and `*_A`.)\n\n.\n> {{{#!diff\n> -        - ``size`` -- an integer representing a slice of all ordered\n> -                      multiset partitions.\n> +        - ``size`` -- an integer representing a slice of all ordered\n> +          multiset partitions\n> }}}\n\n\n* Done.\n\n.\n> You can kill tests `C == loads(dumps(C))` as the `TestSuite` checks this.\n\n\n* Done.\n\n.\n> In `prod`, you do not need to pass a list.\n\n\n* Done.\n\n.\n> Instead of iterating over all `Compositions(n)`, you can use `omposition_iterator_fast(n)`.\n\n\n* Done.\n\n.\n> The `def partspoly_coeff(d): return partspoly[d][0]` seems useless. Just put in the return value.\n\n\n* Done.\n\n.\n> I would make `_iterator_*` return objects that are not actual elements, but lists of frozensets. That way they can be used elsewhere without having to unwrap your elements (which has resulted in large speedups in other code).\n\n\n* Done Implemented as tuples of `frozenset`s.\n\n.\n> There already is a `partial_sums` method in `composition.py` and in `abstract_word.py`. This actually is abstracted in the (cython) function `running_total` in `misc/misc_c.pyx`.\n\n\n* Done.\n\n.\n> I think `to_tableau` should actually output a `(SemiStandard)Tableau` (or an element of the corresponding crystal).\n\n\n* Not sure what to do with this one. \nAnne, can you describe succinctly how to build a list of (skew)tableaux from the list of words that `.to_tableau` produces?\nTravis, internally this is used as a list of lists, so packing and unpacking as a list of skew tableaux is a bit of a waste. Do you recommend separately making a private method\n`._to_tableau_words` that produces what we currently produce with `.to_tableau`?",
    "created_at": "2018-08-21T17:09:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350042",
    "user": "https://github.com/alauve"
}
```

Replying to [comment:138 tscrim]:
> Here are my current comments (more may follow later):
> 
> I don't understand why on, e.g., `deconcatenate` you do not simply return a list. You are constructing it in a deterministic way and lists are easier to manipulate and often faster to work with.


* For `deconcatenate` perhaps a list is appropriate; I have changed this and a couple other methods. But if a user wishes, say, to know if A is finer than B. Won't it be much faster to search through  `B.finer()` if this is a set instead of a list?

.
> Have you compiled and looked at the documentation? I would suspect `minimaj` is ill-formatted.


* Done? I haven't managed to get my documentation to build lately, even on develop.

.
> Same for the `OrderedMultisetPartitions` doc.


* Done? I haven't managed to get my documentation to build lately, even on develop.

.
> The doc for`OrderedMultisetPartitions.__classcall_private__` does not need to list the classes. The code says that.


* Done.

.
> I think a better way to do `_satisfies_constraints` is to implement a `dict` whose keys are the strings and whose values are the individual tests. This is going to have better lookup times (you don't need to check all of the keys 1 by 1).


* Done? Not sure what you had in mind, actually. Not all tests take the same form, so it's not a matter of just going through the key/value pairs without some if-then statements.

.
> You should implement `_an_element_` (so `an_element` is cached). Although I thought the category provided the same one as yours by default?


* Done. It seems I did reimplement the default for the messy cases. (Deleted these and kept the ones for `*_n` and `*_X` and `*_A`.)

.
> {{{#!diff
> -        - ``size`` -- an integer representing a slice of all ordered
> -                      multiset partitions.
> +        - ``size`` -- an integer representing a slice of all ordered
> +          multiset partitions
> }}}


* Done.

.
> You can kill tests `C == loads(dumps(C))` as the `TestSuite` checks this.


* Done.

.
> In `prod`, you do not need to pass a list.


* Done.

.
> Instead of iterating over all `Compositions(n)`, you can use `omposition_iterator_fast(n)`.


* Done.

.
> The `def partspoly_coeff(d): return partspoly[d][0]` seems useless. Just put in the return value.


* Done.

.
> I would make `_iterator_*` return objects that are not actual elements, but lists of frozensets. That way they can be used elsewhere without having to unwrap your elements (which has resulted in large speedups in other code).


* Done Implemented as tuples of `frozenset`s.

.
> There already is a `partial_sums` method in `composition.py` and in `abstract_word.py`. This actually is abstracted in the (cython) function `running_total` in `misc/misc_c.pyx`.


* Done.

.
> I think `to_tableau` should actually output a `(SemiStandard)Tableau` (or an element of the corresponding crystal).


* Not sure what to do with this one. 
Anne, can you describe succinctly how to build a list of (skew)tableaux from the list of words that `.to_tableau` produces?
Travis, internally this is used as a list of lists, so packing and unpacking as a list of skew tableaux is a bit of a waste. Do you recommend separately making a private method
`._to_tableau_words` that produces what we currently produce with `.to_tableau`?



---

archive/issue_comments_350043.json:
```json
{
    "body": "Replying to [comment:144 alauve]:\n\n> > Have you compiled and looked at the documentation? I would suspect `minimaj` is ill-formatted.\n\n> \n> * Done? I haven't managed to get my documentation to build lately, even on develop.\n\n\nThe documentation looks fine to me.\n\n> > Same for the `OrderedMultisetPartitions` doc.\n\n> \n> * Done? I haven't managed to get my documentation to build lately, even on develop.\n\n\nLooks fine to me.\n\n> > I think `to_tableau` should actually output a `(SemiStandard)Tableau` (or an element of the corresponding crystal).\n\n> \n> * Not sure what to do with this one. \n> Anne, can you describe succinctly how to build a list of (skew)tableaux from the list of words that `.to_tableau` produces?\n> Travis, internally this is used as a list of lists, so packing and unpacking as a list of skew tableaux is a bit of a waste. Do you recommend separately making a private method\n> `._to_tableau_words` that produces what we currently produce with `.to_tableau`?\n\n\nI disagree with Travis. The output (mathematically) is really a tuple of column tableaux and a ribbon tableaux. So the output should definitely not be a semistandard tableau. We could just make these methods private as Aaron suggests. Or give the method a different name, such as `to_word_of_tableaux_representation` or something like that.",
    "created_at": "2018-08-27T03:24:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350043",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:144 alauve]:

> > Have you compiled and looked at the documentation? I would suspect `minimaj` is ill-formatted.

> 
> * Done? I haven't managed to get my documentation to build lately, even on develop.


The documentation looks fine to me.

> > Same for the `OrderedMultisetPartitions` doc.

> 
> * Done? I haven't managed to get my documentation to build lately, even on develop.


Looks fine to me.

> > I think `to_tableau` should actually output a `(SemiStandard)Tableau` (or an element of the corresponding crystal).

> 
> * Not sure what to do with this one. 
> Anne, can you describe succinctly how to build a list of (skew)tableaux from the list of words that `.to_tableau` produces?
> Travis, internally this is used as a list of lists, so packing and unpacking as a list of skew tableaux is a bit of a waste. Do you recommend separately making a private method
> `._to_tableau_words` that produces what we currently produce with `.to_tableau`?


I disagree with Travis. The output (mathematically) is really a tuple of column tableaux and a ribbon tableaux. So the output should definitely not be a semistandard tableau. We could just make these methods private as Aaron suggests. Or give the method a different name, such as `to_word_of_tableaux_representation` or something like that.



---

archive/issue_comments_350044.json:
```json
{
    "body": "Speaking of \"different name,\" I would like to broach the subject of the name for these objects.\n\nTo me, a partition (ordered or not) is a decomposition of some gadget into like gadgets. So, a partition of `{{1,1,1,2,2}}` might look like `{{1,2}},  {{1,1}},  {{2}}`. And an **ordered multiset partition** would then look like this (dropping the braces),\n\n`(11, 2, 12)`.\n\nHere, we further demand that the blocks have distinct entries. I might call our present gadgets **__strict__ ordered multiset partitions**, or **ordered partition of a multiset __into sets__**. That's a mouthful, but a certain person (Mike Z) has come across the need to code honest ordered multiset partitions (as I've defined them in the previous paragraph).\n\nI propose to change `OrderedMultisetPartition` to `OrderedMultisetPartition_Strict` and graciously accept alternative suggestions.",
    "created_at": "2018-08-29T12:28:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350044",
    "user": "https://github.com/alauve"
}
```

Speaking of "different name," I would like to broach the subject of the name for these objects.

To me, a partition (ordered or not) is a decomposition of some gadget into like gadgets. So, a partition of `{{1,1,1,2,2}}` might look like `{{1,2}},  {{1,1}},  {{2}}`. And an **ordered multiset partition** would then look like this (dropping the braces),

`(11, 2, 12)`.

Here, we further demand that the blocks have distinct entries. I might call our present gadgets **__strict__ ordered multiset partitions**, or **ordered partition of a multiset __into sets__**. That's a mouthful, but a certain person (Mike Z) has come across the need to code honest ordered multiset partitions (as I've defined them in the previous paragraph).

I propose to change `OrderedMultisetPartition` to `OrderedMultisetPartition_Strict` and graciously accept alternative suggestions.



---

archive/issue_comments_350045.json:
```json
{
    "body": "So I had the opportunity to discuss this with Aaron in person (yesterday, but it was a continuation of a conversation when he started the ticket) and we both felt that it was a good idea to choose a more precise name.  I am in agreement with adding `Strict`.  The reason we felt like more precision is appropriate is that we could lay out the need for four possible objects (using `{{ }}` for multisets and `{ }` for sets):\n* multisets of multisets (e.g. `{{ {{1,1,2}},{{2,2}},{{1}},{{1}},{{3}} }}`)- I think that it is appropriate to call these `MultisetPartitions` (I've written code for these objects and will eventually add them to Sage)\n* ordered lists of multisets (e.g. `({{1}},{{}},{{2,2}},{{}},{{3}},{{1,1,2}},{{1}})`) - seems appropriate to call these `OrderedMultisetPartitions`\n* multisets of sets (e.g. `{{ {1,2,3},{1,2},{1,2},{1},{1} }}`)\n* ordered lists of sets (e.g. `({},{1},{1,2},{1,2,3},{},{1,2},{},{1})`)\n\nAll of these objects come up in the research I am working on and so I would like to choose them carefully.  The proposed names for the last two would be `MultisetPartitions_Strict` and `OrderedMultisetPartitions_Strict`.  The other modifier that we discussed in place of `_Strict` we discussed was `IntoSets`.  We kind of felt that was too long, but it only is a few characters difference.",
    "created_at": "2018-08-29T13:19:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350045",
    "user": "https://github.com/zabrocki"
}
```

So I had the opportunity to discuss this with Aaron in person (yesterday, but it was a continuation of a conversation when he started the ticket) and we both felt that it was a good idea to choose a more precise name.  I am in agreement with adding `Strict`.  The reason we felt like more precision is appropriate is that we could lay out the need for four possible objects (using `{{ }}` for multisets and `{ }` for sets):
* multisets of multisets (e.g. `{{ {{1,1,2}},{{2,2}},{{1}},{{1}},{{3}} }}`)- I think that it is appropriate to call these `MultisetPartitions` (I've written code for these objects and will eventually add them to Sage)
* ordered lists of multisets (e.g. `({{1}},{{}},{{2,2}},{{}},{{3}},{{1,1,2}},{{1}})`) - seems appropriate to call these `OrderedMultisetPartitions`
* multisets of sets (e.g. `{{ {1,2,3},{1,2},{1,2},{1},{1} }}`)
* ordered lists of sets (e.g. `({},{1},{1,2},{1,2,3},{},{1,2},{},{1})`)

All of these objects come up in the research I am working on and so I would like to choose them carefully.  The proposed names for the last two would be `MultisetPartitions_Strict` and `OrderedMultisetPartitions_Strict`.  The other modifier that we discussed in place of `_Strict` we discussed was `IntoSets`.  We kind of felt that was too long, but it only is a few characters difference.



---

archive/issue_comments_350046.json:
```json
{
    "body": "I would very much prefer `OrderedMultisetPartitionsIntoSets` because `strict` doesn't tell you at all what it's about, whereas the former is quite precise.",
    "created_at": "2018-08-29T15:18:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350046",
    "user": "https://github.com/mantepse"
}
```

I would very much prefer `OrderedMultisetPartitionsIntoSets` because `strict` doesn't tell you at all what it's about, whereas the former is quite precise.



---

archive/issue_comments_350047.json:
```json
{
    "body": "Besides, I have an (aldor) implementation of Knuth's algorithm M, The Art Of Computer Programming, Pre-Fascicle~3b, page~40, in case that's of interest (trivial to translate to python).",
    "created_at": "2018-08-29T15:22:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350047",
    "user": "https://github.com/mantepse"
}
```

Besides, I have an (aldor) implementation of Knuth's algorithm M, The Art Of Computer Programming, Pre-Fascicle~3b, page~40, in case that's of interest (trivial to translate to python).



---

archive/issue_comments_350048.json:
```json
{
    "body": "Replying to [comment:148 mantepse]:\n> I would very much prefer `OrderedMultisetPartitionsIntoSets` because `strict` doesn't tell you at all what it's about, whereas the former is quite precise.\n\n\nI would also prefer `OrderedMultisetPartitionsIntoSets` since it is more descriptive!",
    "created_at": "2018-08-29T22:14:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350048",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:148 mantepse]:
> I would very much prefer `OrderedMultisetPartitionsIntoSets` because `strict` doesn't tell you at all what it's about, whereas the former is quite precise.


I would also prefer `OrderedMultisetPartitionsIntoSets` since it is more descriptive!



---

archive/issue_comments_350049.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-06T16:25:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350049",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350050.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-06T16:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350050",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350051.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2018-09-06T19:40:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350051",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_350052.json:
```json
{
    "body": "I believe this is ready to go.",
    "created_at": "2018-09-06T19:40:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350052",
    "user": "https://github.com/alauve"
}
```

I believe this is ready to go.



---

archive/issue_comments_350053.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-09T00:54:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350053",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350054.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-09-09T00:59:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350054",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_350055.json:
```json
{
    "body": "There is still work to be done. Some of my bigger changes:\n\n- Anything passed into an `Element` should have a `parent` as the first argument. I have made it a hard error if that does not happen.\n- No need to have an `OrderedMultisetPartitionsIntoSets_all_constraints.__init__` as it is the same as for the base class.\n- The `TestSuite(X).run()` checks `loads(dumps(X)) == X`, so I removed these tests.\n\nSome comments:\n\nThe parent names with `X` and `A` are not descriptive enough IMO. Also, some of your classes have the input parameters in their names, but not all, e.g., `OrderedMultisetPartitionsIntoSets_A` does not also include the fixed order `d`. I think the `X` is fine, but I would replace `A` with `alphabet`.\n\nThe doc for `OrderedMultisetPartitionsIntoSets` will still need some improvements. I don't like the overall formatting with bullet points for the examples. I think paragraph breaks are sufficient, but if you want something more, I would go with `.. RUBRIC::`. (Also, try to keep the prose under 80 chars/line.)\n\nYour `OrderedMultisetPartitionsIntoSets.__classcall_private__` is somewhat of a mess. For instance, if you passed in things as only keyword input, you would get the generic class, which is a bug:\n\n```\nsage: OMP = OrderedMultisetPartitionsIntoSets(alphabet=['A','B'], order=2)\nsage: list(OMP)\n[[{'A','B'}], [{'A'}, {'A'}], [{'A'}, {'B'}], [{'B'}, {'A'}], [{'B'}, {'B'}]]\nsage: OMP\nOrdered Multiset Partitions with constraints: alphabet={'A', 'B'}, order=2\nsage: type(OMP)\n<class 'sage.combinat.multiset_partition_ordered.OrderedMultisetPartitionsIntoSets_all_constraints_with_category'>\nsage: OrderedMultisetPartitionsIntoSets(['A','B'], 2)\nOrdered Multiset Partitions of order 2 over alphabet {A, B}\n```\nAdditionally I generally believe errors should be raised when inputs are incompatible rather than silently ignoring them. I understand this may not be possible for usable code, but it is something to strive for.\n\n```\nsage: OMP = OrderedMultisetPartitionsIntoSets(weight=[1,2],alphabet=['a','b'],order=2); OMP\nOrdered Multiset Partitions with constraint: weight={1: 1, 2: 2}\nsage: type(OMP)\n<class 'sage.combinat.multiset_partition_ordered.OrderedMultisetPartitionsIntoSets_all_constraints_with_category'>\nsage: list(OMP)\n[[{1}, {2}, {2}], [{1,2}, {2}], [{2}, {1}, {2}], [{2}, {1,2}], [{2}, {2}, {1}]]\n```\n\nSomething to note: the `random_element` is not uniform:\n\n```\nsage: OMP = OrderedMultisetPartitionsIntoSets([1,4], 3)\nsage: d = {}\nsage: for _ in range(6000):\n....:     x = OMP.random_element()\n....:     if x in d:\n....:         d[x] += 1\n....:     else:\n....:         d[x] = 1\nsage: d.values()\n[238, 251, 1040, 287, 273, 250, 1005, 991, 213, 243, 249, 960]\n```\n\n```\nsage: OMP = OrderedMultisetPartitionsIntoSets([1,1,3])\nsage: d = {}\nsage: for _ in range(5000):\n....:     x = OMP.random_element()\n....:     if x in d:\n....:         d[x] += 1\n....:     else:\n....:         d[x] = 1\nsage: d.values()\n[3363, 1637]\nsage: len(OMP)\n5\n```\nIn fact, the latter one for `OrderedMultisetPartitionsIntoSets_X` is cause for concern because it does even generate every element. The one for `OrderedMultisetPartitionIntoSets_n` is uniform, except it does not cover all elements:\n\n```\nsage: OMP = OrderedMultisetPartitionsIntoSets(5)\nsage: d = {}\nsage: for _ in range(5000):\n....:     x = OMP.random_element()\n....:     if x in d:\n....:         d[x] += 1\n....:     else:\n....:         d[x] = 1\nsage: d.values()\n[312, 324, 302, 308, 340, 332, 316, 338,\n 267, 320, 297, 315, 294, 283, 321, 331]\nsage: len(d)\n16\nsage: len(OMP)\n25\n```\n\n`to/from_tableau` is a bad name. To begin with, if anything it should be plural `to/from_tableaux`. Second, each individual part of the list of `to_tableau` is not formatted as a tableau (I am guessing we are suppose to consider it as a reading word). Again, it also does not output any of Sage's tableau objects. Without saying more information about the output in the method documentation, it is not so useful to work with for the uninitiated. Also, considering it is in a crystal, it is probably better to give the map a name different from `\\varphi`.",
    "created_at": "2018-09-09T01:02:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350055",
    "user": "https://github.com/tscrim"
}
```

There is still work to be done. Some of my bigger changes:

- Anything passed into an `Element` should have a `parent` as the first argument. I have made it a hard error if that does not happen.
- No need to have an `OrderedMultisetPartitionsIntoSets_all_constraints.__init__` as it is the same as for the base class.
- The `TestSuite(X).run()` checks `loads(dumps(X)) == X`, so I removed these tests.

Some comments:

The parent names with `X` and `A` are not descriptive enough IMO. Also, some of your classes have the input parameters in their names, but not all, e.g., `OrderedMultisetPartitionsIntoSets_A` does not also include the fixed order `d`. I think the `X` is fine, but I would replace `A` with `alphabet`.

The doc for `OrderedMultisetPartitionsIntoSets` will still need some improvements. I don't like the overall formatting with bullet points for the examples. I think paragraph breaks are sufficient, but if you want something more, I would go with `.. RUBRIC::`. (Also, try to keep the prose under 80 chars/line.)

Your `OrderedMultisetPartitionsIntoSets.__classcall_private__` is somewhat of a mess. For instance, if you passed in things as only keyword input, you would get the generic class, which is a bug:

```
sage: OMP = OrderedMultisetPartitionsIntoSets(alphabet=['A','B'], order=2)
sage: list(OMP)
[[{'A','B'}], [{'A'}, {'A'}], [{'A'}, {'B'}], [{'B'}, {'A'}], [{'B'}, {'B'}]]
sage: OMP
Ordered Multiset Partitions with constraints: alphabet={'A', 'B'}, order=2
sage: type(OMP)
<class 'sage.combinat.multiset_partition_ordered.OrderedMultisetPartitionsIntoSets_all_constraints_with_category'>
sage: OrderedMultisetPartitionsIntoSets(['A','B'], 2)
Ordered Multiset Partitions of order 2 over alphabet {A, B}
```
Additionally I generally believe errors should be raised when inputs are incompatible rather than silently ignoring them. I understand this may not be possible for usable code, but it is something to strive for.

```
sage: OMP = OrderedMultisetPartitionsIntoSets(weight=[1,2],alphabet=['a','b'],order=2); OMP
Ordered Multiset Partitions with constraint: weight={1: 1, 2: 2}
sage: type(OMP)
<class 'sage.combinat.multiset_partition_ordered.OrderedMultisetPartitionsIntoSets_all_constraints_with_category'>
sage: list(OMP)
[[{1}, {2}, {2}], [{1,2}, {2}], [{2}, {1}, {2}], [{2}, {1,2}], [{2}, {2}, {1}]]
```

Something to note: the `random_element` is not uniform:

```
sage: OMP = OrderedMultisetPartitionsIntoSets([1,4], 3)
sage: d = {}
sage: for _ in range(6000):
....:     x = OMP.random_element()
....:     if x in d:
....:         d[x] += 1
....:     else:
....:         d[x] = 1
sage: d.values()
[238, 251, 1040, 287, 273, 250, 1005, 991, 213, 243, 249, 960]
```

```
sage: OMP = OrderedMultisetPartitionsIntoSets([1,1,3])
sage: d = {}
sage: for _ in range(5000):
....:     x = OMP.random_element()
....:     if x in d:
....:         d[x] += 1
....:     else:
....:         d[x] = 1
sage: d.values()
[3363, 1637]
sage: len(OMP)
5
```
In fact, the latter one for `OrderedMultisetPartitionsIntoSets_X` is cause for concern because it does even generate every element. The one for `OrderedMultisetPartitionIntoSets_n` is uniform, except it does not cover all elements:

```
sage: OMP = OrderedMultisetPartitionsIntoSets(5)
sage: d = {}
sage: for _ in range(5000):
....:     x = OMP.random_element()
....:     if x in d:
....:         d[x] += 1
....:     else:
....:         d[x] = 1
sage: d.values()
[312, 324, 302, 308, 340, 332, 316, 338,
 267, 320, 297, 315, 294, 283, 321, 331]
sage: len(d)
16
sage: len(OMP)
25
```

`to/from_tableau` is a bad name. To begin with, if anything it should be plural `to/from_tableaux`. Second, each individual part of the list of `to_tableau` is not formatted as a tableau (I am guessing we are suppose to consider it as a reading word). Again, it also does not output any of Sage's tableau objects. Without saying more information about the output in the method documentation, it is not so useful to work with for the uninitiated. Also, considering it is in a crystal, it is probably better to give the map a name different from `\varphi`.



---

archive/issue_comments_350056.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-09-09T01:02:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350056",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_350057.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-11T18:30:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350057",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350058.json:
```json
{
    "body": "Travis,\n\nThank you for the detailed comments (and for the commit preceding it; my apologies for the mess I left you).\n I addressed all of them in the latest commit, except the first one and last one:\n\n* I'm not sold on the idea of replacing `_A` with `_alphabet` as things start to get a little long. I modeled the names off of `set_partition_ordered.py`, but I'm happy to come up with something different if you keep pushing.\n\n* I didn't touch `\\varphi`... I leave this one for Anne to weigh-in on.",
    "created_at": "2018-09-11T18:36:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350058",
    "user": "https://github.com/alauve"
}
```

Travis,

Thank you for the detailed comments (and for the commit preceding it; my apologies for the mess I left you).
 I addressed all of them in the latest commit, except the first one and last one:

* I'm not sold on the idea of replacing `_A` with `_alphabet` as things start to get a little long. I modeled the names off of `set_partition_ordered.py`, but I'm happy to come up with something different if you keep pushing.

* I didn't touch `\varphi`... I leave this one for Anne to weigh-in on.



---

archive/issue_comments_350059.json:
```json
{
    "body": "Replying to [comment:158 alauve]:\n> * I didn't touch `\\varphi`... I leave this one for Anne to weigh-in on.\n\n\nI think we called the map \\varphi in the paper. But if you want to call it something else, that is fine with me!",
    "created_at": "2018-09-12T06:12:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350059",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:158 alauve]:
> * I didn't touch `\varphi`... I leave this one for Anne to weigh-in on.


I think we called the map \varphi in the paper. But if you want to call it something else, that is fine with me!



---

archive/issue_comments_350060.json:
```json
{
    "body": "Replying to [comment:158 alauve]:\n> * I'm not sold on the idea of replacing `_A` with `_alphabet` as things start to get a little long. I modeled the names off of `set_partition_ordered.py`, but I'm happy to come up with something different if you keep pushing.\n\n\nThe length of the class name is irrelevant as the user will never work with it. It really doesn't take that long anyways to do 4ish extra keystrokes. The big reason I would want this to change is that it gets confusing with the `X` as well. Perhaps an abbreviation such as `_alph`?\n\n> * I didn't touch `\\varphi`... I leave this one for Anne to weigh-in on.\n\n\nI would call it `\\phi` or `\\psi`. The big difference between Sage and the paper is this is less standalone. So IMO it is better to try and avoid conflicts with standard notion. However, I do not care that strongly about this.\n\nI think it is fine that `random_element` does not return things with uniform probability as long as it is documented. I don't like calling it `_fast` nevertheless.",
    "created_at": "2018-09-16T02:06:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350060",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:158 alauve]:
> * I'm not sold on the idea of replacing `_A` with `_alphabet` as things start to get a little long. I modeled the names off of `set_partition_ordered.py`, but I'm happy to come up with something different if you keep pushing.


The length of the class name is irrelevant as the user will never work with it. It really doesn't take that long anyways to do 4ish extra keystrokes. The big reason I would want this to change is that it gets confusing with the `X` as well. Perhaps an abbreviation such as `_alph`?

> * I didn't touch `\varphi`... I leave this one for Anne to weigh-in on.


I would call it `\phi` or `\psi`. The big difference between Sage and the paper is this is less standalone. So IMO it is better to try and avoid conflicts with standard notion. However, I do not care that strongly about this.

I think it is fine that `random_element` does not return things with uniform probability as long as it is documented. I don't like calling it `_fast` nevertheless.



---

archive/issue_comments_350061.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-17T21:10:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350061",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350062.json:
```json
{
    "body": "Finished making Travis's suggestions.\nI decided to edit the doc strings in accordance with the \"into sets\" discussion, and to rename the module.\n\nI hope I tracked down all the places where this name should have been changed...\n* `src/doc/en/reference/combinat/module_list.rst`\n* `src/sage/combinat/all.py`\n* `src/sage/combinat/crystals/catalog.py`\n* `src/sage/combinat/enumerated_sets.py`",
    "created_at": "2018-09-17T21:15:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350062",
    "user": "https://github.com/alauve"
}
```

Finished making Travis's suggestions.
I decided to edit the doc strings in accordance with the "into sets" discussion, and to rename the module.

I hope I tracked down all the places where this name should have been changed...
* `src/doc/en/reference/combinat/module_list.rst`
* `src/sage/combinat/all.py`
* `src/sage/combinat/crystals/catalog.py`
* `src/sage/combinat/enumerated_sets.py`



---

archive/issue_comments_350063.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-09-20T15:18:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350063",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_350064.json:
```json
{
    "body": "Looks good to me. Travis?",
    "created_at": "2018-09-21T00:35:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350064",
    "user": "https://github.com/anneschilling"
}
```

Looks good to me. Travis?



---

archive/issue_comments_350065.json:
```json
{
    "body": "Yep, LGTM modulo my small doc changes (please check). Thank you for all your hard work.",
    "created_at": "2018-09-21T02:01:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350065",
    "user": "https://github.com/tscrim"
}
```

Yep, LGTM modulo my small doc changes (please check). Thank you for all your hard work.



---

archive/issue_comments_350066.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-21T02:02:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350066",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350067.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-21T03:15:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350067",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_350068.json:
```json
{
    "body": "Nice changes, Travis. If I understand your last comment correctly, I can safely set it to positive review.",
    "created_at": "2018-09-21T03:17:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350068",
    "user": "https://github.com/alauve"
}
```

Nice changes, Travis. If I understand your last comment correctly, I can safely set it to positive review.



---

archive/issue_comments_350069.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-09-21T03:17:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350069",
    "user": "https://github.com/alauve"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_350070.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-09-22T10:22:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350070",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_063108.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-09-22T10:22:41Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/24911#event-63108"
}
```



---

archive/issue_comments_350071.json:
```json
{
    "body": "This ticket introduced a lot of `sorted()` calls. You should be aware that it is not safe to assume that any set can be sorted, especially after #22029 and in Python 3.\n\nSee #27003 for one particular fix.",
    "created_at": "2019-01-02T20:34:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24911",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24911#issuecomment-350071",
    "user": "https://github.com/jdemeyer"
}
```

This ticket introduced a lot of `sorted()` calls. You should be aware that it is not safe to assume that any set can be sorted, especially after #22029 and in Python 3.

See #27003 for one particular fix.
