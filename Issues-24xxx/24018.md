# Issue 24018: Warn with substitution of derived classes using equality

archive/issues_024018.json:
```json
{
    "body": "There is a long-standing problem with substitution in that some substitutions do not work when given as equality but do work when given as dictionary.\n\n```\nsage: (x*pi).subs(x*pi==e)\nx*pi\nsage: (x*pi).subs({x*pi:e})\ne\n\nsage: s = x.series(x,2); s\n1*x + Order(x^2)\nsage: (x*pi).subs(x*pi==s)\npi*x\n```\n\nIt looks like that in some cases the conversion to dict switches lhs and rhs of the equation and this is because of such behaviour:\n\n```\nsage: x*pi==e\ne == pi*x\nsage: x == s\n1*x + Order(x^2) == x\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/24255\n\n",
    "created_at": "2017-11-21T06:21:47Z",
    "labels": [
        "component: symbolics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.2",
    "title": "Warn with substitution of derived classes using equality",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/24018",
    "user": "https://github.com/rwst"
}
```
There is a long-standing problem with substitution in that some substitutions do not work when given as equality but do work when given as dictionary.

```
sage: (x*pi).subs(x*pi==e)
x*pi
sage: (x*pi).subs({x*pi:e})
e

sage: s = x.series(x,2); s
1*x + Order(x^2)
sage: (x*pi).subs(x*pi==s)
pi*x
```

It looks like that in some cases the conversion to dict switches lhs and rhs of the equation and this is because of such behaviour:

```
sage: x*pi==e
e == pi*x
sage: x == s
1*x + Order(x^2) == x
```


Issue created by migration from https://trac.sagemath.org/ticket/24255





---

archive/issue_comments_336246.json:
```json
{
    "body": "```\nclass A(SageObject):\n    def __init__(self):\n        from sage.symbolic.ring import SR\n        self._parent = SR\n    def __eq__(a, b):\n        print(a, b)\n        return True\n    def __repr__(self):\n        return \"A\"\n\nclass B(A):\n    def __eq__(a, b):\n        print(a, b)\n        return True\n    def __repr__(self):\n        return \"B\"\n\nsage: from sage.symbolic.tests import A,B\nsage: A() == B()\n(B, A)\nTrue\n\nversus\n\nclass A():\n    def __init__(self):\n        from sage.symbolic.ring import SR\n        self._parent = SR\n    def __eq__(a, b):\n        print(a, b)\n        return True\n    def __repr__(self):\n        return \"A\"\n\nclass B(A):\n    def __eq__(a, b):\n        print(a, b)\n        return True\n    def __repr__(self):\n        return \"B\"\n\nsage: from sage.symbolic.tests import A,B\nsage: A() == B()\n(A, B)\nTrue\n```\nThe first has `A` inherit from `SageObject` the second not.",
    "created_at": "2017-11-23T09:02:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24018#issuecomment-336246",
    "user": "https://github.com/rwst"
}
```

```
class A(SageObject):
    def __init__(self):
        from sage.symbolic.ring import SR
        self._parent = SR
    def __eq__(a, b):
        print(a, b)
        return True
    def __repr__(self):
        return "A"

class B(A):
    def __eq__(a, b):
        print(a, b)
        return True
    def __repr__(self):
        return "B"

sage: from sage.symbolic.tests import A,B
sage: A() == B()
(B, A)
True

versus

class A():
    def __init__(self):
        from sage.symbolic.ring import SR
        self._parent = SR
    def __eq__(a, b):
        print(a, b)
        return True
    def __repr__(self):
        return "A"

class B(A):
    def __eq__(a, b):
        print(a, b)
        return True
    def __repr__(self):
        return "B"

sage: from sage.symbolic.tests import A,B
sage: A() == B()
(A, B)
True
```
The first has `A` inherit from `SageObject` the second not.



---

archive/issue_comments_336247.json:
```json
{
    "body": "Since we cannot use the ``@`richcmp` decorator on a `cdef` class we cannot work around it but must investigate the reason for the argument switching, which is possibly in Cython.",
    "created_at": "2017-11-23T09:57:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24018#issuecomment-336247",
    "user": "https://github.com/rwst"
}
```

Since we cannot use the ``@`richcmp` decorator on a `cdef` class we cannot work around it but must investigate the reason for the argument switching, which is possibly in Cython.



---

archive/issue_comments_336248.json:
```json
{
    "body": "Adding `__eq__` does not work I get a Cython compile error reported at https://github.com/cython/cython/issues/2019",
    "created_at": "2017-11-23T16:11:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24018#issuecomment-336248",
    "user": "https://github.com/rwst"
}
```

Adding `__eq__` does not work I get a Cython compile error reported at https://github.com/cython/cython/issues/2019



---

archive/issue_comments_336249.json:
```json
{
    "body": "Replying to [comment:7 rws]:\n> {{{\n> class A(SageObject):\n>     def __init__(self):\n>         from sage.symbolic.ring import SR\n>         self._parent = SR\n>     def __eq__(a, b):\n>         print(a, b)\n>         return True\n>     def __repr__(self):\n>         return \"A\"\n> \n> class B(A):\n>     def __eq__(a, b):\n>         print(a, b)\n>         return True\n>     def __repr__(self):\n>         return \"B\"\n> \n> sage: from sage.symbolic.tests import A,B\n> sage: A() == B()\n> (B, A)\n> True\n> \n> versus\n> \n> class A():\n>     def __init__(self):\n>         from sage.symbolic.ring import SR\n>         self._parent = SR\n>     def __eq__(a, b):\n>         print(a, b)\n>         return True\n>     def __repr__(self):\n>         return \"A\"\n> \n> class B(A):\n>     def __eq__(a, b):\n>         print(a, b)\n>         return True\n>     def __repr__(self):\n>         return \"B\"\n> \n> sage: from sage.symbolic.tests import A,B\n> sage: A() == B()\n> (A, B)\n> True\n> }}}\n\n\nI think this is just a difference between new-style and old-style classes. This has nothing to do with Cython.",
    "created_at": "2017-11-25T09:23:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24018#issuecomment-336249",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:7 rws]:
> {{{
> class A(SageObject):
>     def __init__(self):
>         from sage.symbolic.ring import SR
>         self._parent = SR
>     def __eq__(a, b):
>         print(a, b)
>         return True
>     def __repr__(self):
>         return "A"
> 
> class B(A):
>     def __eq__(a, b):
>         print(a, b)
>         return True
>     def __repr__(self):
>         return "B"
> 
> sage: from sage.symbolic.tests import A,B
> sage: A() == B()
> (B, A)
> True
> 
> versus
> 
> class A():
>     def __init__(self):
>         from sage.symbolic.ring import SR
>         self._parent = SR
>     def __eq__(a, b):
>         print(a, b)
>         return True
>     def __repr__(self):
>         return "A"
> 
> class B(A):
>     def __eq__(a, b):
>         print(a, b)
>         return True
>     def __repr__(self):
>         return "B"
> 
> sage: from sage.symbolic.tests import A,B
> sage: A() == B()
> (A, B)
> True
> }}}


I think this is just a difference between new-style and old-style classes. This has nothing to do with Cython.



---

archive/issue_comments_336250.json:
```json
{
    "body": "Without any Cython classes involved:\n\n```\nsage: class A(object):\n....:     def __eq__(a, b):\n....:         print(a, b)\n....:         return True\n....:     def __repr__(self):\n....:         return \"A\"\n....: \n....: class B(A):\n....:     def __eq__(a, b):\n....:         print(a, b)\n....:         return True\n....:     def __repr__(self):\n....:         return \"B\"\nsage: A() == B()\n(B, A)\nTrue\n```",
    "created_at": "2017-11-25T09:25:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24018#issuecomment-336250",
    "user": "https://github.com/jdemeyer"
}
```

Without any Cython classes involved:

```
sage: class A(object):
....:     def __eq__(a, b):
....:         print(a, b)
....:         return True
....:     def __repr__(self):
....:         return "A"
....: 
....: class B(A):
....:     def __eq__(a, b):
....:         print(a, b)
....:         return True
....:     def __repr__(self):
....:         return "B"
sage: A() == B()
(B, A)
True
```



---

archive/issue_comments_336251.json:
```json
{
    "body": "Why then would `class A():` not switch arguments? Anyway, this ticket either should warn if subclasses are encountered or at least add explanations to the documentation.",
    "created_at": "2017-11-25T13:45:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24018#issuecomment-336251",
    "user": "https://github.com/rwst"
}
```

Why then would `class A():` not switch arguments? Anyway, this ticket either should warn if subclasses are encountered or at least add explanations to the documentation.



---

archive/issue_comments_336252.json:
```json
{
    "body": "Replying to [comment:13 rws]:\n> Why then would `class A():` not switch arguments? Anyway, this ticket either should warn if subclasses are encountered or at least add explanations to the documentation.\n\n\nOkay the answer is https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python and Python is a PITA.",
    "created_at": "2017-11-25T13:51:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24018",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24018#issuecomment-336252",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:13 rws]:
> Why then would `class A():` not switch arguments? Anyway, this ticket either should warn if subclasses are encountered or at least add explanations to the documentation.


Okay the answer is https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python and Python is a PITA.
