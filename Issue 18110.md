# Issue 18110: implement the shard intersection order on permutations

Issue created by migration from Trac.

Original creator: chapoton

Original creation time: 2015-05-01 12:47:56

CC:  darij tscrim hthomas

This is a poset (and even a lattice) introduced by N. Reading in 2011.

It has nice properties, similar to that of noncrossing partitions.

Let's have it in sage.


---

Comment by chapoton created at 2015-05-01 12:50:36

Changing status from new to needs_review.


---

Comment by chapoton created at 2015-05-01 12:50:36

Changing keywords from "" to "poset".


---

Comment by chapoton created at 2015-05-01 12:50:36

New commits:


---

Comment by darij created at 2015-05-01 13:28:22

You might have forgotten to git-add the main file?


---

Comment by git created at 2015-05-01 13:54:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-05-01 13:55:35

oops, indeed, I was a bit too quick

Do you think that descending_runs should be integrated into runs ?


---

Comment by darij created at 2015-05-01 13:57:55

I don't know -- this seems to be a matter of taste.


---

Comment by vdelecroix created at 2015-05-01 20:34:32

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-05-01 20:34:32

Hello,

1. In `decreasing_runs` why are you creating a list to return a tuple? You would better use

```
return tuple(tuple([n + 1 - i for i in r]) for r in s_bar.runs())
```


2. What is the point of the `cached_function` on `shard_preorder_graph`? As far as I understand the information is only temporarily used to construct the poset. The poset constructor basically makes comparison between all pairs. So you are storing information that will never be used beyond constructing the poset.

- proposition 1: implement better the data to initialize the poset from
- (ugly) proposition 2: clear the cache when you are done

```
Sn = [s.decreasing_runs() for s in Permutations(n)]
P = Poset([Sn, shard_compares], cover_relations=False)
shard_preorder_graph.clear_cache()
return P
```


3. This 

```
dico1 = {}
# conversion: integer -> index of run in r1
for i, bloc in enumerate(r1):
    for j in bloc:
        dico1[j] = i
```

  can be

```
dico1 = {j:i for i,bloc in enumerate(r1) for j in bloc}
```


Vincent


---

Comment by git created at 2015-05-02 12:26:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-05-02 12:30:38

Thanks for the comments. I have corrected the two minor ones.

About the caching: indeed, this is used only in the poset, but used many times.

It is not clear to me how to avoid that. One could precompute in the poset method all
these digraphs, and keep them in a list or a dictionary, and make the `shard_compares` method an internal one. I am not convinced that this would make things more clear.


---

Comment by vdelecroix created at 2015-05-02 13:11:51

Replying to [comment:8 chapoton]:
> Thanks for the comments. I have corrected the two minor ones.
> 
> About the caching: indeed, this is used only in the poset, but used many times.

It is currently not used *in* the poset, only during its construction! Just have a look at the ugly poset code. It is not lazy at all.
 
4. `runs` and `decreasing_runs` should return the same data. It is currently list for one of them and tuple for the other.

5. Why did you wrote the following comment in `shard_compares`?

```
# We assume that r1 has less runs than r0
```


6. The function `shard_preorder_graph` only depends on the interval not on the runs themselves. So you are storing too much in the cache of this function. Make the input a tuple of pairs

```
sage: s = Permutation([2,8,3,9,6,4,5,1,7])
sage: runs = s.decreasing_runs()
sage: shard_preorder_graph(runs) == \
....:    shard_preorder_graph(tuple((r[0],r[-1]) for r in runs))
True
```

  And you should really think moving it somewhere else as this has nothing to do with permutations. This is just a comparability graph given by the inclusion order on intervals. Isn't it?

Vincent


---

Comment by vdelecroix created at 2015-05-02 13:22:18

Replying to [comment:9 vdelecroix]:
> Replying to [comment:8 chapoton]:
>   And you should really think moving it somewhere else as this has nothing to do with permutations. This is just a comparability graph given by the inclusion order on intervals. Isn't it?

This is not quite true, sorry. You are building a comparability graph that also does depend on the order of the input. Not only on the intervals themselves...

Vincent


---

Comment by git created at 2015-05-02 15:25:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-05-02 15:30:20

Hello,

yes, this is a rather subtle order, I think. It is indeed closely related to noncrossing
partitions and to the weak order, but not in obvious ways. For example, the Mobius number is the number of connected partitions.

Concerning 4: I have added an option to specify the output of decreasing runs. Should I do the same for runs ?

Concerning 5: I have added this as a simple necessary condition

concerning 6: I have made `shard_preorder_graph` input a tuple of pairs


---

Comment by vdelecroix created at 2015-05-02 17:26:41

Why not making it a poset on permutations?

Replying to [comment:12 chapoton]:
> Hello,
> 
> yes, this is a rather subtle order, I think. It is indeed closely related to noncrossing
> partitions and to the weak order, but not in obvious ways. For example, the Mobius number is the number of connected partitions.
> 
> Concerning 4: I have added an option to specify the output of decreasing runs. Should I do the same for runs ?

I think so.

> Concerning 5: I have added this as a simple necessary condition
> 
> concerning 6: I have made `shard_preorder_graph` input a tuple of pairs

Nice.


I uploaded a branch at `public/18347` in which instead of storing every graph in an external function I created a new class for `ShardPosetElement`. It does some precomputation. It is much cleaner. It is just a toy implementation to let you see. Your previous `shard_compares` is now `ShardPosetElement.__le__`.

Beyond these technicalities:
 - you must put more definitions (about the order, etc)
 - you should put more relevant doctest! 

```
        sage: P = posets.ShardPoset(4); P
        Finite poset containing 24 elements
        sage: len(P.maximal_chains())
        34
        sage: P.is_selfdual()
        False
```

  is clearly not enough!

Vincent


---

Comment by git created at 2015-05-06 14:22:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-05-07 08:02:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-05-11 12:20:37

I have added some explanations. Enough ?


---

Comment by chapoton created at 2015-05-11 12:20:37

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-05-11 16:27:35

Hello,

What does `connected_parts` is doing in the git branch?

You should work harder on `ShardPosetElement`:

1. it would be better if it inherits from `tuple` (i.e. remove the `p` attribute and add `tuple.__init__(self, p)` in the constructor). Then remove the `__hash__` and the `__repr__` (they are already fine in `tuple`)

2. Implement the various operators `__le__`, `__lt__`, `__gt__`, `__ge__` and check that it is coherent (this should be ok for `__eq__` and `__ne__` inherited from `tuple`)

3. Moreover, in `__le__` you can not assume that `self` and `other` are of the same type. You should start the method with something like:

```
if type(self) is not type(other) or len(self) != len(other):
    raise TypeError("these are not comparable")
```


4. Do you want to keep all attributes of `ShardPosetElement` public as they are?

Vincent


---

Comment by vdelecroix created at 2015-05-11 16:27:35

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-05-11 17:05:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-05-11 17:25:39

Hello

> What does `connected_parts` is doing in the git branch?

Well, I removed it. Could go in another ticket maybe.
 
> 1. it would be better if it inherits from `tuple` (i.e. remove the `p` attribute and add `tuple.__init__(self, p)` in the constructor). Then remove the `__hash__` and the `__repr__` (they are already fine in `tuple`)

Done

> 2. Implement the various operators `__le__`, `__lt__`, `__gt__`, `__ge__` and check that it is coherent (this should be ok for `__eq__` and `__ne__` inherited from `tuple`)

Is this really necessary ? This class is just there to help build the poset, there is no way
it will be ever used for something else, I think.

> 3. Moreover, in `__le__` you can not assume that `self` and `other` are of the same type. You should start the method with something like:
> {{{
> if type(self) is not type(other) or len(self) != len(other):
>     raise TypeError("these are not comparable")
> }}}

Done
 
> 4. Do you want to keep all attributes of `ShardPosetElement` public as they are?

Once again, this class will probably not be very much used. So I do not see the point to hide things.

My motivation for this ticket was to have the poset, which is the main interesting thing here.

Thanks for your comments, by the way.

Frederic


---

Comment by vdelecroix created at 2015-05-11 17:47:51

Hi,

Replying to [comment:19 chapoton]:

I mostly agree with you for 2. and 4. But if you do not care about the elements, then the poset should be abstract on integers: i.e. just store a matrix of relations and send it to `Poset`. You do not want to know which permutation corresponds to which point in this poset?

Vincent


---

Comment by chapoton created at 2015-05-15 12:50:04

Well. I did implement this just to compute the number of maximal chains and the mobius
numbers. So only the "abstract" poset was needed. But of course, this is more useful to other people if the vertices of the poset are more or less labelled by permutations.

I do not think nevertheless that it is necessary to have the elements be permutations.

So I am happy with the current state of things..


---

Comment by vdelecroix created at 2015-05-15 12:56:38

Replying to [comment:21 chapoton]:
> Well. I did implement this just to compute the number of maximal chains and the mobius
> numbers. So only the "abstract" poset was needed. But of course, this is more useful to other people if the vertices of the poset are more or less labelled by permutations.
> 
> I do not think nevertheless that it is necessary to have the elements be permutations.
> 
> So I am happy with the current state of things..

I see. Could you mention somewhere (probably in the docstring of `ShardPosetElement` and `ShardPoset`) that the elements are *not* permutation (for computational reasons). But hopefully they are easily recovered:

```
sage: P = posets.ShardPoset(4)
sage: mins = P.minimal_elements()[0]
sage: p = Permutation(mins)
[2, 3, 4, 1]
sage: p.decreasing_runs()
[[2], [3], [4, 1]]
```

(or a more relevant example)

Vincent


---

Comment by git created at 2015-05-15 19:44:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-05-15 19:45:53

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2015-05-15 19:45:53

ok, back to needs review. I have added some doc about back and forth conversion to permutations.


---

Comment by vdelecroix created at 2015-05-15 19:53:15

Why did you put the `INPUT` block one kilometer away in `Permutation.runs`?!


---

Comment by git created at 2015-05-15 20:02:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-05-22 20:15:01

ping ?


---

Comment by vdelecroix created at 2015-05-23 13:32:34

pong!


---

Comment by vdelecroix created at 2015-05-23 13:32:34

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-05-23 22:59:55

Resolution: fixed


---

Comment by novoselt created at 2016-05-24 02:16:47

Why was a new class derived from `tuple` rather then something inheriting from `SageObject`??? It now triggers a warning included in doctest by #20667


---

Comment by vdelecroix created at 2016-05-24 03:16:50

Inheriting from tuple is forbidden?

More interesting: what is the warning that was not here before?


---

Comment by novoselt created at 2016-05-24 03:21:45

Nothing is forbidden, but
http://doc.sagemath.org/html/en/developer/coding_in_python.html?highlight=sageobject
and the result is
http://git.sagemath.org/sage.git/diff/src/sage/combinat/shard_order.py?id=ed746286af38545c69edfc77c3a9f1cfde4665fd&id2=d5646a4e1a2c6f0575ca90b02085417b676e34dd


---

Comment by vdelecroix created at 2016-05-24 03:29:37

The problem is that this error will not be solved by inheriting from `SageObject` since we need to initialize the content of the tuple... The inheritance from `tuple` is here for speed (the methods use `__hash__` and `__eq__`).

Does the same warning show up with the following?

```
sage: class A(tuple):
....:    def __init__(self, a):
....:        tuple.__init__(a)
sage: a = A([1,2,3])
```

It works without any warning in IPython console...
