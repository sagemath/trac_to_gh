# Issue 15336: (co)product coercion

archive/issues_015336.json:
```json
{
    "body": "CC:  kdilks\n\nIn a bialgebra, that is not obvious there exists *a_realization*\nsuch that implements (easily) the product and the coproduct.\n\nSo I propose a coercion method that try to find automatically\na realization which has the implementation of the (co)product.\n\nCheers,\n\nJean-Baptiste Priez\n\nIssue created by migration from https://trac.sagemath.org/ticket/15573\n\n",
    "created_at": "2013-12-23T14:18:16Z",
    "labels": [
        "categories",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "(co)product coercion",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15336",
    "user": "elixyre"
}
```
CC:  kdilks

In a bialgebra, that is not obvious there exists *a_realization*
such that implements (easily) the product and the coproduct.

So I propose a coercion method that try to find automatically
a realization which has the implementation of the (co)product.

Cheers,

Jean-Baptiste Priez

Issue created by migration from https://trac.sagemath.org/ticket/15573





---

archive/issue_comments_197440.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-12-23T21:06:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197440",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_197441.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-12-23T21:07:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197441",
    "user": "elixyre"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_197442.json:
```json
{
    "body": "I think whatever is returned by `a_realization()` should have a (co)product/antipode/etc. methods implemented. If not, the code should call the \"best\" realization to do the computations in by overwriting the respective `*_by_coercion()` in either the realization category or in the parent directly (sometimes [often] the change-of-basis is nontrivial as well). Although this requirement that `a_realization()` has a concrete implementation of the operation methods (or it's elements) is not stated and it should be.\n\nHowever, `+1` that there should be a `*_by_coercion()` in the most general (realization) category that defines that operation. IMO the `coproduct_by_coercion()` method in this ticket should go in `Coalgebras`, in which `coproduct()` will need some tweaks since it seems to be assuming a basis. Similarly `product_by_coercion()` is inherited from the `Magmas` category and is redundant.\n\nBest,\n\nTravis",
    "created_at": "2013-12-24T23:44:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197442",
    "user": "tscrim"
}
```

I think whatever is returned by `a_realization()` should have a (co)product/antipode/etc. methods implemented. If not, the code should call the "best" realization to do the computations in by overwriting the respective `*_by_coercion()` in either the realization category or in the parent directly (sometimes [often] the change-of-basis is nontrivial as well). Although this requirement that `a_realization()` has a concrete implementation of the operation methods (or it's elements) is not stated and it should be.

However, `+1` that there should be a `*_by_coercion()` in the most general (realization) category that defines that operation. IMO the `coproduct_by_coercion()` method in this ticket should go in `Coalgebras`, in which `coproduct()` will need some tweaks since it seems to be assuming a basis. Similarly `product_by_coercion()` is inherited from the `Magmas` category and is redundant.

Best,

Travis



---

archive/issue_comments_197443.json:
```json
{
    "body": "I experimented a bit with running a patchbot; it chose this ticket and discovered a doctest failure in `hopf_algebras.py` due to an undefined name `left`.  Independently, Travis's comment:4 also seems to mean this needs work.",
    "created_at": "2014-05-06T17:28:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197443",
    "user": "pbruin"
}
```

I experimented a bit with running a patchbot; it chose this ticket and discovered a doctest failure in `hopf_algebras.py` due to an undefined name `left`.  Independently, Travis's comment:4 also seems to mean this needs work.



---

archive/issue_comments_197444.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-05-06T17:28:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197444",
    "user": "pbruin"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_197445.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-07-12T01:21:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197445",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_197446.json:
```json
{
    "body": "> I think whatever is returned by `a_realization()` should have a (co)product/antipode/etc. methods implemented.\n\nThat point is obvious if we considere algebras or coalgebras... any structure with an unique operations. But with bialgebras, moreover with Hopf algebra, one has several operations and one is may be easier to define in some basis and one other in an other one.\n\nReplying to [comment:4 tscrim]:\n> If not, the code should call the \"best\" realization to do the computations in by overwriting the respective `*_by_coercion()` in either the realization category or in the parent directly (sometimes [often] the change-of-basis is nontrivial as well). \n\nThat point seems could be correct if we want define code for sage developpers! My opinion is this code should be code for users! That means: I want do my research without say... to compute in a basis of my new Hopf algebra, I don't want spend my time to tell to sage... I  don't have define a specific realization (`a_realization`) for my operations but if I want the product go to find this basis and the coproduct this one... No! I have implement product/coproduct whatever somewhere so do it!\n\nThen if some code add in sage seems to be slow because of that! This code should specify go to this basis.\n\nReplying to [comment:4 tscrim]:\n> However, `+1` that there should be a `*_by_coercion()` in the most general (realization) category that defines that operation. IMO the `coproduct_by_coercion()` method in this ticket should go in `Coalgebras`, in which `coproduct()` will need some tweaks since it seems to be assuming a basis. Similarly `product_by_coercion()` is inherited from the `Magmas` category and is redundant.\n\nThis code don't have to be in coalgebras or magmas because, for these structures we obviously could define one realization with the unique operation of the structure.\n\nReplying to [comment:7 pbruin]:\n> I experimented a bit with running a patchbot; it chose this ticket and discovered a doctest failure in `hopf_algebras.py` due to an undefined name `left`.  \n\nThat is fix\n\nReplying to [comment:7 pbruin]:\nIndependently, Travis's comment:4 also seems to mean this needs work.\n\nI hope I have answered to that part.\n\nCheers, \nJean-Baptiste",
    "created_at": "2014-07-12T01:40:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197446",
    "user": "elixyre"
}
```

> I think whatever is returned by `a_realization()` should have a (co)product/antipode/etc. methods implemented.

That point is obvious if we considere algebras or coalgebras... any structure with an unique operations. But with bialgebras, moreover with Hopf algebra, one has several operations and one is may be easier to define in some basis and one other in an other one.

Replying to [comment:4 tscrim]:
> If not, the code should call the "best" realization to do the computations in by overwriting the respective `*_by_coercion()` in either the realization category or in the parent directly (sometimes [often] the change-of-basis is nontrivial as well). 

That point seems could be correct if we want define code for sage developpers! My opinion is this code should be code for users! That means: I want do my research without say... to compute in a basis of my new Hopf algebra, I don't want spend my time to tell to sage... I  don't have define a specific realization (`a_realization`) for my operations but if I want the product go to find this basis and the coproduct this one... No! I have implement product/coproduct whatever somewhere so do it!

Then if some code add in sage seems to be slow because of that! This code should specify go to this basis.

Replying to [comment:4 tscrim]:
> However, `+1` that there should be a `*_by_coercion()` in the most general (realization) category that defines that operation. IMO the `coproduct_by_coercion()` method in this ticket should go in `Coalgebras`, in which `coproduct()` will need some tweaks since it seems to be assuming a basis. Similarly `product_by_coercion()` is inherited from the `Magmas` category and is redundant.

This code don't have to be in coalgebras or magmas because, for these structures we obviously could define one realization with the unique operation of the structure.

Replying to [comment:7 pbruin]:
> I experimented a bit with running a patchbot; it chose this ticket and discovered a doctest failure in `hopf_algebras.py` due to an undefined name `left`.  

That is fix

Replying to [comment:7 pbruin]:
Independently, Travis's comment:4 also seems to mean this needs work.

I hope I have answered to that part.

Cheers, 
Jean-Baptiste



---

archive/issue_comments_197447.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-07-12T01:40:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197447",
    "user": "elixyre"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_197448.json:
```json
{
    "body": "one failing doctest, see buildbot report",
    "created_at": "2014-09-07T19:52:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197448",
    "user": "chapoton"
}
```

one failing doctest, see buildbot report



---

archive/issue_comments_197449.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-09-07T19:52:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197449",
    "user": "chapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_197450.json:
```json
{
    "body": "Based on this comment in `hopf_algebra.py` inside antipode_by_coercion:\n\n\n\n```\n            # TODO:\n            # - Use @conditionally_defined once it's in Sage, for a nicer idiom\n            # - Do the right thing (TM): once we will have proper\n            #   overloaded operators (as in MuPAD-Combinat; see #8900),\n            #   we won't need to specify explicitly to which parent one\n            #   should coerce the input to calculate the antipode; so it\n            #   will be sufficient to put this default implementation in\n            #   HopfAlgebras.ParentMethods.\n```\n\n\nit sounds like what this ticket is attempting to achieve was originally the goal.\n\nI think this is something worth figuring out eventually, but for the sake of actually getting later features of CHA included in Sage, I'm fine with Travis's suggestion of making `a_realization` always return a product/coproduct/antipode method that's hard-coded to point to a realization where the method is actually defined, rather than having Sage automatically find a realization where the method is actually defined.",
    "created_at": "2015-06-12T16:22:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15336",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15336#issuecomment-197450",
    "user": "kdilks"
}
```

Based on this comment in `hopf_algebra.py` inside antipode_by_coercion:



```
            # TODO:
            # - Use @conditionally_defined once it's in Sage, for a nicer idiom
            # - Do the right thing (TM): once we will have proper
            #   overloaded operators (as in MuPAD-Combinat; see #8900),
            #   we won't need to specify explicitly to which parent one
            #   should coerce the input to calculate the antipode; so it
            #   will be sufficient to put this default implementation in
            #   HopfAlgebras.ParentMethods.
```


it sounds like what this ticket is attempting to achieve was originally the goal.

I think this is something worth figuring out eventually, but for the sake of actually getting later features of CHA included in Sage, I'm fine with Travis's suggestion of making `a_realization` always return a product/coproduct/antipode method that's hard-coded to point to a realization where the method is actually defined, rather than having Sage automatically find a realization where the method is actually defined.
