# Issue 15336: (co)product coercion

Issue created by migration from https://trac.sagemath.org/ticket/15573

Original creator: elixyre

Original creation time: 2013-12-23 14:18:16

CC:  kdilks

In a bialgebra, that is not obvious there exists *a_realization*
such that implements (easily) the product and the coproduct.

So I propose a coercion method that try to find automatically
a realization which has the implementation of the (co)product.

Cheers,

Jean-Baptiste Priez


---

Comment by git created at 2013-12-23 21:06:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by elixyre created at 2013-12-23 21:07:09

Changing status from new to needs_review.


---

Comment by tscrim created at 2013-12-24 23:44:40

I think whatever is returned by `a_realization()` should have a (co)product/antipode/etc. methods implemented. If not, the code should call the "best" realization to do the computations in by overwriting the respective `*_by_coercion()` in either the realization category or in the parent directly (sometimes [often] the change-of-basis is nontrivial as well). Although this requirement that `a_realization()` has a concrete implementation of the operation methods (or it's elements) is not stated and it should be.

However, `+1` that there should be a `*_by_coercion()` in the most general (realization) category that defines that operation. IMO the `coproduct_by_coercion()` method in this ticket should go in `Coalgebras`, in which `coproduct()` will need some tweaks since it seems to be assuming a basis. Similarly `product_by_coercion()` is inherited from the `Magmas` category and is redundant.

Best,

Travis


---

Comment by pbruin created at 2014-05-06 17:28:54

I experimented a bit with running a patchbot; it chose this ticket and discovered a doctest failure in `hopf_algebras.py` due to an undefined name `left`.  Independently, Travis's comment:4 also seems to mean this needs work.


---

Comment by pbruin created at 2014-05-06 17:28:54

Changing status from needs_review to needs_work.


---

Comment by git created at 2014-07-12 01:21:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by elixyre created at 2014-07-12 01:40:23

> I think whatever is returned by `a_realization()` should have a (co)product/antipode/etc. methods implemented.

That point is obvious if we considere algebras or coalgebras... any structure with an unique operations. But with bialgebras, moreover with Hopf algebra, one has several operations and one is may be easier to define in some basis and one other in an other one.

Replying to [comment:4 tscrim]:
> If not, the code should call the "best" realization to do the computations in by overwriting the respective `*_by_coercion()` in either the realization category or in the parent directly (sometimes [often] the change-of-basis is nontrivial as well). 

That point seems could be correct if we want define code for sage developpers! My opinion is this code should be code for users! That means: I want do my research without say... to compute in a basis of my new Hopf algebra, I don't want spend my time to tell to sage... I  don't have define a specific realization (`a_realization`) for my operations but if I want the product go to find this basis and the coproduct this one... No! I have implement product/coproduct whatever somewhere so do it!

Then if some code add in sage seems to be slow because of that! This code should specify go to this basis.

Replying to [comment:4 tscrim]:
> However, `+1` that there should be a `*_by_coercion()` in the most general (realization) category that defines that operation. IMO the `coproduct_by_coercion()` method in this ticket should go in `Coalgebras`, in which `coproduct()` will need some tweaks since it seems to be assuming a basis. Similarly `product_by_coercion()` is inherited from the `Magmas` category and is redundant.

This code don't have to be in coalgebras or magmas because, for these structures we obviously could define one realization with the unique operation of the structure.

Replying to [comment:7 pbruin]:
> I experimented a bit with running a patchbot; it chose this ticket and discovered a doctest failure in `hopf_algebras.py` due to an undefined name `left`.  

That is fix

Replying to [comment:7 pbruin]:
Independently, Travis's comment:4 also seems to mean this needs work.

I hope I have answered to that part.

Cheers, 
Jean-Baptiste


---

Comment by elixyre created at 2014-07-12 01:40:23

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2014-09-07 19:52:08

one failing doctest, see buildbot report


---

Comment by chapoton created at 2014-09-07 19:52:08

Changing status from needs_review to needs_work.


---

Comment by kdilks created at 2015-06-12 16:22:27

Based on this comment in `hopf_algebra.py` inside antipode_by_coercion:



```
            # TODO:
            # - Use @conditionally_defined once it's in Sage, for a nicer idiom
            # - Do the right thing (TM): once we will have proper
            #   overloaded operators (as in MuPAD-Combinat; see #8900),
            #   we won't need to specify explicitly to which parent one
            #   should coerce the input to calculate the antipode; so it
            #   will be sufficient to put this default implementation in
            #   HopfAlgebras.ParentMethods.
```


it sounds like what this ticket is attempting to achieve was originally the goal.

I think this is something worth figuring out eventually, but for the sake of actually getting later features of CHA included in Sage, I'm fine with Travis's suggestion of making `a_realization` always return a product/coproduct/antipode method that's hard-coded to point to a realization where the method is actually defined, rather than having Sage automatically find a realization where the method is actually defined.
