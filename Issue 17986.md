# Issue 17986: new categories for cartesian products with orders

Issue created by migration from Trac.

Original creator: dkrenn

Original creation time: 2015-04-16 16:13:26

CC:  behackl cheuberg nthiery

Keywords: sd67

Create categories for cartesian products which have a particular order (lexicographically or component-wise) on its elements.


---

Comment by dkrenn created at 2015-04-16 16:20:10

New commits:


---

Comment by dkrenn created at 2015-04-16 16:20:10

Changing status from new to needs_review.


---

Comment by chapoton created at 2015-04-19 10:08:16

fixed a failing doctest
----
New commits:


---

Comment by dkrenn created at 2015-04-19 10:16:59

Replying to [comment:4 chapoton]:
> fixed a failing doctest

Thanks.


> ||[702a8a6](http://git.sagemath.org/sage.git/commit/?id=702a8a6bcf1593671dc5cd1e1cd1e3a7454348cd)||`Merge branch 'u/dkrenn/cat/cartesian' into 6.7.b1`||

What was the reason for this merge?


---

Comment by chapoton created at 2015-04-19 11:17:48

This is forced to me by git, even when the merge is trivial. I work like that:

1) I copy the develop branch into say branch18223

2) I pull the branch from trac, sitting on branch18223

3) git forces me to do a merge commit, often a trivial one.


---

Comment by dkrenn created at 2015-04-19 12:09:41

Replying to [comment:6 chapoton]:
> This is forced to me by git, even when the merge is trivial. I work like that:
> 
> 1) I copy the develop branch into say branch18223
> 
> 2) I pull the branch from trac, sitting on branch18223
> 
> 3) git forces me to do a merge commit, often a trivial one.

http://www.sagemath.org/doc/developer/manual_git.html#merging-and-rebasing says at the end of the section:

    [...] do nothing unless necessary: it is perfectly fine for your branch to be behind master [...]


---

Comment by git created at 2015-04-24 19:16:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-05-03 20:08:59

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-05-03 20:08:59

Hello Daniel,

1. There are tons of product orders that you can define on a cartesian product of posets. You want to write a category for each of them? It is not at all usable for people that wants to build a custom product. The aim of categories is to factorize code not to expand the amount of work. I think that you should seriously develop another strategy for providing an order to a product of posets.

2. Moreover, this looks very unnatural to me:

```
sage: P = Poset((srange(10), lambda left, right: left <= right))
sage: Q = cartesian_product((P, P, P),
....: extra_category=Posets().CompareLexCartesianProduct())
```

  IMHO, something like the following would be better

```
sage: posets.cartesian_product((P,P,P), order = my_order)
```

  where order could also be a custom function or a string like 'lex', 'product', ... this second remark is just from the user point of view.

3. If there is one product, it should be the cartesian product (or the coordinate wise product) which is the categorical one (when morphisms are the monotone functions). Though as there is a lack of definitions, I am not sure that `Hom` between two posets are the monotone functions. Would be interesting to settle that.

4. Sided remark: this will not work with cython Element classes (as there is no element_class)

```
self.element_class.__le__ = \
lambda left, right: left.parent().le(left, right)
```


Vincent


---

Comment by nthiery created at 2015-05-03 20:44:19

Salut Vincent!

We had discussed this design with Daniel, and take my share of the blame. I am not quite happy with this solution. I am not quite happy with other solutions either. So that's a good occasion for a discussion!

I guess the main question is whether there will be other categories in
the long run where there will be several variants for the cartesian
product, and we want everything to interplay.

If not, then having a specific cartesian product for posets is
probably ok.

If yes, we would want to have some syntax where we can specify options
for the various structures.

```
    sage: cartesian_product([A,B,C], poset options, xxx options, ...)
```


This is more or less what the proposed syntax aims for. But it has the
drawbacks you mention. Possibly this would not be so bad if the
category was parametrized by a "term order":


```
    sage: cartesian_product([A,B,C], Posets().CartesianProducts(term_order="lex")
```


It would need to be checked whether we can indeed achieve this syntax
(or a similar one) without tweaking too much the functorial
construction infrastructure.

Another related question is whether a single function is sufficient to
specify the order, or not: maybe we would want to provide
implementations of other methods that apply for specific term orders.

Cheers,
                                  Nicolas


---

Comment by vdelecroix created at 2015-05-03 21:21:59

Salut Nicolas,

Replying to [comment:10 nthiery]:
> We had discussed this design with Daniel, and take my share of the blame. I am not quite happy with this solution. I am not quite happy with other solutions either. So that's a good occasion for a discussion!

On the other hand the feature is clearly missing. So we need to find a solution.

> I guess the main question is whether there will be other categories in
> the long run where there will be several variants for the cartesian
> product, and we want everything to interplay.
> 
> If not, then having a specific cartesian product for posets is
> probably ok.
>
> If yes, we would want to have some syntax where we can specify options
> for the various structures.
> {{{
>     sage: cartesian_product([A,B,C], poset options, xxx options, ...)
> }}}

This worries me a lot since cartesian product is intended for any kind of structures... not only poset. If you start adding specific options into this machinery it will be horrible as well.

> This is more or less what the proposed syntax aims for. But it has the
> drawbacks you mention. Possibly this would not be so bad if the
> category was parametrized by a "term order":
> 
> {{{
>     sage: cartesian_product([A,B,C], Posets().CartesianProducts(term_order="lex")
> }}}

This is already nicer. Though, there is a problem with morphisms then (see my remark 3 in [comment:9 comment:9]). The order in a cartesian product can not be parametrized if the morphisms are monotone functions. So doing the above will prevent defining morphisms in that way. I do not know whether it is what we want to do here.

Note that the following almost works

```
B = cartesian_product([A0, A1, A2])
my_cmp = lambda x,y: x[0] <= y[0] and x[1] <= y[1] and x[2] <= y[2]
P = Poset((B, my_cmp))
```

I say almost, because building a `Poset` is infinitely slow as always and works only for finite posets.

Vincent


---

Comment by dkrenn created at 2015-05-05 07:45:41

Replying to [comment:11 vdelecroix]:
> Note that the following almost works
> {{{
> B = cartesian_product([A0, A1, A2])
> my_cmp = lambda x,y: x[0] <= y[0] and x[1] <= y[1] and x[2] <= y[2]
> P = Poset((B, my_cmp))
> }}}
> I say almost, because building a `Poset` is infinitely slow as always and works only for finite posets.

Just a short comment: This will not work for what I have in mind, since my A0, A1, A2 will be groups or monoids or rings, and I want B to be a group or monoid or ring, resp., as well. This is also one motivation for using the category framework to add the desired comparison behavior to existing structures.


---

Comment by dkrenn created at 2015-06-02 14:33:24

I've now derived a class from `sets.cartesian_product.CartesianProduct` for posets. One can specify by a parameter which order one wants to take. User defined orderes can be used as well.


```
        sage: P = Poset((srange(3), lambda left, right: left <= right))
        sage: P.CartesianProduct = sage.sets.cartesian_product.CartesianProductPosets
        sage: Cl = cartesian_product((P, P), order='lex')
        sage: Cl((1, 1)) <= Cl((2, 0))
        True
        sage: Cc = cartesian_product((P, P), order='components')
        sage: Cc((1, 1)) <= Cc((2, 0))
        False
        sage: def le_sum(left, right):
        ....:     return (sum(left) < sum(right) or
        ....:             sum(left) == sum(right) and left[0] <= right[0])
        sage: Cs = cartesian_product((P, P), order=le_sum)
        sage: Cs((1, 1)) <= Cs((2, 0))
        True
```


----
Last 10 new commits:


---

Comment by dkrenn created at 2015-06-02 14:33:24

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2015-06-02 14:45:39

This new implementation is now used in #18587 for the asymptotic growth groups (#17600, underlying the asymptotic ring #17601)


---

Comment by git created at 2015-08-22 09:33:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2015-09-17 11:10:05

Hello!

I've started to review this ticket and merged it into 6.9.beta5. Here are some comments:

- The changes in `covariant_functorial_construction.py` look good to me.
- Regarding the changes in `categories/sets_cat.py`: 
  - I've added a small reviewer commit to improve the language in the docstring of `cartesian_product`.
  - Overall, these changes also look good to me. I only have one question regarding the `extra_category` keyword: should it be possible to pass lists (or some other iterable) of categories to `extra_category`, or is there no use case for that?

As far as I can see, everything else regarding these changes has been discussed on #18586.

I'll report back as soon as I had a look at the remaining changes.
----
Last 10 new commits:


---

Comment by behackl created at 2015-09-17 11:10:05

Changing status from needs_review to needs_info.


---

Comment by vdelecroix created at 2015-09-17 11:59:10

Hello,

1. I think that the class `CartesianProductPosets` would better be somewhere in `combinat/posets` rather in `sets/cartesian_product`. It is always better to split files.

2. Why is the following not a poset

```
sage: P = Poset((srange(3), lambda left, right: left <= right))
sage: cartesian_product([P,P]).category()
Category of Cartesian products of finite enumerated sets
```


3. The argument `order` in the class `CartesianProductPosets` is mandatory. While the following just works

```
sage: C = cartesian_product([ZZ, ZZ], extra_category=Posets())
```

   actually not

```
sage: TestSuite(C).run()
Failure in _test_not_implemented_methods:
Traceback (most recent call last):
...
AssertionError: Not implemented method: le
------------------------------------------------------------
The following tests failed: _test_not_implemented_methods
```


4. As I already said, it would make sense to have the product order as a default since it is *the* cartesian product (in a categorical sense when morphisms are increasing functions).

Vincent


---

Comment by vdelecroix created at 2015-09-17 11:59:10

Changing status from needs_info to needs_work.


---

Comment by vdelecroix created at 2015-09-17 12:10:25

5. Instead of `order=components` I would use `order=product` which is the standard name (see [wikipedia](https://en.wikipedia.org/wiki/Product_order)). And put it first in your list in view of comment 4.

6. Why

```
super(CartesianProductPosets, self).__init__(sets, category, **kwargs)
from sage.categories.posets import Posets
self._refine_category_(Posets())
```

  instead of

```
category = category.join(Posets())
CartesianProduct.__init__(sets, category, **kwargs)
```

  I guess that the refine category operation is highly non trivial (perhaps even sloppy).

7. (from your doctest) This is ugly

```
sage: QQ.CartesianProduct = sage.sets.cartesian_product.CartesianProductPosets
```

  Is this the way we are supposed to use to construct cartesian product of posets!?

8. Why not implementing `_richcmp_` (see #18305)? You would end up with less code.

9. It is always (should always be) faster to use `x <= y` instead of `x.__le__(y)`. You avoid a lookup.


---

Comment by git created at 2015-09-17 14:01:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2015-09-17 14:15:27

Thanks for having a look at the code Vincent! I'd like to add some more comments as well.

Replying to [comment:18 vdelecroix]:
> 1. I think that the class `CartesianProductPosets` would better be somewhere in `combinat/posets` rather in `sets/cartesian_product`. It is always better to split files.

Currently, I like the idea that both "types" of cartesian products can be found in the same file; I'm not quite sure if it would really be more clean to move this code to some other file. In any case, I don't really have any arguments for or against moving the code, I'll leave this decision to those with more experience.

> 2. Why is the following not a poset
> {{{
> sage: P = Poset((srange(3), lambda left, right: left <= right))
> sage: cartesian_product([P,P]).category()
> Category of Cartesian products of finite enumerated sets
> }}}

This is the same behavior as we had before; this ticket did not change that. However, it probably should.

My suggestion would be to add the line


```
CartesianProduct = CartesianProductPosets
```


to the `ParentMethods`-class in `categories/posets.py`, together with an appropriate (lazy) import. If I understood correctly, this would make all parents with a subcategory of `Posets()` use the `CartesianProductPosets`-class for constructing the cartesian product.

This change would also suggest using a default argument for the order (otherwise, this change is potentially backwards-incompatible)---and as Vincent has pointed out in 4., this would be somehow natural.

> 3. The argument `order` in the class `CartesianProductPosets` is mandatory. While the following just works
> {{{
> sage: C = cartesian_product([ZZ, ZZ], extra_category=Posets())
> }}}
>    actually not
> {{{
> sage: TestSuite(C).run()
> Failure in _test_not_implemented_methods:
> Traceback (most recent call last):
> ...
> AssertionError: Not implemented method: le
> ------------------------------------------------------------
> The following tests failed: _test_not_implemented_methods
> }}}
> 

As far as I can see, this comes from

```
return parents[0].CartesianProduct(...)
```

in the last line of `cartesian_product` in `categories/sets_cat.py`. If the category of `parents[0]` isn't a subcategory of `Posets()`, the non-poset cartesian product is constructed (even with my suggestion from above). In any case, I think it is easy to take care of that case.

I agree completely with 4, 5, 7; and I know too little about `_refine_category_` to comment on 6. It seems like a good idea to follow #18305 and implement `_richcmp_` in the `Element`-class.

Finally, I pushed another small commit with some documentation-related changes.

I'd suggest taking care of setting `Parent.CartesianProduct` automatically for subcategories of `Posets()`, as well as adapting `cartesian_product` such that in case `category` is a subcategory of `Posets()`, the class `CartesianProductPosets` is used for the construction of the cartesian product.

Other than that, this would be `positive_review` from my side.

Benjamin


---

Comment by vdelecroix created at 2015-09-17 17:33:00

Hi Benjamin,

Replying to [comment:21 behackl]:
> Thanks for having a look at the code Vincent! I'd like to add some more comments as well.
> 
> Replying to [comment:18 vdelecroix]:
> > 1. I think that the class `CartesianProductPosets` would better be somewhere in `combinat/posets` rather in `sets/cartesian_product`. It is always better to split files.
> 
> Currently, I like the idea that both "types" of cartesian products can be found in the same file; I'm not quite sure if it would really be more clean to move this code to some other file. In any case, I don't really have any arguments for or against moving the code, I'll leave this decision to those with more experience.

It is not two disjoint types of `CartesianProduct`. One inherits from the other.

Some arguments for the splitting:
 - there at least one antecedant: `sage.groups.group_semidirect_product.GroupSemidirectProduct`
 - if we start populating `sets.cartesian_product` it might become very huge
 - it is (up to `categories/*`) how the code is organized in the source. If you are looking for features of poset you look in `sage.combinat.posets` (ideally it would even be `sage.posets`).

Vincent


---

Comment by dkrenn created at 2015-09-22 12:35:20

Hi Vicent,

Replying to [comment:19 vdelecroix]:
> 8. Why not implementing `_richcmp_` (see #18305)? You would end up with less code.

Indeed it would. It seems that `element_wrapper` is not using my `_richcmp_` and fixing `element_wrapper` seems a bit more work (and not suitable for this ticket here).
----
New commits:


---

Comment by dkrenn created at 2015-09-22 12:54:28

Replying to [comment:18 vdelecroix]:
> 1. I think that the class `CartesianProductPosets` would better be somewhere in `combinat/posets` rather in `sets/cartesian_product`. It is always better to split files.

Ok, split and moved to sage.combinat.posets

> 2. Why is the following not a poset
> {{{
> sage: P = Poset((srange(3), lambda left, right: left <= right))
> sage: cartesian_product([P,P]).category()
> Category of Cartesian products of finite enumerated sets
> }}}

It now is. (I've used the solution Benjamin suggested above).

> 3. The argument `order` in the class `CartesianProductPosets` is mandatory. While the following just works
> {{{
> sage: C = cartesian_product([ZZ, ZZ], extra_category=Posets())
> }}}
>    actually not
> {{{
> sage: TestSuite(C).run()
> Failure in _test_not_implemented_methods:
> Traceback (most recent call last):
> ...
> AssertionError: Not implemented method: le
> ------------------------------------------------------------
> The following tests failed: _test_not_implemented_methods
> }}}

The problem is that `ZZ` (and `QQ` as well) is not a in the category of `Posets`. (#19269 will change this).

> 4. As I already said, it would make sense to have the product order as a default since it is *the* cartesian product (in a categorical sense when morphisms are increasing functions).

Default argument: done.


---

Comment by dkrenn created at 2015-09-22 12:57:06

Replying to [comment:19 vdelecroix]:
> 5. Instead of `order=components` I would use `order=product` which is the standard name (see [wikipedia](https://en.wikipedia.org/wiki/Product_order)). And put it first in your list in view of comment 4.

Changed.

> 6. Why
> {{{
> super(CartesianProductPosets, self).__init__(sets, category, **kwargs)
> from sage.categories.posets import Posets
> self._refine_category_(Posets())
> }}}
>   instead of
> {{{
> category = category.join(Posets())
> CartesianProduct.__init__(sets, category, **kwargs)
> }}}
>   I guess that the refine category operation is highly non trivial (perhaps even sloppy).

Yes, it was kind of sloppy. Changed now.

> 7. (from your doctest) This is ugly
> {{{
> sage: QQ.CartesianProduct = sage.sets.cartesian_product.CartesianProductPosets
> }}}
>   Is this the way we are supposed to use to construct cartesian product of posets!?

This changes, once `QQ` has category `Posets` as well (#19269).

> 8. Why not implementing `_richcmp_` (see #18305)? You would end up with less code.

Skipped; see comment above.

> 9. It is always (should always be) faster to use `x <= y` instead of `x.__le__(y)`. You avoid a lookup.

Ok, thanks for this hint.


---

Comment by vdelecroix created at 2015-09-22 13:07:40

Hi Daniel, hi Benjamin,

Thanks for all the modifs. If it is an easy ticket, could we set #19269 as a dependency? The current related doctests are really awful. If it is not that simple, we will fix these in #19269.

Concerning the `ElementWrapper` I indeed remember that I had the same trouble when converting some code to the new testing framework.

Vincent


---

Comment by git created at 2015-09-22 13:49:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-09-22 13:49:55

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2015-09-22 13:51:28

Replying to [comment:27 vdelecroix]:
> Thanks for all the modifs. If it is an easy ticket, could we set #19269 as a dependency? The current related doctests are really awful. If it is not that simple, we will fix these in #19269.

I'd prefer to fix this in #19269 (due to the discussions there).


---

Comment by dkrenn created at 2015-09-22 13:55:02

Replying to [comment:27 vdelecroix]:
> Concerning the `ElementWrapper` I indeed remember that I had the same trouble when converting some code to the new testing framework.

Once these troubles are solved; I've prepared an implementation of `_richcmp_` in branch
`u/dkrenn/cat/cartesian-product-posets-richcmp`


---

Comment by vdelecroix created at 2015-09-22 14:33:28

Instead of using `QQ` which is not a poset in the doctest why not use available ones from `Posets.<tab>`?

Some more comments

10. In the documentation clqss of `CartesianProductPosets` you should say that `order` and `order_le` are optionals and what is the default behavior. You should also document the behavior of

```
sage: CartesianProductPoset([X,Y,Z], order='lex', order_le=my_le)
```

  (or raise an appropriate error)

11. I am not sure how much this is supported but parents are allowed to have their `category` argument to be set to a tuple as in

```
sage: P = Parent(category=(Rings(),Posets()))
sage: P.category()
Join of Category of rings and Category of posets
```

  In your subclass, the operation `category & Posets()` would break. You might use the safer `Category.join(my_list_of_categories)`. If you do so, add an appropriate doctest for that.

12. What is the point of adding `*kwargs` in the `__init__` method of `CartesianProduct`? If this argument is not supported then it should simply not exists.

13. Add some `TestSuite(C).run()` for various cartesian products of posets (i.e. at least with the two default implemented orders and one self implemented).

14. Since the cartesian product elements are tuples, we might want to use the orders from the tuple themselves (which is fastest then anything else). What about an alternative

```
def le_native(self, x, y):
    return x.value <= y.value
```


15. I am not sure that it is good to have the `le_*` methods as being public. Do you have some feeling about it?


---

Comment by vdelecroix created at 2015-09-22 14:33:28

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-09-22 15:34:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-09-22 15:42:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-09-22 15:50:15

Replying to [comment:32 vdelecroix]:
> Instead of using `QQ` which is not a poset in the doctest why not use available ones from `Posets.<tab>`?

Ok, done for the public method(s). (But I've kept the `QQ`-test in some of the private methods).

> 10. In the documentation clqss of `CartesianProductPosets` you should say that `order` and `order_le` are optionals and what is the default behavior. You should also document the behavior of
> {{{
> sage: CartesianProductPoset([X,Y,Z], order='lex', order_le=my_le)
> }}}
>   (or raise an appropriate error)

`order_le` is not a keyword. I've rewritten the doc to avoid this confusion.

> 11. I am not sure how much this is supported but parents are allowed to have their `category` argument to be set to a tuple as in
> {{{
> sage: P = Parent(category=(Rings(),Posets()))
> sage: P.category()
> Join of Category of rings and Category of posets
> }}}
>   In your subclass, the operation `category & Posets()` would break. You might use the safer `Category.join(my_list_of_categories)`. If you do so, add an appropriate doctest for that.

Changed.

> 12. What is the point of adding `*kwargs` in the `__init__` method of `CartesianProduct`? If this argument is not supported then it should simply not exists.

This boils down to our discussion from #18586: They are passed on to `CartesianProduct` where there is at least a `flatten` keyword. Thus there is a keyword, so arguments are simply passed.

> 13. Add some `TestSuite(C).run()` for various cartesian products of posets (i.e. at least with the two default implemented orders and one self implemented).

Added.

> 14. Since the cartesian product elements are tuples, we might want to use the orders from the tuple themselves (which is fastest then anything else). What about an alternative
> {{{
> def le_native(self, x, y):
>     return x.value <= y.value
> }}}

Added.

> 15. I am not sure that it is good to have the `le_*` methods as being public. Do you have some feeling about it?

Yes, I'd prefer to keep them public, so one can use a different ordering easily (I mean, without changing the given order, but use another order for whatever reasons). Moreover, there seems no need to hide this methods from the public (they can just be used as `le` in posets).


---

Comment by dkrenn created at 2015-09-22 15:50:15

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-09-22 22:39:52

Replying to [comment:35 dkrenn]:
> Replying to [comment:32 vdelecroix]:

> > 10. In the documentation <...>
>
> `order_le` is not a keyword. I've rewritten the doc to avoid this confusion.

got it ;-)

> > 12. What is the point of adding `*kwargs` in the `__init__` method of `CartesianProduct`? If this argument is not supported then it should simply not exists.
> 
> This boils down to our discussion from #18586: They are passed on to `CartesianProduct` where there is at least a `flatten` keyword. Thus there is a keyword, so arguments are simply passed.

I still do not understand at all. I am talking about `sage.sets.cartesian_product.CartesianProduct`. Its constructor does not pass its arguments to anybody. What is the subtle difference in behaviour between `f` and `g` below?

```
def f(**kwds):
   if kwds:
       raise TypeError
   ...

def g():
    ...
```

The only thing I see is that it needs much more to write `f`.


---

Comment by vdelecroix created at 2015-09-22 22:39:52

Changing status from needs_review to needs_info.


---

Comment by git created at 2015-09-23 07:36:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-09-23 07:37:36

Replying to [comment:36 vdelecroix]:
> Replying to [comment:35 dkrenn]:
> > > 12. What is the point of adding `*kwargs` in the `__init__` method of `CartesianProduct`? If this argument is not supported then it should simply not exists.
> > 
> > This boils down to our discussion from #18586: They are passed on to `CartesianProduct` where there is at least a `flatten` keyword. Thus there is a keyword, so arguments are simply passed.
> 
> I still do not understand at all. I am talking about `sage.sets.cartesian_product.CartesianProduct`. Its constructor does not pass its arguments to anybody. What is the subtle difference in behaviour between `f` and `g` below?
> {{{
> def f(**kwds):
>    if kwds:
>        raise TypeError
>    ...
> 
> def g():
>     ...
> }}}
> The only thing I see is that it needs much more to write `f`.

I think I see your point now and I have to admit I thought we were taking about `CartesianProductPosets` (and not about `CartesianProduct`). I agree that this is obsolete now. I've deleted it.
----
New commits:
----
Last 10 new commits:


---

Comment by dkrenn created at 2015-09-23 07:37:36

Changing status from needs_info to needs_review.


---

Comment by chapoton created at 2015-09-23 18:57:54

two failing doctests


---

Comment by behackl created at 2015-09-28 14:32:59

I fixed the two failing doctests (in `6.9.beta7` the category of the cartesian product of `ZZ` with itself changed) and merged `6.9.rc0` into this branch.

Vincent, as you have done quite some work here would you like to add your name to the reviewers?

Finally, as this ticket seems to have reached a stable state, this could be set to `positive_review`. Any objections?

Benjamin
----
Last 10 new commits:


---

Comment by vdelecroix created at 2015-09-28 14:34:59

Replying to [comment:40 behackl]:
> Vincent, as you have done quite some work here would you like to add your name to the reviewers?

done 

> Finally, as this ticket seems to have reached a stable state, this could be set to `positive_review`. Any objections?
 
The branch is in good shape. I would like to go through the whole changes a last time. If everything is fine I will set the positive review. Is that ok?

Vincent


---

Comment by behackl created at 2015-09-28 14:37:42

Replying to [comment:41 vdelecroix]:
> The branch is in good shape. I would like to go through the whole changes a last time. If everything is fine I will set the positive review. Is that ok?

Sure! Thanks for going over it once again! `:-)`

Benjamin


---

Comment by vdelecroix created at 2015-09-30 01:34:01

16. The name `CartesianProductPosets` looks weird. I would rather go for `CartesianProductPoset` (no `s`) or `PosetsCartesianProduct`. As it is currently it looks like _the set of posets that are made from cartesian products_.

17. You should remove your name from `sage/sets/cartesian_product.py`. I have nothing agaist authorship but as it is, it looks like spam ;-)

18. There is no example testing that the coercion can get involved in comparisons. Either it is worth it and it needs a use case or it can be removed.

19. This is not nice

```
+        CartesianProductPosets = LazyImport(
+            'sage.combinat.posets.cartesian_product', 'CartesianProductPosets')
+        CartesianProduct = CartesianProductPosets
```

  because

```
sage: E = Posets().example()
sage: E.Car<tab>
E.CartesianProduct        E.CartesianProductPosets
```

  which actually point toward the exact same thing. Please change for

```
+        CartesianProduct = LazyImport(
+            'sage.combinat.posets.cartesian_product', 'CartesianProductPosets')
```


And some questions:

20. Most methods of finite posets are actually not available in this class... this is very annoying (but I do not see what can be done at the level of this ticket).

21. Are you aware that

```
sage: C = cartesian_product([ZZ, ZZ], extra_category=Posets())
sage: from sage.combinat.posets.cartesian_product import CartesianProductPosets
sage: isinstance(C, CartesianProductPosets)
False
```

  and indeed

```
sage: TestSuite(C).run()
Failure in _test_not_implemented_methods:
...
AssertionError: Not implemented method: le
------------------------------------------------------------
The following tests failed: _test_not_implemented_methods
```



---

Comment by vdelecroix created at 2015-09-30 01:34:01

Changing status from needs_review to needs_work.


---

Comment by dkrenn created at 2015-09-30 11:32:08

Replying to [comment:43 vdelecroix]:
> 16. The name `CartesianProductPosets` looks weird. I would rather go for `CartesianProductPoset` (no `s`) or `PosetsCartesianProduct`. As it is currently it looks like _the set of posets that are made from cartesian products_.

Ok (I don't have an opinion on this); changed to `CartesianProductPoset`.

> 17. You should remove your name from `sage/sets/cartesian_product.py`. I have nothing agaist authorship but as it is, it looks like spam ;-)

Ooops...forgotten to remove it (when moving to the code to `combinat.posets`). Thanks; removed.

> 18. There is no example testing that the coercion can get involved in comparisons. Either it is worth it and it needs a use case or it can be removed.

I've added a doctest. This test can and will be rewritten once #18182 is merged.

> 19. This is not nice
> {{{
> +        CartesianProductPosets = LazyImport(
> +            'sage.combinat.posets.cartesian_product', 'CartesianProductPosets')
> +        CartesianProduct = CartesianProductPosets
> }}}
>   because
> {{{
> sage: E = Posets().example()
> sage: E.Car<tab>
> E.CartesianProduct        E.CartesianProductPosets
> }}}
>   which actually point toward the exact same thing.

I completly agree.

> Please change for
> {{{
> +        CartesianProduct = LazyImport(
> +            'sage.combinat.posets.cartesian_product', 'CartesianProductPosets')
> }}}

I wasn't aware that this works, but it is clear that it works :) Changed.

> 20. Most methods of finite posets are actually not available in this class... this is very annoying (but I do not see what can be done at the level of this ticket).

True; I think this should be fixed by using the `Posets`-category, but definitely not on this ticket.

> 21. Are you aware that
> {{{
> sage: C = cartesian_product([ZZ, ZZ], extra_category=Posets())
> sage: from sage.combinat.posets.cartesian_product import CartesianProductPosets
> sage: isinstance(C, CartesianProductPosets)
> False
> }}}
>   and indeed
> {{{
> sage: TestSuite(C).run()
> Failure in _test_not_implemented_methods:
> ...
> AssertionError: Not implemented method: le
> ------------------------------------------------------------
> The following tests failed: _test_not_implemented_methods
> }}}

Yes, I am aware of. Adding an extra category only makes sense if the underlying object is a poset (thus has `le`). Since `ZZ` is not a poset (see #19269), the cartesian product is not a poset (and has no `le`) and therefore is not an instance of `CartesianProductPoset`. Thus, the failure of the test suite is correct.
FYI: The class used for the cartesian product is determined by its first factor (and not by the category).
----
New commits:


---

Comment by dkrenn created at 2015-09-30 11:32:08

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-09-30 13:32:46

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2015-09-30 13:32:46

All right. Thanks for the last changes.

Vincent


---

Comment by vbraun created at 2015-10-12 07:16:36

Resolution: fixed
