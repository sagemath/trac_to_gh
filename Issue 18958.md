# Issue 18958: Make tensor of CombinatorialFreeModule use cartesian_product

Issue created by migration from Trac.

Original creator: vdelecroix

Original creation time: 2015-09-13 02:06:58

CC:  nthiery tscrim lorenz vdelecroix jhpalmieri

The last class to use `sage.combinat.cartesian_product.CartesianProduct_iters` is the `CombinatorialFreeModule`. It is not simple to get rid of this since there is no check in constructing element of a combinatorial free module... hence changing the basis from being tuples to be element of a cartesian product might lead to subtle errors (e.g. http://trac.sagemath.org/ticket/18411#comment:24).


---

Comment by chapoton created at 2018-02-03 20:22:16

New commits:


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by git created at 2022-08-10 21:28:20

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2022-08-10 21:38:21

Rebased. Some doctests need to be updated. In particular:

```
**********************************************************************
File "src/sage/combinat/free_module.py", line 1520, in sage.combinat.free_module.CombinatorialFreeModule.CombinatorialFreeModule_Tensor._coerce_map_from_
Failed example:
    S.an_element()
Expected:
    3*B[0] # B[-1] + 2*B[0] # B[0] + 2*B[0] # B[1]
...
    UserWarning: Sage is not able to determine whether the factors of this Cartesian product are finite. The lexicographic ordering might not go through all elements.
    3*B[0] # B[-1] + B[0] # B[0] + 2*B[0] # B[1] + B[1] # B[1]
```



---

Comment by git created at 2022-08-11 04:37:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-11 05:05:57

Replying to [comment:11 mkoeppe]:
> {{{
>     UserWarning: Sage is not able to determine whether the factors of this Cartesian product are finite. The lexicographic ordering might not go through all elements.
>     3*B[0] # B[-1] + B[0] # B[0] + 2*B[0] # B[1] + B[1] # B[1]
> }}}

Related recent discussion in #33287


---

Comment by mkoeppe created at 2022-08-11 05:15:09

I think this warning (from `Sets.CartesianProducts.ParentMethods.__iter__`, added in #18411) is useless and is best removed. It's essentially warning that it may be constructing an infinite order of the wrong order type. But this is irrelevant for any algorithm


---

Comment by mkoeppe created at 2022-08-11 18:01:24

Replying to [comment:16 mkoeppe]:
> I think this warning (from `Sets.CartesianProducts.ParentMethods.__iter__`, added in #18411) is useless and is best removed. It's essentially warning that it may be constructing an infinite order of the wrong order type. But this is irrelevant for any algorithm

I take this back. I now propose that instead of issuing a warning, Cartesian products of possibly infinite factors should be enumerated using the existing, poorly named function `sage.misc.mrange.cantor_product` (enumeration in the order of increasing sums-of-ranks).


---

Comment by git created at 2022-08-11 18:31:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-11 18:32:10

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2022-08-11 18:35:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-11 21:06:32

Doctest failures in 2 files remain:

```
sage -t --long --random-seed=231229664758049651431332547293032544509 src/sage/algebras/steenrod/steenrod_algebra.py  # Timed out
sage -t --long --random-seed=231229664758049651431332547293032544509 src/sage/homology/hochschild_complex.py  # 10 doctests failed
```



---

Comment by git created at 2022-08-11 21:19:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-11 21:22:20

Only one file, `src/sage/algebras/steenrod/steenrod_algebra.py` needs a closer look by experts:

```
UserWarning: Testing equality of infinite sets which will not end in case of equality

    TypeError: <class 'sage.sets.set_from_iterator.EnumeratedSetFromIterator_with_category'> is not hashable and does not implement _cache_key()
    ------------------------------------------------------------
    The following tests failed: _test_antipode

(times out)
```



---

Comment by mkoeppe created at 2022-08-12 06:27:19

This is the doctest that times out:

```
sage: d = a.change_basis('comm_long'); d.coproduct() ## line 3392 ##
```


`sage.sets.set_from_iterator.EnumeratedSetFromIterator.__eq__` gives the warning and then indeed times out trying to compare the following sets:

```
(Pdb) p self
basis key family of mod 2 Steenrod algebra, pst_revz basis
(Pdb) p other
basis key family of mod 2 Steenrod algebra, comm_revz_long basis
(Pdb) p type(self)
<class 'sage.sets.set_from_iterator.EnumeratedSetFromIterator_with_category'>
(Pdb) p type(other)
<class 'sage.sets.set_from_iterator.EnumeratedSetFromIterator_with_category'>
```



---

Comment by mkoeppe created at 2022-08-12 06:58:47

This equality test is needed by the `UniqueRepresentation` behavior of `sage.sets.cartesian_product.CartesianProduct`


---

Comment by jhpalmieri created at 2022-08-12 18:59:22

Unfortunately, while I see the doctest failure, I can't replicate it in an interactive session, so it's hard to debug. I think the problem arises in the lines

```
            for (a,b), coeff in x:
                result.append((tensor((A._change_basis_on_basis(a, basis),
                                       A._change_basis_on_basis(b, basis))),coeff))

```

(lines 1376-8).


---

Comment by mkoeppe created at 2022-08-12 20:22:13

Here's a minimal reproducer:

```
            sage: SteenrodAlgebra(basis='pst').Sq(0,1).coproduct()
            sage: a = Sq(2)
            sage: d = a.change_basis('comm_long'); d.coproduct()
```



---

Comment by jhpalmieri created at 2022-08-12 20:41:02

The bases for "mod 2 Steenrod algebra, pst_revz basis" and "mod 2 Steenrod algebra, comm_revz_long basis" have the same indexing sets, although the corresponding algebra elements are different. Therefore the same will be true for their tensor squares. As a result, I'm not sure what to do about this.


---

Comment by mkoeppe created at 2022-08-12 20:46:26


```
sage: s_pst = SteenrodAlgebra(basis='pst')
sage: s_comm_long = SteenrodAlgebra(basis='comm_long')
sage: s_pst.basis()
Lazy family (Term map from basis key family of mod 2 Steenrod algebra, pst_revz basis to mod 2 Steenrod algebra, pst_revz basis(i))_{i in basis key family of mod 2 Steenrod algebra, pst_revz basis}
sage: s_comm_long.basis()
Lazy family (Term map from basis key family of mod 2 Steenrod algebra, comm_revz_long basis to mod 2 Steenrod algebra, comm_revz_long basis(i))_{i in basis key family of mod 2 Steenrod algebra, comm_revz_long basis}
sage: s_pst.basis() == s_comm_long.basis()
/Users/mkoeppe/s/sage/sage-rebasing/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/sets/set_from_iterator.py:311: UserWarning: Testing equality of infinite sets basis key family of mod 2 Steenrod algebra, pst_revz basis and basis key family of mod 2 Steenrod algebra, comm_revz_long basis,  which will not end in case of equality
```



---

Comment by mkoeppe created at 2022-08-12 20:50:19

It seems we either need a better `__eq__` for `LazyFamily` in general, or just more specific `Family` implementation for these basis key families


---

Comment by git created at 2022-08-12 20:59:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-12 21:01:15

This fixes the comparison in comment:31, but not the original problem


---

Comment by mkoeppe created at 2022-08-12 21:13:12


```
sage: s_pst = SteenrodAlgebra(basis='pst')
sage: s_comm_long = SteenrodAlgebra(basis='comm_long')
sage: s_pst.basis().keys() == s_comm_long.basis().keys()
/Users/mkoeppe/s/sage/sage-rebasing/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/sets/set_from_iterator.py:311: UserWarning: Testing equality of infinite sets basis key family of mod 2 Steenrod algebra, pst_revz basis and basis key family of mod 2 Steenrod algebra, comm_revz_long basis,  which will not end in case of equality
```



---

Comment by jhpalmieri created at 2022-08-12 21:22:05

Right, these sets of keys are the same.


---

Comment by jhpalmieri created at 2022-08-12 22:00:23

Although they have different string representations, so I don't know why the latest change doesn't catch it.


---

Comment by mkoeppe created at 2022-08-12 22:01:22

The latest change was for `LazyFamily`, not for `EnumeratedSetFromIterator`.


---

Comment by mkoeppe created at 2022-08-12 22:02:40

`EnumeratedSetFromIterator` does not look at names; `__eq__` is equality as sets


---

Comment by jhpalmieri created at 2022-08-12 22:09:50

This fixes the problem for me, but I don't know if it's the right thing to do:

```diff
diff --git a/src/sage/sets/set_from_iterator.py b/src/sage/sets/set_from_iterator.py
index 3a2360383e..90218aa426 100644
--- a/src/sage/sets/set_from_iterator.py
+++ b/src/sage/sets/set_from_iterator.py
`@``@` -297,6 +297,8 `@``@` class EnumeratedSetFromIterator(Parent):
             True
         """
         if isinstance(other, EnumeratedSetFromIterator):
+            if repr(self) != repr(other):
+                return False
             # trick to allow equality between infinite sets
             # this assume that the function does not return randomized data!
             if (self._func == other._func and
```



---

Comment by mkoeppe created at 2022-08-12 22:13:54

If we want to go in the direction (making the factors "less unique"), I'd think we could give `EnumeratedSetFromIterator` an additional argument `unique_tag` (default None), which would be compared (instead of repr)


---

Comment by jhpalmieri created at 2022-08-12 22:24:20

They have a "name" attribute already; we could use that. Edit: a "name" argument, not an attribute.


---

Comment by jhpalmieri created at 2022-08-12 22:27:08

Of course that boils down to use repr.


---

Comment by jhpalmieri created at 2022-08-12 22:28:24


```diff
diff --git a/src/sage/sets/set_from_iterator.py b/src/sage/sets/set_from_iterator.py
index 3a2360383e..dbb448b829 100644
--- a/src/sage/sets/set_from_iterator.py
+++ b/src/sage/sets/set_from_iterator.py
`@``@` -297,6 +297,9 `@``@` class EnumeratedSetFromIterator(Parent):
             True
         """
         if isinstance(other, EnumeratedSetFromIterator):
+            if hasattr(self, '__custom_name') or hasattr(other, '__custom_name'):
+                if repr(self) != repr(other):
+                    return False
             # trick to allow equality between infinite sets
             # this assume that the function does not return randomized data!
             if (self._func == other._func and
```



---

Comment by mkoeppe created at 2022-08-12 22:39:47

I think this is too dangerous, it's breaking the extensionality of sets


---

Comment by mkoeppe created at 2022-08-12 22:45:10

I think a solution may be to change `sage.sets.cartesian_product.CartesianProduct` so that it only uses `UniqueRepresentation` if it can safely do so


---

Comment by git created at 2022-08-12 22:58:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-12 22:59:32

This fixes comment:29. Haven't checked yet if it breaks anything


---

Comment by jhpalmieri created at 2022-08-12 23:51:05

This produces a lot of doctest failures:

```
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/rings/asymptotic/asymptotic_expansion_generators.py  # 86 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/symbolic/expression.pyx  # 3 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/doctest/forker.py  # 3 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/homology/hochschild_complex.py  # 2 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/categories/pushout.py  # 6 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/rings/asymptotic/asymptotic_ring.py  # 236 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/algebras/hecke_algebras/ariki_koike_algebra.py  # 13 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/rings/asymptotic/term_monoid.py  # 99 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/algebras/askey_wilson.py  # 2 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/rings/asymptotic/growth_group.py  # 114 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/combinat/root_system/extended_affine_weyl_group.py  # 404 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/rings/asymptotic/growth_group_cartesian.py  # 118 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/symbolic/ring.pyx  # 5 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/categories/sets_cat.py  # 2 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/algebras/schur_algebra.py  # 1 doctest failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/categories/magmas.py  # 4 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/doc/en/thematic_tutorials/lie/affine.rst  # 1 doctest failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/groups/group_semidirect_product.py  # 35 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/sets/family.py  # 3 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/rings/big_oh.py  # 2 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/sets/cartesian_product.py  # 2 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/combinat/posets/cartesian_product.py  # 48 doctests failed
sage -t --long --random-seed=269458505477710295233910752449959854719 src/sage/combinat/cartesian_product.py  # 2 doctests failed
```



---

Comment by git created at 2022-08-12 23:51:18

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2022-08-12 23:51:42

Here's a simpler version that also creates such failures


---

Comment by jhpalmieri created at 2022-08-13 00:00:56

But hey, no failures in `algebras/steenrod`, `homology,` or `topology`, so it's all good with me. ;)


---

Comment by mkoeppe created at 2022-08-13 00:07:48

OK some of the failures were already present in 2a17576 (comment:33)


---

Comment by git created at 2022-08-13 00:09:38

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jhpalmieri created at 2022-08-13 02:40:02

I'm still seeing a lot of error messages of the form

```
File "/Users/palmieri/Desktop/Sage/sage_builds/TESTING/sage-9.7.beta8/src/sage/rings/asymptotic/growth_group_cartesian.py", line 320, in __init__
GenericGrowthGroup.__init__(self, sets[0], Vars, self.category(), **kwds)
TypeError: __init__() got an unexpected keyword argument 'flatten'
```

Also a few in `pushout.py`:

```
File "sage/misc/classcall_metaclass.pyx", line 320, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__
 return cls.classcall(cls, *args, **kwds)
TypeError: __classcall__() missing 1 required positional argument: 'category'
```



---

Comment by mkoeppe created at 2022-08-13 03:25:56

https://github.com/sagemath/sagetrac-mirror/actions/runs/2850051513 only sees the error in steenrod with e969448


---

Comment by mkoeppe created at 2022-08-13 03:26:38

Note I backed out 6d5f261


---

Comment by git created at 2022-08-13 04:10:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-13 04:10:40

OK here's a better version of the same approach, it passes all tests for me


---

Comment by git created at 2022-08-13 04:34:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-13 04:51:52

Changing status from new to needs_review.


---

Comment by git created at 2022-08-13 04:56:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-13 07:06:16

Thank you for working on this. It definitely would be good to have things more centralized. Hopefully these comments are fairly simple to incorporate.

I think this is a very dangerous test:

```python
if not repr(self) == repr(other):
```

(which it should use `!=` anyways) because

```
sage: x = 1.0
sage: y = 1
sage: repr(x) == repr(y)
False
sage: x == y
True
sage: hash(x) == hash(y)
True
```

Equal objects need not have equal (string) representations. So you have introduced a change in behavior in a way that does not respect equality.

On the other hand, I disagree with this reasoning:

```
Two :class:`EnumeratedSetFromIterator` objects that are not known to be finite
cannot be reliably tested for equality. Therefore, we do not put such objects
in the :class:`~sage.structure.unique_representation.UniqueRepresentation` cache.
```

It depends on what you mean by equality. Now we normally think of equality of sets as containment in both ways, but it might be better to think of them like knots or polytopes. You might have the same polytope (same subset of *R*<sup>n</sup>) but different representations. So it could make sense for them to not be equal. Consequently, I do not support this disabling of `UniqueRepresentation`. Either you need to remove that altogether, which I strongly oppose because of the consequences with parents and how much nicer `UniqueRepresentation` behavior makes things, or you test by equality, which uses whatever definition of equality the object uses.

This statement is needs correcting:

```diff
-When the first factor is infinite (or not known to be finite), it still
+When all but the first factor is known to be finite, it
 uses the lexicographic order::
```

I believe your code would produce

```
sage: list(islice(cantor_product(NN, NN, GF(2)), 6))
[(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1), (2, 0, 0), (1, 1, 0)]
```


Something else to be aware of is elements of `cartesian_product` are actual Sage elements rather than `list`s. So this could lead to performance regressions. Lots of things use the `CFM_tensor` class; all of the Hopf algebras basically. We might want a base or sub class of the `cartesian_product` that acts as a façade parent for tuples. So the only difference is essentially in the `_element_constructor_` and/or `__call__`.

I am wondering why we did not put `EnumeratedSets().CartesianProducts()` in the category of `EnumeratedSets()`. We might want to do this to have access to some of the generic methods from there, such as `unrank()`. Likewise, it would be good to port over some of these extra methods to `cartesian_product`, which would improve the (generic) implementation, and/or move things into the category.


---

Comment by mkoeppe created at 2022-08-13 07:15:29

Replying to [comment:63 tscrim]:
> I think this is a very dangerous test:
> {{{#!python
> if not repr(self) == repr(other):
> }}}
> (which it should use `!=` anyways) because
> {{{
> sage: x = 1.0
> sage: y = 1
> sage: repr(x) == repr(y)
> False
> sage: x == y
> True
> sage: hash(x) == hash(y)
> True
> }}}
> Equal objects need not have equal (string) representations. So you have introduced a change in behavior in a way that does not respect equality.

No, the `repr` comparison was already in the old method. It's only reordered.


---

Comment by mkoeppe created at 2022-08-13 07:24:29

Replying to [comment:63 tscrim]:
> On the other hand, I disagree with this reasoning:
> {{{
> Two :class:`EnumeratedSetFromIterator` objects that are not known to be finite
> cannot be reliably tested for equality. Therefore, we do not put such objects
> in the :class:`~sage.structure.unique_representation.UniqueRepresentation` cache.
> }}}
> It depends on what you mean by equality. Now we normally think of equality [...] or you test by equality, which uses whatever definition of equality the object uses.

I think you are trying to tell me that when I disabled `UniqueRepresentation`, I also need to disable `WithEqualityById`.

I agree with this, it needs to be corrected.


```
sage: from sage.sets.set_from_iterator import EnumeratedSetFromIterator
sage: F = EnumeratedSetFromIterator(lambda: iter([1, 2]))
sage: F.category()
Category of facade enumerated sets
sage: cartesian_product([F, F]) is cartesian_product([F, F])   # as intended
False
sage: cartesian_product([F, F]) == cartesian_product([F, F])   # BUG
False
```



---

Comment by mkoeppe created at 2022-08-13 07:24:48

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2022-08-13 07:28:25

Replying to [comment:64 mkoeppe]:
> Replying to [comment:63 tscrim]:
> > I think this is a very dangerous test:
> > {{{#!python
> > if not repr(self) == repr(other):
> > }}}
> > (which it should use `!=` anyways) because
> > {{{
> > sage: x = 1.0
> > sage: y = 1
> > sage: repr(x) == repr(y)
> > False
> > sage: x == y
> > True
> > sage: hash(x) == hash(y)
> > True
> > }}}
> > Equal objects need not have equal (string) representations. So you have introduced a change in behavior in a way that does not respect equality.
> 
> No, the `repr` comparison was already in the old method. It's only reordered.

I misread the original code; after that test was true, it would compare the `repr`. This is very strange logic. I agree that it does not change the behavior. However, I still stand by my statement about it being a dangerous test.


---

Comment by mkoeppe created at 2022-08-13 07:30:28

Replying to [comment:63 tscrim]:
> I am wondering why we did not put `EnumeratedSets().CartesianProducts()` in the category of `EnumeratedSets()`. We might want to do this 

+1


---

Comment by tscrim created at 2022-08-13 07:30:36

Replying to [comment:65 mkoeppe]:
> Replying to [comment:63 tscrim]:
> > On the other hand, I disagree with this reasoning:
> > {{{
> > Two :class:`EnumeratedSetFromIterator` objects that are not known to be finite
> > cannot be reliably tested for equality. Therefore, we do not put such objects
> > in the :class:`~sage.structure.unique_representation.UniqueRepresentation` cache.
> > }}}
> > It depends on what you mean by equality. Now we normally think of equality [...] or you test by equality, which uses whatever definition of equality the object uses.
> 
> I think you are trying to tell me that when I disabled `UniqueRepresentation`, I also need to disable `WithEqualityById`.

No, that is not what I am saying. I am saying you should either fully and completely remove `UniqueRepresentation` from being a base class (likely downgrading to `CachedRepresentation`) or understand and learn to live with equality is not always mathematical equality. IMO, what you are doing has a very strong code smell as it is breaking many rules of OOP.


---

Comment by mkoeppe created at 2022-08-13 07:31:10

Replying to [comment:67 tscrim]:
> I still stand by my statement about it being a dangerous test.

I fully agree, but I consider it beyond the scope of this ticket


---

Comment by mkoeppe created at 2022-08-13 07:36:02

Replying to [comment:69 tscrim]:
> IMO, what you are doing has a very strong code smell as it is breaking many rules of OOP.

Sure it is, but I don't agree with your conclusion.

There is a simple fix - we can just push this a level lower, namely into the implementation of CachedRepresentation/UniqueRepresentation.


---

Comment by git created at 2022-08-13 07:46:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-13 07:46:27

Here's the fix for the category


---

Comment by tscrim created at 2022-08-13 08:44:26

Replying to [comment:71 mkoeppe]:
> Replying to [comment:69 tscrim]:
> > IMO, what you are doing has a very strong code smell as it is breaking many rules of OOP.
> 
> Sure it is, but I don't agree with your conclusion.
>
> There is a simple fix - we can just push this a level lower, namely into the implementation of CachedRepresentation/UniqueRepresentation.

I don't understand this last part. The issue is you have a subclass of `UniqueRepresentation` that does not implement the `UniqueRepresentation` protocol (only a `CachedRepresentation`). So it should be a `CachedRepresentation`. This is okay, and you could have a subclass for those Cartesian products of finite sets that inherits from `UniqueRepresentation`. Not only does this make the code more complicated, it also effects the speed and reliability of other implementations.


---

Comment by mkoeppe created at 2022-08-13 16:02:54

Replying to [comment:72 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[278b7c7](https://git.sagemath.org/sage.git/commit/?id=278b7c7ec6eccc9125cd4066c15c3c16268b1382)||`src/sage/categories/enumerated_sets.py: Make (finitary) Cartesian products of enumerated enumerated`||

This caused some doctest failures:

```
File "sage/categories/sets_cat.py", line 2273, in sage.categories.sets_cat.Sets.CartesianProducts.ParentMethods.__iter__
Failed example:
    it = iter(cartesian_product([ZZ, GF(2)]))
Exception raised:
    Traceback (most recent call last):
      File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/doctest/forker.py", line 695, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/doctest/forker.py", line 1093, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.categories.sets_cat.Sets.CartesianProducts.ParentMethods.__iter__[13]>", line 1, in <module>
        it = iter(cartesian_product([ZZ, GF(Integer(2))]))
      File "/__w/sagetrac-mirror/sagetrac-mirror/src/sage/categories/enumerated_sets.py", line 238, in __iter__
        raise NotImplementedError("iterator called but not implemented")
    NotImplementedError: iterator called but not implemented
```



---

Comment by mkoeppe created at 2022-08-13 16:19:01

Let's do these category improvements in a separate ticket, #34356.


---

Comment by git created at 2022-08-13 16:19:57

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2022-08-13 16:48:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-13 16:52:56

Replying to [comment:74 tscrim]:
> The issue is you have a subclass of `UniqueRepresentation` that does not implement the `UniqueRepresentation` protocol (only a `CachedRepresentation`). So it should be a `CachedRepresentation`.

Actually, not even a `CachedRepresentation`. I've now introduced a new class `WithPicklingByInitArgs`, which `CachedRepresentation` subclasses.


---

Comment by git created at 2022-08-13 16:59:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-13 17:00:34

Replying to [comment:63 tscrim]:
> This statement is needs correcting:
> {{{#!diff
> -When the first factor is infinite (or not known to be finite), it still
> +When all but the first factor is known to be finite, it
>  uses the lexicographic order::
> }}}

I have rephrased in a similar way for clarity


---

Comment by git created at 2022-08-13 17:10:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jhpalmieri created at 2022-08-13 19:55:30

Passes tests for me.


---

Comment by git created at 2022-08-13 19:59:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-13 20:03:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-13 20:05:05

Replying to [comment:65 mkoeppe]:
> when I disabled `UniqueRepresentation`, I also need to disable `WithEqualityById`.
> 
> I agree with this, it needs to be corrected.
> 
> {{{
> sage: from sage.sets.set_from_iterator import EnumeratedSetFromIterator
> sage: F = EnumeratedSetFromIterator(lambda: iter([1, 2]))
> sage: F.category()
> Category of facade enumerated sets
> sage: cartesian_product([F, F]) is cartesian_product([F, F])   # as intended
> False
> sage: cartesian_product([F, F]) == cartesian_product([F, F])   # BUG
> False
> }}}

I have added this test (still fails)


---

Comment by jhpalmieri created at 2022-08-13 21:00:35

Maybe this is a stupid question, but should that doctest pass? According to the documentation for `EnumeratedSetFromIterator`:

```
    - ``category`` -- (default: ``None``) an optional category for that
      enumerated set. If you know that your iterator will stop after a finite
      number of steps you should set it as :class:`FiniteEnumeratedSets`, conversely if
      you know that your iterator will run over and over you should set it as
      :class:`InfiniteEnumeratedSets`.
```

If we use 

```
F = EnumeratedSetFromIterator(lambda: iter([1, 2]), category=FiniteEnumeratedSets())
```

then the doctest passes. How is it supposed to function if it doesn't know whether the arguments are finite?


---

Comment by mkoeppe created at 2022-08-13 21:24:55

At the moment, there's no code for it because `CartesianProduct` just relies on `WithEqualityById`. 

To give equality to Cartesian products without `WithEqualityById`, we could just compare the factors for equality (this is if-and-only-if because no flattening is implemented in our Cartesian products). In the example, the factors are `EnumeratedSetFromIterator`, and for these `__eq__` just loops to exhaustion to decide equality.


---

Comment by git created at 2022-08-13 21:36:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-13 23:35:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-13 23:43:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-13 23:51:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-13 23:52:35

Replying to [comment:63 tscrim]:
> Something else to be aware of is elements of `cartesian_product` are actual Sage elements rather than `list`s. So this could lead to performance regressions. Lots of things use the `CFM_tensor` class; all of the Hopf algebras basically. We might want a base or sub class of the `cartesian_product` that acts as a façade parent for tuples. So the only difference is essentially in the `_element_constructor_` and/or `__call__`.

The choice of element class is now set in the subclass `CartesianProduct_with_element_wrapper` of `CartesianProduct_base`


---

Comment by git created at 2022-08-14 00:14:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-14 00:30:33

Replying to [comment:71 mkoeppe]:
> Replying to [comment:69 tscrim]:
> > IMO, what you are doing has a very strong code smell as it is breaking many rules of OOP.
> 
> Sure it is

I have a clean implementation now


---

Comment by git created at 2022-08-14 00:35:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-14 01:04:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-14 04:23:46

Some MRO problems in sage/rings/asymptotic


---

Comment by jhpalmieri created at 2022-08-15 22:01:50

Yes, I see those, too.


---

Comment by git created at 2022-08-17 00:56:11

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mkoeppe created at 2022-08-17 01:02:43

The MRO errors are gone now, but in the same files I get errors like the following.

```
      File "/Users/mkoeppe/s/sage/sage-rebasing/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/structure/unique_representation.py", line 569, in __classcall__
        instance = typecall(cls, *args, **options)
      File "sage/misc/classcall_metaclass.pyx", line 471, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:2380)
        return (<PyTypeObject*>type).tp_call(cls, args, kwds)
      File "/Users/mkoeppe/s/sage/sage-rebasing/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/rings/asymptotic/growth_group_cartesian.py", line 1444, in __init__
        super(UnivariateProduct, self).__init__(
      File "/Users/mkoeppe/s/sage/sage-rebasing/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/rings/asymptotic/growth_group_cartesian.py", line 311, in __init__
        CartesianProductPoset.__init__(self, sets, category, order, **kwds)
      File "/Users/mkoeppe/s/sage/sage-rebasing/local/var/lib/sage/venv-python3.9/lib/python3.9/site-packages/sage/combinat/posets/cartesian_product.py", line 114, in __init__
        super().__init__(sets, category, **kwargs)
    TypeError: __init__() missing 1 required positional argument: 'category'
```


I think what's happening there is that `super().__init__` is being used in a situation where the `__init__` methods do not have compatible signatures.


```
class GenericGrowthGroup(UniqueRepresentation, Parent, WithLocals):
    def __init__(self, base, category, var): ...
class CartesianProduct_base(WithPicklingByInitArgs, Parent):
    def __init__(self, sets, category, flatten=False): ...
class CartesianProductPoset(CartesianProduct_unique):
    def __init__(self, sets, category, order=None, **kwargs):
```



---

Comment by git created at 2022-08-17 01:25:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-17 01:26:55

Now what remains are lots of infinite recursions involving `_element_constructor_` in sage/rings/asymptotic
