# Issue 17426: clean sparse matrices

Issue created by migration from https://trac.sagemath.org/ticket/17663

Original creator: vdelecroix

Original creation time: 2015-01-22 23:15:14

CC:  gagern pbruin ncohen

Big cleaning (and speedup x1.5)


---

Comment by vdelecroix created at 2015-01-22 23:16:27

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2015-01-22 23:16:27

New commits:


---

Comment by gagern created at 2015-01-23 07:03:24

Interesting. Looks mostly good.

This is wrong, though:


```
for i from 0 <= i < self._nrows:
  for j from 0 <= j < self._ncols:
    if not x[k]:
      entries[(i,j)] = x[k]
    k += 1
```


It should be `if x[k]`: you want to copy the _non_-zero elements. I had some trouble testing this code path, though:


```
sage: R.<a,b>=QQ[]
sage: m1=matrix(2,2,[0,a,b,0],sparse=True); m1
[0 a]
[b 0]
sage: type(m1)(m1.parent(),[0,a,b,0],True,True)
[0 0]
[0 0]
```


I haven't yet figured out where the `m1` construction converts its argument, but perhaps we can deprecate or even immediately remove that code path dealing with a single flat list.

I also wonder whether we should have a custom cythonized type to be used as key, instead of the generic CPython tuple or arbitrary size and types. Might make things a lot faster and memory-efficient again.

As far as I can see, most other (non-generic) sparse matrix implementations use something other than a dict to represent its entries. Something like [Yale format](http://en.wikipedia.org/wiki/Sparse_matrix#Yale) as far as I can tell at a quick glance. Perhaps a really proper cleanup should go all the way to using that? I'm not sure. Benefits are better memory efficiency, but we'd get logarithmic lookup times as opposed to the almost constant lookup in a hash table. And modifications would become costly. So perhaps we should offer two alternatives, depending on whether memory is an issue or not? Just thinking out loud, I'm not asking for this to be implemented in the ticket at hand.

The whole class has poor docstring and doctest coverage. I know that when adding new code, it should come with doctests these days. I'm not sure whether your modifications are simply changing existing code and are therefore exempt from this rule. I'd certainly be more happy if you were to add docstrings with tests to all the methods you modified, taking care to test all relevant code paths. To catch things like the one above.


---

Comment by gagern created at 2015-01-23 07:05:14

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-01-23 07:56:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-01-23 08:00:23

Hello,

Replying to [comment:2 gagern]:
> Interesting. Looks mostly good.
> 
> This is wrong, though:
> 
> <...>
>

Right
 
> I haven't yet figured out where the `m1` construction converts its argument, but perhaps we can deprecate or even immediately remove that code path dealing with a single flat list.

Done

> I also wonder whether we should have a custom cythonized type to be used as key, instead of the generic CPython tuple or arbitrary size and types. Might make things a lot faster and memory-efficient again.

Nope. I think we sould get rid of Python there. Sparse graphs have a much better implementation (though not very much documented either). But you are right, having a customized Cython type for pair of Py_ssize_t would be indeed much faster. Let me have a try.

> As far as I can see, most other (non-generic) sparse matrix implementations <...>

Hash table is cool. But not in the way it is done currently. We should not use Python objects other than to wrap the ring elements.

An important question is whether you want to access quickly to the following data:

 - nonzero entries in a fixed row
 - nonzero entries in a fixed column

The best would be as you did: look at the literature and other softwares/libraries.

> The whole class has poor docstring and doctest coverage.

Right, I added some. But I will not go any further.

Vincent


---

Comment by jdemeyer created at 2015-01-23 11:17:44

Replying to [comment:5 vdelecroix]:
> I think we sould get rid of Python there. Sparse graphs have a much better implementation (though not very much documented either). But you are right, having a customized Cython type for pair of Py_ssize_t would be indeed much faster. Let me have a try.
It might be better to keep that for a follow-up ticket.


---

Comment by vdelecroix created at 2015-01-23 12:17:39

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-01-23 12:17:39

Replying to [comment:6 jdemeyer]:
> Replying to [comment:5 vdelecroix]:
> > I think we sould get rid of Python there. Sparse graphs have a much better implementation (though not very much documented either). But you are right, having a customized Cython type for pair of Py_ssize_t would be indeed much faster. Let me have a try.
> It might be better to keep that for a follow-up ticket.

Right. And thinking more, I am not so sure about the overhead as Python int (for -5 <= i < 128) do not need allocation.

Vincent


---

Comment by gagern created at 2015-01-23 18:44:14

Changing status from needs_review to needs_work.


---

Comment by gagern created at 2015-01-23 18:44:14


```
sage -t --long --warn-long 46.2 src/sage/matrix/matrix_space.py
**********************************************************************
File "src/sage/matrix/matrix_space.py", line 1649, in sage.matrix.matrix_space.test_trivial_matrices_inverse
Failed example:
    tinv(QQ['x,y'], sparse=True)
Exception raised:
    Traceback (most recent call last):
      File "local/lib/python2.7/site-packages/sage/doctest/forker.py", line 488, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "local/lib/python2.7/site-packages/sage/doctest/forker.py", line 850, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.matrix.matrix_space.test_trivial_matrices_inverse[17]>", line 1, in <module>
        tinv(QQ['x,y'], sparse=True)
      File "local/lib/python2.7/site-packages/sage/matrix/matrix_space.py", line 1658, in test_trivial_matrices_inverse
        assert(m00.inverse() == m00)
    AssertionError
**********************************************************************
1 item had failures:
   1 of  20 in sage.matrix.matrix_space.test_trivial_matrices_inverse
    [261 tests, 1 failure, 2.72 s]
```



---

Comment by jhpalmieri created at 2015-01-23 19:43:58

I'm curious about the statement "This datastructure is not very efficient." Instead of asking you to explain it here, I think it's reasonable to assume that other people will be curious about it, too, so it should be explained in the docstring where you've introduced it.


---

Comment by git created at 2015-01-23 21:33:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2015-01-23 21:38:27

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-01-23 21:38:27

Replying to [comment:8 gagern]:

Very strange. Actually, when you try to convert matrix from a ring to another you might end up to call the constructor of `MatrixGenericSparse` with arguments `entries=[]`. And so, the case of the empty list needs to be treated!! I added a long comment in the constructor and it might be appropriate to actually modify the code in `MatrixSpace.matrix`.

Replying to [comment:9 jhpalmieri]

True. I added two sentences in a `.. NOTE::`. Actually, I have no idea about the potential speed up.

Vincent


---

Comment by git created at 2015-01-23 21:41:23

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by gagern created at 2015-01-24 09:08:02

The nonzero doctest has me confused:


```
sage: bool(m)
False
sage: m.is_zero() # indirect doctest
True
```


Why is the first expected to be false? Shouldn't a zero matrix evaluate as zero? Isn't one invariant the fact that all entries in the dict must be non-zero?


---

Comment by vdelecroix created at 2015-01-24 09:17:33

Replying to [comment:13 gagern]:
> The nonzero doctest has me confused:
> 
> {{{
> sage: bool(m)
> False
> sage: m.is_zero() # indirect doctest
> True
> }}}
> Why is the first expected to be false?
> Shouldn't a zero matrix evaluate as zero?

It is like 0

```
sage: bool(0)
False
sage: 0.is_zero()
True
```


We have zero <-> False and non-zero <-> True

> Isn't one invariant the fact that all entries in the dict must be non-zero?

Yes, it is. So that the matrix is zero if and only if the dict is empty.

Vincent


---

Comment by gagern created at 2015-01-24 09:59:32

Sorry, had a knot in my thoughts. Read this before becoming fully awake, I guess. I'm running the full test suite again, then I'll have a (hopefully final) look at the code.


---

Comment by vdelecroix created at 2015-01-24 10:01:58

Replying to [comment:15 gagern]:
> Sorry, had a knot in my thoughts. Read this before becoming fully awake, I guess.

:-)


---

Comment by jdemeyer created at 2015-01-24 10:07:54

Replying to [comment:15 gagern]:
> Sorry, had a knot in my thoughts.
Did you look too much at #17030 by chance :-)


---

Comment by gagern created at 2015-01-24 11:03:29

Replying to [comment:17 jdemeyer]:
> Did you look too much at #17030 by chance :-)

:-D

That would be a very professional excuse, but I guess I was thinking more along the lines `bool(…)` vs. `x.__nonzero__()` (which should behave the same) instead of `bool(x)` vs. `x.is_zero()` as the doctest used them.

Some more comments from reading the latest commit.
* `if entries is None or not entries` could be shortened to `if not entries`.
* `_cmp_backward` might use `if i != j: return i - j` in the first case as well. Not sure whether that makes much of a difference.

One more thing, not related to that last commit. Contrary to other sparse matrix implementations, we don't do a range check for inputs. Of course, that might be considered a bug in its own right, but if you feel like it, you could address this here as well.


```
sage: m = matrix(Zmod(5)['x'],2,2,{(3,3):2}) # this APPEARS to work at first
sage: m.is_zero()
False
sage: m
<repr(<sage.matrix.matrix_generic_sparse.Matrix_generic_sparse at 0x7fc795dcbf50>) failed: IndexError: list assignment index out of range>
sage: matrix(Zmod(5),2,2,{(3,3):2}) # this reports the problem early on
...
IndexError: invalid entries list
```



---

Comment by vdelecroix created at 2015-01-24 11:10:22

Replying to [comment:18 gagern]:
> Some more comments from reading the latest commit.
> * `if entries is None or not entries` could be shortened to `if not entries`.

It depends on the school! "my_var is None" is a simple address lookup while "not my_var" implies a function call. So "my_var is None" is very fast compared to "not my_var". But I agree that is fighting for micro seconds that are negligible looking at the rest of the code...

> * `_cmp_backward` might use `if i != j: return i - j` in the first case as well. Not sure whether that makes much of a difference.

Actually this is what I tried. But if you do that, you end up with some warning claiming that the comparison routine returns something different from 0,1,-1!

> One more thing, not related to that last commit.

Indeed, this needs to be fixed. I thought that `MatrixSpace` would have taken care of that. I will add a commit.

Vincent


---

Comment by git created at 2015-01-24 11:33:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-01-24 11:34:58

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2015-01-24 11:35:35

Sorry, wrong doctests. I had to do a forced push.


---

Comment by gagern created at 2015-01-24 13:33:53

Is there any way to actually reach that `The input must be scalar or a dictionary` exception? Since the “entries is not a dict” case is already handled before, I think not.

The comment about the `coerce=False` case sounds like someone asking for a revival of #17658. So if anyone wonders just how bad this “really bad” could be, I'd say “very bad indeed”.


---

Comment by jdemeyer created at 2015-01-24 14:01:54

Please remove

```python
## def _sparse_dot_product(v, w):
##     """
##     INPUT:
##         v and w are dictionaries with integer keys.
##     """
##     x = set(v.keys()).intersection(set(w.keys()))
##     a = 0
##     for k in x:
##         a = a + v[k]*w[k]
##     return a
```



---

Comment by jdemeyer created at 2015-01-24 14:01:54

Changing status from needs_review to needs_work.


---

Comment by git created at 2015-01-24 14:14:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by gagern created at 2015-01-24 15:28:11

Replying to [comment:24 jdemeyer]:

Is there anything special about that one comment block? There are similar comments all over the file, although most come from [2076edf](http://git.sagemath.org/sage.git/commit/?id=2076edfc5e985d848980204f103a1157087350f1) while the one you wanted removed comes from [43baa1b](http://git.sagemath.org/sage.git/commit/?id=43baa1bbc23e4a0f84c37d72f411c1a04ad1fa72). Does that have anything to do with your choice, or is simply that this one comment appeared in the diff?


---

Comment by jdemeyer created at 2015-01-24 16:52:52

Replying to [comment:27 gagern]:
> Is there anything special about that one comment block?
It's because somebody complained in #17583 about this particular comment block.


---

Comment by vdelecroix created at 2015-01-24 20:07:33

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-01-25 22:40:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by gagern created at 2015-01-25 22:42:35

Replying to [comment:19 vdelecroix]:
> It depends on the school! "my_var is None" is a simple address lookup while "not my_var" implies a function call. So "my_var is None" is very fast compared to "not my_var".

Valid point, so I won't object to leave the code as it is. Might even adapt that style.

> > * `_cmp_backward` might use `if i != j: return i - j` in the first case as well. Not sure whether that makes much of a difference.
> 
> Actually this is what I tried. But if you do that, you end up with some warning claiming that the comparison routine returns something different from 0,1,-1!

Can't reproduce such a warning. Who is complaining when? Why no warning for the other pair component? I wonder whether one would want to put some bigger numbers in the test case, in order to make sure that steps with absolute value more than one are always involved in some comparison. But even then I don't see this warning you mention.

My question about the `The input must be scalar or a dictionary` exception being dead code (from comment:23) still stands. I just pushed a commit for that. If you have no objections to it, feel free to mark this as positive review, since I'm happy with your changes.


---

Comment by vdelecroix created at 2015-01-25 22:56:40

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2015-01-25 22:56:40

Replying to [comment:31 gagern]:
> Replying to [comment:19 vdelecroix]:
> > It depends on the school! "my_var is None" is a simple address lookup while "not my_var" implies a function call. So "my_var is None" is very fast compared to "not my_var".
> 
> Valid point, so I won't object to leave the code as it is. Might even adapt that style.

;-)

> > > * `_cmp_backward` might use `if i != j: return i - j` in the first case as well. Not sure whether that makes much of a difference.
> > 
> > Actually this is what I tried. But if you do that, you end up with some warning claiming that the comparison routine returns something different from 0,1,-1!
> 
> Can't reproduce such a warning. Who is complaining when? Why no warning for the other pair component? I wonder whether one would want to put some bigger numbers in the test case, in order to make sure that steps with absolute value more than one are always involved in some comparison. But even then I don't see this warning you mention.

At some point, I had trouble with this but I do not remember exactly. I just learn a funny way to do it returning 1,0 or -1 fast:

```
return (i > j) - (i < j)
```


> My question about the `The input must be scalar or a dictionary` exception being dead code (from comment:23) still stands. I just pushed a commit for that. If you have no objections to it, feel free to mark this as positive review, since I'm happy with your changes.

Thanks for that!

Vincent


---

Comment by vdelecroix created at 2015-01-25 23:02:44

And thanks for the review!

Vincent


---

Comment by vbraun created at 2015-01-29 13:26:10

Resolution: fixed
