# Issue 14708: UniqueRepresentation tutorial could use more love

Issue created by migration from https://trac.sagemath.org/ticket/14912

Original creator: darij

Original creation time: 2013-07-19 22:38:58

CC:  simonking tscrim

Keywords: documentation, structure

Sadly not my love, unless someone teaches me enough of the stuff that I understand it myself.

http://www.sagemath.org/doc/reference/misc/sage/misc/classcall_metaclass.html

One thing that should be added is some explanation of the difference between `__classcall__` and `__classcall_private__`.

Also there seems to be a typo:


```
The UniqueRepresentation and UniqueFactory classes provide two alternative implementations of this design pattern. Both implementations have their own merits. UniqueRepresentation is very easy to use: a class just needs to derive from it, or make sure some of its super classes does. Also, it groups together the class and the factory in a single gadget; in the example above, one would want to do:
```


I think it's UniqueFactory, not UniqueRepresentation, which is easy to use etc.


---

Comment by SimonKing created at 2013-07-19 23:03:31

Replying to [ticket:14912 darij]:
> I think it's UniqueFactory, not UniqueRepresentation, which is easy to use etc.

You couldn't be more mistaken, I think. In the wast majority of cases, if you have defined a class C,

```
class C(base1, base2):
    code
```

then you only need to change it into

```
class C(UniqueRepresentation, base1, base2):
    code
```

and have caching _and_ pickling for free. Setting up a `UniqueFactory` is a lot more work.


---

Comment by darij created at 2013-07-19 23:14:15

Something else is wrong then, because the example directly under the paragraph I quoted is about GF, which is a UniqueFactory.


---

Comment by SimonKing created at 2013-07-20 09:27:07

Replying to [comment:4 darij]:
> Something else is wrong then, because the example directly under the paragraph I quoted is about GF, which is a UniqueFactory.

OK, if this is the case, then indeed it is a bad example.

One question, though: What do you mean by `UniqueRepresentation` tutorial? Is there a separate tutorial, or is it just the pages for sage.structure.factory and sage.structure.unique_representation, respectively?


---

Comment by darij created at 2013-07-20 09:31:58

Oops, what I meant is really just the docstring for `UniqueRepresentation` in `sage/structure/unique_representation.py`.


---

Comment by SimonKing created at 2013-07-23 14:37:23

I think both `sage.structure.unique_representation` and `sage.structure.factory` need more care.

Certainly it is a severe fault that `GF(...)` appears as example of `UniqueRepresentation`.

And I think both parts of the documentation should give hints on when to use `UniqueRepresentation` and when to use `UniqueFactory`.

For example, a `UniqueFactory` can return different implementations of the same algebraic structure, depending on the input data. This would be impossible (or at least not so easily possible) with `UniqueRepresentation`. And you would not be able to use `UniqueRepresentation` with a cdef class---you can define your class in a pyx file, but it has to be `class Foo(UniqueRepresentation, ...)`, not `cdef class Foo(UniqueRepresentation, ...)`, simply since `UniqueRepresentation` uses meta-classes, which is not possible in a cdef class, if I am not mistaken (and of course, multiple inheritance does not work yet in Cython, and after all `UniqueRepresentation` is a python class.

These are reasons for using a factory.

On the other hand, using `UniqueRepresentation` would automatically provide your class with very fast hash and comparison methods implemented in Cython (`UniqueRepresentation` is a Python class, but also inherits from the Cython class `sage.misc.fast_methods.WithEqualityById`). If you use a factory instead, you'd need to take care of hash and comparison all by yourself---and this means: It is possible that a `UniqueFactory` returns objects that are _not_ unique parents!! And moreover, using `UniqueRepresentation` is very easy---in most cases, it is enough to take an existing class and add `UniqueRepresentation` as base.

So, these are reasons for using a unique representation.


---

Comment by SimonKing created at 2013-07-23 15:14:31

Replying to [comment:7 SimonKing]:
> Certainly it is a severe fault that `GF(...)` appears as example of `UniqueRepresentation`.

Or not? I now see that `GF(...)` appears in order to demonstrate the design pattern that is common to both unique representation and unique factory. And it is clearly stated that one would like to have something like

```
isinstance(GF(p), GF)
```

which is _not_ possible with a unique factory but is the case for `UniqueRepresentation`.


---

Comment by SimonKing created at 2013-07-23 15:25:59

I think it is a good idea to have GF mentioned _both_ in the documentation of unique representation and unique factory, since it explains one detail one can base one's choice on.

Namely, as an example of a behaviour one can not get with `UniqueRepresentation`:

```
sage: type(GF(5))
<class 'sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category'>
sage: type(GF(25,'x'))
<class 'sage.rings.finite_rings.finite_field_givaro.FiniteField_givaro_with_category'>
sage: type(GF(5^10,'x'))
<class 'sage.rings.finite_rings.finite_field_ext_pari.FiniteField_ext_pari_with_category'>
sage: type(GF(2^20,'x'))
<class 'sage.rings.finite_rings.finite_field_ntl_gf2e.FiniteField_ntl_gf2e_with_category'>
```



---

Comment by SimonKing created at 2013-07-25 14:18:40

Questions:

- Neither `sage.structure.factory` nor `sage.structure.unique_representation` have a meaningful documentation at module level. Would it make sense to give documentation at module level that helps for choosing among the two models of creating a unique parent behaviour? Or should this be only provided by `CachedRepresentation` and `UniqueRepresentation` resp. by `UniqueFactory`?
- You mentioned that you find the distinction between `__classcall__` and `__classcall_private__` unclear. There is an example clarifying the distinction, but it is hidden in the documentation of `_clear_cache_()`, which is an underscore method and is thus not visible in the reference manual. Do you think that the example from `_clear_cache_()` is clear? Then we could promote it (or a similar example) to a visible place.


---

Comment by darij created at 2013-07-27 01:50:01

I fear the doc of `_clear_cache_()` is beyound my comprehension... Is the difference just in the fact that a `__classcall_private__` method will not be inherited by subclasses while a `__classcall__` will be? (But I thought all methods would be inherited by subclasses?)


---

Comment by SimonKing created at 2013-07-27 08:27:53

Replying to [comment:11 darij]:
> I fear the doc of `_clear_cache_()` is beyound my comprehension... Is the difference just in the fact that a `__classcall_private__` method will not be inherited by subclasses while a `__classcall__` will be? (But I thought all methods would be inherited by subclasses?)

Your question really is about `sage.misc.classcall_metaclass.ClasscallMetaclass`, which is where methods such as `__classcall__`, `__classget__`, `__classcontains__` and `__classcall_private__` take effect.

Here, we look at `sage.misc.classcall_metaclass.ClasscallMetaclass.__call__`, which implements the creation of instances of a class. Of course, if a class C defines `__classcall_private__` and a class D inherits from C, then D also has a `__classcall_private__` method. However, you can find this method in `C.__dict__` but not in `D.__dict__`.

And the rule is: If an instance of a class (here: C or D) is created by calling `ClasscallMetaclass.__class__`, then
* it will be checked whether the class has a `__classcall_private__` in its own `__dict__`. If this is the case, then `__classcall_private__` will be called. Otherwise,
* it is checked whether the class has a `__classcall__` method (which is not necessarily in `__dict__`, as it could be inherited from a base class). If this is the case, then `__classcall__` will be called.

I just said "we look at `ClasscallMetaclass.__call__`". Well, in fact we look at `CLasscallMetaclass.__cinit__`, because this is where the choice between `__classcall__` and `__classcall_private__` is made.

What does all this mean for this ticket?

Question: Do you think it would be enough to state in the documentation of `CachedRepresentation` that it has the `ClasscallMetaclass` and that it provides a `__classcall__` implementing the cache, and that one can use `__classcall_private__` or `__classcall__` as explained in the docs of `ClasscallMetaclass` to overload the default way of caching?

Or I guess it would still be a good idea to have examples in place, without the need to read the `ClasscallMetaclass` docs...


---

Comment by SimonKing created at 2013-08-10 08:46:28

Changing status from new to needs_review.


---

Comment by SimonKing created at 2013-08-10 08:46:28

I have attached a patch. Do you like the new documentation better? What points would you suggest to improve further?

Note that I added documentation to both sage.structure.factory and sage.structure.unique_representation, also adding new tests.


---

Comment by SimonKing created at 2013-08-10 10:21:41

I have replaced my patch by an updated version. The new patch version addresses your complaint about "idempotent preprocessing", elaborating a bit more and adding an example that shows what goes wrong if the pre-processing is not idempotent.


---

Comment by SimonKing created at 2013-08-10 16:49:44

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2013-08-10 16:49:44

I am just re-reading my patch. I find several typos/wrong grammar. In addition, in one of my examples I have a non-idempotent pre-processing. I should change it. Also, by mistake, in one of my examples one finds the version number of my Sage installation---this should of course replaced by "...".


---

Comment by SimonKing created at 2013-08-10 19:06:02

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2013-08-10 19:06:02

I hope all problems are solved with the new patch version...


---

Comment by darij created at 2013-08-11 14:20:26

Just a couple typos fixed. Feel free to qfold into your patch. This is not a review, sorry (I don't have the competence to do it; I barely understood the UniqueRepresentation part and I know about nothing on Python's OOP).


---

Attachment

Thanks for the patch, which made several things clear to me (probably not enough to be able to decide whether to use factories or unique rep -- but at least a good idea how to). I fear somebody who actually knows some OOP will have to review it. The above attachment fixes a couple typos.


---

Comment by SimonKing created at 2013-08-12 13:23:07

Hi Darij,

Thank you for fixing the typos!

Replying to [comment:17 darij]:
> Thanks for the patch, which made several things clear to me (probably not enough to be able to decide whether to use factories or unique rep -- but at least a good idea how to).
> ... I don't have the competence to do it; I barely understood the `UniqueRepresentation` part and I know about nothing on Python's OOP


In a way, this means that you are fully qualified as a reviewer. This is about documentation, and thus if you think that some points are still not addressed then you should speak up! What information do you find missing? Is it
- the definition of cached/unique representation?
- the design pattern: Why should one want to have cached/unique representation?
- how to implement a cached/unique representation?
- Python background: What is a metaclass? What happens during instantiation of a class?
- how to avoid pitfalls?
- else?


---

Comment by darij created at 2013-08-12 13:35:02

One thing I'd be happy to know is what a staticmethod is -- but that's hardly a question for this patch.

And yes, some doc on metaclasses and the instantiation process (I'm confused about what goes in __new__, what in __init__ and what in __classcall__) would be great.

As for the "why" of cached/unique representation, for me it's pretty clear already, and I think the definition in your doc is very readable.

Thanks a lot for the patience!


---

Attachment

Combined patch, including Darij's fixes


---

Comment by SimonKing created at 2013-08-19 16:20:16

I have folded the two patches, and I have added a note on "static methods", including a link to the Python docs.

I did not elaborate on `__new__` versus `__init__` versus `__classcall__`, yet.

Apply trac14912-unique_doc.patch


---

Comment by SimonKing created at 2013-08-19 16:20:45

Replying to [comment:20 SimonKing]:
> I have folded the two patches, and I have added a note on "static methods", including a link to the Python docs.

... which was supposed to imply the question whether you find this helpful.


---

Comment by tscrim created at 2013-08-30 00:55:22

Hey Darij,

This is primarily a *ping* message asking Darij if he's happy with this ticket, but...

The ``@`staticmethod` is a python thing, which makes a method accessible via `ClassName.foo` and doesn't take a first argument of a type as opposed to ``@`classmethod`. If anything, this should belong with the `ClasscallMetaclass` documentation, but that's outside the scope of this ticket.

Best,

Travis


---

Comment by darij created at 2013-08-30 04:02:16

Sorry for letting this slip off my to-do list!

I'm pretty sure that I've understood the important points of the doc now except for some that concern pickling (I don't know how it works and frankly I didn't plan on learning that). I'd feel better if I knew what exactly `__classcall__` does and (as I said) how it is distinguished from `__new__` and `__init__` (and if it calls them, in which order), but that might as well be a different patch.

Is the comment I've added correct and is it relevant?

I've replaced "extension class" by "Cython extension-type class", since they seem to be called either "extension types" or "cdef classes" but never "extension classes".

I'd like more details on this:

```
104	    In addition, it is required that a unique factory instance is provided 
105	    with a name that allows to find its definition.
```

I assume this refers to the string parameter, e. g., in `F = MyFactory("__main__.F")`; but what kind of path should it contain if it is to be used somewhere in a .py file rather than in a doctest? Just `F = MyFactory("F")` ? What if it is defined inside a class?

Not sure about this:

```
And 
 	408	with a factory, it is possible to create the resulting instance by arguments 
 	409	that are different from the key used for caching.
```

Doesn't that also work with CachedRepresentation if one preprocesses by declaring `__classcall_private__`?

`@`Travis: thank you, too.


---

Attachment

almost a review


---

Comment by darij created at 2013-11-08 22:57:32

Thanks to Travis's insistence and also his help, I've more or less reviewed this one at last. The only part I wasn't able to understand is:

```
.. NOTE::

    For technical reasons, it is needed that ``__classcall__`` respectively
    ``__classcall_private__`` are "static methods", i.e., they are callable
    objects that do not bind to an instance or class. For example, a
    :class:`~sage.misc.cachefunc.cached_function` can be used here, because it
    is callable, but does not bind to an instance or class, because it has no
    ``__get__()`` method. A usual Python function, however, has a
    ``__get__()`` method and would thus under normal circumstances bind to an
    instance or class, and thus the instance or class would be passed to the
    function as the first argument. To prevent a callable object from being
    bound to the instance or class, one can prepend the ``@staticmethod``
    decorator to the definition; see :class:`staticmethod`.
```

Well, maybe it's just that I have no idea what `__get__` methods do.

for the *patchbot*:

apply trac14912-unique_doc.patch​ trac_14912-comments-dg.patch


---

Comment by SimonKing created at 2013-11-09 08:17:45

Replying to [comment:23 darij]:
> Sorry for letting this slip off my to-do list!

Same here...

> I'm pretty sure that I've understood the important points of the doc now except for some that concern pickling (I don't know how it works and frankly I didn't plan on learning that). I'd feel better if I knew what exactly `__classcall__` does and (as I said) how it is distinguished from `__new__` and `__init__` (and if it calls them, in which order), but that might as well be a different patch.

In a nutshell: If `C` is a class with `ClasscallMetaclass`, then `__classcall__` (or `__classcall_private__`) is what is executed when you do `C(*args, **kwds)`.

Your `__classcall__` can do _anything_. Really. It could return an instance of `C`, but it could also return something totally different.

Consequence: `__new__` or `__init__` are _only_ called if you did not forget to call them inside of your `__classcall__`. If you look at what `CachedRepresentation.__classcall__` does, you see that indeed `__new__` and `__init__` are called explicitly.

> I'd like more details on this:
> {{{
> 104	    In addition, it is required that a unique factory instance is provided 
> 105	    with a name that allows to find its definition.
> }}}
> I assume this refers to the string parameter, e. g., in `F = MyFactory("__main__.F")`;

Exactly.

> but what kind of path should it contain if it is to be used somewhere in a .py file rather than in a doctest? Just `F = MyFactory("F")` ?

It is exactly as it is stated: A name is needed that allows to find the factory's definition. Hence, if you put `F` into the global name space, then `F = MyFactory("F")` is fine. If `F` is in a module `sage.foo.bar`, then it is `F = MyFactory("sage.foo.bar.F")`.

> What if it is defined inside a class?

If the class is `sage.bar.foo.MyClass` and you want to use a factory for the attribute `F` of this class, then I guess it is `F = MyFactory("sage.bar.foo.MyClass.F"). Not tested, though.

> Not sure about this:
> {{{
> And 
>  	408	with a factory, it is possible to create the resulting instance by arguments 
>  	409	that are different from the key used for caching.
> }}}
> Doesn't that also work with CachedRepresentation if one preprocesses by declaring `__classcall_private__`?

Yes. This could be clarified.


---

Comment by SimonKing created at 2013-11-09 08:21:18

Hi Darij,

the review patch looks fine. Disclaimer: I did not test whether the documentation builds fine after the changes introduced by the review patch. IIRC, it _did_ build (and look) fine with my patch.

Replying to [comment:24 darij]:
> Thanks to Travis's insistence and also his help, I've more or less reviewed this one at last. The only part I wasn't able to understand is:
> {{{
> .. NOTE::
> 
>     For technical reasons, it is needed that ``__classcall__`` respectively
>     ``__classcall_private__`` are "static methods", i.e., they are callable
>     objects that do not bind to an instance or class. For example, a
>     :class:`~sage.misc.cachefunc.cached_function` can be used here, because it
>     is callable, but does not bind to an instance or class, because it has no
>     ``__get__()`` method. A usual Python function, however, has a
>     ``__get__()`` method and would thus under normal circumstances bind to an
>     instance or class, and thus the instance or class would be passed to the
>     function as the first argument. To prevent a callable object from being
>     bound to the instance or class, one can prepend the ```@`staticmethod``
>     decorator to the definition; see :class:`staticmethod`.
> }}}
> Well, maybe it's just that I have no idea what `__get__` methods do.

OK. Then one should add a pointer to the Python references. Travis, Do you have an idea what page to point to?


---

Comment by darij created at 2013-11-09 08:21:51

Thanks for these clarifications!

Replying to [comment:25 SimonKing]:
> Replying to [comment:23 darij]:
> > I'd like more details on this:
> > {{{
> > 104	    In addition, it is required that a unique factory instance is provided 
> > 105	    with a name that allows to find its definition.
> > }}}
> > I assume this refers to the string parameter, e. g., in `F = MyFactory("__main__.F")`;
> 
> Exactly.
> 
> > but what kind of path should it contain if it is to be used somewhere in a .py file rather than in a doctest? Just `F = MyFactory("F")` ?
> 
> It is exactly as it is stated: A name is needed that allows to find the factory's definition. Hence, if you put `F` into the global name space, then `F = MyFactory("F")` is fine. If `F` is in a module `sage.foo.bar`, then it is `F = MyFactory("sage.foo.bar.F")`.
> 
> > What if it is defined inside a class?
> 
> If the class is `sage.bar.foo.MyClass` and you want to use a factory for the attribute `F` of this class, then I guess it is `F = MyFactory("sage.bar.foo.MyClass.F"). Not tested, though.

Yeah, these things could very well be explained in the doc itself.

> > Not sure about this:
> > {{{
> > And 
> >  	408	with a factory, it is possible to create the resulting instance by arguments 
> >  	409	that are different from the key used for caching.
> > }}}
> > Doesn't that also work with CachedRepresentation if one preprocesses by declaring `__classcall_private__`?
> 
> Yes. This could be clarified.

Kind-of; on the other hand, the preprocessing probably needs to be idempotent for pickling to work well, so we have a serious restriction...


---

Comment by tscrim created at 2013-11-09 23:49:40

Replying to [comment:26 SimonKing]:
> > Well, maybe it's just that I have no idea what `__get__` methods do.
> 
> OK. Then one should add a pointer to the Python references. Travis, Do you have an idea what page to point to?

Hey Simon,

My thought would be this: http://docs.python.org/2/howto/descriptor.html (I showed this to Darij the other day).


---

Attachment


---

Comment by tscrim created at 2013-11-23 07:20:15

I'm prepared to set this to positive review (barring my tweaks being review), but I'd like to know what else is desired to be added and where (if anything).

For patchbot;

Apply: trac14912-unique_doc.patch​, trac_14912-comments-dg.patch​, trac_14912-link_tweaks-ts.patch​


---

Comment by darij created at 2013-11-26 05:39:32

Oops, I've just edited Travis's patch instead of qnewing my own. So glad I soon won't have the hg workflow anymore to trip over...

Anyway, here is my "review patch". It is not so much as a review but a more informative documentation of what exactly to do with `UniqueFactory`. Now, "more informative" does not necessarily mean "correct", so I'd much prefer someone more experienced than me to look this through (particularly, but not only, checking my interpretation of `other_keys`).

I still don't grok the note about the `__classcall__` method being static in the unique representation doc, but I didn't really have the time to RTFM about descriptors. If the note is clear to you, Travis, just say so and it will plug this hole in my review.

for the *patchbot*:

apply trac14912-unique_doc.patch​ trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch


---

Comment by chapoton created at 2013-11-26 09:01:27

beware of unvisible characters ! 

apply trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch


---

Comment by SimonKing created at 2013-11-26 09:35:32

Replying to [comment:31 chapoton]:
> beware of unvisible characters ! 

Indeed. The third patch introduces some blank space.

```
Notice that the objects created by the factory inherit neither from 
the factory class, nor from the factory instance (which is not even a 
class). In fact, they don't even know about the factory that created 
them! 
```

Apart from the blank space after the "!" (AFAIK, there is no blank space _before_ "!", ":" and ";", in contrast to French), I am not happy with the statement that the instances don't even know about the factory that created them:

```
sage: F = GF(5)
sage: F._factory_data
(<class 'sage.rings.finite_rings.constructor.FiniteFieldFactory'>,
 (5, 13, 'beta3'),
 (5, None, None, 'modn', '{}', 5, 1, True),
 {})
sage: _[0] is GF
True
```

This actually is how pickling is implemented (namely: By keeping a reference to the creating factory, plus the arguments used to call the factory).


---

Comment by jdemeyer created at 2013-11-26 16:27:18

The docbuild gives warnings:

```
dochtml.log:[structure] /scratch/release/merger/sage-5.13.beta5/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:docstring of sage.structure.unique_representation:127: WARNING: Block quote ends without a blank line; unexpected unindent.
dochtml.log:[structure] /scratch/release/merger/sage-5.13.beta5/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:docstring of sage.structure.unique_representation:129: ERROR: Unexpected indentation.
```



---

Comment by jdemeyer created at 2013-11-26 16:27:18

Changing status from needs_review to needs_work.


---

Comment by darij created at 2013-11-26 18:25:22

Changing status from needs_work to needs_review.


---

Comment by darij created at 2013-11-26 18:25:22

Fixed false claim about factory-created objects being oblivious of their making (thanks Simon!). Couldn't find the blank space after "!" claimed by Simon, but removed some other useless whitespaces. HOPEFULLY fixed Jeroen's docbuild warnings. Made some mini-fixes to unique_representation, including changing "argument" to "arguments" in the `__reduce__` docstring.

Thanks Frederic! (I'd be happier if I new where those symbols are coming from in the first place. Copypasting the names of the attachments from html maybe?)

for the *patchbot*:

apply trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch


---

Attachment

includes Travis' link tweaks. proofread by Travis


---

Comment by tscrim created at 2013-11-29 23:57:40

Everything looks good to me, so I'm going to set this to positive review. However feel free to object.

For patchbot:

Apply: trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch


---

Comment by tscrim created at 2013-11-29 23:58:15

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2013-11-29 23:58:50

Thank you Simon and Darij for your work on this!


---

Comment by jdemeyer created at 2013-12-02 09:48:58


```
sage -t devel/sage/sage/structure/unique_representation.py
**********************************************************************
File "devel/sage/sage/structure/unique_representation.py", line 455, in sage.structure.unique_representation
Failed example:
    type(Kp)
Expected:
    <class 'sage.rings.finite_rings.finite_field_ext_pari.FiniteField_ext_pari_with_category'>
Got:
    <class 'sage.rings.finite_rings.finite_field_pari_ffelt.FiniteField_pari_ffelt_with_category'>
**********************************************************************
File "devel/sage/sage/structure/unique_representation.py", line 814, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    n == id(SymmetricGroup(17))
Expected:
    False
Got:
    True
**********************************************************************
```



---

Comment by jdemeyer created at 2013-12-02 09:48:58

Changing status from positive_review to needs_work.


---

Comment by jdemeyer created at 2013-12-02 09:51:44

The first "error" is due to #14888.


---

Comment by jdemeyer created at 2013-12-02 10:36:39

The second error happens even with a clean version of Sage 5.12.


---

Comment by SimonKing created at 2013-12-02 14:13:15

Hm. In a freshly build sage-5.13.b4, I get

```
        sage: n = id(SymmetricGroup(17))
        sage: import gc
        sage: _ = gc.collect()
        sage: n == id(SymmetricGroup(17))
        False
```

but I get "True" if the same is done as a doc test.

So, rather than relying on the id, I will create a test that demonstrates that this group becomes garbage collected.


---

Comment by SimonKing created at 2013-12-02 14:14:46

For example:

```
sage: S = SymmetricGroup(17)
sage: n = id(S)
sage: import gc
sage: _ = gc.collect()
sage: n in [id(x) for x in gc.get_objects()]
True
sage: del S
sage: _ = gc.collect()
sage: n in [id(x) for x in gc.get_objects()]
False
```

That's a better test.


---

Comment by SimonKing created at 2013-12-02 14:16:59

WTF??

Again, if I run the same thing as doctest, then the answer in the last line is "True", not "False". Hence, the symmetric group gets collected in an interactive session, but not in a test!


---

Comment by SimonKing created at 2013-12-02 14:22:32

I am still shocked that garbage collection works differently in doc tests than in an interactive session, but anyway: Here is an example that works both interactively in in a doc test.

```
        sage: class SomeClass(UniqueRepresentation):
        ....:     def __init__(self, i):
        ....:         print "creating new instance for argument %s"%i
        ....:         self.i = i
        ....:     def __del__(self):
        ....:         print "deleting instance for argument %s"%self.i
        ....:         
        sage: O = SomeClass(1)
        creating new instance for argument 1
        sage: O is SomeClass(1)
        True
        sage: O is SomeClass(2)
        creating new instance for argument 2
        deleting instance for argument 2
        False
        sage: del O
        deleting instance for argument 1
        sage: O = SomeClass(1)
        creating new instance for argument 1
```



---

Attachment


---

Comment by SimonKing created at 2013-12-02 14:28:49

Fixed! Please review!

Apply trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch trac_14912-doc-fixes-sk.patch


---

Comment by SimonKing created at 2013-12-02 14:28:49

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2013-12-02 14:51:47

Replying to [comment:34 darij]:
> Couldn't find the blank space after "!" claimed by Simon,

Sorry, my mistake. In order to find trailing whitespace, I went to the html page of the patch and marked some lines, thus highlighting all characters. And it did look like a highlighted blank spaces after the exclamation mark. But when I looked at the patch itself, it was fine.

Best regards,
Simon


---

Comment by jdemeyer created at 2013-12-02 22:03:24

I will not review the patch, but at least doctests pass now.


---

Comment by darij created at 2013-12-03 01:56:05

I like how your new doctest showcases automatic garbage collection, but what do you think about keeping the old doctest in with a `# not tested` and a comment on how it usually works in the console and demonstrates the non-invariance of the id?

(In my very limited understanding, the doctest environment tries hard at replacing all kind of randomness by determinism, so I'm not surprised that two `id`s end up being the same even if they are created differently.)


---

Comment by jdemeyer created at 2013-12-03 07:51:29

Replying to [comment:48 darij]:
> (In my very limited understanding, the doctest environment tries hard at replacing all kind of randomness by determinism, so I'm not surprised that two `id`s end up being the same even if they are created differently.)
Nobody has any control on the memory locations of allocated objects. The doctests do use `set_random_seed()`, but I very much doubt that this has any influence on `id`.


---

Comment by SimonKing created at 2013-12-03 11:29:50

I would recommend against using my old suggestion --- "id" is an implementation detail and depends on randomness, beyond anything that is controllable by random seeds. So, even when it is marked as `# not tested`, I think it would not be very helpful to show a test against "id".


---

Comment by jdemeyer created at 2013-12-03 12:18:32

The unpredictability of `id` boils down to the unpredictability of `malloc()`: if one does

```
char *a = malloc(s);
free(a);
char *b = malloc(s);
free(b);
```

it is impossible to say whether `a` and `b` will be equal.


---

Comment by jdemeyer created at 2013-12-06 10:46:17

Any chance for a final review? It would be nice to get this into Sage 5.13.


---

Comment by tscrim created at 2013-12-09 01:15:51

Hey Simon,

With `sage-5.13.beta2`, I get:

```
sage -t unique_representation.py
**********************************************************************
File "unique_representation.py", line 822, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    O is SomeClass(2)
Expected:
    creating new instance for argument 2
    deleting instance for argument 2
    False
Got:
    creating new instance for argument 2
    False
**********************************************************************
File "unique_representation.py", line 826, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    del O
Expected:
    deleting instance for argument 1
Got:
    <BLANKLINE>
**********************************************************************
File "unique_representation.py", line 828, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    O = SomeClass(1)
Expected:
    creating new instance for argument 1
Got:
    <BLANKLINE>
**********************************************************************
1 item had failures:
   3 of  89 in sage.structure.unique_representation.CachedRepresentation
    [229 tests, 3 failures, 4.18 s]
----------------------------------------------------------------------
sage -t unique_representation.py  # 3 doctests failed
----------------------------------------------------------------------
```

with the following patches applied:

```
trac_15327-qfold-dg.patch
trac_15327-fixes-dg.patch
trac_15305-coercion_tensor_products-ts.patch
trac13394-weak_value_dictionary.patch
trac_15311-hall_algebras-ts.patch
trac_10963-more_functorial_constructions-nt.patch
trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch
trac_10963_doctest_correction-fc.patch
trac_14102-nonsymmetric-macdonald.patch
trac9107_nesting_nested_classes.patch
trac_9107_fix_cross_reference.patch
trac_14685_bug_aorder_lazypowerseries.patch
trac_15150-ncsym-ts.patch
trac_15174-qfold1.patch
trac_15174-final-touches-dg.patch
trac_15174-review-ts.patch
trac14912-unique_doc.patch
trac_14912-comments-dg.patch
trac_14912-more-ts-dg.patch
trac_14912-doc-fixes-sk.patch
```

I don't think there's anything from the other patches which would cause this to fail... Can someone check this on a later version of Sage?


---

Comment by darij created at 2013-12-09 01:43:59

With the git version of beta5, I get:

```
sage -t src/sage/structure/unique_representation.py
deleting instance for argument 1
    [229 tests, 0.45 s]
```

Weird but supposedly OK?

Could this be the garbage collector triggering `__del__` *after* the doctest? If so, one could easily fix this by explicitly trashing all instances in the doctest.


---

Comment by jdemeyer created at 2013-12-09 09:56:07

Doctests also pass for me.


---

Comment by SimonKing created at 2013-12-09 10:15:55

Replying to [comment:54 darij]:
> Could this be the garbage collector triggering `__del__` *after* the doctest? If so, one could easily fix this by explicitly trashing all instances in the doctest.

Isn't deletion of this instance supposed to be _immediate_? After all, Python's cyclic garbage is not involved in this example, since the to-be-deleted objects are not part of any reference cycle.

Weird. Any idea about (1) the reason and (2) how to fix it?


---

Comment by darij created at 2013-12-09 15:43:51

I'm talking about the instance which is *not explicitly* deleted in the doctest, but just left around to dangle.


---

Comment by SimonKing created at 2013-12-09 16:01:57

Replying to [comment:57 darij]:
> I'm talking about the instance which is *not explicitly* deleted in the doctest, but just left around to dangle.

OK, but I am also talking about the failure reported by travis:

```
File "unique_representation.py", line 826, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    del O
Expected:
    deleting instance for argument 1
Got:
    <BLANKLINE>
**********************************************************************
File "unique_representation.py", line 828, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    O = SomeClass(1)
Expected:
    creating new instance for argument 1
Got:
    <BLANKLINE>
```

Here, the instance _is_ explicitly deleted, but nonetheless it stays in cache. No idea why.


---

Comment by tscrim created at 2013-12-09 17:01:41

Hey Darij,

Could you push your branch to trac so I can look at it? I can't seem to import Hg patches currently. This way we can see if it's something that's been taken care of by a beta version bump.

Thanks,

Travis


---

Comment by darij created at 2013-12-10 03:29:18

Hi Travis,

it's on branch `u/darij/do-not-fork/14912` now. I don't want to put this into public namespace so as not to confuse this ticket; I am not sure if it's a good idea right now to turn #14912 into a git patch.

Greets,\\
Darij


---

Comment by tscrim created at 2013-12-10 16:50:49

Hmmm... with the branch, I get the same output. I'm thinking we shouldn't have a print statement displaying like that.

Jeroen, do you also get the print statement when running doctests on the file? I'm building `5.13.beta5` now and can test tonight.


---

Comment by jdemeyer created at 2013-12-10 17:25:04

I get

```
Doctesting 1 file.
sage -t --long devel/sage/sage/structure/unique_representation.py
deleting instance for argument 1
    [229 tests, 6.90 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 7.1 seconds
    cpu time: 1.1 seconds
    cumulative wall time: 6.9 seconds
```



---

Attachment

Okay, I fixed the leaking print statement by explicitly deleting the object in the doctest. It's a slight hack fix, but since this is only for testing/illustrative purposed, I think its okay.

For patchbot:

Apply: trac14912-unique_doc.patch, trac_14912-comments-dg.patch, trac_14912-more-ts-dg.patch, trac_14912-doc-fixes-sk.patch, trac_14912-fix_leaking_print-ts.patch​


---

Comment by SimonKing created at 2013-12-10 21:52:21

If the patchbot says that it is fine, then it is fine with me as well. But I am not a reviewer...


---

Comment by tscrim created at 2013-12-11 19:22:40

The patchbot has not come around, but can someone just double-check that with my latest patch, the statement isn't printed anymore after running the doctest? With that I think it's positive review (at least for me). Thanks.


---

Comment by tscrim created at 2013-12-16 16:50:29

_ping_ It's a simple double-check to make sure the print statement isn't shown when running `sage -t` on the file. That's all I've changed.


---

Comment by darij created at 2013-12-17 04:52:55

The patches apply fine on 6.0rc0, and the print no longer leaks.

But I've got another question on this paragraph:

```
.. NOTE::

    For technical reasons, it is needed that ``__classcall__`` respectively
    ``__classcall_private__`` are "static methods", i.e., they are callable
    objects that do not bind to an instance or class. For example, a
    :class:`~sage.misc.cachefunc.cached_function` can be used here, because it
    is callable, but does not bind to an instance or class, because it has no
    ``__get__()`` method. A usual Python function, however, has a
    ``__get__()`` method and would thus under normal circumstances bind to an
    instance or class, and thus the instance or class would be passed to the
    function as the first argument. To prevent a callable object from being
    bound to the instance or class, one can prepend the ``@staticmethod``
    decorator to the definition; see :class:`staticmethod`.

    For more on Python's ``__get__()`` method, see:
    http://docs.python.org/2/howto/descriptor.html
```

In `src/sage/groups/perm_gps.py`, I see:

```
    @weak_cached_function
    def __classcall__(cls, *args, **kwds):
        """
        This makes sure that domain is a FiniteEnumeratedSet before it gets passed
        on to the __init__ method.

        EXAMPLES::

            sage: SymmetricGroup(['a','b']).domain() #indirect doctest
            {'a', 'b'}
        """
        domain = kwds.pop('domain', None)
        if domain is not None:
            if domain not in FiniteEnumeratedSets():
                domain = FiniteEnumeratedSet(domain)
            kwds['domain'] = domain
        return super(PermutationGroup_unique, cls).__classcall__(cls, *args, **kwds)
```

This is NOT decorated with ``@`staticmethod`. Isn't this contradictory to the NOTE above?


---

Comment by tscrim created at 2013-12-17 06:26:22

There's this line in `unique_representation.py`:

```
    @weak_cached_function # automatically a staticmethod
    def __classcall__(cls, *args, **options):
```

so apparently it's not a contradiction. Although I don't specifically know why it's used (in `src/sage/groups/perm_gps/permgroup_named.py`) instead of a ``@`staticmethod`.


---

Comment by darij created at 2013-12-17 06:27:19

Changing status from needs_review to positive_review.


---

Comment by darij created at 2013-12-17 06:27:19

Ah, that clears things up; thanks a lot.

Positive_review!!!1111


---

Comment by SimonKing created at 2013-12-17 10:26:44

Replying to [comment:68 tscrim]:
> There's this line in `unique_representation.py`:
> {{{
>     `@`weak_cached_function # automatically a staticmethod
>     def __classcall__(cls, *args, **options):
> }}}
> so apparently it's not a contradiction. Although I don't specifically know why it's used (in `src/sage/groups/perm_gps/permgroup_named.py`) instead of a ``@`staticmethod`.

There is some argument pre-processing: `kwds['domain']` might change. And this _changed_ argument is used as a cache key when calling `super(PermutationGroup_unique, cls).__classcall__(cls, *args, **kwds)`. Apparently the author of this `__classcall__` found it desirable that the instance is pulled from the cache when the original value of `kwds['domain']` is provided next time, _without_ losing time by the preprocessing.


---

Comment by tscrim created at 2013-12-17 20:43:26

Replying to [comment:70 SimonKing]:
> There is some argument pre-processing: `kwds['domain']` might change. And this _changed_ argument is used as a cache key when calling `super(PermutationGroup_unique, cls).__classcall__(cls, *args, **kwds)`. Apparently the author of this `__classcall__` found it desirable that the instance is pulled from the cache when the original value of `kwds['domain']` is provided next time, _without_ losing time by the preprocessing.

Ah I see. Thanks for clarifying and for your work on this.

Thanks to Darij and Jeroen for help in reviewing.


---

Comment by vbraun created at 2013-12-18 14:55:39

Resolution: fixed
