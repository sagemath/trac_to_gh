# Issue 14986: Let the `TestSuite` test that the construction of a parent returns the parent

Issue created by migration from https://trac.sagemath.org/ticket/15223

Original creator: SimonKing

Original creation time: 2013-09-24 13:47:16

CC:  novoselt nthiery combinat tscrim chapoton @mwageringel klee dkrenn

Andrey told me about the following problem. When he implemented toric lattices, he inherited a `.construction()` method from general lattices. Consequence: If he tried to add elements of two different toric lattices, then Sage applied a pushout construction and added the two elements after pushing them to `ZZ^2`, which was not what he wanted.

His solution was, I think, the correct one: He overloaded the `.construction()` method, so that it now returns `None`.

Suggestion: Introduce a test of the `TestSuite` of a parent P, that will complain if P.construction() returns a pair `F, O` such that `F(O)!=P`.

I think this test should be put into `sage.structure.parent.Parent`, because this is where `.construction()` is defined in the first place.


---

Comment by SimonKing created at 2013-09-24 16:54:56

I did not run the full test suite yet, but I already detected several bugs in `.construction()`. So, introducing this test really is a good idea.

Until now, I found:

1. Boolean polynomial rings:
   {{{
sage: P.<x0, x1, x2, x3> = BooleanPolynomialRing(4,order='degrevlex(2),degrevlex(2)')
sage: P.construction()
(MPoly[x0,x1,x2,x3], Finite Field of size 2)
sage: F, O = P.construction()
sage: F(O)
Multivariate Polynomial Ring in x0, x1, x2, x3 over Finite Field of size 2
sage: P
Boolean PolynomialRing in x0, x1, x2, x3
   }}}
   Suggested solution: A boolean polynomial ring is, after all, a quotient of a polynomial ring. So, it should be constructed as such, but the `QuotientFunctor` should be provided with an additional attribute making it notice that a boolean polynomial ring shall be returned.

2. Integer mod rings that are initialised in a non-default category:
   {{{
sage: P = IntegerModRing(19, category = Fields())
sage: F,O = P.construction()
sage: F(O)
Ring of integers modulo 19
sage: P
Ring of integers modulo 19
sage: F(O) == P
False
   }}}
   Why is this? Well, providing a different category changes the class of P (this is how the category framework works), and the `__cmp__` method of integer mod rings checks for the class. And the construction functor `F` is not aware of the category of `P`.

   Suggested solutions: Change `__cmp__` such that `F(O)` evaluates equal to `P`, even though `F(O)` is not in the category of fields, or alternatively make the construction functor aware of the category, so that `F(O)` actually _is_ in the category of fields.


---

Comment by SimonKing created at 2013-09-24 18:32:03

And I am to blame for a third problem, that is actually fairly similar to the second problem mentioned above. It is in my thematic tutorial on categories and coercion.

- I create a parent class inheriting from `UniqueRepresentation`.
- The parent class has a construction functor that keeps track of the "important" arguments needed to reconstruct the parent.
- I create one instance P of the parent class using an additional "unimportant" argument, namely a category.

Consequence: When trying to reconstruct P using the construction functor, the "unimportant" argument is missing, and hence `UniqueRepresentation` believes that a new instance needs to be created. After all, for `UniqueRepresentation`, _all_ arguments are important parts of the cache key.

I have to think how to solve this.


---

Comment by SimonKing created at 2013-09-24 21:24:48

Is it really needed that `BooleanPolynomialRing` has a `.construction()`? Granted, one could describe it as the quotient of a polynomial ring over GF(2). However, you could actually not take an arbitrary ring R and create a boolean polynomial ring over R---the base ring will always be GF(2).

Anyway, using the construction functor for multivariate polynomial rings is plain wrong. We have two options:

1. Let the construction be None
2. Create a new construction functor for boolean polynomial rings, either similar to the multivariate polynomial ring functor, or similar to the quotient functor.

If we go for None, then we would have problems to do fancy constructions starting with a boolean polynomial ring: There would be no pushout constructions. I wonder if we _need_ pushout constructions.

If we go for a new construction functor, I'd suggest to modify quotient functors. After all, it is a quotient in a particular implementation.

And looking at the second problem, it seems to be a general problem with quotient functors: Sometimes we want to add more information on a quotient, such as "the quotient shall belong to the category of fields" or, "the quotient shall be implemented as a boolean polynomial ring". So, we should invent a general scheme to load the quotient functor with this additional information.


---

Comment by SimonKing created at 2013-09-24 21:26:49

By the way, the branch that I uploaded fixes all doctests, except for the three issues described in the previous posts (boolean polynomial rings, quotients that are pushed into a sub-category of the default, and the stuff that I wrote in the thematic tutorial).


---

Comment by SimonKing created at 2013-09-24 21:46:59

The quotient functors (`sage.categories.pushout.QuotientFunctor`) eventually call the `.quo()` method when they are called. They actually do make a special case for fields that are constructed as a quotient.

I think it would be possible to store further arguments in an attribute, say, `_further_arguments`, which should be a dictionary, and then do

```
   Q = R.quo(I, names=self.names, **self._further_arguments)
```

Then, one should also make the `.quo()` method accept these additional arguments.


---

Comment by git created at 2013-09-24 22:10:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2013-09-24 22:13:53

In the current commit, I fix the example in the thematic tutorial by making the construction functor aware of the additional arguments that were originally used to construct the parent.

It works, and I think a similar idea would work for quotient functors.


---

Comment by SimonKing created at 2013-09-25 16:37:43

I just added Nicolas to this ticket, since it relates not only with coercion (this is the component of this ticket) but also with categories.

In a nutshell: If P is a parent, then `P.construction()` should return None, or a pair F,O, where F is a construction functor and O is some object.

The contract is that `F(O)==P`. But nobody has checked this contract so far. The original aim of this ticket is to introduce a test.

While we are at it, I thought one could improve `QuotientFunctor`. First of all, it _must_ allow to pass additional arguments to the quotient being constructed. For example, the construction functor for `IntegerModRing(19, category=Fields())` must know that the category is specialised. Similarly, the construction functor for `BooleanPolynomialRing(...)` must know that the result is not just a quotient of a polynomial ring, but has a special implementation.

And something else that I want to improve with the `QuotientFunctor`: Currently, it is a functor from Rings() to Rings(). But why?? Perhaps, at some point, we want to apply the `QuotientFunctor` in the context of groups!

Hence, I think it would make sense to be more precise when choosing the domain and codomain of the functor.

Today, I experimented with this idea: If Q is a quotient, and `F,O=Q.construction()`, then the quotient functor F should go from `O.category()` to `Q.category()`.

But when running the tests, it turns out that this is too narrow: Sometimes, we want to apply the quotient functor F to a ring over a _different_ base ring.

This makes me think of the following: Would it make sense to introduce a method of categories `C.without_parameters()`, returning the join of all super-categories of C that are not instances of `CategoryWithParameters`?

For example, for `C = Category.join([EnumeratedSets(),Algebras(QQ)])`, `C.without_parameters()` would return `Join of Category of rings and Category of enumerated sets`.

Nicolas, do you think it would hurt to introduce such method here?


---

Comment by nbruin created at 2013-09-25 18:25:06

Replying to [comment:10 SimonKing]:

> While we are at it, I thought one could improve `QuotientFunctor`. First of all, it _must_ allow to pass additional arguments to the quotient being constructed. For example, the construction functor for `IntegerModRing(19, category=Fields())` must know that the category is specialised.

Isn't that going to be a problem?

```
sage: A=IntegerModRing(19, category=Fields())
sage: B=IntegerModRing(19)
sage: B in Fields()
True
```

After this isn't the category of `B` refined to fields? And doesn't that then mean that A and B are the same, and hence should be identical? But if UniqueRepresentation takes the category argument into account, they won't be identical.


---

Comment by nthiery created at 2013-09-25 19:15:59

Replying to [comment:10 SimonKing]:
> I just added Nicolas to this ticket, since it relates not only with coercion (this is the component of this ticket) but also with categories.
> 
> In a nutshell: If P is a parent, then `P.construction()` should return None, or a pair F,O, where F is a construction functor and O is some object.
> 
> The contract is that `F(O)==P`. But nobody has checked this contract so far. The original aim of this ticket is to introduce a test.

This sounds like a good idea indeed! I would tend to put the test in
Sets (in the general trend that there is already too much stuff in
Parent; and maybe construction should be moved there, so as to make it
easier to overload it, e.g. in some categories).

It would make sense as well for the test to accept the case where
`construction` is an undefined abstract method. But maybe we don't
have a use case for now.

> While we are at it, I thought one could improve `QuotientFunctor`. First of all, it _must_ allow to pass additional arguments to the quotient being constructed. For example, the construction functor for `IntegerModRing(19, category=Fields())` must know that the category is specialised. Similarly, the construction functor for `BooleanPolynomialRing(...)` must know that the result is not just a quotient of a polynomial ring, but has a special implementation.
> 
> And something else that I want to improve with the `QuotientFunctor`: Currently, it is a functor from Rings() to Rings(). But why?? Perhaps, at some point, we want to apply the `QuotientFunctor` in the context of groups!
> 
> Hence, I think it would make sense to be more precise when choosing the domain and codomain of the functor.
> 
> Today, I experimented with this idea: If Q is a quotient, and `F,O=Q.construction()`, then the quotient functor F should go from `O.category()` to `Q.category()`.
> 
> But when running the tests, it turns out that this is too narrow: Sometimes, we want to apply the quotient functor F to a ring over a _different_ base ring.

This does not seem directly related to this ticket. Could this easily
be split off into a separate ticket?

> This makes me think of the following: Would it make sense to introduce a method of categories `C.without_parameters()`, returning the join of all super-categories of C that are not instances of `CategoryWithParameters`?
> 
> For example, for `C = Category.join([EnumeratedSets(),Algebras(QQ)])`, `C.without_parameters()` would return `Join of Category of rings and Category of enumerated sets`.
> 
> Nicolas, do you think it would hurt to introduce such method here?

This seems like a sensible method; so if you have a use for it, go
ahead.

Cheers,
                             Nicolas


---

Comment by SimonKing created at 2013-09-25 20:23:52

Replying to [comment:11 nbruin]:
> Isn't that going to be a problem?
> {{{
> sage: A=IntegerModRing(19, category=Fields())
> sage: B=IntegerModRing(19)
> sage: B in Fields()
> True
> }}}
> After this isn't the category of `B` refined to fields?

It is:

```
sage: A = IntegerModRing(19)
sage: B = IntegerModRing(19,category=Fields())
sage: A==B
False
sage: issubclass(type(A), Fields().parent_class)
False
sage: A in Fields()
True
sage: issubclass(type(A), Fields().parent_class)
True
```


> And doesn't that then mean that A and B are the same,

No, it doesn't (to my surprise, I actually thought they _should_ be recognised as equal now):

```
sage: A==B
False
sage: type(A)==type(B)
False
sage: A.category() == B.category()
False
sage: A.category()
Join of Category of fields and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets
sage: B.category()
Join of Category of fields and Category of subquotients of monoids and Category of quotients of semigroups
```


> and hence should be identical? But if UniqueRepresentation takes the category argument into account, they won't be identical.

No, it is not UniqueRepresentation:

```
sage: isinstance(A,UniqueRepresentation)
False
```



---

Comment by SimonKing created at 2013-09-25 20:37:23

Replying to [comment:12 nthiery]:
> This sounds like a good idea indeed! I would tend to put the test in
> Sets (in the general trend that there is already too much stuff in
> Parent; and maybe construction should be moved there, so as to make it
> easier to overload it, e.g. in some categories).

I am not so sure about this. `.construction()` is one of the places where mathematics and implementation meet: On the one hand, `.construction()` returns a functor (or at least something that pretends to be a functor), which is a mathematical notion. On the other hand, the construction functors are quite clearly _also_ responsible for choosing implementations. For example, the fact that the following pushout uses _dense_ power series rings is entirely due to construction functors:

```
sage: Ps.<x> = PowerSeriesRing(QQ, sparse=True)
sage: Pd.<x> = PowerSeriesRing(ZZ, sparse=False)
sage: Pd['y'].has_coerce_map_from(Ps['y'])
False
sage: pushout(Ps['y'],Pd['y'])
Univariate Polynomial Ring in y over Power Series Ring in x over Rational Field
sage: pushout(Ps['y'],Pd['y']) == Ps['y']
False
```


But if it is (partially) about implementation, then I believe its place is not in `Sets.ParentMethods`.

> > But when running the tests, it turns out that this is too narrow: Sometimes, we want to apply the quotient functor F to a ring over a _different_ base ring.
> 
> This does not seem directly related to this ticket. Could this easily
> be split off into a separate ticket?

Probably better. I am actually not sure if it would be a good idea to modify the quotient functor in that way.

> > Nicolas, do you think it would hurt to introduce such method here?
> 
> This seems like a sensible method; so if you have a use for it, go
> ahead.

Not sure yet.


---

Comment by SimonKing created at 2013-09-25 20:44:14

And now I realise that I use git, and I have no idea how to pick some part of the changeset of my last commit, and move it to a different branch.


---

Comment by jkeitel created at 2013-09-25 21:11:44

Hi Simon,

I am not sure how to just take a part of your last commit, but you can do the following:
While you're on your current development branch, write git branch new_branch to start a new branch pointing to the current commit.
Then go back to the old branch via git checkout old_branch and either delete manually the changes you don't want to to have on that branch or go back to a previous commit via
git reset --hard first_few_digits_of_sha_to_revert_to
You can then recommit some of the changes or just start working from there again.

This probably doesn't do exactly what you want, but it might be a start.


---

Comment by SimonKing created at 2013-09-25 21:19:31

Replying to [comment:16 jkeitel]:
> I am not sure how to just take a part of your last commit, but you can do the following:
> While you're on your current development branch, write git branch new_branch to start a new branch pointing to the current commit.
> Then go back to the old branch via git checkout old_branch and either delete manually the changes you don't want to to have on that branch or go back to a previous commit via
> git reset --hard first_few_digits_of_sha_to_revert_to
> You can then recommit some of the changes or just start working from there again.
> 
> This probably doesn't do exactly what you want, but it might be a start.

Thank you!

I had already started before your answer came. That's to say, I have stored `git diff HEAD~ HEAD` into a file `tmp.patch`, then manually reverted the changes that I didn't like, did `git add <changed_files>` and `git commit --amend`. And now, I should be able to create a branch for a different ticket, and apply the relevant changes stored in `tmp.patch`.

Since I didn't push the "wrong" commit to trac (in particular, clearly no other branch on trac will use my wrong commit), I guess it is ok to do `git commit --amend`, although it changes SHA1.


---

Comment by nbruin created at 2013-09-25 22:11:44

Replying to [comment:13 SimonKing]: 
> No, it is not UniqueRepresentation:
> {{{
> sage: isinstance(A,UniqueRepresentation)
> False
> }}}
That doesn't tell the entire story, though:

```
sage: type(IntegerModRing).mro()
[sage.rings.finite_rings.integer_mod_ring.IntegerModFactory,
 sage.structure.factory.UniqueFactory,
 sage.structure.sage_object.SageObject,
 object]
```

so perhaps the _object_ isn't really UniqueRepresentation but the _system_ tries to implement the semantics via a factory. So I think you're seeing exactly the problem I was afraid of:

```
sage: A1=IntegerModRing(19)
sage: A2=IntegerModRing(19)
sage: B1=IntegerModRing(19,category=Fields())
sage: B2=IntegerModRing(19,category=Fields())
sage: A1 is A2
True
sage: B1 is B2
True
sage: A1 in Fields()
True
sage: type(A1)
<class 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic_with_category'>
sage: type(B1)
<class 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic_with_category'>
sage: type(A1) == type(B1)
False
```

so after this we do have two functionally equivalent copies of the same ring: `A1,B1`, but they are not identical. Furthermore, their types are not identical or equal either, but it's hard to see what the difference is between them (note `A1.__cmp__` to see that this last `False` is the reason why `A1 != B1`.

Allowing categories to be refined on "global" (uniqueified) objects implies that the `category` argument needs to be ignored on lookup during the uniqueification. You can't really control the category anyway:

```
sage: A1=IntegerModRing(19,category=Rings())
sage: A1.category()
Join of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups
sage: A1 in Fields()
True
sage: A2=IntegerModRing(19,category=Rings())
sage: A2.category()
Join of Category of subquotients of monoids and Category of quotients of semigroups and Category of fields
```



---

Comment by nbruin created at 2013-09-25 22:55:04

Should specifying the category even be allowed anyway? What can be achieved by doing so? You can get horrible nonsense:

```
sage: A=IntegerModRing(16,category=Fields())
sage: P.<x>=A[]
sage: P in UniqueFactorizationDomains()
True
sage: (2*x+1)^8
1
```

Of course if you do this, you're just asking for the insanity. Normally everything is fine:

```
sage: B=IntegerModRing(16)
sage: Q.<x>=B[]
sage: Q in UniqueFactorizationDomains()
False
```

But it does mean that if `B` here were to be identical to `A`, then the first example would permanently poison the sage session with nonsense. So I'd think `IntegerModRing(16,category=Fields())` should produce an error.


---

Comment by SimonKing created at 2013-09-26 08:23:39

Replying to [comment:19 nbruin]:
> But it does mean that if `B` here were to be identical to `A`, then the first example would permanently poison the sage session with nonsense.

And that's why I think it is a good idea that _all_ given arguments, including the category, are taken into the cache key of the factory. That way, it won't matter if you put a non-field into the category of fields, because you are still able to create a "sane" version of the same ring.

> So I'd think `IntegerModRing(16,category=Fields())` should produce an error.

I don't think so. And in any case, it should be on a different ticket.


---

Comment by SimonKing created at 2013-09-26 08:53:58

Hm. But the more I think about it...:

In the `__cmp__` method of `IntegerModRing`, it is said:

```
        if type(other) is not type(self):   # so that GF(p) =/= Z/pZ
            return cmp(type(self), type(other))
        return cmp(self.__order, other.__order)
```


Note the comment: The aim is to let `GF(p)` and `Z/pZ` evaluate unequal. This gives rise to two questions:

1. Do we really want that they evaluate unequal?

   We have
   {{{
sage: GF(5).has_coerce_map_from(IntegerModRing(5))
True
sage: IntegerModRing(5).has_coerce_map_from(GF(5))
False
   }}}
   Since there is no coercion in both directions, the two rings can not be equal. So, I'd say `GF(5)!=IntegerModRing(5)` is correct, or at least consistent.

2. Do we really want that `IntegerModRing(5)` and `IntegerModRing(5,category=Fields())` evaluate unequal?

   This time, the coercions exist in both directions:
   {{{
sage: IntegerModRing(5).has_coerce_map_from(IntegerModRing(5, category=Fields()))
True
sage: IntegerModRing(5, category=Fields()).has_coerce_map_from(IntegerModRing(5))
True
   }}}
   Hence, we might want to let them evaluate equal.

I see the following options:

- Make it so that integer mod rings with the same modulus evaluate equal, regardless of their type and category. This would be in spite of the comment in the code of `__cmp__`.
- Change `__cmp__` so that integer mod rings evaluate equal if and only if there is a coercion in both directions. Hence, `GF(5)` and `ZZ.quo(5)` would evaluate unequal, but `IntegerModRing(5, category=...)` would all evaluate equal, independent of the category.
- Change `_coerce_map_from_`, so that there is a coercion in both directions if and only if the two integer mod rings evaluate equal. Hence, `IntegerModRing(5, category=...)` would all be distinct, for different categories.
- Do not allow to put in a "category" argument. But then, we might want to learn the rationale of introducing the argument in the first place. After all, if the modulus of integer mod ring R is a prime number, then asking `R in Fields()` will return true. So, if one knows during creation of the ring that the modulus is prime, one might use `GF(p)` instead of `IntegerModRing(p,category=Fields())`.

Further ways to go? In any case, there should be a new ticket.


---

Comment by SimonKing created at 2013-09-26 11:04:34

Replying to [comment:21 SimonKing]:
> - Do not allow to put in a "category" argument. But then, we might want to learn the rationale of introducing the argument in the first place. After all, if the modulus of integer mod ring R is a prime number, then asking `R in Fields()` will return true. So, if one knows during creation of the ring that the modulus is prime, one might use `GF(p)` instead of `IntegerModRing(p,category=Fields())`.

How embarrassing!

I just used `git blame` to find out who introduced the use of a "category" argument for integer mod rings---and found that it was *I*, namely in #9138.

I hope #9138 gives a rationale...


---

Comment by SimonKing created at 2013-09-26 11:10:55

`IntegerModRing` is not mentioned in the discussion of #9138. But in the patch, I found that providing the category as an additional argument used to be a "todo". Namely, before #9138, we had this:

```
sage: FF = IntegerModRing(17, category = Fields()) # todo: not implemented 
sage: FF.category()
Join of Category of fields and Category of finite enumerated sets
sage: TestSuite(FF).run()                          # todo: not implemented
```


So, this yields to the question: Why has it been a "todo"? Nicolas, did you added this "todo"?


---

Comment by SimonKing created at 2013-09-26 11:45:41

It seems that it became "todo" in #8562. And there is a discussion [here](https://groups.google.com/forum/#!topic/sage-devel/IeIeHsnNIf4). It seems indeed that in this discussion there was an agreement that
1. one should not do primality test when creating the `IntegerModRing`
2. calling `is_field()` will do a primality test, and it was even suggested to update the category to `Fields()`, which actually has been impossible at that time
3. it should be possible for the user to assert that the modulus is prime, _without_ using `GF(n)`. And, by the way, note that `GF(n)` would by default do a factorisation of `n`, and I don't know if it is possible for the user to skip this.

What do I conclude from this?

- Given 3., I see why people want to work with `IntegerModRing(n,category=Fields())` instead of `GF(n)` when they know that the huge number n is prime.
- Given 2., it might make sense to call `_refine_category` in `is_field` (and not only by 'R in Fields()') when the primality test succeeds.
- Given the cited discussion, it seems that the existence of an optional `category` argument is good.
- Providing the category `Fields()` at creation time should have the same effect as refining the category to `Fields()`. Namely, at the moment, the categories of `IntegerModRing(5,category=Fields())` and `IntegerModRing(5)` after `... in Fields()` are different.

And I am stuck with the following questions:

- Should the choice of a category play a role in testing equality for integer mod rings?
- Would we like that there is precisely _one_ instance of an integer mod ring for a given modulus, that is automatically updated if the user later provides more information? What I mean is this:
  {{{
sage: R = IntegerModRing(5)
sage: R.category()
Join of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets
sage: S = IntegerModRing(5, category=Fields())
sage: R is S
True
sage: R.category()
Join of Category of fields and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets
   }}}

__Suggested way to proceed__

- I open a new ticket implementing the conclusions formulated above.
- Depending on your answers to my questions, I open another new ticket to address them.
- I make these one or two tickets a dependency for this ticket.


---

Comment by SimonKing created at 2013-09-26 13:17:40

I have opened #15229 for the new problems.


---

Comment by SimonKing created at 2013-09-27 10:45:05

Changing keywords from "" to "construction functor, test suite, sd53".


---

Comment by git created at 2013-09-28 18:55:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2013-09-28 19:00:22

#15229 is ready for review (hint). I have merged #15229 into this branch, and rebased this branch, which was needed, as #15229 introduced a new convention for teaching to an integer mod ring that it is a field.

For me all tests pass. Hence, this one is ready for review, too!


---

Comment by SimonKing created at 2013-09-28 19:00:22

Changing status from new to needs_review.


---

Comment by mmezzarobba created at 2013-12-20 12:40:36

Changing status from needs_review to needs_work.


---

Comment by mmezzarobba created at 2013-12-20 12:40:36

There are new test failures with the current `develop`, unfortunately:

```
----------------------------------------------------------------------
sage -t src/sage/rings/polynomial/pbori.pyx  # 1 doctest failed
sage -t src/sage/rings/finite_rings/integer_mod_ring.py  # 4 doctests failed
sage -t src/sage/rings/residue_field.pyx  # 2 doctests failed
sage -t src/sage/rings/finite_rings/finite_field_pari_ffelt.py  # 1 doctest failed
----------------------------------------------------------------------
```



---

Comment by SimonKing created at 2013-12-28 12:25:54

Reviewing the errors:

```
sage -t src/sage/rings/polynomial/pbori.pyx
**********************************************************************
File "src/sage/rings/polynomial/pbori.pyx", line 476, in sage.rings.polynomial.pbori.BooleanPolynomialRing.construction
Failed example:
    P.<x0, x1, x2, x3> = BooleanPolynomialRing(4,order='degrevlex(2),degrevlex(2)')
Expected nothing
Got:
    doctest:1: DeprecationWarning: using 'degrevlex' in Boolean polynomial rings is deprecated. If needed, reverse the order of variables manually and use 'degneglex'
    See http://trac.sagemath.org/13849 for details.
**********************************************************************
```

OK, it seems we need a different ordering. Mostly harmless

`sage -t src/sage/rings/residue_field.pyx` and `sage -t src/sage/rings/finite_rings/finite_field_pari_ffelt.py`: The new test fails on some examples. Hooray! The new test helped to detect another bug!

For me, `sage -t src/sage/rings/finite_rings/integer_mod_ring.py` passes without error.


---

Comment by SimonKing created at 2013-12-28 12:27:34

PS: What has failed for you in `sage -t src/sage/rings/finite_rings/integer_mod_ring.py`?


---

Comment by mmezzarobba created at 2013-12-28 15:54:55

Replying to [comment:31 SimonKing]:
> PS: What has failed for you in `sage -t src/sage/rings/finite_rings/integer_mod_ring.py`?

The failures do not look deterministic. With the current state of your branch, all tests passed when I did `sage -t integer_mod_ring.py` for the first time. Then I tried again and repeatedly got:

```
$ sage -t src/sage/rings/finite_rings/integer_mod_ring.py
Running doctests with ID 2013-12-28-16-42-51-6b28af73.
Doctesting 1 file.
sage -t src/sage/rings/finite_rings/integer_mod_ring.py
**********************************************************************
File "src/sage/rings/finite_rings/integer_mod_ring.py", line 729, in sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic._pseudo_fraction_field
Failed example:
    Integers(15).fraction_field()
Expected:
    Traceback (most recent call last):
    ...
    TypeError: self must be an integral domain.
Got:
    Ring of integers modulo 15
**********************************************************************
1 item had failures:
   1 of   7 in sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic._pseudo_fraction_field
    [251 tests, 1 failure, 1.68 s]
----------------------------------------------------------------------
sage -t src/sage/rings/finite_rings/integer_mod_ring.py  # 1 doctest failed
----------------------------------------------------------------------
```

But I'm unable to reproduce this behaviour from the sage command line.

I will run the tests again after rebuilding sage from scratch.


---

Comment by mmezzarobba created at 2013-12-28 17:32:20

Replying to [comment:32 mmezzarobba]:
> I will run the tests again after rebuilding sage from scratch.

Done: I get the same heisenfailure in `integer_mod_ring.py` on your branch, _without_ merging in develop. I'm currently checking whether the problem exists on `develop` (again with a clean build, so it will take a while).


---

Comment by mmezzarobba created at 2013-12-28 19:17:49

Replying to [comment:33 mmezzarobba]:
> I'm currently checking whether the problem exists on `develop`

Apparently it doesn't.


---

Comment by mmezzarobba created at 2013-12-28 19:26:07

Replying to [comment:34 mmezzarobba]:
> Replying to [comment:33 mmezzarobba]:
> > I'm currently checking whether the problem exists on `develop`
> 
> Apparently it doesn't.

And I'm also unable to reproduce it when I first build `develop` from scratch, and then merge in your branch and do an incremental build.

Perhaps a bug of 5.12.x that was fixed since them and resurfaced randomly in my tests due to problems with incremental builds, then?


---

Comment by SimonKing created at 2013-12-28 20:12:28

Replying to [comment:32 mmezzarobba]:
> The failures do not look deterministic. With the current state of your branch, all tests passed when I did `sage -t integer_mod_ring.py` for the first time. Then I tried again and repeatedly got:
> {{{
> $ sage -t src/sage/rings/finite_rings/integer_mod_ring.py
> Running doctests with ID 2013-12-28-16-42-51-6b28af73.
> Doctesting 1 file.
> sage -t src/sage/rings/finite_rings/integer_mod_ring.py
> **********************************************************************
> File "src/sage/rings/finite_rings/integer_mod_ring.py", line 729, in sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic._pseudo_fraction_field
> Failed example:
>     Integers(15).fraction_field()
> Expected:
>     Traceback (most recent call last):
>     ...
>     TypeError: self must be an integral domain.
> Got:
>     Ring of integers modulo 15
> }}}

Ahahahaha! It looks like the same example (modulus 15) was used in a different example to demonstrate that one can erroneously claim that `IntegerModRing(15)` is a field, and it could be that by random order of executing the tests this false information was cached. To be on the safe side, we could empty the cache.

> I will run the tests again after rebuilding sage from scratch.

Did you pull from #15229?

For the record: I get

```
sage -t src/sage/rings/residue_field.pyx  # 2 doctests failed
sage -t src/sage/rings/polynomial/pbori.pyx  # 1 doctest failed
sage -t src/sage/rings/finite_rings/finite_field_pari_ffelt.py  # 1 doctest failed
```



---

Comment by git created at 2013-12-28 20:31:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2013-12-28 20:36:16

I have merged #15229, since it changes `integer_mod_ring.py`, and I added a commit to clear the cache of the integer mod ring factory after compromising the cache by lying about `is_field=True`.

Hopefully this will fix the "Heisenbug" (which probably is not more than a side-effect between doc-tests). The remaining failures shall be fixed in the next commit.


---

Comment by SimonKing created at 2013-12-28 20:52:13

Concerning the error with residue fields:

```
sage: K.<z> = CyclotomicField(7)
sage: P = K.factor(17)[0][0]
sage: ff = K.residue_field(P)
sage: ff.construction()
(AlgebraicExtensionFunctor, Finite Field of size 17)
sage: F,R = _
sage: F(R)
Finite Field in zbar of size 17^6
sage: ff
Residue field in zbar of Fractional ideal (17)
sage: ff.order()
24137569
sage: F(R).order()
24137569
```


So, the construction of a residue field just yields a finite field, not a residue field. Either the algebraic extension functor needs information of whether it is a residue field or not, or we need a "residue field functor". I wouldn't like to see the latter, since it is clearly no functor. OK, it would also be possible to kill the construction of residue fields.


---

Comment by SimonKing created at 2013-12-28 21:08:31

The algebraic extension functors already have a version to construct cyclotomic fields. It should be straight forward to make them deal with residue fields, too.


---

Comment by SimonKing created at 2013-12-28 21:35:45

Rather than killing the construction, I guess the following is a nice behaviour:

```
        sage: K.<z> = CyclotomicField(7)
        sage: P = K.factor(17)[0][0]
        sage: k = K.residue_field(P)
        sage: F, R = k.construction()
        sage: F
        AlgebraicExtensionFunctor
        sage: R
        Cyclotomic Field of order 7 and degree 6
        sage: F(R) is k
        True
        sage: F(ZZ)
        Residue field of Integers modulo 17
        sage: F(CyclotomicField(49))
        Residue field in zeta49bar of Fractional ideal (17)
```



---

Comment by git created at 2013-12-28 21:41:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2013-12-28 22:14:39

Residue fields are fixed with the latest commit.
----
New commits:
----
New commits:


---

Comment by git created at 2013-12-28 22:45:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2013-12-28 22:59:42

With the new commit, the construction of field extensions is fixed.

Problem was: Finite fields may have different implementations (givaro, pari_ffelt, ...), but this was ignored in the construction of the construction functor. Now, the implementation is tracked in the construction functor.

One complication: When we merge the construction functors, we need to choose among the implementations. I decided (for now) to always rely on the _default_ implementation upon merging. 

__Rationale__

- The situation is not worse than before. Without the latest commit, applying the construction functor of a finite field would _always_ use the default implementation. With the latest commit, applying the construction functor of a finite field F will use the implementation that was used for F. Only if a new construction functor is created by merging two functors (which may happen in the pushout construction), the default implementation will be used, 

- We can't rely on a custom implementation in the merged functor, since a custom implementation may not be available for a non-prime field, that could be the result of merging.


---

Comment by SimonKing created at 2013-12-28 23:02:07

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2013-12-28 23:02:07

Hooray, with the last commit, `sage -t src/sage/rings/polynomial/pbori.pyx` passes, too!

Hence, I think it could be reviewed now (but I will run the tests while sleeping).


---

Comment by git created at 2013-12-29 07:40:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2013-12-29 07:50:14

Sigh. I still don't like git. It makes it soooooo easy to do mistakes, whose reversal is considered "changing history".

Anyway. It was an accident that I did not revert merging the branch 'develop' before pushing it here.

Can someone tell me, *if* and *how* I should remove the merge commit?

But now all tests pass, and thus it can be reviewed.


---

Comment by mmezzarobba created at 2013-12-29 12:58:28

Replying to [comment:48 SimonKing]:
> Can someone tell me, *if* and *how* I should remove the merge commit?

Im my opinion (some people might disagree), yes, you should, since it is very unlikely that anyone has based anything on the last state of your branch. There is no need to be religious about history rewrites, one just needs to avoid forcing people to do rebases.

To remove the merge commit, just do `git rebase HEAD^ --onto HEAD^^` on your branch (and then `git push -f` to push the modified branch to trac).


---

Comment by git created at 2013-12-29 13:24:03

Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:


---

Comment by SimonKing created at 2013-12-29 13:29:29

Replying to [comment:49 mmezzarobba]:
> Replying to [comment:48 SimonKing]:
> > Can someone tell me, *if* and *how* I should remove the merge commit?
> 
> Im my opinion (some people might disagree), yes, you should, since it is very unlikely that anyone has based anything on the last state of your branch. There is no need to be religious about history rewrites, one just needs to avoid forcing people to do rebases.
> 
> To remove the merge commit, just do `git rebase HEAD^ --onto HEAD^^` on your branch (and then `git push -f` to push the modified branch to trac).

Thank you! Can you briefly explain to me the differences between `^HEAD`, `HEAD^` and `HEAD~`? I keep forgetting what is what.


---

Comment by mmezzarobba created at 2013-12-29 18:16:25

Replying to [comment:51 SimonKing]:
> Thank you! Can you briefly explain to me the differences between `^HEAD`, `HEAD^` and `HEAD~`? I keep forgetting what is what.

The last two specify revisions (commits): `rev^k` is the `k`-th parent of `rev`; `rev~k` is the grand<sup>`k`</sup>-first-parent of `rev`; `rev^` and `rev~` are shorthands `rev^1` == `rev~1`.

`^rev` is something different: it is used to specify lower bounds of ranges of revisions. For example, `rev1 rev2 ^rev3` is the set of all ancestors of `rev1` or `rev2` that are not ancestors of `rev3`.

See `git help revisions` for the full syntax of revision specifications.


---

Comment by rws created at 2014-05-09 08:18:37

Set to 'needs work' because patchbot fails to apply the patch (open dependency).


---

Comment by rws created at 2014-05-09 08:18:37

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2017-01-09 12:54:35

The dependency *is* closed, but apparently the branch doesn't merge.


---

Comment by mkoeppe created at 2020-08-31 01:15:23

In the middle of manually rebasing this onto 9.2.beta10.

```
DONE 91712d0545 Test that the construction of a parent really constructs the parent
DONE 91bbab6438 Add a test to Parent._test_construction
REDONE 2bb2cf269b Fix most doctest errors that are due to enlarging the test suite
DONE a81fcc1072 Make _test_construction pass in the thematic tutorial
DONE e83735ca25 Provide several constr. functors with more parameters
```


TODO:

```
pick cb4929aa68 Rebase wrt. #15229. Fix remaining doc test errors.
pick d0c42ff938 Trac 15223: Avoid side-effects between doctests of integer_mod_ring
pick ab2c12e1fb Trac 15223: Construction of residue fields
pick b23f18d716 Trac 15223: Construction of field extensions with implementation
pick 7a24de6caa Trac 15223: Avoid deprecation warning in a new test
```


----
New commits:


---

Comment by mkoeppe created at 2020-08-31 01:22:39

Looks like there is a circular import problem now:

```
ImportError: cannot import name 'AlgebrasCategory' from 'sage.categories.algebra_functor' (/Users/mkoeppe/s/sage/sage-rebasing/local/lib/python3.7/site-packages/sage/categories/algebra_functor.py)
```



---

Comment by git created at 2020-08-31 01:36:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-31 01:39:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-08-31 01:40:31

Help with this circular import business would be very welcome


---

Comment by tscrim created at 2020-08-31 01:50:36

In `polynomial_quotient_ring.py`, a way around the problem is to just make those imports locally where you need them in `construction()`. Welcome to Sage's circular import hell. `:P`

Also

```diff
 
-        TESTS:
+        TESTS::
 
             sage: M2 = PowerSeriesRing(QQ,4,'f', sparse=True)
             sage: M == M2
             False
```



---

Comment by git created at 2020-08-31 02:17:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-08-31 02:18:19

Hm... this alone did not do the trick


---

Comment by git created at 2020-08-31 02:24:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-31 02:24:49

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2020-08-31 02:25:03

OK, got it.


---

Comment by git created at 2020-08-31 02:26:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-31 02:30:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-08-31 02:42:21

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2020-08-31 02:42:38

Setting it to needs_review so that the patchbot runs


---

Comment by git created at 2020-08-31 03:06:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-31 03:13:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-31 03:22:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-31 03:23:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-08-31 03:28:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-08-31 05:24:13

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2020-08-31 05:24:13

As expected, there are a number of `AssertionError: the object's construction does not recreate this object` errors.

In addition, there are some other errors, probably because of faulty rebasing:

```
sage -t --random-seed=0 src/sage/rings/polynomial/polynomial_quotient_ring.py
sage -t --random-seed=0 src/sage/rings/multi_power_series_ring_element.py
sage -t --random-seed=0 src/sage/rings/multi_power_series_ring.py
sage -t --random-seed=0 src/sage/rings/power_series_ring_element.pyx
sage -t --random-seed=0 src/sage/rings/finite_rings/element_pari_ffelt.pyx
```



---

Comment by mkoeppe created at 2020-09-01 22:42:15


```
File "src/sage/rings/multi_power_series_ring.py", line 504, in sage.rings.multi_power_series_ring.MPowerSeriesRing_generic.construction
Failed example:
    c(R)
Exception raised:
    Traceback (most recent call last):
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 715, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 1139, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.rings.multi_power_series_ring.MPowerSeriesRing_generic.construction[3]>", line 1, in <module>
        c(R)
      File "sage/categories/functor.pyx", line 383, in sage.categories.functor.Functor.__call__ (build/cythonized/sage/categories/functor.c:3146)
        y = self._apply_functor(self._coerce_into_domain(x))
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/categories/pushout.py", line 2456, in _apply_functor
        return R.completion(self.p, self.prec, extras)
      File "sage/rings/polynomial/multi_polynomial_ring_base.pyx", line 184, in sage.rings.polynomial.multi_polynomial_ring_base.MPolynomialRing_base.completion (build/cythonized/sage/rings/polynomial/multi_polynomial_ring_base.c:5003)
        def completion(self, names, prec=20):
    TypeError: completion() takes at most 2 positional arguments (3 given)
**********************************************************************
```

The method `MPolynomialRing_base.completion` lost its `extras` parameter in #23377/#26773, so this method is no longer compatible with other methods...


---

Comment by mkoeppe created at 2020-09-01 22:51:19


```
$ git grep 'def completion('
src/sage/combinat/finite_state_machine.py:    def completion(self, sink=None):
src/sage/rings/function_field/function_field.py:    def completion(self, place, name=None, prec=None, gen_name=None):
src/sage/rings/integer_ring.pyx:    def completion(self, p, prec, extras = {}):
src/sage/rings/number_field/number_field.py:    def completion(self, p, prec, extras={}):
src/sage/rings/polynomial/laurent_polynomial_ring.py:    def completion(self, p, prec=20, extras=None):
src/sage/rings/polynomial/multi_polynomial_ring_base.pyx:    def completion(self, names, prec=20):
src/sage/rings/polynomial/polynomial_ring.py:    def completion(self, p, prec=20, extras=None):
src/sage/rings/qqbar.py:    def completion(self, p, prec, extras={}):
src/sage/rings/qqbar.py:    def completion(self, p, prec, extras={}):
src/sage/rings/rational_field.py:    def completion(self, p, prec, extras = {}):
```



---

Comment by git created at 2020-09-01 23:06:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-01 23:50:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-01 23:52:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-02 00:37:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-02 00:44:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-09-02 01:19:37

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2020-09-02 01:23:52

Help with fixing the remaining failures would be welcome


---

Comment by mmezzarobba created at 2020-09-02 17:49:48

Replying to [comment:91 mkoeppe]:
> Help with fixing the remaining failures would be welcome

Here is an attempt (not really tested)...
----
New commits:


---

Comment by mkoeppe created at 2020-09-03 04:07:53

`src/sage/algebras/free_zinbiel_algebra.py` needs some help


---

Comment by git created at 2020-09-03 04:10:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-09-03 04:14:28

A number of those `verbose=True` tests probably are best made `verbose=False` so we don't have this problem.

Right now beta11 is compiling for me. Can you tell me what the problem is with `free_zinbiel_algebra.py` so I know what to start looking for?


---

Comment by git created at 2020-09-03 04:16:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-09-03 04:17:29

Also relevant: #23010.


---

Comment by mkoeppe created at 2020-09-03 04:18:27

Replying to [comment:97 tscrim]:
> Right now beta11 is compiling for me. Can you tell me what the problem is with `free_zinbiel_algebra.py` so I know what to start looking for?

On this ticket: 

```
sage -t --long --random-seed=0 src/sage/algebras/free_zinbiel_algebra.py
**********************************************************************
File "src/sage/algebras/free_zinbiel_algebra.py", line 211, in sage.algebras.free_zinbiel_algebra.FreeZinbielAlgebra.__init__
Failed example:
    TestSuite(Z).run(elements=[Z.an_element(), G[1], G[1]*G[2]*G[0]])
Expected nothing
Got:
    Failure in _test_construction:
    Traceback (most recent call last):
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/misc/sage_unittest.py", line 297, in run
        test_method(tester=tester)
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/categories/sets_cat.py", line 1508, in _test_construction
        FO = self.construction()
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/algebras/free_zinbiel_algebra.py", line 498, in construction
        return ZinbielFunctor(self.variable_names()), self.base_ring()
      File "sage/structure/category_object.pyx", line 474, in sage.structure.category_object.CategoryObject.variable_names (build/cythonized/sage/structure/category_object.c:4392)
        raise ValueError("variable names have not yet been set using self._assign_names(...)")
    ValueError: variable names have not yet been set using self._assign_names(...)
    ------------------------------------------------------------
    The following tests failed: _test_construction
```



---

Comment by mkoeppe created at 2020-09-03 04:23:40

Replying to [comment:99 tscrim]:
> Also relevant: #23010.
See my comment there -- all commits have already merged apparently


---

Comment by mkoeppe created at 2020-09-03 04:25:25

Replying to [comment:93 mmezzarobba]:
> Here is an attempt (not really tested)...
> New commits:
> ||[3630d25](https://git.sagemath.org/sage.git/commit?id=3630d255fe8330c8772eb856a1acdae3749f2101)||`#15223 pass variable names to residue_field() in AlgebraicExtensionFunctor`||

I have fixed one bug, but more work is needed because the interface of method `residue_field` is not very consistent:

```
$ git grep 'def residue_field'
src/sage/categories/discrete_valuation.py:        def residue_field(self):
src/sage/categories/discrete_valuation.py:        def residue_field(self):
src/sage/rings/function_field/function_field.py:    def residue_field(self, place, name=None):
src/sage/rings/function_field/function_field.py:    def residue_field(self, place, name=None):
src/sage/rings/function_field/place.py:    def residue_field(self, name=None):
src/sage/rings/function_field/place.py:    def residue_field(self, name=None):
src/sage/rings/function_field/valuation_ring.py:    def residue_field(self, name=None):
src/sage/rings/ideal.py:    def residue_field(self):
src/sage/rings/integer_ring.pyx:    def residue_field(self, prime, check = True):
src/sage/rings/laurent_series_ring.py:    def residue_field(self):
src/sage/rings/number_field/number_field.py:    def residue_field(self, prime, names=None, check=True):
src/sage/rings/number_field/number_field_ideal.py:    def residue_field(self, names=None):
src/sage/rings/number_field/order.py:    def residue_field(self, prime, names=None, check=False):
src/sage/rings/padics/padic_generic.py:    def residue_field(self):
src/sage/rings/polynomial/ideal.py:    def residue_field(self, names=None, check=True):
src/sage/rings/polynomial/polynomial_ring.py:    def residue_field(self, ideal, names=None):
src/sage/rings/power_series_ring.py:    def residue_field(self):
src/sage/rings/puiseux_series_ring.py:    def residue_field(self):
src/sage/rings/rational_field.py:    def residue_field(self, p, check=True):
src/sage/rings/valuation/valuation_space.py:        def residue_field(self):
```



---

Comment by mkoeppe created at 2020-09-03 05:25:51

Changing status from needs_review to needs_work.


---

Comment by mmezzarobba created at 2020-09-05 07:01:58

Replying to [comment:102 mkoeppe]:
> I have fixed one bug,

Uh, I said I had not really tested my patches, but I thought I had run the tests from the few most relevant files, sorry.

> but more work is needed because the interface of method `residue_field` is not very consistent:

It is not clear to me on what kinds of objects this functor can be called with `residue != None`. It may be good enough for this ticket to take care of the cases that currently work...


---

Comment by git created at 2020-09-05 07:21:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-05 07:22:34

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-09-05 09:00:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mmezzarobba created at 2020-09-05 09:02:59

`@`dkrenn: Commit e664f08 fixes an issue with the uniqueness of cartesian product asymptotic growth groups. My fix is a bit fragile, do you have a better idea?


---

Comment by mmezzarobba created at 2020-09-05 10:02:36

Replying to [comment:110 mmezzarobba]:
> `@`dkrenn: Commit b6b012b fixes an issue with the uniqueness of cartesian product asymptotic growth groups. My fix is a bit fragile, do you have a better idea?

Hmm, actually, we have the same issue with `CartesianProductPoset` itself. So I think we need a factory for them, and that's where the normalization of the category should go. But `CartesianProductPoset` can depend on arbitrary functions. I suppose one would like to ensure uniqueness at least for the standard orderings, even if posets with custom orderings are all distinct. I'm not sure how to do that best; using `UniqueFactory`, the code will be a bit unwieldy.


---

Comment by git created at 2020-09-05 10:03:23

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-09-05 23:24:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-09-06 00:29:20

To fix failures like the one in `src/sage/combinat/symmetric_group_algebra.py`, we also need to give `AlgebraFunctor` and `GroupAlgebraFunctor` a category argument.

Do we already have a forgetful functor somewhere that can take care of such things by composing?


---

Comment by git created at 2020-09-06 00:38:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-09-06 00:59:29

Replying to [comment:100 mkoeppe]:
> Replying to [comment:97 tscrim]:
> > Right now beta11 is compiling for me. Can you tell me what the problem is with `free_zinbiel_algebra.py` so I know what to start looking for?

Minimal example:

```
sage: algebras.FreeZinbiel(QQ, ZZ).construction()                                                                                               
ValueError: variable names have not yet been set using self._assign_names(...)
```



---

Comment by mkoeppe created at 2020-09-06 05:35:55

To fix the failures in `src/sage/matrix/matrix_gap.pyx`, we would need to store `implementation` in `MatrixFunctor`.


---

Comment by git created at 2020-09-10 23:33:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-09-10 23:34:39

Thank you. Sorry for taking a week to get to this.

So the problem is the extension of the free Zinbiel algebra to the infinite number of variables but the `construction()` was only implemented for the finite case. I have fixed this and some other minor things with the construction functor for handling infinite number of variables.


---

Comment by tscrim created at 2020-09-13 02:11:48

Replying to [comment:114 mkoeppe]:
> To fix failures like the one in `src/sage/combinat/symmetric_group_algebra.py`, we also need to give `AlgebraFunctor` and `GroupAlgebraFunctor` a category argument.
> 
> Do we already have a forgetful functor somewhere that can take care of such things by composing?

Sort of, there is the `ForgetfulFunction_generic` in `categories/functor.pyx`. You probably will need to implement a subclass of that for this purpose.


---

Comment by git created at 2020-09-14 18:48:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-09-14 18:49:26

Proposing to take care of the remaining failures in a follow-up ticket.


---

Comment by mkoeppe created at 2020-09-14 18:49:26

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2020-09-15 03:46:54

I am happy with that and the rest of the changes. Anyone else have any objections?


---

Comment by mmezzarobba created at 2020-09-15 06:08:48

Replying to [comment:123 tscrim]:
> I am happy with that and the rest of the changes. Anyone else have any objections?

No, I was going to make the same suggestion as Matthias.


---

Comment by mkoeppe created at 2020-09-15 06:26:05

Replying to [comment:123 tscrim]:
> I am happy with that and the rest of the changes. 
For completeness, I have reviewed your changes to the Zinbiel construction functor.


---

Comment by mkoeppe created at 2020-09-15 06:26:05

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2020-09-15 06:30:51

Follow-up in #30574


---

Comment by tscrim created at 2020-09-21 23:25:20

Is #30507 really a dependency? If not, we should remove it so this gets picked up into Sage.


---

Comment by mkoeppe created at 2020-09-21 23:26:47

It isn't - thanks for catching this


---

Comment by vbraun created at 2020-09-27 09:09:57

Resolution: fixed
