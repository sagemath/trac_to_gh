# Issue 14916: Check embedding morphism when comparing two toric varieties

Issue created by migration from https://trac.sagemath.org/ticket/15153

Original creator: jkeitel

Original creation time: 2013-09-04 07:35:52

CC:  vbraun novoselt

Keywords: toric

At the moment two toric varieties are taken to be equal if _their fans are the same, names of variables are the same and stored in the same order,          and base fields are the same_, independent of whether they have the same embedding morphism or not.

What does that imply? Since ToricDivisorGroup inherits from UniqueRepresentation, two toric varieties that only differ in their embedding will share the same ToricDivisorGroup object and therefore a ToricDivisor created by a variety will reference the variety that first created its ToricDivisorGroup object, independent of whether that's correct or not.

As a consequence, we have the following behavior:


```
sage: P2 = toric_varieties.P(2)
sage: variety1 = P2.affine_patch(2)
sage: variety2 = ToricVariety(variety1.fan())
sage: variety1 == variety2
True
sage: div1 = variety1.divisor(Cone([(1,0)]))
sage: div2 = variety2.divisor(Cone([(1,0)]))
sage: div1.scheme().embedding_morphism()
Scheme morphism:
  From: 2-d affine toric variety
  To:   2-d CPR-Fano toric variety covered by 3 affine patches
  Defn: Defined on coordinates by sending [z0 : z1] to
        [z0 : z1 : 1]
sage: div2.scheme().embedding_morphism() # should produce an exception
Scheme morphism:
  From: 2-d affine toric variety
  To:   2-d CPR-Fano toric variety covered by 3 affine patches
  Defn: Defined on coordinates by sending [z0 : z1] to
        [z0 : z1 : 1]
sage: div2.scheme() is variety2
False
sage: div2.scheme() is variety1
True
```

While this set-up might seem highly artificial, in the context of toric fibrations in #12892 one naturally gets fiber varieties that only differ in their embedding.

Unless there are arguments against it, I therefore suggest to extend `ToricVariety_field.__cmp__` to include the embedding morphism.


---

Comment by git created at 2013-09-04 08:07:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jkeitel created at 2013-09-04 08:11:11

Changing status from new to needs_review.


---

Comment by jkeitel created at 2013-09-04 08:11:11

I've pushed a small patch and would be grateful for any comments. Thank you!


---

Comment by vbraun created at 2013-09-04 09:50:03

I think thats not good enough, sometimes we set the `_embedding_morphism` attribute directly. This would then change the already-cached class. The proper way would be a derived class for toric variety with embedding, and then make those unique.


---

Comment by novoselt created at 2013-09-04 19:34:42

We definitely want to have isomorphic varieties with different embedding and varieties probably have to be unique as well. Should then `embedding_morphism` become a part of the constructor (with default value `None`) and setting it generate a new instance? I am not sure if a derived class will simplify the situation here.


---

Comment by jkeitel created at 2013-09-04 20:13:19

Replying to [comment:5 novoselt]:
> We definitely want to have isomorphic varieties with different embedding and varieties probably have to be unique as well. Should then `embedding_morphism` become a part of the constructor (with default value `None`) and setting it generate a new instance? I am not sure if a derived class will simplify the situation here.

This sounds good to me, but then again I am not sure that I understood how Volker's suggestion would have solved the problem. Whenever you're allowed to modify `._embedding_morphism` you have to make sure you throw out all UniqueRepresentations you are referring to, don't you? So creating a new ToricVariety sounds like a clean solution.

In any case, I just realized that the patch also needs some additional work. Several of the ToricMorphisms inherit directly from SchemeMorphism and inherit their `__cmp__` directly from Element, which seems to access its parent (i.e. the ToricVariety) and therefore causes a RecursionError. How can one circumvent that? Come up with __cmp__ methods (maybe such as comparing `_fan_morphism`) for the ToricMorphism classes?


---

Comment by jkeitel created at 2013-09-04 20:13:19

Changing status from needs_review to needs_work.


---

Comment by vbraun created at 2013-09-04 20:39:30

I basically agree that we should make `embedding_morphism` part of the constructor. The only design question is whether we always want to have a `embedding_morphism()` method that then raises an exception by default. Alternatively, we could have a simple mixin class that just tracks the embedding morphism part. Then you'd have to define

```
class ToricVarietyWithEmbedding_class(Embedding_mixin, ToricVariety_class):
    pass
```

and similarly for AffineToricVariety, !CPRFanoToricVariety. Its a few extra lines over the plain approach where everything has a `embedding_morphism()` method but with the advantage that you wouldn't have the extra method if you don't need it.


---

Comment by novoselt created at 2013-09-04 21:31:48

I think with subclasses `__cmp__` of the parent class will have to return 0 only if both elements have exactly they type of the parent class, i.e. not are just instances of the parent class. This seem cumbersome to me, so I'd rather have always have this "extra" method returning either `None` or throwing an exception if it was not set in the constructor.


---

Comment by vbraun created at 2013-09-04 21:37:09

Either way you'll have to return 0 only if the embeddings are the same. So for all purposes the variety with and without embedding are distinct, and we may just as well make the types different by making the embedding case a subclass. Also, it would be nice if `_repr_` would distinguish the case with and without embedding so there is not too much of a surprise if they do not compare as equal.


---

Comment by novoselt created at 2013-09-04 21:41:15

To always compare embeddings varieties without embedding should be aware of there existence, in which case it really seems to me that they are of the same class, but with different values of attributes.

Adjusting `_repr_` is a great idea!


---

Comment by jkeitel created at 2013-09-05 07:36:17

Okay, if I understand correctly, then regardless of how it is implemented, one would want to have
1. An argument `embedding_morphism` in the constructor of `ToricVariety,CPRFanoToricVariety` and replace all accesses to `._embedding_morphism` by creating new varieties.
2. A distinction between cases with and without embedding in `_repr_`.

However, I am still not sure how to deal with the comparison of two varieties with embedding. I suppose one really only wants to morphisms to be equal if they have equal domains and codomains. As mentioned above, however, this leads to an infinite recursion loop. Should one implement some sort of comparison method for the morphisms that does not check equality of domains or is there another more elegant way around this problem?


---

Comment by vbraun created at 2013-09-05 10:48:09

The alternative would be to have a way to compare the varieties ignoring their embedding, and only compare domain/codomain of morphisms ignoring the embedding. This is where the separate classes shine as you can just call the base `ToricVariety_field.__cmp__(self, other)` directly. If its all munged into one class then you have to invent yet another method `compare_without_embedding()` or so.

But, as you said, one can also just make put comparison of morphisms into a method 
`compare(self, other, ignore_domain=False, ignore_codomain=False)`.


---

Comment by jkeitel created at 2013-09-05 11:49:55

That actually sounds very nice. Having two separate classes may really be the cleanest option. I think one would have to have to `compare` methods for ToricVariety anyway because of the following scenario:

Let f_i be the embedding of A_i into B_i. When comparing f_1 to f_2 the `SchemeMorphism_something.__cmp__` method must use the old `ToricVariety_field.__cmp__` method to avoid falling into an infinite loop.

Unless there are objections, I think I'll try and implement something along these lines and push it here once there is some progress. 

Thanks for all the help so far!


---

Comment by novoselt created at 2013-09-05 15:02:35

My problems with extra classes just for the sake of embedding:
 * need to have these extra classes for every flavour (toric, affine toric, CPRFano, maybe others later) - not difficult, but annoying;
 * anything that constructs a new toric variety should properly handle the class - of course, this may have to be done anyway to properly handle embedding attribute;
 * more serious: comparison of varieties without embedding is unclear to me: if `X` is just a variety and `Y` is the same but embedded (and realized by an extra class), then `cmp(X, Y)` will call `X.__cmp__(Y)`. This should just compare varieties by themselves and they are equal. On the other hand `Y.__cmp__(X)` will take into account embeddings, so they are not equal, which is bad. To fix it, the first method already should be aware of the embedding and take it into account.

Note that `==` in general for toric framework means "Sage-equal" (and in fact should be the same as `is` if varieties are made unique). This more or less was how this ticket appeared - this sense is not handled correctly and it breaks technical things. If one wants more mathematical equality, probably the correct way is to call already existing (or not?-) `is_isomorphic`, which clearly should not take into account embedding.

A possible solution to recursion is to not call embedding comparison/equality in `__cmp__` of toric varieties, but rather check that domains/codomains are the same in our internal sense and then check the defining map of the embedding to be the same, i.e. its data apart from domain/codomain. This should make it possible to compare embedding morphisms directly too.


---

Comment by vbraun created at 2013-09-05 15:19:10

You just have to add

```python
class FooToricVarietyWithEmbedding_class(Embedding_mixin, FooToricVariety_class):
    pass
```

for each subclass of toric variety. I don't think its too much effort. There are further tricks with dynamic classes and categories if you really want to avoid it, but at this point I don't think its worth it since there are not going to be that many subclasses of toric variety.

As for comparison, I think it should just always be unequal if the types differ. So an AffineToricVariety is always different from a ToricVariety, and a variety with embedding is always different from a variety without embedding. The `==` comparison implicitly means: can be interchanged freely for the purposes of caching. This can be implemented easily in the base class without knowing about the embedding:

```python
    def __init__(self, other):   # in ToricVariety_field
        c = cmp(self.__class__, other.__class__)
        if c != 0:
            return c
        ...
```



---

Comment by novoselt created at 2013-09-05 15:26:07

OK, hard to argue ;-) Although new classes probably have to include docstrings with doctests.


---

Comment by git created at 2013-09-06 09:56:47

Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:


---

Comment by jkeitel created at 2013-09-06 10:52:18

Okay, I've tried to implement your suggestions. Although the (modified) doc tests run I am sure that there are mistakes / things that could be done more elegantly in my patch and I'd very much appreciate your comments.

Maybe a couple of things right away:
- I couldn't figure out how to use super to initialize both `EmbeddedToricVariety_Mixin, ToricVariety_field` in the constructor of `ToricVarietyWithEmbedding_field` and analogously for the Fano case.
- Another problem with super: I could not replace `ToricVariety_field.__cmp__(self, right)` by some construction like `super(self.__class__, self)` in `EmbeddedToricVariety_Mixin` despite comments and help from Volker. (Apparently I don't properly understand how multiple inheritance works in python)
- variety.affine_patch(i) now returns patches whose embedding morphisms are given by Morphisms defined through FanMorphisms instead of polynomal ones, but one can of course get the old representation via `patch.embedding_morphism().as_polynomial_map()`

Also, the morphisms in #12892 will need to implement short `__cmp__` methods just as I did for the two morphism classes in the above patch.

Many thanks already!


---

Comment by git created at 2013-09-24 15:47:00

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by jkeitel created at 2013-09-24 15:50:59

Changing status from needs_work to needs_review.


---

Comment by jkeitel created at 2013-09-24 15:50:59

Hi,

I've now included the toric morphisms introduced by #12892 and implemented comparison methods for them. I realize that my git usage wasn't that great - many commits and an unnecessary merge. Won't happen again!

I'd still appreciate comments on the patch.

Regards,
Jan


---

Comment by novoselt created at 2013-09-28 17:43:05

I am confused by this branch (which is very likely to be my problem) - I try to look at changes since the last Voker's commit and the very last one, but there is a lot of changes to makefile and other general stuff. If I try to start with the next commit, it seems that some embedding-related changes were already done before. So - how do I look at changes related to this ticket only?


---

Comment by jkeitel created at 2013-09-28 17:49:57

This is very likely due to my poor handling of git. I wanted to carry over code from the previous patch for the comparison method, but I had already merged an update from the master branch into that. When I therefore merged the comparison method code into Volker's fibrations, it included the changes unrelated to my patch.
In the future, I won't do that anymore, but in the mean time you'll probably just have to ignore the changes to the makefile. Sorry about that!


---

Comment by git created at 2013-09-29 13:25:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jkeitel created at 2013-09-29 13:27:23

Okay, I think this should now work with all the changes Andrey made while reviewing #12892.


---

Comment by rws created at 2014-04-14 09:12:02

Changing status from needs_review to needs_work.


---

Comment by rws created at 2014-04-14 09:12:02

Does not merge cleanly. Please rebase.


---

Comment by git created at 2014-05-06 14:34:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-05-06 14:39:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-05-06 14:42:46

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jkeitel created at 2014-05-06 14:52:11

I have rebased the patch against 6.2.rc2 and added the remaining doctests. All doctests pass for me and the documentation builds.


---

Comment by jkeitel created at 2014-05-06 14:52:11

Changing status from needs_work to needs_review.


---

Comment by rws created at 2014-05-13 06:09:50

patchbot:

```
sage -t --long src/sage/schemes/generic/algebraic_scheme.py  # 10 doctests failed
```



---

Comment by rws created at 2014-05-13 06:09:50

Changing status from needs_review to needs_work.


---

Comment by git created at 2014-05-13 07:59:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jkeitel created at 2014-05-13 08:02:00

Changing status from needs_work to needs_review.


---

Comment by jkeitel created at 2014-05-13 08:02:00

Thank you for that, I don't know how I missed this - I thought I ran all the tests in /schemes/. In any case, it was just a few trivial changes and this time I ran long doctests on all of sage. Some dev script failures, but these might be due to the machine I was running the tests on, so I'm putting this back to needs review.


---

Comment by novoselt created at 2014-05-13 18:16:17

There are some docstrings with no input/output, which is fine since there is a reference to another docstring, but there are also no examples. Shouldn't they be added so that e.g. `TestSuite` is applied to resulting classes?


---

Comment by novoselt created at 2014-05-13 22:38:36

There are multiple references to "the criteria of :class:`ToricEmbedding<ToricEmbedding_Mixin>`" yet upon looking into docstrings of that class these criteria are not clear. There are also tests where it seems that the same morphisms are constructed, yet they compare unequal. Would be nice to have a precise definition of what is considered an embedding morphism and why it is necessary to compare equal morphisms as unequal.


---

Comment by novoselt created at 2014-05-13 22:38:36

Changing status from needs_review to needs_work.
