# Issue 14916: Check embedding morphism when comparing two toric varieties

archive/issues_014916.json:
```json
{
    "body": "CC:  @vbraun @novoselt\n\nKeywords: toric\n\nAt the moment two toric varieties are taken to be equal if *their fans are the same, names of variables are the same and stored in the same order,          and base fields are the same*, independent of whether they have the same embedding morphism or not.\n\nWhat does that imply? Since ToricDivisorGroup inherits from UniqueRepresentation, two toric varieties that only differ in their embedding will share the same ToricDivisorGroup object and therefore a ToricDivisor created by a variety will reference the variety that first created its ToricDivisorGroup object, independent of whether that's correct or not.\n\nAs a consequence, we have the following behavior:\n\n\n```\nsage: P2 = toric_varieties.P(2)\nsage: variety1 = P2.affine_patch(2)\nsage: variety2 = ToricVariety(variety1.fan())\nsage: variety1 == variety2\nTrue\nsage: div1 = variety1.divisor(Cone([(1,0)]))\nsage: div2 = variety2.divisor(Cone([(1,0)]))\nsage: div1.scheme().embedding_morphism()\nScheme morphism:\n  From: 2-d affine toric variety\n  To:   2-d CPR-Fano toric variety covered by 3 affine patches\n  Defn: Defined on coordinates by sending [z0 : z1] to\n        [z0 : z1 : 1]\nsage: div2.scheme().embedding_morphism() # should produce an exception\nScheme morphism:\n  From: 2-d affine toric variety\n  To:   2-d CPR-Fano toric variety covered by 3 affine patches\n  Defn: Defined on coordinates by sending [z0 : z1] to\n        [z0 : z1 : 1]\nsage: div2.scheme() is variety2\nFalse\nsage: div2.scheme() is variety1\nTrue\n```\n\nWhile this set-up might seem highly artificial, in the context of toric fibrations in #12892 one naturally gets fiber varieties that only differ in their embedding.\n\nUnless there are arguments against it, I therefore suggest to extend `ToricVariety_field.__cmp__` to include the embedding morphism.\n\nIssue created by migration from https://trac.sagemath.org/ticket/15153\n\n",
    "created_at": "2013-09-04T07:35:52Z",
    "labels": [
        "algebraic geometry",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Check embedding morphism when comparing two toric varieties",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14916",
    "user": "jkeitel"
}
```
CC:  @vbraun @novoselt

Keywords: toric

At the moment two toric varieties are taken to be equal if *their fans are the same, names of variables are the same and stored in the same order,          and base fields are the same*, independent of whether they have the same embedding morphism or not.

What does that imply? Since ToricDivisorGroup inherits from UniqueRepresentation, two toric varieties that only differ in their embedding will share the same ToricDivisorGroup object and therefore a ToricDivisor created by a variety will reference the variety that first created its ToricDivisorGroup object, independent of whether that's correct or not.

As a consequence, we have the following behavior:


```
sage: P2 = toric_varieties.P(2)
sage: variety1 = P2.affine_patch(2)
sage: variety2 = ToricVariety(variety1.fan())
sage: variety1 == variety2
True
sage: div1 = variety1.divisor(Cone([(1,0)]))
sage: div2 = variety2.divisor(Cone([(1,0)]))
sage: div1.scheme().embedding_morphism()
Scheme morphism:
  From: 2-d affine toric variety
  To:   2-d CPR-Fano toric variety covered by 3 affine patches
  Defn: Defined on coordinates by sending [z0 : z1] to
        [z0 : z1 : 1]
sage: div2.scheme().embedding_morphism() # should produce an exception
Scheme morphism:
  From: 2-d affine toric variety
  To:   2-d CPR-Fano toric variety covered by 3 affine patches
  Defn: Defined on coordinates by sending [z0 : z1] to
        [z0 : z1 : 1]
sage: div2.scheme() is variety2
False
sage: div2.scheme() is variety1
True
```

While this set-up might seem highly artificial, in the context of toric fibrations in #12892 one naturally gets fiber varieties that only differ in their embedding.

Unless there are arguments against it, I therefore suggest to extend `ToricVariety_field.__cmp__` to include the embedding morphism.

Issue created by migration from https://trac.sagemath.org/ticket/15153





---

archive/issue_comments_190532.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-09-04T08:07:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190532",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_190533.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-09-04T08:11:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190533",
    "user": "jkeitel"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_190534.json:
```json
{
    "body": "I've pushed a small patch and would be grateful for any comments. Thank you!",
    "created_at": "2013-09-04T08:11:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190534",
    "user": "jkeitel"
}
```

I've pushed a small patch and would be grateful for any comments. Thank you!



---

archive/issue_comments_190535.json:
```json
{
    "body": "I think thats not good enough, sometimes we set the `_embedding_morphism` attribute directly. This would then change the already-cached class. The proper way would be a derived class for toric variety with embedding, and then make those unique.",
    "created_at": "2013-09-04T09:50:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190535",
    "user": "@vbraun"
}
```

I think thats not good enough, sometimes we set the `_embedding_morphism` attribute directly. This would then change the already-cached class. The proper way would be a derived class for toric variety with embedding, and then make those unique.



---

archive/issue_comments_190536.json:
```json
{
    "body": "We definitely want to have isomorphic varieties with different embedding and varieties probably have to be unique as well. Should then `embedding_morphism` become a part of the constructor (with default value `None`) and setting it generate a new instance? I am not sure if a derived class will simplify the situation here.",
    "created_at": "2013-09-04T19:34:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190536",
    "user": "@novoselt"
}
```

We definitely want to have isomorphic varieties with different embedding and varieties probably have to be unique as well. Should then `embedding_morphism` become a part of the constructor (with default value `None`) and setting it generate a new instance? I am not sure if a derived class will simplify the situation here.



---

archive/issue_comments_190537.json:
```json
{
    "body": "Replying to [comment:5 novoselt]:\n> We definitely want to have isomorphic varieties with different embedding and varieties probably have to be unique as well. Should then `embedding_morphism` become a part of the constructor (with default value `None`) and setting it generate a new instance? I am not sure if a derived class will simplify the situation here.\n\nThis sounds good to me, but then again I am not sure that I understood how Volker's suggestion would have solved the problem. Whenever you're allowed to modify `._embedding_morphism` you have to make sure you throw out all UniqueRepresentations you are referring to, don't you? So creating a new ToricVariety sounds like a clean solution.\n\nIn any case, I just realized that the patch also needs some additional work. Several of the ToricMorphisms inherit directly from SchemeMorphism and inherit their `__cmp__` directly from Element, which seems to access its parent (i.e. the ToricVariety) and therefore causes a RecursionError. How can one circumvent that? Come up with __cmp__ methods (maybe such as comparing `_fan_morphism`) for the ToricMorphism classes?",
    "created_at": "2013-09-04T20:13:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190537",
    "user": "jkeitel"
}
```

Replying to [comment:5 novoselt]:
> We definitely want to have isomorphic varieties with different embedding and varieties probably have to be unique as well. Should then `embedding_morphism` become a part of the constructor (with default value `None`) and setting it generate a new instance? I am not sure if a derived class will simplify the situation here.

This sounds good to me, but then again I am not sure that I understood how Volker's suggestion would have solved the problem. Whenever you're allowed to modify `._embedding_morphism` you have to make sure you throw out all UniqueRepresentations you are referring to, don't you? So creating a new ToricVariety sounds like a clean solution.

In any case, I just realized that the patch also needs some additional work. Several of the ToricMorphisms inherit directly from SchemeMorphism and inherit their `__cmp__` directly from Element, which seems to access its parent (i.e. the ToricVariety) and therefore causes a RecursionError. How can one circumvent that? Come up with __cmp__ methods (maybe such as comparing `_fan_morphism`) for the ToricMorphism classes?



---

archive/issue_comments_190538.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-09-04T20:13:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190538",
    "user": "jkeitel"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_190539.json:
```json
{
    "body": "I basically agree that we should make `embedding_morphism` part of the constructor. The only design question is whether we always want to have a `embedding_morphism()` method that then raises an exception by default. Alternatively, we could have a simple mixin class that just tracks the embedding morphism part. Then you'd have to define\n\n```\nclass ToricVarietyWithEmbedding_class(Embedding_mixin, ToricVariety_class):\n    pass\n```\n\nand similarly for AffineToricVariety, !CPRFanoToricVariety. Its a few extra lines over the plain approach where everything has a `embedding_morphism()` method but with the advantage that you wouldn't have the extra method if you don't need it.",
    "created_at": "2013-09-04T20:39:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190539",
    "user": "@vbraun"
}
```

I basically agree that we should make `embedding_morphism` part of the constructor. The only design question is whether we always want to have a `embedding_morphism()` method that then raises an exception by default. Alternatively, we could have a simple mixin class that just tracks the embedding morphism part. Then you'd have to define

```
class ToricVarietyWithEmbedding_class(Embedding_mixin, ToricVariety_class):
    pass
```

and similarly for AffineToricVariety, !CPRFanoToricVariety. Its a few extra lines over the plain approach where everything has a `embedding_morphism()` method but with the advantage that you wouldn't have the extra method if you don't need it.



---

archive/issue_comments_190540.json:
```json
{
    "body": "I think with subclasses `__cmp__` of the parent class will have to return 0 only if both elements have exactly they type of the parent class, i.e. not are just instances of the parent class. This seem cumbersome to me, so I'd rather have always have this \"extra\" method returning either `None` or throwing an exception if it was not set in the constructor.",
    "created_at": "2013-09-04T21:31:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190540",
    "user": "@novoselt"
}
```

I think with subclasses `__cmp__` of the parent class will have to return 0 only if both elements have exactly they type of the parent class, i.e. not are just instances of the parent class. This seem cumbersome to me, so I'd rather have always have this "extra" method returning either `None` or throwing an exception if it was not set in the constructor.



---

archive/issue_comments_190541.json:
```json
{
    "body": "Either way you'll have to return 0 only if the embeddings are the same. So for all purposes the variety with and without embedding are distinct, and we may just as well make the types different by making the embedding case a subclass. Also, it would be nice if `_repr_` would distinguish the case with and without embedding so there is not too much of a surprise if they do not compare as equal.",
    "created_at": "2013-09-04T21:37:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190541",
    "user": "@vbraun"
}
```

Either way you'll have to return 0 only if the embeddings are the same. So for all purposes the variety with and without embedding are distinct, and we may just as well make the types different by making the embedding case a subclass. Also, it would be nice if `_repr_` would distinguish the case with and without embedding so there is not too much of a surprise if they do not compare as equal.



---

archive/issue_comments_190542.json:
```json
{
    "body": "To always compare embeddings varieties without embedding should be aware of there existence, in which case it really seems to me that they are of the same class, but with different values of attributes.\n\nAdjusting `_repr_` is a great idea!",
    "created_at": "2013-09-04T21:41:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190542",
    "user": "@novoselt"
}
```

To always compare embeddings varieties without embedding should be aware of there existence, in which case it really seems to me that they are of the same class, but with different values of attributes.

Adjusting `_repr_` is a great idea!



---

archive/issue_comments_190543.json:
```json
{
    "body": "Okay, if I understand correctly, then regardless of how it is implemented, one would want to have\n1. An argument `embedding_morphism` in the constructor of `ToricVariety,CPRFanoToricVariety` and replace all accesses to `._embedding_morphism` by creating new varieties.\n2. A distinction between cases with and without embedding in `_repr_`.\n\nHowever, I am still not sure how to deal with the comparison of two varieties with embedding. I suppose one really only wants to morphisms to be equal if they have equal domains and codomains. As mentioned above, however, this leads to an infinite recursion loop. Should one implement some sort of comparison method for the morphisms that does not check equality of domains or is there another more elegant way around this problem?",
    "created_at": "2013-09-05T07:36:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190543",
    "user": "jkeitel"
}
```

Okay, if I understand correctly, then regardless of how it is implemented, one would want to have
1. An argument `embedding_morphism` in the constructor of `ToricVariety,CPRFanoToricVariety` and replace all accesses to `._embedding_morphism` by creating new varieties.
2. A distinction between cases with and without embedding in `_repr_`.

However, I am still not sure how to deal with the comparison of two varieties with embedding. I suppose one really only wants to morphisms to be equal if they have equal domains and codomains. As mentioned above, however, this leads to an infinite recursion loop. Should one implement some sort of comparison method for the morphisms that does not check equality of domains or is there another more elegant way around this problem?



---

archive/issue_comments_190544.json:
```json
{
    "body": "The alternative would be to have a way to compare the varieties ignoring their embedding, and only compare domain/codomain of morphisms ignoring the embedding. This is where the separate classes shine as you can just call the base `ToricVariety_field.__cmp__(self, other)` directly. If its all munged into one class then you have to invent yet another method `compare_without_embedding()` or so.\n\nBut, as you said, one can also just make put comparison of morphisms into a method \n`compare(self, other, ignore_domain=False, ignore_codomain=False)`.",
    "created_at": "2013-09-05T10:48:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190544",
    "user": "@vbraun"
}
```

The alternative would be to have a way to compare the varieties ignoring their embedding, and only compare domain/codomain of morphisms ignoring the embedding. This is where the separate classes shine as you can just call the base `ToricVariety_field.__cmp__(self, other)` directly. If its all munged into one class then you have to invent yet another method `compare_without_embedding()` or so.

But, as you said, one can also just make put comparison of morphisms into a method 
`compare(self, other, ignore_domain=False, ignore_codomain=False)`.



---

archive/issue_comments_190545.json:
```json
{
    "body": "That actually sounds very nice. Having two separate classes may really be the cleanest option. I think one would have to have to `compare` methods for ToricVariety anyway because of the following scenario:\n\nLet f_i be the embedding of A_i into B_i. When comparing f_1 to f_2 the `SchemeMorphism_something.__cmp__` method must use the old `ToricVariety_field.__cmp__` method to avoid falling into an infinite loop.\n\nUnless there are objections, I think I'll try and implement something along these lines and push it here once there is some progress. \n\nThanks for all the help so far!",
    "created_at": "2013-09-05T11:49:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190545",
    "user": "jkeitel"
}
```

That actually sounds very nice. Having two separate classes may really be the cleanest option. I think one would have to have to `compare` methods for ToricVariety anyway because of the following scenario:

Let f_i be the embedding of A_i into B_i. When comparing f_1 to f_2 the `SchemeMorphism_something.__cmp__` method must use the old `ToricVariety_field.__cmp__` method to avoid falling into an infinite loop.

Unless there are objections, I think I'll try and implement something along these lines and push it here once there is some progress. 

Thanks for all the help so far!



---

archive/issue_comments_190546.json:
```json
{
    "body": "My problems with extra classes just for the sake of embedding:\n* need to have these extra classes for every flavour (toric, affine toric, CPRFano, maybe others later) - not difficult, but annoying;\n* anything that constructs a new toric variety should properly handle the class - of course, this may have to be done anyway to properly handle embedding attribute;\n* more serious: comparison of varieties without embedding is unclear to me: if `X` is just a variety and `Y` is the same but embedded (and realized by an extra class), then `cmp(X, Y)` will call `X.__cmp__(Y)`. This should just compare varieties by themselves and they are equal. On the other hand `Y.__cmp__(X)` will take into account embeddings, so they are not equal, which is bad. To fix it, the first method already should be aware of the embedding and take it into account.\n\nNote that `==` in general for toric framework means \"Sage-equal\" (and in fact should be the same as `is` if varieties are made unique). This more or less was how this ticket appeared - this sense is not handled correctly and it breaks technical things. If one wants more mathematical equality, probably the correct way is to call already existing (or not?-) `is_isomorphic`, which clearly should not take into account embedding.\n\nA possible solution to recursion is to not call embedding comparison/equality in `__cmp__` of toric varieties, but rather check that domains/codomains are the same in our internal sense and then check the defining map of the embedding to be the same, i.e. its data apart from domain/codomain. This should make it possible to compare embedding morphisms directly too.",
    "created_at": "2013-09-05T15:02:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190546",
    "user": "@novoselt"
}
```

My problems with extra classes just for the sake of embedding:
* need to have these extra classes for every flavour (toric, affine toric, CPRFano, maybe others later) - not difficult, but annoying;
* anything that constructs a new toric variety should properly handle the class - of course, this may have to be done anyway to properly handle embedding attribute;
* more serious: comparison of varieties without embedding is unclear to me: if `X` is just a variety and `Y` is the same but embedded (and realized by an extra class), then `cmp(X, Y)` will call `X.__cmp__(Y)`. This should just compare varieties by themselves and they are equal. On the other hand `Y.__cmp__(X)` will take into account embeddings, so they are not equal, which is bad. To fix it, the first method already should be aware of the embedding and take it into account.

Note that `==` in general for toric framework means "Sage-equal" (and in fact should be the same as `is` if varieties are made unique). This more or less was how this ticket appeared - this sense is not handled correctly and it breaks technical things. If one wants more mathematical equality, probably the correct way is to call already existing (or not?-) `is_isomorphic`, which clearly should not take into account embedding.

A possible solution to recursion is to not call embedding comparison/equality in `__cmp__` of toric varieties, but rather check that domains/codomains are the same in our internal sense and then check the defining map of the embedding to be the same, i.e. its data apart from domain/codomain. This should make it possible to compare embedding morphisms directly too.



---

archive/issue_comments_190547.json:
```json
{
    "body": "You just have to add\n\n```python\nclass FooToricVarietyWithEmbedding_class(Embedding_mixin, FooToricVariety_class):\n    pass\n```\n\nfor each subclass of toric variety. I don't think its too much effort. There are further tricks with dynamic classes and categories if you really want to avoid it, but at this point I don't think its worth it since there are not going to be that many subclasses of toric variety.\n\nAs for comparison, I think it should just always be unequal if the types differ. So an AffineToricVariety is always different from a ToricVariety, and a variety with embedding is always different from a variety without embedding. The `==` comparison implicitly means: can be interchanged freely for the purposes of caching. This can be implemented easily in the base class without knowing about the embedding:\n\n```python\n    def __init__(self, other):   # in ToricVariety_field\n        c = cmp(self.__class__, other.__class__)\n        if c != 0:\n            return c\n        ...\n```\n",
    "created_at": "2013-09-05T15:19:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190547",
    "user": "@vbraun"
}
```

You just have to add

```python
class FooToricVarietyWithEmbedding_class(Embedding_mixin, FooToricVariety_class):
    pass
```

for each subclass of toric variety. I don't think its too much effort. There are further tricks with dynamic classes and categories if you really want to avoid it, but at this point I don't think its worth it since there are not going to be that many subclasses of toric variety.

As for comparison, I think it should just always be unequal if the types differ. So an AffineToricVariety is always different from a ToricVariety, and a variety with embedding is always different from a variety without embedding. The `==` comparison implicitly means: can be interchanged freely for the purposes of caching. This can be implemented easily in the base class without knowing about the embedding:

```python
    def __init__(self, other):   # in ToricVariety_field
        c = cmp(self.__class__, other.__class__)
        if c != 0:
            return c
        ...
```




---

archive/issue_comments_190548.json:
```json
{
    "body": "OK, hard to argue ;-) Although new classes probably have to include docstrings with doctests.",
    "created_at": "2013-09-05T15:26:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190548",
    "user": "@novoselt"
}
```

OK, hard to argue ;-) Although new classes probably have to include docstrings with doctests.



---

archive/issue_comments_190549.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:",
    "created_at": "2013-09-06T09:56:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190549",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:



---

archive/issue_comments_190550.json:
```json
{
    "body": "Okay, I've tried to implement your suggestions. Although the (modified) doc tests run I am sure that there are mistakes / things that could be done more elegantly in my patch and I'd very much appreciate your comments.\n\nMaybe a couple of things right away:\n- I couldn't figure out how to use super to initialize both `EmbeddedToricVariety_Mixin, ToricVariety_field` in the constructor of `ToricVarietyWithEmbedding_field` and analogously for the Fano case.\n- Another problem with super: I could not replace `ToricVariety_field.__cmp__(self, right)` by some construction like `super(self.__class__, self)` in `EmbeddedToricVariety_Mixin` despite comments and help from Volker. (Apparently I don't properly understand how multiple inheritance works in python)\n- variety.affine_patch(i) now returns patches whose embedding morphisms are given by Morphisms defined through FanMorphisms instead of polynomal ones, but one can of course get the old representation via `patch.embedding_morphism().as_polynomial_map()`\n\nAlso, the morphisms in #12892 will need to implement short `__cmp__` methods just as I did for the two morphism classes in the above patch.\n\nMany thanks already!",
    "created_at": "2013-09-06T10:52:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190550",
    "user": "jkeitel"
}
```

Okay, I've tried to implement your suggestions. Although the (modified) doc tests run I am sure that there are mistakes / things that could be done more elegantly in my patch and I'd very much appreciate your comments.

Maybe a couple of things right away:
- I couldn't figure out how to use super to initialize both `EmbeddedToricVariety_Mixin, ToricVariety_field` in the constructor of `ToricVarietyWithEmbedding_field` and analogously for the Fano case.
- Another problem with super: I could not replace `ToricVariety_field.__cmp__(self, right)` by some construction like `super(self.__class__, self)` in `EmbeddedToricVariety_Mixin` despite comments and help from Volker. (Apparently I don't properly understand how multiple inheritance works in python)
- variety.affine_patch(i) now returns patches whose embedding morphisms are given by Morphisms defined through FanMorphisms instead of polynomal ones, but one can of course get the old representation via `patch.embedding_morphism().as_polynomial_map()`

Also, the morphisms in #12892 will need to implement short `__cmp__` methods just as I did for the two morphism classes in the above patch.

Many thanks already!



---

archive/issue_comments_190551.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2013-09-24T15:47:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190551",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_190552.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-09-24T15:50:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190552",
    "user": "jkeitel"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_190553.json:
```json
{
    "body": "Hi,\n\nI've now included the toric morphisms introduced by #12892 and implemented comparison methods for them. I realize that my git usage wasn't that great - many commits and an unnecessary merge. Won't happen again!\n\nI'd still appreciate comments on the patch.\n\nRegards,\nJan",
    "created_at": "2013-09-24T15:50:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190553",
    "user": "jkeitel"
}
```

Hi,

I've now included the toric morphisms introduced by #12892 and implemented comparison methods for them. I realize that my git usage wasn't that great - many commits and an unnecessary merge. Won't happen again!

I'd still appreciate comments on the patch.

Regards,
Jan



---

archive/issue_comments_190554.json:
```json
{
    "body": "I am confused by this branch (which is very likely to be my problem) - I try to look at changes since the last Voker's commit and the very last one, but there is a lot of changes to makefile and other general stuff. If I try to start with the next commit, it seems that some embedding-related changes were already done before. So - how do I look at changes related to this ticket only?",
    "created_at": "2013-09-28T17:43:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190554",
    "user": "@novoselt"
}
```

I am confused by this branch (which is very likely to be my problem) - I try to look at changes since the last Voker's commit and the very last one, but there is a lot of changes to makefile and other general stuff. If I try to start with the next commit, it seems that some embedding-related changes were already done before. So - how do I look at changes related to this ticket only?



---

archive/issue_comments_190555.json:
```json
{
    "body": "This is very likely due to my poor handling of git. I wanted to carry over code from the previous patch for the comparison method, but I had already merged an update from the master branch into that. When I therefore merged the comparison method code into Volker's fibrations, it included the changes unrelated to my patch.\nIn the future, I won't do that anymore, but in the mean time you'll probably just have to ignore the changes to the makefile. Sorry about that!",
    "created_at": "2013-09-28T17:49:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190555",
    "user": "jkeitel"
}
```

This is very likely due to my poor handling of git. I wanted to carry over code from the previous patch for the comparison method, but I had already merged an update from the master branch into that. When I therefore merged the comparison method code into Volker's fibrations, it included the changes unrelated to my patch.
In the future, I won't do that anymore, but in the mean time you'll probably just have to ignore the changes to the makefile. Sorry about that!



---

archive/issue_comments_190556.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-09-29T13:25:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190556",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_190557.json:
```json
{
    "body": "Okay, I think this should now work with all the changes Andrey made while reviewing #12892.",
    "created_at": "2013-09-29T13:27:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190557",
    "user": "jkeitel"
}
```

Okay, I think this should now work with all the changes Andrey made while reviewing #12892.



---

archive/issue_comments_190558.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-04-14T09:12:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190558",
    "user": "@rwst"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_190559.json:
```json
{
    "body": "Does not merge cleanly. Please rebase.",
    "created_at": "2014-04-14T09:12:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190559",
    "user": "@rwst"
}
```

Does not merge cleanly. Please rebase.



---

archive/issue_comments_190560.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-06T14:34:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190560",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_190561.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-06T14:39:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190561",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_190562.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2014-05-06T14:42:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190562",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_190563.json:
```json
{
    "body": "I have rebased the patch against 6.2.rc2 and added the remaining doctests. All doctests pass for me and the documentation builds.",
    "created_at": "2014-05-06T14:52:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190563",
    "user": "jkeitel"
}
```

I have rebased the patch against 6.2.rc2 and added the remaining doctests. All doctests pass for me and the documentation builds.



---

archive/issue_comments_190564.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-05-06T14:52:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190564",
    "user": "jkeitel"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_190565.json:
```json
{
    "body": "patchbot:\n\n```\nsage -t --long src/sage/schemes/generic/algebraic_scheme.py  # 10 doctests failed\n```\n",
    "created_at": "2014-05-13T06:09:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190565",
    "user": "@rwst"
}
```

patchbot:

```
sage -t --long src/sage/schemes/generic/algebraic_scheme.py  # 10 doctests failed
```




---

archive/issue_comments_190566.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-05-13T06:09:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190566",
    "user": "@rwst"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_190567.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-13T07:59:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190567",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_190568.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-05-13T08:02:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190568",
    "user": "jkeitel"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_190569.json:
```json
{
    "body": "Thank you for that, I don't know how I missed this - I thought I ran all the tests in /schemes/. In any case, it was just a few trivial changes and this time I ran long doctests on all of sage. Some dev script failures, but these might be due to the machine I was running the tests on, so I'm putting this back to needs review.",
    "created_at": "2014-05-13T08:02:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190569",
    "user": "jkeitel"
}
```

Thank you for that, I don't know how I missed this - I thought I ran all the tests in /schemes/. In any case, it was just a few trivial changes and this time I ran long doctests on all of sage. Some dev script failures, but these might be due to the machine I was running the tests on, so I'm putting this back to needs review.



---

archive/issue_comments_190570.json:
```json
{
    "body": "There are some docstrings with no input/output, which is fine since there is a reference to another docstring, but there are also no examples. Shouldn't they be added so that e.g. `TestSuite` is applied to resulting classes?",
    "created_at": "2014-05-13T18:16:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190570",
    "user": "@novoselt"
}
```

There are some docstrings with no input/output, which is fine since there is a reference to another docstring, but there are also no examples. Shouldn't they be added so that e.g. `TestSuite` is applied to resulting classes?



---

archive/issue_comments_190571.json:
```json
{
    "body": "There are multiple references to \"the criteria of :class:`ToricEmbedding<ToricEmbedding_Mixin>`\" yet upon looking into docstrings of that class these criteria are not clear. There are also tests where it seems that the same morphisms are constructed, yet they compare unequal. Would be nice to have a precise definition of what is considered an embedding morphism and why it is necessary to compare equal morphisms as unequal.",
    "created_at": "2014-05-13T22:38:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190571",
    "user": "@novoselt"
}
```

There are multiple references to "the criteria of :class:`ToricEmbedding<ToricEmbedding_Mixin>`" yet upon looking into docstrings of that class these criteria are not clear. There are also tests where it seems that the same morphisms are constructed, yet they compare unequal. Would be nice to have a precise definition of what is considered an embedding morphism and why it is necessary to compare equal morphisms as unequal.



---

archive/issue_comments_190572.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-05-13T22:38:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14916",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14916#issuecomment-190572",
    "user": "@novoselt"
}
```

Changing status from needs_review to needs_work.
