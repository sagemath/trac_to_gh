# Issue 22562: Strange warnings from numpy/matplotlib when sage is built with clang

archive/issues_022562.json:
```json
{
    "body": "CC:  @dimpase @jhpalmieri\n\nSeen with clang+OS X and freeBSD+clang\n\n```\nsage -t --long src/doc/en/prep/Calculus.rst  # 1 doctest failed\nsage -t --long src/sage/plot/graphics.py  # 1 doctest failed\nsage -t --long src/sage/plot/plot.py  # 1 doctest failed\nsage -t --long src/sage/rings/polynomial/polynomial_real_mpfr_dense.pyx  # 1 doctest failed\nsage -t --long src/sage/structure/coerce.pyx  # 1 doctest failed\n```\n\nAll these doctest fail because an unexpected warning is emitted:\n\n```\nRuntimeWarning: invalid value encountered in greater_equal\n```\n\n`Calculus.rst` and `graphics.py` this is from `matplotlib`\n\n```\n        numpy.float32('1.5') * x\n    :\n    RuntimeWarning: invalid value encountered in multiply\n    1.50000000000000*x\n```\n\nfor the others, from `numpy`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/22799\n\n",
    "created_at": "2017-04-13T02:27:00Z",
    "labels": [
        "porting",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "Strange warnings from numpy/matplotlib when sage is built with clang",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22562",
    "user": "@kiwifb"
}
```
CC:  @dimpase @jhpalmieri

Seen with clang+OS X and freeBSD+clang

```
sage -t --long src/doc/en/prep/Calculus.rst  # 1 doctest failed
sage -t --long src/sage/plot/graphics.py  # 1 doctest failed
sage -t --long src/sage/plot/plot.py  # 1 doctest failed
sage -t --long src/sage/rings/polynomial/polynomial_real_mpfr_dense.pyx  # 1 doctest failed
sage -t --long src/sage/structure/coerce.pyx  # 1 doctest failed
```

All these doctest fail because an unexpected warning is emitted:

```
RuntimeWarning: invalid value encountered in greater_equal
```

`Calculus.rst` and `graphics.py` this is from `matplotlib`

```
        numpy.float32('1.5') * x
    :
    RuntimeWarning: invalid value encountered in multiply
    1.50000000000000*x
```

for the others, from `numpy`.

Issue created by migration from https://trac.sagemath.org/ticket/22799





---

archive/issue_comments_314410.json:
```json
{
    "body": "Both polynomial_real_mpfr_dense.pyx and coerce.py are the same test - more or less\n\n```\n        sage: import numpy\n        sage: x = polygen(RR)\n        sage: numpy.float32('1.5') * x\n        1.50000000000000*x\n        sage: x * numpy.float32('1.5')\n        1.50000000000000*x\n```\n\nThere are references to #8426 and #18076.",
    "created_at": "2017-04-13T05:21:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314410",
    "user": "@kiwifb"
}
```

Both polynomial_real_mpfr_dense.pyx and coerce.py are the same test - more or less

```
        sage: import numpy
        sage: x = polygen(RR)
        sage: numpy.float32('1.5') * x
        1.50000000000000*x
        sage: x * numpy.float32('1.5')
        1.50000000000000*x
```

There are references to #8426 and #18076.



---

archive/issue_comments_314411.json:
```json
{
    "body": "As I suspected, both warning ultimately originate from inside `numpy`. The `multiply` warning comes from `numpy/core/tests/test_datetime.py`??? And `greater_equal` from `numpy/lib/tests/test_nanfunctions.py`, comparison with NaN.",
    "created_at": "2017-04-13T08:00:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314411",
    "user": "@kiwifb"
}
```

As I suspected, both warning ultimately originate from inside `numpy`. The `multiply` warning comes from `numpy/core/tests/test_datetime.py`??? And `greater_equal` from `numpy/lib/tests/test_nanfunctions.py`, comparison with NaN.



---

archive/issue_comments_314412.json:
```json
{
    "body": "I tried to compare the build logs for numpy (on OS X) using `gcc` vs. `clang`. I found a few errors or warnings in the clang build that are not present in the gcc build. For example:\n\n```\nnumpy/core/src/multiarray/datetime.c:781:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n    if (out_meta->base == -1) {\n        ~~~~~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:1847:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n    if (out_meta->base == -1) {\n        ~~~~~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:1976:20: warning: comparison of unsigned enum expression >= 0 is always true [-Wtautological-compare]\n    if (meta->base >= 0 && meta->base < (NPY_FR_GENERIC + 1)) {\n        ~~~~~~~~~~ ^  ~\nnumpy/core/src/multiarray/datetime.c:2395:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2411:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1 || meta->base == NPY_FR_GENERIC) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2424:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2463:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2495:28: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n            if (meta->base == -1) {\n                ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2522:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2598:28: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n            if (meta->base == -1) {\n                ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2609:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2622:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2661:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2730:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:2784:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n        if (meta->base == -1) {\n            ~~~~~~~~~~ ^  ~~\nnumpy/core/src/multiarray/datetime.c:3118:26: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]\n    if (inout_meta->base == -1) {\n        ~~~~~~~~~~~~~~~~ ^  ~~\n16 warnings generated.\n```\n\nThere are quite a few warnings in the clang build related to comparisons.",
    "created_at": "2017-04-14T19:02:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314412",
    "user": "@jhpalmieri"
}
```

I tried to compare the build logs for numpy (on OS X) using `gcc` vs. `clang`. I found a few errors or warnings in the clang build that are not present in the gcc build. For example:

```
numpy/core/src/multiarray/datetime.c:781:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
    if (out_meta->base == -1) {
        ~~~~~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:1847:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
    if (out_meta->base == -1) {
        ~~~~~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:1976:20: warning: comparison of unsigned enum expression >= 0 is always true [-Wtautological-compare]
    if (meta->base >= 0 && meta->base < (NPY_FR_GENERIC + 1)) {
        ~~~~~~~~~~ ^  ~
numpy/core/src/multiarray/datetime.c:2395:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2411:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1 || meta->base == NPY_FR_GENERIC) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2424:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2463:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2495:28: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
            if (meta->base == -1) {
                ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2522:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2598:28: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
            if (meta->base == -1) {
                ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2609:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2622:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2661:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2730:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:2784:24: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
        if (meta->base == -1) {
            ~~~~~~~~~~ ^  ~~
numpy/core/src/multiarray/datetime.c:3118:26: warning: comparison of constant -1 with expression of type 'NPY_DATETIMEUNIT' is always false [-Wtautological-constant-out-of-range-compare]
    if (inout_meta->base == -1) {
        ~~~~~~~~~~~~~~~~ ^  ~~
16 warnings generated.
```

There are quite a few warnings in the clang build related to comparisons.



---

archive/issue_comments_314413.json:
```json
{
    "body": "By the way, the page https://www.scipy.org/scipylib/building/macosx.html says that we should use\n\n```\nexport FFLAGS=-ff2c\n```\n\nalong with the remark 'The Fortran flag \u201c-ff2c\u201d has been reported to be necessary.' We do not do this. Is there any reason to believe that this would help?",
    "created_at": "2017-04-14T21:57:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314413",
    "user": "@jhpalmieri"
}
```

By the way, the page https://www.scipy.org/scipylib/building/macosx.html says that we should use

```
export FFLAGS=-ff2c
```

along with the remark 'The Fortran flag “-ff2c” has been reported to be necessary.' We do not do this. Is there any reason to believe that this would help?



---

archive/issue_comments_314414.json:
```json
{
    "body": "Replying to [comment:5 jhpalmieri]:\n> By the way, the page https://www.scipy.org/scipylib/building/macosx.html says that we should use\n> {{{\n> export FFLAGS=-ff2c\n> }}}\n> along with the remark 'The Fortran flag \u201c-ff2c\u201d has been reported to be necessary.' We do not do this. Is there any reason to believe that this would help?\n\nIf we were using g77 for sure it would be necessary. The page itself is dated in my opinion. I'll dig a bit around the compilation warnings, there may be over-optimisation somewhere.",
    "created_at": "2017-04-15T02:17:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314414",
    "user": "@kiwifb"
}
```

Replying to [comment:5 jhpalmieri]:
> By the way, the page https://www.scipy.org/scipylib/building/macosx.html says that we should use
> {{{
> export FFLAGS=-ff2c
> }}}
> along with the remark 'The Fortran flag “-ff2c” has been reported to be necessary.' We do not do this. Is there any reason to believe that this would help?

If we were using g77 for sure it would be necessary. The page itself is dated in my opinion. I'll dig a bit around the compilation warnings, there may be over-optimisation somewhere.



---

archive/issue_comments_314415.json:
```json
{
    "body": "It is at least interesting that we are getting compiler warnings on some of the files related to doctest failures, and furthermore on comparisons.",
    "created_at": "2017-04-15T02:58:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314415",
    "user": "@jhpalmieri"
}
```

It is at least interesting that we are getting compiler warnings on some of the files related to doctest failures, and furthermore on comparisons.



---

archive/issue_comments_314416.json:
```json
{
    "body": "Replying to [comment:7 jhpalmieri]:\n> It is at least interesting that we are getting compiler warnings on some of the files related to doctest failures, and furthermore on comparisons.\n\nIt is indeed.",
    "created_at": "2017-04-15T03:00:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314416",
    "user": "@kiwifb"
}
```

Replying to [comment:7 jhpalmieri]:
> It is at least interesting that we are getting compiler warnings on some of the files related to doctest failures, and furthermore on comparisons.

It is indeed.



---

archive/issue_comments_314417.json:
```json
{
    "body": "Just for those wondering: upgrading to numpy 1.12.1 doesn't change a thing.",
    "created_at": "2017-04-15T03:16:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314417",
    "user": "@kiwifb"
}
```

Just for those wondering: upgrading to numpy 1.12.1 doesn't change a thing.



---

archive/issue_comments_314418.json:
```json
{
    "body": "I am not sure `numpy` is the root cause of the problem. I recompiled `numpy` using `x86_64-apple-darwin16.5.0-gcc` which is currently installed by gfortran package. I remove gcc, but not more sophisticated names like the above. The error persists. Of course the above compiler is not bootstraped which could have an impact. \n\nHowever, I am wondering if something funny happens in the coercion framework.",
    "created_at": "2017-04-15T20:50:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314418",
    "user": "@kiwifb"
}
```

I am not sure `numpy` is the root cause of the problem. I recompiled `numpy` using `x86_64-apple-darwin16.5.0-gcc` which is currently installed by gfortran package. I remove gcc, but not more sophisticated names like the above. The error persists. Of course the above compiler is not bootstraped which could have an impact. 

However, I am wondering if something funny happens in the coercion framework.



---

archive/issue_comments_314419.json:
```json
{
    "body": "I suspect that the bug is not (only) in coersion, but in numpy's float conversion/truncation module; on FreeBSD/clang I get no warning with `numpy.float` or\n`numpy.float128`, but I do get warnings with `numpy.float<k>` with `k<128`:\n\n```\nsage: import numpy as np\nsage: x=polygen(RR)\nsage: np.float32('1.5')*x\n/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply\n  #!/usr/bin/env python\n1.50000000000000*x\nsage: np.float16('1.5')*x\n/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply\n  #!/usr/bin/env python\n1.50000000000000*x\nsage: np.float64('1.5')*x\n/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply\n  #!/usr/bin/env python\n1.50000000000000*x\nsage: np.float128('1.5')*x\n1.50000000000000*x\nsage: np.float('1.5')*x\n1.50000000000000*x\n```\n\nThat's of course still a mystery, and a combination of the fact that it only happens with `x` coming from `RealField()` (its precision does not matter, I tried many values, with the same effect).",
    "created_at": "2017-04-21T08:39:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314419",
    "user": "@dimpase"
}
```

I suspect that the bug is not (only) in coersion, but in numpy's float conversion/truncation module; on FreeBSD/clang I get no warning with `numpy.float` or
`numpy.float128`, but I do get warnings with `numpy.float<k>` with `k<128`:

```
sage: import numpy as np
sage: x=polygen(RR)
sage: np.float32('1.5')*x
/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply
  #!/usr/bin/env python
1.50000000000000*x
sage: np.float16('1.5')*x
/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply
  #!/usr/bin/env python
1.50000000000000*x
sage: np.float64('1.5')*x
/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply
  #!/usr/bin/env python
1.50000000000000*x
sage: np.float128('1.5')*x
1.50000000000000*x
sage: np.float('1.5')*x
1.50000000000000*x
```

That's of course still a mystery, and a combination of the fact that it only happens with `x` coming from `RealField()` (its precision does not matter, I tried many values, with the same effect).



---

archive/issue_comments_314420.json:
```json
{
    "body": "Good observation, I had only tried 64.",
    "created_at": "2017-04-21T10:55:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314420",
    "user": "@kiwifb"
}
```

Good observation, I had only tried 64.



---

archive/issue_comments_314421.json:
```json
{
    "body": "Replying to [ticket:22799 fbissey]:\n> All these doctest fail because an unexpected warning is emitted:\n> {{{\n> RuntimeWarning: invalid value encountered in greater_equal\n> }}}\n\nTraceback please (general rule: when posting bug report, **never** truncate a traceback).",
    "created_at": "2017-04-21T12:19:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314421",
    "user": "@jdemeyer"
}
```

Replying to [ticket:22799 fbissey]:
> All these doctest fail because an unexpected warning is emitted:
> {{{
> RuntimeWarning: invalid value encountered in greater_equal
> }}}

Traceback please (general rule: when posting bug report, **never** truncate a traceback).



---

archive/issue_comments_314422.json:
```json
{
    "body": "Replying to [comment:13 jdemeyer]:\n> Replying to [ticket:22799 fbissey]:\n> > All these doctest fail because an unexpected warning is emitted:\n> > {{{\n> > RuntimeWarning: invalid value encountered in greater_equal\n> > }}}\n> \n> Traceback please (general rule: when posting bug report, **never** truncate a traceback).\n\nthese are very uninformative (it's just a message that comes from the depths of a compiled part of numpy, not causing any interrupts). For instance:\n\n\n```\nFile \"src/sage/rings/polynomial/polynomial_real_mpfr_dense.pyx\", line 21, in sage.rings.polynomial.polynomial_real_mpfr_dense\nFailed example:\n    numpy.float32('1.5') * x\nExpected:\n    1.50000000000000*x\nGot:\n    doctest:warning\n      File \"/usr/home/dima/Sage/sage/src/bin/sage-runtests\", line 89, in <module>\n        err = DC.run()\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/control.py\", line 1134, in run\n        self.run_doctests()\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/control.py\", line 858, in run_doctests\n        self.dispatcher.dispatch()\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 1705, in dispatch\n        self.parallel_dispatch()\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 1595, in parallel_dispatch\n        w.start()  # This might take some time\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 1871, in start\n        super(DocTestWorker, self).start()\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/multiprocessing/process.py\", line 130, in start\n        self._popen = Popen(self)\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/multiprocessing/forking.py\", line 126, in __init__\n        code = process_obj._bootstrap()\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/multiprocessing/process.py\", line 258, in _bootstrap\n        self.run()\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 1844, in run\n        task(self.options, self.outtmpfile, msgpipe, self.result_queue)\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 2137, in __call__\n        runner.run(test)\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 641, in run\n        return self._run(test, compileflags, out)\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 503, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 866, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.rings.polynomial.polynomial_real_mpfr_dense[7]>\", line 1, in <module>\n        numpy.float32('1.5') * x\n    :\n    RuntimeWarning: invalid value encountered in multiply\n    1.50000000000000*x\n```\n\n\nIt's also pretty hard to extract anything useful at the Sage prompt, I tried to set up a numpy interrupt following [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.seterrcall.html#numpy.seterrcall), but it ends up telling me that the interrupt happends at the top level of ipython.",
    "created_at": "2017-04-21T14:15:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314422",
    "user": "@dimpase"
}
```

Replying to [comment:13 jdemeyer]:
> Replying to [ticket:22799 fbissey]:
> > All these doctest fail because an unexpected warning is emitted:
> > {{{
> > RuntimeWarning: invalid value encountered in greater_equal
> > }}}
> 
> Traceback please (general rule: when posting bug report, **never** truncate a traceback).

these are very uninformative (it's just a message that comes from the depths of a compiled part of numpy, not causing any interrupts). For instance:


```
File "src/sage/rings/polynomial/polynomial_real_mpfr_dense.pyx", line 21, in sage.rings.polynomial.polynomial_real_mpfr_dense
Failed example:
    numpy.float32('1.5') * x
Expected:
    1.50000000000000*x
Got:
    doctest:warning
      File "/usr/home/dima/Sage/sage/src/bin/sage-runtests", line 89, in <module>
        err = DC.run()
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/control.py", line 1134, in run
        self.run_doctests()
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/control.py", line 858, in run_doctests
        self.dispatcher.dispatch()
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1705, in dispatch
        self.parallel_dispatch()
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1595, in parallel_dispatch
        w.start()  # This might take some time
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1871, in start
        super(DocTestWorker, self).start()
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/multiprocessing/process.py", line 130, in start
        self._popen = Popen(self)
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/multiprocessing/forking.py", line 126, in __init__
        code = process_obj._bootstrap()
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/multiprocessing/process.py", line 258, in _bootstrap
        self.run()
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 1844, in run
        task(self.options, self.outtmpfile, msgpipe, self.result_queue)
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 2137, in __call__
        runner.run(test)
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 641, in run
        return self._run(test, compileflags, out)
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 503, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/usr/home/dima/Sage/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 866, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.rings.polynomial.polynomial_real_mpfr_dense[7]>", line 1, in <module>
        numpy.float32('1.5') * x
    :
    RuntimeWarning: invalid value encountered in multiply
    1.50000000000000*x
```


It's also pretty hard to extract anything useful at the Sage prompt, I tried to set up a numpy interrupt following [numpy docs](https://docs.scipy.org/doc/numpy/reference/generated/numpy.seterrcall.html#numpy.seterrcall), but it ends up telling me that the interrupt happends at the top level of ipython.



---

archive/issue_comments_314423.json:
```json
{
    "body": "Could you run numpy tests on clang/OSX? I did so on clang/FreeBSD, with some failures in complex arithmetic/functions (mostly numerical noise, but not only)\nMore precisely:\n- untar the numpy tarball in `upstream/`\n- launch `sage -sh`\n- install nose (`pip install nose`)\n- `cd upstream/numpy-1.11.1/numpy/testing`\n- run `./setup.py install`\n- `cd ../core/tests`\n- run `python test*.py`\n\nOn FreeBSD I get\n\n```\nRan 3072 tests in 53.164s\nFAILED (KNOWNFAIL=6, SKIP=4, failures=22)\n```\n\n\nPerhaps we should upgrade to 1.12.1 and see if this helps.",
    "created_at": "2017-04-21T14:50:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314423",
    "user": "@dimpase"
}
```

Could you run numpy tests on clang/OSX? I did so on clang/FreeBSD, with some failures in complex arithmetic/functions (mostly numerical noise, but not only)
More precisely:
- untar the numpy tarball in `upstream/`
- launch `sage -sh`
- install nose (`pip install nose`)
- `cd upstream/numpy-1.11.1/numpy/testing`
- run `./setup.py install`
- `cd ../core/tests`
- run `python test*.py`

On FreeBSD I get

```
Ran 3072 tests in 53.164s
FAILED (KNOWNFAIL=6, SKIP=4, failures=22)
```


Perhaps we should upgrade to 1.12.1 and see if this helps.



---

archive/issue_comments_314424.json:
```json
{
    "body": "I did `./sage -i nose` to install nose, but otherwise followed your instructions. I got\n\n```\nRan 3072 tests in 47.097s\n\nOK (KNOWNFAIL=6, SKIP=4)\n```\n\nI also got this warning many times:\n\n```\n/Users/palmieri/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta2/numpy-1.11.1/numpy/core/tests/test_datetime.py:1114: FutureWarning: In the future, NAT != NAT will be True rather than False.\n```\n",
    "created_at": "2017-04-21T15:55:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314424",
    "user": "@jhpalmieri"
}
```

I did `./sage -i nose` to install nose, but otherwise followed your instructions. I got

```
Ran 3072 tests in 47.097s

OK (KNOWNFAIL=6, SKIP=4)
```

I also got this warning many times:

```
/Users/palmieri/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta2/numpy-1.11.1/numpy/core/tests/test_datetime.py:1114: FutureWarning: In the future, NAT != NAT will be True rather than False.
```




---

archive/issue_comments_314425.json:
```json
{
    "body": "Replying to [comment:16 dimpase]:\n> Perhaps we should upgrade to 1.12.1 and see if this helps.\n\nFirst thing I tried. No changes. But I will try the tests ASAP.",
    "created_at": "2017-04-21T20:13:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314425",
    "user": "@kiwifb"
}
```

Replying to [comment:16 dimpase]:
> Perhaps we should upgrade to 1.12.1 and see if this helps.

First thing I tried. No changes. But I will try the tests ASAP.



---

archive/issue_comments_314426.json:
```json
{
    "body": "So `numpy-1.12.1` \n\n```\n(sage-sh) fbissey@Mirage:tests$ python test*.py\n.................................................................................................................................................................................................................................................................................................................................................................................................................................KKK........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................S.................................................................................................................................................................................................................................................................................................................................................S.........................................................................................................................................................................................................................................................................................................K......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................K...SK.S.......S................................................................................\n----------------------------------------------------------------------\nRan 3167 tests in 81.934s\n\nOK (KNOWNFAIL=6, SKIP=5)\n```\n\nNo warnings.",
    "created_at": "2017-04-21T20:46:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314426",
    "user": "@kiwifb"
}
```

So `numpy-1.12.1` 

```
(sage-sh) fbissey@Mirage:tests$ python test*.py
.................................................................................................................................................................................................................................................................................................................................................................................................................................KKK........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................S.................................................................................................................................................................................................................................................................................................................................................S.........................................................................................................................................................................................................................................................................................................K......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................K...SK.S.......S................................................................................
----------------------------------------------------------------------
Ran 3167 tests in 81.934s

OK (KNOWNFAIL=6, SKIP=5)
```

No warnings.



---

archive/issue_comments_314427.json:
```json
{
    "body": "We're [discussing](https://groups.google.com/d/msg/sage-devel/6lMB-5nKbUY/38Bb65kxBAAJ) this problem on sage-devel and it appears that Sage does not follow the coercion \nframework prescription for the case of `numpy.float32('1.5')*x`, but instead does something that makes numpy unhappy on clang...",
    "created_at": "2017-04-22T22:27:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314427",
    "user": "@dimpase"
}
```

We're [discussing](https://groups.google.com/d/msg/sage-devel/6lMB-5nKbUY/38Bb65kxBAAJ) this problem on sage-devel and it appears that Sage does not follow the coercion 
framework prescription for the case of `numpy.float32('1.5')*x`, but instead does something that makes numpy unhappy on clang...



---

archive/issue_comments_314428.json:
```json
{
    "body": "Replying to [comment:20 dimpase]:\n> it appears that Sage does not follow the coercion \n> framework prescription for the case of `numpy.float32('1.5')*x`\n\nThis has nothing to do with the coercion framework. When doing `a * b`, Python usually calls `type(a).__mul__(a, b)`. If `a` is not a Sage object (as is the case here), then it's the `__mul__` method of `a` which handles this multiplication. Only if this returns `NotImplemented`, then Python will call `type(b).__mul__(a, b)`.",
    "created_at": "2017-04-23T07:34:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314428",
    "user": "@jdemeyer"
}
```

Replying to [comment:20 dimpase]:
> it appears that Sage does not follow the coercion 
> framework prescription for the case of `numpy.float32('1.5')*x`

This has nothing to do with the coercion framework. When doing `a * b`, Python usually calls `type(a).__mul__(a, b)`. If `a` is not a Sage object (as is the case here), then it's the `__mul__` method of `a` which handles this multiplication. Only if this returns `NotImplemented`, then Python will call `type(b).__mul__(a, b)`.



---

archive/issue_comments_314429.json:
```json
{
    "body": "Replying to [comment:21 jdemeyer]:\n> Replying to [comment:20 dimpase]:\n> > it appears that Sage does not follow the coercion \n> > framework prescription for the case of `numpy.float32('1.5')*x`\n> \n> This has nothing to do with the coercion framework. When doing `a * b`, Python usually calls `type(a).__mul__(a, b)`. If `a` is not a Sage object (as is the case here), then it's the `__mul__` method of `a` which handles this multiplication. Only if this returns `NotImplemented`, then Python will call `type(b).__mul__(a, b)`.\n\nAre you saying that the warning comes from \n`type(numpy.float32('1.5')).__mul__()` ? OK, this makes sense---I tried this call on clang/FreeBSD and got the warning in question all right. So we know where to look at.\n\n\nStill, this does not explain why `sage.structure.element.coercion_model.explain()` lies in this case (or in the case `x` comes as the 1st argument).",
    "created_at": "2017-04-23T09:03:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314429",
    "user": "@dimpase"
}
```

Replying to [comment:21 jdemeyer]:
> Replying to [comment:20 dimpase]:
> > it appears that Sage does not follow the coercion 
> > framework prescription for the case of `numpy.float32('1.5')*x`
> 
> This has nothing to do with the coercion framework. When doing `a * b`, Python usually calls `type(a).__mul__(a, b)`. If `a` is not a Sage object (as is the case here), then it's the `__mul__` method of `a` which handles this multiplication. Only if this returns `NotImplemented`, then Python will call `type(b).__mul__(a, b)`.

Are you saying that the warning comes from 
`type(numpy.float32('1.5')).__mul__()` ? OK, this makes sense---I tried this call on clang/FreeBSD and got the warning in question all right. So we know where to look at.


Still, this does not explain why `sage.structure.element.coercion_model.explain()` lies in this case (or in the case `x` comes as the 1st argument).



---

archive/issue_comments_314430.json:
```json
{
    "body": "Replying to [comment:18 fbissey]:\n> Replying to [comment:16 dimpase]:\n> > Perhaps we should upgrade to 1.12.1 and see if this helps.\n> \n> First thing I tried. No changes. But I will try the tests ASAP.\n\nby the way, `__mul__` is changing in 1.12. On 1.11 I get\n\n```\nsage: import numpy as np\nsage: v=np.float32('1.5')\nsage: v*\"bla\"\n/home/dima/Sage/sage-dev/src/bin/sage-ipython:1: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future\n  #!/usr/bin/env python\n'bla'\n```\n\nwhile on 1.12 \n\n```\nsage: v*\"bla\"\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-10-f57c3b7020a0> in <module>()\n----> 1 v*\"bla\"\n\nTypeError: 'numpy.float32' object cannot be interpreted as an index\n```\n",
    "created_at": "2017-04-23T10:08:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314430",
    "user": "@dimpase"
}
```

Replying to [comment:18 fbissey]:
> Replying to [comment:16 dimpase]:
> > Perhaps we should upgrade to 1.12.1 and see if this helps.
> 
> First thing I tried. No changes. But I will try the tests ASAP.

by the way, `__mul__` is changing in 1.12. On 1.11 I get

```
sage: import numpy as np
sage: v=np.float32('1.5')
sage: v*"bla"
/home/dima/Sage/sage-dev/src/bin/sage-ipython:1: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
  #!/usr/bin/env python
'bla'
```

while on 1.12 

```
sage: v*"bla"
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-10-f57c3b7020a0> in <module>()
----> 1 v*"bla"

TypeError: 'numpy.float32' object cannot be interpreted as an index
```




---

archive/issue_comments_314431.json:
```json
{
    "body": "Replying to [comment:22 dimpase]:\n> Still, this does not explain why `sage.structure.element.coercion_model.explain()` lies in this case\n\n`cm.explain()` answers what the coercion model would do if asked to perform this multiplication. It doesn't answer what *Python* does when asked to perform this multiplication.",
    "created_at": "2017-04-23T10:42:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314431",
    "user": "@jdemeyer"
}
```

Replying to [comment:22 dimpase]:
> Still, this does not explain why `sage.structure.element.coercion_model.explain()` lies in this case

`cm.explain()` answers what the coercion model would do if asked to perform this multiplication. It doesn't answer what *Python* does when asked to perform this multiplication.



---

archive/issue_comments_314432.json:
```json
{
    "body": "Replying to [comment:26 jdemeyer]:\n> Replying to [comment:22 dimpase]:\n> > Still, this does not explain why `sage.structure.element.coercion_model.explain()` lies in this case\n> \n> `cm.explain()` answers what the coercion model would do if asked to perform this multiplication. It doesn't answer what *Python* does when asked to perform this multiplication.\n\n- Do you mean that `x*numpy.float32('1.5')` does not use coersion, either? (Otherwise intentionally breaking the code path printed by `coercion_model.explain()` would make a difference---but it does not)\n- Documentation could be much more clear on how he coercion model is (or is not) invoked in particular cases.",
    "created_at": "2017-04-23T13:05:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314432",
    "user": "@dimpase"
}
```

Replying to [comment:26 jdemeyer]:
> Replying to [comment:22 dimpase]:
> > Still, this does not explain why `sage.structure.element.coercion_model.explain()` lies in this case
> 
> `cm.explain()` answers what the coercion model would do if asked to perform this multiplication. It doesn't answer what *Python* does when asked to perform this multiplication.

- Do you mean that `x*numpy.float32('1.5')` does not use coersion, either? (Otherwise intentionally breaking the code path printed by `coercion_model.explain()` would make a difference---but it does not)
- Documentation could be much more clear on how he coercion model is (or is not) invoked in particular cases.



---

archive/issue_comments_314433.json:
```json
{
    "body": "Replying to [comment:27 dimpase]:\n>  - Do you mean that `x*numpy.float32('1.5')` does not use coersion, either?\n\nNo, that would immediately use the coercion model. If you think that there is a bug with `coercion_model.explain()` please open a new self-contained bug.",
    "created_at": "2017-04-23T13:15:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314433",
    "user": "@jdemeyer"
}
```

Replying to [comment:27 dimpase]:
>  - Do you mean that `x*numpy.float32('1.5')` does not use coersion, either?

No, that would immediately use the coercion model. If you think that there is a bug with `coercion_model.explain()` please open a new self-contained bug.



---

archive/issue_comments_314434.json:
```json
{
    "body": "I think that the multiplication in question is done entirely in numpy. (Yes, numpy does have its own polynomial class). \n\n```\nsage: import numpy as np\nsage: v=np.float32('1.5')\nsage: x=polygen(RealField())\nsage: np.multiply(v,x)\n/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply\n  #!/usr/bin/env python\n1.50000000000000*x\nsage: np.multiply(x,v)\n/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply\n  #!/usr/bin/env python\n1.50000000000000*x\n```\n\nI have no idea whether `RR['x']` was designed to be compatible with numpy's polynomials, or this is a coincidence.\nMore computations:\n\n```\nsage: np.multiply(x^3,x-x^2)\n-x^5 + x^4\nsage: np.multiply(v+v*x^3,x-x^2)\n/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply\n  #!/usr/bin/env python\n/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in add\n  #!/usr/bin/env python\n-1.50000000000000*x^5 + 1.50000000000000*x^4 - 1.50000000000000*x^2 + 1.50000000000000*x\nsage: np.multiply(v,v)\n2.25\n```\n\nthis is all for clang/FreeBSD (on Linux with gcc, all of the above passes without warnings).",
    "created_at": "2017-04-24T09:14:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314434",
    "user": "@dimpase"
}
```

I think that the multiplication in question is done entirely in numpy. (Yes, numpy does have its own polynomial class). 

```
sage: import numpy as np
sage: v=np.float32('1.5')
sage: x=polygen(RealField())
sage: np.multiply(v,x)
/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply
  #!/usr/bin/env python
1.50000000000000*x
sage: np.multiply(x,v)
/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply
  #!/usr/bin/env python
1.50000000000000*x
```

I have no idea whether `RR['x']` was designed to be compatible with numpy's polynomials, or this is a coincidence.
More computations:

```
sage: np.multiply(x^3,x-x^2)
-x^5 + x^4
sage: np.multiply(v+v*x^3,x-x^2)
/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply
  #!/usr/bin/env python
/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in add
  #!/usr/bin/env python
-1.50000000000000*x^5 + 1.50000000000000*x^4 - 1.50000000000000*x^2 + 1.50000000000000*x
sage: np.multiply(v,v)
2.25
```

this is all for clang/FreeBSD (on Linux with gcc, all of the above passes without warnings).



---

archive/issue_comments_314435.json:
```json
{
    "body": "I don't see why the doctest\n\n```\n    sage: numpy.float32('1.5') * x\n    1.50000000000000*x\n```\n\nin `sage.rings.polynomial.polynomial_real_mpfr_dense` should pass in the first place, since no Sage coercion is taking place. Do we need to add some sort of conversion from Sage types to numpy types?",
    "created_at": "2017-04-24T19:18:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314435",
    "user": "@jhpalmieri"
}
```

I don't see why the doctest

```
    sage: numpy.float32('1.5') * x
    1.50000000000000*x
```

in `sage.rings.polynomial.polynomial_real_mpfr_dense` should pass in the first place, since no Sage coercion is taking place. Do we need to add some sort of conversion from Sage types to numpy types?



---

archive/issue_comments_314436.json:
```json
{
    "body": "Replying to [comment:34 jhpalmieri]:\n> I don't see why the doctest\n> {{{\n>     sage: numpy.float32('1.5') * x\n>     1.50000000000000*x\n> }}}\n> in `sage.rings.polynomial.polynomial_real_mpfr_dense` should pass in the first place, since no Sage coercion is taking place.\n\nWrong. Let me explain what happens:\n\n1. Python calls `type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)`.\n\n2. Numpy tries to do this multiplication but realizes that it cannot, so it returns `NotImplemented`.\n\n3. Python calls `type(x).__mul__(..., ...)` which involves the coercion model.\n\n4. The coercion model knows how to handle this.\n\nSo the difference between GCC and Clang almost certainly lies in step 2 above.",
    "created_at": "2017-04-24T19:39:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314436",
    "user": "@jdemeyer"
}
```

Replying to [comment:34 jhpalmieri]:
> I don't see why the doctest
> {{{
>     sage: numpy.float32('1.5') * x
>     1.50000000000000*x
> }}}
> in `sage.rings.polynomial.polynomial_real_mpfr_dense` should pass in the first place, since no Sage coercion is taking place.

Wrong. Let me explain what happens:

1. Python calls `type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)`.

2. Numpy tries to do this multiplication but realizes that it cannot, so it returns `NotImplemented`.

3. Python calls `type(x).__mul__(..., ...)` which involves the coercion model.

4. The coercion model knows how to handle this.

So the difference between GCC and Clang almost certainly lies in step 2 above.



---

archive/issue_comments_314437.json:
```json
{
    "body": "In case it helps, I think the `RuntimeWarning` message comes from line 122 of `numpy-1.11.1/numpy/core/src/umath/ufunc_object.c`.",
    "created_at": "2017-04-24T19:44:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314437",
    "user": "@jhpalmieri"
}
```

In case it helps, I think the `RuntimeWarning` message comes from line 122 of `numpy-1.11.1/numpy/core/src/umath/ufunc_object.c`.



---

archive/issue_comments_314438.json:
```json
{
    "body": "Hmm, I was not entirely right. The correct sequence looks like:\n\n1. Python calls `type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)`.\n\n2. Numpy tries to do this multiplication but realizes that it cannot.\n\n3. Numpy \"coerces\" `numpy.float32(1.5)` to `float(1.5)` (a Python float) and calls `float(1.5) * x` instead.\n\n4. Python realizes that it cannot do this multiplication.\n\n5. Python calls `type(x).__mul__(1.5, x)` which is handled by the coercion model.\n\nStill, the difference must be in step 2.",
    "created_at": "2017-04-24T19:49:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314438",
    "user": "@jdemeyer"
}
```

Hmm, I was not entirely right. The correct sequence looks like:

1. Python calls `type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)`.

2. Numpy tries to do this multiplication but realizes that it cannot.

3. Numpy "coerces" `numpy.float32(1.5)` to `float(1.5)` (a Python float) and calls `float(1.5) * x` instead.

4. Python realizes that it cannot do this multiplication.

5. Python calls `type(x).__mul__(1.5, x)` which is handled by the coercion model.

Still, the difference must be in step 2.



---

archive/issue_comments_314439.json:
```json
{
    "body": "If I apply this patch to numpy, then the failing doctests don't fail any more:\n\n```diff\n--- a/numpy/core/src/umath/ufunc_object.c\t2016-06-25 16:59:40.000000000 -0700\n+++ b/numpy/core/src/umath/ufunc_object.c\t2017-04-24 13:10:59.000000000 -0700\n@@ -120,9 +120,6 @@\n     switch(method) {\n     case UFUNC_ERR_WARN:\n         PyOS_snprintf(msg, sizeof(msg), \"%s encountered in %s\", errtype, name);\n-        if (PyErr_Warn(PyExc_RuntimeWarning, msg) < 0) {\n-            goto fail;\n-        }\n         break;\n     case UFUNC_ERR_RAISE:\n         PyErr_Format(PyExc_FloatingPointError, \"%s encountered in %s\",\n```\n\nThis does not explain what's going on, and I don't see a particular reason to think that this is the right solution, but maybe someone who understands Python and/or numpy better might be able to make something productive out of it.",
    "created_at": "2017-04-24T20:38:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314439",
    "user": "@jhpalmieri"
}
```

If I apply this patch to numpy, then the failing doctests don't fail any more:

```diff
--- a/numpy/core/src/umath/ufunc_object.c	2016-06-25 16:59:40.000000000 -0700
+++ b/numpy/core/src/umath/ufunc_object.c	2017-04-24 13:10:59.000000000 -0700
@@ -120,9 +120,6 @@
     switch(method) {
     case UFUNC_ERR_WARN:
         PyOS_snprintf(msg, sizeof(msg), "%s encountered in %s", errtype, name);
-        if (PyErr_Warn(PyExc_RuntimeWarning, msg) < 0) {
-            goto fail;
-        }
         break;
     case UFUNC_ERR_RAISE:
         PyErr_Format(PyExc_FloatingPointError, "%s encountered in %s",
```

This does not explain what's going on, and I don't see a particular reason to think that this is the right solution, but maybe someone who understands Python and/or numpy better might be able to make something productive out of it.



---

archive/issue_comments_314440.json:
```json
{
    "body": "Replying to [comment:37 jdemeyer]:\n> Hmm, I was not entirely right. The correct sequence looks like:\n> \n> 1. Python calls `type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)`.\n> \n> 2. Numpy tries to do this multiplication but realizes that it cannot.\n> \n> 3. Numpy \"coerces\" `numpy.float32(1.5)` to `float(1.5)` (a Python float) and calls `float(1.5) * x` instead.\n> \n> 4. Python realizes that it cannot do this multiplication.\n> \n> 5. Python calls `type(x).__mul__(1.5, x)` which is handled by the coercion model.\n> \n> Still, the difference must be in step 2.\n\nthis theory does not work, as step 2 has nothing to do with `type(x)`---but `type(x)` matters, as can be seen here:\n\n```\nsage: type(x)\n<type 'sage.symbolic.expression.Expression'>\nsage: type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)\n1.5*x\nsage: x=polygen(RDF)\nsage: type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)\n1.5*x\nsage: x=polygen(RR)\nsage: type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)\n/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply\n  #!/usr/bin/env python\n1.50000000000000*x\nsage: float(1.5)*x\n1.50000000000000*x\n```\n",
    "created_at": "2017-04-27T08:24:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314440",
    "user": "@dimpase"
}
```

Replying to [comment:37 jdemeyer]:
> Hmm, I was not entirely right. The correct sequence looks like:
> 
> 1. Python calls `type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)`.
> 
> 2. Numpy tries to do this multiplication but realizes that it cannot.
> 
> 3. Numpy "coerces" `numpy.float32(1.5)` to `float(1.5)` (a Python float) and calls `float(1.5) * x` instead.
> 
> 4. Python realizes that it cannot do this multiplication.
> 
> 5. Python calls `type(x).__mul__(1.5, x)` which is handled by the coercion model.
> 
> Still, the difference must be in step 2.

this theory does not work, as step 2 has nothing to do with `type(x)`---but `type(x)` matters, as can be seen here:

```
sage: type(x)
<type 'sage.symbolic.expression.Expression'>
sage: type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)
1.5*x
sage: x=polygen(RDF)
sage: type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)
1.5*x
sage: x=polygen(RR)
sage: type(numpy.float32('1.5')).__mul__(numpy.float32('1.5'), x)
/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply
  #!/usr/bin/env python
1.50000000000000*x
sage: float(1.5)*x
1.50000000000000*x
```




---

archive/issue_comments_314441.json:
```json
{
    "body": "I have created https://github.com/numpy/numpy/issues/9007",
    "created_at": "2017-04-27T11:48:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314441",
    "user": "@dimpase"
}
```

I have created https://github.com/numpy/numpy/issues/9007



---

archive/issue_comments_314442.json:
```json
{
    "body": "You can't multiply a type by a number, or if you can, I don't know what sort of answer you would expect. Note also that your working example at the end is with `float`, not `numpy.float32`. So I claim that your example doesn't make any sense. I get this:\n\n```\nsage: numpy.float32('1.5') * x\n/Users/palmieri/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta3/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply\n  #!/usr/bin/env python\n1.50000000000000*x\n```\n\nThat is, it just comes from plain multiplication in numpy.",
    "created_at": "2017-04-27T15:24:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314442",
    "user": "@jhpalmieri"
}
```

You can't multiply a type by a number, or if you can, I don't know what sort of answer you would expect. Note also that your working example at the end is with `float`, not `numpy.float32`. So I claim that your example doesn't make any sense. I get this:

```
sage: numpy.float32('1.5') * x
/Users/palmieri/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta3/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply
  #!/usr/bin/env python
1.50000000000000*x
```

That is, it just comes from plain multiplication in numpy.



---

archive/issue_comments_314443.json:
```json
{
    "body": "Replying to [comment:41 jhpalmieri]:\n> You can't multiply a type by a number, \nin this case the type has `__mul__` \n\n```\nsage: import numpy\nsage: v=numpy.float32('1.5')\nsage: t=type(v)\nsage: t.__mul__?\nType:           wrapper_descriptor\nString form:    <slot wrapper '__mul__' of 'numpy.generic' objects>\nFile:           \nDocstring:      x.__mul__(y) <==> x*y\n...\nsage: t.__mul__(v,2)\n3.0\n```\n\nof course, in this case this is the same as `v*2`, just some levels down the code path.\n\nOne can unwind it a bit more:\n\n```\nsage: v.__mul__\n<method-wrapper '__mul__' of numpy.float32 object at 0x7f4ad5773318>\nsage: v.__mul__(2)\n3.0\nsage: v.__mul__(polygen(RR))\n/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply\n  #!/usr/bin/env python\n1.50000000000000*x\n```\n\n\nby the way, the same warning with `__add__` and `__sub__`.",
    "created_at": "2017-04-27T16:42:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314443",
    "user": "@dimpase"
}
```

Replying to [comment:41 jhpalmieri]:
> You can't multiply a type by a number, 
in this case the type has `__mul__` 

```
sage: import numpy
sage: v=numpy.float32('1.5')
sage: t=type(v)
sage: t.__mul__?
Type:           wrapper_descriptor
String form:    <slot wrapper '__mul__' of 'numpy.generic' objects>
File:           
Docstring:      x.__mul__(y) <==> x*y
...
sage: t.__mul__(v,2)
3.0
```

of course, in this case this is the same as `v*2`, just some levels down the code path.

One can unwind it a bit more:

```
sage: v.__mul__
<method-wrapper '__mul__' of numpy.float32 object at 0x7f4ad5773318>
sage: v.__mul__(2)
3.0
sage: v.__mul__(polygen(RR))
/usr/home/dima/Sage/sage/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in multiply
  #!/usr/bin/env python
1.50000000000000*x
```


by the way, the same warning with `__add__` and `__sub__`.



---

archive/issue_comments_314444.json:
```json
{
    "body": "Right, so isn't\n\n```\nnumpy.float32('1.5') * polygen(RR)\n```\n\na simple illustration of the problem, with no `type` involved?",
    "created_at": "2017-04-27T16:52:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314444",
    "user": "@jhpalmieri"
}
```

Right, so isn't

```
numpy.float32('1.5') * polygen(RR)
```

a simple illustration of the problem, with no `type` involved?



---

archive/issue_comments_314445.json:
```json
{
    "body": "Replying to [comment:43 jhpalmieri]:\n> Right, so isn't\n> {{{\n> numpy.float32('1.5') * polygen(RR)\n> }}}\n> a simple illustration of the problem, with no `type` involved?\nit's less clear this way whether or how Sage's coersion is involved. \n\n```\nnumpy.float32('1.5').__mul__(polygen(RR))\n```\n\nalso does not call type explicitly, and is closer to the end of the codepath of this computation.",
    "created_at": "2017-04-27T17:06:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314445",
    "user": "@dimpase"
}
```

Replying to [comment:43 jhpalmieri]:
> Right, so isn't
> {{{
> numpy.float32('1.5') * polygen(RR)
> }}}
> a simple illustration of the problem, with no `type` involved?
it's less clear this way whether or how Sage's coersion is involved. 

```
numpy.float32('1.5').__mul__(polygen(RR))
```

also does not call type explicitly, and is closer to the end of the codepath of this computation.



---

archive/issue_comments_314446.json:
```json
{
    "body": "First, sorry, I misunderstood about the use of type in the original example. Second, doesn't the problem happen before Sage's coercion? Third, it is not clear how numpy decides whether or not it can do a multiplication (in the language of Jeroen's step 2), so the type of x could very well be relevant there, couldn't it?\n\nMaybe someone who is comfortable with gdb and related tools (= not me) should try the problematic operation in Sage + gcc and also in Sage + clang to see what is happening differently in the two cases.",
    "created_at": "2017-04-27T17:40:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314446",
    "user": "@jhpalmieri"
}
```

First, sorry, I misunderstood about the use of type in the original example. Second, doesn't the problem happen before Sage's coercion? Third, it is not clear how numpy decides whether or not it can do a multiplication (in the language of Jeroen's step 2), so the type of x could very well be relevant there, couldn't it?

Maybe someone who is comfortable with gdb and related tools (= not me) should try the problematic operation in Sage + gcc and also in Sage + clang to see what is happening differently in the two cases.



---

archive/issue_comments_314447.json:
```json
{
    "body": "Numpy devs say a lot on \u200bhttps://github.com/numpy/numpy/issues/9007 - that apparently Sage might be setting the FPU flag which is read by numpy, and leads to this warning. Also, they are able to show how to exclude `np.float32` and `np.float64` types from being under suspicion.\n\nPerhaps we should upgrade to numpy 1.12.1, so that we're all on the same version (I am on 1.12.1)",
    "created_at": "2017-04-27T19:33:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314447",
    "user": "@dimpase"
}
```

Numpy devs say a lot on ​https://github.com/numpy/numpy/issues/9007 - that apparently Sage might be setting the FPU flag which is read by numpy, and leads to this warning. Also, they are able to show how to exclude `np.float32` and `np.float64` types from being under suspicion.

Perhaps we should upgrade to numpy 1.12.1, so that we're all on the same version (I am on 1.12.1)



---

archive/issue_comments_314448.json:
```json
{
    "body": "Replying to [comment:41 jhpalmieri]:\n> You can't multiply a type by a number\n\nSorry, as Dima said, `type(A).__mul__(A, B)` is just a contrived way of writing `A.__mul__(B)`. I wrote it with `type()` because that's closer to what Python internally actually does.\n\nNote that `A.__mul__(B)` is *not* the same as `A * B`: essentially `A * B` first calls `A.__mul__(B)`. When this returns `NotImplemented`, Python tries the reversed multiplication.",
    "created_at": "2017-04-27T19:42:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314448",
    "user": "@jdemeyer"
}
```

Replying to [comment:41 jhpalmieri]:
> You can't multiply a type by a number

Sorry, as Dima said, `type(A).__mul__(A, B)` is just a contrived way of writing `A.__mul__(B)`. I wrote it with `type()` because that's closer to what Python internally actually does.

Note that `A.__mul__(B)` is *not* the same as `A * B`: essentially `A * B` first calls `A.__mul__(B)`. When this returns `NotImplemented`, Python tries the reversed multiplication.



---

archive/issue_comments_314449.json:
```json
{
    "body": "Replying to [comment:47 jdemeyer]:\n> Replying to [comment:41 jhpalmieri]:\n> > You can't multiply a type by a number\n> \n> Sorry, as Dima said, `type(A).__mul__(A, B)` is just a contrived way of writing `A.__mul__(B)`.\n\nRight, I understand this now, as was vaguely implied in comment:45.",
    "created_at": "2017-04-27T20:01:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314449",
    "user": "@jhpalmieri"
}
```

Replying to [comment:47 jdemeyer]:
> Replying to [comment:41 jhpalmieri]:
> > You can't multiply a type by a number
> 
> Sorry, as Dima said, `type(A).__mul__(A, B)` is just a contrived way of writing `A.__mul__(B)`.

Right, I understand this now, as was vaguely implied in comment:45.



---

archive/issue_comments_314450.json:
```json
{
    "body": "Replying to [comment:46 dimpase]:\n> Numpy devs say a lot on \u200bhttps://github.com/numpy/numpy/issues/9007 - that apparently Sage might be setting the FPU flag which is read by numpy, and leads to this warning. Also, they are able to show how to exclude `np.float32` and `np.float64` types from being under suspicion.\n> \n> Perhaps we should upgrade to numpy 1.12.1, so that we're all on the same version (I am on 1.12.1)\n\nYes we could make a ticket numpy-1.12.1, we could drop at least one patch and I don't expect anything else to break. \n\nThe discussion on the numpy tracker goes in the direction I suspected it would. numpy is issuing the warning because of something happening in sage. I had arrived at that conclusion by recompiling numpy (1.12.1 at the time) with gcc on a full clang install on OS X. And the problem didn't go away, implying something sage-side is happening when compiled with clang.",
    "created_at": "2017-04-27T21:14:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314450",
    "user": "@kiwifb"
}
```

Replying to [comment:46 dimpase]:
> Numpy devs say a lot on ​https://github.com/numpy/numpy/issues/9007 - that apparently Sage might be setting the FPU flag which is read by numpy, and leads to this warning. Also, they are able to show how to exclude `np.float32` and `np.float64` types from being under suspicion.
> 
> Perhaps we should upgrade to numpy 1.12.1, so that we're all on the same version (I am on 1.12.1)

Yes we could make a ticket numpy-1.12.1, we could drop at least one patch and I don't expect anything else to break. 

The discussion on the numpy tracker goes in the direction I suspected it would. numpy is issuing the warning because of something happening in sage. I had arrived at that conclusion by recompiling numpy (1.12.1 at the time) with gcc on a full clang install on OS X. And the problem didn't go away, implying something sage-side is happening when compiled with clang.



---

archive/issue_comments_314451.json:
```json
{
    "body": "numpy upgrade is on #22582.",
    "created_at": "2017-04-28T10:29:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314451",
    "user": "@dimpase"
}
```

numpy upgrade is on #22582.



---

archive/issue_comments_314452.json:
```json
{
    "body": "Let's agree on who would work on debugging; say, in `src/sage/rings/polynomial/polynomial_real_mpfr_dense.pyx` one would probably need to set an FPU trap to find exactly what triggers the numpy warning in `np.float32('1.5')*polygen(RR)` (it's very likely to be a call to `mpfr`, but which one?)\n\nOr perhaps there should be a way to set this up globally, for all the cython modules.\n\n(I'd be too busy in the coming week).",
    "created_at": "2017-04-30T10:32:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314452",
    "user": "@dimpase"
}
```

Let's agree on who would work on debugging; say, in `src/sage/rings/polynomial/polynomial_real_mpfr_dense.pyx` one would probably need to set an FPU trap to find exactly what triggers the numpy warning in `np.float32('1.5')*polygen(RR)` (it's very likely to be a call to `mpfr`, but which one?)

Or perhaps there should be a way to set this up globally, for all the cython modules.

(I'd be too busy in the coming week).



---

archive/issue_comments_314453.json:
```json
{
    "body": "Similarly, the warning is emitted in\n\n```\nsage: numpy.float64(5)>e\n```\n\nor `>=` instead of `>`, or `pi` instead of `e`. Note that `pi.n()` and `e.n()` are of type `RR`, so again it points at the direction on `mpfr`.",
    "created_at": "2017-05-03T11:14:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314453",
    "user": "@dimpase"
}
```

Similarly, the warning is emitted in

```
sage: numpy.float64(5)>e
```

or `>=` instead of `>`, or `pi` instead of `e`. Note that `pi.n()` and `e.n()` are of type `RR`, so again it points at the direction on `mpfr`.



---

archive/issue_comments_314454.json:
```json
{
    "body": "In spirit, it's pretty much the same as the `polygen(RR)` problem. Let `b=numpy.float64(5)`. Then\n`b.__gt__(e)` prints the same warning; under the hood it apparently calls `mpfr`, which raises an FP flag, which then gets picked up by the warning printer. \n\nNote that if I first call `np.seterr(invalid='ignore')` then no warnings are printed.",
    "created_at": "2017-05-03T11:27:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314454",
    "user": "@dimpase"
}
```

In spirit, it's pretty much the same as the `polygen(RR)` problem. Let `b=numpy.float64(5)`. Then
`b.__gt__(e)` prints the same warning; under the hood it apparently calls `mpfr`, which raises an FP flag, which then gets picked up by the warning printer. 

Note that if I first call `np.seterr(invalid='ignore')` then no warnings are printed.



---

archive/issue_comments_314455.json:
```json
{
    "body": "it could help to configure MPFR with `--enable-logging` (see details in doc/README.dev in the MPFR source repository):\n\n```\nFor example, just define MPFR_LOG_ALL, run you program, and view `mpfr.log`.\n```\n",
    "created_at": "2017-05-04T09:31:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314455",
    "user": "@zimmermann6"
}
```

it could help to configure MPFR with `--enable-logging` (see details in doc/README.dev in the MPFR source repository):

```
For example, just define MPFR_LOG_ALL, run you program, and view `mpfr.log`.
```




---

archive/issue_comments_314456.json:
```json
{
    "body": "Leads me to two observation. I accidentally rebuilt mpfr with gcc on my linux box (`MPFR_CONFIGURE=\"--enable-logging\" ./sage -f mpfr`) and ran all the test successfully. So `mpfr+clang` seems to be the real cause of the trouble.\nOnce I remembered that on my linux machine I had to set `CC` and `CXX` I encountered another problem trying to compile with logging:\n\n```\nlibtool: compile:  clang -DMPFR_USE_LOGGING=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_LOCALE_H=1 -DHAVE_WCHAR_H=1 -DHAVE_STDARG=1 -DHAVE_SYS_TIME_H=1 -DHAVE_STRUCT_LCONV_DECIMAL_POINT=1 -DHAVE_STRUCT_LCONV_THOUSANDS_SEP=1 -DHAVE_ALLOCA_H=1 -DHAVE_STDINT_H=1 -DHAVE_VA_COPY=1 -DHAVE_SETLOCALE=1 -DHAVE_GETTIMEOFDAY=1 -DHAVE_LONG_LONG=1 -DHAVE_INTMAX_T=1 -DMPFR_HAVE_INTMAX_MAX=1 -DMPFR_HAVE_FESETROUND=1 -DHAVE_DENORMS=1 -DHAVE_SIGNEDZ=1 -DHAVE_ROUND=1 -DHAVE_TRUNC=1 -DHAVE_FLOOR=1 -DHAVE_CEIL=1 -DHAVE_NEARBYINT=1 -DHAVE_LDOUBLE_IEEE_EXT_LITTLE=1 -DHAVE_CLOCK_GETTIME=1 -DLT_OBJDIR=\\\".libs/\\\" -DHAVE_ATTRIBUTE_MODE=1 -DHAVE___GMPN_ROOTREM=1 -I. -I/home/fbissey/sandbox/git-fork/sage-clang/local/include -Wall -Wmissing-prototypes -Wpointer-arith -m64 -O2 -march=corei7-avx -mtune=corei7-avx -g -MT add.lo -MD -MP -MF .deps/add.Tpo -c add.c  -fPIC -DPIC -o .libs/add.o\nadd.c:28:3: error: illegal storage class on function\n  MPFR_LOG_FUNC\n  ^\n./mpfr-impl.h:1716:3: note: expanded from macro 'MPFR_LOG_FUNC'\n  auto void __mpfr_log_cleanup (int *time);                             \\\n  ^\nadd.c:28:3: error: function definition is not allowed here\n./mpfr-impl.h:1717:39: note: expanded from macro 'MPFR_LOG_FUNC'\n  void __mpfr_log_cleanup (int *time) {                                 \\\n                                      ^\n2 errors generated.\n```\n\nSo we'll have to fix logging with clang before we can investigate with this tool. I will try on OS X shortly.",
    "created_at": "2017-05-04T10:13:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314456",
    "user": "@kiwifb"
}
```

Leads me to two observation. I accidentally rebuilt mpfr with gcc on my linux box (`MPFR_CONFIGURE="--enable-logging" ./sage -f mpfr`) and ran all the test successfully. So `mpfr+clang` seems to be the real cause of the trouble.
Once I remembered that on my linux machine I had to set `CC` and `CXX` I encountered another problem trying to compile with logging:

```
libtool: compile:  clang -DMPFR_USE_LOGGING=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_LOCALE_H=1 -DHAVE_WCHAR_H=1 -DHAVE_STDARG=1 -DHAVE_SYS_TIME_H=1 -DHAVE_STRUCT_LCONV_DECIMAL_POINT=1 -DHAVE_STRUCT_LCONV_THOUSANDS_SEP=1 -DHAVE_ALLOCA_H=1 -DHAVE_STDINT_H=1 -DHAVE_VA_COPY=1 -DHAVE_SETLOCALE=1 -DHAVE_GETTIMEOFDAY=1 -DHAVE_LONG_LONG=1 -DHAVE_INTMAX_T=1 -DMPFR_HAVE_INTMAX_MAX=1 -DMPFR_HAVE_FESETROUND=1 -DHAVE_DENORMS=1 -DHAVE_SIGNEDZ=1 -DHAVE_ROUND=1 -DHAVE_TRUNC=1 -DHAVE_FLOOR=1 -DHAVE_CEIL=1 -DHAVE_NEARBYINT=1 -DHAVE_LDOUBLE_IEEE_EXT_LITTLE=1 -DHAVE_CLOCK_GETTIME=1 -DLT_OBJDIR=\".libs/\" -DHAVE_ATTRIBUTE_MODE=1 -DHAVE___GMPN_ROOTREM=1 -I. -I/home/fbissey/sandbox/git-fork/sage-clang/local/include -Wall -Wmissing-prototypes -Wpointer-arith -m64 -O2 -march=corei7-avx -mtune=corei7-avx -g -MT add.lo -MD -MP -MF .deps/add.Tpo -c add.c  -fPIC -DPIC -o .libs/add.o
add.c:28:3: error: illegal storage class on function
  MPFR_LOG_FUNC
  ^
./mpfr-impl.h:1716:3: note: expanded from macro 'MPFR_LOG_FUNC'
  auto void __mpfr_log_cleanup (int *time);                             \
  ^
add.c:28:3: error: function definition is not allowed here
./mpfr-impl.h:1717:39: note: expanded from macro 'MPFR_LOG_FUNC'
  void __mpfr_log_cleanup (int *time) {                                 \
                                      ^
2 errors generated.
```

So we'll have to fix logging with clang before we can investigate with this tool. I will try on OS X shortly.



---

archive/issue_comments_314457.json:
```json
{
    "body": "Hum equivalent error on OS X\n\n```\nlibtool: compile:  gcc -DMPFR_USE_LOGGING=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_LOCALE_H=1 -DHAVE_WCHAR_H=1 -DHAVE_STDARG=1 -DHAVE_SYS_TIME_H=1 -DHAVE_STRUCT_LCONV_DECIMAL_POINT=1 -DHAVE_STRUCT_LCONV_THOUSANDS_SEP=1 -DHAVE_ALLOCA_H=1 -DHAVE_STDINT_H=1 -DHAVE_VA_COPY=1 -DHAVE_SETLOCALE=1 -DHAVE_GETTIMEOFDAY=1 -DHAVE_LONG_LONG=1 -DHAVE_INTMAX_T=1 -DMPFR_HAVE_INTMAX_MAX=1 -DMPFR_HAVE_FESETROUND=1 -DHAVE_DENORMS=1 -DHAVE_SIGNEDZ=1 -DHAVE_ROUND=1 -DHAVE_TRUNC=1 -DHAVE_FLOOR=1 -DHAVE_CEIL=1 -DHAVE_NEARBYINT=1 -DHAVE_LDOUBLE_IEEE_EXT_LITTLE=1 -DHAVE_CLOCK_GETTIME=1 -DLT_OBJDIR=\\\".libs/\\\" -DHAVE_ATTRIBUTE_MODE=1 -DHAVE___GMPN_ROOTREM=1 -I. -I/Users/fbissey/build/sage-clang/local/include -Wall -Wmissing-prototypes -Wpointer-arith -m64 -O2 -march=corei7-avx -mtune=corei7-avx -g -MT exceptions.lo -MD -MP -MF .deps/exceptions.Tpo -c exceptions.c  -fno-common -DPIC -o .libs/exceptions.o\nIn file included from exceptions.c:23:\n./mpfr-impl.h:1557:4: error: \"Logging not supported (needs gcc >= 3.0 and GNU C Library >= 2.0).\"\n#  error \"Logging not supported (needs gcc >= 3.0 and GNU C Library >= 2.0).\"\n   ^\n1 error generated.\n```\n",
    "created_at": "2017-05-04T10:34:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314457",
    "user": "@kiwifb"
}
```

Hum equivalent error on OS X

```
libtool: compile:  gcc -DMPFR_USE_LOGGING=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_LOCALE_H=1 -DHAVE_WCHAR_H=1 -DHAVE_STDARG=1 -DHAVE_SYS_TIME_H=1 -DHAVE_STRUCT_LCONV_DECIMAL_POINT=1 -DHAVE_STRUCT_LCONV_THOUSANDS_SEP=1 -DHAVE_ALLOCA_H=1 -DHAVE_STDINT_H=1 -DHAVE_VA_COPY=1 -DHAVE_SETLOCALE=1 -DHAVE_GETTIMEOFDAY=1 -DHAVE_LONG_LONG=1 -DHAVE_INTMAX_T=1 -DMPFR_HAVE_INTMAX_MAX=1 -DMPFR_HAVE_FESETROUND=1 -DHAVE_DENORMS=1 -DHAVE_SIGNEDZ=1 -DHAVE_ROUND=1 -DHAVE_TRUNC=1 -DHAVE_FLOOR=1 -DHAVE_CEIL=1 -DHAVE_NEARBYINT=1 -DHAVE_LDOUBLE_IEEE_EXT_LITTLE=1 -DHAVE_CLOCK_GETTIME=1 -DLT_OBJDIR=\".libs/\" -DHAVE_ATTRIBUTE_MODE=1 -DHAVE___GMPN_ROOTREM=1 -I. -I/Users/fbissey/build/sage-clang/local/include -Wall -Wmissing-prototypes -Wpointer-arith -m64 -O2 -march=corei7-avx -mtune=corei7-avx -g -MT exceptions.lo -MD -MP -MF .deps/exceptions.Tpo -c exceptions.c  -fno-common -DPIC -o .libs/exceptions.o
In file included from exceptions.c:23:
./mpfr-impl.h:1557:4: error: "Logging not supported (needs gcc >= 3.0 and GNU C Library >= 2.0)."
#  error "Logging not supported (needs gcc >= 3.0 and GNU C Library >= 2.0)."
   ^
1 error generated.
```




---

archive/issue_comments_314458.json:
```json
{
    "body": "Unless you already tried this, I'd try re-running autoconf.",
    "created_at": "2017-05-04T11:05:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314458",
    "user": "@dimpase"
}
```

Unless you already tried this, I'd try re-running autoconf.



---

archive/issue_comments_314459.json:
```json
{
    "body": "Replying to [comment:58 dimpase]:\n> Unless you already tried this, I'd try re-running autoconf.\n\nYou mean recreating mpfr's configure by running `autoreconf` or something else altogether?",
    "created_at": "2017-05-04T11:08:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314459",
    "user": "@kiwifb"
}
```

Replying to [comment:58 dimpase]:
> Unless you already tried this, I'd try re-running autoconf.

You mean recreating mpfr's configure by running `autoreconf` or something else altogether?



---

archive/issue_comments_314460.json:
```json
{
    "body": "\n```\n/* The following test on glibc is there mainly for Darwin (Mac OS X), to\n   obtain a better error message. The real test should have been a test\n   concerning nested functions in gcc, which are disabled by default on\n   Darwin; but it is not possible to do that without a configure test. */\n# if defined (__cplusplus) || !(__MPFR_GNUC(3,0) && __MPFR_GLIBC(2,0))\n#  error \"Logging not supported (needs gcc >= 3.0 and GNU C Library >= 2.0).\"\n```\n\nseems to say that logging needs nested functions. And clang does not do them, as we know... I'd say this is an MPFR bug, no?",
    "created_at": "2017-05-04T11:15:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314460",
    "user": "@dimpase"
}
```


```
/* The following test on glibc is there mainly for Darwin (Mac OS X), to
   obtain a better error message. The real test should have been a test
   concerning nested functions in gcc, which are disabled by default on
   Darwin; but it is not possible to do that without a configure test. */
# if defined (__cplusplus) || !(__MPFR_GNUC(3,0) && __MPFR_GLIBC(2,0))
#  error "Logging not supported (needs gcc >= 3.0 and GNU C Library >= 2.0)."
```

seems to say that logging needs nested functions. And clang does not do them, as we know... I'd say this is an MPFR bug, no?



---

archive/issue_comments_314461.json:
```json
{
    "body": "Replying to [comment:60 dimpase]:\n> {{{\n> /* The following test on glibc is there mainly for Darwin (Mac OS X), to\n>    obtain a better error message. The real test should have been a test\n>    concerning nested functions in gcc, which are disabled by default on\n>    Darwin; but it is not possible to do that without a configure test. */\n> # if defined (__cplusplus) || !(__MPFR_GNUC(3,0) && __MPFR_GLIBC(2,0))\n> #  error \"Logging not supported (needs gcc >= 3.0 and GNU C Library >= 2.0).\"\n> }}}\n> seems to say that logging needs nested functions. And clang does not do them, as we know... I'd say this is an MPFR bug, no?\n\nYes. Using a GNU extension - the word bug can be argued, but it fails to adhere to the standard which you do at your own peril and the cost of portability.",
    "created_at": "2017-05-04T11:36:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314461",
    "user": "@kiwifb"
}
```

Replying to [comment:60 dimpase]:
> {{{
> /* The following test on glibc is there mainly for Darwin (Mac OS X), to
>    obtain a better error message. The real test should have been a test
>    concerning nested functions in gcc, which are disabled by default on
>    Darwin; but it is not possible to do that without a configure test. */
> # if defined (__cplusplus) || !(__MPFR_GNUC(3,0) && __MPFR_GLIBC(2,0))
> #  error "Logging not supported (needs gcc >= 3.0 and GNU C Library >= 2.0)."
> }}}
> seems to say that logging needs nested functions. And clang does not do them, as we know... I'd say this is an MPFR bug, no?

Yes. Using a GNU extension - the word bug can be argued, but it fails to adhere to the standard which you do at your own peril and the cost of portability.



---

archive/issue_comments_314462.json:
```json
{
    "body": "One can of course do a log on gcc and hope that it's identical to what one would get on clang...",
    "created_at": "2017-05-04T13:11:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314462",
    "user": "@dimpase"
}
```

One can of course do a log on gcc and hope that it's identical to what one would get on clang...



---

archive/issue_comments_314463.json:
```json
{
    "body": "> I'd say this is an MPFR bug, no?\n\nit is in fact a clang bug:\n\nhttps://bugs.llvm.org//show_bug.cgi?id=6378\n\n\"Clang doesn't support the GNU nested function extension, sorry.\nWe have no plans to implement it.\"",
    "created_at": "2017-05-04T14:51:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314463",
    "user": "@zimmermann6"
}
```

> I'd say this is an MPFR bug, no?

it is in fact a clang bug:

https://bugs.llvm.org//show_bug.cgi?id=6378

"Clang doesn't support the GNU nested function extension, sorry.
We have no plans to implement it."



---

archive/issue_comments_314464.json:
```json
{
    "body": "Replying to [comment:63 zimmerma]:\n> > I'd say this is an MPFR bug, no?\n> \n> it is in fact a clang bug:\n> \n> https://bugs.llvm.org//show_bug.cgi?id=6378\n> \n> \"Clang doesn't support the GNU nested function extension, sorry.\n> We have no plans to implement it.\"\n\nWell, as MPFR makes no claims to adhere to a C standard, you may indeed consider it a feature :-)",
    "created_at": "2017-05-04T15:38:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314464",
    "user": "@dimpase"
}
```

Replying to [comment:63 zimmerma]:
> > I'd say this is an MPFR bug, no?
> 
> it is in fact a clang bug:
> 
> https://bugs.llvm.org//show_bug.cgi?id=6378
> 
> "Clang doesn't support the GNU nested function extension, sorry.
> We have no plans to implement it."

Well, as MPFR makes no claims to adhere to a C standard, you may indeed consider it a feature :-)



---

archive/issue_comments_314465.json:
```json
{
    "body": "for what's worth, this is the `mpfr.log` I see on linux/gcc, after stripping the initialisation part, and running\n`np.float64(5).__gt__(e)`; looks like `mpfr` is computing `exp(1.0)` to certain precision.\n\n\n```\n> mpfr_exp:IN  x[53]=1 rnd=3\n> mpfr_const_log2_internal:IN  rnd_mode=0\n> mpfr_const_log2_internal:ZIV 1st prec=42\n> mpfr_div:IN  u[42]=2.2496e+21 v[42]=3.24549e+21 rnd=0\n> mpfr_div:TIM 0ms\n> mpfr_div:OUT q[42]=0.693147 inexact=-1\n> mpfr_const_log2_internal:TIM 0ms\n> mpfr_const_log2_internal:OUT x[32]=0.693147 inex=1\n> mpfr_mul:IN  b[32]=0.693147 c[64]=4.61169e+18 rnd=2\n> mpfr_mul:TIM 0ms\n> mpfr_mul:OUT a[32]=3.19658e+18 inexact=1\n> mpfr_sub_ui:IN  x[64]=-4.61169e+18 u=2 rnd=0\n> mpfr_sub:IN  b[64]=-4.61169e+18 c[64]=2 rnd=0\n> mpfr_sub:TIM 0ms\n> mpfr_sub:OUT a[64]=-4.61169e+18\n> mpfr_sub_ui:TIM 0ms\n> mpfr_sub_ui:OUT y[64]=-4.61169e+18 inexact=0\n> mpfr_mul:IN  b[32]=0.693147 c[64]=-4.61169e+18 rnd=3\n> mpfr_mul:TIM 0ms\n> mpfr_mul:OUT a[32]=-3.19658e+18 inexact=-1\n> mpfr_exp_2:IN  x[53]=1 rnd=3\n> mpfr_const_log2_internal:IN  rnd_mode=0\n> mpfr_const_log2_internal:ZIV 1st prec=74\n> mpfr_div:IN  u[74]=2.17458e+40 v[74]=3.13725e+40 rnd=0\n> mpfr_div:TIM 0ms\n> mpfr_div:OUT q[74]=0.693147 inexact=-1\n> mpfr_const_log2_internal:TIM 0ms\n> mpfr_const_log2_internal:OUT x[64]=0.693147 inex=1\n> mpfr_div:IN  u[53]=1 v[64]=0.693147 rnd=0\n> mpfr_div:TIM 0ms\n> mpfr_div:OUT q[64]=1.4427 inexact=1\n> mpfr_exp_2.114: d(x)=1.000000000000000000000000000000e+00 n=1\n> mpfr_exp_2:ZIV 1st prec=78\n> mpfr_exp_2.152: n=1 K=5 l=11 q=78 error_r=2\n> mpfr_const_log2_internal:IN  rnd_mode=0\n> mpfr_const_log2_internal:ZIV 1st prec=90\n> mpfr_div:IN  u[90]=8.48887e+52 v[90]=1.22469e+53 rnd=0\n> mpfr_div:TIM 0ms\n> mpfr_div:OUT q[90]=0.693147 inexact=-1\n> mpfr_const_log2_internal:TIM 0ms\n> mpfr_const_log2_internal:OUT x[80]=0.693147 inex=1\n> mpfr_exp_2.169:x[53]=1\n> mpfr_exp_2.170:r[80]=0.693147\n> mpfr_sub:IN  b[53]=1 c[80]=0.693147 rnd=2\n> mpfr_sub:TIM 0ms\n> mpfr_sub:OUT a[80]=0.306853\n> mpfr_exp_2.189:r[78]=0.306853\n> mpfr_div_2ui:IN  x[78]=0.306853 n=5 rnd=2\n> mpfr_div_2ui:TIM 0ms\n> mpfr_div_2ui:OUT y[78]=0.00958915 inexact=0\n> mpfr_exp_2.202: l=270 q=78 (K+l)*q^2=1.673e+06\n> mpfr_exp_2.219: before mult. by 2^n:\n> mpfr_exp_2.220:s[80]=1.35914\n> mpfr_exp_2.221: err=5 bits\n> mpfr_mul_2si:IN  x[80]=1.35914 n=1 rnd=3\n> mpfr_mul_2si:TIM 0ms\n> mpfr_mul_2si:OUT y[53]=2.71828 inexact=-1\n> mpfr_exp_2:TIM 3ms\n> mpfr_exp_2:OUT y[53]=2.71828 inexact=-1\n> mpfr_exp:TIM 3ms\n> mpfr_exp:OUT y[53]=2.71828 inexact=-1\n> mpfr_exp:IN  x[53]=1 rnd=2\n> mpfr_mul:IN  b[32]=0.693147 c[64]=4.61169e+18 rnd=2\n> mpfr_mul:TIM 0ms\n> mpfr_mul:OUT a[32]=3.19658e+18 inexact=1\n> mpfr_sub_ui:IN  x[64]=-4.61169e+18 u=2 rnd=0\n> mpfr_sub:IN  b[64]=-4.61169e+18 c[64]=2 rnd=0\n> mpfr_sub:TIM 0ms\n> mpfr_sub:OUT a[64]=-4.61169e+18\n> mpfr_sub_ui:TIM 0ms\n> mpfr_sub_ui:OUT y[64]=-4.61169e+18 inexact=0\n> mpfr_mul:IN  b[32]=0.693147 c[64]=-4.61169e+18 rnd=3\n> mpfr_mul:TIM 0ms\n> mpfr_mul:OUT a[32]=-3.19658e+18 inexact=-1\n> mpfr_exp_2:IN  x[53]=1 rnd=2\n> mpfr_div:IN  u[53]=1 v[64]=0.693147 rnd=0\n> mpfr_div:TIM 0ms\n> mpfr_div:OUT q[64]=1.4427 inexact=1\n> mpfr_exp_2.114: d(x)=1.000000000000000000000000000000e+00 n=1\n> mpfr_exp_2:ZIV 1st prec=78\n> mpfr_exp_2.152: n=1 K=5 l=11 q=78 error_r=2\n> mpfr_exp_2.169:x[53]=1\n> mpfr_exp_2.170:r[80]=0.693147\n> mpfr_sub:IN  b[53]=1 c[80]=0.693147 rnd=2\n> mpfr_sub:TIM 0ms\n> mpfr_sub:OUT a[80]=0.306853\n> mpfr_exp_2.189:r[78]=0.306853\n> mpfr_div_2ui:IN  x[78]=0.306853 n=5 rnd=2\n> mpfr_div_2ui:TIM 0ms\n> mpfr_div_2ui:OUT y[78]=0.00958915 inexact=0\n> mpfr_exp_2.202: l=270 q=78 (K+l)*q^2=1.673e+06\n> mpfr_exp_2.219: before mult. by 2^n:\n> mpfr_exp_2.220:s[80]=1.35914\n> mpfr_exp_2.221: err=5 bits\n> mpfr_mul_2si:IN  x[80]=1.35914 n=1 rnd=2\n> mpfr_mul_2si:TIM 0ms\n> mpfr_mul_2si:OUT y[53]=2.71828 inexact=1\n> mpfr_exp_2:TIM 0ms\n> mpfr_exp_2:OUT y[53]=2.71828 inexact=1\n> mpfr_exp:TIM 0ms\n> mpfr_exp:OUT y[53]=2.71828 inexact=1\n> mpfr_mul:IN  b[64]=52 c[77]=0.25 rnd=2\n> mpfr_mul:TIM 0ms\n> mpfr_mul:OUT a[64]=13 inexact=0\n> mpfr_mul:IN  b[64]=52 c[77]=0.25 rnd=2\n> mpfr_mul:TIM 0ms\n> mpfr_mul:OUT a[64]=13 inexact=0\n> mpfr_add:IN  b[53]=-5 c[53]=2.71828 rnd=3\n> mpfr_add:TIM 0ms\n> mpfr_add:OUT a[53]=-2.28172\n> mpfr_add:IN  b[53]=-5 c[53]=2.71828 rnd=2\n> mpfr_add:TIM 0ms\n> mpfr_add:OUT a[53]=-2.28172\n> mpfr_mul:IN  b[64]=52 c[77]=0.25 rnd=2\n> mpfr_mul:TIM 0ms\n> mpfr_mul:OUT a[64]=13 inexact=0\n> mpfr_mul:IN  b[64]=52 c[77]=0.25 rnd=2\n> mpfr_mul:TIM 0ms\n> mpfr_mul:OUT a[64]=13 inexact=0\n> mpfr_exp_2: Ziv failed 0.00% (0 bad cases / 2 calls)\n> mpfr_const_log2_internal: Ziv failed 0.00% (0 bad cases / 3 calls)\n```\n",
    "created_at": "2017-05-04T17:01:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314465",
    "user": "@dimpase"
}
```

for what's worth, this is the `mpfr.log` I see on linux/gcc, after stripping the initialisation part, and running
`np.float64(5).__gt__(e)`; looks like `mpfr` is computing `exp(1.0)` to certain precision.


```
> mpfr_exp:IN  x[53]=1 rnd=3
> mpfr_const_log2_internal:IN  rnd_mode=0
> mpfr_const_log2_internal:ZIV 1st prec=42
> mpfr_div:IN  u[42]=2.2496e+21 v[42]=3.24549e+21 rnd=0
> mpfr_div:TIM 0ms
> mpfr_div:OUT q[42]=0.693147 inexact=-1
> mpfr_const_log2_internal:TIM 0ms
> mpfr_const_log2_internal:OUT x[32]=0.693147 inex=1
> mpfr_mul:IN  b[32]=0.693147 c[64]=4.61169e+18 rnd=2
> mpfr_mul:TIM 0ms
> mpfr_mul:OUT a[32]=3.19658e+18 inexact=1
> mpfr_sub_ui:IN  x[64]=-4.61169e+18 u=2 rnd=0
> mpfr_sub:IN  b[64]=-4.61169e+18 c[64]=2 rnd=0
> mpfr_sub:TIM 0ms
> mpfr_sub:OUT a[64]=-4.61169e+18
> mpfr_sub_ui:TIM 0ms
> mpfr_sub_ui:OUT y[64]=-4.61169e+18 inexact=0
> mpfr_mul:IN  b[32]=0.693147 c[64]=-4.61169e+18 rnd=3
> mpfr_mul:TIM 0ms
> mpfr_mul:OUT a[32]=-3.19658e+18 inexact=-1
> mpfr_exp_2:IN  x[53]=1 rnd=3
> mpfr_const_log2_internal:IN  rnd_mode=0
> mpfr_const_log2_internal:ZIV 1st prec=74
> mpfr_div:IN  u[74]=2.17458e+40 v[74]=3.13725e+40 rnd=0
> mpfr_div:TIM 0ms
> mpfr_div:OUT q[74]=0.693147 inexact=-1
> mpfr_const_log2_internal:TIM 0ms
> mpfr_const_log2_internal:OUT x[64]=0.693147 inex=1
> mpfr_div:IN  u[53]=1 v[64]=0.693147 rnd=0
> mpfr_div:TIM 0ms
> mpfr_div:OUT q[64]=1.4427 inexact=1
> mpfr_exp_2.114: d(x)=1.000000000000000000000000000000e+00 n=1
> mpfr_exp_2:ZIV 1st prec=78
> mpfr_exp_2.152: n=1 K=5 l=11 q=78 error_r=2
> mpfr_const_log2_internal:IN  rnd_mode=0
> mpfr_const_log2_internal:ZIV 1st prec=90
> mpfr_div:IN  u[90]=8.48887e+52 v[90]=1.22469e+53 rnd=0
> mpfr_div:TIM 0ms
> mpfr_div:OUT q[90]=0.693147 inexact=-1
> mpfr_const_log2_internal:TIM 0ms
> mpfr_const_log2_internal:OUT x[80]=0.693147 inex=1
> mpfr_exp_2.169:x[53]=1
> mpfr_exp_2.170:r[80]=0.693147
> mpfr_sub:IN  b[53]=1 c[80]=0.693147 rnd=2
> mpfr_sub:TIM 0ms
> mpfr_sub:OUT a[80]=0.306853
> mpfr_exp_2.189:r[78]=0.306853
> mpfr_div_2ui:IN  x[78]=0.306853 n=5 rnd=2
> mpfr_div_2ui:TIM 0ms
> mpfr_div_2ui:OUT y[78]=0.00958915 inexact=0
> mpfr_exp_2.202: l=270 q=78 (K+l)*q^2=1.673e+06
> mpfr_exp_2.219: before mult. by 2^n:
> mpfr_exp_2.220:s[80]=1.35914
> mpfr_exp_2.221: err=5 bits
> mpfr_mul_2si:IN  x[80]=1.35914 n=1 rnd=3
> mpfr_mul_2si:TIM 0ms
> mpfr_mul_2si:OUT y[53]=2.71828 inexact=-1
> mpfr_exp_2:TIM 3ms
> mpfr_exp_2:OUT y[53]=2.71828 inexact=-1
> mpfr_exp:TIM 3ms
> mpfr_exp:OUT y[53]=2.71828 inexact=-1
> mpfr_exp:IN  x[53]=1 rnd=2
> mpfr_mul:IN  b[32]=0.693147 c[64]=4.61169e+18 rnd=2
> mpfr_mul:TIM 0ms
> mpfr_mul:OUT a[32]=3.19658e+18 inexact=1
> mpfr_sub_ui:IN  x[64]=-4.61169e+18 u=2 rnd=0
> mpfr_sub:IN  b[64]=-4.61169e+18 c[64]=2 rnd=0
> mpfr_sub:TIM 0ms
> mpfr_sub:OUT a[64]=-4.61169e+18
> mpfr_sub_ui:TIM 0ms
> mpfr_sub_ui:OUT y[64]=-4.61169e+18 inexact=0
> mpfr_mul:IN  b[32]=0.693147 c[64]=-4.61169e+18 rnd=3
> mpfr_mul:TIM 0ms
> mpfr_mul:OUT a[32]=-3.19658e+18 inexact=-1
> mpfr_exp_2:IN  x[53]=1 rnd=2
> mpfr_div:IN  u[53]=1 v[64]=0.693147 rnd=0
> mpfr_div:TIM 0ms
> mpfr_div:OUT q[64]=1.4427 inexact=1
> mpfr_exp_2.114: d(x)=1.000000000000000000000000000000e+00 n=1
> mpfr_exp_2:ZIV 1st prec=78
> mpfr_exp_2.152: n=1 K=5 l=11 q=78 error_r=2
> mpfr_exp_2.169:x[53]=1
> mpfr_exp_2.170:r[80]=0.693147
> mpfr_sub:IN  b[53]=1 c[80]=0.693147 rnd=2
> mpfr_sub:TIM 0ms
> mpfr_sub:OUT a[80]=0.306853
> mpfr_exp_2.189:r[78]=0.306853
> mpfr_div_2ui:IN  x[78]=0.306853 n=5 rnd=2
> mpfr_div_2ui:TIM 0ms
> mpfr_div_2ui:OUT y[78]=0.00958915 inexact=0
> mpfr_exp_2.202: l=270 q=78 (K+l)*q^2=1.673e+06
> mpfr_exp_2.219: before mult. by 2^n:
> mpfr_exp_2.220:s[80]=1.35914
> mpfr_exp_2.221: err=5 bits
> mpfr_mul_2si:IN  x[80]=1.35914 n=1 rnd=2
> mpfr_mul_2si:TIM 0ms
> mpfr_mul_2si:OUT y[53]=2.71828 inexact=1
> mpfr_exp_2:TIM 0ms
> mpfr_exp_2:OUT y[53]=2.71828 inexact=1
> mpfr_exp:TIM 0ms
> mpfr_exp:OUT y[53]=2.71828 inexact=1
> mpfr_mul:IN  b[64]=52 c[77]=0.25 rnd=2
> mpfr_mul:TIM 0ms
> mpfr_mul:OUT a[64]=13 inexact=0
> mpfr_mul:IN  b[64]=52 c[77]=0.25 rnd=2
> mpfr_mul:TIM 0ms
> mpfr_mul:OUT a[64]=13 inexact=0
> mpfr_add:IN  b[53]=-5 c[53]=2.71828 rnd=3
> mpfr_add:TIM 0ms
> mpfr_add:OUT a[53]=-2.28172
> mpfr_add:IN  b[53]=-5 c[53]=2.71828 rnd=2
> mpfr_add:TIM 0ms
> mpfr_add:OUT a[53]=-2.28172
> mpfr_mul:IN  b[64]=52 c[77]=0.25 rnd=2
> mpfr_mul:TIM 0ms
> mpfr_mul:OUT a[64]=13 inexact=0
> mpfr_mul:IN  b[64]=52 c[77]=0.25 rnd=2
> mpfr_mul:TIM 0ms
> mpfr_mul:OUT a[64]=13 inexact=0
> mpfr_exp_2: Ziv failed 0.00% (0 bad cases / 2 calls)
> mpfr_const_log2_internal: Ziv failed 0.00% (0 bad cases / 3 calls)
```




---

archive/issue_comments_314466.json:
```json
{
    "body": "indeed, MPFR is first computing `exp(1)` with rounding towards -infinity, then again `exp(1)` with rounding towards +infinity.\n\nThen it computes twice `52*0.25` with rounding towards +infinity (I wonder why the same value is computed twice).\n\nThen it adds `-5` and `2.71828` with rounding towards -infinity and +infinity,\nI guess this is to compare intervals for `5` and `exp(1)`.\n\nAgain it computes twice `52*0.25` with the same rounding, I don't know why.",
    "created_at": "2017-05-04T20:04:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314466",
    "user": "@zimmermann6"
}
```

indeed, MPFR is first computing `exp(1)` with rounding towards -infinity, then again `exp(1)` with rounding towards +infinity.

Then it computes twice `52*0.25` with rounding towards +infinity (I wonder why the same value is computed twice).

Then it adds `-5` and `2.71828` with rounding towards -infinity and +infinity,
I guess this is to compare intervals for `5` and `exp(1)`.

Again it computes twice `52*0.25` with the same rounding, I don't know why.



---

archive/issue_comments_314467.json:
```json
{
    "body": "Replying to [comment:64 dimpase]:\n> Replying to [comment:63 zimmerma]:\n> > > I'd say this is an MPFR bug, no?\n> > \n> > it is in fact a clang bug:\n> > \n> > https://bugs.llvm.org//show_bug.cgi?id=6378\n> > \n> > \"Clang doesn't support the GNU nested function extension, sorry.\n> > We have no plans to implement it.\"\n> \n> Well, as MPFR makes no claims to adhere to a C standard, you may indeed consider it a feature :-)\n> \n\nAs a person that has worked/ is working on rather exotic systems and do porting I consider it sad. It has been an extension for a rather a long time, if it was considered a useful or desirable feature it would be in the standard or planned for the next standard. That feature doesn't seem to have a big uptake either, we only had one package that absolutely required porting in sage so far.\n\nFortunately you don't use it in the functional part of mpfr but it is annoying.\n\nMy opinion is that while you make no claim to be standard compliant you should aim towards it and admit it as an issue, it does not have to be a show stopper bug.",
    "created_at": "2017-05-04T23:11:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314467",
    "user": "@kiwifb"
}
```

Replying to [comment:64 dimpase]:
> Replying to [comment:63 zimmerma]:
> > > I'd say this is an MPFR bug, no?
> > 
> > it is in fact a clang bug:
> > 
> > https://bugs.llvm.org//show_bug.cgi?id=6378
> > 
> > "Clang doesn't support the GNU nested function extension, sorry.
> > We have no plans to implement it."
> 
> Well, as MPFR makes no claims to adhere to a C standard, you may indeed consider it a feature :-)
> 

As a person that has worked/ is working on rather exotic systems and do porting I consider it sad. It has been an extension for a rather a long time, if it was considered a useful or desirable feature it would be in the standard or planned for the next standard. That feature doesn't seem to have a big uptake either, we only had one package that absolutely required porting in sage so far.

Fortunately you don't use it in the functional part of mpfr but it is annoying.

My opinion is that while you make no claim to be standard compliant you should aim towards it and admit it as an issue, it does not have to be a show stopper bug.



---

archive/issue_comments_314468.json:
```json
{
    "body": "> My opinion is that while you make no claim to be standard compliant you should aim towards it and admit it as an issue, it does not have to be a show stopper bug.\n\nfeel free to report to the clang developers. It makes no sense to implement in MPFR a feature that should be implemented by the compiler.\n\nBack to the issue, does `np.float64(5).__gt__(e)` give the warning with clang?\n\nPaul",
    "created_at": "2017-05-05T06:40:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314468",
    "user": "@zimmermann6"
}
```

> My opinion is that while you make no claim to be standard compliant you should aim towards it and admit it as an issue, it does not have to be a show stopper bug.

feel free to report to the clang developers. It makes no sense to implement in MPFR a feature that should be implemented by the compiler.

Back to the issue, does `np.float64(5).__gt__(e)` give the warning with clang?

Paul



---

archive/issue_comments_314469.json:
```json
{
    "body": "anyway, to trace the function `mpfr_exp` for example, you can apply the following patch (against the development version, but it should apply to 3.1.5 as well):\n\n```\n--- src/exp.c   (revision 11456)\n+++ src/exp.c   (working copy)\n@@ -42,10 +42,15 @@\n   int inexact;\n   MPFR_SAVE_EXPO_DECL (expo);\n \n+#if 0\n   MPFR_LOG_FUNC\n     ((\"x[%Pu]=%.*Rg rnd=%d\", mpfr_get_prec (x), mpfr_log_prec, x, rnd_mode),\n      (\"y[%Pu]=%.*Rg inexact=%d\",\n       mpfr_get_prec (y), mpfr_log_prec, y, inexact));\n+#else\n+  mpfr_printf (\"x[%Pu]=%.*Rg rnd=%d\\n\", mpfr_get_prec (x), 6, x, rnd_mode);\n+  fflush (stdout);\n+#endif\n \n   if (MPFR_UNLIKELY( MPFR_IS_SINGULAR(x) ))\n     {\n@@ -185,5 +190,8 @@\n         }\n     }\n \n+  mpfr_printf (\"y[%Pu]=%.*Rg inexact=%d\\n\", mpfr_get_prec (y), 6, y, inexact);\n+  fflush (stdout);\n+\n   return mpfr_check_range (y, inexact, rnd_mode);\n }\n```\n\nThis will enable to see whether the warning occurs inside the `mpfr_exp` call\n(you might want to replace `mpfr_printf(...)` by `mpfr_fprintf (stderr, ...)` if the warning is printed to stderr, and change `fflush(stdout)` into `fflush(stderr)`).",
    "created_at": "2017-05-05T06:51:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314469",
    "user": "@zimmermann6"
}
```

anyway, to trace the function `mpfr_exp` for example, you can apply the following patch (against the development version, but it should apply to 3.1.5 as well):

```
--- src/exp.c   (revision 11456)
+++ src/exp.c   (working copy)
@@ -42,10 +42,15 @@
   int inexact;
   MPFR_SAVE_EXPO_DECL (expo);
 
+#if 0
   MPFR_LOG_FUNC
     (("x[%Pu]=%.*Rg rnd=%d", mpfr_get_prec (x), mpfr_log_prec, x, rnd_mode),
      ("y[%Pu]=%.*Rg inexact=%d",
       mpfr_get_prec (y), mpfr_log_prec, y, inexact));
+#else
+  mpfr_printf ("x[%Pu]=%.*Rg rnd=%d\n", mpfr_get_prec (x), 6, x, rnd_mode);
+  fflush (stdout);
+#endif
 
   if (MPFR_UNLIKELY( MPFR_IS_SINGULAR(x) ))
     {
@@ -185,5 +190,8 @@
         }
     }
 
+  mpfr_printf ("y[%Pu]=%.*Rg inexact=%d\n", mpfr_get_prec (y), 6, y, inexact);
+  fflush (stdout);
+
   return mpfr_check_range (y, inexact, rnd_mode);
 }
```

This will enable to see whether the warning occurs inside the `mpfr_exp` call
(you might want to replace `mpfr_printf(...)` by `mpfr_fprintf (stderr, ...)` if the warning is printed to stderr, and change `fflush(stdout)` into `fflush(stderr)`).



---

archive/issue_comments_314470.json:
```json
{
    "body": "Replying to [comment:68 zimmerma]:\n> Back to the issue, does `np.float64(5).__gt__(e)` give the warning with clang?\n\nYes, at least on OS X:\n\n```\nsage: np.float16(5).__gt__(e)\n/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n  #!/usr/bin/env python\nTrue\nsage: np.float32(5).__gt__(e)\n/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n  #!/usr/bin/env python\nTrue\nsage: np.float64(5).__gt__(e)\n/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n  #!/usr/bin/env python\nTrue\nsage: np.float128(5).__gt__(e)\n/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n  #!/usr/bin/env python\nTrue\n```\n",
    "created_at": "2017-05-08T20:46:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314470",
    "user": "@jhpalmieri"
}
```

Replying to [comment:68 zimmerma]:
> Back to the issue, does `np.float64(5).__gt__(e)` give the warning with clang?

Yes, at least on OS X:

```
sage: np.float16(5).__gt__(e)
/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
  #!/usr/bin/env python
True
sage: np.float32(5).__gt__(e)
/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
  #!/usr/bin/env python
True
sage: np.float64(5).__gt__(e)
/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
  #!/usr/bin/env python
True
sage: np.float128(5).__gt__(e)
/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
  #!/usr/bin/env python
True
```




---

archive/issue_comments_314471.json:
```json
{
    "body": "Replying to [comment:70 jhpalmieri]:\n> Replying to [comment:68 zimmerma]:\n> > Back to the issue, does `np.float64(5).__gt__(e)` give the warning with clang?\n> \n> Yes, at least on OS X:\n> {{{\n> sage: np.float16(5).__gt__(e)\n> /Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n>   #!/usr/bin/env python\n> True\n> sage: np.float32(5).__gt__(e)\n> /Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n>   #!/usr/bin/env python\n> True\n> sage: np.float64(5).__gt__(e)\n> /Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n>   #!/usr/bin/env python\n> True\n> sage: np.float128(5).__gt__(e)\n> /Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n>   #!/usr/bin/env python\n> True\n> }}}\nSame on linux.",
    "created_at": "2017-05-08T21:25:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314471",
    "user": "@kiwifb"
}
```

Replying to [comment:70 jhpalmieri]:
> Replying to [comment:68 zimmerma]:
> > Back to the issue, does `np.float64(5).__gt__(e)` give the warning with clang?
> 
> Yes, at least on OS X:
> {{{
> sage: np.float16(5).__gt__(e)
> /Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
>   #!/usr/bin/env python
> True
> sage: np.float32(5).__gt__(e)
> /Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
>   #!/usr/bin/env python
> True
> sage: np.float64(5).__gt__(e)
> /Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
>   #!/usr/bin/env python
> True
> sage: np.float128(5).__gt__(e)
> /Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
>   #!/usr/bin/env python
> True
> }}}
Same on linux.



---

archive/issue_comments_314472.json:
```json
{
    "body": "With the patch from comment:69:\n\n```\nsage: import numpy as np\nsage: np.float128(5).__gt__(e)\nx[53]=1 rnd=3\ny[53]=2.71828 inexact=-1\nx[53]=1 rnd=2\ny[53]=2.71828 inexact=1\n/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n  #!/usr/bin/env python\nTrue\n```\n",
    "created_at": "2017-05-08T22:41:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314472",
    "user": "@jhpalmieri"
}
```

With the patch from comment:69:

```
sage: import numpy as np
sage: np.float128(5).__gt__(e)
x[53]=1 rnd=3
y[53]=2.71828 inexact=-1
x[53]=1 rnd=2
y[53]=2.71828 inexact=1
/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta5/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
  #!/usr/bin/env python
True
```




---

archive/issue_comments_314473.json:
```json
{
    "body": "Any suggestions for other changes along the lines of comment:69 to help track down the problem?",
    "created_at": "2017-05-08T22:54:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314473",
    "user": "@jhpalmieri"
}
```

Any suggestions for other changes along the lines of comment:69 to help track down the problem?



---

archive/issue_comments_314474.json:
```json
{
    "body": "I suppose anything short of actually setting up a watch on FPU bits will not help much.\n(sorry for slow response - I'm in single-parenting mode for a week :-))",
    "created_at": "2017-05-08T23:24:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314474",
    "user": "@dimpase"
}
```

I suppose anything short of actually setting up a watch on FPU bits will not help much.
(sorry for slow response - I'm in single-parenting mode for a week :-))



---

archive/issue_comments_314475.json:
```json
{
    "body": "from comment [comment:72] it seems the warning occurs **after** the two calls to `mpfr_exp`.\nHere is another patch to see whether it occurs in `mpfr_mul` or `mpfr_add`:\n\n```\nIndex: src/add.c\n===================================================================\n--- src/add.c   (revision 11456)\n+++ src/add.c   (working copy)\n@@ -25,11 +25,16 @@\n MPFR_HOT_FUNCTION_ATTR int\n mpfr_add (mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd_mode)\n {\n+#if 0\n   MPFR_LOG_FUNC\n     ((\"b[%Pu]=%.*Rg c[%Pu]=%.*Rg rnd=%d\",\n       mpfr_get_prec (b), mpfr_log_prec, b,\n       mpfr_get_prec (c), mpfr_log_prec, c, rnd_mode),\n      (\"a[%Pu]=%.*Rg\", mpfr_get_prec (a), mpfr_log_prec, a));\n+#else\n+  printf (\"enter mpfr_add\\n\");\n+  fflush (stdout);\n+#endif\n \n   if (MPFR_ARE_SINGULAR_OR_UBF (b, c))\n     {\n@@ -100,23 +105,28 @@\n   MPFR_ASSERTD (MPFR_IS_PURE_FP (b));\n   MPFR_ASSERTD (MPFR_IS_PURE_FP (c));\n \n+  int ret;\n   if (MPFR_UNLIKELY(MPFR_SIGN(b) != MPFR_SIGN(c)))\n     { /* signs differ, it is a subtraction */\n       if (MPFR_LIKELY(MPFR_PREC(a) == MPFR_PREC(b)\n                       && MPFR_PREC(b) == MPFR_PREC(c)))\n-        return mpfr_sub1sp(a, b, c, rnd_mode);\n+        ret = mpfr_sub1sp(a, b, c, rnd_mode);\n       else\n-        return mpfr_sub1(a, b, c, rnd_mode);\n+        ret = mpfr_sub1(a, b, c, rnd_mode);\n     }\n   else\n     { /* signs are equal, it's an addition */\n       if (MPFR_LIKELY(MPFR_PREC(a) == MPFR_PREC(b)\n                       && MPFR_PREC(b) == MPFR_PREC(c)))\n-        return mpfr_add1sp(a, b, c, rnd_mode);\n+        ret = mpfr_add1sp(a, b, c, rnd_mode);\n       else\n         if (MPFR_GET_EXP(b) < MPFR_GET_EXP(c))\n-          return mpfr_add1(a, c, b, rnd_mode);\n+          ret = mpfr_add1(a, c, b, rnd_mode);\n         else\n-          return mpfr_add1(a, b, c, rnd_mode);\n+          ret = mpfr_add1(a, b, c, rnd_mode);\n     }\n+\n+  printf (\"exit mpfr_add\\n\");\n+  fflush (stdout);\n+  return ret;\n }\nIndex: src/mul.c\n===================================================================\n--- src/mul.c   (revision 11456)\n+++ src/mul.c   (working copy)\n@@ -688,6 +688,7 @@\n   mp_size_t bn, cn, tn, k, threshold;\n   MPFR_TMP_DECL (marker);\n \n+#if 0\n   MPFR_LOG_FUNC\n     ((\"b[%Pu]=%.*Rg c[%Pu]=%.*Rg rnd=%d\",\n       mpfr_get_prec (b), mpfr_log_prec, b,\n@@ -694,6 +695,10 @@\n       mpfr_get_prec (c), mpfr_log_prec, c, rnd_mode),\n      (\"a[%Pu]=%.*Rg inexact=%d\",\n       mpfr_get_prec (a), mpfr_log_prec, a, inexact));\n+#else\n+  printf (\"enter mpfr_mul\\n\");\n+  fflush (stdout);\n+#endif\n \n   /* deal with special cases */\n   if (MPFR_ARE_SINGULAR (b, c))\n@@ -1030,5 +1035,7 @@\n         rnd_mode = MPFR_RNDZ;\n       return mpfr_underflow (a, rnd_mode, sign);\n     }\n+  printf (\"exit mpfr_mul\\n\");\n+  fflush (stdout);\n   MPFR_RET (inexact);\n }\n```\n\nSide question: what routine of MPFR (if any) does `np.float128(5).__gt__` call?",
    "created_at": "2017-05-09T06:59:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314475",
    "user": "@zimmermann6"
}
```

from comment [comment:72] it seems the warning occurs **after** the two calls to `mpfr_exp`.
Here is another patch to see whether it occurs in `mpfr_mul` or `mpfr_add`:

```
Index: src/add.c
===================================================================
--- src/add.c   (revision 11456)
+++ src/add.c   (working copy)
@@ -25,11 +25,16 @@
 MPFR_HOT_FUNCTION_ATTR int
 mpfr_add (mpfr_ptr a, mpfr_srcptr b, mpfr_srcptr c, mpfr_rnd_t rnd_mode)
 {
+#if 0
   MPFR_LOG_FUNC
     (("b[%Pu]=%.*Rg c[%Pu]=%.*Rg rnd=%d",
       mpfr_get_prec (b), mpfr_log_prec, b,
       mpfr_get_prec (c), mpfr_log_prec, c, rnd_mode),
      ("a[%Pu]=%.*Rg", mpfr_get_prec (a), mpfr_log_prec, a));
+#else
+  printf ("enter mpfr_add\n");
+  fflush (stdout);
+#endif
 
   if (MPFR_ARE_SINGULAR_OR_UBF (b, c))
     {
@@ -100,23 +105,28 @@
   MPFR_ASSERTD (MPFR_IS_PURE_FP (b));
   MPFR_ASSERTD (MPFR_IS_PURE_FP (c));
 
+  int ret;
   if (MPFR_UNLIKELY(MPFR_SIGN(b) != MPFR_SIGN(c)))
     { /* signs differ, it is a subtraction */
       if (MPFR_LIKELY(MPFR_PREC(a) == MPFR_PREC(b)
                       && MPFR_PREC(b) == MPFR_PREC(c)))
-        return mpfr_sub1sp(a, b, c, rnd_mode);
+        ret = mpfr_sub1sp(a, b, c, rnd_mode);
       else
-        return mpfr_sub1(a, b, c, rnd_mode);
+        ret = mpfr_sub1(a, b, c, rnd_mode);
     }
   else
     { /* signs are equal, it's an addition */
       if (MPFR_LIKELY(MPFR_PREC(a) == MPFR_PREC(b)
                       && MPFR_PREC(b) == MPFR_PREC(c)))
-        return mpfr_add1sp(a, b, c, rnd_mode);
+        ret = mpfr_add1sp(a, b, c, rnd_mode);
       else
         if (MPFR_GET_EXP(b) < MPFR_GET_EXP(c))
-          return mpfr_add1(a, c, b, rnd_mode);
+          ret = mpfr_add1(a, c, b, rnd_mode);
         else
-          return mpfr_add1(a, b, c, rnd_mode);
+          ret = mpfr_add1(a, b, c, rnd_mode);
     }
+
+  printf ("exit mpfr_add\n");
+  fflush (stdout);
+  return ret;
 }
Index: src/mul.c
===================================================================
--- src/mul.c   (revision 11456)
+++ src/mul.c   (working copy)
@@ -688,6 +688,7 @@
   mp_size_t bn, cn, tn, k, threshold;
   MPFR_TMP_DECL (marker);
 
+#if 0
   MPFR_LOG_FUNC
     (("b[%Pu]=%.*Rg c[%Pu]=%.*Rg rnd=%d",
       mpfr_get_prec (b), mpfr_log_prec, b,
@@ -694,6 +695,10 @@
       mpfr_get_prec (c), mpfr_log_prec, c, rnd_mode),
      ("a[%Pu]=%.*Rg inexact=%d",
       mpfr_get_prec (a), mpfr_log_prec, a, inexact));
+#else
+  printf ("enter mpfr_mul\n");
+  fflush (stdout);
+#endif
 
   /* deal with special cases */
   if (MPFR_ARE_SINGULAR (b, c))
@@ -1030,5 +1035,7 @@
         rnd_mode = MPFR_RNDZ;
       return mpfr_underflow (a, rnd_mode, sign);
     }
+  printf ("exit mpfr_mul\n");
+  fflush (stdout);
   MPFR_RET (inexact);
 }
```

Side question: what routine of MPFR (if any) does `np.float128(5).__gt__` call?



---

archive/issue_comments_314476.json:
```json
{
    "body": "Replying to [comment:75 zimmerma]:\n> from comment [comment:72] it seems the warning occurs **after** the two calls to `mpfr_exp`.\n\nThis is correct; there is no interrupt mechanics set that would make sure the warning printed immediately. The warning is printed **after** `numpy` completes the task of computing the value of \n`np.float128(5).__gt__(e)`, before it returns the result.\n\n> Side question: what routine of MPFR (if any) does `np.float128(5).__gt__` call?\nNumpy people told us some details [here](https://github.com/numpy/numpy/issues/9007#issuecomment-298935092). \nThey say that behind the curtains it will try calling something like `e.__lt__`, assuming `e` is the argument (and all this happens within a compiled module written in (generated) C, making it hard to debug easily).\n\nSo we have two Python-based computer algebra systems not talking to each other too well...",
    "created_at": "2017-05-09T07:46:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314476",
    "user": "@dimpase"
}
```

Replying to [comment:75 zimmerma]:
> from comment [comment:72] it seems the warning occurs **after** the two calls to `mpfr_exp`.

This is correct; there is no interrupt mechanics set that would make sure the warning printed immediately. The warning is printed **after** `numpy` completes the task of computing the value of 
`np.float128(5).__gt__(e)`, before it returns the result.

> Side question: what routine of MPFR (if any) does `np.float128(5).__gt__` call?
Numpy people told us some details [here](https://github.com/numpy/numpy/issues/9007#issuecomment-298935092). 
They say that behind the curtains it will try calling something like `e.__lt__`, assuming `e` is the argument (and all this happens within a compiled module written in (generated) C, making it hard to debug easily).

So we have two Python-based computer algebra systems not talking to each other too well...



---

archive/issue_comments_314477.json:
```json
{
    "body": "my guess is the following:\n\n(1) first intervals of MPFR values are computed that enclose 5 and exp(1)\n\n(2) then those intervals are converted into the `np.float128` type\n\n(3) then the comparison is performed\n\nI guess the warning occurs because a NaN was generated in step (2). It might be inside the `mpfr_get_float128` function. Here is another patch to check:\n\n```\nIndex: src/get_float128.c\n===================================================================\n--- src/get_float128.c  (revision 11456)\n+++ src/get_float128.c  (working copy)\n@@ -30,8 +30,15 @@\n mpfr_get_float128 (mpfr_srcptr x, mpfr_rnd_t rnd_mode)\n {\n \n+  printf (\"enter mpfr_get_float128\\n\");\n+  fflush (stdout);\n+\n   if (MPFR_UNLIKELY (MPFR_IS_SINGULAR (x)))\n-    return (__float128) mpfr_get_d (x, rnd_mode);\n+    {\n+      printf (\"exit mpfr_get_float128: MPFR_IS_SINGULAR(x)\\n\");\n+      fflush (stdout);\n+      return (__float128) mpfr_get_d (x, rnd_mode);\n+    }\n   else /* now x is a normal non-zero number */\n     {\n       __float128 r; /* result */\n@@ -97,6 +104,8 @@\n         }\n       if (sign < 0)\n         r = -r;\n+      printf (\"exit mpfr_get_float128: normal case\\n\");\n+      fflush (stdout);\n       return r;\n     }\n }\n```\n",
    "created_at": "2017-05-09T08:17:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314477",
    "user": "@zimmermann6"
}
```

my guess is the following:

(1) first intervals of MPFR values are computed that enclose 5 and exp(1)

(2) then those intervals are converted into the `np.float128` type

(3) then the comparison is performed

I guess the warning occurs because a NaN was generated in step (2). It might be inside the `mpfr_get_float128` function. Here is another patch to check:

```
Index: src/get_float128.c
===================================================================
--- src/get_float128.c  (revision 11456)
+++ src/get_float128.c  (working copy)
@@ -30,8 +30,15 @@
 mpfr_get_float128 (mpfr_srcptr x, mpfr_rnd_t rnd_mode)
 {
 
+  printf ("enter mpfr_get_float128\n");
+  fflush (stdout);
+
   if (MPFR_UNLIKELY (MPFR_IS_SINGULAR (x)))
-    return (__float128) mpfr_get_d (x, rnd_mode);
+    {
+      printf ("exit mpfr_get_float128: MPFR_IS_SINGULAR(x)\n");
+      fflush (stdout);
+      return (__float128) mpfr_get_d (x, rnd_mode);
+    }
   else /* now x is a normal non-zero number */
     {
       __float128 r; /* result */
@@ -97,6 +104,8 @@
         }
       if (sign < 0)
         r = -r;
+      printf ("exit mpfr_get_float128: normal case\n");
+      fflush (stdout);
       return r;
     }
 }
```




---

archive/issue_comments_314478.json:
```json
{
    "body": "I don't see `get_float128.c` in version 3.1.5. I've tried to use similar patches in `get_ld.c`, `get_d64.c`, and `get_float.c`, but none of the relevant functions print anything when I run `np.float128(5).__gt__(e)` (or the same with `np.float64`, etc.).",
    "created_at": "2017-05-09T19:51:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314478",
    "user": "@jhpalmieri"
}
```

I don't see `get_float128.c` in version 3.1.5. I've tried to use similar patches in `get_ld.c`, `get_d64.c`, and `get_float.c`, but none of the relevant functions print anything when I run `np.float128(5).__gt__(e)` (or the same with `np.float64`, etc.).



---

archive/issue_comments_314479.json:
```json
{
    "body": "Replying to [comment:77 zimmerma]:\n> my guess is the following:\n> \n> (1) first intervals of MPFR values are computed that enclose 5 and exp(1)\n> \n> (2) then those intervals are converted into the `np.float128` type\n\nIMHO it is different (and isn't in so by the complete(?) trace in comment 65 above): `numpy` has no way to convert MPFR numbers into `numpy` numbers,\nwithout asking Sage to do this. And it does not even know that Sage can do it. So it all happens on the level of Python data: `numpy` knows that after getting \"not implemented\" from `np.float128(5).__gt__(e)` it may try `e.__lt__(np.float128(5))`.\nAnd the latter invokes comparison in Sage, done with MPFR numbers.\n\n> \n> (3) then the comparison is performed\n\nIsn't the actual comparison is performed on MPFR numbers rather than on `numpy` numbers?\nAs above\n\n```\n> mpfr_add:IN  b[53]=-5 c[53]=2.71828 rnd=3\n> mpfr_add:TIM 0ms\n> mpfr_add:OUT a[53]=-2.28172\n> mpfr_add:IN  b[53]=-5 c[53]=2.71828 rnd=2\n> mpfr_add:TIM 0ms\n```\n",
    "created_at": "2017-05-09T20:25:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314479",
    "user": "@dimpase"
}
```

Replying to [comment:77 zimmerma]:
> my guess is the following:
> 
> (1) first intervals of MPFR values are computed that enclose 5 and exp(1)
> 
> (2) then those intervals are converted into the `np.float128` type

IMHO it is different (and isn't in so by the complete(?) trace in comment 65 above): `numpy` has no way to convert MPFR numbers into `numpy` numbers,
without asking Sage to do this. And it does not even know that Sage can do it. So it all happens on the level of Python data: `numpy` knows that after getting "not implemented" from `np.float128(5).__gt__(e)` it may try `e.__lt__(np.float128(5))`.
And the latter invokes comparison in Sage, done with MPFR numbers.

> 
> (3) then the comparison is performed

Isn't the actual comparison is performed on MPFR numbers rather than on `numpy` numbers?
As above

```
> mpfr_add:IN  b[53]=-5 c[53]=2.71828 rnd=3
> mpfr_add:TIM 0ms
> mpfr_add:OUT a[53]=-2.28172
> mpfr_add:IN  b[53]=-5 c[53]=2.71828 rnd=2
> mpfr_add:TIM 0ms
```




---

archive/issue_comments_314480.json:
```json
{
    "body": "> Isn't the actual comparison is performed on MPFR numbers rather than on numpy numbers?\n\nyes it might be, since after the two `mpfr_add` calls we should get an interval [u,v] where\nexp(1)-5 lies. Then I guess Sage should check whether `u > 0` or `v < 0`. But this is possible via several MPFR functions (which are not logged through `--enable-logging`). It could be\n`mpfr_cmp_ui (u, 0)`, or `mpfr_cmp (u, zero)` since zero is predefined, or `mpfr_sgn(u)`. One should add logging in those functions to see which one is called.",
    "created_at": "2017-05-10T06:56:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314480",
    "user": "@zimmermann6"
}
```

> Isn't the actual comparison is performed on MPFR numbers rather than on numpy numbers?

yes it might be, since after the two `mpfr_add` calls we should get an interval [u,v] where
exp(1)-5 lies. Then I guess Sage should check whether `u > 0` or `v < 0`. But this is possible via several MPFR functions (which are not logged through `--enable-logging`). It could be
`mpfr_cmp_ui (u, 0)`, or `mpfr_cmp (u, zero)` since zero is predefined, or `mpfr_sgn(u)`. One should add logging in those functions to see which one is called.



---

archive/issue_comments_314481.json:
```json
{
    "body": "As far as I can tell, the last thing called (or at least the last thing called in which I've added logging) before numpy reports an error is `mpfr_cmp3`.",
    "created_at": "2017-05-11T18:59:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314481",
    "user": "@jhpalmieri"
}
```

As far as I can tell, the last thing called (or at least the last thing called in which I've added logging) before numpy reports an error is `mpfr_cmp3`.



---

archive/issue_comments_314482.json:
```json
{
    "body": "> As far as I can tell, the last thing called (or at least the last thing called in which I've added logging) before numpy reports an error is `mpfr_cmp3`.\n\nplease could you test with the following patch (against mpfr-3.1.5)?\n\n```\n--- cmp.c       2016-09-27 09:58:15.000000000 +0200\n+++ /tmp/cmp.c  2017-05-12 08:32:54.914688069 +0200\n@@ -35,6 +35,11 @@\n   mp_size_t bn, cn;\n   mp_limb_t *bp, *cp;\n \n+  printf (\"enter mpfr_cmp3\\n\");\n+  printf (\"b=\"); mpfr_dump (b);\n+  printf (\"c=\"); mpfr_dump (c);\n+  printf (\"s=%d\\n\", s);\n+\n   s = MPFR_MULT_SIGN( s , MPFR_SIGN(c) );\n \n   if (MPFR_ARE_SINGULAR(b, c))\n@@ -42,34 +47,59 @@\n       if (MPFR_IS_NAN (b) || MPFR_IS_NAN (c))\n         {\n           MPFR_SET_ERANGE ();\n+          printf (\"exit mpfr_cmp3: NaN case\\n\");\n           return 0;\n         }\n       else if (MPFR_IS_INF(b))\n         {\n           if (MPFR_IS_INF(c) && s == MPFR_SIGN(b) )\n-            return 0;\n+            {\n+              printf (\"exit mpfr_cmp3: Inf1 case\\n\");\n+              return 0;\n+            }\n           else\n-            return MPFR_SIGN(b);\n+            {\n+              printf (\"exit mpfr_cmp3: Inf2 case\\n\");\n+              return MPFR_SIGN(b);\n+            }\n         }\n       else if (MPFR_IS_INF(c))\n-        return -s;\n+        {\n+          printf (\"exit mpfr_cmp3: Inf3 case\\n\");\n+          return -s;\n+        }\n       else if (MPFR_IS_ZERO(b))\n-        return MPFR_IS_ZERO(c) ? 0 : -s;\n+        {\n+          printf (\"exit mpfr_cmp3: zero1 case\\n\");\n+          return MPFR_IS_ZERO(c) ? 0 : -s;\n+        }\n       else /* necessarily c=0 */\n-        return MPFR_SIGN(b);\n+        {\n+          return MPFR_SIGN(b);\n+          printf (\"exit mpfr_cmp3: zero2 case\\n\");\n+        }\n     }\n   /* b and c are real numbers */\n   if (s != MPFR_SIGN(b))\n-    return MPFR_SIGN(b);\n+    {\n+      printf (\"exit mpfr_cmp3: s != MPFR_SIGN(b)\\n\");\n+      return MPFR_SIGN(b);\n+    }\n \n   /* now signs are equal */\n \n   be = MPFR_GET_EXP (b);\n   ce = MPFR_GET_EXP (c);\n   if (be > ce)\n-    return s;\n+    {\n+      printf (\"exit mpfr_cmp3: be > ce\\n\");\n+      return s;\n+    }\n   if (be < ce)\n-    return -s;\n+    {\n+      printf (\"exit mpfr_cmp3: be < ce\\n\");\n+      return -s;\n+    }\n \n   /* both signs and exponents are equal */\n \n@@ -82,18 +112,31 @@\n   for ( ; bn >= 0 && cn >= 0; bn--, cn--)\n     {\n       if (bp[bn] > cp[cn])\n-        return s;\n+        {\n+          printf (\"exit mpfr_cmp3: bp[bn] > cp[cn]\\n\");\n+          return s;\n+        }\n       if (bp[bn] < cp[cn])\n-        return -s;\n+        {\n+          printf (\"exit mpfr_cmp3: bp[bn] < cp[cn]\\n\");\n+          return -s;\n+        }\n     }\n   for ( ; bn >= 0; bn--)\n     if (bp[bn])\n-      return s;\n+      {\n+        printf (\"exit mpfr_cmp3: bp[bn] > 0\\n\");\n+        return s;\n+      }\n   for ( ; cn >= 0; cn--)\n     if (cp[cn])\n-      return -s;\n+      {\n+        printf (\"exit mpfr_cmp3: cp[bn] > 0\\n\");\n+        return -s;\n+      }\n \n-   return 0;\n+  printf (\"exit mpfr_cmp3: equal case\\n\");\n+  return 0;\n }\n \n #undef mpfr_cmp\n```\n",
    "created_at": "2017-05-12T06:36:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314482",
    "user": "@zimmermann6"
}
```

> As far as I can tell, the last thing called (or at least the last thing called in which I've added logging) before numpy reports an error is `mpfr_cmp3`.

please could you test with the following patch (against mpfr-3.1.5)?

```
--- cmp.c       2016-09-27 09:58:15.000000000 +0200
+++ /tmp/cmp.c  2017-05-12 08:32:54.914688069 +0200
@@ -35,6 +35,11 @@
   mp_size_t bn, cn;
   mp_limb_t *bp, *cp;
 
+  printf ("enter mpfr_cmp3\n");
+  printf ("b="); mpfr_dump (b);
+  printf ("c="); mpfr_dump (c);
+  printf ("s=%d\n", s);
+
   s = MPFR_MULT_SIGN( s , MPFR_SIGN(c) );
 
   if (MPFR_ARE_SINGULAR(b, c))
@@ -42,34 +47,59 @@
       if (MPFR_IS_NAN (b) || MPFR_IS_NAN (c))
         {
           MPFR_SET_ERANGE ();
+          printf ("exit mpfr_cmp3: NaN case\n");
           return 0;
         }
       else if (MPFR_IS_INF(b))
         {
           if (MPFR_IS_INF(c) && s == MPFR_SIGN(b) )
-            return 0;
+            {
+              printf ("exit mpfr_cmp3: Inf1 case\n");
+              return 0;
+            }
           else
-            return MPFR_SIGN(b);
+            {
+              printf ("exit mpfr_cmp3: Inf2 case\n");
+              return MPFR_SIGN(b);
+            }
         }
       else if (MPFR_IS_INF(c))
-        return -s;
+        {
+          printf ("exit mpfr_cmp3: Inf3 case\n");
+          return -s;
+        }
       else if (MPFR_IS_ZERO(b))
-        return MPFR_IS_ZERO(c) ? 0 : -s;
+        {
+          printf ("exit mpfr_cmp3: zero1 case\n");
+          return MPFR_IS_ZERO(c) ? 0 : -s;
+        }
       else /* necessarily c=0 */
-        return MPFR_SIGN(b);
+        {
+          return MPFR_SIGN(b);
+          printf ("exit mpfr_cmp3: zero2 case\n");
+        }
     }
   /* b and c are real numbers */
   if (s != MPFR_SIGN(b))
-    return MPFR_SIGN(b);
+    {
+      printf ("exit mpfr_cmp3: s != MPFR_SIGN(b)\n");
+      return MPFR_SIGN(b);
+    }
 
   /* now signs are equal */
 
   be = MPFR_GET_EXP (b);
   ce = MPFR_GET_EXP (c);
   if (be > ce)
-    return s;
+    {
+      printf ("exit mpfr_cmp3: be > ce\n");
+      return s;
+    }
   if (be < ce)
-    return -s;
+    {
+      printf ("exit mpfr_cmp3: be < ce\n");
+      return -s;
+    }
 
   /* both signs and exponents are equal */
 
@@ -82,18 +112,31 @@
   for ( ; bn >= 0 && cn >= 0; bn--, cn--)
     {
       if (bp[bn] > cp[cn])
-        return s;
+        {
+          printf ("exit mpfr_cmp3: bp[bn] > cp[cn]\n");
+          return s;
+        }
       if (bp[bn] < cp[cn])
-        return -s;
+        {
+          printf ("exit mpfr_cmp3: bp[bn] < cp[cn]\n");
+          return -s;
+        }
     }
   for ( ; bn >= 0; bn--)
     if (bp[bn])
-      return s;
+      {
+        printf ("exit mpfr_cmp3: bp[bn] > 0\n");
+        return s;
+      }
   for ( ; cn >= 0; cn--)
     if (cp[cn])
-      return -s;
+      {
+        printf ("exit mpfr_cmp3: cp[bn] > 0\n");
+        return -s;
+      }
 
-   return 0;
+  printf ("exit mpfr_cmp3: equal case\n");
+  return 0;
 }
 
 #undef mpfr_cmp
```




---

archive/issue_comments_314483.json:
```json
{
    "body": "I get this:\n\n```\nenter mpfr_cmp3\nb=-0\nc=0.10011011111100001010100010110001010001010111011010010E1\ns=1\nexit mpfr_cmp3: zero1 case\n/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta4/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in less\n  #!/usr/bin/env python\n```\n",
    "created_at": "2017-05-12T18:14:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314483",
    "user": "@jhpalmieri"
}
```

I get this:

```
enter mpfr_cmp3
b=-0
c=0.10011011111100001010100010110001010001010111011010010E1
s=1
exit mpfr_cmp3: zero1 case
/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta4/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in less
  #!/usr/bin/env python
```




---

archive/issue_comments_314484.json:
```json
{
    "body": "I see no \"less\" comparison in the `mpfr_cmp3` branch corresponding to the `zero1` case. The `invalid value encountered in less` warning might correspond to a comparison with NaN, but neither b nor c are NaN here.",
    "created_at": "2017-05-13T07:31:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314484",
    "user": "@zimmermann6"
}
```

I see no "less" comparison in the `mpfr_cmp3` branch corresponding to the `zero1` case. The `invalid value encountered in less` warning might correspond to a comparison with NaN, but neither b nor c are NaN here.



---

archive/issue_comments_314485.json:
```json
{
    "body": "What the the Python call that triggers this?\n\nIt used to be `np.float64(5).__gt__(e)`, giving invalid value in `greater` warning. Does the same call with patched MPFR give invalid value in `less` warning?",
    "created_at": "2017-05-13T07:54:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314485",
    "user": "@dimpase"
}
```

What the the Python call that triggers this?

It used to be `np.float64(5).__gt__(e)`, giving invalid value in `greater` warning. Does the same call with patched MPFR give invalid value in `less` warning?



---

archive/issue_comments_314486.json:
```json
{
    "body": "I get warnings with both `__gt__` and `__lt__`; the one in comment:83 was from `__lt__`. When I do `np.float64('1.5').__gt__(e)`, the various logging messages end in this:\n\n```\nenter mpfr_cmp3\nb=0.10011011111100001010100010110001010001010111011010100E1\nc=0\ns=1\nenter mpfr_cmp3\nb=-0\nc=0.10011011111100001010100010110001010001010111011010010E1\ns=1\nexit mpfr_cmp3: zero1 case\n/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta4/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater\n  #!/usr/bin/env python\n```\n",
    "created_at": "2017-05-13T16:03:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314486",
    "user": "@jhpalmieri"
}
```

I get warnings with both `__gt__` and `__lt__`; the one in comment:83 was from `__lt__`. When I do `np.float64('1.5').__gt__(e)`, the various logging messages end in this:

```
enter mpfr_cmp3
b=0.10011011111100001010100010110001010001010111011010100E1
c=0
s=1
enter mpfr_cmp3
b=-0
c=0.10011011111100001010100010110001010001010111011010010E1
s=1
exit mpfr_cmp3: zero1 case
/Users/jpalmier/Desktop/Sage_stuff/sage_builds/TESTING/sage-8.0.beta4/src/bin/sage-ipython:1: RuntimeWarning: invalid value encountered in greater
  #!/usr/bin/env python
```




---

archive/issue_comments_314487.json:
```json
{
    "body": "Replying to [comment:84 zimmerma]:\n> I see no \"less\" comparison in the `mpfr_cmp3` branch corresponding to the `zero1` case. The `invalid value encountered in less` warning might correspond to a comparison with NaN, but neither b nor c are NaN here.\n\nis there a \"greater\" comparison? This is the one that would correspond to `__lt__` in the original call, as numpy people tell us.",
    "created_at": "2017-05-13T19:47:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314487",
    "user": "@dimpase"
}
```

Replying to [comment:84 zimmerma]:
> I see no "less" comparison in the `mpfr_cmp3` branch corresponding to the `zero1` case. The `invalid value encountered in less` warning might correspond to a comparison with NaN, but neither b nor c are NaN here.

is there a "greater" comparison? This is the one that would correspond to `__lt__` in the original call, as numpy people tell us.



---

archive/issue_comments_314488.json:
```json
{
    "body": "> is there a \"greater\" comparison?\n\nthere is no \"greater\" comparison either. The only comparisons are between exponents and words of the significand, but no such comparison occurs when one of the operands is zero.\nAnd anyway, there is no double-precision `NaN` in that function.",
    "created_at": "2017-05-14T11:47:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314488",
    "user": "@zimmermann6"
}
```

> is there a "greater" comparison?

there is no "greater" comparison either. The only comparisons are between exponents and words of the significand, but no such comparison occurs when one of the operands is zero.
And anyway, there is no double-precision `NaN` in that function.



---

archive/issue_comments_314489.json:
```json
{
    "body": "here is somewhat less involved way to trigger this, not involving running through numpy evaluation loop\n\n```\nimport numpy as np\nfrom ctypes import cdll\nfrom ctypes.util import find_library\nlibm = cdll.LoadLibrary(find_library('m'))\nprint libm.fetestexcept(int(0x01)) # checks if FE_INVALID is set\nbool(e.__lt__(np.float32('1.5')))\nprint libm.fetestexcept(int(0x01))\n```\n\nRunning this on Linux/gcc produces\n\n```\n0\nFalse\n0\n```\n\nwhile on FreeBSD/clang I get\n\n```\n0\nFalse\n1\n```\n\n\nAfter I've found this, I decided to check whether merely importing numpy does something to the FPU flags on FreeBSD, and in fact it does! Namely, the output of\n\n```\nfrom ctypes import cdll\nfrom ctypes.util import find_library\nlibm = cdll.LoadLibrary(find_library('m'))\nprint libm.fetestexcept(int(0x01))\nimport numpy\nprint libm.fetestexcept(int(0x01))\n```\n\nis\n\n```\n0\n0\n```\n\non Linux/gcc, and\n\n```\n1\n0\n```\n\non FreeBSD/clang! And in fact one can see that the FE_INVALID bit is flipped by\n\n```\nbool(e.__lt__(float('1.5')))\n```\n\njust as well:\n\n```\nsage: import numpy \n....: from ctypes import cdll\n....: from ctypes.util import find_library\n....: libm = cdll.LoadLibrary(find_library('m'))\n....: print libm.fetestexcept(int(0x01))\n....: bool(e.__lt__(float('1.5')))\n....: print libm.fetestexcept(int(0x01))\n....: \n0\nFalse\n1\n```\n\non FreeBSD/clang (but the last 1 becomes 0 on Linux/gcc).",
    "created_at": "2017-05-15T15:35:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314489",
    "user": "@dimpase"
}
```

here is somewhat less involved way to trigger this, not involving running through numpy evaluation loop

```
import numpy as np
from ctypes import cdll
from ctypes.util import find_library
libm = cdll.LoadLibrary(find_library('m'))
print libm.fetestexcept(int(0x01)) # checks if FE_INVALID is set
bool(e.__lt__(np.float32('1.5')))
print libm.fetestexcept(int(0x01))
```

Running this on Linux/gcc produces

```
0
False
0
```

while on FreeBSD/clang I get

```
0
False
1
```


After I've found this, I decided to check whether merely importing numpy does something to the FPU flags on FreeBSD, and in fact it does! Namely, the output of

```
from ctypes import cdll
from ctypes.util import find_library
libm = cdll.LoadLibrary(find_library('m'))
print libm.fetestexcept(int(0x01))
import numpy
print libm.fetestexcept(int(0x01))
```

is

```
0
0
```

on Linux/gcc, and

```
1
0
```

on FreeBSD/clang! And in fact one can see that the FE_INVALID bit is flipped by

```
bool(e.__lt__(float('1.5')))
```

just as well:

```
sage: import numpy 
....: from ctypes import cdll
....: from ctypes.util import find_library
....: libm = cdll.LoadLibrary(find_library('m'))
....: print libm.fetestexcept(int(0x01))
....: bool(e.__lt__(float('1.5')))
....: print libm.fetestexcept(int(0x01))
....: 
0
False
1
```

on FreeBSD/clang (but the last 1 becomes 0 on Linux/gcc).



---

archive/issue_comments_314490.json:
```json
{
    "body": "That is, we also need to debug Sage for a place that flips FE_INVALID!\n\n```\n$ ./sage --python\nPython 2.7.13 (default, May 14 2017, 23:48:25) \n[GCC 4.2.1 Compatible Clang 4.0.0 ] on freebsd11\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> from ctypes import cdll\n>>> from ctypes.util import find_library\n>>> libm = cdll.LoadLibrary(find_library('m'))\n>>> print libm.fetestexcept(int(0x01))\n0\n>>> from sage.all import *\n>>> print libm.fetestexcept(int(0x01))\n1\n```\n",
    "created_at": "2017-05-15T15:37:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314490",
    "user": "@dimpase"
}
```

That is, we also need to debug Sage for a place that flips FE_INVALID!

```
$ ./sage --python
Python 2.7.13 (default, May 14 2017, 23:48:25) 
[GCC 4.2.1 Compatible Clang 4.0.0 ] on freebsd11
Type "help", "copyright", "credits" or "license" for more information.
>>> from ctypes import cdll
>>> from ctypes.util import find_library
>>> libm = cdll.LoadLibrary(find_library('m'))
>>> print libm.fetestexcept(int(0x01))
0
>>> from sage.all import *
>>> print libm.fetestexcept(int(0x01))
1
```




---

archive/issue_comments_314491.json:
```json
{
    "body": "I added a bunch of `print (\"TAG: {}\".format(libm.fetestexcept(int(0x01))))` statements with various tags. The result changes from 0 to 1 in the file `sage/libs/pynac/pynac.pyx`, at the line `init_pynac_I()`. Within that function, it changes at the line\n\n```\n  K = QuadraticField(-1, 'I', embedding=CC.gen(), latex_name='i')\n```\n\nQuadratic fields are constructed using `UniqueFactory`, and the result changes from 0 to 1 in the `try/except` block\n\n```\n        cache_key = key\n        print (\"020: {}\".format(libm.fetestexcept(int(0x01))))\n        try:\n            try:\n                return self._cache[version, cache_key]\n            except TypeError: # key is unhashable\n                print (\"030: {}\".format(libm.fetestexcept(int(0x01))))\n                cache_key = _cache_key(cache_key)\n                return self._cache[version, cache_key]\n        except KeyError:\n            print (\"040: {}\".format(libm.fetestexcept(int(0x01))))\n            pass\n```\n\nin the `get_object` method for `UniqueFactory` in sage/structure/factory.pyx. With the print statements as indicated, I see\n\n```\n020: 0\n040: 1\n050: 1\n```\n\nSo is it something to do with the cache? The cache is defined by\n\n```\nself._cache = sage.misc.weak_dict.WeakValueDictionary()\n```\n\nSo is something going on with Sage's weak dictionaries?\n\nThere is also the possibility that I'm misinterpreting everything and the problem is somewhere else completely.",
    "created_at": "2017-05-15T16:15:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314491",
    "user": "@jhpalmieri"
}
```

I added a bunch of `print ("TAG: {}".format(libm.fetestexcept(int(0x01))))` statements with various tags. The result changes from 0 to 1 in the file `sage/libs/pynac/pynac.pyx`, at the line `init_pynac_I()`. Within that function, it changes at the line

```
  K = QuadraticField(-1, 'I', embedding=CC.gen(), latex_name='i')
```

Quadratic fields are constructed using `UniqueFactory`, and the result changes from 0 to 1 in the `try/except` block

```
        cache_key = key
        print ("020: {}".format(libm.fetestexcept(int(0x01))))
        try:
            try:
                return self._cache[version, cache_key]
            except TypeError: # key is unhashable
                print ("030: {}".format(libm.fetestexcept(int(0x01))))
                cache_key = _cache_key(cache_key)
                return self._cache[version, cache_key]
        except KeyError:
            print ("040: {}".format(libm.fetestexcept(int(0x01))))
            pass
```

in the `get_object` method for `UniqueFactory` in sage/structure/factory.pyx. With the print statements as indicated, I see

```
020: 0
040: 1
050: 1
```

So is it something to do with the cache? The cache is defined by

```
self._cache = sage.misc.weak_dict.WeakValueDictionary()
```

So is something going on with Sage's weak dictionaries?

There is also the possibility that I'm misinterpreting everything and the problem is somewhere else completely.



---

archive/issue_comments_314492.json:
```json
{
    "body": "I don't get the need of nested try/except blocks in that fragment of the code, is it just some leftover?",
    "created_at": "2017-05-15T20:50:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314492",
    "user": "@dimpase"
}
```

I don't get the need of nested try/except blocks in that fragment of the code, is it just some leftover?



---

archive/issue_comments_314493.json:
```json
{
    "body": "I suppose it should be\n\n```\ntry:\n    blah\nexcept TypeError:\n    blah\nexcept KeyError:\n    pass\n```\n\n?",
    "created_at": "2017-05-15T20:55:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314493",
    "user": "@jhpalmieri"
}
```

I suppose it should be

```
try:
    blah
except TypeError:
    blah
except KeyError:
    pass
```

?



---

archive/issue_comments_314494.json:
```json
{
    "body": "Unless the last `except` is also there to catch a `KeyError` in the call to `return self._cache[version, cache_key]` within the first `except` clause.",
    "created_at": "2017-05-15T21:26:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314494",
    "user": "@jhpalmieri"
}
```

Unless the last `except` is also there to catch a `KeyError` in the call to `return self._cache[version, cache_key]` within the first `except` clause.



---

archive/issue_comments_314495.json:
```json
{
    "body": "what happens if you remove the `except KeyError` part?",
    "created_at": "2017-05-16T07:58:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314495",
    "user": "@zimmermann6"
}
```

what happens if you remove the `except KeyError` part?



---

archive/issue_comments_314496.json:
```json
{
    "body": "Probably one should try building [fpectl Python module](https://docs.python.org/2/library/fpectl.html#module-fpectl) (not in Sage Python) and use it to locate where flags are raised during the import.",
    "created_at": "2017-05-16T09:25:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314496",
    "user": "@dimpase"
}
```

Probably one should try building [fpectl Python module](https://docs.python.org/2/library/fpectl.html#module-fpectl) (not in Sage Python) and use it to locate where flags are raised during the import.



---

archive/issue_comments_314497.json:
```json
{
    "body": "Replying to [comment:96 dimpase]:\n> Probably one should try building [fpectl Python module](https://docs.python.org/2/library/fpectl.html#module-fpectl) (not in Sage Python) and use it to locate where flags are raised during the import.\n\ngood idea. I'm curious to see where a NaN is generated.",
    "created_at": "2017-05-16T09:44:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314497",
    "user": "@zimmermann6"
}
```

Replying to [comment:96 dimpase]:
> Probably one should try building [fpectl Python module](https://docs.python.org/2/library/fpectl.html#module-fpectl) (not in Sage Python) and use it to locate where flags are raised during the import.

good idea. I'm curious to see where a NaN is generated.



---

archive/issue_comments_314498.json:
```json
{
    "body": "Replying to [comment:95 zimmerma]:\n> what happens if you remove the `except KeyError` part?\n\nA `KeyError` gets raised and Sage crashes on start-up:\n\n```\nKeyError: ((8, 0, 'beta5'), (Rational Field, x^2 + 1, ('I',), (Complex Lazy Field, 1*I), 'i', None, False, None))\n```\n\nIf instead I print out self._cache, version, and cache_key, I see this:\n\n```\nself._cache: <WeakValueDictionary at 0x21bb99410>\nversion: (8, 0, 'beta5'), cache_key: (Rational Field, x^2 + 1, ('I',), (Complex Lazy Field, 1*I), 'i', None, False, None)\n```\n",
    "created_at": "2017-05-16T15:10:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314498",
    "user": "@jhpalmieri"
}
```

Replying to [comment:95 zimmerma]:
> what happens if you remove the `except KeyError` part?

A `KeyError` gets raised and Sage crashes on start-up:

```
KeyError: ((8, 0, 'beta5'), (Rational Field, x^2 + 1, ('I',), (Complex Lazy Field, 1*I), 'i', None, False, None))
```

If instead I print out self._cache, version, and cache_key, I see this:

```
self._cache: <WeakValueDictionary at 0x21bb99410>
version: (8, 0, 'beta5'), cache_key: (Rational Field, x^2 + 1, ('I',), (Complex Lazy Field, 1*I), 'i', None, False, None)
```




---

archive/issue_comments_314499.json:
```json
{
    "body": "and then do you get `050: 1` or `050: 0`?\nI wonder how the access to `self._cache[version, cache_key]` can yield an invalid exception.",
    "created_at": "2017-05-17T14:38:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314499",
    "user": "@zimmermann6"
}
```

and then do you get `050: 1` or `050: 0`?
I wonder how the access to `self._cache[version, cache_key]` can yield an invalid exception.



---

archive/issue_comments_314500.json:
```json
{
    "body": "Replying to [comment:99 zimmerma]:\n> and then do you get `050: 1` or `050: 0`?\n\nIf I remove the entire `except KeyError` section, Sage crashes before it ever gets to that print statement. If I keep that part, possibly adding some print statements to it, then I get `050: 1`, as I said before.\n\n> I wonder how the access to `self._cache[version, cache_key]` can yield an invalid exception.",
    "created_at": "2017-05-17T14:55:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314500",
    "user": "@jhpalmieri"
}
```

Replying to [comment:99 zimmerma]:
> and then do you get `050: 1` or `050: 0`?

If I remove the entire `except KeyError` section, Sage crashes before it ever gets to that print statement. If I keep that part, possibly adding some print statements to it, then I get `050: 1`, as I said before.

> I wonder how the access to `self._cache[version, cache_key]` can yield an invalid exception.



---

archive/issue_comments_314501.json:
```json
{
    "body": "I have no other idea, except trying the fpectl Python module as suggested in comment [comment:97].",
    "created_at": "2017-05-17T15:14:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314501",
    "user": "@zimmermann6"
}
```

I have no other idea, except trying the fpectl Python module as suggested in comment [comment:97].



---

archive/issue_comments_314502.json:
```json
{
    "body": "Replying to [comment:101 zimmerma]:\n> I have no other idea, except trying the fpectl Python module as suggested in comment [comment:97].\n\nI'm trying this on FreeBSD now. fpectl is in fact quite broken, so I had to hack around to build it, and yes, I can set `fpectl.turnon_sigfpe()` and get a coredump while running `from sage.all import *`. The problem is to get a good coredump now...",
    "created_at": "2017-05-17T15:35:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314502",
    "user": "@dimpase"
}
```

Replying to [comment:101 zimmerma]:
> I have no other idea, except trying the fpectl Python module as suggested in comment [comment:97].

I'm trying this on FreeBSD now. fpectl is in fact quite broken, so I had to hack around to build it, and yes, I can set `fpectl.turnon_sigfpe()` and get a coredump while running `from sage.all import *`. The problem is to get a good coredump now...



---

archive/issue_comments_314503.json:
```json
{
    "body": "the coredump (while running `from sage.all import *` with sigfpe on) points its finger at a call to `mpfr_set_d`. Specifically:\n\n```\n  /* \"sage/rings/real_mpfr.pyx\":5796\n *         cdef RealField_class parent = <RealField_class>self._codomain\n *         cdef RealNumber y = parent._new()\n *         mpfr_set_d(y.value, x, parent.rnd)             # <<<<<<<<<<<<<<\n *         return y\n *\n */\n  __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_v_x); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 5796, __py\nx_L1_error)\n  mpfr_set_d(__pyx_v_y->value, __pyx_t_6, __pyx_v_parent->rnd);       \n```\n\n\nas can be seen at\n\n\n```\n#0  0x0000000800b141ca in kill () from /lib/libc.so.7\n#1  0x00000008044892eb in sigdie (sig=8, s=0x80448b8b3 \"Unhandled SIGFPE: An unhandled floating point exception occurred.\")\n    at implementation.c:427\n#2  0x000000080448910f in cysigs_signal_handler (sig=8) at implementation.c:206\n#3  0x00000008013ed78f in pthread_sigmask () from /lib/libthr.so.3\n#4  0x00000008013ecd6f in pthread_getspecific () from /lib/libthr.so.3\n#5  <signal handler called>\n#6  0x0000000811a7abfd in mpfr_set_d (r=0x8605c89d0, d=<value optimized out>, rnd_mode=MPFR_RNDN) at set_d.c:121\n#7  0x0000000848c5af54 in __pyx_f_4sage_5rings_9real_mpfr_11double_toRR__call_ (__pyx_v_self=<value optimized out>, \n    __pyx_v_x=0x84a298320, __pyx_skip_dispatch=<value optimized out>)\n    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/rings/real_mpfr.c:37760\n#8  0x000000080cf2b20a in __pyx_f_4sage_9structure_6coerce_24CoercionModel_cache_maps_canonical_coercion (\n    __pyx_v_self=<value optimized out>, __pyx_v_x=<value optimized out>, __pyx_v_y=0x84a298320, \n    __pyx_skip_dispatch=<value optimized out>) at /usr/home/dima/Sage/sage/src/build/cythonized/sage/structure/coerce.c:10904\n#9  0x000000080cf3433b in __pyx_f_4sage_9structure_6coerce_24CoercionModel_cache_maps_richcmp (__pyx_v_self=0x808a86738, \n    __pyx_v_x=0x8605c87d0, __pyx_v_y=0x84a298320, __pyx_v_op=0, __pyx_skip_dispatch=<value optimized out>)\n    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/structure/coerce.c:20224\n#10 0x000000080ccd0185 in __pyx_pw_4sage_9structure_7element_7Element_67__richcmp__ (__pyx_v_self=0x8605c87d0, \n    __pyx_v_other=0x84a298320, __pyx_v_op=0) at /usr/home/dima/Sage/sage/src/build/cythonized/sage/structure/element.c:10385\n#11 0x0000000800e76d2b in try_rich_compare (v=0x8605c87d0, w=0x84a298320, op=0) at Objects/object.c:622\n#12 0x0000000800e74c69 in PyObject_RichCompare (v=0x8605c87d0, w=0x84a298320, op=0) at Objects/object.c:930\n#13 0x0000000800ed2ced in PyEval_EvalFrameEx (f=0x855fbdda0, throwflag=<value optimized out>) at Python/ceval.c:4858\n#14 0x0000000800ecd874 in PyEval_EvalCodeEx (co=<value optimized out>, globals=<value optimized out>, locals=<value optimized out>, \n    args=<value optimized out>, argcount=<value optimized out>, kws=0x0, kwcount=<value optimized out>, defs=0x0, defcount=0, \n    closure=0x0) at Python/ceval.c:3584\n#15 0x0000000800e588c3 in function_call (func=<value optimized out>, arg=<value optimized out>, kw=<value optimized out>)\n    at Objects/funcobject.c:523\n#16 0x0000000800e2b9c1 in PyObject_CallFunctionObjArgs (callable=0x810fa2758) at Objects/abstract.c:2547\n#17 0x0000000800e5deb8 in listsort (self=0x8605c4908, args=<value optimized out>, kwds=<value optimized out>)\n    at Objects/listobject.c:2100\n...\n```\n",
    "created_at": "2017-05-17T16:20:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314503",
    "user": "@dimpase"
}
```

the coredump (while running `from sage.all import *` with sigfpe on) points its finger at a call to `mpfr_set_d`. Specifically:

```
  /* "sage/rings/real_mpfr.pyx":5796
 *         cdef RealField_class parent = <RealField_class>self._codomain
 *         cdef RealNumber y = parent._new()
 *         mpfr_set_d(y.value, x, parent.rnd)             # <<<<<<<<<<<<<<
 *         return y
 *
 */
  __pyx_t_6 = __pyx_PyFloat_AsDouble(__pyx_v_x); if (unlikely((__pyx_t_6 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 5796, __py
x_L1_error)
  mpfr_set_d(__pyx_v_y->value, __pyx_t_6, __pyx_v_parent->rnd);       
```


as can be seen at


```
#0  0x0000000800b141ca in kill () from /lib/libc.so.7
#1  0x00000008044892eb in sigdie (sig=8, s=0x80448b8b3 "Unhandled SIGFPE: An unhandled floating point exception occurred.")
    at implementation.c:427
#2  0x000000080448910f in cysigs_signal_handler (sig=8) at implementation.c:206
#3  0x00000008013ed78f in pthread_sigmask () from /lib/libthr.so.3
#4  0x00000008013ecd6f in pthread_getspecific () from /lib/libthr.so.3
#5  <signal handler called>
#6  0x0000000811a7abfd in mpfr_set_d (r=0x8605c89d0, d=<value optimized out>, rnd_mode=MPFR_RNDN) at set_d.c:121
#7  0x0000000848c5af54 in __pyx_f_4sage_5rings_9real_mpfr_11double_toRR__call_ (__pyx_v_self=<value optimized out>, 
    __pyx_v_x=0x84a298320, __pyx_skip_dispatch=<value optimized out>)
    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/rings/real_mpfr.c:37760
#8  0x000000080cf2b20a in __pyx_f_4sage_9structure_6coerce_24CoercionModel_cache_maps_canonical_coercion (
    __pyx_v_self=<value optimized out>, __pyx_v_x=<value optimized out>, __pyx_v_y=0x84a298320, 
    __pyx_skip_dispatch=<value optimized out>) at /usr/home/dima/Sage/sage/src/build/cythonized/sage/structure/coerce.c:10904
#9  0x000000080cf3433b in __pyx_f_4sage_9structure_6coerce_24CoercionModel_cache_maps_richcmp (__pyx_v_self=0x808a86738, 
    __pyx_v_x=0x8605c87d0, __pyx_v_y=0x84a298320, __pyx_v_op=0, __pyx_skip_dispatch=<value optimized out>)
    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/structure/coerce.c:20224
#10 0x000000080ccd0185 in __pyx_pw_4sage_9structure_7element_7Element_67__richcmp__ (__pyx_v_self=0x8605c87d0, 
    __pyx_v_other=0x84a298320, __pyx_v_op=0) at /usr/home/dima/Sage/sage/src/build/cythonized/sage/structure/element.c:10385
#11 0x0000000800e76d2b in try_rich_compare (v=0x8605c87d0, w=0x84a298320, op=0) at Objects/object.c:622
#12 0x0000000800e74c69 in PyObject_RichCompare (v=0x8605c87d0, w=0x84a298320, op=0) at Objects/object.c:930
#13 0x0000000800ed2ced in PyEval_EvalFrameEx (f=0x855fbdda0, throwflag=<value optimized out>) at Python/ceval.c:4858
#14 0x0000000800ecd874 in PyEval_EvalCodeEx (co=<value optimized out>, globals=<value optimized out>, locals=<value optimized out>, 
    args=<value optimized out>, argcount=<value optimized out>, kws=0x0, kwcount=<value optimized out>, defs=0x0, defcount=0, 
    closure=0x0) at Python/ceval.c:3584
#15 0x0000000800e588c3 in function_call (func=<value optimized out>, arg=<value optimized out>, kw=<value optimized out>)
    at Objects/funcobject.c:523
#16 0x0000000800e2b9c1 in PyObject_CallFunctionObjArgs (callable=0x810fa2758) at Objects/abstract.c:2547
#17 0x0000000800e5deb8 in listsort (self=0x8605c4908, args=<value optimized out>, kwds=<value optimized out>)
    at Objects/listobject.c:2100
...
```




---

archive/issue_comments_314504.json:
```json
{
    "body": "even shorter way to see the problem:\n\n```\n$ ./sage --python\nPython 2.7.13 (default, May 17 2017, 16:36:57) \n[GCC 4.2.1 Compatible Clang 4.0.0 ] on freebsd11\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import fpectl\n>>> from sage.all import *\n>>> fpectl.turnon_sigfpe()\n>>> p=RDF.pi()\n>>> from sage.rings.real_mpfr import double_toRR\n>>> f=double_toRR(RDF, RealField(22))\n>>> f(p)\nFatal Python error: Unprotected floating point exception\n...\n```\n\nand the piece of the dump points to the same place:\n\n```\n#13 <signal handler called>\n#14 0x0000000811a7abfd in mpfr_set_d (r=0x879a93550, d=<value optimized out>, rnd_mode=MPFR_RNDN) at set_d.c:121\n#15 0x0000000848c5af54 in __pyx_f_4sage_5rings_9real_mpfr_11double_toRR__call_ (__pyx_v_self=<value optimized out>, \n    __pyx_v_x=0x87983bfd0, __pyx_skip_dispatch=<value optimized out>)\n    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/rings/real_mpfr.c:37760\n#16 0x000000080d17a5d1 in __pyx_pw_4sage_10categories_3map_3Map_30__call__ (__pyx_v_self=<value optimized out>, \n    __pyx_args=<value optimized out>, __pyx_kwds=<value optimized out>)\n    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/categories/map.c:6682\n#17 0x0000000800e31195 in PyObject_Call (func=0x879a88e60, arg=0x800752610, kw=0x0) at Objects/abstract.c:2547\n```\n",
    "created_at": "2017-05-17T16:53:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314504",
    "user": "@dimpase"
}
```

even shorter way to see the problem:

```
$ ./sage --python
Python 2.7.13 (default, May 17 2017, 16:36:57) 
[GCC 4.2.1 Compatible Clang 4.0.0 ] on freebsd11
Type "help", "copyright", "credits" or "license" for more information.
>>> import fpectl
>>> from sage.all import *
>>> fpectl.turnon_sigfpe()
>>> p=RDF.pi()
>>> from sage.rings.real_mpfr import double_toRR
>>> f=double_toRR(RDF, RealField(22))
>>> f(p)
Fatal Python error: Unprotected floating point exception
...
```

and the piece of the dump points to the same place:

```
#13 <signal handler called>
#14 0x0000000811a7abfd in mpfr_set_d (r=0x879a93550, d=<value optimized out>, rnd_mode=MPFR_RNDN) at set_d.c:121
#15 0x0000000848c5af54 in __pyx_f_4sage_5rings_9real_mpfr_11double_toRR__call_ (__pyx_v_self=<value optimized out>, 
    __pyx_v_x=0x87983bfd0, __pyx_skip_dispatch=<value optimized out>)
    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/rings/real_mpfr.c:37760
#16 0x000000080d17a5d1 in __pyx_pw_4sage_10categories_3map_3Map_30__call__ (__pyx_v_self=<value optimized out>, 
    __pyx_args=<value optimized out>, __pyx_kwds=<value optimized out>)
    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/categories/map.c:6682
#17 0x0000000800e31195 in PyObject_Call (func=0x879a88e60, arg=0x800752610, kw=0x0) at Objects/abstract.c:2547
```




---

archive/issue_comments_314505.json:
```json
{
    "body": "Does MPFR suppress compiler's messages?\n(there is some `>/dev/null` in the log...) Just wondering whether we might be missing some interesting compiler warnings.",
    "created_at": "2017-05-17T18:09:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314505",
    "user": "@dimpase"
}
```

Does MPFR suppress compiler's messages?
(there is some `>/dev/null` in the log...) Just wondering whether we might be missing some interesting compiler warnings.



---

archive/issue_comments_314506.json:
```json
{
    "body": "here is sanity check - even without the fpectl thing, one can see that `f(p)` above flips an FPU bit:\n\n```\nsage: from ctypes import cdll\nsage: from ctypes.util import find_library\nsage: libm = cdll.LoadLibrary(find_library('m'))\nsage: print libm.fetestexcept(int(0x01))\n1\nsage: import numpy   # this resets the FPU bits\nsage: print libm.fetestexcept(int(0x01))\n0\nsage: p=RDF.pi()\nsage: from sage.rings.real_mpfr import double_toRR\nsage: f=double_toRR(RDF, RealField(22))\nsage: f(p)\n3.14159\nsage: print libm.fetestexcept(int(0x01))\n1\n```\n\nMore precisely, it is the FE_INVALID bit.",
    "created_at": "2017-05-17T18:17:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314506",
    "user": "@dimpase"
}
```

here is sanity check - even without the fpectl thing, one can see that `f(p)` above flips an FPU bit:

```
sage: from ctypes import cdll
sage: from ctypes.util import find_library
sage: libm = cdll.LoadLibrary(find_library('m'))
sage: print libm.fetestexcept(int(0x01))
1
sage: import numpy   # this resets the FPU bits
sage: print libm.fetestexcept(int(0x01))
0
sage: p=RDF.pi()
sage: from sage.rings.real_mpfr import double_toRR
sage: f=double_toRR(RDF, RealField(22))
sage: f(p)
3.14159
sage: print libm.fetestexcept(int(0x01))
1
```

More precisely, it is the FE_INVALID bit.



---

archive/issue_comments_314507.json:
```json
{
    "body": "Replying to [comment:99 zimmerma]:\n> I wonder how the access to `self._cache[version, cache_key]` can yield an invalid exception.\n\nWith ad hoc mpfr logging turned on, I see a lot of messages printed by mpfr between the \"try\" and \"except\" parts of the code. I don't know why. For example, if I add some print messages to `mpfr_set_d`:\n\n```\n020: 0\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\nenter mpfr_set_d\n exit mpfr_set_d: normal\n040: 1\nenter mpfr_set_d\n exit mpfr_set_d: normal\nversion:(8, 0, 'beta4'), cache_key: (Rational Field, x^2 + 1, ('I',), (Complex Lazy Field, 1*I), 'i', None, False, None)\n050: 1\n```\n\n(\"exit mpfr_set_d: normal\" is printed if the end of that function is reached, as opposed to the special cases for 0 or infinity.)",
    "created_at": "2017-05-17T19:30:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314507",
    "user": "@jhpalmieri"
}
```

Replying to [comment:99 zimmerma]:
> I wonder how the access to `self._cache[version, cache_key]` can yield an invalid exception.

With ad hoc mpfr logging turned on, I see a lot of messages printed by mpfr between the "try" and "except" parts of the code. I don't know why. For example, if I add some print messages to `mpfr_set_d`:

```
020: 0
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
enter mpfr_set_d
 exit mpfr_set_d: normal
040: 1
enter mpfr_set_d
 exit mpfr_set_d: normal
version:(8, 0, 'beta4'), cache_key: (Rational Field, x^2 + 1, ('I',), (Complex Lazy Field, 1*I), 'i', None, False, None)
050: 1
```

("exit mpfr_set_d: normal" is printed if the end of that function is reached, as opposed to the special cases for 0 or infinity.)



---

archive/issue_comments_314508.json:
```json
{
    "body": "line 121 of `set_d.c` is the following in mpfr-3.1.5 (if no patch was applied in Sage):\n\n```\n    manl = d;\n```\n\nA first suggestion is to add a cast:\n\n```\n    manl = (mp_limb_t) d;\n```\n\nAlso, please could you compile with `-O0 -g` so that the debugger does not optimize out the value of `d`?\n\n```\n#6  0x0000000811a7abfd in mpfr_set_d (r=0x8605c89d0, d=<value optimized out>, rnd_mode=MPFR_RNDN) at set_d.c:121\n```\n\nAlternatively, one could add at the beginning of `__gmpfr_extract_double`:\n\n```\n   printf (\"d=%f\\n\", d);\n```\n\nto see which value of `d` produces the invalid exception.",
    "created_at": "2017-05-18T07:40:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314508",
    "user": "@zimmermann6"
}
```

line 121 of `set_d.c` is the following in mpfr-3.1.5 (if no patch was applied in Sage):

```
    manl = d;
```

A first suggestion is to add a cast:

```
    manl = (mp_limb_t) d;
```

Also, please could you compile with `-O0 -g` so that the debugger does not optimize out the value of `d`?

```
#6  0x0000000811a7abfd in mpfr_set_d (r=0x8605c89d0, d=<value optimized out>, rnd_mode=MPFR_RNDN) at set_d.c:121
```

Alternatively, one could add at the beginning of `__gmpfr_extract_double`:

```
   printf ("d=%f\n", d);
```

to see which value of `d` produces the invalid exception.



---

archive/issue_comments_314509.json:
```json
{
    "body": "Replying to [comment:108 zimmerma]:\n> line 121 of `set_d.c` is the following in mpfr-3.1.5 (if no patch was applied in Sage):\n> {{{\n>     manl = d;\n> }}}\n> A first suggestion is to add a cast:\n> {{{\n>     manl = (mp_limb_t) d;\n> }}}\n> Also, please could you compile with `-O0 -g` so that the debugger does not optimize out the value of `d`?\n> {{{\n> #6  0x0000000811a7abfd in mpfr_set_d (r=0x8605c89d0, d=<value optimized out>, rnd_mode=MPFR_RNDN) at set_d.c:121\n\nHere is the result (coredump) of `f(1.5)` invoked as in comment 104 above:\n\n```\n#13 <signal handler called>\n#14 0x0000000811a86deb in __gmpfr_extract_double (rp=0x7fffffffd438, d=1.3835058055282164e+19) at set_d.c:121\n#15 0x0000000811a8696e in mpfr_set_d (r=0x879ad3610, d=1.5, rnd_mode=MPFR_RNDN) at set_d.c:214\n#16 0x0000000848c5af54 in __pyx_f_4sage_5rings_9real_mpfr_11double_toRR__call_ (__pyx_v_self=<value optimized out>, \n    __pyx_v_x=0x87987bfd0, __pyx_skip_dispatch=<value optimized out>)\n    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/rings/real_mpfr.c:37760\n#17 0x000000080d17a38e in __pyx_pw_4sage_10categories_3map_3Map_30__call__ (__pyx_v_self=<value optimized out>, \n    __pyx_args=<value optimized out>, __pyx_kwds=<value optimized out>)\n    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/categories/map.c:7093\n```\n\n\nafter I recompiled mpfr and mpc with `-O0` (by using SAGE_DEBUG=yes)\nIn instead I do `f(p)` (exactly as in comment 104) the only difference I see\nis \n\n```\n#14 0x0000000811486deb in __gmpfr_extract_double (rp=0x7fffffffd448, d=1.4488038916154245e+19) at set_d.c:121\n#15 0x000000081148696e in mpfr_set_d (r=0x87991da30, d=3.1415926535897931, rnd_mode=MPFR_RNDN) at set_d.c:214\n```\n\n\nWhat would you like to get printed (or/and C-cast'ed ?) based on this info?",
    "created_at": "2017-05-18T09:52:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314509",
    "user": "@dimpase"
}
```

Replying to [comment:108 zimmerma]:
> line 121 of `set_d.c` is the following in mpfr-3.1.5 (if no patch was applied in Sage):
> {{{
>     manl = d;
> }}}
> A first suggestion is to add a cast:
> {{{
>     manl = (mp_limb_t) d;
> }}}
> Also, please could you compile with `-O0 -g` so that the debugger does not optimize out the value of `d`?
> {{{
> #6  0x0000000811a7abfd in mpfr_set_d (r=0x8605c89d0, d=<value optimized out>, rnd_mode=MPFR_RNDN) at set_d.c:121

Here is the result (coredump) of `f(1.5)` invoked as in comment 104 above:

```
#13 <signal handler called>
#14 0x0000000811a86deb in __gmpfr_extract_double (rp=0x7fffffffd438, d=1.3835058055282164e+19) at set_d.c:121
#15 0x0000000811a8696e in mpfr_set_d (r=0x879ad3610, d=1.5, rnd_mode=MPFR_RNDN) at set_d.c:214
#16 0x0000000848c5af54 in __pyx_f_4sage_5rings_9real_mpfr_11double_toRR__call_ (__pyx_v_self=<value optimized out>, 
    __pyx_v_x=0x87987bfd0, __pyx_skip_dispatch=<value optimized out>)
    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/rings/real_mpfr.c:37760
#17 0x000000080d17a38e in __pyx_pw_4sage_10categories_3map_3Map_30__call__ (__pyx_v_self=<value optimized out>, 
    __pyx_args=<value optimized out>, __pyx_kwds=<value optimized out>)
    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/categories/map.c:7093
```


after I recompiled mpfr and mpc with `-O0` (by using SAGE_DEBUG=yes)
In instead I do `f(p)` (exactly as in comment 104) the only difference I see
is 

```
#14 0x0000000811486deb in __gmpfr_extract_double (rp=0x7fffffffd448, d=1.4488038916154245e+19) at set_d.c:121
#15 0x000000081148696e in mpfr_set_d (r=0x87991da30, d=3.1415926535897931, rnd_mode=MPFR_RNDN) at set_d.c:214
```


What would you like to get printed (or/and C-cast'ed ?) based on this info?



---

archive/issue_comments_314510.json:
```json
{
    "body": "please could you first apply the following patch and try again?\n\n```\n--- set_d.c.orig        2017-05-18 12:01:41.925524683 +0200\n+++ set_d.c     2017-05-18 12:04:38.728177129 +0200\n@@ -38,6 +38,8 @@\n   mp_limb_t manh;\n #endif\n \n+  printf (\"line 41: d=%.16e\\n\", d);\n+\n   /* BUGS\n      1. Should handle Inf and NaN in IEEE specific code.\n      2. Handle Inf and NaN also in default code, to avoid hangs.\n@@ -95,11 +97,13 @@\n           {\n             d *= (1.0 / 65536.0);\n             exp += 16;\n+            printf (\"100: d=%.16e exp=%ld\\n\", d, exp);\n           }\n         while (d >= 1.0)\n           {\n             d *= 0.5;\n             exp += 1;\n+            printf (\"106: d=%.16e exp=%ld\\n\", d, exp);\n           }\n       }\n     else if (d < 0.5)\n@@ -116,7 +120,9 @@\n           }\n       }\n \n+    printf (\"MP_BASE_AS_DOUBLE = %.16e\\n\", MP_BASE_AS_DOUBLE);\n     d *= MP_BASE_AS_DOUBLE;\n+    printf (\"125: d=%.16e\\n\", d);\n #if GMP_NUMB_BITS >= 64\n     manl = d;\n #else\n```\n\nI suspect the value of `d` at (original) line 121 is NaN, but I can't see how this can happen.",
    "created_at": "2017-05-18T10:10:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314510",
    "user": "@zimmermann6"
}
```

please could you first apply the following patch and try again?

```
--- set_d.c.orig        2017-05-18 12:01:41.925524683 +0200
+++ set_d.c     2017-05-18 12:04:38.728177129 +0200
@@ -38,6 +38,8 @@
   mp_limb_t manh;
 #endif
 
+  printf ("line 41: d=%.16e\n", d);
+
   /* BUGS
      1. Should handle Inf and NaN in IEEE specific code.
      2. Handle Inf and NaN also in default code, to avoid hangs.
@@ -95,11 +97,13 @@
           {
             d *= (1.0 / 65536.0);
             exp += 16;
+            printf ("100: d=%.16e exp=%ld\n", d, exp);
           }
         while (d >= 1.0)
           {
             d *= 0.5;
             exp += 1;
+            printf ("106: d=%.16e exp=%ld\n", d, exp);
           }
       }
     else if (d < 0.5)
@@ -116,7 +120,9 @@
           }
       }
 
+    printf ("MP_BASE_AS_DOUBLE = %.16e\n", MP_BASE_AS_DOUBLE);
     d *= MP_BASE_AS_DOUBLE;
+    printf ("125: d=%.16e\n", d);
 #if GMP_NUMB_BITS >= 64
     manl = d;
 #else
```

I suspect the value of `d` at (original) line 121 is NaN, but I can't see how this can happen.



---

archive/issue_comments_314511.json:
```json
{
    "body": "with the patch I get\n\n```\nline 41: d=3.1415926535897931e+00\n106: d=1.5707963267948966e+00 exp=1\n106: d=7.8539816339744828e-01 exp=2\nMP_BASE_AS_DOUBLE = 1.8446744073709552e+19\n125: d=1.4488038916154245e+19\nFatal Python error: Unprotected floating point exception\n```\n\nand essentially the same (up to line number changes):\n\n```\n#13 <signal handler called>\n#14 0x0000000811486e6c in __gmpfr_extract_double (rp=0x7fffffffd458, d=1.4488038916154245e+19) at set_d.c:127\n#15 0x000000081148696e in mpfr_set_d (r=0x87991e910, d=3.1415926535897931, rnd_mode=MPFR_RNDN) at set_d.c:220\n#16 0x000000084865af54 in __pyx_f_4sage_5rings_9real_mpfr_11double_toRR__call_ (__pyx_v_self=<value optimized out>, \n    __pyx_v_x=0x8796baf58, __pyx_skip_dispatch=<value optimized out>)\n    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/rings/real_mpfr.c:37760\n```\n",
    "created_at": "2017-05-18T11:57:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314511",
    "user": "@dimpase"
}
```

with the patch I get

```
line 41: d=3.1415926535897931e+00
106: d=1.5707963267948966e+00 exp=1
106: d=7.8539816339744828e-01 exp=2
MP_BASE_AS_DOUBLE = 1.8446744073709552e+19
125: d=1.4488038916154245e+19
Fatal Python error: Unprotected floating point exception
```

and essentially the same (up to line number changes):

```
#13 <signal handler called>
#14 0x0000000811486e6c in __gmpfr_extract_double (rp=0x7fffffffd458, d=1.4488038916154245e+19) at set_d.c:127
#15 0x000000081148696e in mpfr_set_d (r=0x87991e910, d=3.1415926535897931, rnd_mode=MPFR_RNDN) at set_d.c:220
#16 0x000000084865af54 in __pyx_f_4sage_5rings_9real_mpfr_11double_toRR__call_ (__pyx_v_self=<value optimized out>, 
    __pyx_v_x=0x8796baf58, __pyx_skip_dispatch=<value optimized out>)
    at /usr/home/dima/Sage/sage/src/build/cythonized/sage/rings/real_mpfr.c:37760
```




---

archive/issue_comments_314512.json:
```json
{
    "body": "Replying to [comment:108 zimmerma]:\n> line 121 of `set_d.c` is the following in mpfr-3.1.5 (if no patch was applied in Sage):\n> {{{\n>     manl = d;\n> }}}\n> A first suggestion is to add a cast:\n> {{{\n>     manl = (mp_limb_t) d;\n> }}}\nForgot to mention that this cast does not change anything at all.",
    "created_at": "2017-05-18T12:44:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314512",
    "user": "@dimpase"
}
```

Replying to [comment:108 zimmerma]:
> line 121 of `set_d.c` is the following in mpfr-3.1.5 (if no patch was applied in Sage):
> {{{
>     manl = d;
> }}}
> A first suggestion is to add a cast:
> {{{
>     manl = (mp_limb_t) d;
> }}}
Forgot to mention that this cast does not change anything at all.



---

archive/issue_comments_314513.json:
```json
{
    "body": "ok, I can reproduce the issue on my Linux machine with the following program (where I replaced `mp_limb_t manl` by `long manl`):\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <fenv.h>\n\nint\nmain (int argc, char *argv[])\n{\n  long manl;\n  double d = atof (argv[1]);\n\n  printf (\"fetestexcept() = %d\\n\", fetestexcept (FE_INVALID));\n\n  manl = d;\n\n  printf (\"fetestexcept() = %d\\n\", fetestexcept (FE_INVALID));\n\n  printf (\"manl = %ld\\n\", manl);\n\n  return 0;\n}\n```\n\nwhich gives:\n\n```\nzimmerma@tomate:/tmp$ gcc -O0 e.c -lm\nzimmerma@tomate:/tmp$ ./a.out 1.4488038916154245e+19\nfetestexcept() = 0\nfetestexcept() = 1\nmanl = -9223372036854775808\n```\n\nthus a possible explanation could be that `mp_limb_t` is a signed 64-bit type (aka `long`) on this platform, but I doubt.\n\nPlease can you check the output of this program (and the same by replacing `long` by `mp_limb_t` and adding the `gmp.h` header)?",
    "created_at": "2017-05-18T13:22:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314513",
    "user": "@zimmermann6"
}
```

ok, I can reproduce the issue on my Linux machine with the following program (where I replaced `mp_limb_t manl` by `long manl`):

```
#include <stdio.h>
#include <stdlib.h>
#include <fenv.h>

int
main (int argc, char *argv[])
{
  long manl;
  double d = atof (argv[1]);

  printf ("fetestexcept() = %d\n", fetestexcept (FE_INVALID));

  manl = d;

  printf ("fetestexcept() = %d\n", fetestexcept (FE_INVALID));

  printf ("manl = %ld\n", manl);

  return 0;
}
```

which gives:

```
zimmerma@tomate:/tmp$ gcc -O0 e.c -lm
zimmerma@tomate:/tmp$ ./a.out 1.4488038916154245e+19
fetestexcept() = 0
fetestexcept() = 1
manl = -9223372036854775808
```

thus a possible explanation could be that `mp_limb_t` is a signed 64-bit type (aka `long`) on this platform, but I doubt.

Please can you check the output of this program (and the same by replacing `long` by `mp_limb_t` and adding the `gmp.h` header)?



---

archive/issue_comments_314514.json:
```json
{
    "body": "on the platform one has `mp_limb_t` of type `unsigned long int`, but still if I replace\n\n```\nlong manl;\n```\n\nwith\n\n```\nunsigned long manl;\n```\n\nand replace format `%ld` by `%lu` I get\n\n```\n$ ./a.out 1.4488038916154245e+19\nfetestexcept() = 0\nfetestexcept() = 1\nmanl = 14488038916154245120\n```\n\n\nIn fact, as well, `FE_INEXACT` is raised, not only `FE_INVALID`.\n\n----\n\nBy the way: sometimes, if I enter as input something smaller, say `1.44e0` I get no `FE_INVALID` raised, but instead `FE_INEXACT` is raised.\n\nEntering `1.44e0` on Linux/gcc still raises `FE_INEXACT` after the assignment; on FreeBSD/clang `FE_INEXACT` is also raised at `d=atof()` call.",
    "created_at": "2017-05-18T14:36:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314514",
    "user": "@dimpase"
}
```

on the platform one has `mp_limb_t` of type `unsigned long int`, but still if I replace

```
long manl;
```

with

```
unsigned long manl;
```

and replace format `%ld` by `%lu` I get

```
$ ./a.out 1.4488038916154245e+19
fetestexcept() = 0
fetestexcept() = 1
manl = 14488038916154245120
```


In fact, as well, `FE_INEXACT` is raised, not only `FE_INVALID`.

----

By the way: sometimes, if I enter as input something smaller, say `1.44e0` I get no `FE_INVALID` raised, but instead `FE_INEXACT` is raised.

Entering `1.44e0` on Linux/gcc still raises `FE_INEXACT` after the assignment; on FreeBSD/clang `FE_INEXACT` is also raised at `d=atof()` call.



---

archive/issue_comments_314515.json:
```json
{
    "body": "> By the way: sometimes, if I enter as input something smaller, say 1.44e0 I get no FE_INVALID raised, but instead FE_INEXACT is raised. \n\nthis is normal, since 1.44e0 is not an integer, and thus the integer conversion should raise the\ninexact flag, but for `1.4488038916154245e+19` it should not be the case, since the value of `d` should be `14488038916154245120`, which is the closest 53-bit floating-point number.\n\nWe are making progress. Now I can reproduce the issue with clang on my Linux-Debian computer with the following program:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <fenv.h>\n\nint\nmain (int argc, char *argv[])\n{\n  unsigned long manl;\n  double d = atof (argv[1]);\n\n  printf (\"d = %f\\n\", d);\n\n  printf (\"fetestexcept() = %d\\n\", fetestexcept (FE_ALL_EXCEPT));\n\n  manl = d;\n\n  printf (\"fetestexcept() = %d\\n\", fetestexcept (FE_ALL_EXCEPT));\n\n  printf (\"manl = %lu\\n\", manl);\n\n  return 0;\n}\n```\n\nwhich gives:\n\n```\nzimmerma@tomate:/tmp$ gcc -O0 -g e.c -lm; ./a.out 1.4488038916154245e+19\nd = 14488038916154245120.000000\nfetestexcept() = 0\nfetestexcept() = 0\nmanl = 14488038916154245120\nzimmerma@tomate:/tmp$ clang -O0 -g e.c -lm; ./a.out 1.4488038916154245e+19\nd = 14488038916154245120.000000\nfetestexcept() = 0\nfetestexcept() = 1\nmanl = 14488038916154245120\n```\n",
    "created_at": "2017-05-18T14:53:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314515",
    "user": "@zimmermann6"
}
```

> By the way: sometimes, if I enter as input something smaller, say 1.44e0 I get no FE_INVALID raised, but instead FE_INEXACT is raised. 

this is normal, since 1.44e0 is not an integer, and thus the integer conversion should raise the
inexact flag, but for `1.4488038916154245e+19` it should not be the case, since the value of `d` should be `14488038916154245120`, which is the closest 53-bit floating-point number.

We are making progress. Now I can reproduce the issue with clang on my Linux-Debian computer with the following program:

```
#include <stdio.h>
#include <stdlib.h>
#include <fenv.h>

int
main (int argc, char *argv[])
{
  unsigned long manl;
  double d = atof (argv[1]);

  printf ("d = %f\n", d);

  printf ("fetestexcept() = %d\n", fetestexcept (FE_ALL_EXCEPT));

  manl = d;

  printf ("fetestexcept() = %d\n", fetestexcept (FE_ALL_EXCEPT));

  printf ("manl = %lu\n", manl);

  return 0;
}
```

which gives:

```
zimmerma@tomate:/tmp$ gcc -O0 -g e.c -lm; ./a.out 1.4488038916154245e+19
d = 14488038916154245120.000000
fetestexcept() = 0
fetestexcept() = 0
manl = 14488038916154245120
zimmerma@tomate:/tmp$ clang -O0 -g e.c -lm; ./a.out 1.4488038916154245e+19
d = 14488038916154245120.000000
fetestexcept() = 0
fetestexcept() = 1
manl = 14488038916154245120
```




---

archive/issue_comments_314516.json:
```json
{
    "body": "by dichotomy I found that the exception seems to be raised for 2<sup>63</sup>-512 and larger values:\n\n```\nzimmerma@tomate:/tmp$ clang -O0 -g e.c -lm; ./a.out 9223372036854775295.0\nd = 9223372036854774784.000000\nfetestexcept() = 0\nfetestexcept() = 0\nmanl = 9223372036854774784\nzimmerma@tomate:/tmp$ clang -O0 -g e.c -lm; ./a.out 9223372036854775296.0\nd = 9223372036854775808.000000\nfetestexcept() = 0\nfetestexcept() = 1\nmanl = 9223372036854775808\n```\n",
    "created_at": "2017-05-18T15:00:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314516",
    "user": "@zimmermann6"
}
```

by dichotomy I found that the exception seems to be raised for 2<sup>63</sup>-512 and larger values:

```
zimmerma@tomate:/tmp$ clang -O0 -g e.c -lm; ./a.out 9223372036854775295.0
d = 9223372036854774784.000000
fetestexcept() = 0
fetestexcept() = 0
manl = 9223372036854774784
zimmerma@tomate:/tmp$ clang -O0 -g e.c -lm; ./a.out 9223372036854775296.0
d = 9223372036854775808.000000
fetestexcept() = 0
fetestexcept() = 1
manl = 9223372036854775808
```




---

archive/issue_comments_314517.json:
```json
{
    "body": "On FreeBSD/clang the output of the comment 115 code is different (FP_INEXACT is raised, as I already said):\n\n```\n./a.out 1.4488038916154245e+19\nd = 14488038916154245120.000000\nfetestexcept() = 32\nfetestexcept() = 33\nmanl = 14488038916154245120\n```\n\n\nBut OK, it's indeed something fixable",
    "created_at": "2017-05-18T15:00:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314517",
    "user": "@dimpase"
}
```

On FreeBSD/clang the output of the comment 115 code is different (FP_INEXACT is raised, as I already said):

```
./a.out 1.4488038916154245e+19
d = 14488038916154245120.000000
fetestexcept() = 32
fetestexcept() = 33
manl = 14488038916154245120
```


But OK, it's indeed something fixable



---

archive/issue_comments_314518.json:
```json
{
    "body": "seems to be bug 17686 of clang: https://bugs.llvm.org//show_bug.cgi?id=17686",
    "created_at": "2017-05-18T15:05:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314518",
    "user": "@zimmermann6"
}
```

seems to be bug 17686 of clang: https://bugs.llvm.org//show_bug.cgi?id=17686



---

archive/issue_comments_314519.json:
```json
{
    "body": "Hmm, I do not like the reaction of clang devs, sounds like \"huh, we don't care\" to me.\nSee e.g. related https://bugs.llvm.org//show_bug.cgi?id=8100",
    "created_at": "2017-05-18T15:27:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314519",
    "user": "@dimpase"
}
```

Hmm, I do not like the reaction of clang devs, sounds like "huh, we don't care" to me.
See e.g. related https://bugs.llvm.org//show_bug.cgi?id=8100



---

archive/issue_comments_314520.json:
```json
{
    "body": "https://bugs.llvm.org//show_bug.cgi?id=8100 is a different issue. I hope they will fix bug 17686.\nIn the meantime the following ugly patch should fix the warning (in this code the value of `d` is\nalways greater or equal to 2<sup>63</sup>):\n\n```\n   manl = 0x8000000000000000 + (mp_limb_t) (d - 9223372036854775808.0);\n```\n",
    "created_at": "2017-05-18T16:06:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314520",
    "user": "@zimmermann6"
}
```

https://bugs.llvm.org//show_bug.cgi?id=8100 is a different issue. I hope they will fix bug 17686.
In the meantime the following ugly patch should fix the warning (in this code the value of `d` is
always greater or equal to 2<sup>63</sup>):

```
   manl = 0x8000000000000000 + (mp_limb_t) (d - 9223372036854775808.0);
```




---

archive/issue_comments_314521.json:
```json
{
    "body": "Yeah, this does work! I'll post the (1-line) patch; not sure how to make it conditional on clang, but that's of secondary importance. At least this nightmare is over, apparently. :-)",
    "created_at": "2017-05-18T21:20:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314521",
    "user": "@dimpase"
}
```

Yeah, this does work! I'll post the (1-line) patch; not sure how to make it conditional on clang, but that's of secondary importance. At least this nightmare is over, apparently. :-)



---

archive/issue_comments_314522.json:
```json
{
    "body": "Replying to [comment:121 dimpase]:\n> Yeah, this does work! I'll post the (1-line) patch; not sure how to make it conditional on clang, but that's of secondary importance. At least this nightmare is over, apparently. :-)\n\nPatch to mpfr or numpy? #12426 has stuff to expose the fact that clang is used, so it could be folded back into that.",
    "created_at": "2017-05-18T21:34:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314522",
    "user": "@kiwifb"
}
```

Replying to [comment:121 dimpase]:
> Yeah, this does work! I'll post the (1-line) patch; not sure how to make it conditional on clang, but that's of secondary importance. At least this nightmare is over, apparently. :-)

Patch to mpfr or numpy? #12426 has stuff to expose the fact that clang is used, so it could be folded back into that.



---

archive/issue_comments_314523.json:
```json
{
    "body": "This implements Paul's fix. I'm still running tests, but few things so far indicate that no FPU-related noise is created. (E.g. `from sage.all import *` works with `fpectl` armed to go off at any FPU flags raised, etc). And we can leave `numpy` alone.",
    "created_at": "2017-05-18T21:41:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314523",
    "user": "@dimpase"
}
```

This implements Paul's fix. I'm still running tests, but few things so far indicate that no FPU-related noise is created. (E.g. `from sage.all import *` works with `fpectl` armed to go off at any FPU flags raised, etc). And we can leave `numpy` alone.



---

archive/issue_comments_314524.json:
```json
{
    "body": "I think we can improve the patch by inserting a pragma so the fix is only compiled if we are using clang.",
    "created_at": "2017-05-18T21:45:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314524",
    "user": "@kiwifb"
}
```

I think we can improve the patch by inserting a pragma so the fix is only compiled if we are using clang.



---

archive/issue_comments_314525.json:
```json
{
    "body": "Hopefully the MPFR upstream would step in and provide the patch?",
    "created_at": "2017-05-18T22:25:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314525",
    "user": "@dimpase"
}
```

Hopefully the MPFR upstream would step in and provide the patch?



---

archive/issue_comments_314526.json:
```json
{
    "body": "Ok, this now compile the workaround only when clang is used. And it is ready for review.\n----\nNew commits:",
    "created_at": "2017-05-18T23:29:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314526",
    "user": "@kiwifb"
}
```

Ok, this now compile the workaround only when clang is used. And it is ready for review.
----
New commits:



---

archive/issue_comments_314527.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-05-18T23:29:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314527",
    "user": "@kiwifb"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_314528.json:
```json
{
    "body": "With this plus #12426, all tests pass for me on OS X!",
    "created_at": "2017-05-19T03:46:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314528",
    "user": "@jhpalmieri"
}
```

With this plus #12426, all tests pass for me on OS X!



---

archive/issue_comments_314529.json:
```json
{
    "body": "we applied the following patch in the development version of MPFR:\n\n```\n--- src/set_d.c (revision 11493)\n+++ src/set_d.c (working copy)\n@@ -130,8 +130,16 @@\n \n     d *= MP_BASE_AS_DOUBLE;\n #if GMP_NUMB_BITS >= 64\n+#ifndef __clang__\n     manl = d;\n #else\n+    /* clang produces an invalid exception when d >= 2^63,\n+       see https://bugs.llvm.org//show_bug.cgi?id=17686.\n+       Since this is always the case, here, we use the following patch. */\n+    MPFR_STAT_STATIC_ASSERT (GMP_NUMB_BITS == 64);\n+    manl = 0x8000000000000000 + (mp_limb_t) (d - 0x8000000000000000);\n+#endif /* __clang__ */\n+#else\n     MPFR_STAT_STATIC_ASSERT (GMP_NUMB_BITS == 32);\n     manh = (mp_limb_t) d;\n     manl = (mp_limb_t) ((d - manh) * MP_BASE_AS_DOUBLE);\n```\n",
    "created_at": "2017-05-19T08:19:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314529",
    "user": "@zimmermann6"
}
```

we applied the following patch in the development version of MPFR:

```
--- src/set_d.c (revision 11493)
+++ src/set_d.c (working copy)
@@ -130,8 +130,16 @@
 
     d *= MP_BASE_AS_DOUBLE;
 #if GMP_NUMB_BITS >= 64
+#ifndef __clang__
     manl = d;
 #else
+    /* clang produces an invalid exception when d >= 2^63,
+       see https://bugs.llvm.org//show_bug.cgi?id=17686.
+       Since this is always the case, here, we use the following patch. */
+    MPFR_STAT_STATIC_ASSERT (GMP_NUMB_BITS == 64);
+    manl = 0x8000000000000000 + (mp_limb_t) (d - 0x8000000000000000);
+#endif /* __clang__ */
+#else
     MPFR_STAT_STATIC_ASSERT (GMP_NUMB_BITS == 32);
     manh = (mp_limb_t) d;
     manl = (mp_limb_t) ((d - manh) * MP_BASE_AS_DOUBLE);
```




---

archive/issue_comments_314530.json:
```json
{
    "body": "OK, I'll update the branch with this precise patch shortly. I have to think of using `ifndef` more.",
    "created_at": "2017-05-19T08:23:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314530",
    "user": "@kiwifb"
}
```

OK, I'll update the branch with this precise patch shortly. I have to think of using `ifndef` more.



---

archive/issue_comments_314531.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-05-19T09:24:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314531",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_314532.json:
```json
{
    "body": "I followed your commit as closely as possible, but 3.1.5 doesn't seem to have `MPFR_STAT_STATIC_ASSERT` so I had to remove it.",
    "created_at": "2017-05-19T09:25:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314532",
    "user": "@kiwifb"
}
```

I followed your commit as closely as possible, but 3.1.5 doesn't seem to have `MPFR_STAT_STATIC_ASSERT` so I had to remove it.



---

archive/issue_comments_314533.json:
```json
{
    "body": "Replying to [comment:131 fbissey]:\n> I followed your commit as closely as possible, but 3.1.5 doesn't seem to have `MPFR_STAT_STATIC_ASSERT` so I had to remove it.\n\nok, sorry for that. I also realized that 3.1.5 uses the generic case (_GMP_IEEE_FLOATS not defined)\nwhile the development version of MPFR has _MPFR_IEEE_FLOATS defined, thus uses a different code\n(which does not raise the exception).",
    "created_at": "2017-05-19T11:08:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314533",
    "user": "@zimmermann6"
}
```

Replying to [comment:131 fbissey]:
> I followed your commit as closely as possible, but 3.1.5 doesn't seem to have `MPFR_STAT_STATIC_ASSERT` so I had to remove it.

ok, sorry for that. I also realized that 3.1.5 uses the generic case (_GMP_IEEE_FLOATS not defined)
while the development version of MPFR has _MPFR_IEEE_FLOATS defined, thus uses a different code
(which does not raise the exception).



---

archive/issue_comments_314534.json:
```json
{
    "body": "Someone to review? John?",
    "created_at": "2017-05-25T02:56:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314534",
    "user": "@kiwifb"
}
```

Someone to review? John?



---

archive/issue_comments_314535.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-05-25T04:57:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314535",
    "user": "@jhpalmieri"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_314536.json:
```json
{
    "body": "Yes, positive review.",
    "created_at": "2017-05-25T04:57:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314536",
    "user": "@jhpalmieri"
}
```

Yes, positive review.



---

archive/issue_comments_314537.json:
```json
{
    "body": "I'm running tests on FreeBSD now, but I expect it will all be good with the patch.",
    "created_at": "2017-05-25T05:10:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314537",
    "user": "@dimpase"
}
```

I'm running tests on FreeBSD now, but I expect it will all be good with the patch.



---

archive/issue_comments_314538.json:
```json
{
    "body": "yes, this also is good on FreeBSD",
    "created_at": "2017-05-25T07:47:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314538",
    "user": "@dimpase"
}
```

yes, this also is good on FreeBSD



---

archive/issue_comments_314539.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-05-27T23:42:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22562",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22562#issuecomment-314539",
    "user": "@vbraun"
}
```

Resolution: fixed
