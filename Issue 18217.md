# Issue 18217: New `random_cone()` function

Issue created by migration from https://trac.sagemath.org/ticket/18454

Original creator: mjo

Original creation time: 2015-05-19 19:24:29

For testing algebraic properties of cones (for example, the dual of a dual cone is the original cone) it is useful to be able to generate "random" cones.

I have a work-in-progress branch for this which adds `random_cone()` to `sage.geometry.cone`.


---

Comment by mjo created at 2015-05-19 21:31:20

Changing status from new to needs_review.


---

Comment by mjo created at 2015-05-19 21:31:20

New commits:


---

Comment by novoselt created at 2015-05-20 04:46:14

I will surely have more picks, but for starters:

 - it would be nice to have an option of specifying the lattice of the random cone

 - decision to limit maximum number of rays to double dimension is not natural - I would drop it completely, but perhaps warn the user in documentation that it may take a while to generate a random cone with a lot of rays of low dimension. If you are up to the "guaranteed possible maximum" then it is dimension plus one - consider the cone on the vertices of a simplex containing the origin.


---

Comment by mjo created at 2015-05-20 05:20:01

Replying to [comment:2 novoselt]:
> I will surely have more picks, but for starters:
> 
>  - it would be nice to have an option of specifying the lattice of the random cone

Thanks, I can try to do this one.




>  - decision to limit maximum number of rays to double dimension is not natural - I would drop it completely, but perhaps warn the user in documentation that it may take a while to generate a random cone with a lot of rays of low dimension.

I wasn't sure what to do here. I was trying to avoid returning a cone with e.g. four rays when the user specified `min_rays == max_rays == 10` (for example). What do we do if the user requests a minimum of 100 rays in R<sup>2</sup>? It's going to take a while indeed =)

In R<sup>3</sup>, it might happen by chance, but the current algorithm won't get there eventually: we're appending new rays to a list, and once we have plus/minus the standard basis, we can append forever and never get any new generators. We'd have to throw out the cone once it becomes the whole space and start over.


---

Comment by git created at 2015-05-20 14:28:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by novoselt created at 2015-05-20 16:15:37

Well, it would be helpful to know in what sense the cone is "random". If it is a cone on a random set of rays, then dimension+1 is the only sensible upper bound to me - such a cone always can be constructed. In R<sup>2</sup> it may be possible to force construction of cones with more than 4 rays - given that the code can handle 4 instead of 3 for the whole space, probably it can live with 100. But if we are talking about the minimal number of extremal rays, then for R<sup>1,2</sup> maximum is the dimension and for all others we can do anything - generate a random n-gon in a plane and lift it.

In most cases I think you would want a strictly convex cone, so that's exactly what you want with bonus points if primitive generators are not necessarily in the same hyperplane. Algorithm: generate random vectors with positive last component. There may be an extra switch to allow linear subspaces in cones.


---

Comment by mjo created at 2015-05-21 14:52:55

Replying to [comment:5 novoselt]:
> Well, it would be helpful to know in what sense the cone is "random". If it is a cone on a random set of rays, then dimension+1 is the only sensible upper bound to me - such a cone always can be constructed.

In any dimension you can do better, up to 2*dimension -- just take the standard basis and add negative multiples of them. The resulting come will have 2*dimension generating rays and be equal to the entire space.




> In R<sup>2</sup> it may be possible to force construction of cones with more than 4 rays - given that the code can handle 4 instead of 3 for the whole space, probably it can live with 100.

Can you really get more than four in R<sup>2</sup>? I haven't tried to prove it but geometrically, once you have four and try to add one more, the fifth one should either be contained in the cone already (obsoleting the new one), or be above/below some other generator (obsoleting the old one).


> But if we are talking about the minimal number of extremal rays, then for R<sup>1,2</sup> maximum is the dimension and for all others we can do anything - generate a random n-gon in a plane and lift it.

Right, so here you definitely wouldn't want to limit the number of rays to dimension+1.


> In most cases I think you would want a strictly convex cone, so that's exactly what you want with bonus points if primitive generators are not necessarily in the same hyperplane. Algorithm: generate random vectors with positive last component. There may be an extra switch to allow linear subspaces in cones.

When I started working on this, I thought I was interested in proper (strictly convex, nonempty interior) cones. But the stuff I'm doing appears to generalize, and none of my test cases require this (nor do the test cases I added in commit 1bbb2d1). But I agree it would be useful. I'll try to add a `strictly_convex = None/True/False` parameter. Likewise for `solid = None/True/False` if it doesn't look too hard.


---

Comment by novoselt created at 2015-05-21 23:43:16

Replying to [comment:6 mjo]:
> Replying to [comment:5 novoselt]:
> > Well, it would be helpful to know in what sense the cone is "random". If it is a cone on a random set of rays, then dimension+1 is the only sensible upper bound to me - such a cone always can be constructed.
> In any dimension you can do better, up to 2*dimension -- just take the standard basis and add negative multiples of them. The resulting come will have 2*dimension generating rays and be equal to the entire space.
"Better" in what sense? Take (or "generate randomly") rays (1,0), (0,1), (-1,-1) in the plane and you can no longer add rays which are independent of these three. "Random generation" of four rays in opposite pairs is much less likely to happen. So if you keep generating rays removing those which are dependent with already constructed ones until you reach a predefined maximum, you cannot guarantee that more than 3 are possible.


> > In R<sup>2</sup> it may be possible to force construction of cones with more than 4 rays - given that the code can handle 4 instead of 3 for the whole space, probably it can live with 100.
> Can you really get more than four in R<sup>2</sup>?
I meant that you can have a cone in the plane with a hundred rays that you decided to call generating ones - Sage constructors may allow you to do it for cones with linear subspaces, although I don't know why one would want it.

> > But if we are talking about the minimal number of extremal rays, then for R<sup>1,2</sup> maximum is the dimension and for all others we can do anything - generate a random n-gon in a plane and lift it.
> 
> Right, so here you definitely wouldn't want to limit the number of rays to dimension+1.
Nor to twice the dimension!


---

Comment by mjo created at 2015-05-22 03:16:53

Replying to [comment:7 novoselt]:
> > Right, so here you definitely wouldn't want to limit the number of rays to dimension+1.
> Nor to twice the dimension!

Ok, point taken =)

I'll remove the restriction in the next commit and add warnings to the docs. It looks easy to add a `strictly_convex` parameter, so that's on its way too. Letting the user request a solid cone is a mess, though.


---

Comment by git created at 2015-05-23 01:12:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-05-23 01:22:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2015-05-23 01:25:36

That wasn't *too* bad. I removed all of the unnecessary restrictions. The only ones that remain avoid (guaranteed) infinite loops. Almost all of the code is in sanity checks, error reporting, and tests.

Once I refactored for `strictly_convex`, `solid` wasn't so hard anymore. By putting everything in a loop, it makes it easy to throw the current cone away and start over. We therefore don't have to try too hard to fix an unpromising cone.


---

Comment by git created at 2015-05-23 15:15:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-04 22:29:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-13 14:31:26

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2015-06-13 14:52:57

There are no new changes there, just a rebase on top of 6.8.beta4 for the sake of ticket #18696.


---

Comment by git created at 2015-07-12 01:34:02

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mjo created at 2015-07-25 18:12:43

Replying to [comment:7 novoselt]:

Is there anything I can do to help get this reviewed? Bribery and/or trade reviews?

I have a bunch of "easy" (new method) tickets in the pipeline for a paper I'm working on, and I've used random testing for many of the properties in those tickets. I'd like to be able to cite Sage in the paper (and vice-versa) as a working implementation if we can get the algorithm merged in time.

If there are any implementation bugs, the output is either random or an error so I can just fix them and no one should notice =)

I'm happy to seek out other reviewers if you'd prefer, but I know the cone code is your baby so I'd prefer that you review it if you can.


---

Comment by novoselt created at 2015-07-27 01:39:09

I really hope to review it this coming week! (As well as small follow ups that you have posted.)


---

Comment by novoselt created at 2015-07-31 01:36:58

I have a problem with `min/max_dim` - I was sure they talk about the dimension of the cone, until I got to their description. The example with it is also confusing:

```
    We can predict the dimension when ``min_dim == max_dim``::

        sage: set_random_seed()
        sage: random_cone(min_dim=4, max_dim=4, min_rays=0, max_rays=0)
        0-d cone in 4-d lattice N
```

To me this looks like we predict the dimension 0 based on `min/max_rays`.

I would be in favour of using `min/max_dim` for the dimension of the cone, allowing specifying `lattice` together with these parameters as long as its dimension is at least `max_dim`, and when not given defaulting to `max_dim`-dimensional lattice. If you don't want to work on such functionality, can we please rename parameters to `min/max_ambient_dim` to avoid ambiguity when reading calls of this function?


---

Comment by novoselt created at 2015-07-31 22:04:02

I am not a big fun of examples that generate multiple cones of the same type to make sure that things are OK. What's the point? These tests WILL be run multiple times by users and patchbots during global testing, aren't these repetitions enough?


---

Comment by git created at 2015-08-03 16:58:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2015-08-03 17:00:28

Replying to [comment:19 novoselt]:
> I have a problem with `min/max_dim` - I was sure they talk about the dimension of the cone, until I got to their description. The example with it is also confusing:

Right on both counts. I renamed the parameters, and fixed those two doctests. Now I save the result of `random_cone()` and check only the relevant property.

I also removed a bunch of the redundant tests and cleaned up a little.

I think I'm receiving trac notifications again so I should be more responsive...


---

Comment by mjo created at 2015-08-05 01:23:18

Replying to [comment:19 novoselt]:
> I would be in favour of using `min/max_dim` for the dimension of the cone, allowing specifying `lattice` together with these parameters as long as its dimension is at least `max_dim`, and when not given defaulting to `max_dim`-dimensional lattice. If you don't want to work on such functionality...

(I forgot to respond to this part).

I don't need this ability, and I'm already pretty deep in trac ticket debt, so I don't want to add any more knobs right now. I'd be willing to add it later on if someone requests it though.


---

Comment by novoselt created at 2015-08-12 01:46:35

OK:
 - merged current version of #18613 to make isomorphism checks work as expected
 - there was a duplicate piece of code, removed
 - I tweaked some code, hopefully not unreasonably

Regarding redundant tests I was mostly complaining about things like 

```
    Ensure that we can generate cones which are not strictly convex
    (can take a long time)::

        sage: set_random_seed()                         # long time
        sage: l = [ random_cone(min_ambient_dim=1,      # long time
        ....:                   max_ambient_dim=8,      # long time
        ....:                   min_rays=2,             # long time
        ....:                   max_rays=10,            # long time
        ....:                   strictly_convex=False)\
        ....:                   .is_strictly_convex()   # long time
        ....:       for i in range(0,10)]               # long time
        sage: any(l)                                    # long time
        False

    As well as ones that are strictly convex::

        sage: set_random_seed()                        # long time
        sage: l = [ random_cone(min_ambient_dim=1,     # long time
        ....:                   max_ambient_dim=8,     # long time
        ....:                   min_rays=2,            # long time
        ....:                   max_rays=10,           # long time
        ....:                   strictly_convex=True)\
        ....:                   .is_strictly_convex()  # long time
        ....:       for i in range(0,10) ]             # long time
        sage: all(l)                                   # long time
        True
```

given that above we have

```
    We can also request a strictly convex cone::

        sage: set_random_seed()
        sage: K = random_cone(max_ambient_dim=8, max_rays=10,
        ....:                 strictly_convex=True)
        sage: K.is_strictly_convex()
        True

    Or one that isn't strictly convex::

        sage: set_random_seed()
        sage: K = random_cone(min_ambient_dim=5, min_rays=2,
        ....:                 strictly_convex=False)
        sage: K.is_strictly_convex()
        False
```

Since this single random tests will be repeated many times on different machines, I see little point in running 10 tests for longer version. But if you really like to keep them it is fine with me.

The code also seems a bit over-commented to me, but if you had to have them there probably others can appreciate it as well. And #18613 has clearly demonstrated that it is a very useful addition!

Bottom line: set to positive review if you are OK with my changes (and perhaps review #18613 as well?-))
----
New commits:


---

Comment by mjo created at 2015-08-14 19:13:58

Replying to [comment:25 novoselt]:
> OK:
>  - merged current version of #18613 to make isomorphism checks work as expected
>  - there was a duplicate piece of code, removed
>  - I tweaked some code, hopefully not unreasonably
> 
> Regarding redundant tests I was mostly complaining about things like... But if you really like to keep them it is fine with me.

Nope, I just had some other redundant tests in mind. You're right, I've removed them. Thanks for the rest of the changes, too, they all look good. Just need a thumbs up on my last commit and I think this is ready.


---

Comment by mjo created at 2015-08-14 19:14:24

Last 10 new commits:


---

Comment by novoselt created at 2015-08-15 00:32:49

Thumbs up!


---

Comment by novoselt created at 2015-08-15 00:32:49

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-08-15 17:52:39

Resolution: fixed


---

Comment by jdemeyer created at 2018-01-16 23:02:01

This recently started breaking, no idea why...

See #24517
