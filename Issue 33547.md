# Issue 33547: provide a framework for finite group actions

Issue created by migration from https://trac.sagemath.org/ticket/33784

Original creator: mantepse

Original creation time: 2022-05-02 11:30:31

CC:  tscrim kcrisman




---

Comment by mantepse created at 2022-05-02 11:35:12

Changing type from PLEASE CHANGE to enhancement.


---

Comment by mantepse created at 2022-05-02 11:35:12

Changing component from PLEASE CHANGE to group theory.


---

Comment by mantepse created at 2022-05-02 11:35:12

Sage should have an easy to use and efficient framework to play with finite group actions.
----
New commits:


---

Comment by git created at 2022-05-03 13:14:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-03 18:46:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-03 19:12:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-05-03 19:15:34

This ticket provides an easy user interface to define a permutation group corresponding to a finite group actions.


```
        sage: a = lambda x: (2*x) % 6                                                                                                                                                        
        sage: X = [0,1,2,3,4,5]                                                                                                                                                              
        sage: G = PermutationGroup(action=a, domain=X)                                                                                                                                       
        sage: G.orbits()                                                                                                                                                                     
        [[0], [1, 2, 4], [3], [5]]                                                                                                                                                           
                                                                                                                                                                                             
        sage: a = lambda g, x: vector(g*x, immutable=True)                                                                                                                                   
        sage: X = [vector(x, immutable=True) for x in GF(3)^2]                                                                                                                               
        sage: G = SL(2,3); G.gens()                                                                                                                                                          
        (                                                                                                                                                                                    
        [1 1]  [0 1]                                                                                                                                                                         
        [0 1], [2 0]                                                                                                                                                                         
        )                                                                                                                                                                                    
        sage: H = PermutationGroup(G.gens(), action=a, domain=X)                                                                                                                             
        sage: H.orbits()                                                                                                                                                                     
        [[(0, 0)], [(1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]]                                                                                                         
        sage: H.gens()                                                                                                                                                                       
        [((0,1),(1,1),(2,1))((0,2),(2,2),(1,2)),                                                                                                                                             
         ((1,0),(0,2),(2,0),(0,1))((1,1),(1,2),(2,2),(2,1))]    
```



---

Comment by mantepse created at 2022-05-03 19:16:07

Changing status from new to needs_review.


---

Comment by kcrisman created at 2022-05-03 20:53:45

This is nice.  Some questions.

> This ticket provides an easy user interface to define a permutation group corresponding to a finite group actions.
> 
> {{{
>         sage: a = lambda x: (2*x) % 6                                                                                                                                                        
>         sage: X = [0,1,2,3,4,5]                                                                                                                                                              
>         sage: G = PermutationGroup(action=a, domain=X)                                                                                                                                       
>         sage: G.orbits()                                                                                                                                                                     
>         [[0], [1, 2, 4], [3], [5]]                                                                                                                                                           
>                      
> }}} 

Is there any checking that this is meaningful, or is it garbage in, garbage out?  Such as if one changed the lambda function here to be modulo 5, or 100.  (I know that 100 is garbage, I think 5 would be as well.)

Also, should it print out differently?  You do `PermutationGroup_generic.__init__` and presumably this defines its string representation.  

Can we do group operations (I mean like semi/direct product etc.) on it with others?  Does each (finite permutation) group automatically have an extension to this with a natural action (and would that be conjugation, right mult., left mult.)?  I'm just a little concerned about how it might be able to integrate in long-term with other group stuff.


---

Comment by mantepse created at 2022-05-04 06:05:45

Replying to [comment:10 kcrisman]:
> This is nice.

Thank you :-)

> > {{{
> >         sage: a = lambda x: (2*x) % 6                                                                                                                                                        
> >         sage: X = [0,1,2,3,4,5]                                                                                                                                                              
> >         sage: G = PermutationGroup(action=a, domain=X)                                                                                                                                       
> >         sage: G.orbits()                                                                                                                                                                     
> >         [[0], [1, 2, 4], [3], [5]]                                                                                                                                                           
> >                      
> > }}} 
> 
> Is there any checking that this is meaningful, or is it garbage in, garbage out?  Such as if one changed the lambda function here to be modulo 5, or 100.  (I know that 100 is garbage, I think 5 would be as well.)

Currently it is garbage in, garbage out.  Do you have any checks in mind one could do?

Maybe it would even be possible to allow domain being specified only partially.  That is, it should suffice to include one element per orbit, to generate the full domain.

> Also, should it print out differently?  You do `PermutationGroup_generic.__init__` and presumably this defines its string representation.

Since `PermutationGroup(action=a, domain=X)` is just yet another way to define a `PermutationGroup`, it should be a `PermutationGroup` and print as such.  Note that only the image of 𝐺 → 𝔖_𝑋 is remembered.  (Can't trac do LaTeX?)

> Can we do group operations (I mean like semi/direct product etc.) on it with others?  Does each (finite permutation) group automatically have an extension to this with a natural action (and would that be conjugation, right mult., left mult.)?  I'm just a little concerned about how it might be able to integrate in long-term with other group stuff.

Does my reply above answer this question?


---

Comment by mantepse created at 2022-05-04 08:36:32

Replying to [comment:11 mantepse]:
> Replying to [comment:10 kcrisman]:
> > > {{{
> > >         sage: a = lambda x: (2*x) % 6                                                                                                                                                        
> > >         sage: X = [0,1,2,3,4,5]                                                                                                                                                              
> > >         sage: G = PermutationGroup(action=a, domain=X)                                                                                                                                       
> > >         sage: G.orbits()                                                                                                                                                                     
> > >         [[0], [1, 2, 4], [3], [5]]                                                                                                                                                           
> > >                      
> > > }}} 
> > 
> > Is there any checking that this is meaningful, or is it garbage in, garbage out?  Such as if one changed the lambda function here to be modulo 5, or 100.  (I know that 100 is garbage, I think 5 would be as well.)
> 
> Currently it is garbage in, garbage out.  Do you have any checks in mind one could do?

Actually, the map `a = lambda x: (2*x) % 6` is garbage - it is not invertible and therefore certainly not the generator of a cyclic group.  It should be `a = lambda x: (2*x) % 5`.

Currently, `sage.combinat.cyclic_sieving_phenomenon.orbit_decomposition` is defined as follows:

```
def orbit_decomposition(L, cyc_act) -> list[list]:
    orbits = []
    L_prime = set(L)
    while L_prime:
        obj = L_prime.pop()
        orbit = [obj]
        obj = cyc_act(obj)
        while obj in L_prime:
            orbit.append(obj)
            L_prime.remove(obj)
            obj = cyc_act(obj)
        orbits.append(orbit)
    return orbits
```

I think it would be better to make it

```
def orbit_decomposition(L, cyc_act) -> list[list]:
    orbits = []
    L_prime = set(L)
    while L_prime:
        fst = L_prime.pop()
        orbit = [fst]
        obj = cyc_act(fst)
        while obj != fst:
            orbit.append(obj)
            L_prime.discard(obj)
            obj = cyc_act(obj)
        orbits.append(orbit)
    return orbits
```

Doing so one would have to provide only one element from each orbit, and the remaining elements would be generated by the action.  This might be practical sometimes.  Moreover and more importantly, silly mistakes as the one above would be detected, because `orbit_decomposition` would go into an infinite loop.

However, we cannot have a similar behaviour for `PermutationGroup(gens, domain=domain)`, because of the following weirdness:

```
sage: PermutationGroup([("a","c")]).domain()
{'a', 'c'}
sage: PermutationGroup([(1,3)]).domain()
{1, 2, 3}
```

So the only way to get a permutation group with domain `{1, 3}` is

```
sage: PermutationGroup([(1,3)], domain=[1,3]).domain()
{1, 3}
```



---

Comment by git created at 2022-05-04 08:56:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kcrisman created at 2022-05-04 12:38:48

> Currently it is garbage in, garbage out.  Do you have any checks in mind one could do?

No, I'm not sure, but I know that Sage tends to lean in that direction.  Maybe something one could ask on the list about, or David might have ideas.  Glad you saw there was a mistake, by the way - I don't know why I got confused there either.  Although should the empty permutation be a generator, strictly speaking?


```
+        sage: H.gens()
+        [(), (1,2,4), (3,6,5)]
```


I admit I'm a little confused about the difference between the "acting group" and the homomorphic image here.

> Since `PermutationGroup(action=a, domain=X)` is just yet another way to define a `PermutationGroup`, it should be a `PermutationGroup` and print as such.  Note that only the image of 𝐺 → 𝔖_𝑋 is remembered.  (Can't trac do LaTeX?)

Hmm, so really it just a wrapper of sorts making it easier to define permutation (sub)groups on arbitrary finite sets

> > Can we do group operations (I mean like semi/direct product etc.) on it with others?  Does each (finite permutation) group automatically have an extension to this with a natural action (and would that be conjugation, right mult., left mult.)?  I'm just a little concerned about how it might be able to integrate in long-term with other group stuff.
> 
> Does my reply above answer this question?
So I guess not any differently from before.

> I think it would be better to make it

Probably that could be a separate ticket, since it would be improving already-existing functionality.

> {{{
> sage: PermutationGroup([(1,3)]).domain()
> {1, 2, 3}
> }}}

Yeah, this is annoying, I've run into it before.


---

Comment by mantepse created at 2022-05-04 15:17:49

Replying to [comment:14 kcrisman]:

> Although should the empty permutation be a generator, strictly speaking?
> 
> {{{
> +        sage: H.gens()
> +        [(), (1,2,4), (3,6,5)]
> }}}

Well, `PermutationGroup` allows it, but I could also (manually) remove singleton orbits.
 
> I admit I'm a little confused about the difference between the "acting group" and the homomorphic image here.

For example, the symmetric group acts on the singleton set trivially:

```
sage: PermutationGroup(SymmetricGroup(3).gens(), action=lambda g, x: x, domain=[1])
Permutation Group with generators [(), ()]
```

and there is no way to recover the symmetric group from that.  I think that is okay, because any computation you want to do with the action you can actually do with the permutation group.

> Hmm, so really it just a wrapper of sorts making it easier to define permutation (sub)groups on arbitrary finite sets

Indeed.

> Can we do group operations (I mean like semi/direct product etc.) on it with others?  

My plan is to provide a new implementation of combinatorial species, which will make computations with group actions of the symmetric group (and possibly some others) very convenient.  It seems that there is very little support currently.

> Does each (finite permutation) group automatically have an extension to this with a natural action (and would that be conjugation, right mult., left mult.)?  I'm just a little concerned about how it might be able to integrate in long-term with other group stuff.

I am not sure what "to this" is pointing to.  With my current implementation, the action of the group is not part of the data of the `PermutationGroup`, and I think that this is how it should be.  If there is something we want to do with the action, we would indeed need a separate `FiniteGroupAction` class.  However, currently I cannot think of anything that would justify it.


---

Comment by kcrisman created at 2022-05-04 15:26:08

> I am not sure what "to this" is pointing to.  With my current implementation, the action of the group is not part of the data of the `PermutationGroup`, and I think that this is how it should be.  If there is something we want to do with the action, we would indeed need a separate `FiniteGroupAction` class.  However, currently I cannot think of anything that would justify it.

Okay, this paragraph clarifies greatly what you are trying to do here.  It is a little outside of my full expertise so I won't do further review, but I think this is a good start at some of your goals, and certainly for making it much easier to do permutation groups that are "non-standard".


---

Comment by git created at 2022-05-05 07:49:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2022-05-05 19:31:37

Note that what we really need (and what Gap may already have) is the general notion of a (finite) group G and a (finite) G-set V. So basically a homomorphism G -> Sym(V), although I'm not sure that's always the best way of working with such an object.

Given a group G, one often wants to cconsider *many* actions. For instance, for any subgroup H of G one probably wants to consider the natural action of G on the cosets G/H. Or one may be interested in the conjugation action on elements or subgroups (although that is probably better handled with specific conjugacy code rather than general permutation-theoretic code).

I don't think you want to define different group wrappers just to store the action in every time. I would probably suggest to just first see what framework you can build up from taking *actions* as your central objects. You can then see if it is warranted to provide many wrappers in the direction of groups-with-action or G-sets (set-with-group-acting-on-it).

Of course, an important example (and probably the one that's underlying most of actual functionality) is S_n itself, acting on {1,..,n}. But finite linear groups such as GL(n,q) also come with natural actions. I suspect most of the non-trivial functionality is already available in GAP and the trick will be to properly wrap/expose it in sage.


---

Comment by mantepse created at 2022-05-05 21:17:38

Hi Nils, thank you for your comments!

The current branch does only one very simple thing: it provides an easy interface to obtain the image of the homomorphism G -> Sym(V).  Personally, I used the function `sage.combinat.cyclic_sieving.orbit_decomposition` so far.  The current branch is a replacement for that, and I hope that creating the `PermutationGroup` has very little overhead, but does have the advantage of providing it through a well-established interface.  Note that the action itself isn't stored, only the orbits (of course, this might be a large object) and the generators.  I admit that this takes up twice as much space as `orbit_decomposition`.

I thought at first that I'd want to model group actions themselves (hence the title of the ticket), but it turned out that I don't really need this.  Moreover, I didn't find any interesting functionality such a class `FiniteGroupAction` could have, which wouldn't be a functionality already provided by `PermutationGroup`.

Does this sound reasonable?


---

Comment by wdj created at 2022-05-06 15:22:31

I copy+pasted all the code in that permgroup.py module in this trac ticket into a sage file, then
attached it to a sage session and ran some examples by hand. 
Here are a few comments:

line 371: I'd remove "#See Trac 12597". This isn't your addition, but why keep this?

Lines 435 and 475 return "The following tests failed..." Is this supposed to happen?

There are also errors in lines 552, 562, 563, 649.

Line 765 returns True (not False, as in the documentation).

Is line 760 needed? ("Check trac 29624 is fixed.") You didn't add this but this ticket is 10 years old now.

Line 890 returns False (not True, as in the documentation).

There seems to be something wrong with the PermutationGroupElement code. Look at the TrypeErrors returns by running the examples in lines 896 and 899.

I could go on if you like (the module has over 5000 lines). Let me know.


---

Comment by kcrisman created at 2022-05-06 15:34:14

David, I think a lot of that might be cruft that could be addressed on another ticket (and maybe it should be! feel free to open one).  Here is the diff of this ticket, if it helps - should only have to review it, per se.

```diff
diff --git a/src/sage/groups/perm_gps/permgroup.py b/src/sage/groups/perm_gps/permgroup.py
index f10fb48..c2ffd5e 100644
--- a/src/sage/groups/perm_gps/permgroup.py
+++ b/src/sage/groups/perm_gps/permgroup.py
@@ -331,6 +331,39 @@ def PermutationGroup(gens=None, *args, **kwds):
         sage: G2.GeneratorsSmallest()
         [ (3,4,5), (2,3)(4,5), (1,2)(4,5) ]
 
+    We can create a permutation group from a group action::
+
+        sage: a = lambda x: (2*x) % 7
+        sage: H = PermutationGroup(action=a, domain=range(7))
+        sage: H.orbits()
+        [[0], [1, 2, 4], [3, 6, 5]]
+        sage: H.gens()
+        [(1,2,4), (3,6,5)]
+
+    Note that we provide generators for the acting group.  The
+    permutation group we construct is its homomorphic image::
+
+        sage: a = lambda g, x: vector(g*x, immutable=True)
+        sage: X = [vector(x, immutable=True) for x in GF(3)^2]
+        sage: G = SL(2,3); G.gens()
+        (
+        [1 1]  [0 1]
+        [0 1], [2 0]
+        )
+        sage: H = PermutationGroup(G.gens(), action=a, domain=X)
+        sage: H.orbits()
+        [[(0, 0)], [(1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]]
+        sage: H.gens()
+        [((0,1),(1,1),(2,1))((0,2),(2,2),(1,2)),
+         ((1,0),(0,2),(2,0),(0,1))((1,1),(1,2),(2,2),(2,1))]
+
+    The orbits of the conjugation action are the conjugacy classes,
+    i.e., in bijection with integer partitions::
+
+        sage: a = lambda g, x: g*x*g^-1
+        sage: [len(PermutationGroup(SymmetricGroup(n).gens(), action=a, domain=SymmetricGroup(n)).orbits()) for n in range(1, 8)]
+        [1, 2, 3, 5, 7, 11, 15]
+
     TESTS::
 
         sage: r = Permutation("(1,7,9,3)(2,4,8,6)")
@@ -350,6 +383,7 @@ def PermutationGroup(gens=None, *args, **kwds):
         ...
         DeprecationWarning: gap_group, domain, canonicalize, category will become keyword only
         See https://trac.sagemath.org/31510 for details.
+
     """
     if not is_ExpectElement(gens) and hasattr(gens, '_permgroup_'):
         return gens._permgroup_()
@@ -359,6 +393,11 @@ def PermutationGroup(gens=None, *args, **kwds):
     domain = kwds.get("domain", None)
     canonicalize = kwds.get("canonicalize", True)
     category = kwds.get("category", None)
+    action = kwds.get("action", None)
+    if action is not None:
+        if domain is None:
+            raise ValueError("you must specify the domain for an action")
+        return PermutationGroup_action(gens, action, domain, gap_group=gap_group)
     if args:
         from sage.misc.superseded import deprecation
         deprecation(31510, "gap_group, domain, canonicalize, category will become keyword only")
@@ -1299,7 +1338,7 @@ class PermutationGroup_generic(FiniteGroup):
         EXAMPLES::
 
             sage: G = PermutationGroup([[(1,2,3),(4,5)]])
-            sage: e = G.identity()
+            sage: e = G.identity()                                              # indirect doctest
             sage: e
             ()
             sage: g = G.gen(0)
@@ -4989,5 +5028,109 @@ class PermutationGroup_subgroup(PermutationGroup_generic):
 # Allow for subclasses to use a different subgroup class
 PermutationGroup_generic.Subgroup = PermutationGroup_subgroup
 
+class PermutationGroup_action(PermutationGroup_generic):
+    """
+    A permutation group given by a finite group action.
+
+    EXAMPLES:
+
+    A cyclic action::
+
+        sage: n = 3
+        sage: a = lambda x: SetPartition([[e % n + 1 for e in b] for b in x])
+        sage: S = SetPartitions(n)
+        sage: G = PermutationGroup(action=a, domain=S)
+        sage: G.orbits()
+        [[{{1}, {2}, {3}}],
+         [{{1, 2}, {3}}, {{1}, {2, 3}}, {{1, 3}, {2}}],
+         [{{1, 2, 3}}]]
+
+    The regular action of the symmetric group::
+
+        sage: a = lambda g, x: g*x*g^-1
+        sage: S = SymmetricGroup(3)
+        sage: G = PermutationGroup(S.gens(), action=a, domain=S)
+        sage: G.orbits()
+        [[()], [(1,3,2), (1,2,3)], [(2,3), (1,3), (1,2)]]
+
+    The trivial action of the symmetric group::
+
+        sage: PermutationGroup(SymmetricGroup(3).gens(), action=lambda g, x: x, domain=[1])
+        Permutation Group with generators [()]
+    """
+    def __init__(self, gens, action, domain, gap_group=None, category=None, canonicalize=None):
+        """
+        Initialize ``self``.
+
+        INPUT:
+
+        - ``gens`` -- list of generators of the group or ``None`` if the action is cyclic
+
+        - ``action`` -- a group action `G \times X\to X` if ``gens``
+          is given, or a cyclic group action `X\to X` if ``gens`` is
+          ``None``
+
+        - ``domain`` -- the set the group is acting on
+
+        - ``gap_group`` -- a gap or libgap permutation group, or a string
+          defining one (default: ``None``), this is currently not supported
+
+        - ``canonicalize`` -- bool (default: ``True``); if ``True``,
+          sort generators and remove duplicates
+
+        OUTPUT:
+
+        - A finite group action given as a permutation group.
+
+        EXAMPLES::
+
+            sage: a = lambda x: (2*x) % 7
+            sage: G = PermutationGroup(action=a, domain=range(7))
+            sage: G.orbits()
+            [[0], [1, 2, 4], [3, 6, 5]]
+
+        """
+        from sage.combinat.cyclic_sieving_phenomenon import orbit_decomposition
+        from sage.sets.disjoint_set import DisjointSet
+        if gap_group is not None:
+            raise ValueError("gap_group is not supported with action")
+        if gens is None:
+            self._orbits = orbit_decomposition(domain, action)
+            gens = [tuple(o) for o in self._orbits if len(o) > 1]
+        else:
+            g_orbits = [orbit_decomposition(domain, lambda x: action(g, x))
+                        for g in gens]
+            gens = []
+            for g_orbit in g_orbits:
+                g_gens = [tuple(o) for o in g_orbit if len(o) > 1]
+                if g_gens:
+                    gens.append(g_gens)
+
+            D = DisjointSet(domain)
+            for g_orbit in g_orbits:
+                for o in g_orbit:
+                    for i in range(1, len(o)):
+                        D.union(o[0], o[i])
+            self._orbits = list(D)
+
+        PermutationGroup_generic.__init__(self, gens=gens,
+                                          gap_group=gap_group, domain=domain,
+                                          category=category,
+                                          canonicalize=canonicalize)
+
+    def orbits(self):
+        """
+        Returns the orbits of the elements of the domain under the
+        default group action.
+
+        EXAMPLES::
+
+            sage: a = lambda x: (2*x) % 7
+            sage: G = PermutationGroup(action=a, domain=range(7))
+            sage: G.orbits()
+            [[0], [1, 2, 4], [3, 6, 5]]
+        """
+        return self._orbits
+
 from sage.misc.rest_index_of_methods import gen_rest_table_index
 __doc__ = __doc__.format(METHODS_OF_PermutationGroup_generic=gen_rest_table_index(PermutationGroup_generic))
```



---

Comment by wdj created at 2022-05-06 19:29:21

If that's the only part needing review, then it looks good to me!


---

Comment by mantepse created at 2022-05-08 18:26:20

If so, please click on "modify ticket", enter your name into the "Reviewers" field and select "positive review".

Thank you so much!


---

Comment by wdj created at 2022-05-08 19:20:45

Changing status from needs_review to positive_review.


---

Comment by wdj created at 2022-05-08 19:21:11

Replying to [comment:24 mantepse]:
> If so, please click on "modify ticket", enter your name into the "Reviewers" field and select "positive review".
> 
> Thank you so much!

Done.


---

Comment by tscrim created at 2022-05-09 04:44:32

Changing status from positive_review to needs_work.


---

Comment by tscrim created at 2022-05-09 04:44:32

A few little things:

- `orbits()` should not return a mutable object since it is the cached object. The cached result is better as a tuple of tuples IMO. Otherwise `orbits()` needs to make a deep copy.
- `Returns` -> `Return` in `orbits()`.
- Real name for the reviewer.
- It might be good to be explicit and say this is a left action.

Perhaps not such a little thing, and while it isn't necessary for a positive review, it might be good to do now:

I believe a more efficient way to compute the action for a non-cyclic group is to directly manipulate the orbits constructed for one generator rather than building the orbits for all generators and splicing them together. This requires less memory and should at most use the same number of operations. As a bit of an extreme case, take a large product of copies of the trivial group (or `Z/2Z`) acting on a large set.


---

Comment by mantepse created at 2022-05-09 07:33:18

Thank you Travis for joining, I was hoping for you!

Replying to [comment:27 tscrim]:

> - `orbits()` should not return a mutable object since it is the cached object. The cached result is better as a tuple of tuples IMO. Otherwise `orbits()` needs to make a deep copy.

I noticed this too.  The problem I had is that `PermutationGroup_generic.orbits` has the the same problem:

```
sage: G = PermutationGroup([ [(3,4)], [(1,3)] ])
sage: O = G.orbits(); O
[[1, 3, 4], [2]]
sage: O[0] = 1
sage: G.orbits()
[1, [2]]
```


I think it is important that the two methods do the same thing.  Because of your next item,

> - `Returns` -> `Return` in `orbits()`.

I decided to open a new ticket to change the behaviour of `PermutationGroup_generic.orbits` first, and fix the "Returns".

> - It might be good to be explicit and say this is a left action.

Done (in the INPUT section).

> Perhaps not such a little thing, and while it isn't necessary for a positive review, it might be good to do now:
> 
> I believe a more efficient way to compute the action for a non-cyclic group is to directly manipulate the orbits constructed for one generator rather than building the orbits for all generators and splicing them together. This requires less memory and should at most use the same number of operations. As a bit of an extreme case, take a large product of copies of the trivial group (or `Z/2Z`) acting on a large set.

I'll think about this, but I'll first open the other ticket.


---

Comment by mantepse created at 2022-05-09 14:55:30

Replying to [comment:28 mantepse]:
> I believe a more efficient way to compute the action for a non-cyclic group is to directly manipulate the orbits constructed for one generator rather than building the orbits for all generators and splicing them together. This requires less memory and should at most use the same number of operations. As a bit of an extreme case, take a large product of copies of the trivial group (or `Z/2Z`) acting on a large set.

I now realise that it is unclear to me what you have in mind.  Let's say that `G` is generated by `g` and `h`.  We compute `g_orbit = orbit_decomposition(domain, lambda x: action(g, x))`.  I also need the generators corresponding to the homomorphic image of `h`, which is `orbit_decomposition(domain, lambda x: action(h, x))`, I don't see how I could avoid that.  I could apply `h*g^-1` to each element in `g_orbit`, but I don't see how this would avoid computations.

Help appreciated!


---

Comment by tscrim created at 2022-05-10 02:38:32

Replying to [comment:31 mantepse]:
> Replying to [comment:28 mantepse]:
> > I believe a more efficient way to compute the action for a non-cyclic group is to directly manipulate the orbits constructed for one generator rather than building the orbits for all generators and splicing them together. This requires less memory and should at most use the same number of operations. As a bit of an extreme case, take a large product of copies of the trivial group (or `Z/2Z`) acting on a large set.
> 
> I now realise that it is unclear to me what you have in mind.  Let's say that `G` is generated by `g` and `h`.  We compute `g_orbit = orbit_decomposition(domain, lambda x: action(g, x))`.  I also need the generators corresponding to the homomorphic image of `h`, which is `orbit_decomposition(domain, lambda x: action(h, x))`, I don't see how I could avoid that.  I could apply `h*g^-1` to each element in `g_orbit`, but I don't see how this would avoid computations.

You compute `orbit_decomposition()` for `g`, and then you just apply `h` to each element in each orbit. If it goes to a different orbit, then you merge the two. You can stop early once you have one orbit too. I don’t think there is a way to shortcut acting on each element by each generator (at least without knowing some structure of the group). However, you do not need to hold all of the orbits for each element (i.e., also for `h` in your example) simultaneously. I don’t see why you also need to apply `g^-1`.


---

Comment by git created at 2022-05-10 10:04:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2022-05-10 10:39:59

Replying to [comment:32 tscrim]:

Thank you for explaining!
> You compute orbit_decomposition() for g, and then you just apply h to each element in each orbit. If it goes to a different orbit, then you merge the two. You can stop early once you have one orbit too. I don’t think there is a way to shortcut acting on each element by each generator (at least without knowing some structure of the group). However, you do not need to hold all of the orbits for each element (i.e., also for h in your example) simultaneously. I don’t see why you also need to apply g^-1. 

I still don't get it (and I made a mistake myself).  Suppose the generator corresponding to `g` is

```
(x1, g x1, g^2 x1, ...) (x2, g x2, g^2 x2, ...)...
```

Then applying `h` to each element of the first orbit I obtain

```
(h x1, h g x1, h g^2 x1, ...)
```

but this is not a cycle of a generator of the homomorphic image, is it?


---

Comment by tscrim created at 2022-05-10 10:58:12

Ah, I think I have misunderstood what you mean by orbits. I was thinking of G-orbits for the whole group, but to define the permutation group, you need the orbits of each generator. Thus, you need to hold all of this information, which is more than you need for the G-orbits.


---

Comment by mantepse created at 2022-05-10 11:45:25

Changing status from needs_work to needs_review.


---

Comment by mantepse created at 2022-05-10 11:45:25

Indeed.  In principle I only need the generators, but I think it makes sense to compute the orbits of the group action, right away instead of asking gap to do it.

For cyclic actions, the orbits are what I'm after, in fact.


---

Comment by tscrim created at 2022-05-10 23:50:05

Thank you. Then back to a positive review.


---

Comment by tscrim created at 2022-05-10 23:50:05

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-05-24 22:45:04

Resolution: fixed
