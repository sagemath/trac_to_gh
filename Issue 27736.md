# Issue 27736: Implement wedge over a face of Polyhedron

archive/issues_027736.json:
```json
{
    "body": "CC:  @jplab @laisrast @kliem\n\nKeywords: polytopes,\n\nFrom \u200b\u200bhttps://www.csun.edu/~ctoth/Handbook/chap15.pdf:\n\nThe wedge over a facet `F` of a polytope `P` is defined as the product:\n\n`P \\times \\mathbb{R}\\cap \\{a^\\top x +|x_{d+1} \\leq b|\\}`\n\nwhere `F` is a facet defined by `a^\\top x leq b`.\n\nIt  has  dimension `d+1`, `m+1` facets, and `2n-n_F` vertices, if `F` has `n_F` vertices. More generally,  the wedge construction can be performed (defined by the same formula) for a face `F`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/27973\n\n",
    "created_at": "2019-06-12T08:19:03Z",
    "labels": [
        "component: geometry"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.9",
    "title": "Implement wedge over a face of Polyhedron",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27736",
    "user": "https://github.com/jplab"
}
```
CC:  @jplab @laisrast @kliem

Keywords: polytopes,

From ​​https://www.csun.edu/~ctoth/Handbook/chap15.pdf:

The wedge over a facet `F` of a polytope `P` is defined as the product:

`P \times \mathbb{R}\cap \{a^\top x +|x_{d+1} \leq b|\}`

where `F` is a facet defined by `a^\top x leq b`.

It  has  dimension `d+1`, `m+1` facets, and `2n-n_F` vertices, if `F` has `n_F` vertices. More generally,  the wedge construction can be performed (defined by the same formula) for a face `F`.

Issue created by migration from https://trac.sagemath.org/ticket/27973





---

archive/issue_comments_391372.json:
```json
{
    "body": "As the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).",
    "created_at": "2019-06-14T14:55:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391372",
    "user": "https://github.com/embray"
}
```

As the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).



---

archive/issue_comments_391373.json:
```json
{
    "body": "Changing keywords from \"polytopes,\" to \"polytopes, days100\".",
    "created_at": "2019-07-22T16:40:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391373",
    "user": "https://github.com/jplab"
}
```

Changing keywords from "polytopes," to "polytopes, days100".



---

archive/issue_comments_391374.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2019-07-23T13:49:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391374",
    "user": "https://github.com/LaisRast"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_391375.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-07-23T13:49:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391375",
    "user": "https://github.com/LaisRast"
}
```

New commits:



---

archive/issue_comments_391376.json:
```json
{
    "body": "Changing keywords from \"polytopes, days100\" to \"polytopes, days100, wedge, facet\".",
    "created_at": "2019-07-23T13:49:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391376",
    "user": "https://github.com/LaisRast"
}
```

Changing keywords from "polytopes, days100" to "polytopes, days100, wedge, facet".



---

archive/issue_comments_391377.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2019-07-23T13:51:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391377",
    "user": "https://github.com/LaisRast"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_391378.json:
```json
{
    "body": "Hi,\n\n* In the docstring, it usually starts with 1 sentence, and empty line and then further information about the method.\n\n* I would say that the width is a \"indication of how wide the wedge is taken around the face\". Said the current way, it makes it confusing about other potential notions around polytopes (lattice polytopes have widths...) So I would say: \"indication of how wide the resulted wedge should be\".\n\n* The doctests are not using the function as a method. \n\n* Replace the backtick by single quotes in the error messages.\n\n* `L = Polyhedron(rays=[[1],[-1]])` could be `Polyhedron(lines=[This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))`\n\n* I would write `F_Hrep = list(F_Hrep)` after the for loop and replace in the creation of the polytope.\n\n* It would be good to test and show in examples combinatorial isomorphism type with a known polytope which is a wedge. For example the prism over a triangle is a wedge over a triangle. And the duals to cyclic 3-polytopes are wedges.",
    "created_at": "2019-07-23T14:23:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391378",
    "user": "https://github.com/jplab"
}
```

Hi,

* In the docstring, it usually starts with 1 sentence, and empty line and then further information about the method.

* I would say that the width is a "indication of how wide the wedge is taken around the face". Said the current way, it makes it confusing about other potential notions around polytopes (lattice polytopes have widths...) So I would say: "indication of how wide the resulted wedge should be".

* The doctests are not using the function as a method. 

* Replace the backtick by single quotes in the error messages.

* `L = Polyhedron(rays=[[1],[-1]])` could be `Polyhedron(lines=[This is the Trac macro *1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1-macro))`

* I would write `F_Hrep = list(F_Hrep)` after the for loop and replace in the creation of the polytope.

* It would be good to test and show in examples combinatorial isomorphism type with a known polytope which is a wedge. For example the prism over a triangle is a wedge over a triangle. And the duals to cyclic 3-polytopes are wedges.



---

archive/issue_comments_391379.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-07-23T14:23:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391379",
    "user": "https://github.com/jplab"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_391380.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-23T15:07:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391380",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_391381.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-07-23T15:09:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391381",
    "user": "https://github.com/LaisRast"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_391382.json:
```json
{
    "body": "Replying to [comment:7 jipilab]:\n\nThanks. Done.",
    "created_at": "2019-07-23T15:09:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391382",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:7 jipilab]:

Thanks. Done.



---

archive/issue_comments_391383.json:
```json
{
    "body": "Seems like there are tab character in reference/index.rst There seems to be many errors in the bot too...",
    "created_at": "2019-07-23T20:29:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391383",
    "user": "https://github.com/jplab"
}
```

Seems like there are tab character in reference/index.rst There seems to be many errors in the bot too...



---

archive/issue_comments_391384.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-24T08:09:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391384",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_391385.json:
```json
{
    "body": "The description of the ticket is still only about facets.",
    "created_at": "2019-07-24T08:46:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391385",
    "user": "https://github.com/kliem"
}
```

The description of the ticket is still only about facets.



---

archive/issue_comments_391386.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-07-24T08:54:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391386",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_391387.json:
```json
{
    "body": "Please preserve the backend and base ring as in #27926.",
    "created_at": "2019-07-24T08:54:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391387",
    "user": "https://github.com/kliem"
}
```

Please preserve the backend and base ring as in #27926.



---

archive/issue_comments_391388.json:
```json
{
    "body": "Actually, I think the backend might be preserved. (product and intersection might behave this way).\n\nCan you please check. Maybe add a doctest.\n\nHowever, in the intermediate steps you don't preserve the backend. This might cause issues with algebraic polyhedra.",
    "created_at": "2019-07-24T09:31:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391388",
    "user": "https://github.com/kliem"
}
```

Actually, I think the backend might be preserved. (product and intersection might behave this way).

Can you please check. Maybe add a doctest.

However, in the intermediate steps you don't preserve the backend. This might cause issues with algebraic polyhedra.



---

archive/issue_comments_391389.json:
```json
{
    "body": "Replying to [comment:12 gh-kliem]:\n> The description of the ticket is still only about facets.\n\n\nNope. See last sentence of the description.",
    "created_at": "2019-07-24T10:28:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391389",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:12 gh-kliem]:
> The description of the ticket is still only about facets.


Nope. See last sentence of the description.



---

archive/issue_comments_391390.json:
```json
{
    "body": "Replying to [comment:14 gh-kliem]:\n> Actually, I think the backend might be preserved. (product and intersection might behave this way).\n> \n> Can you please check. Maybe add a doctest.\n> \n> However, in the intermediate steps you don't preserve the backend. This might cause issues with algebraic polyhedra.\n\n\nThe backend and the basering are preserved as long as the value of `width` belongs to the basering of `self`. This is the case when `width` takes the default value. Otherwise, we have the following behavior\n\n```\nsage: P = polytopes.cyclic_polytope(3,7); P\nA 3-dimensional polyhedron in QQ^3 defined as the convex hull of 7 vertices\nsage: P.backend()\n'ppl'\nsage: P.wedge(P.faces(2)[0]).backend()\n'ppl'\nsage: P.wedge(P.faces(2)[0]).base_ring()\nRational Field\nsage: P.wedge(P.faces(2)[0], width=RDF(1)).backend()\ncdd\nsage: P.wedge(P.faces(2)[0], width=RDF(1)).base_ring()\nReal Double Field\n```\nwhich I think is an acceptable behavior.",
    "created_at": "2019-07-24T13:32:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391390",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:14 gh-kliem]:
> Actually, I think the backend might be preserved. (product and intersection might behave this way).
> 
> Can you please check. Maybe add a doctest.
> 
> However, in the intermediate steps you don't preserve the backend. This might cause issues with algebraic polyhedra.


The backend and the basering are preserved as long as the value of `width` belongs to the basering of `self`. This is the case when `width` takes the default value. Otherwise, we have the following behavior

```
sage: P = polytopes.cyclic_polytope(3,7); P
A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 7 vertices
sage: P.backend()
'ppl'
sage: P.wedge(P.faces(2)[0]).backend()
'ppl'
sage: P.wedge(P.faces(2)[0]).base_ring()
Rational Field
sage: P.wedge(P.faces(2)[0], width=RDF(1)).backend()
cdd
sage: P.wedge(P.faces(2)[0], width=RDF(1)).base_ring()
Real Double Field
```
which I think is an acceptable behavior.



---

archive/issue_comments_391391.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-24T13:46:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391391",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_391392.json:
```json
{
    "body": "The examples you gave are not meaningful. ppl and cdd are the standard backends for the given ring.\n\nWhat about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).\n\nWhat about the examples of #25097. Do they work?\n\n(Sorry, still can't test it myself).\n\nReplying to [comment:16 gh-LaisRast]:\n> Replying to [comment:14 gh-kliem]:\n> > Actually, I think the backend might be preserved. (product and intersection might behave this way).\n> > \n> > Can you please check. Maybe add a doctest.\n> > \n> > However, in the intermediate steps you don't preserve the backend. This might cause issues with algebraic polyhedra.\n\n> \n> The backend and the basering are preserved as long as the value of `width` belongs to the basering of `self`. This is the case when `width` takes the default value. Otherwise, we have the following behavior\n> \n> ```\n> sage: P = polytopes.cyclic_polytope(3,7); P\n> A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 7 vertices\n> sage: P.backend()\n> 'ppl'\n> sage: P.wedge(P.faces(2)[0]).backend()\n> 'ppl'\n> sage: P.wedge(P.faces(2)[0]).base_ring()\n> Rational Field\n> sage: P.wedge(P.faces(2)[0], width=RDF(1)).backend()\n> cdd\n> sage: P.wedge(P.faces(2)[0], width=RDF(1)).base_ring()\n> Real Double Field\n> ```\n> which I think is an acceptable behavior.",
    "created_at": "2019-07-24T14:21:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391392",
    "user": "https://github.com/kliem"
}
```

The examples you gave are not meaningful. ppl and cdd are the standard backends for the given ring.

What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).

What about the examples of #25097. Do they work?

(Sorry, still can't test it myself).

Replying to [comment:16 gh-LaisRast]:
> Replying to [comment:14 gh-kliem]:
> > Actually, I think the backend might be preserved. (product and intersection might behave this way).
> > 
> > Can you please check. Maybe add a doctest.
> > 
> > However, in the intermediate steps you don't preserve the backend. This might cause issues with algebraic polyhedra.

> 
> The backend and the basering are preserved as long as the value of `width` belongs to the basering of `self`. This is the case when `width` takes the default value. Otherwise, we have the following behavior
> 
> ```
> sage: P = polytopes.cyclic_polytope(3,7); P
> A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 7 vertices
> sage: P.backend()
> 'ppl'
> sage: P.wedge(P.faces(2)[0]).backend()
> 'ppl'
> sage: P.wedge(P.faces(2)[0]).base_ring()
> Rational Field
> sage: P.wedge(P.faces(2)[0], width=RDF(1)).backend()
> cdd
> sage: P.wedge(P.faces(2)[0], width=RDF(1)).base_ring()
> Real Double Field
> ```
> which I think is an acceptable behavior.



---

archive/issue_comments_391393.json:
```json
{
    "body": "Replying to [comment:18 gh-kliem]:\n> What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).\n> \n> What about the examples of #25097. Do they work?\n> \n> (Sorry, still can't test it myself).\n> \n\n\nThe polyhedron `H` is the responsible for changing the base ring and the backend. The following should fix the problem (up to change of base ring form ZZ to QQ, see `W2` below):\n\n```diff\n-    def wedge(self, face, width=1):\n+    def wedge(self, face, width=None):\n         r\"\"\"\n         Return the wedge over a ``face`` of the polytope ``self``.\n\n@@ -4205,6 +4205,10 @@ class Polyhedron_base(Element):\n             sage: P.wedge(P.faces(2)[0], width=RDF(1)).base_ring()\n             Real Double Field\n         \"\"\"\n+        if width is None:\n+            width = ZZ.one()\n+\n         if not self.is_compact():\n             raise ValueError(\"polyhedron 'self' must be a polytope\")\n\n@@ -4223,7 +4227,11 @@ class Polyhedron_base(Element):\n\n         L = Polyhedron(lines=[[1]])\n         Q = self.product(L)\n-        H = Polyhedron(ieqs=[F_Hrep + [width], F_Hrep + [-width]])\n+\n+        parent = self.parent().base_extend(width, ambient_dim=self.ambient_dim()+1)\n+        ieqs = [F_Hrep + [width], F_Hrep + [-width]]\n+        H = parent.element_class(parent, None, [ieqs, None])\n         return Q.intersection(H)\n\n```\n\nSome examples:\n\n```\nsage: P = polytopes.cyclic_polytope(3,7, base_ring=ZZ, backend='normaliz')\nsage: W1 = P.wedge(P.faces(2)[0]); W1.base_ring(); W1.backend()\nInteger Ring\n'normaliz'\nsage: W2 = P.wedge(P.faces(2)[0], width=5/2); W2.base_ring(); W2.backend()\nRational Field\n'normaliz'\nsage: W2 = P.wedge(P.faces(2)[0], width=4/2); W2.base_ring(); W2.backend()\nRational Field\n'normaliz'\nsage: W2.vertices()\n(A vertex at (0, 0, 0, 0),\n A vertex at (1, 1, 1, 0),\n A vertex at (2, 4, 8, 0),\n A vertex at (3, 9, 27, -3),\n A vertex at (3, 9, 27, 3),\n A vertex at (4, 16, 64, -12),\n A vertex at (4, 16, 64, 12),\n A vertex at (5, 25, 125, -30),\n A vertex at (5, 25, 125, 30),\n A vertex at (6, 36, 216, -60),\n A vertex at (6, 36, 216, 60))\n```\n\n`W2` has vertices with integer coordinates",
    "created_at": "2019-07-24T15:28:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391393",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:18 gh-kliem]:
> What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).
> 
> What about the examples of #25097. Do they work?
> 
> (Sorry, still can't test it myself).
> 


The polyhedron `H` is the responsible for changing the base ring and the backend. The following should fix the problem (up to change of base ring form ZZ to QQ, see `W2` below):

```diff
-    def wedge(self, face, width=1):
+    def wedge(self, face, width=None):
         r"""
         Return the wedge over a ``face`` of the polytope ``self``.

@@ -4205,6 +4205,10 @@ class Polyhedron_base(Element):
             sage: P.wedge(P.faces(2)[0], width=RDF(1)).base_ring()
             Real Double Field
         """
+        if width is None:
+            width = ZZ.one()
+
         if not self.is_compact():
             raise ValueError("polyhedron 'self' must be a polytope")

@@ -4223,7 +4227,11 @@ class Polyhedron_base(Element):

         L = Polyhedron(lines=[[1]])
         Q = self.product(L)
-        H = Polyhedron(ieqs=[F_Hrep + [width], F_Hrep + [-width]])
+
+        parent = self.parent().base_extend(width, ambient_dim=self.ambient_dim()+1)
+        ieqs = [F_Hrep + [width], F_Hrep + [-width]]
+        H = parent.element_class(parent, None, [ieqs, None])
         return Q.intersection(H)

```

Some examples:

```
sage: P = polytopes.cyclic_polytope(3,7, base_ring=ZZ, backend='normaliz')
sage: W1 = P.wedge(P.faces(2)[0]); W1.base_ring(); W1.backend()
Integer Ring
'normaliz'
sage: W2 = P.wedge(P.faces(2)[0], width=5/2); W2.base_ring(); W2.backend()
Rational Field
'normaliz'
sage: W2 = P.wedge(P.faces(2)[0], width=4/2); W2.base_ring(); W2.backend()
Rational Field
'normaliz'
sage: W2.vertices()
(A vertex at (0, 0, 0, 0),
 A vertex at (1, 1, 1, 0),
 A vertex at (2, 4, 8, 0),
 A vertex at (3, 9, 27, -3),
 A vertex at (3, 9, 27, 3),
 A vertex at (4, 16, 64, -12),
 A vertex at (4, 16, 64, 12),
 A vertex at (5, 25, 125, -30),
 A vertex at (5, 25, 125, 30),
 A vertex at (6, 36, 216, -60),
 A vertex at (6, 36, 216, 60))
```

`W2` has vertices with integer coordinates



---

archive/issue_comments_391394.json:
```json
{
    "body": "Is this `ZZ.one()` really needed? Base extend should work recognize `1` as well.\n\nCan you add `base_ring=self.base_ring()` and same for backend to initialization of L. (Setting up the correct base ring right away, avoids coercion for the product to my understanding.)\n\nReplying to [comment:19 gh-LaisRast]:\n> Replying to [comment:18 gh-kliem]:\n> > What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).\n> > \n> > What about the examples of #25097. Do they work?\n> > \n> > (Sorry, still can't test it myself).\n> > \n\n> \n> The polyhedron `H` is the responsible for changing the base ring and the backend. The following should fix the problem (up to change of base ring form ZZ to QQ, see `W2` below):\n> \n> \n> ```\n> #!diff\n> -    def wedge(self, face, width=1):\n> +    def wedge(self, face, width=None):\n>          r\"\"\"\n>          Return the wedge over a ``face`` of the polytope ``self``.\n> \n> @@ -4205,6 +4205,10 @@ class Polyhedron_base(Element):\n>              sage: P.wedge(P.faces(2)[0], width=RDF(1)).base_ring()\n>              Real Double Field\n>          \"\"\"\n> +        if width is None:\n> +            width = ZZ.one()\n> +\n>          if not self.is_compact():\n>              raise ValueError(\"polyhedron 'self' must be a polytope\")\n> \n> @@ -4223,7 +4227,11 @@ class Polyhedron_base(Element):\n> \n>          L = Polyhedron(lines=[[1]])\n>          Q = self.product(L)\n> -        H = Polyhedron(ieqs=[F_Hrep + [width], F_Hrep + [-width]])\n> +\n> +        parent = self.parent().base_extend(width, ambient_dim=self.ambient_dim()+1)\n> +        ieqs = [F_Hrep + [width], F_Hrep + [-width]]\n> +        H = parent.element_class(parent, None, [ieqs, None])\n>          return Q.intersection(H)\n> \n> ```\n> \n> Some examples:\n> \n> ```\n> sage: P = polytopes.cyclic_polytope(3,7, base_ring=ZZ, backend='normaliz')\n> sage: W1 = P.wedge(P.faces(2)[0]); W1.base_ring(); W1.backend()\n> Integer Ring\n> 'normaliz'\n> sage: W2 = P.wedge(P.faces(2)[0], width=5/2); W2.base_ring(); W2.backend()\n> Rational Field\n> 'normaliz'\n> sage: W2 = P.wedge(P.faces(2)[0], width=4/2); W2.base_ring(); W2.backend()\n> Rational Field\n> 'normaliz'\n> sage: W2.vertices()\n> (A vertex at (0, 0, 0, 0),\n>  A vertex at (1, 1, 1, 0),\n>  A vertex at (2, 4, 8, 0),\n>  A vertex at (3, 9, 27, -3),\n>  A vertex at (3, 9, 27, 3),\n>  A vertex at (4, 16, 64, -12),\n>  A vertex at (4, 16, 64, 12),\n>  A vertex at (5, 25, 125, -30),\n>  A vertex at (5, 25, 125, 30),\n>  A vertex at (6, 36, 216, -60),\n>  A vertex at (6, 36, 216, 60))\n> ```\n> \n> `W2` has vertices with integer coordinates",
    "created_at": "2019-07-24T21:59:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391394",
    "user": "https://github.com/kliem"
}
```

Is this `ZZ.one()` really needed? Base extend should work recognize `1` as well.

Can you add `base_ring=self.base_ring()` and same for backend to initialization of L. (Setting up the correct base ring right away, avoids coercion for the product to my understanding.)

Replying to [comment:19 gh-LaisRast]:
> Replying to [comment:18 gh-kliem]:
> > What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).
> > 
> > What about the examples of #25097. Do they work?
> > 
> > (Sorry, still can't test it myself).
> > 

> 
> The polyhedron `H` is the responsible for changing the base ring and the backend. The following should fix the problem (up to change of base ring form ZZ to QQ, see `W2` below):
> 
> 
> ```
> #!diff
> -    def wedge(self, face, width=1):
> +    def wedge(self, face, width=None):
>          r"""
>          Return the wedge over a ``face`` of the polytope ``self``.
> 
> @@ -4205,6 +4205,10 @@ class Polyhedron_base(Element):
>              sage: P.wedge(P.faces(2)[0], width=RDF(1)).base_ring()
>              Real Double Field
>          """
> +        if width is None:
> +            width = ZZ.one()
> +
>          if not self.is_compact():
>              raise ValueError("polyhedron 'self' must be a polytope")
> 
> @@ -4223,7 +4227,11 @@ class Polyhedron_base(Element):
> 
>          L = Polyhedron(lines=[[1]])
>          Q = self.product(L)
> -        H = Polyhedron(ieqs=[F_Hrep + [width], F_Hrep + [-width]])
> +
> +        parent = self.parent().base_extend(width, ambient_dim=self.ambient_dim()+1)
> +        ieqs = [F_Hrep + [width], F_Hrep + [-width]]
> +        H = parent.element_class(parent, None, [ieqs, None])
>          return Q.intersection(H)
> 
> ```
> 
> Some examples:
> 
> ```
> sage: P = polytopes.cyclic_polytope(3,7, base_ring=ZZ, backend='normaliz')
> sage: W1 = P.wedge(P.faces(2)[0]); W1.base_ring(); W1.backend()
> Integer Ring
> 'normaliz'
> sage: W2 = P.wedge(P.faces(2)[0], width=5/2); W2.base_ring(); W2.backend()
> Rational Field
> 'normaliz'
> sage: W2 = P.wedge(P.faces(2)[0], width=4/2); W2.base_ring(); W2.backend()
> Rational Field
> 'normaliz'
> sage: W2.vertices()
> (A vertex at (0, 0, 0, 0),
>  A vertex at (1, 1, 1, 0),
>  A vertex at (2, 4, 8, 0),
>  A vertex at (3, 9, 27, -3),
>  A vertex at (3, 9, 27, 3),
>  A vertex at (4, 16, 64, -12),
>  A vertex at (4, 16, 64, 12),
>  A vertex at (5, 25, 125, -30),
>  A vertex at (5, 25, 125, 30),
>  A vertex at (6, 36, 216, -60),
>  A vertex at (6, 36, 216, 60))
> ```
> 
> `W2` has vertices with integer coordinates



---

archive/issue_comments_391395.json:
```json
{
    "body": "Replying to [comment:18 gh-kliem]:\n> What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).\n\n\nA note: in Sage `4/2` is rational:\n\n```\nsage: type(4/2)\n<class 'sage.rings.rational.Rational'>\n```\n\nand it should be like that, not to create nightmares.\n\nHence, taking `width=4/2`, the expected behavior is *really* to change the base ring to rational numbers.\n\nIn Sage dividing two `Integers` yields an element in the FractionField, i.e. the rationals. It is the users responsibility to know these things. Just like `2.0` is not an integer.\n\nThat said, it is completely fine to have `base_ring=QQ` but integral vertices. The goal of base ring is not to steadily represent the smallest ring in which the vertices lay in.",
    "created_at": "2019-07-25T07:18:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391395",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:18 gh-kliem]:
> What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).


A note: in Sage `4/2` is rational:

```
sage: type(4/2)
<class 'sage.rings.rational.Rational'>
```

and it should be like that, not to create nightmares.

Hence, taking `width=4/2`, the expected behavior is *really* to change the base ring to rational numbers.

In Sage dividing two `Integers` yields an element in the FractionField, i.e. the rationals. It is the users responsibility to know these things. Just like `2.0` is not an integer.

That said, it is completely fine to have `base_ring=QQ` but integral vertices. The goal of base ring is not to steadily represent the smallest ring in which the vertices lay in.



---

archive/issue_comments_391396.json:
```json
{
    "body": "I was aware of `4/2` being rational.\nI just find it awful to change the backend when you enter rational width.\nThe backend should never change unintentionally unless necessary (so if you enter `width=2.0` the backend will change to cdd, which I would consider the expected behavior.)\n\nIt's just annoying when you want to use `normaliz` and every operation ignores your preference and you have to change backend over and over (and even worse calculations might take longer time with `ppl`, which you decided not to use in the first place).\n\nReplying to [comment:21 jipilab]:\n> Replying to [comment:18 gh-kliem]:\n> > What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).\n\n> \n> A note: in Sage `4/2` is rational:\n> \n> \n> sage: type(4/2)\n> <class 'sage.rings.rational.Rational'>\n> }}}\n> \n> and it should be like that, not to create nightmares.\n> \n> Hence, taking `width=4/2`, the expected behavior is *really* to change the base ring to rational numbers.\n> \n> In Sage dividing two `Integers` yields an element in the FractionField, i.e. the rationals. It is the users responsibility to know these things. Just like `2.0` is not an integer.\n> \n> That said, it is completely fine to have `base_ring=QQ` but integral vertices. The goal of base ring is not to steadily represent the smallest ring in which the vertices lay in.",
    "created_at": "2019-07-25T07:58:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391396",
    "user": "https://github.com/kliem"
}
```

I was aware of `4/2` being rational.
I just find it awful to change the backend when you enter rational width.
The backend should never change unintentionally unless necessary (so if you enter `width=2.0` the backend will change to cdd, which I would consider the expected behavior.)

It's just annoying when you want to use `normaliz` and every operation ignores your preference and you have to change backend over and over (and even worse calculations might take longer time with `ppl`, which you decided not to use in the first place).

Replying to [comment:21 jipilab]:
> Replying to [comment:18 gh-kliem]:
> > What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).

> 
> A note: in Sage `4/2` is rational:
> 
> 
> sage: type(4/2)
> <class 'sage.rings.rational.Rational'>
> }}}
> 
> and it should be like that, not to create nightmares.
> 
> Hence, taking `width=4/2`, the expected behavior is *really* to change the base ring to rational numbers.
> 
> In Sage dividing two `Integers` yields an element in the FractionField, i.e. the rationals. It is the users responsibility to know these things. Just like `2.0` is not an integer.
> 
> That said, it is completely fine to have `base_ring=QQ` but integral vertices. The goal of base ring is not to steadily represent the smallest ring in which the vertices lay in.



---

archive/issue_comments_391397.json:
```json
{
    "body": "Replying to [comment:22 gh-kliem]:\n> I was aware of `4/2` being rational.\n> I just find it awful to change the backend when you enter rational width.\n> The backend should never change unintentionally unless necessary (so if you enter `width=2.0` the backend will change to cdd, which I would consider the expected behavior.)\n> \n> It's just annoying when you want to use `normaliz` and every operation ignores your preference and you have to change backend over and over (and even worse calculations might take longer time with `ppl`, which you decided not to use in the first place).\n> \n> Replying to [comment:21 jipilab]:\n> > Replying to [comment:18 gh-kliem]:\n> > > What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).\n\n> > \n> > A note: in Sage `4/2` is rational:\n> > \n> > \n> > sage: type(4/2)\n> > <class 'sage.rings.rational.Rational'>\n> > }}}\n> > \n> > and it should be like that, not to create nightmares.\n> > \n> > Hence, taking `width=4/2`, the expected behavior is *really* to change the base ring to rational numbers.\n> > \n> > In Sage dividing two `Integers` yields an element in the FractionField, i.e. the rationals. It is the users responsibility to know these things. Just like `2.0` is not an integer.\n> > \n> > That said, it is completely fine to have `base_ring=QQ` but integral vertices. The goal of base ring is not to steadily represent the smallest ring in which the vertices lay in.\n\n\nOf course, of course. The only thing to do is to carry the backend to the wedge, no big deal...",
    "created_at": "2019-07-25T08:13:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391397",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:22 gh-kliem]:
> I was aware of `4/2` being rational.
> I just find it awful to change the backend when you enter rational width.
> The backend should never change unintentionally unless necessary (so if you enter `width=2.0` the backend will change to cdd, which I would consider the expected behavior.)
> 
> It's just annoying when you want to use `normaliz` and every operation ignores your preference and you have to change backend over and over (and even worse calculations might take longer time with `ppl`, which you decided not to use in the first place).
> 
> Replying to [comment:21 jipilab]:
> > Replying to [comment:18 gh-kliem]:
> > > What about normaliz with base ring ZZ and width 5/2 (even worse 4/2)? (I suspect backend will not be preserved).

> > 
> > A note: in Sage `4/2` is rational:
> > 
> > 
> > sage: type(4/2)
> > <class 'sage.rings.rational.Rational'>
> > }}}
> > 
> > and it should be like that, not to create nightmares.
> > 
> > Hence, taking `width=4/2`, the expected behavior is *really* to change the base ring to rational numbers.
> > 
> > In Sage dividing two `Integers` yields an element in the FractionField, i.e. the rationals. It is the users responsibility to know these things. Just like `2.0` is not an integer.
> > 
> > That said, it is completely fine to have `base_ring=QQ` but integral vertices. The goal of base ring is not to steadily represent the smallest ring in which the vertices lay in.


Of course, of course. The only thing to do is to carry the backend to the wedge, no big deal...



---

archive/issue_comments_391398.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-25T09:27:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391398",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_391399.json:
```json
{
    "body": "Replying to [comment:20 gh-kliem]:\n> Base extend should work recognize `1` as well.\n\nNot anymore after the last commit I did. `ZZ.one()` is really needed now. The `width` should have a `base_ring`method in order for the wedge to work.\n\n> Can you add `base_ring=self.base_ring()` and same for backend to initialization of L. (Setting up the correct base ring right away, avoids coercion for the product to my understanding.)\n\nThis might produce problems due to the following behavior:\n\n```\nsage: Polyhedron(lines=[[1]])\nA 1-dimensional polyhedron in ZZ^1 defined as the convex hull of 1 vertex and 1 line\nsage: Polyhedron(lines=[[1]], base_ring=AA)\nThe empty polyhedron in AA^1\nsage: Polyhedron(lines=[[1]], base_ring=AA, backend='normaliz')\nA 1-dimensional polyhedron in AA^1 defined as the convex hull of 1 vertex and 1 line\n```\n\n\nThe backend should now be preserved as long as this is possible. The base ring will change to the field of fractions of the current base ring, if width takes the default value 1. This is really needed because the base ring for the vertices is either the base ring for the ieqs or its field of fractions\n\n---\nNew commits:",
    "created_at": "2019-07-25T09:29:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391399",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:20 gh-kliem]:
> Base extend should work recognize `1` as well.

Not anymore after the last commit I did. `ZZ.one()` is really needed now. The `width` should have a `base_ring`method in order for the wedge to work.

> Can you add `base_ring=self.base_ring()` and same for backend to initialization of L. (Setting up the correct base ring right away, avoids coercion for the product to my understanding.)

This might produce problems due to the following behavior:

```
sage: Polyhedron(lines=[[1]])
A 1-dimensional polyhedron in ZZ^1 defined as the convex hull of 1 vertex and 1 line
sage: Polyhedron(lines=[[1]], base_ring=AA)
The empty polyhedron in AA^1
sage: Polyhedron(lines=[[1]], base_ring=AA, backend='normaliz')
A 1-dimensional polyhedron in AA^1 defined as the convex hull of 1 vertex and 1 line
```


The backend should now be preserved as long as this is possible. The base ring will change to the field of fractions of the current base ring, if width takes the default value 1. This is really needed because the base ring for the vertices is either the base ring for the ieqs or its field of fractions

---
New commits:



---

archive/issue_comments_391400.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-07-25T09:45:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391400",
    "user": "https://github.com/LaisRast"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_391401.json:
```json
{
    "body": "Replying to [comment:25 gh-LaisRast]:\n> Replying to [comment:20 gh-kliem]:\n> > Base extend should work recognize `1` as well.\n\n> Not anymore after the last commit I did. `ZZ.one()` is really needed now. The `width` should have a `base_ring`method in order for the wedge to work.\n> \n> > Can you add `base_ring=self.base_ring()` and same for backend to initialization of L. (Setting up the correct base ring right away, avoids coercion for the product to my understanding.)\n\n> This might produce problems due to the following behavior:\n> \n> \n> ```\n> sage: Polyhedron(lines=[[1]])\n> A 1-dimensional polyhedron in ZZ^1 defined as the convex hull of 1 vertex and 1 line\n> sage: Polyhedron(lines=[[1]], base_ring=AA)\n> The empty polyhedron in AA^1\n> sage: Polyhedron(lines=[[1]], base_ring=AA, backend='normaliz')\n> A 1-dimensional polyhedron in AA^1 defined as the convex hull of 1 vertex and 1 line\n> ```\n\n\nI think that's a bug.\n> \n> \n> The backend should now be preserved as long as this is possible. The base ring will change to the field of fractions of the current base ring, if width takes the default value 1. This is really needed because the base ring for the vertices is either the base ring for the ieqs or its field of fractions\n> \n> \n> ---\n> New commits:\n> |                                                                                                                                          |                                        |\n> |------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------|\n> |[00f2253](https://git.sagemath.org/sage.git/commit?id=00f225333846d3559bcf9caefc62a35e0b8b918a)|`polyhedron H now preserves backend now`|\n> |[09597bd](https://git.sagemath.org/sage.git/commit?id=09597bdff5713b097959a839fc6f24f4134e0f90)|`backend should be preserved now`|\n> |[7653fb8](https://git.sagemath.org/sage.git/commit?id=7653fb8d21fc31d7ab34ff2c1c6da050934adef9)|`Now should work if width is in RDF`|",
    "created_at": "2019-07-25T11:15:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391401",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:25 gh-LaisRast]:
> Replying to [comment:20 gh-kliem]:
> > Base extend should work recognize `1` as well.

> Not anymore after the last commit I did. `ZZ.one()` is really needed now. The `width` should have a `base_ring`method in order for the wedge to work.
> 
> > Can you add `base_ring=self.base_ring()` and same for backend to initialization of L. (Setting up the correct base ring right away, avoids coercion for the product to my understanding.)

> This might produce problems due to the following behavior:
> 
> 
> ```
> sage: Polyhedron(lines=[[1]])
> A 1-dimensional polyhedron in ZZ^1 defined as the convex hull of 1 vertex and 1 line
> sage: Polyhedron(lines=[[1]], base_ring=AA)
> The empty polyhedron in AA^1
> sage: Polyhedron(lines=[[1]], base_ring=AA, backend='normaliz')
> A 1-dimensional polyhedron in AA^1 defined as the convex hull of 1 vertex and 1 line
> ```


I think that's a bug.
> 
> 
> The backend should now be preserved as long as this is possible. The base ring will change to the field of fractions of the current base ring, if width takes the default value 1. This is really needed because the base ring for the vertices is either the base ring for the ieqs or its field of fractions
> 
> 
> ---
> New commits:
> |                                                                                                                                          |                                        |
> |------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------|
> |[00f2253](https://git.sagemath.org/sage.git/commit?id=00f225333846d3559bcf9caefc62a35e0b8b918a)|`polyhedron H now preserves backend now`|
> |[09597bd](https://git.sagemath.org/sage.git/commit?id=09597bdff5713b097959a839fc6f24f4134e0f90)|`backend should be preserved now`|
> |[7653fb8](https://git.sagemath.org/sage.git/commit?id=7653fb8d21fc31d7ab34ff2c1c6da050934adef9)|`Now should work if width is in RDF`|



---

archive/issue_comments_391402.json:
```json
{
    "body": "Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.\nAlternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.\n\nThe current code does not work with width a python integer ect.\nHow about `parent = self.parent().base_extend(width/1, \u2026`, I believe this works as well.\nThen a default `width=1` would be fine as well.\nAs of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.",
    "created_at": "2019-07-25T11:29:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391402",
    "user": "https://github.com/kliem"
}
```

Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.
Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.

The current code does not work with width a python integer ect.
How about `parent = self.parent().base_extend(width/1, …`, I believe this works as well.
Then a default `width=1` would be fine as well.
As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.



---

archive/issue_comments_391403.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-07-25T11:29:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391403",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_391404.json:
```json
{
    "body": "Replying to [comment:28 gh-kliem]:\n> Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.\n> Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.\n\nI switched to `field`.\n\n> The current code does not work with width a python integer ect.\n> How about `parent = self.parent().base_extend(width/1, \u2026`, I believe this works as well.\n> Then a default `width=1` would be fine as well.\n> As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.\n> \n\nIn python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.",
    "created_at": "2019-07-25T11:59:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391404",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:28 gh-kliem]:
> Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.
> Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.

I switched to `field`.

> The current code does not work with width a python integer ect.
> How about `parent = self.parent().base_extend(width/1, …`, I believe this works as well.
> Then a default `width=1` would be fine as well.
> As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.
> 

In python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.



---

archive/issue_comments_391405.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-25T12:01:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391405",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_391406.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-07-25T12:20:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391406",
    "user": "https://github.com/LaisRast"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_391407.json:
```json
{
    "body": "Replying to [comment:29 gh-LaisRast]:\n> Replying to [comment:28 gh-kliem]:\n> > Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.\n> > Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.\n\n> I switched to `field`.\n> \n> > The current code does not work with width a python integer ect.\n> > How about `parent = self.parent().base_extend(width/1, \u2026`, I believe this works as well.\n> > Then a default `width=1` would be fine as well.\n> > As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.\n> > \n\n> In python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.\n\nHaving `ZZ.one()` as default instead of python `1` solves the problem for the default value. If the value of `width` is not the default value, then it is a sage ring element. This solves the problem for non-default values.",
    "created_at": "2019-07-25T12:20:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391407",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:29 gh-LaisRast]:
> Replying to [comment:28 gh-kliem]:
> > Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.
> > Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.

> I switched to `field`.
> 
> > The current code does not work with width a python integer ect.
> > How about `parent = self.parent().base_extend(width/1, …`, I believe this works as well.
> > Then a default `width=1` would be fine as well.
> > As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.
> > 

> In python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.

Having `ZZ.one()` as default instead of python `1` solves the problem for the default value. If the value of `width` is not the default value, then it is a sage ring element. This solves the problem for non-default values.



---

archive/issue_comments_391408.json:
```json
{
    "body": "Replying to [comment:29 gh-LaisRast]:\n> Replying to [comment:28 gh-kliem]:\n> > Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.\n> > Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.\n\n> I switched to `field`.\n> \n> > The current code does not work with width a python integer ect.\n> > How about `parent = self.parent().base_extend(width/1, \u2026`, I believe this works as well.\n> > Then a default `width=1` would be fine as well.\n> > As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.\n> > \n\n> In python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.\n\n`parent._coerce_base_ring(1/1)` gives rational field, which tells me that base extend works fine.\nDon't worry about passing a ring to `Polyhedra.base_extend`.\nProbably you should pass `1/width` as argument `base_ring`:\n\n```diff\n-        parent = self.parent().base_extend(width.base_ring().fraction_field(),\\\n+        parent = self.parent().base_extend(1/width,\\\n                                             ambient_dim=self.ambient_dim()+1)\n```\n\nThis extends the ring of parent, such that `1/width` is an element.\nThere is a number of occasions, where I used `base_extend` this way to have polyhedral operations respect the base ring.",
    "created_at": "2019-07-25T12:23:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391408",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:29 gh-LaisRast]:
> Replying to [comment:28 gh-kliem]:
> > Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.
> > Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.

> I switched to `field`.
> 
> > The current code does not work with width a python integer ect.
> > How about `parent = self.parent().base_extend(width/1, …`, I believe this works as well.
> > Then a default `width=1` would be fine as well.
> > As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.
> > 

> In python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.

`parent._coerce_base_ring(1/1)` gives rational field, which tells me that base extend works fine.
Don't worry about passing a ring to `Polyhedra.base_extend`.
Probably you should pass `1/width` as argument `base_ring`:

```diff
-        parent = self.parent().base_extend(width.base_ring().fraction_field(),\
+        parent = self.parent().base_extend(1/width,\
                                             ambient_dim=self.ambient_dim()+1)
```

This extends the ring of parent, such that `1/width` is an element.
There is a number of occasions, where I used `base_extend` this way to have polyhedral operations respect the base ring.



---

archive/issue_comments_391409.json:
```json
{
    "body": "Replying to [comment:31 gh-LaisRast]:\n> Replying to [comment:29 gh-LaisRast]:\n> > Replying to [comment:28 gh-kliem]:\n> > > Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.\n> > > Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.\n\n> > I switched to `field`.\n> > \n> > > The current code does not work with width a python integer ect.\n> > > How about `parent = self.parent().base_extend(width/1, \u2026`, I believe this works as well.\n> > > Then a default `width=1` would be fine as well.\n> > > As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.\n> > > \n\n> > In python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.\n> \n> Having `ZZ.one()` as default instead of python `1` solves the problem for the default value. If the value of `width` is not the default value, then it is a sage ring element. This solves the problem for non-default values.\n\n\nNo. If you write a python script that uses this method, you will have to import `Integer` from sage as well to be able to pass `width`.\nSomething as `1l` or `1L` or `float(0.9)` should work as well.\n\nActually you need to use `ZZ.one()/width` (not `1/width`), which should do the trick. Sorry about the confusion.\nAlternatively, you find a method to map `width` to a sage ring element and then still do the fraction field.",
    "created_at": "2019-07-25T12:41:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391409",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:31 gh-LaisRast]:
> Replying to [comment:29 gh-LaisRast]:
> > Replying to [comment:28 gh-kliem]:
> > > Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.
> > > Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.

> > I switched to `field`.
> > 
> > > The current code does not work with width a python integer ect.
> > > How about `parent = self.parent().base_extend(width/1, …`, I believe this works as well.
> > > Then a default `width=1` would be fine as well.
> > > As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.
> > > 

> > In python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.
> 
> Having `ZZ.one()` as default instead of python `1` solves the problem for the default value. If the value of `width` is not the default value, then it is a sage ring element. This solves the problem for non-default values.


No. If you write a python script that uses this method, you will have to import `Integer` from sage as well to be able to pass `width`.
Something as `1l` or `1L` or `float(0.9)` should work as well.

Actually you need to use `ZZ.one()/width` (not `1/width`), which should do the trick. Sorry about the confusion.
Alternatively, you find a method to map `width` to a sage ring element and then still do the fraction field.



---

archive/issue_comments_391410.json:
```json
{
    "body": "Please allow python integers (and floats) as input for width.",
    "created_at": "2019-07-25T12:42:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391410",
    "user": "https://github.com/kliem"
}
```

Please allow python integers (and floats) as input for width.



---

archive/issue_comments_391411.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-07-25T12:42:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391411",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_391412.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-25T12:48:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391412",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_391413.json:
```json
{
    "body": "Replying to [comment:33 gh-kliem]:\n> Replying to [comment:31 gh-LaisRast]:\n> > Replying to [comment:29 gh-LaisRast]:\n> > > Replying to [comment:28 gh-kliem]:\n> > > > Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.\n> > > > Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.\n\n> > > I switched to `field`.\n> > > \n> > > > The current code does not work with width a python integer ect.\n> > > > How about `parent = self.parent().base_extend(width/1, \u2026`, I believe this works as well.\n> > > > Then a default `width=1` would be fine as well.\n> > > > As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.\n> > > > \n\n> > > In python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.\n> > \n> > Having `ZZ.one()` as default instead of python `1` solves the problem for the default value. If the value of `width` is not the default value, then it is a sage ring element. This solves the problem for non-default values.\n\n> \n> No. If you write a python script that uses this method, you will have to import `Integer` from sage as well to be able to pass `width`.\n> Something as `1l` or `1L` or `float(0.9)` should work as well.\n> \n> Actually you need to use `ZZ.one()/width` (not `1/width`), which should do the trick. Sorry about the confusion.\n> Alternatively, you find a method to map `width` to a sage ring element and then still do the fraction field.\n\n\nThis is actually a good trick to deal with python numbers.",
    "created_at": "2019-07-25T12:48:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391413",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:33 gh-kliem]:
> Replying to [comment:31 gh-LaisRast]:
> > Replying to [comment:29 gh-LaisRast]:
> > > Replying to [comment:28 gh-kliem]:
> > > > Most importantly the `normaliz` tests should be marked optional as `pynormaliz` cannot be assumed to be installed.
> > > > Alternatively, you can switch to backend `field` for the tests, this demonstrates as well that the backend is preserved.

> > > I switched to `field`.
> > > 
> > > > The current code does not work with width a python integer ect.
> > > > How about `parent = self.parent().base_extend(width/1, …`, I believe this works as well.
> > > > Then a default `width=1` would be fine as well.
> > > > As of #27926 `parent.base_extend` works with elements of rings and numbers that can be interpreted as such.
> > > > 

> > > In python3 (resp. python2), `x = 1/1; type(x)` gives `<class 'float'>` (resp. `<type 'int'>`), which does not have a `.base_ring()`. I need `.base_ring()` so I can find its `.fraction_field()`.
> > 
> > Having `ZZ.one()` as default instead of python `1` solves the problem for the default value. If the value of `width` is not the default value, then it is a sage ring element. This solves the problem for non-default values.

> 
> No. If you write a python script that uses this method, you will have to import `Integer` from sage as well to be able to pass `width`.
> Something as `1l` or `1L` or `float(0.9)` should work as well.
> 
> Actually you need to use `ZZ.one()/width` (not `1/width`), which should do the trick. Sorry about the confusion.
> Alternatively, you find a method to map `width` to a sage ring element and then still do the fraction field.


This is actually a good trick to deal with python numbers.



---

archive/issue_comments_391414.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-07-25T12:48:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391414",
    "user": "https://github.com/LaisRast"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_391415.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-25T12:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391415",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_events_069326.json:
```json
{
    "actor": "https://github.com/jplab",
    "created_at": "2019-07-25T13:27:18Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "milestone": "sage-8.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27736#event-69326"
}
```



---

archive/issue_comments_391416.json:
```json
{
    "body": "Replying to [comment:27 gh-kliem]:\n> Replying to [comment:25 gh-LaisRast]:\n> > Replying to [comment:20 gh-kliem]:\n> > > Base extend should work recognize `1` as well.\n\n> > Not anymore after the last commit I did. `ZZ.one()` is really needed now. The `width` should have a `base_ring`method in order for the wedge to work.\n> > \n> > > Can you add `base_ring=self.base_ring()` and same for backend to initialization of L. (Setting up the correct base ring right away, avoids coercion for the product to my understanding.)\n\n> > This might produce problems due to the following behavior:\n> > \n> > \n> > ```\n> > sage: Polyhedron(lines=[[1]])\n> > A 1-dimensional polyhedron in ZZ^1 defined as the convex hull of 1 vertex and 1 line\n> > sage: Polyhedron(lines=[[1]], base_ring=AA)\n> > The empty polyhedron in AA^1\n> > sage: Polyhedron(lines=[[1]], base_ring=AA, backend='normaliz')\n> > A 1-dimensional polyhedron in AA^1 defined as the convex hull of 1 vertex and 1 line\n> > ```\n\n> \n> I think that's a bug.\n\n\nThis is definitely a bug.",
    "created_at": "2019-07-25T13:41:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391416",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:27 gh-kliem]:
> Replying to [comment:25 gh-LaisRast]:
> > Replying to [comment:20 gh-kliem]:
> > > Base extend should work recognize `1` as well.

> > Not anymore after the last commit I did. `ZZ.one()` is really needed now. The `width` should have a `base_ring`method in order for the wedge to work.
> > 
> > > Can you add `base_ring=self.base_ring()` and same for backend to initialization of L. (Setting up the correct base ring right away, avoids coercion for the product to my understanding.)

> > This might produce problems due to the following behavior:
> > 
> > 
> > ```
> > sage: Polyhedron(lines=[[1]])
> > A 1-dimensional polyhedron in ZZ^1 defined as the convex hull of 1 vertex and 1 line
> > sage: Polyhedron(lines=[[1]], base_ring=AA)
> > The empty polyhedron in AA^1
> > sage: Polyhedron(lines=[[1]], base_ring=AA, backend='normaliz')
> > A 1-dimensional polyhedron in AA^1 defined as the convex hull of 1 vertex and 1 line
> > ```

> 
> I think that's a bug.


This is definitely a bug.



---

archive/issue_comments_391417.json:
```json
{
    "body": "> Actually you need to use `ZZ.one()/width` (not `1/width`), which should do the trick. Sorry about the confusion.\n> Alternatively, you find a method to map `width` to a sage ring element and then still do the fraction field.\n\n\nI do not get at all all this fuss.\n\nThe default of `width` should be set to `None`. If no value is given, the algorithm will fetch the base ring of the object and take `.one()` of that base ring and continue with that value.\n\nIf the user gives a weird value for the width, that's the user's problem (the whole `Polyhedron` class is based on this principle). It is not at all expected that the base ring is preserved. Only if possible (which is handled by the intersection method...\n\nThe only thing that matters is the backend. Thus the returned polyhedron should have the right backend...\n\nI fail to see the issue here.",
    "created_at": "2019-07-25T13:51:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391417",
    "user": "https://github.com/jplab"
}
```

> Actually you need to use `ZZ.one()/width` (not `1/width`), which should do the trick. Sorry about the confusion.
> Alternatively, you find a method to map `width` to a sage ring element and then still do the fraction field.


I do not get at all all this fuss.

The default of `width` should be set to `None`. If no value is given, the algorithm will fetch the base ring of the object and take `.one()` of that base ring and continue with that value.

If the user gives a weird value for the width, that's the user's problem (the whole `Polyhedron` class is based on this principle). It is not at all expected that the base ring is preserved. Only if possible (which is handled by the intersection method...

The only thing that matters is the backend. Thus the returned polyhedron should have the right backend...

I fail to see the issue here.



---

archive/issue_comments_391418.json:
```json
{
    "body": "... in particular, I do not see at all why a `base_extend` would be necessary.",
    "created_at": "2019-07-25T13:56:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391418",
    "user": "https://github.com/jplab"
}
```

... in particular, I do not see at all why a `base_extend` would be necessary.



---

archive/issue_comments_391419.json:
```json
{
    "body": "`H` should be well-defined and with correct backend. This is what we need `base_extend` for.\nI didn't check if we really need the value `1/width`.\nI don't find a python integer to be a overly strange input.\nEspecially, since we already put in the effort to make our default work.\n\nUsing standard constructor for `H` with backend argument can result in an error, when the backend doesn't support `width`.\nStandard constructor without backend argument, will not preserve backend, e.g. with `self` being integral.\n\n`base_extend` does preserve backend whenever possible, which is exactly what we want.\n\nBtw, can't we just write down all equations and inequalities right away.\nThis saves the time of calculating double description for two (possibly large) intermediate polyhedra.",
    "created_at": "2019-07-25T14:41:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391419",
    "user": "https://github.com/kliem"
}
```

`H` should be well-defined and with correct backend. This is what we need `base_extend` for.
I didn't check if we really need the value `1/width`.
I don't find a python integer to be a overly strange input.
Especially, since we already put in the effort to make our default work.

Using standard constructor for `H` with backend argument can result in an error, when the backend doesn't support `width`.
Standard constructor without backend argument, will not preserve backend, e.g. with `self` being integral.

`base_extend` does preserve backend whenever possible, which is exactly what we want.

Btw, can't we just write down all equations and inequalities right away.
This saves the time of calculating double description for two (possibly large) intermediate polyhedra.



---

archive/issue_comments_391420.json:
```json
{
    "body": "Replying to [comment:43 gh-kliem]:\n> `H` should be well-defined and with correct backend. This is what we need `base_extend` for.\n\n\n`H` is a totally well defined object on whatever reasonable given value of `width` that is given by the user. There is no such thing as correct backend at this stage. All you would do is try to do a good guess before `intersection` will proceed to do exactly the same, but with the help of coercion. So why try to do things twice?\n\nIf the user doesn't say a word, then for sure we should just take a width from the same base ring. Then, the story with backend is irrelevant since this should be taken care of in the intersection method, and not in this specific place.\n\n> I didn't check if we really need the value `1/width`.\n> I don't find a python integer to be a overly strange input.\n> Especially, since we already put in the effort to make our default work.\n\n\nThe code is barely 15 lines long... ;-)\n\n> Using standard constructor for `H` with backend argument can result in an error, when the backend doesn't support `width`.\n\n\nNow I see what you mean. But again that business should be taken care of by intersection, and not here.\n\n> Standard constructor without backend argument, will not preserve backend, e.g. with `self` being integral.\n> \n> `base_extend` does preserve backend whenever possible, which is exactly what we want.\n\n\nAgreed. But this is a hack, and I do not like that solution. Further, one line after `H` is defined it is passed right away to intersection.\n\n> Btw, can't we just write down all equations and inequalities right away.\n> This saves the time of calculating double description for two (possibly large) intermediate polyhedra.\n\n\nYes, and the long term idea is to have intersection do this kind of redundancy checks using `normaliz` tools. (long term...) Once adding inequalities dynamically will be readily available in Sage, we can talk about it again. For now, I don't think we have to deal with this in this ticket.\n\nIn the end, the wedge is the intersection of an infinite prism over the given polyhedron (trivial to keep base ring and backend) and an infinite `keil` defined by two inequalities. The base ring of this `keil` is decided by the type of `width`, and the backend should also be decided from the type of `width`.\n\nThen, the decision for the backend of the intersection should be delegated to `.intersection` method. Why all the fuss here in wedge? If the user gives a float width and had normaliz as a backend, why should it stay normaliz? It can't!\n\nThe coercion will just figure out the right object and backend... This is already taken care of in intersection.\n\nThe following illustrates exactly the behavior that I expect to happen in `wedge`:\n\n```\nsage: P = Polyhedron(rays=[[1,0],[0,1]],base_ring=RDF)\nsage: Q = Polyhedron(rays=[[-1,0],[0,1]],vertices=[[1,0]],backend='normaliz')\nsage: P & Q\nA 2-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices and 1 ray\nsage: P.backend()\n'cdd'\nsage: Q.backend()\n'normaliz'\n```",
    "created_at": "2019-07-25T15:16:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391420",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:43 gh-kliem]:
> `H` should be well-defined and with correct backend. This is what we need `base_extend` for.


`H` is a totally well defined object on whatever reasonable given value of `width` that is given by the user. There is no such thing as correct backend at this stage. All you would do is try to do a good guess before `intersection` will proceed to do exactly the same, but with the help of coercion. So why try to do things twice?

If the user doesn't say a word, then for sure we should just take a width from the same base ring. Then, the story with backend is irrelevant since this should be taken care of in the intersection method, and not in this specific place.

> I didn't check if we really need the value `1/width`.
> I don't find a python integer to be a overly strange input.
> Especially, since we already put in the effort to make our default work.


The code is barely 15 lines long... ;-)

> Using standard constructor for `H` with backend argument can result in an error, when the backend doesn't support `width`.


Now I see what you mean. But again that business should be taken care of by intersection, and not here.

> Standard constructor without backend argument, will not preserve backend, e.g. with `self` being integral.
> 
> `base_extend` does preserve backend whenever possible, which is exactly what we want.


Agreed. But this is a hack, and I do not like that solution. Further, one line after `H` is defined it is passed right away to intersection.

> Btw, can't we just write down all equations and inequalities right away.
> This saves the time of calculating double description for two (possibly large) intermediate polyhedra.


Yes, and the long term idea is to have intersection do this kind of redundancy checks using `normaliz` tools. (long term...) Once adding inequalities dynamically will be readily available in Sage, we can talk about it again. For now, I don't think we have to deal with this in this ticket.

In the end, the wedge is the intersection of an infinite prism over the given polyhedron (trivial to keep base ring and backend) and an infinite `keil` defined by two inequalities. The base ring of this `keil` is decided by the type of `width`, and the backend should also be decided from the type of `width`.

Then, the decision for the backend of the intersection should be delegated to `.intersection` method. Why all the fuss here in wedge? If the user gives a float width and had normaliz as a backend, why should it stay normaliz? It can't!

The coercion will just figure out the right object and backend... This is already taken care of in intersection.

The following illustrates exactly the behavior that I expect to happen in `wedge`:

```
sage: P = Polyhedron(rays=[[1,0],[0,1]],base_ring=RDF)
sage: Q = Polyhedron(rays=[[-1,0],[0,1]],vertices=[[1,0]],backend='normaliz')
sage: P & Q
A 2-dimensional polyhedron in RDF^2 defined as the convex hull of 2 vertices and 1 ray
sage: P.backend()
'cdd'
sage: Q.backend()
'normaliz'
```



---

archive/issue_comments_391421.json:
```json
{
    "body": "The problem is not float. A float is going to change backend to `cdd`, which is fine.\n\nLet `P` with parent `Polyhedra_normaliz_ZZ` and `Q` with parent `Polyhedra_ppl_QQ` then coercion will lead the intersection to be an element of `Polyhedra_ppl_QQ`, because there is a map in exactly one direction.\n\nHence, intersection might change the backend (it might prefer backend of `self` or `other` depending on the involved rings).\nHowever, I would expect a user to create all polyhedra with his preferred backend, so that shouldn't cause issues.\n\nNow, if we create a polyhedron `H` with default backend (and not what the user chose as backend of `self`) this might cause the `backend` to change. I think one could only prevent this by not using coercion for intersection.",
    "created_at": "2019-07-25T17:48:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391421",
    "user": "https://github.com/kliem"
}
```

The problem is not float. A float is going to change backend to `cdd`, which is fine.

Let `P` with parent `Polyhedra_normaliz_ZZ` and `Q` with parent `Polyhedra_ppl_QQ` then coercion will lead the intersection to be an element of `Polyhedra_ppl_QQ`, because there is a map in exactly one direction.

Hence, intersection might change the backend (it might prefer backend of `self` or `other` depending on the involved rings).
However, I would expect a user to create all polyhedra with his preferred backend, so that shouldn't cause issues.

Now, if we create a polyhedron `H` with default backend (and not what the user chose as backend of `self`) this might cause the `backend` to change. I think one could only prevent this by not using coercion for intersection.



---

archive/issue_comments_391422.json:
```json
{
    "body": "> Now, if we create a polyhedron `H` with default backend (and not what the user chose as backend of `self`) this might cause the `backend` to change. I think one could only prevent this by not using coercion for intersection.\n\n\nI thought that the solution since the beginning is to query the backend of `self`and apply it to `H`. If it fails, well this is a bad day for the user, because the backend will have to change whatsoever, due to the type of input, which we should trust is what the user wants.\n\nHence, try to create `H` with the backend of self, it is fails, just create `H` using the type of the given width.\n\nI would let `intersection` alone here and still trust it to do what is right when the time comes.\n\nIn the end, that the backend is not preserved by an operation which is not intended to, is not the end of the world. Is it?",
    "created_at": "2019-07-25T17:57:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391422",
    "user": "https://github.com/jplab"
}
```

> Now, if we create a polyhedron `H` with default backend (and not what the user chose as backend of `self`) this might cause the `backend` to change. I think one could only prevent this by not using coercion for intersection.


I thought that the solution since the beginning is to query the backend of `self`and apply it to `H`. If it fails, well this is a bad day for the user, because the backend will have to change whatsoever, due to the type of input, which we should trust is what the user wants.

Hence, try to create `H` with the backend of self, it is fails, just create `H` using the type of the given width.

I would let `intersection` alone here and still trust it to do what is right when the time comes.

In the end, that the backend is not preserved by an operation which is not intended to, is not the end of the world. Is it?



---

archive/issue_comments_391423.json:
```json
{
    "body": "Replying to [comment:46 jipilab]:\n> \n> > Now, if we create a polyhedron `H` with default backend (and not what the user chose as backend of `self`) this might cause the `backend` to change. I think one could only prevent this by not using coercion for intersection.\n\n> \n> I thought that the solution since the beginning is to query the backend of `self`and apply it to `H`. If it fails, well this is a bad day for the user, because the backend will have to change whatsoever, due to the type of input, which we should trust is what the user wants.\n> \n> Hence, try to create `H` with the backend of self, it is fails, just create `H` using the type of the given width.\n\n\nThis is exactly what `base_extend` does. It changes the parent as little as possible. Of course you can also use the constructor with `try` and `except`, which is what `base_extend` does (but cached).\n> \n> I would let `intersection` alone here and still trust it to do what is right when the time comes.\n\n\nIt will always prefer the backend of the polyhedron with larger ring due to coercion.\n> \n> In the end, that the backend is not preserved by an operation which is not intended to, is not the end of the world. Is it?\n\n\nIt is a pain, if it could have been prevented. If working with large polyhedra, which are manageable with `normaliz` and take forever with `ppl` you don't want the backend to change.\n\nTo ask a user to to `base_extend` before wedge over face is very sudle.",
    "created_at": "2019-07-25T18:20:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391423",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:46 jipilab]:
> 
> > Now, if we create a polyhedron `H` with default backend (and not what the user chose as backend of `self`) this might cause the `backend` to change. I think one could only prevent this by not using coercion for intersection.

> 
> I thought that the solution since the beginning is to query the backend of `self`and apply it to `H`. If it fails, well this is a bad day for the user, because the backend will have to change whatsoever, due to the type of input, which we should trust is what the user wants.
> 
> Hence, try to create `H` with the backend of self, it is fails, just create `H` using the type of the given width.


This is exactly what `base_extend` does. It changes the parent as little as possible. Of course you can also use the constructor with `try` and `except`, which is what `base_extend` does (but cached).
> 
> I would let `intersection` alone here and still trust it to do what is right when the time comes.


It will always prefer the backend of the polyhedron with larger ring due to coercion.
> 
> In the end, that the backend is not preserved by an operation which is not intended to, is not the end of the world. Is it?


It is a pain, if it could have been prevented. If working with large polyhedra, which are manageable with `normaliz` and take forever with `ppl` you don't want the backend to change.

To ask a user to to `base_extend` before wedge over face is very sudle.



---

archive/issue_comments_391424.json:
```json
{
    "body": "By the way, I don't really care how one initialized `H`. I just think it should have the backend of `self` if `width` admits it.",
    "created_at": "2019-07-25T20:01:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391424",
    "user": "https://github.com/kliem"
}
```

By the way, I don't really care how one initialized `H`. I just think it should have the backend of `self` if `width` admits it.



---

archive/issue_comments_391425.json:
```json
{
    "body": "Replying to [comment:47 gh-kliem]:\n> Replying to [comment:46 jipilab]:\n> > \n> > > Now, if we create a polyhedron `H` with default backend (and not what the user chose as backend of `self`) this might cause the `backend` to change. I think one could only prevent this by not using coercion for intersection.\n\n> > \n> > I thought that the solution since the beginning is to query the backend of `self`and apply it to `H`. If it fails, well this is a bad day for the user, because the backend will have to change whatsoever, due to the type of input, which we should trust is what the user wants.\n> > \n> > Hence, try to create `H` with the backend of self, it is fails, just create `H` using the type of the given width.\n\n> \n> This is exactly what `base_extend` does. It changes the parent as little as possible. Of course you can also use the constructor with `try` and `except`, which is what `base_extend` does (but cached).\n\n\nOk, fine. But I would not do this business with `1/width`, etc.\n\n> > \n> > I would let `intersection` alone here and still trust it to do what is right when the time comes.\n\n> \n> It will always prefer the backend of the polyhedron with larger ring due to coercion.\n> > \n> > In the end, that the backend is not preserved by an operation which is not intended to, is not the end of the world. Is it?\n\n> \n> It is a pain, if it could have been prevented. If working with large polyhedra, which are manageable with `normaliz` and take forever with `ppl` you don't want the backend to change.\n\n\nObviously.\n\n> To ask a user to to `base_extend` before wedge over face is very sudle.\n\n\nSudle? I am not sure to understand what you mean. Do you have any concrete suggestion for the code now?",
    "created_at": "2019-07-28T10:21:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391425",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:47 gh-kliem]:
> Replying to [comment:46 jipilab]:
> > 
> > > Now, if we create a polyhedron `H` with default backend (and not what the user chose as backend of `self`) this might cause the `backend` to change. I think one could only prevent this by not using coercion for intersection.

> > 
> > I thought that the solution since the beginning is to query the backend of `self`and apply it to `H`. If it fails, well this is a bad day for the user, because the backend will have to change whatsoever, due to the type of input, which we should trust is what the user wants.
> > 
> > Hence, try to create `H` with the backend of self, it is fails, just create `H` using the type of the given width.

> 
> This is exactly what `base_extend` does. It changes the parent as little as possible. Of course you can also use the constructor with `try` and `except`, which is what `base_extend` does (but cached).


Ok, fine. But I would not do this business with `1/width`, etc.

> > 
> > I would let `intersection` alone here and still trust it to do what is right when the time comes.

> 
> It will always prefer the backend of the polyhedron with larger ring due to coercion.
> > 
> > In the end, that the backend is not preserved by an operation which is not intended to, is not the end of the world. Is it?

> 
> It is a pain, if it could have been prevented. If working with large polyhedra, which are manageable with `normaliz` and take forever with `ppl` you don't want the backend to change.


Obviously.

> To ask a user to to `base_extend` before wedge over face is very sudle.


Sudle? I am not sure to understand what you mean. Do you have any concrete suggestion for the code now?



---

archive/issue_comments_391426.json:
```json
{
    "body": "Replying to [comment:49 jipilab]:\n> Replying to [comment:47 gh-kliem]:\n> > Replying to [comment:46 jipilab]:\n> > To ask a user to to `base_extend` before wedge over face is very sudle.\n\n> \n> Sudle? I am not sure to understand what you mean. Do you have any concrete suggestion for the code now?\n\n\nIn many cases polyhedra will by default be set up with base ring `ZZ` like in\n\n```\nsage: P = polytopes.simplex(backend='normaliz'); type(P)\n<class 'sage.geometry.polyhedron.parent.Polyhedra_ZZ_normaliz_with_category.element_class'>\n```\n\nIf a user wants to keep his backend and we ask him to change the base ring to `QQ` before doing wedge over face, this is confusing.",
    "created_at": "2019-07-30T12:57:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391426",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:49 jipilab]:
> Replying to [comment:47 gh-kliem]:
> > Replying to [comment:46 jipilab]:
> > To ask a user to to `base_extend` before wedge over face is very sudle.

> 
> Sudle? I am not sure to understand what you mean. Do you have any concrete suggestion for the code now?


In many cases polyhedra will by default be set up with base ring `ZZ` like in

```
sage: P = polytopes.simplex(backend='normaliz'); type(P)
<class 'sage.geometry.polyhedron.parent.Polyhedra_ZZ_normaliz_with_category.element_class'>
```

If a user wants to keep his backend and we ask him to change the base ring to `QQ` before doing wedge over face, this is confusing.



---

archive/issue_comments_391427.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-08-21T14:03:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391427",
    "user": "https://github.com/jplab"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_391428.json:
```json
{
    "body": "A few comments:\n\n* In the docstring `indicates how wide the resulted wedge should be`: I would say: `This parameter specifies how wide the wedge will be`.\n\n* `A (bounded) Polyhedron object` -> `A (bounded) polyhedron`\n\n* Please provide me a simple argument as to why the field of fraction of the base ring should be used \"by default\" (i.e. when the width is 1). I would say that the resulting base ring should be determined by the constructor. Yes, this will depend on the input polytope, which is fine. Further, yes, the backend should be preserved if possible, which simply means that one should pass it to the constructor. What do I see wrong?\n\nBecause we are using `Q.intersection(H)`, on top of what is done before, it is going to do a coercion to find the appropriate thing to do. I do not really understand why we force the parent of `H` to be the fraction field if it might not be necessary.\n\n* The text inside of the TEST is misleading since even if we give a different value to width, the base ring *will* change. ... so again, I am confused about how this is done. Further, the tests should provide a bit more demonstration as to how it preserves the backend (please show at least how it preserves 2 backends, with appropriate base rings).",
    "created_at": "2019-08-21T14:03:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391428",
    "user": "https://github.com/jplab"
}
```

A few comments:

* In the docstring `indicates how wide the resulted wedge should be`: I would say: `This parameter specifies how wide the wedge will be`.

* `A (bounded) Polyhedron object` -> `A (bounded) polyhedron`

* Please provide me a simple argument as to why the field of fraction of the base ring should be used "by default" (i.e. when the width is 1). I would say that the resulting base ring should be determined by the constructor. Yes, this will depend on the input polytope, which is fine. Further, yes, the backend should be preserved if possible, which simply means that one should pass it to the constructor. What do I see wrong?

Because we are using `Q.intersection(H)`, on top of what is done before, it is going to do a coercion to find the appropriate thing to do. I do not really understand why we force the parent of `H` to be the fraction field if it might not be necessary.

* The text inside of the TEST is misleading since even if we give a different value to width, the base ring *will* change. ... so again, I am confused about how this is done. Further, the tests should provide a bit more demonstration as to how it preserves the backend (please show at least how it preserves 2 backends, with appropriate base rings).



---

archive/issue_comments_391429.json:
```json
{
    "body": "Replying to [comment:51 jipilab]:\n> A few comments:\n> \n> * In the docstring `indicates how wide the resulted wedge should be`: I would say: `This parameter specifies how wide the wedge will be`.\n> \n> * `A (bounded) Polyhedron object` -> `A (bounded) polyhedron`\n> \n> * Please provide me a simple argument as to why the field of fraction of the base ring should be used \"by default\" (i.e. when the width is 1). I would say that the resulting base ring should be determined by the constructor. Yes, this will depend on the input polytope, which is fine. Further, yes, the backend should be preserved if possible, which simply means that one should pass it to the constructor. What do I see wrong?\n\n\nI agree that is makes no sense to use the field of fractions, when `width` is 1. I guess we should use the field of fractions whenever `width` is not a unit.\n\nIf we just pass the `backend` to the constructor, we get an error if the value of `width` is not handled by the current backend. Is this the desired behavior? If you don't like the current setup, we can also just use `does_backend_handle_base_ring` from parent.py (its basically a cached version of doing `try ... except` for the constructor).",
    "created_at": "2019-08-23T21:21:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391429",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:51 jipilab]:
> A few comments:
> 
> * In the docstring `indicates how wide the resulted wedge should be`: I would say: `This parameter specifies how wide the wedge will be`.
> 
> * `A (bounded) Polyhedron object` -> `A (bounded) polyhedron`
> 
> * Please provide me a simple argument as to why the field of fraction of the base ring should be used "by default" (i.e. when the width is 1). I would say that the resulting base ring should be determined by the constructor. Yes, this will depend on the input polytope, which is fine. Further, yes, the backend should be preserved if possible, which simply means that one should pass it to the constructor. What do I see wrong?


I agree that is makes no sense to use the field of fractions, when `width` is 1. I guess we should use the field of fractions whenever `width` is not a unit.

If we just pass the `backend` to the constructor, we get an error if the value of `width` is not handled by the current backend. Is this the desired behavior? If you don't like the current setup, we can also just use `does_backend_handle_base_ring` from parent.py (its basically a cached version of doing `try ... except` for the constructor).



---

archive/issue_comments_391430.json:
```json
{
    "body": "Replying to [comment:52 gh-kliem]:\n> Replying to [comment:51 jipilab]:\n> > A few comments:\n> > \n> > * In the docstring `indicates how wide the resulted wedge should be`: I would say: `This parameter specifies how wide the wedge will be`.\n> > \n> > * `A (bounded) Polyhedron object` -> `A (bounded) polyhedron`\n> > \n> > * Please provide me a simple argument as to why the field of fraction of the base ring should be used \"by default\" (i.e. when the width is 1). I would say that the resulting base ring should be determined by the constructor. Yes, this will depend on the input polytope, which is fine. Further, yes, the backend should be preserved if possible, which simply means that one should pass it to the constructor. What do I see wrong?\n\n> \n> I agree that is makes no sense to use the field of fractions, when `width` is 1. I guess we should use the field of fractions whenever `width` is not a unit.\n> \n> If we just pass the `backend` to the constructor, we get an error if the value of `width` is not handled by the current backend. Is this the desired behavior? \n\n\nI guess not. \n\n> If you don't like the current setup, we can also just use `does_backend_handle_base_ring` from parent.py (its basically a cached version of doing `try ... except` for the constructor).\n\n\nYes, to me that's probably the best intermediate to proceed this way and let the intersection deal with the rest.",
    "created_at": "2019-08-26T10:23:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391430",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:52 gh-kliem]:
> Replying to [comment:51 jipilab]:
> > A few comments:
> > 
> > * In the docstring `indicates how wide the resulted wedge should be`: I would say: `This parameter specifies how wide the wedge will be`.
> > 
> > * `A (bounded) Polyhedron object` -> `A (bounded) polyhedron`
> > 
> > * Please provide me a simple argument as to why the field of fraction of the base ring should be used "by default" (i.e. when the width is 1). I would say that the resulting base ring should be determined by the constructor. Yes, this will depend on the input polytope, which is fine. Further, yes, the backend should be preserved if possible, which simply means that one should pass it to the constructor. What do I see wrong?

> 
> I agree that is makes no sense to use the field of fractions, when `width` is 1. I guess we should use the field of fractions whenever `width` is not a unit.
> 
> If we just pass the `backend` to the constructor, we get an error if the value of `width` is not handled by the current backend. Is this the desired behavior? 


I guess not. 

> If you don't like the current setup, we can also just use `does_backend_handle_base_ring` from parent.py (its basically a cached version of doing `try ... except` for the constructor).


Yes, to me that's probably the best intermediate to proceed this way and let the intersection deal with the rest.



---

archive/issue_comments_391431.json:
```json
{
    "body": "Merged with newest develop.\n\n---\nNew commits:",
    "created_at": "2019-08-26T11:57:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391431",
    "user": "https://github.com/kliem"
}
```

Merged with newest develop.

---
New commits:



---

archive/issue_comments_391432.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-08-26T12:40:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391432",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_391433.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-08-26T12:43:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391433",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_391434.json:
```json
{
    "body": "Tried to simplify construction of `H`.\n\nBtw, I also tried to preserve the `base_ring` (when width is 1), but this did not work for the test in line 4205.",
    "created_at": "2019-08-26T12:43:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391434",
    "user": "https://github.com/kliem"
}
```

Tried to simplify construction of `H`.

Btw, I also tried to preserve the `base_ring` (when width is 1), but this did not work for the test in line 4205.



---

archive/issue_comments_391435.json:
```json
{
    "body": "The sentence:\n\n```diff\n+        The base_ring will change to the field of fractions of the current\n+        base_ring, unless width forces a different ring.\n```\n\nis still confusing as it says that the base ring always will change to the field of fractions. What if it stays as ZZ? (which is possible). This should be fixed...\n\nThe rest seems to be good.",
    "created_at": "2019-08-26T13:34:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391435",
    "user": "https://github.com/jplab"
}
```

The sentence:

```diff
+        The base_ring will change to the field of fractions of the current
+        base_ring, unless width forces a different ring.
```

is still confusing as it says that the base ring always will change to the field of fractions. What if it stays as ZZ? (which is possible). This should be fixed...

The rest seems to be good.



---

archive/issue_comments_391436.json:
```json
{
    "body": "Replying to [comment:57 jipilab]:\n> The sentence:\n> \n> \n> ```\n> #!diff\n> +        The base_ring will change to the field of fractions of the current\n> +        base_ring, unless width forces a different ring.\n> ```\n> \n> is still confusing as it says that the base ring always will change to the field of fractions. What if it stays as ZZ? (which is \n\n\nI don't think so. `H` is constructed from inequalities without specifying the basering. In this case the constructor coerces the base rings of all values and then takes the fraction field. If you want `ZZ` as basering when constructing a polyhedron from inequalities, you need to specify it for the constructor.\n>This should be fixed...\n> \n> The rest seems to be good.",
    "created_at": "2019-08-26T13:54:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391436",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:57 jipilab]:
> The sentence:
> 
> 
> ```
> #!diff
> +        The base_ring will change to the field of fractions of the current
> +        base_ring, unless width forces a different ring.
> ```
> 
> is still confusing as it says that the base ring always will change to the field of fractions. What if it stays as ZZ? (which is 


I don't think so. `H` is constructed from inequalities without specifying the basering. In this case the constructor coerces the base rings of all values and then takes the fraction field. If you want `ZZ` as basering when constructing a polyhedron from inequalities, you need to specify it for the constructor.
>This should be fixed...
> 
> The rest seems to be good.



---

archive/issue_comments_391437.json:
```json
{
    "body": "Replying to [comment:58 gh-kliem]:\n> Replying to [comment:57 jipilab]:\n> > The sentence:\n> > \n> > \n> > ```\n> > #!diff\n> > +        The base_ring will change to the field of fractions of the current\n> > +        base_ring, unless width forces a different ring.\n> > ```\n> > \n> > is still confusing as it says that the base ring always will change to the field of fractions. What if it stays as ZZ? (which is \n\n> \n> I don't think so. `H` is constructed from inequalities without specifying the basering. In this case the constructor coerces the base rings of all values and then takes the fraction field. If you want `ZZ` as basering when constructing a polyhedron from inequalities, you need to specify it for the constructor.\n\n\nOk... fine.",
    "created_at": "2019-08-26T14:48:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391437",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:58 gh-kliem]:
> Replying to [comment:57 jipilab]:
> > The sentence:
> > 
> > 
> > ```
> > #!diff
> > +        The base_ring will change to the field of fractions of the current
> > +        base_ring, unless width forces a different ring.
> > ```
> > 
> > is still confusing as it says that the base ring always will change to the field of fractions. What if it stays as ZZ? (which is 

> 
> I don't think so. `H` is constructed from inequalities without specifying the basering. In this case the constructor coerces the base rings of all values and then takes the fraction field. If you want `ZZ` as basering when constructing a polyhedron from inequalities, you need to specify it for the constructor.


Ok... fine.



---

archive/issue_comments_391438.json:
```json
{
    "body": "Is this good to go now?",
    "created_at": "2019-08-29T18:51:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391438",
    "user": "https://github.com/kliem"
}
```

Is this good to go now?



---

archive/issue_comments_391439.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-08-30T12:41:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391439",
    "user": "https://github.com/jplab"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_069327.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2019-09-05T21:33:25Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27736#event-69327"
}
```



---

archive/issue_comments_391440.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-09-05T21:33:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27736",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27736#issuecomment-391440",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
