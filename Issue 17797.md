# Issue 17797: symmetric_form weirdness for affine roots

Issue created by migration from Trac.

Original creator: bump

Original creation time: 2015-03-21 17:38:15

CC:  sage-combinat tscrim

Affine weight lattices have a method called symmetric_form which implements the symmetric bilinear form on the weight lattice (or weight space) used extensively in representation theory. See Kac, *Infinite-dimensional Lie algebras* Chapter 2. It is an inner product, that is, a pairing of the space with itself. Here are some examples where it doesn't work right unless you coerce the root into the weight lattice.


```
sage: RS = RootSystem(['A',2,1])
sage: P = RS.weight_lattice(extended=true)
sage: Q = RS.root_lattice()
sage: alpha = Q.simple_roots()
sage: alphacheck = Q.simple_coroots()
sage: omega = P.fundamental_weights()
sage: [alpha[1].symmetric_form(omega[i]) for i in [0,1,2]]
[-1, 2, -1]
sage: [alpha[1].symmetric_form(alphacheck[i]) for i in [0,1,2]]
[-1, 2, -1]
sage: [P(alpha[1]).symmetric_form(alphacheck[i]) for i in [0,1,2]]
[0, 1, 0]
sage: [P(alpha[1]).symmetric_form(omega[i]) for i in [0,1,2]]
[0, 1, 0]
```


The first three answers are (in my opinion) wrong for the following reasons.
The last answer is correct. The first one is therefore wrong since
the symmetric form should not depend on whether alpha is regarded as
an element of Q or of P. The second two pairings should be undefined since
alphacheck cannot be coerced into P.


---

Comment by bump created at 2015-03-21 17:41:43

Changing keywords from "" to "days64, symmetric_form".


---

Comment by tscrim created at 2015-03-22 07:00:31

So do you think we should raise an error message when we have incompatible arguments, which would be a coroot with a weight/root, and coerce otherwise? Or should we use the a<sup>v</sup> = 2 a / (a, a) identification to do the pairing? Also you'd be okay with the first would coerce move `alpha[1]` into the weight lattice?


---

Comment by bump created at 2015-03-22 13:34:10

> So do you think we should raise an error message when we have incompatible arguments, which would be a coroot with a weight/root, and coerce otherwise?

Yes. We do have another pairing `self.scalar(other)` which I think we use for the pairing with the dual space.

> Or should we use the av = 2 a / (a, a) identification to do the pairing? 

I think the answer is no, since this will blow up on imaginary roots where e.g. `(delta|delta)=0`. 

> Also you'd be okay with the first would coerce move alpha[1] into the weight lattice?

Yes, if we coerce elements of the root lattice into the weight lattice to compute the symmetric form I think this will give the right answer.


---

Comment by bump created at 2015-04-03 13:10:47

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by tscrim created at 2015-04-03 20:05:04

This doesn't seem to work for all non-simply-laced types (I've only checked some)


---

Comment by bump created at 2015-04-05 12:51:52

I'm writing some workarounds for #15806. It may be easier to fix the symmetric_form method after I'm done.


---

Comment by bump created at 2015-04-14 20:56:01

The methods `_inner_qq`, `_inner_pq` and `_inner_qq` in #15806 should make it possible to fix this by handling all three cases.
