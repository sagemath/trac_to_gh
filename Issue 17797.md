# Issue 17797: symmetric_form weirdness for affine roots

archive/issues_017797.json:
```json
{
    "body": "CC:  sage-combinat tscrim\n\nAffine weight lattices have a method called symmetric_form which implements the symmetric bilinear form on the weight lattice (or weight space) used extensively in representation theory. See Kac, *Infinite-dimensional Lie algebras* Chapter 2. It is an inner product, that is, a pairing of the space with itself. Here are some examples where it doesn't work right unless you coerce the root into the weight lattice.\n\n\n```\nsage: RS = RootSystem(['A',2,1])\nsage: P = RS.weight_lattice(extended=true)\nsage: Q = RS.root_lattice()\nsage: alpha = Q.simple_roots()\nsage: alphacheck = Q.simple_coroots()\nsage: omega = P.fundamental_weights()\nsage: [alpha[1].symmetric_form(omega[i]) for i in [0,1,2]]\n[-1, 2, -1]\nsage: [alpha[1].symmetric_form(alphacheck[i]) for i in [0,1,2]]\n[-1, 2, -1]\nsage: [P(alpha[1]).symmetric_form(alphacheck[i]) for i in [0,1,2]]\n[0, 1, 0]\nsage: [P(alpha[1]).symmetric_form(omega[i]) for i in [0,1,2]]\n[0, 1, 0]\n```\n\n\nThe first three answers are (in my opinion) wrong for the following reasons.\nThe last answer is correct. The first one is therefore wrong since\nthe symmetric form should not depend on whether alpha is regarded as\nan element of Q or of P. The second two pairings should be undefined since\nalphacheck cannot be coerced into P.\n\nIssue created by migration from https://trac.sagemath.org/ticket/18034\n\n",
    "created_at": "2015-03-21T17:38:15Z",
    "labels": [
        "PLEASE CHANGE",
        "major",
        "bug"
    ],
    "title": "symmetric_form weirdness for affine roots",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17797",
    "user": "bump"
}
```
CC:  sage-combinat tscrim

Affine weight lattices have a method called symmetric_form which implements the symmetric bilinear form on the weight lattice (or weight space) used extensively in representation theory. See Kac, *Infinite-dimensional Lie algebras* Chapter 2. It is an inner product, that is, a pairing of the space with itself. Here are some examples where it doesn't work right unless you coerce the root into the weight lattice.


```
sage: RS = RootSystem(['A',2,1])
sage: P = RS.weight_lattice(extended=true)
sage: Q = RS.root_lattice()
sage: alpha = Q.simple_roots()
sage: alphacheck = Q.simple_coroots()
sage: omega = P.fundamental_weights()
sage: [alpha[1].symmetric_form(omega[i]) for i in [0,1,2]]
[-1, 2, -1]
sage: [alpha[1].symmetric_form(alphacheck[i]) for i in [0,1,2]]
[-1, 2, -1]
sage: [P(alpha[1]).symmetric_form(alphacheck[i]) for i in [0,1,2]]
[0, 1, 0]
sage: [P(alpha[1]).symmetric_form(omega[i]) for i in [0,1,2]]
[0, 1, 0]
```


The first three answers are (in my opinion) wrong for the following reasons.
The last answer is correct. The first one is therefore wrong since
the symmetric form should not depend on whether alpha is regarded as
an element of Q or of P. The second two pairings should be undefined since
alphacheck cannot be coerced into P.

Issue created by migration from https://trac.sagemath.org/ticket/18034





---

archive/issue_comments_238525.json:
```json
{
    "body": "Changing keywords from \"\" to \"days64, symmetric_form\".",
    "created_at": "2015-03-21T17:41:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17797#issuecomment-238525",
    "user": "bump"
}
```

Changing keywords from "" to "days64, symmetric_form".



---

archive/issue_comments_238526.json:
```json
{
    "body": "So do you think we should raise an error message when we have incompatible arguments, which would be a coroot with a weight/root, and coerce otherwise? Or should we use the a<sup>v</sup> = 2 a / (a, a) identification to do the pairing? Also you'd be okay with the first would coerce move `alpha[1]` into the weight lattice?",
    "created_at": "2015-03-22T07:00:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17797#issuecomment-238526",
    "user": "tscrim"
}
```

So do you think we should raise an error message when we have incompatible arguments, which would be a coroot with a weight/root, and coerce otherwise? Or should we use the a<sup>v</sup> = 2 a / (a, a) identification to do the pairing? Also you'd be okay with the first would coerce move `alpha[1]` into the weight lattice?



---

archive/issue_comments_238527.json:
```json
{
    "body": "> So do you think we should raise an error message when we have incompatible arguments, which would be a coroot with a weight/root, and coerce otherwise?\n\nYes. We do have another pairing `self.scalar(other)` which I think we use for the pairing with the dual space.\n\n> Or should we use the av = 2 a / (a, a) identification to do the pairing? \n\nI think the answer is no, since this will blow up on imaginary roots where e.g. `(delta|delta)=0`. \n\n> Also you'd be okay with the first would coerce move alpha[1] into the weight lattice?\n\nYes, if we coerce elements of the root lattice into the weight lattice to compute the symmetric form I think this will give the right answer.",
    "created_at": "2015-03-22T13:34:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17797#issuecomment-238527",
    "user": "bump"
}
```

> So do you think we should raise an error message when we have incompatible arguments, which would be a coroot with a weight/root, and coerce otherwise?

Yes. We do have another pairing `self.scalar(other)` which I think we use for the pairing with the dual space.

> Or should we use the av = 2 a / (a, a) identification to do the pairing? 

I think the answer is no, since this will blow up on imaginary roots where e.g. `(delta|delta)=0`. 

> Also you'd be okay with the first would coerce move alpha[1] into the weight lattice?

Yes, if we coerce elements of the root lattice into the weight lattice to compute the symmetric form I think this will give the right answer.



---

archive/issue_comments_238528.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to combinatorics.",
    "created_at": "2015-04-03T13:10:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17797#issuecomment-238528",
    "user": "bump"
}
```

Changing component from PLEASE CHANGE to combinatorics.



---

archive/issue_comments_238529.json:
```json
{
    "body": "This doesn't seem to work for all non-simply-laced types (I've only checked some)",
    "created_at": "2015-04-03T20:05:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17797#issuecomment-238529",
    "user": "tscrim"
}
```

This doesn't seem to work for all non-simply-laced types (I've only checked some)



---

archive/issue_comments_238530.json:
```json
{
    "body": "I'm writing some workarounds for #15806. It may be easier to fix the symmetric_form method after I'm done.",
    "created_at": "2015-04-05T12:51:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17797#issuecomment-238530",
    "user": "bump"
}
```

I'm writing some workarounds for #15806. It may be easier to fix the symmetric_form method after I'm done.



---

archive/issue_comments_238531.json:
```json
{
    "body": "The methods `_inner_qq`, `_inner_pq` and `_inner_qq` in #15806 should make it possible to fix this by handling all three cases.",
    "created_at": "2015-04-14T20:56:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17797#issuecomment-238531",
    "user": "bump"
}
```

The methods `_inner_qq`, `_inner_pq` and `_inner_qq` in #15806 should make it possible to fix this by handling all three cases.
