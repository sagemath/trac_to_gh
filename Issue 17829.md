# Issue 17829: Cleanup of ModulesWithBasis and friends

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2015-03-27 06:32:19

Assignee: tscrim

CC:  nthiery darij aschilling zabrocki jhpalmieri

Currently `ModulesWithBasis` requires its implementations to behave like `CombinatorialFreeModule`, along with having an indexing set for the basis which is comparable. The aim of this ticket is to move various methods from `CombintorialFreeModule` and it's element class to `ModulesWithBasis`. This ticket will also give better generic functionality, such as a default implementation of `support`.


---

Comment by tscrim created at 2015-10-11 19:24:51

Changing status from new to needs_review.


---

Comment by tscrim created at 2015-10-11 19:24:51

Okay, I figured this was the best starting point for trying to see if the quack of a free module echoes. For this ticket, I moved many methods up and was able to generalize them. There were only minimal changes needed to remove the ordering on `support` (only the Macdonald basis of `Sym`) and make `monomial_coefficients()` an abstract method. I added the `copy` parameter to monomial coefficients for both speed and `dict` in the usual free modules has this API. Most of the other changes are trivial changes to doctest output.

The next thing to do would be to check to see if #10672 becomes invalid because of this ticket (execpt perhaps the iteration issue). After that, then move onto either merging CFM and (sparse?) free modules #10671 or rebasing and finalizing #18310.
----
New commits:


---

Comment by tscrim created at 2015-10-11 19:30:36

Also a question mostly for Nicolas, do we still need `_apply_module_morphism`? Is it just a method so that we don't have to create a full morphism object?


---

Comment by darij created at 2015-10-12 19:49:07

+1! This is the way to go, and thanks for doing it.

However, one thing I'm still missing is an explicit explanation of what methods one needs to implement in order to inherit from `ModulesWithBasis`. I suspect this is no longer up-to-date:

```
        # To implement a module_with_basis you need to implement either
        #   basis() or an _indices attribute and monomial().
```

(as in, we probably need more now), right? 

Coercion of coefficients into the base ring needs to be carefully thought over. As of now, I am not sure if it works correctly. For instance, `term` does no coercion, but `__invert__` does `self.parent().term(one, ~mcs[one])`, although the inversion operator `~` might produce an element of a bigger ring (for example, `~(ZZ(2))` returns `1/2`).

One more thing, which is probably not your fault but just caught my eyes. The docstring of `module_morphism` says:

```
            - ``matrix``   -- a matrix of size `\dim X \times \dim Y`
              or `\dim Y \times \dim X`
```

I don't see why the "or" is here. The doctests show that `\dim Y \times \dim X` works, but does `\dim X \times \dim Y` work too? And if so, *should* it? I think checking whether the matrix has the "wrong" dimensions, and then trying to fix them by transposing it, would be a brittle paradigm. 

Also, could we have doctests proving that the `monomial_coefficients` method works correctly (including not mutating the dictionary unless explicitly required) on various instances of `ModulesWithBasis` (e.g., vector spaces)? Thank you!


---

Comment by git created at 2015-10-12 22:19:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-12 22:34:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-12 22:38:08

So in my latest commit I fixed doctests. Some were trivial due to `support` no longer being ordered (and hence changes to the k-schur book tests and the cc of Anne and Mike), some were more substantial:

- `ChainComplexes` when passed a field said `VectorSpaces`, and so it did not consider itself as having a distinguished basis. However, if you give it a ring (like `ZZ`), then it became in `ModulesWithBasis` (=`FreeModules`), which it currently does not live from what I saw. Since there wasn't anything using this extra functionality (any attempt to use it was likely broken), I opted to downgrade the category to just `Modules`. (John, I cc'ed you to let you know.)

- I added a `dense_coefficient_list` for finite dimensional modules with basis so that you could get an ordered list of coefficients including 0's. This was needed for hyperplane arrangements. I'm open to different names.

- I made the linear expression code be in finite dimensional modules with basis.

Replying to [comment:3 darij]:
> However, one thing I'm still missing is an explicit explanation of what methods one needs to implement in order to inherit from `ModulesWithBasis`. I suspect this is no longer up-to-date:
> {{{
>         # To implement a module_with_basis you need to implement either
>         #   basis() or an _indices attribute and monomial().
> }}}
> (as in, we probably need more now), right? 

I put that in there because that is all that should be required. However, how the code breaks and the traceback tells you everything you need to know as far as what to implement.

> Coercion of coefficients into the base ring needs to be carefully thought over. As of now, I am not sure if it works correctly. For instance, `term` does no coercion, but `__invert__` does `self.parent().term(one, ~mcs[one])`, although the inversion operator `~` might produce an element of a bigger ring (for example, `~(ZZ(2))` returns `1/2`).

Actually my generic implementation should handle this with grace as it is `coeff * self.monomial(index)`. However, CFM currently does not do any coercion as indicated in the docstring, but that is a discussion for another ticket.

> One more thing, which is probably not your fault but just caught my eyes. The docstring of `module_morphism` says:
> {{{
>             - ``matrix``   -- a matrix of size `\dim X \times \dim Y`
>               or `\dim Y \times \dim X`
> }}}
> I don't see why the "or" is here. The doctests show that `\dim Y \times \dim X` works, but does `\dim X \times \dim Y` work too? And if so, *should* it? I think checking whether the matrix has the "wrong" dimensions, and then trying to fix them by transposing it, would be a brittle paradigm. 

I don't know and I don't really care as that is outside of the scope of this ticket.

> Also, could we have doctests proving that the `monomial_coefficients` method works correctly (including not mutating the dictionary unless explicitly required) on various instances of `ModulesWithBasis` (e.g., vector spaces)?

Added.


---

Comment by nthiery created at 2015-10-13 21:36:16

Replying to [comment:3 darij]:
> One more thing, which is probably not your fault but just caught my eyes. The docstring of `module_morphism` says:
> {{{
>             - ``matrix``   -- a matrix of size `\dim X \times \dim Y`
>               or `\dim Y \times \dim X`
> }}}
> I don't see why the "or" is here. The doctests show that `\dim Y \times \dim X` works, but does `\dim X \times \dim Y` work too? And if so, *should* it? I think checking whether the matrix has the "wrong" dimensions, and then trying to fix them by transposing it, would be a brittle paradigm. 

Which of the two it is depends on the value of the optional ``side`` argument. No worry, there is no attempt at "fixing" things by transposition.


---

Comment by nthiery created at 2015-10-13 21:38:39

Replying to [comment:2 tscrim]:
> Also a question mostly for Nicolas, do we still need `_apply_module_morphism`? Is it just a method so that we don't have to create a full morphism object?

As far as I know, that was indeed the motivation when Mike H implemented it. I imagine it can make sense in certain cases where many different morphisms are applied. But I don't have a strong opinion either.


---

Comment by nthiery created at 2015-10-13 21:40:39

Thanks for the progress on that btw!


---

Comment by tscrim created at 2015-10-13 21:50:48

Replying to [comment:8 nthiery]:
> Replying to [comment:2 tscrim]:
> > Also a question mostly for Nicolas, do we still need `_apply_module_morphism`? Is it just a method so that we don't have to create a full morphism object?
> 
> As far as I know, that was indeed the motivation when Mike H implemented it. I imagine it can make sense in certain cases where many different morphisms are applied. But I don't have a strong opinion either.

I ended up doing something for diagram algebras where I found this to be useful (although I could have used a full morphism to work around it), so I'm happy enough to keep it around for now.


---

Comment by darij created at 2015-10-14 04:09:40

Replying to [comment:7 nthiery]:
> Replying to [comment:3 darij]:
> > One more thing, which is probably not your fault but just caught my eyes. The docstring of `module_morphism` says:
> > {{{
> >             - ``matrix``   -- a matrix of size `\dim X \times \dim Y`
> >               or `\dim Y \times \dim X`
> > }}}
> > I don't see why the "or" is here. The doctests show that `\dim Y \times \dim X` works, but does `\dim X \times \dim Y` work too? And if so, *should* it? I think checking whether the matrix has the "wrong" dimensions, and then trying to fix them by transposing it, would be a brittle paradigm. 
> 
> Which of the two it is depends on the value of the optional ``side`` argument. No worry, there is no attempt at "fixing" things by transposition.

Ah, thank you! I didn't see this, as the argument is hidden inside the `**keywords`.


---

Comment by git created at 2015-10-14 18:21:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-15 02:34:54

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by tscrim created at 2015-10-15 14:31:10

It wasn't letting me post this comment:

To fix the failing doctests, I made the free modules be in the category of finite dimensional modules with basis, which I believe they should have been awhile ago. I also merged in the filtered algebras patch.


---

Comment by git created at 2015-10-22 02:29:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-24 17:29:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-24 21:38:31

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2015-10-24 23:46:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2015-10-24 23:50:06

Great job, Travis. If you are fine with my edits and the doctests agree, this is a positive_review.

I am somewhat unhappy about the fact that submodules of free modules don't play nicely with `monomial_coefficients` (if `M` is a submodule of `R^n` given as the span of some vectors, then `m.monomial_coefficients` for `m \in M` gives me the monomial coefficients of `m` with respect to the standard basis of `R^n`, not with respect to any basis of `M`), but this is hardly a flaw of this particular ticket.


---

Comment by tscrim created at 2015-10-25 00:01:59

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-10-25 08:36:05

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2015-10-25 08:36:05

How about running the tests before setting something to positive review?

```
sage -t --long src/sage/geometry/linear_expression.py
**********************************************************************
File "src/sage/geometry/linear_expression.py", line 183, in sage.geometry.linear_expression.LinearExpression.monomial_coefficients
Failed example:
    sorted(linear.monomial_coefficients().items()
Exception raised:
    Traceback (most recent call last):
      File "/mnt/disk/home/buildslave-sage/slave/sage_git/build/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 496, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/mnt/disk/home/buildslave-sage/slave/sage_git/build/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 856, in compile_and_execute
        compiled = compiler(example)
      File "/mnt/disk/home/buildslave-sage/slave/sage_git/build/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 494, in <lambda>
        example.source, filename, "single", compileflags, 1)
      File "<doctest sage.geometry.linear_expression.LinearExpression.monomial_coefficients[3]>", line 1
        sorted(linear.monomial_coefficients().items()
                                                    ^
    SyntaxError: unexpected EOF while parsing
**********************************************************************
1 item had failures:
   1 of   5 in sage.geometry.linear_expression.LinearExpression.monomial_coefficients
    [165 tests, 1 failure, 1.47 s]
```



---

Comment by git created at 2015-10-25 14:27:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2015-10-25 14:28:12

Changing status from needs_work to positive_review.


---

Comment by darij created at 2015-10-25 14:29:06

Thanks Travis! (I've just fired up my virtual machine a few minutes ago to deal with this...)

Note to self: do test sage/geometry...


---

Comment by vbraun created at 2015-10-26 00:18:42

Resolution: fixed


---

Comment by dimpase created at 2019-07-30 13:53:51

in `src/sage/categories/modules_with_basis.py` one still sees 

```
   Once :trac:`18066` is merged
```

namely here:

```
9bc28fd5fdb (Travis Scrimshaw  2015-03-26 23:33:19 -0700  129)         This category currently requires an implementation of an
6cc8b8460df (Travis Scrimshaw  2015-10-04 16:20:51 -0500  130)         element method ``support``. Once :trac:`18066` is merged, an
6cc8b8460df (Travis Scrimshaw  2015-10-04 16:20:51 -0500  131)         implementation of an ``items`` method will be required.
```

