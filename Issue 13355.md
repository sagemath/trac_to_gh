# Issue 13355: loglog plots of "large" function fail to find good evaluation points

archive/issues_013355.json:
```json
{
    "body": "Assignee: jason, was\n\nCC:  @eviatarbach\n\nIt sounds like the adaptative algorithm fails to find suitable\nevaluation points when plotting large functions (like exp) in loglog\nscale. In the following example, the exp function gets drawn with only\nthree points:\n\n```\nsage: plot([n^2,exp(n)], xmin=1, xmax=10^5, ymin=1,ymax=10^10, scale=\"loglog\")\nverbose 0 (2397: plot.py, generate_plot_points) WARNING: When plotting, failed to evaluate function at 198 points.\nverbose 0 (2397: plot.py, generate_plot_points) Last error message: ''\n```\n\n\nIf xmax is replaced by 10^10, the function is not even drawn:\n\n```\nsage: sage: plot([n^2,exp(n)], xmin=1, xmax=10^10, ymin=1,ymax=10^10, scale=\"loglog\")\nverbose 0 (2397: plot.py, generate_plot_points) WARNING: When plotting, failed to evaluate function at 199 points.\nverbose 0 (2397: plot.py, generate_plot_points) Last error message: ''\n```\n\n\nOn the other hand, the equivalent semilogy plot works smoothly:\n\n```\nsage: plot([10^n,exp(10^n)], xmin=0, xmax=5, ymin=1,ymax=10^10, scale=\"semilogy\")\nverbose 0 (2397: plot.py, generate_plot_points) WARNING: When plotting, failed to evaluate function at 86 points.\nverbose 0 (2397: plot.py, generate_plot_points) Last error message: ''\n```\n\n\n(Such plots are typically useful in classes about algorithmic complexity http://combinat.sagemath.org/doc/thematic_tutorials/agregation-option-calcul-formel/tris_et_complexite.html)\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/13559\n\n",
    "created_at": "2012-10-02T15:10:02Z",
    "labels": [
        "component: graphics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "loglog plots of \"large\" function fail to find good evaluation points",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13355",
    "user": "https://github.com/nthiery"
}
```
Assignee: jason, was

CC:  @eviatarbach

It sounds like the adaptative algorithm fails to find suitable
evaluation points when plotting large functions (like exp) in loglog
scale. In the following example, the exp function gets drawn with only
three points:

```
sage: plot([n^2,exp(n)], xmin=1, xmax=10^5, ymin=1,ymax=10^10, scale="loglog")
verbose 0 (2397: plot.py, generate_plot_points) WARNING: When plotting, failed to evaluate function at 198 points.
verbose 0 (2397: plot.py, generate_plot_points) Last error message: ''
```


If xmax is replaced by 10^10, the function is not even drawn:

```
sage: sage: plot([n^2,exp(n)], xmin=1, xmax=10^10, ymin=1,ymax=10^10, scale="loglog")
verbose 0 (2397: plot.py, generate_plot_points) WARNING: When plotting, failed to evaluate function at 199 points.
verbose 0 (2397: plot.py, generate_plot_points) Last error message: ''
```


On the other hand, the equivalent semilogy plot works smoothly:

```
sage: plot([10^n,exp(10^n)], xmin=0, xmax=5, ymin=1,ymax=10^10, scale="semilogy")
verbose 0 (2397: plot.py, generate_plot_points) WARNING: When plotting, failed to evaluate function at 86 points.
verbose 0 (2397: plot.py, generate_plot_points) Last error message: ''
```


(Such plots are typically useful in classes about algorithmic complexity http://combinat.sagemath.org/doc/thematic_tutorials/agregation-option-calcul-formel/tris_et_complexite.html)


Issue created by migration from https://trac.sagemath.org/ticket/13559





---

archive/issue_comments_163873.json:
```json
{
    "body": "Changing keywords from \"\" to \"agregation\".",
    "created_at": "2012-10-02T15:12:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163873",
    "user": "https://github.com/nthiery"
}
```

Changing keywords from "" to "agregation".



---

archive/issue_comments_163874.json:
```json
{
    "body": "It is not a problem with loglog. There is the same problem with normal plots.\n\n```\nsage: var('n')\nsage: plot([n^2,exp(n)], xmin=1, xmax=10^5, ymin=1,ymax=10^10)\nverbose 0 (2395: plot.py, generate_plot_points) WARNING: When plotting, failed to evaluate function at 198 points.\nverbose 0 (2395: plot.py, generate_plot_points) Last error message: ''\n```\n\nFYI, the change to loglog/semilog* scale happens only during the very end when `show()` is called. This happens *after* the generation of the plot points. Though I can't understand why semilogy is working fine for you (you still get the warnings though).",
    "created_at": "2012-10-03T13:12:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163874",
    "user": "https://github.com/ppurka"
}
```

It is not a problem with loglog. There is the same problem with normal plots.

```
sage: var('n')
sage: plot([n^2,exp(n)], xmin=1, xmax=10^5, ymin=1,ymax=10^10)
verbose 0 (2395: plot.py, generate_plot_points) WARNING: When plotting, failed to evaluate function at 198 points.
verbose 0 (2395: plot.py, generate_plot_points) Last error message: ''
```

FYI, the change to loglog/semilog* scale happens only during the very end when `show()` is called. This happens *after* the generation of the plot points. Though I can't understand why semilogy is working fine for you (you still get the warnings though).



---

archive/issue_comments_163875.json:
```json
{
    "body": "Replying to [comment:2 ppurka]:\n> FYI, the change to loglog/semilog* scale happens only during the very end when `show()` is called. This happens *after* the generation of the plot points.\n\nReally??? Ouch! In a x log scale one certainly would want to disperse ploting points differently.",
    "created_at": "2012-10-04T10:35:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163875",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:2 ppurka]:
> FYI, the change to loglog/semilog* scale happens only during the very end when `show()` is called. This happens *after* the generation of the plot points.

Really??? Ouch! In a x log scale one certainly would want to disperse ploting points differently.



---

archive/issue_comments_163876.json:
```json
{
    "body": "> > FYI, the change to loglog/semilog* scale happens only during the very end when `show()` is called. This happens *after* the generation of the plot points.\n> \n> Really??? Ouch! In a x log scale one certainly would want to disperse ploting points differently.\nTrue, but that would be another ticket.  And sometimes one would want to plot the same data in two different ways, so we wouldn't want to remove that entirely.",
    "created_at": "2012-10-04T15:39:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163876",
    "user": "https://github.com/kcrisman"
}
```

> > FYI, the change to loglog/semilog* scale happens only during the very end when `show()` is called. This happens *after* the generation of the plot points.
> 
> Really??? Ouch! In a x log scale one certainly would want to disperse ploting points differently.
True, but that would be another ticket.  And sometimes one would want to plot the same data in two different ways, so we wouldn't want to remove that entirely.



---

archive/issue_comments_163877.json:
```json
{
    "body": "Hi!\n\nReplying to [comment:4 kcrisman]:\n> True, but that would be another ticket.\n\nWell, unless there is a quick solution for just the issue stated in this ticket, I am happy recycling it to whatever the right fix should be (taking into account the log scale early or delaying the generation of the evaluation points to `show`).\n\n> And sometimes one would want to plot the same data in two different ways, so we wouldn't want to remove that entirely.\n\nI don't know the current implementation, so there might be technical obstructions I can't see; however, in principle, isn't the data really the function rather than the points? In that case, should'nt the points just be recalculated as needed?",
    "created_at": "2012-10-14T21:19:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163877",
    "user": "https://github.com/nthiery"
}
```

Hi!

Replying to [comment:4 kcrisman]:
> True, but that would be another ticket.

Well, unless there is a quick solution for just the issue stated in this ticket, I am happy recycling it to whatever the right fix should be (taking into account the log scale early or delaying the generation of the evaluation points to `show`).

> And sometimes one would want to plot the same data in two different ways, so we wouldn't want to remove that entirely.

I don't know the current implementation, so there might be technical obstructions I can't see; however, in principle, isn't the data really the function rather than the points? In that case, should'nt the points just be recalculated as needed?



---

archive/issue_comments_163878.json:
```json
{
    "body": "Replying to [comment:5 nthiery]:\n> I don't know the current implementation, so there might be technical obstructions I can't see; however, in principle, isn't the data really the function rather than the points? In that case, should'nt the points just be recalculated as needed?\n\nSuppose you want to plot the points `(0, 1), (1, 10), (2, 100), (3, 1000)`. Then what you could do is send these points to matplotlib and ask it to plot it in a linear scale by using, say, `pyplot.plot(x, y)`. Alternatively, if you want semilogy plot, you could do `pyplot.semilogy(x, y)`, where `x` and `y` are the data points along the x and y axes. Note that we do *not* send the \"linearized\" data points `[0, 1, 2, 3]` (obtained by taking log of `[1, 10, 100, 1000]` to the base 10) as the `y` list to matplotlib.\n\nNow, suppose you want to plot `10**n` for large values of `n`. You would still do the same thing. Find the values of this function in the linear scale and then pass on the computed values to matplotlib to plot it on the logarithmic scale. In either case, the computation of the values of the function is being done on the *linear* scale. And it is this computation that is failing in your examples. As of now, this problem needs a fix even on the linear scale, let alone the log scale.",
    "created_at": "2012-10-15T13:19:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163878",
    "user": "https://github.com/ppurka"
}
```

Replying to [comment:5 nthiery]:
> I don't know the current implementation, so there might be technical obstructions I can't see; however, in principle, isn't the data really the function rather than the points? In that case, should'nt the points just be recalculated as needed?

Suppose you want to plot the points `(0, 1), (1, 10), (2, 100), (3, 1000)`. Then what you could do is send these points to matplotlib and ask it to plot it in a linear scale by using, say, `pyplot.plot(x, y)`. Alternatively, if you want semilogy plot, you could do `pyplot.semilogy(x, y)`, where `x` and `y` are the data points along the x and y axes. Note that we do *not* send the "linearized" data points `[0, 1, 2, 3]` (obtained by taking log of `[1, 10, 100, 1000]` to the base 10) as the `y` list to matplotlib.

Now, suppose you want to plot `10**n` for large values of `n`. You would still do the same thing. Find the values of this function in the linear scale and then pass on the computed values to matplotlib to plot it on the logarithmic scale. In either case, the computation of the values of the function is being done on the *linear* scale. And it is this computation that is failing in your examples. As of now, this problem needs a fix even on the linear scale, let alone the log scale.



---

archive/issue_comments_163879.json:
```json
{
    "body": "In fact, I just realized why you are getting the errors. The problem is with `fast_float`.\n\n```\nsage: set_verbose(1)\nsage: p = plot_loglog(exp(x), (1, 10^5), plot_points=2)\nverbose 1 (2397: plot.py, generate_plot_points)\nUnable to compute f(100000.0) (time = 19.237264)\nsage: exp(100000.0).n()\n2.80666336042612e43429\nsage: from sage.ext.fast_eval import fast_float\nsage: f(x) = exp(x)\nsage: v = f.variables()\nsage: F = fast_float(f, *v)\nsage: F(100000.0)\ninf\n```\n\nMaybe you are better off generating the list of data points by using exact arithmetic in Sage and then passing off the list to `list_plot`.",
    "created_at": "2012-10-15T13:42:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163879",
    "user": "https://github.com/ppurka"
}
```

In fact, I just realized why you are getting the errors. The problem is with `fast_float`.

```
sage: set_verbose(1)
sage: p = plot_loglog(exp(x), (1, 10^5), plot_points=2)
verbose 1 (2397: plot.py, generate_plot_points)
Unable to compute f(100000.0) (time = 19.237264)
sage: exp(100000.0).n()
2.80666336042612e43429
sage: from sage.ext.fast_eval import fast_float
sage: f(x) = exp(x)
sage: v = f.variables()
sage: F = fast_float(f, *v)
sage: F(100000.0)
inf
```

Maybe you are better off generating the list of data points by using exact arithmetic in Sage and then passing off the list to `list_plot`.



---

archive/issue_comments_163880.json:
```json
{
    "body": "> In fact, I just realized why you are getting the errors. The problem is with `fast_float`.\n> {{{\n> sage: from sage.ext.fast_eval import fast_float\n> sage: f(x) = exp(x)\n> sage: v = f.variables()\n> sage: F = fast_float(f, *v)\n> sage: F(100000.0)\n> inf\n> }}}\nHuh, that is not good.\n\n```\nsage: F(709.7)\n1.6549840276802644e+308\nsage: F(709.8)\ninf\n```\n\nThat's as much bisecting as I want to do.  And really, here is what is going on, I suspect.\n\n```\n\nIn [3]: import math\n\nIn [6]: math.exp(709.8)\n---------------------------------------------------------------------------\nOverflowError                             Traceback (most recent call last)\n\n/Users/.../<ipython console> in <module>()\n\nOverflowError: math range error\n\nIn [7]: math.exp(709.7)\nOut[7]: 1.6549840276802644e+308\n```\n\nSo `fast_float` really is doing floats, but we need something better than that.",
    "created_at": "2012-10-15T14:52:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163880",
    "user": "https://github.com/kcrisman"
}
```

> In fact, I just realized why you are getting the errors. The problem is with `fast_float`.
> {{{
> sage: from sage.ext.fast_eval import fast_float
> sage: f(x) = exp(x)
> sage: v = f.variables()
> sage: F = fast_float(f, *v)
> sage: F(100000.0)
> inf
> }}}
Huh, that is not good.

```
sage: F(709.7)
1.6549840276802644e+308
sage: F(709.8)
inf
```

That's as much bisecting as I want to do.  And really, here is what is going on, I suspect.

```

In [3]: import math

In [6]: math.exp(709.8)
---------------------------------------------------------------------------
OverflowError                             Traceback (most recent call last)

/Users/.../<ipython console> in <module>()

OverflowError: math range error

In [7]: math.exp(709.7)
Out[7]: 1.6549840276802644e+308
```

So `fast_float` really is doing floats, but we need something better than that.



---

archive/issue_comments_163881.json:
```json
{
    "body": "Changing component from graphics to basic arithmetic.",
    "created_at": "2012-10-17T01:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163881",
    "user": "https://github.com/kcrisman"
}
```

Changing component from graphics to basic arithmetic.



---

archive/issue_comments_163882.json:
```json
{
    "body": "Changing assignee from jason, was to @aghitza.",
    "created_at": "2012-10-17T01:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163882",
    "user": "https://github.com/kcrisman"
}
```

Changing assignee from jason, was to @aghitza.



---

archive/issue_comments_163883.json:
```json
{
    "body": "The solution of this ticket depends on #15030 and [this ask.sagemath](http://ask.sagemath.org/question/3001/contour_plot-issue-with-large-numbers) thread.\n\nHow? I suppose we can introduce a plot keyword `precision=53` that gets passed on to `fast_callable` and one can increase that to get higher precision but slower plots.",
    "created_at": "2013-09-14T15:04:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13355",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13355#issuecomment-163883",
    "user": "https://github.com/ppurka"
}
```

The solution of this ticket depends on #15030 and [this ask.sagemath](http://ask.sagemath.org/question/3001/contour_plot-issue-with-large-numbers) thread.

How? I suppose we can introduce a plot keyword `precision=53` that gets passed on to `fast_callable` and one can increase that to get higher precision but slower plots.
