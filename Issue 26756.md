# Issue 26756: Allow multiplication of function field elements with differentials from compatible fields

Issue created by migration from https://trac.sagemath.org/ticket/26993

Original creator: @BrentBaccala

Original creation time: 2019-01-02 04:27:11

CC:  klee

Keywords: function field

In the new function field code (Trac #22982), you currently can't multiply function field elements with differentials from a subfield.

For example, in this basic setup:


```
sage: K.<x> = FunctionField(QQ); R.<y> = K[]
sage: L.<y> = K.extension(y^2 - x*y + 4*x^3)
```


`y * y.differential()` works, but `y * x.differential()` doesn't, because there's no way to multiply an element of `L` with a differential from `K`.

The code attached to this ticket fixes that problem.


---

Comment by @BrentBaccala created at 2019-01-02 04:32:24

New commits:


---

Comment by chapoton created at 2019-01-02 12:31:06

Note: the dependency field should be filled with ticket numbers, including #, and not with branch names.


---

Comment by @BrentBaccala created at 2019-01-03 20:32:09

Replying to [comment:2 chapoton]:
> Note: the dependency field should be filled with ticket numbers, including #, and not with branch names.

Corrected.


---

Comment by embray created at 2019-01-15 18:15:21

Retarging tickets optimistically to the next milestone.  If you are responsible for this ticket (either its reporter or owner) and don't believe you are likely to complete this ticket before the next release (8.7) please retarget this ticket's milestone to sage-pending or sage-wishlist.


---

Comment by git created at 2019-04-08 19:40:10

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @BrentBaccala created at 2019-04-08 19:43:18

Changing status from new to needs_review.


---

Comment by git created at 2019-04-11 02:43:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2019-04-16 05:33:48

What is the map from the module of differentials of K into the module of differentials of L that you implement a coercion for?


---

Comment by @BrentBaccala created at 2019-04-16 23:12:59

Replying to [comment:10 klee]:
> What is the map from the module of differentials of K into the module of differentials of L that you implement a coercion for? 

f dx maps to f dx.


```
sage: K.<x> = FunctionField(QQ); R.<y> = K[]
sage: L.<y> = K.extension(y^2 - x*y + 4*x^3)

sage: x*x.differential()
(x) d(x)
sage: (x*x.differential()).parent()
Space of differentials of Rational function field in x over Rational Field

sage: L.space_of_differentials()(x*x.differential())
(x) d(x)
sage: L.space_of_differentials()(x*x.differential()).parent()
Space of differentials of Function field in y defined by y^2 - x*y + 4*x^3
```



---

Comment by klee created at 2019-04-17 04:57:27

Do you also handle the case when  K=k(x), L=K(y), M=L(z) is a tower of function fields, z an element of M, and you take z*dx? What should be the result?


---

Comment by @BrentBaccala created at 2019-04-17 22:22:31

Replying to [comment:12 klee]:
> Do you also handle the case when  K=k(x), L=K(y), M=L(z) is a tower of function fields, z an element of M, and you take z*dx? What should be the result?
> 

No, nested fields don't work right.  For example,


```
sage: K.<x> = FunctionField(QQ)
sage: R.<y> = K[]
sage: L.<y> = K.extension(y^2 - x)
sage: R.<z> = L[]
sage: M.<z> = L.extension(z^2 - y)

sage: M.space_of_differentials()(x.differential())
d(y)
```



Part of the reason for this is that the element constructor (without applying this ticket) doesn't work the way I'd expect:


```
sage: K.space_of_differentials()(x)
d(x)
sage: L.space_of_differentials()(x)
d(x)
sage: M.space_of_differentials()(x)
d(y)
```


What is the rationale for expressing differentials in extensions w.r.t. the generator of the field immediately underneath the extension?  Should there be some way to express differentials w.r.t the rational function field under all of the extensions?

I'm thinking that the result of `M.space_of_differentials()(x)` should be `d(x)` and the differentials should all be expressed w.r.t the base rational function field.  Otherwise, if they're expressed w.r.t. the first underlying field, then the result of `M.space_of_differentials()(x)` should be `2 y d(y)`.

Should the user be able to select which variable is used to express differentials?

For my application, I either want to express differentials w.r.t the base rational function field, or w.r.t. a local uniformizing variable at a specific place.

I'd like to hear some feedback on what klee (and others) think.


---

Comment by klee created at 2019-04-18 04:35:15

Replying to [comment:13 gh-BrentBaccala]:
> Replying to [comment:12 klee]:
> > Do you also handle the case when  K=k(x), L=K(y), M=L(z) is a tower of function fields, z an element of M, and you take z*dx? What should be the result?
> > 
> 
> No, nested fields don't work right. 

So it seems.

> Part of the reason for this is that the element constructor (without applying this ticket) doesn't work the way I'd expect:
> 
> {{{
> sage: K.space_of_differentials()(x)
> d(x)
> sage: L.space_of_differentials()(x)
> d(x)
> sage: M.space_of_differentials()(x)
> d(y)
> }}}

Currently Sage only supports differentials of global function fields (and rational function fields). 

So you may need to enlarge the class of function fields that differentials are supported before you work on this ticket. Or you may clarify the cases for which the coercion works.


---

Comment by @BrentBaccala created at 2019-04-18 20:43:27

Replying to [comment:14 klee]:
> Currently Sage only supports differentials of global function fields (and rational function fields). 
> 
> So you may need to enlarge the class of function fields that differentials are supported before you work on this ticket. Or you may clarify the cases for which the coercion works.

OK, so let me change the example.  How about this:


```
sage: K.<x> = FunctionField(GF(31))
sage: R.<y> = K[]
sage: L.<y> = K.extension(y^2 - x)
sage: R.<z> = L[]
sage: M.<z> = L.extension(z^2 - y)

sage: K.space_of_differentials()(x)
d(x)
sage: L.space_of_differentials()(x)
d(x)
sage: M.space_of_differentials()(x)
d(y)
```


Now `M` is a global function field, right?  Yet we still see the same behavior.  Furthermore...


```
sage: z.differential()
(8/x*z) d(y)
```


Yet dz = 1/(2*z) dy, which doesn't seem to be (8/x*z):


```
sage: 1/(2*z) == (8/x*z)
False
```


What's going on here?


```
sage: M.derivation()
Derivation map:
  From: Function field in z defined by z^2 + 30*y
  To:   Function field in z defined by z^2 + 30*y
  Defn: z |--> 8/x*z
        y |--> 16/x*y
        x |--> 1
```


`M`'s derivation map is w.r.t. x, but `FunctionFieldDifferential_global`'s constructor assumes that it's w.r.t. y, right?


---

Comment by @BrentBaccala created at 2019-04-18 23:24:05

Changing status from needs_review to needs_work.


---

Comment by klee created at 2019-04-19 01:08:38

Replying to [comment:15 gh-BrentBaccala]:
> Replying to [comment:14 klee]:
> > Currently Sage only supports differentials of global function fields (and rational function fields). 
> > 
> > So you may need to enlarge the class of function fields that differentials are supported before you work on this ticket. Or you may clarify the cases for which the coercion works.
> 
> OK, so let me change the example.  How about this:
> 
> {{{
> sage: K.<x> = FunctionField(GF(31))
> sage: R.<y> = K[]
> sage: L.<y> = K.extension(y^2 - x)
> sage: R.<z> = L[]
> sage: M.<z> = L.extension(z^2 - y)
> 
> sage: K.space_of_differentials()(x)
> d(x)
> sage: L.space_of_differentials()(x)
> d(x)
> sage: M.space_of_differentials()(x)
> d(y)
> }}}
> 
> Now `M` is a global function field, right?  

I meant global function fields in sage. They are separable extensions of rational function fields over finite fields. M is not a global function field in sage in this sense.

The erroneous behavior of your example just indicates that to support differentials of extensions of non-rational function fields, some part of the infrastructure needs to be fixed. 

I guess your coercion is not intended just for global functions fields.  But as we saw, based on the current sage, your coercion doesn't work right for tower of function fields.  Then perhaps the scope of your coercion is extensions of rational function fields. I asked you to clarify this.

On the other hand, I think what you are implementing is the natural inclusion of the tensor product $L \otimes_K \Omega_K$ into $\Omega_L$ defined by f*(gdx) -> fg dx for f in L and g, x in K. Then the coercion would work right for towers of function fields once you enlarge the scope of differentials in sage properly. I am curious if you want to do this in this ticket or another ticket.


---

Comment by @BrentBaccala created at 2019-04-19 03:43:17

Replying to [comment:17 klee]:
> The erroneous behavior of your example just indicates that to support differentials of extensions of non-rational function fields, some part of the infrastructure needs to be fixed. 

OK.  I think that's another ticket.

> I guess your coercion is not intended just for global functions fields.  But as we saw, based on the current sage, your coercion doesn't work right for tower of function fields.  Then perhaps the scope of your coercion is extensions of rational function fields. I asked you to clarify this.

No, my coercion is not intended just for global function fields.  I'd like it to work for all of the function fields that can formed using the present code.

> On the other hand, I think what you are implementing is the natural inclusion of the tensor product $L \otimes_K \Omega_K$ into $\Omega_L$ defined by f*(gdx) -> fg dx for f in L and g, x in K. Then the coercion would work right for towers of function fields once you enlarge the scope of differentials in sage properly. I am curious if you want to do this in this ticket or another ticket.
> 

I'm thinking that I'll open another ticket to revise the differential code so that it supports all of the existing function fields, then come back to this ticket to see if any changes are needed here.

I haven't created that new ticket yet.  Do you want me to add you to the cc line when I do?


---

Comment by klee created at 2019-04-19 04:45:49

Replying to [comment:18 gh-BrentBaccala]:
> I'm thinking that I'll open another ticket to revise the differential code so that it supports all of the existing function fields, then come back to this ticket to see if any changes are needed here.

Nice.
 
> I haven't created that new ticket yet.  Do you want me to add you to the cc line when I do?

Ok. No one asks for that these days :-)


---

Comment by @BrentBaccala created at 2019-04-22 18:43:38

Replying to [comment:18 gh-BrentBaccala]:
> I'm thinking that I'll open another ticket to revise the differential code so that it supports all of the existing function fields, then come back to this ticket to see if any changes are needed here.

That ticket is now #27712


---

Comment by git created at 2019-04-24 00:27:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2019-04-24 00:37:41

Changing status from needs_work to needs_review.


---

Comment by git created at 2019-04-26 00:50:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-06-04 03:08:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-06-14 01:36:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2019-06-14 01:38:44

I worked on your code and could simplify a lot the code. 

Positive review on your part of the code.


---

Comment by klee created at 2019-06-25 07:27:13

Needs review on reviewer's part of the code.


---

Comment by tscrim created at 2019-06-26 10:05:51

I thought the coercion frame took care of coercions of actions. In particular, I would think you do not need to implement that `_acted_upon_` given that you (now) have the coercion map.


---

Comment by klee created at 2019-06-26 11:06:03

Replying to [comment:30 tscrim]:
> I thought the coercion frame took care of coercions of actions. In particular, I would think you do not need to implement that `_acted_upon_` given that you (now) have the coercion map.

There is no action to be discovered by the coercion frame even though the coercion map is there. 

For y*dx, where x is in a function field F and y is in its extension E, which is the case that this ticket deals with, the action on the differential dx is **not** constructed from `_rmul_` automatically because y is not in F.


So I implemented one.


---

Comment by tscrim created at 2019-06-26 14:27:19

Hmm...that sounds like a pushout construction is missing. Well, that could be done on a followup as this works.


---

Comment by tscrim created at 2019-06-26 14:27:19

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2019-06-27 20:13:44

Resolution: fixed
