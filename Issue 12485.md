# Issue 12485: Better implementation of Frobenius automorphism

Issue created by migration from https://trac.sagemath.org/ticket/12657

Original creator: roed

Original creation time: 2012-03-12 19:40:12

Assignee: roed

CC:  jpflori caruso

The Frobenius automorphism of _p_-adic fields was added in #8241.  The implementation is horribly inefficient and should use Hensel lifting directly rather than decomposing into a list of Teichmuller representatives.

This optimization should probably wait on #12555.


---

Comment by roed created at 2014-01-06 21:24:41

The method that needs to be improved is `frobenius_unram` in `src/sage/libs/linkages/padics/unram_shared.pxi`.  This may want to wait on some more p-adic polynomial developments, but could also be done now.


---

Comment by roed created at 2017-07-17 17:38:51

Changing keywords from "" to "sd87".


---

Comment by git created at 2017-07-19 21:02:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-07-19 21:38:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by asteele created at 2017-07-20 02:07:42

Changing status from new to needs_review.


---

Comment by gpark created at 2017-07-20 16:02:26

Changing status from needs_review to positive_review.


---

Comment by gpark created at 2017-07-20 16:02:26

All test passed.


---

Comment by tscrim created at 2017-07-20 23:17:16

Changing status from positive_review to needs_work.


---

Comment by tscrim created at 2017-07-20 23:17:16

Author name missing.


---

Comment by asteele created at 2017-07-20 23:30:42

Changing status from needs_work to needs_review.


---

Comment by caruso created at 2017-07-21 03:40:42

I don't understand why you need to redo Newton iteration in `frobenius_unram`.

Alternatively, instead of storing the powers of `frob_a` in a dictonary, you can use Horner scheme.


---

Comment by asteele created at 2017-07-21 04:10:14

We redid the Newton iteration in _frob_gen() because that was easier (for me) than finding & adapting an existing method. The only method I see is .hensel_lift(p,e) in  sage.rings.polynomial.polynomial_element.Polynomial, and I don't see the advantage of adapting that.

As for the horner scheme--our experiments suggested that the expensive operation was multiplication (in large degree unramified extensions). For example, In R.<a> = Zq(37<sup>100</sup>,100), addition of two random elements takes ~80 micro seconds, while muliplication takes ~80 milli seconds. My naive guess is that cacheing the powers of frob_a in the dictionary and paying the cost of addition will be much faster than paying the repeated cost of multiplication. In any case, storing the powers in a dict or computing the polynomials via horner are much faster than the previous method of computing frobenius.


---

Comment by caruso created at 2017-07-21 05:50:58

Replying to [comment:16 asteele]:
> We redid the Newton iteration in _frob_gen() because that was easier (for me) than finding & adapting an existing method. The only method I see is .hensel_lift(p,e) in  sage.rings.polynomial.polynomial_element.Polynomial, and I don't see the advantage of adapting that.

I wanted to say that you redid Newton iteration in `_frob_gen()` and in `frobenius_unram()`. Is there a reason for that? 

> As for the horner scheme--our experiments suggested that the expensive operation was multiplication (in large degree unramified extensions). For example, In R.<a> = Zq(37<sup>100</sup>,100), addition of two random elements takes ~80 micro seconds, while muliplication takes ~80 milli seconds. My naive guess is that cacheing the powers of frob_a in the dictionary and paying the cost of addition will be much faster than paying the repeated cost of multiplication. In any case, storing the powers in a dict or computing the polynomials via horner are much faster than the previous method of computing frobenius.

I don't understand why Horner method is more costly in terms of multiplications. On the contrary, I think that it is (a bit) less costly.


---

Comment by git created at 2017-07-21 09:07:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by asteele created at 2017-07-21 10:16:36

Aha, thanks for catching that! That was a mistake, and has been fixed.

Replying to [comment:18 caruso]:
> Replying to [comment:16 asteele]:
> > We redid the Newton iteration in _frob_gen() because that was easier (for me) than finding & adapting an existing method. The only method I see is .hensel_lift(p,e) in  sage.rings.polynomial.polynomial_element.Polynomial, and I don't see the advantage of adapting that.
> 
> I wanted to say that you redid Newton iteration in `_frob_gen()` and in `frobenius_unram()`. Is there a reason for that? 
>

I just tested the Horner method and it is roughly 10 times slower in Zq(5<sup>100</sup>,100). It seems that multiplying elements of the extension by elements in Q_p is very fast, but multiplying elements in the extension is generally slow. Cacheing the expensive multiplications  (and maybe performing more multiplications over all) appears to be a good strategy in very high degree.

> > As for the horner scheme--our experiments suggested that the expensive operation was multiplication (in large degree unramified extensions). For example, In R.<a> = Zq(37<sup>100</sup>,100), addition of two random elements takes ~80 micro seconds, while muliplication takes ~80 milli seconds. My naive guess is that cacheing the powers of frob_a in the dictionary and paying the cost of addition will be much faster than paying the repeated cost of multiplication. In any case, storing the powers in a dict or computing the polynomials via horner are much faster than the previous method of computing frobenius.
> 
> I don't understand why Horner method is more costly in terms of multiplications. On the contrary, I think that it is (a bit) less costly.


---

Comment by caruso created at 2017-07-21 14:47:30

Let me disagree :-).

On my laptop, with your current implementation, it takes about 1s to compute the Frobenius of a random element over `Zq(5^100,100)` (without taking in account the computation of the Frobenius of the generator) while it takes less than 0.1s using the Horner scheme (cf implementation attached). It is then about 10 times faster.

By the way, as far as I understand, an element of Zq is representated as P(a) where a is the generator and P is a polynomial over Z. What we do currently is to write all the coefficients of P in radix p (this is done by the method `list`), and then just after recompose them into actual integers. It would be better to avoid this useful computation and access directly to the coefficients of P but I'm not sure it's easy to do it.


---

Comment by git created at 2017-07-21 14:48:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by asteele created at 2017-07-22 16:00:31

Fantastic! I see your implementation of Horner is much better than what I was doing, and I have reproduced the performance increase on k8s: After `_frob_gen()` is cached, your scheme computes frobenius of random elements of ` Zq(5^100,100) ` in approximately 60 ms, while the previous method was taking 800ms. Your current implementation is definitely the way to go (and is roughly 1000 times faster than what is currently in Sage)

Replying to [comment:21 caruso]:
> Let me disagree :-).
> 
> On my laptop, with your current implementation, it takes about 1s to compute the Frobenius of a random element over `Zq(5^100,100)` (without taking in account the computation of the Frobenius of the generator) while it takes less than 0.1s using the Horner scheme (cf implementation attached). It is then about 10 times faster.
> 
> By the way, as far as I understand, an element of Zq is representated as P(a) where a is the generator and P is a polynomial over Z. What we do currently is to write all the coefficients of P in radix p (this is done by the method `list`), and then just after recompose them into actual integers. It would be better to avoid this useful computation and access directly to the coefficients of P but I'm not sure it's easy to do it.


---

Comment by chapoton created at 2017-07-23 08:17:07

maybe the iteration `+    for i in range(len(coefs)):`
could be replaced by just `+    for ci in coefs:` ?


---

Comment by asteele created at 2017-07-25 20:16:38

I've cleaned up the code a little bit, removing the previous method (which contained the non-pythonic iteration `for i in range(len(coefs))` ). Code now uses Xavier's implementation of Horner' scheme, passes all doctests and, I think, is ready for review.
----
New commits:


---

Comment by caruso created at 2017-07-28 18:06:42

Changing status from needs_review to positive_review.


---

Comment by caruso created at 2017-07-28 18:06:42

Ok, positive review (through it would be even faster to use the method `polynomial` of ticket #14825 but it still needs work).


---

Comment by vbraun created at 2017-07-29 19:27:02

Resolution: fixed
