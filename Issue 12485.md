# Issue 12485: Better implementation of Frobenius automorphism

archive/issues_012485.json:
```json
{
    "body": "Assignee: @roed314\n\nCC:  jpflori @xcaruso\n\nThe Frobenius automorphism of *p*-adic fields was added in #8241.  The implementation is horribly inefficient and should use Hensel lifting directly rather than decomposing into a list of Teichmuller representatives.\n\nThis optimization should probably wait on #12555.\n\nIssue created by migration from https://trac.sagemath.org/ticket/12657\n\n",
    "created_at": "2012-03-12T19:40:12Z",
    "labels": [
        "padics",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.1",
    "title": "Better implementation of Frobenius automorphism",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/12485",
    "user": "@roed314"
}
```
Assignee: @roed314

CC:  jpflori @xcaruso

The Frobenius automorphism of *p*-adic fields was added in #8241.  The implementation is horribly inefficient and should use Hensel lifting directly rather than decomposing into a list of Teichmuller representatives.

This optimization should probably wait on #12555.

Issue created by migration from https://trac.sagemath.org/ticket/12657





---

archive/issue_comments_147843.json:
```json
{
    "body": "The method that needs to be improved is `frobenius_unram` in `src/sage/libs/linkages/padics/unram_shared.pxi`.  This may want to wait on some more p-adic polynomial developments, but could also be done now.",
    "created_at": "2014-01-06T21:24:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147843",
    "user": "@roed314"
}
```

The method that needs to be improved is `frobenius_unram` in `src/sage/libs/linkages/padics/unram_shared.pxi`.  This may want to wait on some more p-adic polynomial developments, but could also be done now.



---

archive/issue_comments_147844.json:
```json
{
    "body": "Changing keywords from \"\" to \"sd87\".",
    "created_at": "2017-07-17T17:38:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147844",
    "user": "@roed314"
}
```

Changing keywords from "" to "sd87".



---

archive/issue_comments_147845.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-19T21:02:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147845",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_147846.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-19T21:38:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147846",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_147847.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-07-20T02:07:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147847",
    "user": "@andersteele"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_147848.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-07-20T16:02:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147848",
    "user": "gpark"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_147849.json:
```json
{
    "body": "All test passed.",
    "created_at": "2017-07-20T16:02:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147849",
    "user": "gpark"
}
```

All test passed.



---

archive/issue_comments_147850.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2017-07-20T23:17:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147850",
    "user": "@tscrim"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_147851.json:
```json
{
    "body": "Author name missing.",
    "created_at": "2017-07-20T23:17:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147851",
    "user": "@tscrim"
}
```

Author name missing.



---

archive/issue_comments_147852.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-07-20T23:30:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147852",
    "user": "@andersteele"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_147853.json:
```json
{
    "body": "I don't understand why you need to redo Newton iteration in `frobenius_unram`.\n\nAlternatively, instead of storing the powers of `frob_a` in a dictonary, you can use Horner scheme.",
    "created_at": "2017-07-21T03:40:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147853",
    "user": "@xcaruso"
}
```

I don't understand why you need to redo Newton iteration in `frobenius_unram`.

Alternatively, instead of storing the powers of `frob_a` in a dictonary, you can use Horner scheme.



---

archive/issue_comments_147854.json:
```json
{
    "body": "We redid the Newton iteration in _frob_gen() because that was easier (for me) than finding & adapting an existing method. The only method I see is .hensel_lift(p,e) in  sage.rings.polynomial.polynomial_element.Polynomial, and I don't see the advantage of adapting that.\n\nAs for the horner scheme--our experiments suggested that the expensive operation was multiplication (in large degree unramified extensions). For example, In R.<a> = Zq(37<sup>100</sup>,100), addition of two random elements takes ~80 micro seconds, while muliplication takes ~80 milli seconds. My naive guess is that cacheing the powers of frob_a in the dictionary and paying the cost of addition will be much faster than paying the repeated cost of multiplication. In any case, storing the powers in a dict or computing the polynomials via horner are much faster than the previous method of computing frobenius.",
    "created_at": "2017-07-21T04:10:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147854",
    "user": "@andersteele"
}
```

We redid the Newton iteration in _frob_gen() because that was easier (for me) than finding & adapting an existing method. The only method I see is .hensel_lift(p,e) in  sage.rings.polynomial.polynomial_element.Polynomial, and I don't see the advantage of adapting that.

As for the horner scheme--our experiments suggested that the expensive operation was multiplication (in large degree unramified extensions). For example, In R.<a> = Zq(37<sup>100</sup>,100), addition of two random elements takes ~80 micro seconds, while muliplication takes ~80 milli seconds. My naive guess is that cacheing the powers of frob_a in the dictionary and paying the cost of addition will be much faster than paying the repeated cost of multiplication. In any case, storing the powers in a dict or computing the polynomials via horner are much faster than the previous method of computing frobenius.



---

archive/issue_comments_147855.json:
```json
{
    "body": "Replying to [comment:16 asteele]:\n> We redid the Newton iteration in _frob_gen() because that was easier (for me) than finding & adapting an existing method. The only method I see is .hensel_lift(p,e) in  sage.rings.polynomial.polynomial_element.Polynomial, and I don't see the advantage of adapting that.\n\nI wanted to say that you redid Newton iteration in `_frob_gen()` and in `frobenius_unram()`. Is there a reason for that? \n\n> As for the horner scheme--our experiments suggested that the expensive operation was multiplication (in large degree unramified extensions). For example, In R.<a> = Zq(37<sup>100</sup>,100), addition of two random elements takes ~80 micro seconds, while muliplication takes ~80 milli seconds. My naive guess is that cacheing the powers of frob_a in the dictionary and paying the cost of addition will be much faster than paying the repeated cost of multiplication. In any case, storing the powers in a dict or computing the polynomials via horner are much faster than the previous method of computing frobenius.\n\nI don't understand why Horner method is more costly in terms of multiplications. On the contrary, I think that it is (a bit) less costly.",
    "created_at": "2017-07-21T05:50:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147855",
    "user": "@xcaruso"
}
```

Replying to [comment:16 asteele]:
> We redid the Newton iteration in _frob_gen() because that was easier (for me) than finding & adapting an existing method. The only method I see is .hensel_lift(p,e) in  sage.rings.polynomial.polynomial_element.Polynomial, and I don't see the advantage of adapting that.

I wanted to say that you redid Newton iteration in `_frob_gen()` and in `frobenius_unram()`. Is there a reason for that? 

> As for the horner scheme--our experiments suggested that the expensive operation was multiplication (in large degree unramified extensions). For example, In R.<a> = Zq(37<sup>100</sup>,100), addition of two random elements takes ~80 micro seconds, while muliplication takes ~80 milli seconds. My naive guess is that cacheing the powers of frob_a in the dictionary and paying the cost of addition will be much faster than paying the repeated cost of multiplication. In any case, storing the powers in a dict or computing the polynomials via horner are much faster than the previous method of computing frobenius.

I don't understand why Horner method is more costly in terms of multiplications. On the contrary, I think that it is (a bit) less costly.



---

archive/issue_comments_147856.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-21T09:07:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147856",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_147857.json:
```json
{
    "body": "Aha, thanks for catching that! That was a mistake, and has been fixed.\n\nReplying to [comment:18 caruso]:\n> Replying to [comment:16 asteele]:\n> > We redid the Newton iteration in _frob_gen() because that was easier (for me) than finding & adapting an existing method. The only method I see is .hensel_lift(p,e) in  sage.rings.polynomial.polynomial_element.Polynomial, and I don't see the advantage of adapting that.\n> \n> I wanted to say that you redid Newton iteration in `_frob_gen()` and in `frobenius_unram()`. Is there a reason for that? \n>\n\nI just tested the Horner method and it is roughly 10 times slower in Zq(5<sup>100</sup>,100). It seems that multiplying elements of the extension by elements in Q_p is very fast, but multiplying elements in the extension is generally slow. Cacheing the expensive multiplications  (and maybe performing more multiplications over all) appears to be a good strategy in very high degree.\n\n> > As for the horner scheme--our experiments suggested that the expensive operation was multiplication (in large degree unramified extensions). For example, In R.<a> = Zq(37<sup>100</sup>,100), addition of two random elements takes ~80 micro seconds, while muliplication takes ~80 milli seconds. My naive guess is that cacheing the powers of frob_a in the dictionary and paying the cost of addition will be much faster than paying the repeated cost of multiplication. In any case, storing the powers in a dict or computing the polynomials via horner are much faster than the previous method of computing frobenius.\n> \n> I don't understand why Horner method is more costly in terms of multiplications. On the contrary, I think that it is (a bit) less costly.",
    "created_at": "2017-07-21T10:16:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147857",
    "user": "@andersteele"
}
```

Aha, thanks for catching that! That was a mistake, and has been fixed.

Replying to [comment:18 caruso]:
> Replying to [comment:16 asteele]:
> > We redid the Newton iteration in _frob_gen() because that was easier (for me) than finding & adapting an existing method. The only method I see is .hensel_lift(p,e) in  sage.rings.polynomial.polynomial_element.Polynomial, and I don't see the advantage of adapting that.
> 
> I wanted to say that you redid Newton iteration in `_frob_gen()` and in `frobenius_unram()`. Is there a reason for that? 
>

I just tested the Horner method and it is roughly 10 times slower in Zq(5<sup>100</sup>,100). It seems that multiplying elements of the extension by elements in Q_p is very fast, but multiplying elements in the extension is generally slow. Cacheing the expensive multiplications  (and maybe performing more multiplications over all) appears to be a good strategy in very high degree.

> > As for the horner scheme--our experiments suggested that the expensive operation was multiplication (in large degree unramified extensions). For example, In R.<a> = Zq(37<sup>100</sup>,100), addition of two random elements takes ~80 micro seconds, while muliplication takes ~80 milli seconds. My naive guess is that cacheing the powers of frob_a in the dictionary and paying the cost of addition will be much faster than paying the repeated cost of multiplication. In any case, storing the powers in a dict or computing the polynomials via horner are much faster than the previous method of computing frobenius.
> 
> I don't understand why Horner method is more costly in terms of multiplications. On the contrary, I think that it is (a bit) less costly.



---

archive/issue_comments_147858.json:
```json
{
    "body": "Let me disagree :-).\n\nOn my laptop, with your current implementation, it takes about 1s to compute the Frobenius of a random element over `Zq(5^100,100)` (without taking in account the computation of the Frobenius of the generator) while it takes less than 0.1s using the Horner scheme (cf implementation attached). It is then about 10 times faster.\n\nBy the way, as far as I understand, an element of Zq is representated as P(a) where a is the generator and P is a polynomial over Z. What we do currently is to write all the coefficients of P in radix p (this is done by the method `list`), and then just after recompose them into actual integers. It would be better to avoid this useful computation and access directly to the coefficients of P but I'm not sure it's easy to do it.",
    "created_at": "2017-07-21T14:47:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147858",
    "user": "@xcaruso"
}
```

Let me disagree :-).

On my laptop, with your current implementation, it takes about 1s to compute the Frobenius of a random element over `Zq(5^100,100)` (without taking in account the computation of the Frobenius of the generator) while it takes less than 0.1s using the Horner scheme (cf implementation attached). It is then about 10 times faster.

By the way, as far as I understand, an element of Zq is representated as P(a) where a is the generator and P is a polynomial over Z. What we do currently is to write all the coefficients of P in radix p (this is done by the method `list`), and then just after recompose them into actual integers. It would be better to avoid this useful computation and access directly to the coefficients of P but I'm not sure it's easy to do it.



---

archive/issue_comments_147859.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-07-21T14:48:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147859",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_147860.json:
```json
{
    "body": "Fantastic! I see your implementation of Horner is much better than what I was doing, and I have reproduced the performance increase on k8s: After `_frob_gen()` is cached, your scheme computes frobenius of random elements of ` Zq(5^100,100) ` in approximately 60 ms, while the previous method was taking 800ms. Your current implementation is definitely the way to go (and is roughly 1000 times faster than what is currently in Sage)\n\nReplying to [comment:21 caruso]:\n> Let me disagree :-).\n> \n> On my laptop, with your current implementation, it takes about 1s to compute the Frobenius of a random element over `Zq(5^100,100)` (without taking in account the computation of the Frobenius of the generator) while it takes less than 0.1s using the Horner scheme (cf implementation attached). It is then about 10 times faster.\n> \n> By the way, as far as I understand, an element of Zq is representated as P(a) where a is the generator and P is a polynomial over Z. What we do currently is to write all the coefficients of P in radix p (this is done by the method `list`), and then just after recompose them into actual integers. It would be better to avoid this useful computation and access directly to the coefficients of P but I'm not sure it's easy to do it.",
    "created_at": "2017-07-22T16:00:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147860",
    "user": "@andersteele"
}
```

Fantastic! I see your implementation of Horner is much better than what I was doing, and I have reproduced the performance increase on k8s: After `_frob_gen()` is cached, your scheme computes frobenius of random elements of ` Zq(5^100,100) ` in approximately 60 ms, while the previous method was taking 800ms. Your current implementation is definitely the way to go (and is roughly 1000 times faster than what is currently in Sage)

Replying to [comment:21 caruso]:
> Let me disagree :-).
> 
> On my laptop, with your current implementation, it takes about 1s to compute the Frobenius of a random element over `Zq(5^100,100)` (without taking in account the computation of the Frobenius of the generator) while it takes less than 0.1s using the Horner scheme (cf implementation attached). It is then about 10 times faster.
> 
> By the way, as far as I understand, an element of Zq is representated as P(a) where a is the generator and P is a polynomial over Z. What we do currently is to write all the coefficients of P in radix p (this is done by the method `list`), and then just after recompose them into actual integers. It would be better to avoid this useful computation and access directly to the coefficients of P but I'm not sure it's easy to do it.



---

archive/issue_comments_147861.json:
```json
{
    "body": "maybe the iteration `+    for i in range(len(coefs)):`\ncould be replaced by just `+    for ci in coefs:` ?",
    "created_at": "2017-07-23T08:17:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147861",
    "user": "@fchapoton"
}
```

maybe the iteration `+    for i in range(len(coefs)):`
could be replaced by just `+    for ci in coefs:` ?



---

archive/issue_comments_147862.json:
```json
{
    "body": "I've cleaned up the code a little bit, removing the previous method (which contained the non-pythonic iteration `for i in range(len(coefs))` ). Code now uses Xavier's implementation of Horner' scheme, passes all doctests and, I think, is ready for review.\n----\nNew commits:",
    "created_at": "2017-07-25T20:16:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147862",
    "user": "@andersteele"
}
```

I've cleaned up the code a little bit, removing the previous method (which contained the non-pythonic iteration `for i in range(len(coefs))` ). Code now uses Xavier's implementation of Horner' scheme, passes all doctests and, I think, is ready for review.
----
New commits:



---

archive/issue_comments_147863.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-07-28T18:06:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147863",
    "user": "@xcaruso"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_147864.json:
```json
{
    "body": "Ok, positive review (through it would be even faster to use the method `polynomial` of ticket #14825 but it still needs work).",
    "created_at": "2017-07-28T18:06:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147864",
    "user": "@xcaruso"
}
```

Ok, positive review (through it would be even faster to use the method `polynomial` of ticket #14825 but it still needs work).



---

archive/issue_comments_147865.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-07-29T19:27:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12485",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12485#issuecomment-147865",
    "user": "@vbraun"
}
```

Resolution: fixed
