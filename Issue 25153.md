# Issue 25153: multivariate factorization over QQbar

Issue created by migration from Trac.

Original creator: @BrentBaccala

Original creation time: 2018-05-17 21:44:34

CC:  @tom111

We can currently (#8544) factor univariate polynomials over QQbar:


```
sage: R.<x>=QQbar[]
sage: (x^2+1).factor()
(x - I) * (x + I)
```


We can factor over multivariate rings, if the polynomial is actually univariate:


```
sage: R.<x,y>=QQbar[]
sage: (x^2+1).factor()
(x - I) * (x + I)
```


But we can't do full "absolute factorization" (that's what it's called in the literature):


```
sage: R.<x,y>=QQbar[]
sage: (x^2+y^2).factor()
...
NotImplementedError: proof = True factorization not implemented.  Call factor with proof=False.
sage: (x^2+y^2).factor(proof=False)
...
TypeError: no conversion of this ring to a Singular ring defined
```


I was going to implement this using Singular's `absfact.lib`, but then I realized that those routines only work for rings over Q (or transcendental extensions thereof), and not over number fields.

So, it's not just as easy as calling `absFactorize`.

I flagged it `major` because polynomial factorization is a fundamental feature that blocks the implementation of other things, like primary decomposition of ideals.


---

Comment by @BrentBaccala created at 2018-05-18 19:47:47

Changing status from new to needs_review.


---

Comment by @BrentBaccala created at 2018-05-18 19:47:47

I added code to call Singular's `absFactorize` if the polynomial's coefficients are in `QQ`.

Here's what's now possible:


```
sage: R.<x,y> = QQbar[]

sage: L = (x^2+y^2).factor()
sage: L
((-1*I)*x - y) * (1*I*x - y)
sage: L.value()
x^2 + y^2

sage: p = (-7*x^2 + 2*x*y^2 + 6*x + y^4 + 14*y^2 + 47)*(5*x^2+y^2)^3*(x-y)^4
sage: F = p.factor()
sage: F
...
sage: F.value() == p
True
```


But something like this still doesn't work (because the coefficients aren't in `QQ`):


```
sage: (x+QQbar(sqrt(2))*y).factor()
```


It's something, which is better than nothing, so I think we should move it towards `master`, but there's still a lot of work to be done before this ticket is closed.
----
New commits:


---

Comment by tscrim created at 2018-05-19 03:54:59

I agree that small improvements are good. We can always do followup tickets to add more functionality. I do have some comments:

Can we use `libsingular` instead of calls to `singular` (which uses the pexpect interface and is much slower)?

Doc tweaks:

```diff
         ALGORITHM:
 
-        Uses Singular's `absfact` library.
+        Uses Singular's ``absfact`` library.
 
-        TODO:
+        .. TODO::
 
-        Implement absolute factorization over number fields
+            Implement absolute factorization over number fields.
```

Also if you could split the long output line so that it is at most ~80 chars per line.

Instead of `elem_map`, you could just use `elem_dict.__getitem__`.

I don't see the need for the internal functions `polynomial_map` and `reverse_polynomial_map`. These little trivial functions make the code harder to follow.

In Python, usually `assert`s are with spaces, e.g., `assert minpoly.degree() == 0`.


---

Comment by @BrentBaccala created at 2018-05-19 04:14:15

Changing status from needs_review to needs_work.


---

Comment by git created at 2018-05-24 01:59:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2018-05-24 02:12:05

Over the weekend I remembered a technique that I read years ago for factoring over a number field - factor the norm of the polynomial, which has rational coefficients and is a multiple of the original polynomial.

So, this ticket is moving towards `closed` more quickly that I had thought possible.  I think it can now factor any polynomial over `QQbar`.

The algorithm is tricky enough that I'm planning to write up a short paper describing it, post it on arxiv, and link to it from the documentation.  If anybody has a better suggestion for how to incorporate a three page paper explaining the algorithm of a Sage method, please let me know.

I took most of `tscrim`'s suggestions, but I can't figure out how to access a Singular variable from `libsingular`.  I posted a [question](https://ask.sagemath.org/question/42413) on asksage, but so far no answer.

I also intend to implement factorization over `AA` before flipping this ticket to `needs_review`.


---

Comment by git created at 2018-06-14 03:40:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-06-14 03:46:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2018-06-14 20:01:04

Changing status from needs_work to needs_review.


---

Comment by @BrentBaccala created at 2018-06-14 20:01:04

Still haven't figured out how to access the Singular variable from `libsingular`; got an answer to that [SageMath question](https://ask.sagemath.org/question/42413) that made sense, but `nbruin` (the responder) said that it was "tricky" and he was right.

I spent two weeks trying to figure out to make this code work without doing division in polynomial rings over `QQbar` but it's a lot harder than I thought.  I'm attaching a PDF that describes the progress I've made and the problems that I've had.

Right now, the code is fairly straightforward, but does require polynomial division over `QQbar`, and therefore requires Trac #25351 to be applied before it works.  I've spent enough time trying to break that dependency, so I'm flipping this ticket to `needs_review` and leaving it the way it is.  See the attached PDF for more details.


---

Attachment

I didn't realize that my suggestion would have been so complicated. Thank you for looking into it. I have two small additional nitpicks, but otherwise this ticket is a positive review assuming #25351 (which I cannot review as that is much more involved mathematically, you should cc some people who work more in that area, such as jdemeyer).

You do not need to create a list:

```diff
norm_f = prod([numfield_f.map_coefficients(h) for h in numfield.embeddings(QQbar)]).change_ring(QQ)
norm_f = prod(numfield_f.map_coefficients(h) for h in numfield.embeddings(QQbar)).change_ring(QQ)
```



```diff
-        REFERENCE::
+        REFERENCES:
 
-            Geddes, et. al, "Algorithms for Computer Algebra", Section 8.8
+        - Geddes, et. al, "Algorithms for Computer Algebra", Section 8.8
```

although I think it would be better to reference the book in the master ref file and use `- [Geddes1234]_ Section 8.8` as the reference.


---

Comment by nbruin created at 2018-06-15 16:09:21

If at all possible, you'll probably want to avoid computing norms by multiplying complex embeddings together. Especially when you have your polynomial over a number field, it's probably much better to avoid floats altogether. For instance, if your number field is given as K=QQ[t]/(h(t)) (with h(t) monic) and you have a polynomial f(x) in K[x], then you can represent your polynomial as F(x,t) in QQ[x,t], via the isomorphism K[x] ~ Q[x,t]/(h(t)). Then you have that

Norm_(K[x]/Q[x]) (f) = Resultant(F,h,t)

Code for computing resultants is usually quite optimized. You can experiment a bit to see which approach works best, but I'd expect the resultant to work quite well.


---

Comment by git created at 2018-06-18 02:32:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2018-06-18 02:36:48

I made the changes suggested by tscrim and nbruin; thanks for your feedback.

Using the resultant was more of a pain that I thought it should be.  The difficulty lay mainly in needing to introduce a new variable, different from the others.  If anybody can suggest a better way that what I came up with, please let me know.


---

Comment by nbruin created at 2018-06-18 06:11:39

Variable names might be haunting us here:

```
sage: k=NumberField(x^2+1,"x")
sage: R=PolynomialRing(k,"x,y")
sage: P=PolynomialRing(QQ,k.gens()+R.gens())
ValueError: variable name 'x' appears more than once
```

Unless you can guarantee the variable names of the number field and the polynomial ring aren't clashing, it seems you cannot go about the problem this way. While it would be reasonable to assume that a user wouldn't intentionally throw this kind of awful naming at you, it's quite conceivable that automatic code would end up doing something like this. Example:

```
sage: matrix(k,2,2,[k.0,0,0,1]).charpoly()
x^2 + (-x - 1)*x + x
```

So it would seem the names of your variables for the trivariate ring should be unrelated to the names that occur for the others. Assuming you have a polynomial g in a ring P over a number field k over QQ, I think you can do your conversion with something along the lines of

```
R=g.parent()
k=R.base_ring()
P=PolynomialRing(QQ,len(k.gens()+R.gens()),'T')   
G=sum(P({(0,)+tuple(k):1})*v.polynomial()(P.0) for k,v in g.dict().iteritems())
NG=G.resultant(k.polynomial()(P.0),P.0)
RQ=PolynomialRing(QQ,R.gens())
NGQ=NG((0,)+RQ.gens())
```

Doing your conversions like this has the advantage that you don't rely on names of generators at all.


---

Comment by git created at 2018-06-19 04:25:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2018-06-19 04:27:36

OK, I re-coded it the way nbruin suggested.


---

Comment by nbruin created at 2018-06-19 05:54:48


```
+            norm_f = sum(norm_ring({tuple(k)[1:]:v})
+                         for k,v in norm_flat.dict().iteritems())
```

Please don't think that unpacking a polynomial into a dictionary is the best way of handling it! To "lift" number field elements, I didn't see another way, but in this case

```
norm_f = norm_flat((0,)+norm_ring.gens())
```

would work just fine, as far as I can see. If you have a good reason to use the dict upacking (is it faster?) then it's fine, of course; but otherwise using the simpler code is probably preferable.


---

Comment by git created at 2018-06-19 16:30:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2018-06-19 16:41:23

I thought there had to a better way to do it!


---

Attachment


---

Comment by git created at 2018-12-09 03:27:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-04-19 03:17:05

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2019-06-06 20:05:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-06-11 21:11:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-26 00:47:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-09-26 01:20:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-10-27 16:45:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2019-10-27 23:52:31

Two minor things: The first is the `.. TODO::` block should be indented. The second is more stylistic, but I would avoid the blankline after the start of the `for` loops.


---

Comment by git created at 2019-10-28 00:35:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @BrentBaccala created at 2019-10-28 00:36:55

Replying to [comment:28 tscrim]:
> Two minor things: The first is the `.. TODO::` block should be indented. The second is more stylistic, but I would avoid the blankline after the start of the `for` loops.

OK, done.

I didn't remove the blank lines on the second for loop because it's so long, I feel the blank lines improve it readability.


---

Comment by tscrim created at 2019-10-28 02:28:51

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2019-10-28 02:28:51

Thanks. I disagree about the space because I have never really seen that elsewhere in Python code and it looks strange to be because of that. Yet, I don't think it is important enough to hold up the ticket.


---

Comment by vbraun created at 2019-10-30 23:47:53

Resolution: fixed
