# Issue 19820: Add iterator to DisjointSet class

Issue created by migration from Trac.

Original creator: jmantysalo

Original creation time: 2016-02-15 17:54:12

CC:  slabbe

This small patch enables for example


```
D = DisjointSet('abcd'); D.union('b','c')
for part in D: pass
```




---

Comment by jmantysalo created at 2016-02-15 17:55:52

An oneliner. At least works, but there might be places for optimizations.
----
New commits:


---

Comment by jmantysalo created at 2016-02-15 17:55:52

Changing status from new to needs_review.


---

Comment by tscrim created at 2016-02-15 20:42:31

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2016-02-15 20:42:31

LGTM.


---

Comment by slabbe created at 2016-02-16 10:08:52

I now remember why I did not coded the `__iter__`. It is because the two basic and efficient methods of this data structure are join and find and they are done lazyly. Lazyly in the sense that we you join the class of an element a with the class of an element b, then the parent of the root of a is now b or vice versa. It is not true that the structure is now that the direct parent of all elements of the new merged class is equal to the root. But this is what we get when we call `find` on all elements of the data structure. At that time, I decided not to code `__iter__` because to me, an internal method like `__iter__` is a basic internal method of enumerable that is expected to be efficient. But for this particular data structure, I did not find that calling `find` on every elements was in the spirit of the data structure...

Anyway, I do think that a method that returns an enumerable on the roots is useful as I answered to Jori in a private email yesterday. Thinking about it now, I would have suggested a method `roots` that returns a list of the roots (an iterator needs to store the list anyway), which avoids the creation of the list of all elements in each class which is currently done in the oneliner that got positively reviewed.

Also, one thing I would suggest is to add a `NotImplementedError` to the `__iter__` to explain that such an enumeration needs to call `find` on all elements which is a costly operation (all proportion preserved) for that data structure. And suggest to use the method `roots`.

I let you decide if you agree with me and if we put this ticket on hold ...13 hours after a positive review.

https://en.wikipedia.org/wiki/Disjoint-set_data_structure


---

Comment by jmantysalo created at 2016-02-16 10:19:55

I put this on _needs_info_ to get some more time to explain.


---

Comment by jmantysalo created at 2016-02-16 10:19:55

Changing status from positive_review to needs_info.


---

Comment by slabbe created at 2016-02-16 10:32:36

I just realize the oneliner for `__iter__` is

```
    return self.root_to_elements_dict().itervalues()
```

and not

```
    return self.root_to_elements_dict().iterkeys()
```

Indeed, we also need to decide what to iterate on...


---

Comment by jmantysalo created at 2016-02-16 11:18:47

I want to make a function computing congruence of a (finite) lattice generated by some element sets. The result is splitting of elements to sets, i.e. exactly disjoint union. Hence `DisjointUnion` feels natural choise. The code basically iterates "elements `a` and `b` must belong to same equivalnce class, so combine set containing `a` and set containing `b`."

If I understood right, there is no way to make a fast iteration of values possible; the whole idea of this data structure is to avoid moving data in memory so that iterating would become fast.

I think that `itervalues()` and not `iterkeys()` is the right solution, if we are going to make this. There is basically no "roots" in mathematical sense in disjoint union. So the question is about "expected to be efficient". I would vote against it: we can make a slow iterator.


---

Comment by slabbe created at 2016-02-16 12:43:41

Thanks for allowing the discussion.

Replying to [comment:7 jmantysalo]:
> I think that `itervalues()` and not `iterkeys()` is the right solution, if we are going to make this. There is basically no "roots" in mathematical sense in disjoint union. 

You are right. I agree. Also `iterkeys()` is not well defined as the chosen roots might be different depending on the computer.

> So the question is about "expected to be efficient". I would vote against it: we can make a slow iterator.

Ok. So, let `__iter__()` return `self.root_to_elements_dict().itervalues()` then. I don't think there is much improvement we can do by avoiding the creation of the root to elements dict.

Positive review then :)


---

Comment by slabbe created at 2016-02-16 12:45:36

Changing status from needs_info to positive_review.


---

Comment by vbraun created at 2016-02-16 17:05:44

Resolution: fixed
