# Issue 12580: resulant of two polynomials returns incorrect value

Issue created by migration from Trac.

Original creator: bhutz

Original creation time: 2012-03-26 19:55:16

Assignee: tba

Keywords: polynomial resultant

The resultant of two homogeneous polynomials can return an incorrect value:
R.<x,y>=PolynomialRing(ZZ)

f=6*x<sup>2</sup> + x*y + y<sup>2</sup>

g=y<sup>2</sup>
print f.resultant(g)

m=matrix([[6,1,1,0],[0,6,1,1],[0,0,1,0],[0,0,0,1]])

m.determinant()

notice that the coefficient of the f.resultant(g) does not match the integer determinant (they should be the same).  I believe this is because the .resultant function is actually calling the pari library, which is interpreting y<sup>2</sup> as a single variable polynomial.  Thus it builds the wrong matrix. Probably the following:

m=matrix([[6,1,1,0],[0,6,1,1],[1,0,0,0],[0,1,0,0]])

m.determinant()

which is the value Sage is returning. The correct value is returned in Sage from

m=f.sylvester_matrix(g,x)

m.determinant()


---

Comment by nbruin created at 2012-03-27 16:01:04

Changing component from number theory to basic arithmetic.


---

Comment by nbruin created at 2012-03-27 16:01:04

Changing priority from major to minor.


---

Comment by nbruin created at 2012-03-27 16:01:04

See [this sage-devel thread](http://groups.google.com/group/sage-devel/browse_thread/thread/c15d8628b25517ca?hl=en). The documented use of f.resultant(g,<var>) is to take the resultant of f,g with respect to <var>. This is useful for eliminating variables when doing computations with polynomials. As documented, f.resultant(g) takes the resultant relative to the first parameter.

The resultant operation expected/requested in the ticket is a different one: It is the "bivariate form" resultant. You can compute it by taking a univariate polynomial resultant of dehomogenized forms and compensating for degree-drop by multiplying by the right power of some leading coefficients (if both forms drop in degree then they have a common root at infinity and the resultant is 0). Note that this routine should raise an error if any of its parameters is not homogeneous or not bivariate.

The resultant method on multivariate polynomials basically has to be the ordinary polynomial resultant. If you really want to have the form-resultant you can implement it as a separate function:

```
def form_resultant(F,G):
    """debugging, error checking and better coercion left as an exercise"""
    R=F.base_ring()
    Rt=PolynomialRing(R,'t')
    f=F(Rt.0,1)
    lcF=F.coefficient([F.degree(),0])
    g=G(Rt.0,1)
    lcG=G.coefficient([G.degree(),0])
    return lcF^(G.degree()-g.degree())*lcG^(F.degree()-f.degree())*f.resultant(g)
```


If there is a class somewhere that symbolizes homogeneous bivariate forms, you could hang that function off it as "form_resultant".

Note that in general, computing with bivariate forms is done most efficiently by representing them by a univariate polynomial together with a degree (to keep track of leading 0 coefficients). Univariate polynomials tend to have much more efficient implementations.

Changing to "invalid". If you want to track an enhancement proposal to implement a "forms" class, it's probably better to open a new ticket. I think it will be tricky to come up with a useful design for that, though.


---

Comment by mariah created at 2012-05-23 19:32:09

Changing status from new to needs_review.


---

Comment by mariah created at 2012-05-23 19:33:07

Since this ticket has been set to invalid, I believe this ticket can be
closed.


---

Comment by mariah created at 2012-05-23 19:33:07

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2012-06-02 13:28:03

Resolution: wontfix
