# Issue 24399: Rivin's test for circumcribability and inscribability

archive/issues_024399.json:
```json
{
    "body": "Keywords: polytopes, polyhedra, planar graphs\n\nLet's add the test by Rivin to check whether a polyhedral graph is the graph of a circumscribed polyhedron. (And also for inscribed polyhedra). It's a fairly straightforward LP. \n\nI think it would be good to add this to graphs and also to polyhedra. \n\nIssue created by migration from https://trac.sagemath.org/ticket/24636\n\n",
    "created_at": "2018-02-01T11:27:50Z",
    "labels": [
        "graph theory",
        "major",
        "enhancement"
    ],
    "title": "Rivin's test for circumcribability and inscribability",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/24399",
    "user": "moritz"
}
```
Keywords: polytopes, polyhedra, planar graphs

Let's add the test by Rivin to check whether a polyhedral graph is the graph of a circumscribed polyhedron. (And also for inscribed polyhedra). It's a fairly straightforward LP. 

I think it would be good to add this to graphs and also to polyhedra. 

Issue created by migration from https://trac.sagemath.org/ticket/24636





---

archive/issue_comments_341811.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-02-02T10:17:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341811",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_341812.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-02-02T10:19:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341812",
    "user": "moritz"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_341813.json:
```json
{
    "body": "Same remark than for #24634: is this definition/method valid for both graphs and digraphs ?",
    "created_at": "2018-02-02T14:49:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341813",
    "user": "dcoudert"
}
```

Same remark than for #24634: is this definition/method valid for both graphs and digraphs ?



---

archive/issue_comments_341814.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-02-02T18:50:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341814",
    "user": "moritz"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_341815.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-02-02T21:29:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341815",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_341816.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2018-02-02T21:31:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341816",
    "user": "moritz"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_341817.json:
```json
{
    "body": "I moved the methos to where they belong.",
    "created_at": "2018-02-02T21:31:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341817",
    "user": "moritz"
}
```

I moved the methos to where they belong.



---

archive/issue_comments_341818.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-02-03T10:19:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341818",
    "user": "dcoudert"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_341819.json:
```json
{
    "body": "A few comments:\n- `is circumscribed is all of ` -> `is circumscribed if all of `\n\n- For error messages, I was told several times to be short, not starting with capital letter and not ending with `.`. So you should change `raise NotImplementedError('%s is not polyhedral. This method only works for polyhedral graphs.' % str(self))` -> `raise NotImplementedError('this method only works for polyhedral graphs')`\n\n- Do not hesitate to add some empty line to ease de readability\n\n- You create an undirected copy of the graph. Does it means that the definition is valid for both graphs and digraphs ? It's just to know in which file should be the method. More importantly, is it useful ?\n\n- I don't understand why you use `vertices_dict` to relabel the vertices. Why is it important to use integer vertex labels ?\n\n- `The faces are completely determinend` -> `The faces are completely determined`\n\n- `set([])` -> `set()`\n\n- `if len(set(cycle)) > 2:` Here the cycle is assumed to be simple and the first and last vertices are the same. So `if len(cycle) > 3:` is be better.\n\n\n- Why are you forcing the solver to `ppl` ?\n\nI may have other comments, but so far I don't understand the LP formulation. It is hard to read...",
    "created_at": "2018-02-03T10:19:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341819",
    "user": "dcoudert"
}
```

A few comments:
- `is circumscribed is all of ` -> `is circumscribed if all of `

- For error messages, I was told several times to be short, not starting with capital letter and not ending with `.`. So you should change `raise NotImplementedError('%s is not polyhedral. This method only works for polyhedral graphs.' % str(self))` -> `raise NotImplementedError('this method only works for polyhedral graphs')`

- Do not hesitate to add some empty line to ease de readability

- You create an undirected copy of the graph. Does it means that the definition is valid for both graphs and digraphs ? It's just to know in which file should be the method. More importantly, is it useful ?

- I don't understand why you use `vertices_dict` to relabel the vertices. Why is it important to use integer vertex labels ?

- `The faces are completely determinend` -> `The faces are completely determined`

- `set([])` -> `set()`

- `if len(set(cycle)) > 2:` Here the cycle is assumed to be simple and the first and last vertices are the same. So `if len(cycle) > 3:` is be better.


- Why are you forcing the solver to `ppl` ?

I may have other comments, but so far I don't understand the LP formulation. It is hard to read...



---

archive/issue_comments_341820.json:
```json
{
    "body": "Thanks for the comments, David!\n\nReplying to [comment:8 dcoudert]:\n\n> - `is circumscribed is all of ` -> `is circumscribed if all of `\ndone\n> - For error messages, I was told several times to be short, not starting with capital letter and not ending with `.`. So you should change `raise NotImplementedError('%s is not polyhedral. This method only works for polyhedral graphs.' % str(self))` -> `raise NotImplementedError('this method only works for polyhedral graphs')`\nok, done.\n> - Do not hesitate to add some empty line to ease de readability\nI've added a few. \n> - You create an undirected copy of the graph. Does it means that the definition is valid for both graphs and digraphs ? It's just to know in which file should be the method.\nI create the undirected graph for one reason only: I want to iterate over all_simple_cycles of the (undirected) graph. There doesn't seem to be a method for that, but for digraphs, there is such a method; therefore I iterate over all simple cycles of the directed version of the graph and throw away the cycles of type `[x,y,x]`, i.e. of length `3` and also I get every simple cycle of the original graph twice. This is why I collect the inequalities and equations as sets first, to avoid having each constraint twice. \n\nThis does not mean that the definition makes sense for directed graph; it is in the right place\n> More importantly, is it useful ?\nI think this is an interesting property not so much for graphs, but for polyhedra. But it only depends on the graph of the polyhedra, which is why I put it in graph.py and not in the polyhedra section. The most useful call will be something like `P.graph().is_inscribable()` for a polyhedron P; (which could then be shortened to P.is_inscribable()). (Notice that there is already a method `is_inscribed`, so at least some people are interested in these kinds of questions)\n> \n> - I don't understand why you use `vertices_dict` to relabel the vertices. Why is it important to use integer vertex labels ?\nThe reason is that the variables-dictionary given by `M.new_variable()` for a MILP `M` don't seem to be flexible enough to handle complicated keys. \n> \n> - `The faces are completely determinend` -> `The faces are completely determined`\ndone\n> \n> - `set([])` -> `set()`\ndone\n> \n> - `if len(set(cycle)) > 2:` Here the cycle is assumed to be simple and the first and last vertices are the same. So `if len(cycle) > 3:` is be better.\nok, sure.\n> \n> \n> - Why are you forcing the solver to `ppl` ?\nI want the results to be accurate: Using a numerical solver might lead to incorrect results, especially because I am checking in end if the result is positive. Using exact arithmetic over the rationals and comparing against zero in the end will be slower but hopefully gives the correct result. \n\n> I may have other comments, but so far I don't understand the LP formulation. It is hard to read...\nI tried to explain it a bit better and also gave a link to a write-up by David Eppstein. (https://www.ics.uci.edu/~eppstein/junkyard/uninscribable/)\nI hope this helps; I am looking forward to your other comments..\nThanks again!",
    "created_at": "2018-02-03T14:56:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341820",
    "user": "moritz"
}
```

Thanks for the comments, David!

Replying to [comment:8 dcoudert]:

> - `is circumscribed is all of ` -> `is circumscribed if all of `
done
> - For error messages, I was told several times to be short, not starting with capital letter and not ending with `.`. So you should change `raise NotImplementedError('%s is not polyhedral. This method only works for polyhedral graphs.' % str(self))` -> `raise NotImplementedError('this method only works for polyhedral graphs')`
ok, done.
> - Do not hesitate to add some empty line to ease de readability
I've added a few. 
> - You create an undirected copy of the graph. Does it means that the definition is valid for both graphs and digraphs ? It's just to know in which file should be the method.
I create the undirected graph for one reason only: I want to iterate over all_simple_cycles of the (undirected) graph. There doesn't seem to be a method for that, but for digraphs, there is such a method; therefore I iterate over all simple cycles of the directed version of the graph and throw away the cycles of type `[x,y,x]`, i.e. of length `3` and also I get every simple cycle of the original graph twice. This is why I collect the inequalities and equations as sets first, to avoid having each constraint twice. 

This does not mean that the definition makes sense for directed graph; it is in the right place
> More importantly, is it useful ?
I think this is an interesting property not so much for graphs, but for polyhedra. But it only depends on the graph of the polyhedra, which is why I put it in graph.py and not in the polyhedra section. The most useful call will be something like `P.graph().is_inscribable()` for a polyhedron P; (which could then be shortened to P.is_inscribable()). (Notice that there is already a method `is_inscribed`, so at least some people are interested in these kinds of questions)
> 
> - I don't understand why you use `vertices_dict` to relabel the vertices. Why is it important to use integer vertex labels ?
The reason is that the variables-dictionary given by `M.new_variable()` for a MILP `M` don't seem to be flexible enough to handle complicated keys. 
> 
> - `The faces are completely determinend` -> `The faces are completely determined`
done
> 
> - `set([])` -> `set()`
done
> 
> - `if len(set(cycle)) > 2:` Here the cycle is assumed to be simple and the first and last vertices are the same. So `if len(cycle) > 3:` is be better.
ok, sure.
> 
> 
> - Why are you forcing the solver to `ppl` ?
I want the results to be accurate: Using a numerical solver might lead to incorrect results, especially because I am checking in end if the result is positive. Using exact arithmetic over the rationals and comparing against zero in the end will be slower but hopefully gives the correct result. 

> I may have other comments, but so far I don't understand the LP formulation. It is hard to read...
I tried to explain it a bit better and also gave a link to a write-up by David Eppstein. (https://www.ics.uci.edu/~eppstein/junkyard/uninscribable/)
I hope this helps; I am looking forward to your other comments..
Thanks again!



---

archive/issue_comments_341821.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-02-03T14:58:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341821",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_341822.json:
```json
{
    "body": "At the beginning of method `is_circumscribable`, you have `G = self.to_undirected()` but you  don't use `G` afterward, and self is undirected. I suspect that you want to remove loops and multiple edges. If so, you should use `G` in the following.\n\nConcerning `vertices_dict`, the variables-dictionary given by `M.new_variable()` **is** flexible enough to accept any hashable type. So you don't need this dictionary.\n\nI suggest to rewrite the code as:\n\n```\n    M = MixedIntegerLinearProgram(maximization=True, solver=\"ppl\")\n    e = M.new_variable(nonnegative=True)\n    c = M.new_variable()\n    M.set_min(c[0], -1)\n    M.set_max(c[0], 1)\n    M.set_objective(c[0])\n\n    for u,v in self.edge_iterator(labels=0):\n        if u > v:\n            u,v = v,u\n        M.set_max(e[u,v], ZZ(1)/ZZ(2))\n        M.add_constraint(e[u,v] - c[0], min=0)\n        M.add_constraint(e[u,v] + c[0], max=ZZ(1)/ZZ(2))\n\n    from sage.misc.flatten import flatten\n    # The faces are completely determined by the graph structure:\n    # for polyhedral graph, there is only one way to choose the faces.\n    efaces = self.faces()\n    vfaces = [flatten(face) for face in efaces]\n    \n    # In order to generate all simple cycles of G, we use the \"all_simple_cycles\"\n    # method of directed graphs, generating each cycle twice (in both directions)\n    # The two sets below make sure only one direction gives rise to an (in)equality\n    D = self.to_directed()\n    equality_constraints = set()\n    inequality_constraints = set()\n    for cycle in D.all_simple_cycles():\n        if len(cycle) > 3:\n            edges = (tuple(sorted([cycle[i], cycle[i+1]])) for i in range(len(cycle)-1))\n            scycle = set(cycle)\n            if any(scycle.issubset(_) for _ in vfaces):\n                equality_constraints.add(edges)\n            else:\n                inequality_constraints.add(edges)\n\n    for eq in equality_constraints:\n        M.add_constraint(M.sum(e[_] for _ in eq) == 1)\n    for ieq in inequality_constraints:\n        M.add_constraint(M.sum(e[_] for _ in ieq) - c[0] >= 1)\n```\n\n\nThis code is working (I tried), and I find it easier to read.\n\nDo we agree that \n- the equality constraints are exactly the faces\n- any simple cycle that is not a face induces an inequality constraint\n\nIf so, why using `issubset` ?  \n\nOtherwise, we could do something like:\n\n```\n    vfaces = set(Set(flatten(face)) for face in efaces)\n    \n    # In order to generate all simple cycles of G, we use the \"all_simple_cycles\"\n    # method of directed graphs, generating each cycle twice (in both directions)\n    # The two sets below make sure only one direction gives rise to an (in)equality\n    D = self.to_directed()\n    equality_constraints = set()\n    inequality_constraints = set()\n    for cycle in D.all_simple_cycles():\n        if len(cycle) > 3:\n            edges = (tuple(sorted([cycle[i], cycle[i+1]])) for i in range(len(cycle)-1))\n            if not Set(cycle) in vfaces:\n                equality_constraints.add(edges)\n            else:\n                inequality_constraints.add(edges)\n```\n\nand we can even save set `equality_constraints` since it is duplicate of `efaces`.",
    "created_at": "2018-02-03T18:42:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341822",
    "user": "dcoudert"
}
```

At the beginning of method `is_circumscribable`, you have `G = self.to_undirected()` but you  don't use `G` afterward, and self is undirected. I suspect that you want to remove loops and multiple edges. If so, you should use `G` in the following.

Concerning `vertices_dict`, the variables-dictionary given by `M.new_variable()` **is** flexible enough to accept any hashable type. So you don't need this dictionary.

I suggest to rewrite the code as:

```
    M = MixedIntegerLinearProgram(maximization=True, solver="ppl")
    e = M.new_variable(nonnegative=True)
    c = M.new_variable()
    M.set_min(c[0], -1)
    M.set_max(c[0], 1)
    M.set_objective(c[0])

    for u,v in self.edge_iterator(labels=0):
        if u > v:
            u,v = v,u
        M.set_max(e[u,v], ZZ(1)/ZZ(2))
        M.add_constraint(e[u,v] - c[0], min=0)
        M.add_constraint(e[u,v] + c[0], max=ZZ(1)/ZZ(2))

    from sage.misc.flatten import flatten
    # The faces are completely determined by the graph structure:
    # for polyhedral graph, there is only one way to choose the faces.
    efaces = self.faces()
    vfaces = [flatten(face) for face in efaces]
    
    # In order to generate all simple cycles of G, we use the "all_simple_cycles"
    # method of directed graphs, generating each cycle twice (in both directions)
    # The two sets below make sure only one direction gives rise to an (in)equality
    D = self.to_directed()
    equality_constraints = set()
    inequality_constraints = set()
    for cycle in D.all_simple_cycles():
        if len(cycle) > 3:
            edges = (tuple(sorted([cycle[i], cycle[i+1]])) for i in range(len(cycle)-1))
            scycle = set(cycle)
            if any(scycle.issubset(_) for _ in vfaces):
                equality_constraints.add(edges)
            else:
                inequality_constraints.add(edges)

    for eq in equality_constraints:
        M.add_constraint(M.sum(e[_] for _ in eq) == 1)
    for ieq in inequality_constraints:
        M.add_constraint(M.sum(e[_] for _ in ieq) - c[0] >= 1)
```


This code is working (I tried), and I find it easier to read.

Do we agree that 
- the equality constraints are exactly the faces
- any simple cycle that is not a face induces an inequality constraint

If so, why using `issubset` ?  

Otherwise, we could do something like:

```
    vfaces = set(Set(flatten(face)) for face in efaces)
    
    # In order to generate all simple cycles of G, we use the "all_simple_cycles"
    # method of directed graphs, generating each cycle twice (in both directions)
    # The two sets below make sure only one direction gives rise to an (in)equality
    D = self.to_directed()
    equality_constraints = set()
    inequality_constraints = set()
    for cycle in D.all_simple_cycles():
        if len(cycle) > 3:
            edges = (tuple(sorted([cycle[i], cycle[i+1]])) for i in range(len(cycle)-1))
            if not Set(cycle) in vfaces:
                equality_constraints.add(edges)
            else:
                inequality_constraints.add(edges)
```

and we can even save set `equality_constraints` since it is duplicate of `efaces`.



---

archive/issue_comments_341823.json:
```json
{
    "body": "Replying to [comment:11 dcoudert]:\n> At the beginning of method `is_circumscribable`, you have `G = self.to_undirected()` but you  don't use `G` afterward, and self is undirected. I suspect that you want to remove loops and multiple edges. If so, you should use `G` in the following.\nNo, I simply forgot to delete that file when moving the method from generic_graph to graph. Graph with loops and multiple edges are caught by the is_polyhedral test before.\n\n> Concerning `vertices_dict`, the variables-dictionary given by `M.new_variable()` **is** flexible enough to accept any hashable type. So you don't need this dictionary.\nGreat! I don't know anymore why I was thinking these dictionary weren't flexible enough.\n> \n> I suggest to rewrite the code as:\nI adopted all your changes, they do make the code more readable! Not all doctest worked with what you had, but after added `set` to the following line \n\n```\nvfaces = [set(flatten(face)) for face in efaces]\n```\n\nand modifying a few things, everything now works again. Also, your version generated all the inequalities for non-facial cycles twice; I added a `frozenset` to remedy this. (I had `tuple(sorted(edges))` before.)\n> \n> Do we agree that \n> - the equality constraints are exactly the faces\n> - any simple cycle that is not a face induces an inequality constraint\n> \nYes!\n> If so, why using `issubset` ?  \nNot using it anymore..\n> \n> Otherwise, we could do something like:\n> and we can even save set `equality_constraints` since it is duplicate of `efaces`.\ndone, the equalities are now treated directly from efaces before\n\n \nThank you: this certainly improved the code!",
    "created_at": "2018-02-03T20:44:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341823",
    "user": "moritz"
}
```

Replying to [comment:11 dcoudert]:
> At the beginning of method `is_circumscribable`, you have `G = self.to_undirected()` but you  don't use `G` afterward, and self is undirected. I suspect that you want to remove loops and multiple edges. If so, you should use `G` in the following.
No, I simply forgot to delete that file when moving the method from generic_graph to graph. Graph with loops and multiple edges are caught by the is_polyhedral test before.

> Concerning `vertices_dict`, the variables-dictionary given by `M.new_variable()` **is** flexible enough to accept any hashable type. So you don't need this dictionary.
Great! I don't know anymore why I was thinking these dictionary weren't flexible enough.
> 
> I suggest to rewrite the code as:
I adopted all your changes, they do make the code more readable! Not all doctest worked with what you had, but after added `set` to the following line 

```
vfaces = [set(flatten(face)) for face in efaces]
```

and modifying a few things, everything now works again. Also, your version generated all the inequalities for non-facial cycles twice; I added a `frozenset` to remedy this. (I had `tuple(sorted(edges))` before.)
> 
> Do we agree that 
> - the equality constraints are exactly the faces
> - any simple cycle that is not a face induces an inequality constraint
> 
Yes!
> If so, why using `issubset` ?  
Not using it anymore..
> 
> Otherwise, we could do something like:
> and we can even save set `equality_constraints` since it is duplicate of `efaces`.
done, the equalities are now treated directly from efaces before

 
Thank you: this certainly improved the code!



---

archive/issue_comments_341824.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-03T20:44:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341824",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_341825.json:
```json
{
    "body": "Please add an empty line after `M.add_constraint(M.sum(e[tuple(sorted(_))] for _ in edges) == 1)`.\n\n`vfaces` should be a set, not a list. Testing if an item is in a list takes linear time in the size of the list, and much less in a set. See the example below.\n\n```\nsage: L = list(range(1000))\nsage: shuffle(L)\nsage: S = set(L)\nsage: %time all(i in L for i in L)\nCPU times: user 7.08 ms, sys: 423 \u00b5s, total: 7.5 ms\nWall time: 7.19 ms\nTrue\nsage: %time all(i in S for i in L)\nCPU times: user 304 \u00b5s, sys: 182 \u00b5s, total: 486 \u00b5s\nWall time: 329 \u00b5s\nTrue\n```\n\n\nSo I propose to use\n\n```\nvfaces = set(frozenset(flatten(face)) for face in efaces))\n```\n\nand\n\n```\n            if len(cycle) > 3:\n                scycle = frozenset(cycle)\n                if scycle not in vfaces:\n                    edges = (tuple(sorted([cycle[i], cycle[i+1]])) for i in range(len(cycle)-1))\n                    inequality_constraints.add(frozenset(edges))\n```\n\nWe need to use `frozenset` (or `Set`) since this type is hashable, and so we can have a set of frozensets.\n\nObserve that since `cycle` is a list, we can do `scycle = frozenset(cycle)`. No need to flatten the cycle first.\n\nIn the description of the method, you could add after `by solving a linear program`\n\n```\nthat assigns weights between 0 and 1/2 on each edge of the polyhedron, so that the weights on any face add to exactly one and the weights on any non-facial cycle add to more than one. If this can be done, the polyhedron can be circumscribed.\n```\n",
    "created_at": "2018-02-04T08:52:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341825",
    "user": "dcoudert"
}
```

Please add an empty line after `M.add_constraint(M.sum(e[tuple(sorted(_))] for _ in edges) == 1)`.

`vfaces` should be a set, not a list. Testing if an item is in a list takes linear time in the size of the list, and much less in a set. See the example below.

```
sage: L = list(range(1000))
sage: shuffle(L)
sage: S = set(L)
sage: %time all(i in L for i in L)
CPU times: user 7.08 ms, sys: 423 µs, total: 7.5 ms
Wall time: 7.19 ms
True
sage: %time all(i in S for i in L)
CPU times: user 304 µs, sys: 182 µs, total: 486 µs
Wall time: 329 µs
True
```


So I propose to use

```
vfaces = set(frozenset(flatten(face)) for face in efaces))
```

and

```
            if len(cycle) > 3:
                scycle = frozenset(cycle)
                if scycle not in vfaces:
                    edges = (tuple(sorted([cycle[i], cycle[i+1]])) for i in range(len(cycle)-1))
                    inequality_constraints.add(frozenset(edges))
```

We need to use `frozenset` (or `Set`) since this type is hashable, and so we can have a set of frozensets.

Observe that since `cycle` is a list, we can do `scycle = frozenset(cycle)`. No need to flatten the cycle first.

In the description of the method, you could add after `by solving a linear program`

```
that assigns weights between 0 and 1/2 on each edge of the polyhedron, so that the weights on any face add to exactly one and the weights on any non-facial cycle add to more than one. If this can be done, the polyhedron can be circumscribed.
```




---

archive/issue_comments_341826.json:
```json
{
    "body": "Replying to [comment:14 dcoudert]:\n> Please add an empty line after `M.add_constraint(M.sum(e[tuple(sorted(_))] for _ in edges) == 1)`.\ndone\n> `vfaces` should be a set, not a list. \nsure, that makes sense!\n\n> \n> Observe that since `cycle` is a list, we can do `scycle = frozenset(cycle)`. No need to flatten the cycle first.\nNice! Now I avoid flattening lists also when generating the list  \n`vfaces = set(frozenset([_[0] for _ in face]) for face in efaces)'\nUsing `flatten` instead of `[_[0] for _ in face]` leads to errors when the vertices of the Graph are lists themselves (as often happens when looking at the planar dual). Now it works.\n\n> \n> In the description of the method, you could add after `by solving a linear program`\n...\ndone!\n\nThank you for the further suggestions!",
    "created_at": "2018-02-04T13:51:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341826",
    "user": "moritz"
}
```

Replying to [comment:14 dcoudert]:
> Please add an empty line after `M.add_constraint(M.sum(e[tuple(sorted(_))] for _ in edges) == 1)`.
done
> `vfaces` should be a set, not a list. 
sure, that makes sense!

> 
> Observe that since `cycle` is a list, we can do `scycle = frozenset(cycle)`. No need to flatten the cycle first.
Nice! Now I avoid flattening lists also when generating the list  
`vfaces = set(frozenset([_[0] for _ in face]) for face in efaces)'
Using `flatten` instead of `[_[0] for _ in face]` leads to errors when the vertices of the Graph are lists themselves (as often happens when looking at the planar dual). Now it works.

> 
> In the description of the method, you could add after `by solving a linear program`
...
done!

Thank you for the further suggestions!



---

archive/issue_comments_341827.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-04T13:51:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341827",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_341828.json:
```json
{
    "body": "This is much better, but I have further comments (sorry):\n- please ensure that the comments are written in 80 columns mode. The line `A polyhedron is circumscribed if all of its facets are tangent to a sphere.` exceeds the 80th column.\n\n- In the examples, you could add\n\n```\nsage: O = graphs.OctahedralGraph()\nsage: 0.is_circumscribable()\nTrue\n```\n\n\n- in the example of `is_inscribable`:\n\n```\nsage: C = graphs.CubeGraph(3)\nsage: v = next(C.vertex_iterator())\nsage: triangle = [_ + v for _ in C.neighbors(v)]\n```\n\nHonestly, I don't understand the transformation, but it's not important.\n\nMay be it would be more informative to have:\n\n```\nsage: C = graphs.CubeGraph(3)\nsage: C.is_inscribable()\nTrue\nsage: C.planar_dual().is_inscribable()\nTrue\nsage: H = graphs.HerschelGraph()\nsage: H.is_inscribable()               # long time (> 1 sec)\nFalse\nsage: H.planar_dual().is_inscribable() # long time (> 1 sec)\nTrue\n```\n",
    "created_at": "2018-02-04T15:50:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341828",
    "user": "dcoudert"
}
```

This is much better, but I have further comments (sorry):
- please ensure that the comments are written in 80 columns mode. The line `A polyhedron is circumscribed if all of its facets are tangent to a sphere.` exceeds the 80th column.

- In the examples, you could add

```
sage: O = graphs.OctahedralGraph()
sage: 0.is_circumscribable()
True
```


- in the example of `is_inscribable`:

```
sage: C = graphs.CubeGraph(3)
sage: v = next(C.vertex_iterator())
sage: triangle = [_ + v for _ in C.neighbors(v)]
```

Honestly, I don't understand the transformation, but it's not important.

May be it would be more informative to have:

```
sage: C = graphs.CubeGraph(3)
sage: C.is_inscribable()
True
sage: C.planar_dual().is_inscribable()
True
sage: H = graphs.HerschelGraph()
sage: H.is_inscribable()               # long time (> 1 sec)
False
sage: H.planar_dual().is_inscribable() # long time (> 1 sec)
True
```




---

archive/issue_comments_341829.json:
```json
{
    "body": "Replying to [comment:17 dcoudert]:\n> This is much better, but I have further comments (sorry):\nThat's great, I enjoy your comments very much!\n> - please ensure that the comments are written in 80 columns mode. \ndone.\n> \n> - In the examples, you could add ...\nI added the octahedron.\n\n> Honestly, I don't understand the transformation, but it's not important.\nI added an explanation what it does (it is cutting off a vertex from the cube)\n> \n> May be it would be more informative to have...\nI added some more examples that I find pretty instructive. They include the smallest examples of non-(in/circum)scribable graphs. (Another would be dual to the truncated tetrahedron: the stacked tetrahedron, a.k.a. Triakis tetradhedron (https://en.wikipedia.org/wiki/Triakis_tetrahedron), which is not inscribed. But I don't know how to get the graph easily, except `polytopes.truncated_tetrahedron().graph().planar_dual()` or `polytopes.truncated_tetrahedron().polar().graph()` of course..)\n\nThank you for looking at the code so closely!",
    "created_at": "2018-02-04T17:06:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341829",
    "user": "moritz"
}
```

Replying to [comment:17 dcoudert]:
> This is much better, but I have further comments (sorry):
That's great, I enjoy your comments very much!
> - please ensure that the comments are written in 80 columns mode. 
done.
> 
> - In the examples, you could add ...
I added the octahedron.

> Honestly, I don't understand the transformation, but it's not important.
I added an explanation what it does (it is cutting off a vertex from the cube)
> 
> May be it would be more informative to have...
I added some more examples that I find pretty instructive. They include the smallest examples of non-(in/circum)scribable graphs. (Another would be dual to the truncated tetrahedron: the stacked tetrahedron, a.k.a. Triakis tetradhedron (https://en.wikipedia.org/wiki/Triakis_tetrahedron), which is not inscribed. But I don't know how to get the graph easily, except `polytopes.truncated_tetrahedron().graph().planar_dual()` or `polytopes.truncated_tetrahedron().polar().graph()` of course..)

Thank you for looking at the code so closely!



---

archive/issue_comments_341830.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-04T17:06:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341830",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_341831.json:
```json
{
    "body": "Perfect.\n\nNow let's check the references.\n* `.. [HRS1993] ] Craig D. Hodgson, Igor Rivin and Warren D. Smith, \\` -> `.. [HRS1993] \\C. D. Hodgson, I. Rivin and W. D. Smith.`",
    "created_at": "2018-02-04T17:35:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341831",
    "user": "dcoudert"
}
```

Perfect.

Now let's check the references.
* `.. [HRS1993] ] Craig D. Hodgson, Igor Rivin and Warren D. Smith, \` -> `.. [HRS1993] \C. D. Hodgson, I. Rivin and W. D. Smith.`



---

archive/issue_comments_341832.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-02-04T17:44:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341832",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_341833.json:
```json
{
    "body": "fixed, thanks!\n----\nNew commits:",
    "created_at": "2018-02-04T17:45:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341833",
    "user": "moritz"
}
```

fixed, thanks!
----
New commits:



---

archive/issue_comments_341834.json:
```json
{
    "body": "No more comments.",
    "created_at": "2018-02-04T18:30:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341834",
    "user": "dcoudert"
}
```

No more comments.



---

archive/issue_comments_341835.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2018-02-04T18:30:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341835",
    "user": "dcoudert"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_341836.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-02-09T08:03:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24399",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24399#issuecomment-341836",
    "user": "vbraun"
}
```

Resolution: fixed
