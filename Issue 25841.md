# Issue 25841: Ideals of finite dimensional Lie algebras

archive/issues_025841.json:
```json
{
    "body": "CC:  @tscrim\n\nKeywords: Lie algebras, ideals\n\nAn implementation of ideals generated by a subset of a finite dimensional Lie algebra with basis. In the finite dimensional case a naive (and probably inefficient) method of repeatedly computing brackets to find a basis of the ideal is available, as opposed to the Gr\u00f6bner-basis style methods that would need to be used in the general case. Part of a part of #16824\n\nIssue created by migration from https://trac.sagemath.org/ticket/26078\n\n",
    "created_at": "2018-08-17T07:09:48Z",
    "labels": [
        "component: algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.4",
    "title": "Ideals of finite dimensional Lie algebras",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25841",
    "user": "https://github.com/ehaka"
}
```
CC:  @tscrim

Keywords: Lie algebras, ideals

An implementation of ideals generated by a subset of a finite dimensional Lie algebra with basis. In the finite dimensional case a naive (and probably inefficient) method of repeatedly computing brackets to find a basis of the ideal is available, as opposed to the GrÃ¶bner-basis style methods that would need to be used in the general case. Part of a part of #16824

Issue created by migration from https://trac.sagemath.org/ticket/26078





---

archive/issue_comments_364298.json:
```json
{
    "body": "Some implementation already exists in a codebase that I need to clean up and import into Sage.",
    "created_at": "2018-08-17T07:10:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364298",
    "user": "https://github.com/ehaka"
}
```

Some implementation already exists in a codebase that I need to clean up and import into Sage.



---

archive/issue_comments_364299.json:
```json
{
    "body": "That was basically how my previous code (on #14901) was doing things. Although it probably should be done lazily (i.e., when the user asks for `basis`). Will you also be including code for subalgebras?",
    "created_at": "2018-08-17T10:47:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364299",
    "user": "https://github.com/tscrim"
}
```

That was basically how my previous code (on #14901) was doing things. Although it probably should be done lazily (i.e., when the user asks for `basis`). Will you also be including code for subalgebras?



---

archive/issue_comments_364300.json:
```json
{
    "body": "The lazy implementation is a good idea, I will tweak it in when I get to the import. Currently I have no code related to generic subalgebras, only a coercion from an ideal back to the ambient algebra. I'll have to see if during cleanup of the ideal-code there is something that sticks out as belonging in a subalgebra construction.",
    "created_at": "2018-08-17T13:12:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364300",
    "user": "https://github.com/ehaka"
}
```

The lazy implementation is a good idea, I will tweak it in when I get to the import. Currently I have no code related to generic subalgebras, only a coercion from an ideal back to the ambient algebra. I'll have to see if during cleanup of the ideal-code there is something that sticks out as belonging in a subalgebra construction.



---

archive/issue_comments_364301.json:
```json
{
    "body": "A first iteration of ideals and subalgebras of finite dimensional Lie algebras with basis is in the commits. I added subalgebras to the scope of this ticket since it turned out that a lot of the code fit naturally within the subalgebra setting, and the only extra piece was the differing computation of a basis.\n\nThe implementation of ideals+subalgebras is through a `LieSubset` base class, whose elements are wrappers (subclassing `LieAlgebraElementWrapper`) around elements of the ambient Lie algebra. Any computations are done by the lift-retract model suggested by `Sets().Subobjects()`.\n\nMuch of the code would fit inside also within a generic `LieIdeal` or `LieSubalgebra` class, however the essential part of containment testing of elements would not be implemented, so I decided to leave all the code in a finite dimensional class for now.\n\nAlthough technically independent from nilpotent Lie algebras, I added the dependency #26076 in order  to implement the fact that a subalgebra or ideal of a nilpotent Lie algebra is also nilpotent.\n\n---\nLast 10 new commits:",
    "created_at": "2018-08-29T06:13:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364301",
    "user": "https://github.com/ehaka"
}
```

A first iteration of ideals and subalgebras of finite dimensional Lie algebras with basis is in the commits. I added subalgebras to the scope of this ticket since it turned out that a lot of the code fit naturally within the subalgebra setting, and the only extra piece was the differing computation of a basis.

The implementation of ideals+subalgebras is through a `LieSubset` base class, whose elements are wrappers (subclassing `LieAlgebraElementWrapper`) around elements of the ambient Lie algebra. Any computations are done by the lift-retract model suggested by `Sets().Subobjects()`.

Much of the code would fit inside also within a generic `LieIdeal` or `LieSubalgebra` class, however the essential part of containment testing of elements would not be implemented, so I decided to leave all the code in a finite dimensional class for now.

Although technically independent from nilpotent Lie algebras, I added the dependency #26076 in order  to implement the fact that a subalgebra or ideal of a nilpotent Lie algebra is also nilpotent.

---
Last 10 new commits:



---

archive/issue_comments_364302.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-08-29T06:13:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364302",
    "user": "https://github.com/ehaka"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_364303.json:
```json
{
    "body": "Changing keywords from \"Lie algebras, ideals\" to \"Lie algebras, ideals, subalgebras\".",
    "created_at": "2018-08-29T06:13:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364303",
    "user": "https://github.com/ehaka"
}
```

Changing keywords from "Lie algebras, ideals" to "Lie algebras, ideals, subalgebras".



---

archive/issue_comments_364304.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-08-29T06:18:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364304",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364305.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-02T11:03:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364305",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364306.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-02T13:34:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364306",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364307.json:
```json
{
    "body": "Some comments:\n\nWhy do you have these ABCs? I don't see the point of having them and instead just having `LieSubalgebra_finite_dimensional_with_basis` as the starting class. It is easy enough to separate things once we find a use-case for them, but doing so prematurely can make it harder in terms of maintenance. Of course, if you do have a use-case for them in the future, just let me know.\n\nRather than manually setting the category as default, you should just use\n\n```\nambient.category().Subobjects()\n```\nas that means you do not need the essentially duplication of `subalgebra` and `ideal` in the fin-dim nilpotent with basis category. It also is a much more robust default.\n\nIn `basis()`, `EXAMPLES:` -> `EXAMPLES::`.\n\n`monomoial_coefficients` should not have keys that are not in the support (e.g., the `0: 0` in your example).\n\nSubsequently your `__getitem__` should just call `self.to_vector()[i]` (and return `0` if `i` is not in the basis index set).\n\nI would consider caching the result of `to_vector()` since it is computationally expensive.\n\nI would change `ambient_submodule` to\n\n```python\n    def module(self, sparse=False):\n        m = self.ambient().module(sparse=sparse)\n        ambientbasis = [self.lift(X).to_vector() for X in self.basis()]\n        return m.submodule_with_basis(ambientbasis)\n```\nI found the name somewhat confusing and nothing in the API for `module` forces the result to be an ambient module (nor should it have specifically contain \"free\" in its doc). The result of `module` is meant to reflect the space where we want to do the linear algebra computations.\n\n`if len(gens) == 0:` -> `if not gens:` Although I think in this case, it is better to not have any generators, even if it makes the code more complicated. I would also strip all copies of 0 from the generating set for better input normalization.\n\nI would avoid the use of the (more) ambiguous `gens` in the subalgebra code and instead use `lie_algebra_generators`.\n\nInstead of `P.ambient().bracket(self_lift, x_lift)`, use the more direct (and faster) `self_lift._bracket_(x_lift)`. Similarly, instead of calling the lift, I would just use `self_lift = self.value`. Internal methods can use internal parts. :)\n\nDo you want to implement methods like `__add__`, `direct_sum`, `is_subalgebra`, `intersection` (for ideals), etc. on this ticket? Similarly, do we want to add shorthands such as `L[x, L]` and `x.bracket(L)` for creating ideals? (I am happy to do these implementations.)",
    "created_at": "2018-09-08T22:35:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364307",
    "user": "https://github.com/tscrim"
}
```

Some comments:

Why do you have these ABCs? I don't see the point of having them and instead just having `LieSubalgebra_finite_dimensional_with_basis` as the starting class. It is easy enough to separate things once we find a use-case for them, but doing so prematurely can make it harder in terms of maintenance. Of course, if you do have a use-case for them in the future, just let me know.

Rather than manually setting the category as default, you should just use

```
ambient.category().Subobjects()
```
as that means you do not need the essentially duplication of `subalgebra` and `ideal` in the fin-dim nilpotent with basis category. It also is a much more robust default.

In `basis()`, `EXAMPLES:` -> `EXAMPLES::`.

`monomoial_coefficients` should not have keys that are not in the support (e.g., the `0: 0` in your example).

Subsequently your `__getitem__` should just call `self.to_vector()[i]` (and return `0` if `i` is not in the basis index set).

I would consider caching the result of `to_vector()` since it is computationally expensive.

I would change `ambient_submodule` to

```python
    def module(self, sparse=False):
        m = self.ambient().module(sparse=sparse)
        ambientbasis = [self.lift(X).to_vector() for X in self.basis()]
        return m.submodule_with_basis(ambientbasis)
```
I found the name somewhat confusing and nothing in the API for `module` forces the result to be an ambient module (nor should it have specifically contain "free" in its doc). The result of `module` is meant to reflect the space where we want to do the linear algebra computations.

`if len(gens) == 0:` -> `if not gens:` Although I think in this case, it is better to not have any generators, even if it makes the code more complicated. I would also strip all copies of 0 from the generating set for better input normalization.

I would avoid the use of the (more) ambiguous `gens` in the subalgebra code and instead use `lie_algebra_generators`.

Instead of `P.ambient().bracket(self_lift, x_lift)`, use the more direct (and faster) `self_lift._bracket_(x_lift)`. Similarly, instead of calling the lift, I would just use `self_lift = self.value`. Internal methods can use internal parts. :)

Do you want to implement methods like `__add__`, `direct_sum`, `is_subalgebra`, `intersection` (for ideals), etc. on this ticket? Similarly, do we want to add shorthands such as `L[x, L]` and `x.bracket(L)` for creating ideals? (I am happy to do these implementations.)



---

archive/issue_comments_364308.json:
```json
{
    "body": "Replying to [comment:9 tscrim]:\n> Some comments:\n> \n> Of course, if you do have a use-case for them in the future, just let me know.\n\n\nNo use case, just my own misunderstanding of which way of doing things was more maintainable. I will fix this now.\n\n> Rather than manually setting the category as default, you should just use\n> \n> ```\n> ambient.category().Subobjects()\n> ```\n> as that means you do not need the essentially duplication of `subalgebra` and `ideal` in the fin-dim nilpotent with basis category. It also is a much more robust default.\n\n\nThe thing I was worried about here is the `Graded` and `Stratified` categories. The result in such cases would be\n\n```\nsage: LieAlgebras(QQ).Graded().Subobjects()\nJoin of Category of graded Lie algebras over Rational Field and Category of subobjects of sets\n```\nbut not every subalgebra is graded, so this would still need separate handling. Because of this it wasn't clear to me if categories should be handled in an 'opt-out' or 'opt-in' manner. The main worry was that if the default is 'opt-out', then any future implementation of a subcategory of Lie algebras would have to also consider whether ideals and subalgebras are automatically in this category, which sounded error-prone.\n\n> I would change `ambient_submodule` to\n> \n> ```python\n>     def module(self, sparse=False):\n>         m = self.ambient().module(sparse=sparse)\n>         ambientbasis = [self.lift(X).to_vector() for X in self.basis()]\n>         return m.submodule_with_basis(ambientbasis)\n> ```\n> I found the name somewhat confusing and nothing in the API for `module` forces the result to be an ambient module (nor should it have specifically contain \"free\" in its doc). The result of `module` is meant to reflect the space where we want to do the linear algebra computations.\n\n\nWill fix. However I am not sure how to get rid of \"free\" coming from\n\n```\nsage: L.<X,Y,Z> = LieAlgebra(ZZ, {('X','Y'): {'Z': 3}})\nsage: L.module(sparse=False)\nAmbient free module of rank 3 over the principal ideal domain Integer Ring\n```\n\n> `if len(gens) == 0:` -> `if not gens:` Although I think in this case, it is better to not have any generators, even if it makes the code more complicated. I would also strip all copies of 0 from the generating set for better input normalization.\n\n\nHow much processing should be done here? The upper limit I suppose would be to extract a maximal linearly independent subset, but this might be too expensive for high dimensions. I will add the 'cheap' zero-stripping now.\n\n> I would avoid the use of the (more) ambiguous `gens` in the subalgebra code and instead use `lie_algebra_generators`.\n\n\nI will add `lie_algebra_generators` to subalgebras, but also keep `gens`, since it is used also by ideals, and I think it would be confusing to have the generating set of an ideal referred to as `lie_algebra_generators`.\n\n> Do you want to implement methods like `__add__`, `direct_sum`, `is_subalgebra`, `intersection` (for ideals), etc. on this ticket? Similarly, do we want to add shorthands such as `L[x, L]` and `x.bracket(L)` for creating ideals? (I am happy to do these implementations.)\n\n\nThese sound like very good convenience additions. You can do the implementation as you most likely have a clearer vision on how it should be done.\n\nI will do the other corrections now, except for the default category thing, as I would still like to hear your comments on how to handle the `Graded` issue.",
    "created_at": "2018-09-09T05:54:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364308",
    "user": "https://github.com/ehaka"
}
```

Replying to [comment:9 tscrim]:
> Some comments:
> 
> Of course, if you do have a use-case for them in the future, just let me know.


No use case, just my own misunderstanding of which way of doing things was more maintainable. I will fix this now.

> Rather than manually setting the category as default, you should just use
> 
> ```
> ambient.category().Subobjects()
> ```
> as that means you do not need the essentially duplication of `subalgebra` and `ideal` in the fin-dim nilpotent with basis category. It also is a much more robust default.


The thing I was worried about here is the `Graded` and `Stratified` categories. The result in such cases would be

```
sage: LieAlgebras(QQ).Graded().Subobjects()
Join of Category of graded Lie algebras over Rational Field and Category of subobjects of sets
```
but not every subalgebra is graded, so this would still need separate handling. Because of this it wasn't clear to me if categories should be handled in an 'opt-out' or 'opt-in' manner. The main worry was that if the default is 'opt-out', then any future implementation of a subcategory of Lie algebras would have to also consider whether ideals and subalgebras are automatically in this category, which sounded error-prone.

> I would change `ambient_submodule` to
> 
> ```python
>     def module(self, sparse=False):
>         m = self.ambient().module(sparse=sparse)
>         ambientbasis = [self.lift(X).to_vector() for X in self.basis()]
>         return m.submodule_with_basis(ambientbasis)
> ```
> I found the name somewhat confusing and nothing in the API for `module` forces the result to be an ambient module (nor should it have specifically contain "free" in its doc). The result of `module` is meant to reflect the space where we want to do the linear algebra computations.


Will fix. However I am not sure how to get rid of "free" coming from

```
sage: L.<X,Y,Z> = LieAlgebra(ZZ, {('X','Y'): {'Z': 3}})
sage: L.module(sparse=False)
Ambient free module of rank 3 over the principal ideal domain Integer Ring
```

> `if len(gens) == 0:` -> `if not gens:` Although I think in this case, it is better to not have any generators, even if it makes the code more complicated. I would also strip all copies of 0 from the generating set for better input normalization.


How much processing should be done here? The upper limit I suppose would be to extract a maximal linearly independent subset, but this might be too expensive for high dimensions. I will add the 'cheap' zero-stripping now.

> I would avoid the use of the (more) ambiguous `gens` in the subalgebra code and instead use `lie_algebra_generators`.


I will add `lie_algebra_generators` to subalgebras, but also keep `gens`, since it is used also by ideals, and I think it would be confusing to have the generating set of an ideal referred to as `lie_algebra_generators`.

> Do you want to implement methods like `__add__`, `direct_sum`, `is_subalgebra`, `intersection` (for ideals), etc. on this ticket? Similarly, do we want to add shorthands such as `L[x, L]` and `x.bracket(L)` for creating ideals? (I am happy to do these implementations.)


These sound like very good convenience additions. You can do the implementation as you most likely have a clearer vision on how it should be done.

I will do the other corrections now, except for the default category thing, as I would still like to hear your comments on how to handle the `Graded` issue.



---

archive/issue_comments_364309.json:
```json
{
    "body": "Replying to [comment:10 gh-ehaka]:\n> Replying to [comment:9 tscrim]:\n> > Rather than manually setting the category as default, you should just use\n> > \n> > ```\n> > ambient.category().Subobjects()\n> > ```\n> > as that means you do not need the essentially duplication of `subalgebra` and `ideal` in the fin-dim nilpotent with basis category. It also is a much more robust default.\n\n> \n> The thing I was worried about here is the `Graded` and `Stratified` categories. The result in such cases would be\n> \n> ```\n> sage: LieAlgebras(QQ).Graded().Subobjects()\n> Join of Category of graded Lie algebras over Rational Field and Category of subobjects of sets\n> ```\n> but not every subalgebra is graded, so this would still need separate handling. Because of this it wasn't clear to me if categories should be handled in an 'opt-out' or 'opt-in' manner. The main worry was that if the default is 'opt-out', then any future implementation of a subcategory of Lie algebras would have to also consider whether ideals and subalgebras are automatically in this category, which sounded error-prone.\n\n\nAh, I see your point. However, I think this might be more of an issue of `Subobjects` interacting with `Grading` improperly. The category should be subobjects of the ambient category, but you are correct, it does not imply they are graded. I will ask Nicolas about this.\n\n> > I would change `ambient_submodule` to\n> > \n> > ```python\n> >     def module(self, sparse=False):\n> >         m = self.ambient().module(sparse=sparse)\n> >         ambientbasis = [self.lift(X).to_vector() for X in self.basis()]\n> >         return m.submodule_with_basis(ambientbasis)\n> > ```\n> > I found the name somewhat confusing and nothing in the API for `module` forces the result to be an ambient module (nor should it have specifically contain \"free\" in its doc). The result of `module` is meant to reflect the space where we want to do the linear algebra computations.\n\n> \n> Will fix. However I am not sure how to get rid of \"free\" coming from\n> \n> ```\n> sage: L.<X,Y,Z> = LieAlgebra(ZZ, {('X','Y'): {'Z': 3}})\n> sage: L.module(sparse=False)\n> Ambient free module of rank 3 over the principal ideal domain Integer Ring\n> ```\n\n\nAs for the free modules, the result of `module` are (generally) free modules since we usually work on Lie algebras over fields or PIDs. The result in this case is a free module, so it is somewhat expected in the output.\n\n> > `if len(gens) == 0:` -> `if not gens:` Although I think in this case, it is better to not have any generators, even if it makes the code more complicated. I would also strip all copies of 0 from the generating set for better input normalization.\n\n> \n> How much processing should be done here? The upper limit I suppose would be to extract a maximal linearly independent subset, but this might be too expensive for high dimensions. I will add the 'cheap' zero-stripping now.\n\n\nI think removing the \"cheap\" zeros (i.e., identically zero) gens is sufficient.\n\n> > I would avoid the use of the (more) ambiguous `gens` in the subalgebra code and instead use `lie_algebra_generators`.\n\n> \n> I will add `lie_algebra_generators` to subalgebras, but also keep `gens`, since it is used also by ideals, and I think it would be confusing to have the generating set of an ideal referred to as `lie_algebra_generators`.\n\n\n+1 for keeping `gens`, especially for ideals, but for an ideal, `lie_algebra_generators` should redirect to `basis` (as otherwise `gens` is not guaranteed to generate the ideal as a Lie subalgebra).\n\n> > Do you want to implement methods like `__add__`, `direct_sum`, `is_subalgebra`, `intersection` (for ideals), etc. on this ticket? Similarly, do we want to add shorthands such as `L[x, L]` and `x.bracket(L)` for creating ideals? (I am happy to do these implementations.)\n\n> \n> These sound like very good convenience additions. You can do the implementation as you most likely have a clearer vision on how it should be done.\n\n\nI will do that soon.",
    "created_at": "2018-09-09T06:26:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364309",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:10 gh-ehaka]:
> Replying to [comment:9 tscrim]:
> > Rather than manually setting the category as default, you should just use
> > 
> > ```
> > ambient.category().Subobjects()
> > ```
> > as that means you do not need the essentially duplication of `subalgebra` and `ideal` in the fin-dim nilpotent with basis category. It also is a much more robust default.

> 
> The thing I was worried about here is the `Graded` and `Stratified` categories. The result in such cases would be
> 
> ```
> sage: LieAlgebras(QQ).Graded().Subobjects()
> Join of Category of graded Lie algebras over Rational Field and Category of subobjects of sets
> ```
> but not every subalgebra is graded, so this would still need separate handling. Because of this it wasn't clear to me if categories should be handled in an 'opt-out' or 'opt-in' manner. The main worry was that if the default is 'opt-out', then any future implementation of a subcategory of Lie algebras would have to also consider whether ideals and subalgebras are automatically in this category, which sounded error-prone.


Ah, I see your point. However, I think this might be more of an issue of `Subobjects` interacting with `Grading` improperly. The category should be subobjects of the ambient category, but you are correct, it does not imply they are graded. I will ask Nicolas about this.

> > I would change `ambient_submodule` to
> > 
> > ```python
> >     def module(self, sparse=False):
> >         m = self.ambient().module(sparse=sparse)
> >         ambientbasis = [self.lift(X).to_vector() for X in self.basis()]
> >         return m.submodule_with_basis(ambientbasis)
> > ```
> > I found the name somewhat confusing and nothing in the API for `module` forces the result to be an ambient module (nor should it have specifically contain "free" in its doc). The result of `module` is meant to reflect the space where we want to do the linear algebra computations.

> 
> Will fix. However I am not sure how to get rid of "free" coming from
> 
> ```
> sage: L.<X,Y,Z> = LieAlgebra(ZZ, {('X','Y'): {'Z': 3}})
> sage: L.module(sparse=False)
> Ambient free module of rank 3 over the principal ideal domain Integer Ring
> ```


As for the free modules, the result of `module` are (generally) free modules since we usually work on Lie algebras over fields or PIDs. The result in this case is a free module, so it is somewhat expected in the output.

> > `if len(gens) == 0:` -> `if not gens:` Although I think in this case, it is better to not have any generators, even if it makes the code more complicated. I would also strip all copies of 0 from the generating set for better input normalization.

> 
> How much processing should be done here? The upper limit I suppose would be to extract a maximal linearly independent subset, but this might be too expensive for high dimensions. I will add the 'cheap' zero-stripping now.


I think removing the "cheap" zeros (i.e., identically zero) gens is sufficient.

> > I would avoid the use of the (more) ambiguous `gens` in the subalgebra code and instead use `lie_algebra_generators`.

> 
> I will add `lie_algebra_generators` to subalgebras, but also keep `gens`, since it is used also by ideals, and I think it would be confusing to have the generating set of an ideal referred to as `lie_algebra_generators`.


+1 for keeping `gens`, especially for ideals, but for an ideal, `lie_algebra_generators` should redirect to `basis` (as otherwise `gens` is not guaranteed to generate the ideal as a Lie subalgebra).

> > Do you want to implement methods like `__add__`, `direct_sum`, `is_subalgebra`, `intersection` (for ideals), etc. on this ticket? Similarly, do we want to add shorthands such as `L[x, L]` and `x.bracket(L)` for creating ideals? (I am happy to do these implementations.)

> 
> These sound like very good convenience additions. You can do the implementation as you most likely have a clearer vision on how it should be done.


I will do that soon.



---

archive/issue_comments_364310.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-09T07:49:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364310",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364311.json:
```json
{
    "body": "I made the changes, however I am still having some confusion with the desired behavior for the subalgebra element methods `__getitem__`, `to_vector` and `monomial_coefficients`. \n\nHaving changed `module` to refer to a submodule of the ambient Lie algebra as opposed to the intrinsic module, `to_vector` should naturally give elements in the same ambient format, i.e. not in the intrinsic basis. The doc of `monomial_coefficients` refers to the basis of `self` though, so that is now still given in terms of the intrinsic basis. It wasn't clear to me which of these `__getitem__` should refer to. Currently I left it pointing to `monomial_coefficients`.",
    "created_at": "2018-09-09T08:00:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364311",
    "user": "https://github.com/ehaka"
}
```

I made the changes, however I am still having some confusion with the desired behavior for the subalgebra element methods `__getitem__`, `to_vector` and `monomial_coefficients`. 

Having changed `module` to refer to a submodule of the ambient Lie algebra as opposed to the intrinsic module, `to_vector` should naturally give elements in the same ambient format, i.e. not in the intrinsic basis. The doc of `monomial_coefficients` refers to the basis of `self` though, so that is now still given in terms of the intrinsic basis. It wasn't clear to me which of these `__getitem__` should refer to. Currently I left it pointing to `monomial_coefficients`.



---

archive/issue_comments_364312.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-09T08:12:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364312",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364313.json:
```json
{
    "body": "I think `__getitem__` should mimic `monomial_coefficients` and give things in terms of the intrinsic basis (more generally, if we have some way to give a Lie algebra a custom support set, it should return the coefficient of the basis element corresponding to the input `i`, cf. the Lie algebras defined via structure coefficients).\n\nSo I had a brief email exchange with Nicolas, and the conclusion I arrived to is we probably should (for now) just do the parsing in the explicit subalgebra class (this is what is done in the `SubmoduleWithBasis` class). This will probably be the case until a generic mechanism is added to the category framework.",
    "created_at": "2018-09-09T09:05:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364313",
    "user": "https://github.com/tscrim"
}
```

I think `__getitem__` should mimic `monomial_coefficients` and give things in terms of the intrinsic basis (more generally, if we have some way to give a Lie algebra a custom support set, it should return the coefficient of the basis element corresponding to the input `i`, cf. the Lie algebras defined via structure coefficients).

So I had a brief email exchange with Nicolas, and the conclusion I arrived to is we probably should (for now) just do the parsing in the explicit subalgebra class (this is what is done in the `SubmoduleWithBasis` class). This will probably be the case until a generic mechanism is added to the category framework.



---

archive/issue_comments_364314.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-09T14:10:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364314",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364315.json:
```json
{
    "body": "I think it would be better to have\n\n```\n        category = cat.Subobjects().or_subcategory(category)\n        if ambient in LieAlgebras(ambient.base_ring()).Nilpotent():\n            category = category.Nilpotent()\n```\nsince that way we don't have to force the user to pass a nilpotent category. Likewise, we should allow the user to pass a `category` via `subalgebra` and `ideal`.\n\nThinking a little bit more, we probably want to combine the ideal and subalgebra classes and simply use an attribute `_is_ideal` (for the `basis()` method) and the `self.is_ideal(self.ambient())` as a check for when we need the code to diverge. This would keep things easier to work with as perhaps we construct something as a subalgebra that happens to be an ideal, but we don't want to compute things twice or have messy code to share data. Does that make sense?",
    "created_at": "2018-09-10T07:21:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364315",
    "user": "https://github.com/tscrim"
}
```

I think it would be better to have

```
        category = cat.Subobjects().or_subcategory(category)
        if ambient in LieAlgebras(ambient.base_ring()).Nilpotent():
            category = category.Nilpotent()
```
since that way we don't have to force the user to pass a nilpotent category. Likewise, we should allow the user to pass a `category` via `subalgebra` and `ideal`.

Thinking a little bit more, we probably want to combine the ideal and subalgebra classes and simply use an attribute `_is_ideal` (for the `basis()` method) and the `self.is_ideal(self.ambient())` as a check for when we need the code to diverge. This would keep things easier to work with as perhaps we construct something as a subalgebra that happens to be an ideal, but we don't want to compute things twice or have messy code to share data. Does that make sense?



---

archive/issue_comments_364316.json:
```json
{
    "body": "Replying to [comment:17 tscrim]:\n> I think it would be better to have\n> \n> ```\n>         category = cat.Subobjects().or_subcategory(category)\n>         if ambient in LieAlgebras(ambient.base_ring()).Nilpotent():\n>             category = category.Nilpotent()\n> ```\n> since that way we don't have to force the user to pass a nilpotent category. Likewise, we should allow the user to pass a `category` via `subalgebra` and `ideal`.\n> \n> Thinking a little bit more, we probably want to combine the ideal and subalgebra classes and simply use an attribute `_is_ideal` (for the `basis()` method) and the `self.is_ideal(self.ambient())` as a check for when we need the code to diverge. This would keep things easier to work with as perhaps we construct something as a subalgebra that happens to be an ideal, but we don't want to compute things twice or have messy code to share data. Does that make sense?\n\n\nThat does sound like it could work. Should the class name stay as subalgebra or be something else? I could try to refactor this in later today.",
    "created_at": "2018-09-10T07:32:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364316",
    "user": "https://github.com/ehaka"
}
```

Replying to [comment:17 tscrim]:
> I think it would be better to have
> 
> ```
>         category = cat.Subobjects().or_subcategory(category)
>         if ambient in LieAlgebras(ambient.base_ring()).Nilpotent():
>             category = category.Nilpotent()
> ```
> since that way we don't have to force the user to pass a nilpotent category. Likewise, we should allow the user to pass a `category` via `subalgebra` and `ideal`.
> 
> Thinking a little bit more, we probably want to combine the ideal and subalgebra classes and simply use an attribute `_is_ideal` (for the `basis()` method) and the `self.is_ideal(self.ambient())` as a check for when we need the code to diverge. This would keep things easier to work with as perhaps we construct something as a subalgebra that happens to be an ideal, but we don't want to compute things twice or have messy code to share data. Does that make sense?


That does sound like it could work. Should the class name stay as subalgebra or be something else? I could try to refactor this in later today.



---

archive/issue_comments_364317.json:
```json
{
    "body": "I would just keep it called subalgebra, but in the docs you will have to discuss the new input parameter `is_ideal`, where you can (indirectly) mention that the class will also be used to construct ideals.",
    "created_at": "2018-09-10T07:35:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364317",
    "user": "https://github.com/tscrim"
}
```

I would just keep it called subalgebra, but in the docs you will have to discuss the new input parameter `is_ideal`, where you can (indirectly) mention that the class will also be used to construct ideals.



---

archive/issue_comments_364318.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-10T16:38:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364318",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364319.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-10T16:49:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364319",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364320.json:
```json
{
    "body": "I combined everything into one class, which seemed to work quite nicely as it even cut down on some of the duplicate code e.g. in the basis computation.\n\nI also added the category parameter to the `ideal` and `subalgebra` methods. However testing creation of a stratified subalgebra I realized that the `FilteredModulesWithBasis` category requires the `_indices` attribute. The issue is that the proper `_indices` parameter can only be computed after the basis is computed. So currently trying to use methods of `FilteredModulesWithBasis` before basis computation gives errors\n\n```\nsage: L.<x,y> = LieAlgebra(QQ, abelian=True)\nsage: C = LieAlgebras(QQ).FiniteDimensional().WithBasis().Subobjects().Graded().Stratified()\nsage: S = L.subalgebra(x,category=C)\nsage: S.homogeneous_component_basis(1).list()\nTraceback (most recent call last):\n...\nAttributeError: 'LieSubalgebra_finite_dimensional_with_basis_with_category' object has no attribute '_indices'\nsage: B = S.basis()\nsage: S.homogeneous_component_basis(1).list()\n[x]\n```\nI'm not sure how to handle the issue of not knowing the proper indices a priori. Having `_indices` initially correspond to the generators did not seem like a good solution, since the `degree_on_basis` method of `FiniteDimensionalGradedLieAlgebrasWithBasis.Stratified` will immediately compute the basis, and then the the old `_indices` will be irrelevant, leading to strange results for e.g. `homogeneous_component_basis`.\n\nIs the correct way to fix this behavior to create a subclass for graded subalgebras or is there something else that could be done? Alternatively, the proper implementation of graded subalgebras could also be left to a later ticket.",
    "created_at": "2018-09-10T17:10:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364320",
    "user": "https://github.com/ehaka"
}
```

I combined everything into one class, which seemed to work quite nicely as it even cut down on some of the duplicate code e.g. in the basis computation.

I also added the category parameter to the `ideal` and `subalgebra` methods. However testing creation of a stratified subalgebra I realized that the `FilteredModulesWithBasis` category requires the `_indices` attribute. The issue is that the proper `_indices` parameter can only be computed after the basis is computed. So currently trying to use methods of `FilteredModulesWithBasis` before basis computation gives errors

```
sage: L.<x,y> = LieAlgebra(QQ, abelian=True)
sage: C = LieAlgebras(QQ).FiniteDimensional().WithBasis().Subobjects().Graded().Stratified()
sage: S = L.subalgebra(x,category=C)
sage: S.homogeneous_component_basis(1).list()
Traceback (most recent call last):
...
AttributeError: 'LieSubalgebra_finite_dimensional_with_basis_with_category' object has no attribute '_indices'
sage: B = S.basis()
sage: S.homogeneous_component_basis(1).list()
[x]
```
I'm not sure how to handle the issue of not knowing the proper indices a priori. Having `_indices` initially correspond to the generators did not seem like a good solution, since the `degree_on_basis` method of `FiniteDimensionalGradedLieAlgebrasWithBasis.Stratified` will immediately compute the basis, and then the the old `_indices` will be irrelevant, leading to strange results for e.g. `homogeneous_component_basis`.

Is the correct way to fix this behavior to create a subclass for graded subalgebras or is there something else that could be done? Alternatively, the proper implementation of graded subalgebras could also be left to a later ticket.



---

archive/issue_comments_364321.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-10T19:08:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364321",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364322.json:
```json
{
    "body": "Make `_indices` a ``@`lazy_attribute`:\n\n```python\nfrom sage.misc.lazy_attribute import lazy_attribute\nfrom sage.sets.finite_enumerated_set import FiniteEnumeratedSet\n\n@lazy_attribute\ndef _indices(self):\n    return FiniteEnumeratedSet(self.basis().keys())\n```\nWith this, the first part of your example passes. (The reason for `FiniteEnumeratedSet` is so that `S._indices.cardinality()` will work and is consistent with other parts of Sage.)",
    "created_at": "2018-09-10T23:15:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364322",
    "user": "https://github.com/tscrim"
}
```

Make `_indices` a ``@`lazy_attribute`:

```python
from sage.misc.lazy_attribute import lazy_attribute
from sage.sets.finite_enumerated_set import FiniteEnumeratedSet

@lazy_attribute
def _indices(self):
    return FiniteEnumeratedSet(self.basis().keys())
```
With this, the first part of your example passes. (The reason for `FiniteEnumeratedSet` is so that `S._indices.cardinality()` will work and is consistent with other parts of Sage.)



---

archive/issue_comments_364323.json:
```json
{
    "body": "Although code generally should not be using `_indices` as this just serves to index the keys of the generators, not necessarily the basis. I might consider also changing the code in `filtered_modules_with_basis` to use `self.basis().keys()` instead of `self._indices`, but that should be done on a separate ticket. (The reason it is doing this is because it was more or less assuming that things in this category are subclasses of `CombinatorialFreeModule`.)",
    "created_at": "2018-09-10T23:18:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364323",
    "user": "https://github.com/tscrim"
}
```

Although code generally should not be using `_indices` as this just serves to index the keys of the generators, not necessarily the basis. I might consider also changing the code in `filtered_modules_with_basis` to use `self.basis().keys()` instead of `self._indices`, but that should be done on a separate ticket. (The reason it is doing this is because it was more or less assuming that things in this category are subclasses of `CombinatorialFreeModule`.)



---

archive/issue_comments_364324.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-11T04:38:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364324",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364325.json:
```json
{
    "body": "My last round of comments (I am pretty sure); just two more things. I can do these fixes too (since I also have the other ideal creation to take care of too) if you prefer.\n\n- We probably should do some form of caching on `monomial_coefficients` for each element. I would do a `_monomial_coefficients`, defaulting to `None` that stores the computation, then have\n  {{{#!python\ndef monomial_coefficients(self, copy=False):\n    if self._monomial_coefficients is None:\n        sm = self.parent().module()\n        v = sm.coordinate_vector(self.to_vector())\n        self._monomial_coefficients = {k: v[k] for k in range(len(v)) if not v[k].is_zero()}\n    if copy:\n        return dict(self._monomial_coefficients)\n    return self._monomial_coefficients\n  }}}\n  Using this, we can also override\n  {{{#!python\nfrom sage.data_structures.blas_dict import add\ndef _add_(self, other):\n  sup = super(self, LieSubalgebra_finite_dimensional_with_basis.Element)\n  ret = sup._add_(other)\n  if self._monomial_coefficients is not None and other._monomial_coefficients is not None:\n      ret._monomial_coefficients = add(self._monomial_coefficients, other._monomial_coefficients)\n  }}}\n  and similarly for all of the other basic operations. I would also move this all into `lie_algebra_element.pyx`. What do you think?\n- `if not v[k].is_zero()` -> `if v[k]`.",
    "created_at": "2018-09-11T05:43:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364325",
    "user": "https://github.com/tscrim"
}
```

My last round of comments (I am pretty sure); just two more things. I can do these fixes too (since I also have the other ideal creation to take care of too) if you prefer.

- We probably should do some form of caching on `monomial_coefficients` for each element. I would do a `_monomial_coefficients`, defaulting to `None` that stores the computation, then have
  {{{#!python
def monomial_coefficients(self, copy=False):
    if self._monomial_coefficients is None:
        sm = self.parent().module()
        v = sm.coordinate_vector(self.to_vector())
        self._monomial_coefficients = {k: v[k] for k in range(len(v)) if not v[k].is_zero()}
    if copy:
        return dict(self._monomial_coefficients)
    return self._monomial_coefficients
  }}}
  Using this, we can also override
  {{{#!python
from sage.data_structures.blas_dict import add
def _add_(self, other):
  sup = super(self, LieSubalgebra_finite_dimensional_with_basis.Element)
  ret = sup._add_(other)
  if self._monomial_coefficients is not None and other._monomial_coefficients is not None:
      ret._monomial_coefficients = add(self._monomial_coefficients, other._monomial_coefficients)
  }}}
  and similarly for all of the other basic operations. I would also move this all into `lie_algebra_element.pyx`. What do you think?
- `if not v[k].is_zero()` -> `if v[k]`.



---

archive/issue_comments_364326.json:
```json
{
    "body": "I take it moving things to `lie_algebra_element.pyx` is a speed optimization? Sounds good to me. If it is not too much trouble for you, you can handle these.",
    "created_at": "2018-09-11T06:09:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364326",
    "user": "https://github.com/ehaka"
}
```

I take it moving things to `lie_algebra_element.pyx` is a speed optimization? Sounds good to me. If it is not too much trouble for you, you can handle these.



---

archive/issue_comments_364327.json:
```json
{
    "body": "Yes, it would be an optimization (because it will be in Cython and closer to C code). I will get to work on them now.",
    "created_at": "2018-09-11T06:12:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364327",
    "user": "https://github.com/tscrim"
}
```

Yes, it would be an optimization (because it will be in Cython and closer to C code). I will get to work on them now.



---

archive/issue_comments_364328.json:
```json
{
    "body": "Okay, here are those changes. I did not do `x.bracket(L)` because that was going to be too much work to make sure it was consistent across the board, and it is really syntactic sugar at the end of the day.\n\nIf my changes are good, then I believe we are at a positive review.\n\n---\nNew commits:",
    "created_at": "2018-09-11T07:18:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364328",
    "user": "https://github.com/tscrim"
}
```

Okay, here are those changes. I did not do `x.bracket(L)` because that was going to be too much work to make sure it was consistent across the board, and it is really syntactic sugar at the end of the day.

If my changes are good, then I believe we are at a positive review.

---
New commits:



---

archive/issue_comments_364329.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-09-11T09:10:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364329",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_364330.json:
```json
{
    "body": "All the improvements above look good to me. I also added a doctest to the initialization of a subalgebra element (at least I assume that was what patchbot was complaining about).",
    "created_at": "2018-09-11T09:14:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364330",
    "user": "https://github.com/ehaka"
}
```

All the improvements above look good to me. I also added a doctest to the initialization of a subalgebra element (at least I assume that was what patchbot was complaining about).



---

archive/issue_comments_364331.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-09-11T09:14:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364331",
    "user": "https://github.com/ehaka"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_364332.json:
```json
{
    "body": "Whoops, yes, I forgot to add that. Thank you.",
    "created_at": "2018-09-11T12:48:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364332",
    "user": "https://github.com/tscrim"
}
```

Whoops, yes, I forgot to add that. Thank you.



---

archive/issue_events_065094.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-09-12T19:58:39Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/25841#event-65094"
}
```



---

archive/issue_comments_364333.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-09-12T19:58:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25841",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25841#issuecomment-364333",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
