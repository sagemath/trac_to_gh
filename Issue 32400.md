# Issue 32400: Add sage.geometry.abc; deprecate is_Polyhedron, is_LatticePolytope, is_Cone, ...

Issue created by migration from https://trac.sagemath.org/ticket/32637

Original creator: mkoeppe

Original creation time: 2021-10-05 17:52:48

CC:  @kliem mjo egourgoulhon


```
$ git grep 'def is_[A-Z]' src/sage/geometry/
src/sage/geometry/cone.py:def is_Cone(x):
src/sage/geometry/fan.py:def is_Fan(x):
src/sage/geometry/lattice_polytope.py:def is_LatticePolytope(x):
src/sage/geometry/lattice_polytope.py:def is_NefPartition(x):
src/sage/geometry/point_collection.pyx:def is_PointCollection(x):
src/sage/geometry/polyhedron/base.py:def is_Polyhedron(X):
src/sage/geometry/toric_lattice.py:def is_ToricLattice(x):
src/sage/geometry/toric_lattice.py:def is_ToricLatticeQuotient(x):
src/sage/geometry/toric_lattice_element.pyx:def is_ToricLatticeElement(x):
```


A small number of uses outside of `sage.geometry` will need updating. `$ git grep 'geometry.*import.*is_[A-Z]' src/sage/`

(Part of meta-ticket #32414)


---

Comment by mkoeppe created at 2021-10-17 21:17:30

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2021-10-17 21:17:30

New commits:


---

Comment by mjo created at 2021-10-18 00:35:31

I worry that we're changing `is_Foo()` to mean "does this object provide the interface defined by `abc.Foo`?" But then `abc.Foo` doesn't declare any methods, properties, or data.

On the other hand, you don't want to put the implementation into the base class, because the whole point is to avoid importing the implementations to perform a typecheck. Nor does it make much sense to blindly add a million ``@`abstractmethod def foo(...): pass` lines to each ABC. I guess in lieu of an alternative, it has to be OK.

I wonder if something ridiculous like this wouldn't also work as an interim hack:


```
sage: def is_Polyhedron(C):
....:     return "Polyhedron_base" in [c.__name__ for c in C.__class__.__mro__]
```


You can also check the (string) module name with `c.__module__` to avoid name clashes. But chances are, it's slower at runtime.


---

Comment by mkoeppe created at 2021-10-18 00:37:18

Replying to [comment:5 mjo]:
> I worry that we're changing `is_Foo()` to mean "does this object provide the interface defined by `abc.Foo`?" But then `abc.Foo` doesn't declare any methods, properties, or data.

As explained in #32414, "each of the new abstract base classes is intended to have a unique direct implementation subclass. Attempting to define new hierarchies of abstract base classes is beyond the scope of this ticket. Also, the new classes do not define any methods.".


---

Comment by mkoeppe created at 2021-10-18 00:42:00

Replying to [comment:5 mjo]:
> I wonder if something ridiculous like this wouldn't also work as an interim hack:
> {{{
> sage: def is_Polyhedron(C):
> ....:     return "Polyhedron_base" in [c.__name__ for c in C.__class__.__mro__]
> }}}
Yeah, I'm not interested in a solution that looks like this


---

Comment by mjo created at 2021-10-18 00:46:18

Replying to [comment:6 mkoeppe]:
> 
> As explained in #32414, "each of the new abstract base classes is intended to have a unique direct implementation subclass. Attempting to define new hierarchies of abstract base classes is beyond the scope of this ticket. Also, the new classes do not define any methods.".

I saw that, but unless you plan to live forever and spend most of it monitoring trac, there's no technical means to enforce that restriction.


---

Comment by mkoeppe created at 2021-10-18 00:50:00

Sounds like someone wants to write a decorator for these types of classes


---

Comment by git created at 2021-10-18 00:51:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2021-10-18 01:32:49

Replying to [comment:9 mkoeppe]:
> Sounds like someone wants to write a decorator for these types of classes

I don't know how to do it with a decorator, but I think a metaclass can ensure that a given class is only subclassed once. As an added bonus, the metaclass can explain why these exist and how they should be used (i.e. that they aren't really abstract base classes).

This example fails (as intended) the second time we subclass:


```python
class TypeCheckWrapper(type):
    _subclasses = 0

    def __init__(cls, name, bases, clsdict):
        if len(cls.mro()) > 2:
            TypeCheckWrapper._subclasses += 1
            if TypeCheckWrapper._subclasses > 1:
                raise TypeError("TypeCheckWrapper with multiple subclasses")
        super(TypeCheckWrapper, cls).__init__(name, bases, clsdict)

class Polyhedron(metaclass=TypeCheckWrapper):
    pass

print("Defined base class Polyhedron")

class Cone(Polyhedron):
    pass

print("Defined class Cone(Polyhedron)")

class Polytope(Polyhedron):
    pass

print("Defined class Polytope(Polyhedron)")
```



---

Comment by mkoeppe created at 2021-10-18 01:38:11

I think this discussion should go to a separate ticket. Note also that some of the ABCs added in other tickets of #32414 are actually extension classes, and using a metaclass there is probably tricky.


---

Comment by mkoeppe created at 2021-10-18 02:04:26

A simple solution could be to just add a doctest for the MRO length. We enforce pretty much everything else with doctests as well.


---

Comment by mkoeppe created at 2021-10-18 02:32:07


```
    TESTS::

        sage: import sage.geometry.abc
        sage: len(sage.geometry.abc.Polyhedron.__subclasses__()) <= 1
        True
```



---

Comment by git created at 2021-10-18 02:51:57

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by mkoeppe created at 2021-10-18 02:52:08

How's this?


---

Comment by git created at 2021-10-18 03:31:49

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2021-10-18 03:37:38

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by mjo created at 2021-10-19 02:09:40

Changing status from needs_review to positive_review.


---

Comment by mjo created at 2021-10-19 02:09:40

We actually have a module (`sage.cpython.cython_metaclass`)  that hacks metaclasses into cython using undocumented internals. What could possibly go wrong?

Using doctests is good enough.


---

Comment by mkoeppe created at 2021-10-19 02:22:16

Thanks!


---

Comment by vbraun created at 2021-10-20 23:00:52

Resolution: fixed
