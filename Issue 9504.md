# Issue 9504: Add support for toric sublattices

Issue created by migration from https://trac.sagemath.org/ticket/9504

Original creator: novoselt

Original creation time: 2010-07-15 07:40:09

Assignee: mhampton

CC:  vbraun

Following discussion of #9296, I am rewriting toric lattices to allow construction of sublattices.

Apply after #9245.


---

Comment by novoselt created at 2010-07-15 07:44:40

Changing status from new to needs_work.


---

Attachment

Hi Volker, 

The new version of the patch is completely documented, does not brake anything in existing modules anymore, and in general, I think, provides quite satisfactory support for toric sublattices, with the exception of `dual` which requires quotient lattices and I need some input on them.

For sublattices, as before, I have followed `ZZ^n` behaviour with minimal interference and it seems to work just fine. For quotients it is probably not the way to go, since we are considering a special case of quotients without torsion. Look at the following example:

```
sage: N = ToricLattice(3)
sage: Ns = N.submodule_with_basis([N(1,2,3)])
sage: Ns
Free module of degree 3 and rank 1 over Integer Ring
User basis matrix:
[1 2 3]
sage: Ns.basis()
[
N(1, 2, 3)
]
sage: Ns(N(1,2,3))
N(1, 2, 3)
sage: N.dual().gen(0) * Ns.gen(0)
1
sage: Q = N/Ns
sage: Q
Finitely generated module V/W over Integer Ring with invariants (0, 0)
sage: Q.gens()
((1, 0), (0, 1))
sage: Q.gen(0).lift()
N(0, 0, 1)
sage: Q(N(3,2,1))
(-8, -4)
sage: N.dual().gen(0) * Q.gen(0)
...
TypeError: unsupported operand parent(s) for '*':
'3-d lattice M' and 'Finitely generated module V/W
over Integer Ring with invariants (0, 0)'
```

Elements of `N` and its sublattice are actually represented by elements of `N` (although elements of `Ns` know internally that they belong to `Ns`, i.e. their `parent` is `Ns`). Elements of `Q`, on the other hand, are represented by their coordinates in some basis. The natural dual of `Q` is some sublattice of `N.dual()`, so in this notation we will have as a legal operation something like `Q(1,2) * M(3,0,-1)` which does not look nice to me. Plus, `Q` here cannot be a toric lattice in the same sense as `N` since `N` is unique but it may have different 2-dimensional quotient lattices with different coercion maps.

 * What do you think about representing elements of `Q` by elements of `N` as well? `Q(N(e))` can either be "the same" as `e`, or we can convert any input to its "canonical" representative with respect to the fixed lift. I think the second choice is probably better. Of course, it still will be possible to get coordinates of elements in a basis of the quotient.
 * Should we somehow distinguish these quotient elements in printing/latexing? In LaTeX it makes sense just to draw a bar over the whole representative, printing is a bit trickier. Maybe `N/(1,2,3)` or `N-(1,2,3)`? These do look like arithmetic operations, but since they should not appear in expressions, it should not be too confusing, especially the first form with "quotient by a vector".
 * Do we care about the choice of the basis for the quotient? I.e. should there be a possibility to specify it? If not, I think the best way is to take the same one as is generated by the standard quotient method. (If yes, we can also choose the basis of dual quotient/sublattice as dual to the basis of the original sublattice/quotient.) 

Let me know what you think,

Andrey


---

Comment by vbraun created at 2010-07-21 04:50:41

I don't know yet what to do with quotients, but can we change the representation of sublattices to, for example,

```
sage: L = ToricLattice(3, "L")
sage: L.submodule_with_basis([(3,2,1),(1,2,3)])
Sublattice <L(3, 2, 1), L(1, 2, 3)> of 3-d lattice L
sage: L.submodule([(3,2,1)])
1-d sublattice of 3-d lattice L
```

Patch is attached.


---

Comment by novoselt created at 2010-07-21 05:03:36

Yes, of course, I actually was going to do something like that but forgot. 

I would prefer not to have different `_repr_` and `_latex_` for the second class - can we always show `basis()` no matter how it was obtained?


---

Comment by vbraun created at 2010-07-21 14:04:20

My thinking was that only if you use `submodule_with_basis` then you are actually interested in the precise form of the basis. In both cases, the LaTeX representation is the same (lack of imagination on my part, perhaps :-)

Of course there is something to be said for uniform output, too. I could live with that as well...


---

Comment by novoselt created at 2010-07-21 14:37:04

I was thinking that it is nice for distinguishing different sublattices. While "3-d lattice N" is almost unique (exactly unique if the user didn't meddle with dual and LaTeX names), "1-d sublattice of 3-d lattice N" is not as descriptive. And I think that in most cases users don't use `_with_basis`, but they may get such sublattices as output of other functions. In this case it may be strange that sometimes there is a basis and sometimes there isn't.

It will indeed be more uniform with free submodules behaviour. They actually put a special line indicating whether it is a user basis or the echelonized one. I find their output to be too long and taking too many lines, also that's my personal taste and I don't propose changing it.


---

Comment by vbraun created at 2010-07-23 19:14:18

I've looked at the code for quotients in Sage, which is `FGP_Module_class` and `FGP_Element`. The elements of `Q=N/Ns` already carry a dual representation, both their quotient (in an arbitrary but fixed basis for `Q`) as well as their representative in `N` is stored.

We could derive from FGP_Module_class/FGP_Element to print

```
sage: N.submodule_with_basis([N(1,2,3),N(3,2,1)]) / N.submodule_with_basis([N(1,2,3)])
The quotient lattice <N(1,2,3),N(3,2,1)>/<N(1,2,3)>
```

I agree that `Q(1,2) * M(3,0,-1)` looks a bit odd, so i think we should force the user to make the lifts explicit: `Q(1,2).lift() * M(3,0,-1)`. This also prevents surprises if `M(3,0,-1)` were not in the dual of the quotient, in which case the product does depend on the chosen lift.

The way `FGP_Module_class` randomly picks a basis for the quotient is fine, I think. I don't foresee any need to specify the quotient basis. 

Andrey, did you make any further changes? I can implement the above if you want.


---

Comment by novoselt created at 2010-07-24 06:23:20

My main progress on quotients so far was looking over these FGP modules and thinking what should we do. I think I am in favor of leaving `quotient` and `/` to be the same as they are with possibility to produce torsion modules, but implementing `quotient_lattice` to return some `ToricLattice_quotient` object which is **NOT** derived from `FGP_module_class` and works only when there is no torsion. Reasons:
 * "Toric lattice" is a thing isomorphic to `ZZ^n`, so if we want a quotient which is also a toric lattice, it should not contain torsion.
 * This case is likely to be simpler than general quotients and, therefore, can be implemented more efficiently than general quotients.
 * In this case I do want elements of these quotients behave differently from the "usual ones," details below.
 * On the other hand, it is probably still nice to have a possibility to construct torsion quotients, so it would be better not to hide this functionality completely.

There more I think about it, the more I get convinced that quotient lattices and their elements should behave as follows:
 * Quotients don't have their own names, they are attached to the original ambient lattices.
 * Elements do have both representations: in terms of some basis for the quotient and a fixed representative of the class. The latter is the one which is used "externally".
 * If `Q` is a 2-d sublattice of a 3-d lattice `N`, I think that its elements should print like
 {{{
N[1,2,3]
}}}
 i.e. still shown as elements of N, but with some hint that this is a quotient object, after all, that's exactly how quotient objects are represented in mathematics: by an element of the original space with a bar on top or something like this.
 * Creation of elements of `Q` should work both as `Q(1,2,3)` and `Q(1,2)` - in the first case an element of `N` is used and in the second one - the internal basis (there should be no confusion between two - if `Q` and `N` are of the same dimension, then `Q` is `N`). This will allow users to write
 {{{
Q(1,2,3) * M(1,2,3)
}}}
 and it will either work if `M(1,2,3)` is an element of the lattice dual to `Q`, i.e. it is within proper submodule where the choice of a representative for elements of `Q` does not matter, or an exception will be raised. Those who know what they are doing can also use 
 {{{
Q(1,2,3).lift() * M(1,2,3)
}}}
 and in this case there can be no error but the result may depend on the choice of the lift (which is fixed during any given session, at least).

 I think such behaviour is cleaner and more consistent than using coordinates in internal basis, it will also clearly distinguish all elements that are related to the same ambient lattice, no matter how many submodules and quotients are involved. Plus, it is more or less clear what is `Q(1,2,3)`, but what is `Q(1,2)`, how is it related to its lift, and how will it pair with a given element of the dual lattice?

Coming back to the proposal not to derive from FGP. One more good point is that we may represent nested sublattices/quotients more efficiently (I think all obejcts of the form "quotient of quotient of sublattice of quotient" can be represented by a single quotient of a sublattice of an ambient lattice). Bad point is that we may work a little bit harder and we may loose consistency with "standard quotients".

So we need to decide on: 1) Should `ToricLattice_quotient` derive from `FGP_Module_class` or not? 2) Should we represent quotient elements mostly by representatives as described above?


---

Comment by vbraun created at 2010-07-24 14:56:28

I like your proposal. I think it would be faster to simply derive from `FGP_Module`, but I agree that an independent `ToricLattice_quotient` would integrate better with the other `ToricLattice`s.


---

Comment by novoselt created at 2010-07-30 07:01:39

OK, after thinking some more and actually working on it, I decided to stick with derivation from FGP_Module. The most important things for now (i.e. for lattices associated to cones) are quotients of ambient toric lattices by its saturated submodules and being able to get both lifts of elements of the quotient to the ambient lattice and coordinates of these elements in some fixed basis of the quotient. It is also important to fix creation of quotients and their elements, to avoid code adjustments, and text representations to avoid doctest adjustments. I hope that the new patch does address these issues and if we want to add some functionality or to change implementation later it should not be too difficult.

Creation of elements for free modules works (and does not work) like this:

```
sage: Q = ZZ^3 / span([vector([1,2,3])])
sage: Q
Finitely generated module V/W over Integer Ring with invariants (0, 0)
sage: Q(1,2)
TypeError: can't initialize vector from nonzero non-list
sage: Q(1,2,3)
TypeError: __call__() takes at most 3 arguments (4 given)
sage: Q([1,2,3])
TypeError: length of v must be at most the number of rows of self
sage: Q([1,2])
(1, 2)
sage: Q([1])
(1, 0)
sage: Q([])
(0, 0)
```

I find most of the above lines counter-intuitive. The same thing for proposed toric quotients:

```
sage: N = ToricLattice(3)
sage: Q = N/N.submodule([N(1,2,3)])
sage: Q(1,2)
TypeError: x must be a list of the right length
sage: Q(1,2,3)
N[1, 2, 3]
sage: Q([1,2,3])
N[1, 2, 3]
sage: Q([1,2])
TypeError: x must be a list of the right length
sage: Q([1])
TypeError: x must be a list of the right length
sage: Q([])
TypeError: x must be a list of the right length
```

So, basically, to easily create an element of `Q` one needs to think in terms of the original ambient lattice `N`. And elements print in terms of `N` (with "[]" instead of "()"). It is still possible to operate with generators of `Q` when necessary:

```
sage: Q.linear_combination_of_smith_form_gens([1,2])
N[0, 2, 1]
sage: Q(0,2,1)
N[0, 2, 1]
sage: Q(0,2,1).vector()
(1, 2)
```

(I don't quite like this `vector` name, but that's what is inherited.)

I have not done any work on dual lattices for sublattices and quotients, nor on action on their elements. Is it required for #9296? If not, may be we can proceed and worry about it later (I added it to my growing todo-list ;-)) However we get for free support of torsion quotients and iterated constructions:

```
sage: subQ = Q.submodule([(3,3,3)])
sage: subQ
1-d lattice, quotient of Sublattice <N(1, 2, 3), N(0, 3, 6)> by Sublattice <N(1, 2, 3)>
sage: Q/subQ
Torsion quotient of 3-d lattice N by Sublattice <N(1, 2, 3), N(0, 3, 6)>
```

I made printing different for torsion and non-torsion quotients. Latexing is the same, since it does not use words in any of our objects and I don't see a good "wordless" way to indicate torsion presence.

Bottom line: I am marking this as "needs review" since I hope that patches are correct and satisfactory for current needs and it is possible to build missing features on top of them.


---

Comment by novoselt created at 2010-07-30 07:01:39

Changing status from needs_work to needs_review.


---

Attachment


---

Comment by vbraun created at 2010-08-05 19:27:00

I'm happy with a different string `_repr_()` in the case with torsion, but I would prefer 

```
sage: Q/subQ
Quotient with torsion of 3-d lattice N by Sublattice <N(1, 2, 3), N(0, 3, 6)>
```

to make it clear that the quotient is not *pure* torsion.


---

Comment by vbraun created at 2010-08-07 04:05:42

In the patch below I:
  * changed the `_repr_()` output as per my previous comment
  * allow coercion from quotient lattice into a new `ToricLattice`, see the changed docstring of `ToricLattice.__call__`.
  * some pickling fixes
  * added a method `ToricLattice_quotient._make_generator_positive_on()` to change the sign of a generator as required for the lattice computations later.
With these changes, I'm ready to give it a positive review. Let me know if you agree :-)


---

Comment by novoselt created at 2010-08-10 02:03:14

I agree in general, but have some comments:
 * Thanks for catching my copy-pasted missing ":"!
 * `_repr_` modification is great, it does make the description more clear.
 * What is called "coercion" in the documentation and comments is "construction/conversion" since it does not happen implicitly (and I don't think that it should!).
 * Pickle improvement are also great, but the function `unpickle_v1` is missing documentation and tests and shows in `sage -coverage`.

Finally, I don't quite like new treatment of `gens` and I am a bit confused with its implementation:
 * Is it possible for your purposes to pass "the point generator should be positive on" as an optional argument to constructor, i.e. something like
 {{{
sage: Q = N.quotient(sublattice, positive_point=point)
}}}
 My point is that I expect generators to be fixed, but the proposed version makes it is possible to change them after creation. If it is really necessary to set it up later, let's leave it as is.
 * Why the requirement is to get positive pairing with some element of the covering lattice? Shouldn't it be an element from the lattice dual to `self.cover()`? Then the important sign will be `self.lift() * point` rather then the expression involving multiple conversions to circumvent the "defense system" against pairing of elements of the same lattice.


---

Comment by novoselt created at 2010-08-10 02:03:14

Changing status from needs_review to needs_info.


---

Comment by vbraun created at 2010-08-10 04:40:34

I'll rename coercion->construction and add the missing docstrings. 

About the generators of the quotient lattice, making them part of the constructor call is fine, too. Should two quotient lattices with different (but equivalent) generators be equal? Currently, the `__eq__()` method does not compare the generators.

Later on, the "positive direction" will be determined by a ray of the cone that is not a ray of the subcone. So its convenient if it can be specified by a lattice point and not a dual lattice point. I don't know any other place where one needs to fix the sign of quotient generators, so I haven't tried to write it more general.


---

Comment by novoselt created at 2010-08-10 05:26:54

I think for equality testing of quotient lattices the choice of generators is irrelevant, especially since we have emphasis on representation by lifts, rather than in terms of generators. I am concerned about generators change for the same object, since the choice of generators may have been used somewhere already and cached. In fact I have just tried the following, which does not seem right to me:

```
sage: N = ToricLattice(3)
sage: Ns = N.submodule([N(1,1,1), N(1,2,3)])
sage: Q = N/Ns
sage: Q
1-d lattice, quotient of 3-d lattice N by Sublattice <N(1, 0, -1), N(0, 1, 2)>
sage: q1 = Q(1,0,0)
sage: q1
N[1, 0, 0]
sage: q1.vector()
(1)
sage: Q.gen(0)
N[0, 0, 1]
sage: Q._make_generator_positive_on(N(0,0,-1))
sage: Q.gen(0)
N[0, 0, -1]
sage: q2 = Q(1,0,0)
sage: q2
N[1, 0, 0]
sage: q2.vector()
(1)
```

So perhaps this change should be done on a deeper level. Note that it is also possible to compare these elements from different lattices

```
sage: q1.parent() is q2.parent()
False
sage: q1 == q2
True
```

and in fact I would expect it to fail here since comparison of elements is done using their coordinate representation in terms of generators, which should be different.

As far as the computation of the "positive direction" goes, I am fine with leaving it as is, but perhaps inserting into the docstring your explanation above.


---

Comment by vbraun created at 2010-08-10 21:46:56

I've updated the reviewer patch accordingly. Now the coordinate vectors work as expected:

```
sage: N = ToricLattice(3)
sage: Ns = N.submodule([N(1,1,1), N(1,2,3)])
sage: Q = N.quotient(Ns, positive_point=N(0,0,-1))
sage: Q.gen(0)
N[0, 0, -1]
sage: Q.gen(0).vector()
(1,)
sage: Q(0,0,-1)
N[0, 0, -1]
sage: Q(0,0,-1).vector()
(1,)
sage: q1 = Q(1,0,0)
sage: q1
N[1, 0, 0]
sage: q1.vector()
(-1,)
```



---

Comment by vbraun created at 2010-08-10 21:47:39

Changing status from needs_info to needs_review.


---

Comment by vbraun created at 2010-08-11 01:40:39

There was one more bug in the check that `positive_dual_point` is in the right lattice, now it works correctly including the Chow group computations that depend on it.


---

Comment by vbraun created at 2010-08-11 01:41:52

Updated patch


---

Attachment


---

Attachment

I made `coordinate_vector/vector` to return a vector rather than tuple and fixed a couple of typos. I think now it is ready to be switched to "positive review" and I am moving on to the next one!


---

Comment by vbraun created at 2010-08-13 19:38:55

I agree with your changes! What confused me was that the docstring of `FGP_Module_class.coordinate_vector` does say that it returns a tuple, but alas, it does return a vector. I'll attach an updated patch to fix this docstring, too. Feel free to set positive review...


---

Comment by vbraun created at 2010-08-13 19:39:45

Updated docstring


---

Comment by novoselt created at 2010-08-13 21:23:25

Changing status from needs_review to positive_review.


---

Attachment

For the release manager: apply all patches in the order listed, but only the second version of the very last one.


---

Comment by mpatel created at 2010-08-15 09:09:32

Please update [attachment:trac_9504_change_sublattice_repr.patch] with a more descriptive commit string.


---

Comment by mpatel created at 2010-08-15 09:09:32

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2010-08-15 14:43:28

Added commit message


---

Attachment

I've added the customary commit message to the patch. I'll set this ticket back to positive review since only metadata was changed.

Apply patches in this order:

  * trac_9504_add_support_for_toric_sublattices.patch
  * trac_9504_change_sublattice_repr.patch
  * trac_9504_add_support_for_quotients_of_toric_lattices.patch
  * trac_9504_reviewer_changes.patch
  * trac_9504_last_changes.2.patch


---

Comment by vbraun created at 2010-08-15 14:46:50

Changing status from needs_work to positive_review.


---

Comment by mpatel created at 2010-09-15 10:00:58

Resolution: fixed
