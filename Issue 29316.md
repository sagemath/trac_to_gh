# Issue 29316: add a method to test whether a polynomial is symmetric

archive/issues_029316.json:
```json
{
    "body": "CC:  @nbruin @tscrim\n\nAs mentioned in [this sage-devel thread](https://groups.google.com/forum/#!topic/sage-devel/Z9YS7Hh146I) it is desirable to have a simple check to test whether a given polynomial is symmetric (with respect to a given permutation group).\n\nThis ticket aims to implement a generic `is_symmetric(self, group=None)` on multivariate polynomials (where the default group is the full symmetric group).\n\nIssue created by migration from https://trac.sagemath.org/ticket/29553\n\n",
    "created_at": "2020-04-23T10:04:15Z",
    "labels": [
        "component: algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.1",
    "title": "add a method to test whether a polynomial is symmetric",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/29316",
    "user": "https://github.com/videlec"
}
```
CC:  @nbruin @tscrim

As mentioned in [this sage-devel thread](https://groups.google.com/forum/#!topic/sage-devel/Z9YS7Hh146I) it is desirable to have a simple check to test whether a given polynomial is symmetric (with respect to a given permutation group).

This ticket aims to implement a generic `is_symmetric(self, group=None)` on multivariate polynomials (where the default group is the full symmetric group).

Issue created by migration from https://trac.sagemath.org/ticket/29553





---

archive/issue_comments_415166.json:
```json
{
    "body": "New commits:",
    "created_at": "2020-04-23T11:46:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415166",
    "user": "https://github.com/videlec"
}
```

New commits:



---

archive/issue_comments_415167.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-04-23T11:46:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415167",
    "user": "https://github.com/videlec"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_415168.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-04-23T11:49:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415168",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_415169.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-04-23T16:31:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415169",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_415170.json:
```json
{
    "body": "It might be good to convert the polynomial to a dictionary first in order to speed up the looking up of coefficients, e.g.:\n\n```diff\n-        for e in self.exponents():\n-            coeff = self[e]\n-            for g in gens:\n-                if self[e.permuted(g)] != coeff:\n-                    return False\n-        return True\n+        pd = self.dict()\n+        return all(pd[e.permuted(g)] == c for e, c in pd.items() for g in gens)\n```\n\n\nFor the example at hand, this is noticeably faster:\n\n```\nsage: sage: n = 12\n....: sage: f = x / (1-exp(-x))\n....: sage: Sym = SymmetricFunctions(QQ)\n....: sage: P = PolynomialRing(QQ, 'x', n)\n....: sage: seq = prod(f.subs({f.default_variable(): var}) for var in P.gens())\n....: sage: sage: inp = [(var, 0) for var in P.gens()]\n....: sage: seq_taylor = seq.taylor(*inp, n // 2)\n....: sage: g = (P(seq_taylor))\n....: %time g.is_symmetric()\n....:\nCPU times: user 2.48 s, sys: 5.07 ms, total: 2.48 s\nWall time: 2.49 s                                       # before\nCPU times: user 121 ms, sys: 2.11 ms, total: 123 ms\nWall time: 123 ms                                       # after\nTrue\n```\n\nand even for small polynomials this seems to be at least as fast:\n\n```\nsage: R.<x,y,z> = QQ[]\n....: f = (1 + x^2 + y^2 + z^2)^2\n....: %timeit f.is_symmetric()\n....:\n10000 loops, best of 5: 177 \u00b5s per loop    # before\n10000 loops, best of 5: 64.3 \u00b5s per loop   # after\n```\n\n\nSecondly, in `permgroup_element.pyx`, there are methods `_act_on_list_on_position` and `_act_on_array_on_position`. Do you think it would be more consistent to add a `PermutationGroupElement._act_on_etuple_on_position`, rather than `ETuple.permuted`?\n\nAlso, you will want to merge #29540.",
    "created_at": "2020-04-23T18:52:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415170",
    "user": "https://github.com/mwageringel"
}
```

It might be good to convert the polynomial to a dictionary first in order to speed up the looking up of coefficients, e.g.:

```diff
-        for e in self.exponents():
-            coeff = self[e]
-            for g in gens:
-                if self[e.permuted(g)] != coeff:
-                    return False
-        return True
+        pd = self.dict()
+        return all(pd[e.permuted(g)] == c for e, c in pd.items() for g in gens)
```


For the example at hand, this is noticeably faster:

```
sage: sage: n = 12
....: sage: f = x / (1-exp(-x))
....: sage: Sym = SymmetricFunctions(QQ)
....: sage: P = PolynomialRing(QQ, 'x', n)
....: sage: seq = prod(f.subs({f.default_variable(): var}) for var in P.gens())
....: sage: sage: inp = [(var, 0) for var in P.gens()]
....: sage: seq_taylor = seq.taylor(*inp, n // 2)
....: sage: g = (P(seq_taylor))
....: %time g.is_symmetric()
....:
CPU times: user 2.48 s, sys: 5.07 ms, total: 2.48 s
Wall time: 2.49 s                                       # before
CPU times: user 121 ms, sys: 2.11 ms, total: 123 ms
Wall time: 123 ms                                       # after
True
```

and even for small polynomials this seems to be at least as fast:

```
sage: R.<x,y,z> = QQ[]
....: f = (1 + x^2 + y^2 + z^2)^2
....: %timeit f.is_symmetric()
....:
10000 loops, best of 5: 177 µs per loop    # before
10000 loops, best of 5: 64.3 µs per loop   # after
```


Secondly, in `permgroup_element.pyx`, there are methods `_act_on_list_on_position` and `_act_on_array_on_position`. Do you think it would be more consistent to add a `PermutationGroupElement._act_on_etuple_on_position`, rather than `ETuple.permuted`?

Also, you will want to merge #29540.



---

archive/issue_comments_415171.json:
```json
{
    "body": "Replying to [comment:6 gh-mwageringel]:\n> It might be good to convert the polynomial to a dictionary first in order to speed up the looking up of coefficients, e.g.:\n\nIt is sad this is the case. The polynomial datastructure is supposed to be fast in accessing coefficients... I believe it strongly depends on the base ring. But given the time difference I agree that it makes sense.\n\n>\n> <SNIP\n>\n> Secondly, in `permgroup_element.pyx`, there are methods `_act_on_list_on_position` and `_act_on_array_on_position`. Do you think it would be more consistent to add a `PermutationGroupElement._act_on_etuple_on_position`, rather than `ETuple.permuted`?\n\nSure. That will also be convenient for action of permutations on polynomials.\n \n> Also, you will want to merge #29540.\n\nIndeed.",
    "created_at": "2020-04-23T19:13:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415171",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:6 gh-mwageringel]:
> It might be good to convert the polynomial to a dictionary first in order to speed up the looking up of coefficients, e.g.:

It is sad this is the case. The polynomial datastructure is supposed to be fast in accessing coefficients... I believe it strongly depends on the base ring. But given the time difference I agree that it makes sense.

>
> <SNIP
>
> Secondly, in `permgroup_element.pyx`, there are methods `_act_on_list_on_position` and `_act_on_array_on_position`. Do you think it would be more consistent to add a `PermutationGroupElement._act_on_etuple_on_position`, rather than `ETuple.permuted`?

Sure. That will also be convenient for action of permutations on polynomials.
 
> Also, you will want to merge #29540.

Indeed.



---

archive/issue_comments_415172.json:
```json
{
    "body": "Replying to [comment:8 vdelecroix]:\n> Replying to [comment:6 gh-mwageringel]:\n> > It might be good to convert the polynomial to a dictionary first in order to speed up the looking up of coefficients, e.g.:\n> \n> It is sad this is the case. The polynomial datastructure is supposed to be fast in accessing coefficients... I believe it strongly depends on the base ring. But given the time difference I agree that it makes sense.\n\nThe `MPolynomial_libsignular.__getitem__` code looks like this:\n\n```python\n        m = p_ISet(1,r)\n        i = 1\n        for e in x:\n            overflow_check(e, r)\n            p_SetExp(m, i, int(e), r)\n            i += 1\n        p_Setm(m, r)\n\n        while(p):\n            if p_ExpVectorEqual(p, m, r) == 1:\n                p_Delete(&m,r)\n                return si2sa(p_GetCoeff(p, r), r, self._parent._base)\n            p = pNext(p)\n```\n\nSo it looks more like it is going through a list rather than a dict. I don't know how singular does this, but it looks like a very different data structure than the na\u00efve implementation. IIRC, their data structure is solely to be efficient at computing Gr\u00f6bner bases.\n\nTL;DR Converting to a dict is definitely the best option with the current implementation.\n\nAs a more broader question, it might be worthwhile to consider reimplementing generic multivariate polynomials in Cython and only convert to (lib)singular when wanting a Gr\u00f6bner basis.",
    "created_at": "2020-04-23T23:57:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415172",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:8 vdelecroix]:
> Replying to [comment:6 gh-mwageringel]:
> > It might be good to convert the polynomial to a dictionary first in order to speed up the looking up of coefficients, e.g.:
> 
> It is sad this is the case. The polynomial datastructure is supposed to be fast in accessing coefficients... I believe it strongly depends on the base ring. But given the time difference I agree that it makes sense.

The `MPolynomial_libsignular.__getitem__` code looks like this:

```python
        m = p_ISet(1,r)
        i = 1
        for e in x:
            overflow_check(e, r)
            p_SetExp(m, i, int(e), r)
            i += 1
        p_Setm(m, r)

        while(p):
            if p_ExpVectorEqual(p, m, r) == 1:
                p_Delete(&m,r)
                return si2sa(p_GetCoeff(p, r), r, self._parent._base)
            p = pNext(p)
```

So it looks more like it is going through a list rather than a dict. I don't know how singular does this, but it looks like a very different data structure than the naïve implementation. IIRC, their data structure is solely to be efficient at computing Gröbner bases.

TL;DR Converting to a dict is definitely the best option with the current implementation.

As a more broader question, it might be worthwhile to consider reimplementing generic multivariate polynomials in Cython and only convert to (lib)singular when wanting a Gröbner basis.



---

archive/issue_comments_415173.json:
```json
{
    "body": "How about generalising it to computing actions of linear group elements and of linear groups on polynomials?\n\nIt seems to be a bit restrictive to only have methods for fixed point computation, whereas it's only slightly less general, and you compute the action anyway!",
    "created_at": "2020-04-24T01:09:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415173",
    "user": "https://github.com/dimpase"
}
```

How about generalising it to computing actions of linear group elements and of linear groups on polynomials?

It seems to be a bit restrictive to only have methods for fixed point computation, whereas it's only slightly less general, and you compute the action anyway!



---

archive/issue_comments_415174.json:
```json
{
    "body": "Replying to [comment:10 dimpase]:\n> How about generalising it to computing actions of linear group elements and of linear groups on polynomials?\n>\n> It seems to be a bit restrictive to only have methods for fixed point computation, whereas it's only slightly less general, and you compute the action anyway!\n\nFeel free to open a ticket for that. The code here is permuting exponents and do not touch the coefficients. The linear action might better be done via a proper action.",
    "created_at": "2020-04-24T07:37:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415174",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:10 dimpase]:
> How about generalising it to computing actions of linear group elements and of linear groups on polynomials?
>
> It seems to be a bit restrictive to only have methods for fixed point computation, whereas it's only slightly less general, and you compute the action anyway!

Feel free to open a ticket for that. The code here is permuting exponents and do not touch the coefficients. The linear action might better be done via a proper action.



---

archive/issue_comments_415175.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-04-24T08:35:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415175",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_415176.json:
```json
{
    "body": "Implementation changed to go via action of `PermutationGroupElement` on `ETuple`.",
    "created_at": "2020-04-24T08:36:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415176",
    "user": "https://github.com/videlec"
}
```

Implementation changed to go via action of `PermutationGroupElement` on `ETuple`.



---

archive/issue_comments_415177.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-04-24T08:45:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415177",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_415178.json:
```json
{
    "body": "Does it work for Laurent polynomials?",
    "created_at": "2020-04-25T02:06:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415178",
    "user": "https://github.com/dimpase"
}
```

Does it work for Laurent polynomials?



---

archive/issue_comments_415179.json:
```json
{
    "body": "\n```\nresult._data = <int*> sig_malloc(sizeof(int)*result._nonzero*2)\n```\n\nlooks like a memory leak, as I don't see a matching `sig_free()` call.",
    "created_at": "2020-04-25T02:11:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415179",
    "user": "https://github.com/dimpase"
}
```


```
result._data = <int*> sig_malloc(sizeof(int)*result._nonzero*2)
```

looks like a memory leak, as I don't see a matching `sig_free()` call.



---

archive/issue_comments_415180.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2020-04-25T02:11:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415180",
    "user": "https://github.com/dimpase"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_415181.json:
```json
{
    "body": "Replying to [comment:16 dimpase]:\n> {{{\n> result._data = <int*> sig_malloc(sizeof(int)*result._nonzero*2)\n> }}}\n> looks like a memory leak, as I don't see a matching `sig_free()` call.\n\nWhy would there be a `sig_free()`? `result` is the return value of the function, and it would be the job of the `ETuple` to handle freeing that in its deallocation I believe.\n\nI also have a few comments:\n\n\n```diff\n-        - ``group`` (optional) - if set, test whether the polynomial is\n-          symmetric with respect to the given permutation group.\n+        - ``group`` (default: symmetric group) -- if set, test whether the\n+          polynomial is invariant with respect to the given permutation group\n```\n\n\nThis error message doesn't make sense to me `raise ValueError(\"wrong argument 'group'\")`.\n\n\n```diff\n-        for e, coeff in coeffs.items():\n-            for g in gens:\n-                if coeffs.get(g._act_on_etuple_on_position(e, True), zero) != coeff:\n-                    return False\n-        return True\n+        return all(coeffs.get(g._act_on_etuple_on_position(e, True), zero) == coeff\n+                   for e, coeff in coeffs.items() for g in gens)\n```\n\n\nIn `monomial.py`:\n\n```diff\n-from sage.combinat.partition import Partition\n+from sage.combinat.partition import Partition, _Partitions\n```\n\n\n```diff\n-        out = self.sum_of_terms((Partition(e), c)\n-                                for (e,c) in f.dict().items()\n-                                if all(e[i+1] <= e[i] for i in range(len(e) - 1)))\n+        R = self.base_ring()\n+        out = self._from_dict({_Partitions(e): R(c)\n+                                for (e,c) in f.dict().items()\n+                                if all(e[i+1] <= e[i] for i in range(len(e)-1))})\n```\n",
    "created_at": "2020-04-25T03:06:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415181",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:16 dimpase]:
> {{{
> result._data = <int*> sig_malloc(sizeof(int)*result._nonzero*2)
> }}}
> looks like a memory leak, as I don't see a matching `sig_free()` call.

Why would there be a `sig_free()`? `result` is the return value of the function, and it would be the job of the `ETuple` to handle freeing that in its deallocation I believe.

I also have a few comments:


```diff
-        - ``group`` (optional) - if set, test whether the polynomial is
-          symmetric with respect to the given permutation group.
+        - ``group`` (default: symmetric group) -- if set, test whether the
+          polynomial is invariant with respect to the given permutation group
```


This error message doesn't make sense to me `raise ValueError("wrong argument 'group'")`.


```diff
-        for e, coeff in coeffs.items():
-            for g in gens:
-                if coeffs.get(g._act_on_etuple_on_position(e, True), zero) != coeff:
-                    return False
-        return True
+        return all(coeffs.get(g._act_on_etuple_on_position(e, True), zero) == coeff
+                   for e, coeff in coeffs.items() for g in gens)
```


In `monomial.py`:

```diff
-from sage.combinat.partition import Partition
+from sage.combinat.partition import Partition, _Partitions
```


```diff
-        out = self.sum_of_terms((Partition(e), c)
-                                for (e,c) in f.dict().items()
-                                if all(e[i+1] <= e[i] for i in range(len(e) - 1)))
+        R = self.base_ring()
+        out = self._from_dict({_Partitions(e): R(c)
+                                for (e,c) in f.dict().items()
+                                if all(e[i+1] <= e[i] for i in range(len(e)-1))})
```




---

archive/issue_comments_415182.json:
```json
{
    "body": "`sig_malloc` is a thin wrapper around C `malloc()`. There is no garbage collection in Cython that would magically call `sig_free()` on what `result._data` points to - unless I seriously misunderstand something.",
    "created_at": "2020-04-25T04:50:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415182",
    "user": "https://github.com/dimpase"
}
```

`sig_malloc` is a thin wrapper around C `malloc()`. There is no garbage collection in Cython that would magically call `sig_free()` on what `result._data` points to - unless I seriously misunderstand something.



---

archive/issue_comments_415183.json:
```json
{
    "body": "In `ETuple`:\n\n```python\n    def __dealloc__(self):\n        if self._data != <int*>0:\n            sig_free(self._data)\n```\n\nSo whenever `result` (which is an `ETuple`) is destroyed, then that memory is freed.",
    "created_at": "2020-04-25T05:40:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415183",
    "user": "https://github.com/tscrim"
}
```

In `ETuple`:

```python
    def __dealloc__(self):
        if self._data != <int*>0:
            sig_free(self._data)
```

So whenever `result` (which is an `ETuple`) is destroyed, then that memory is freed.



---

archive/issue_comments_415184.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2020-04-25T05:54:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415184",
    "user": "https://github.com/dimpase"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_415185.json:
```json
{
    "body": "OK, I see, thanks for an explanation.",
    "created_at": "2020-04-25T05:54:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415185",
    "user": "https://github.com/dimpase"
}
```

OK, I see, thanks for an explanation.



---

archive/issue_comments_415186.json:
```json
{
    "body": "Replying to [comment:17 tscrim]:\n> Replying to [comment:16 dimpase]:\n> > {{{\n> > result._data = <int*> sig_malloc(sizeof(int)*result._nonzero*2)\n> > }}}\n> > looks like a memory leak, as I don't see a matching `sig_free()` call.\n> \n> Why would there be a `sig_free()`? `result` is the return value of the function, and it would be the job of the `ETuple` to handle freeing that in its deallocation I believe.\n\nIndeed. That is exactly what is happening.",
    "created_at": "2020-04-25T05:58:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415186",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:17 tscrim]:
> Replying to [comment:16 dimpase]:
> > {{{
> > result._data = <int*> sig_malloc(sizeof(int)*result._nonzero*2)
> > }}}
> > looks like a memory leak, as I don't see a matching `sig_free()` call.
> 
> Why would there be a `sig_free()`? `result` is the return value of the function, and it would be the job of the `ETuple` to handle freeing that in its deallocation I believe.

Indeed. That is exactly what is happening.



---

archive/issue_comments_415187.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-04-25T06:08:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415187",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_415188.json:
```json
{
    "body": "beware that monomial.py has been modified recently, in #29540",
    "created_at": "2020-04-25T06:24:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415188",
    "user": "https://github.com/fchapoton"
}
```

beware that monomial.py has been modified recently, in #29540



---

archive/issue_comments_415189.json:
```json
{
    "body": "To me the naming \"on position\" suggests a certain way a permutation acts on lists, independently from the notion of left and right (although this action does satisfy the properties of a left action). So I think either the `_on_position` or the `self_on_left` should be removed, as these terms are at odds with each other.\n\nI would probably drop the `self_on_left` as it is simple enough to call the method on the inverse permutation instead when necessary, but your current implementation does the opposite of what `_act_on_list_on_position` does. I had not considered this before - sorry. Since you mentioned the action on polynomials, I can see why the current implementation might be preferable. In that case, you could just rename the method to `_act_on_etuple`.\n\nIn any case, left and right seem to be mixed up currently:\n\n\n```\nsage: S = SymmetricGroup(6)\nsage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')\nsage: from sage.rings.polynomial.polydict import ETuple\nsage: e = ETuple([10..15])\nsage: right = lambda x, p: p._act_on_etuple_on_position(x, self_on_left=False)\nsage: right(e, p * q) == right(right(e, p), q)  # should be True\nFalse\n```\n",
    "created_at": "2020-04-25T12:54:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415189",
    "user": "https://github.com/mwageringel"
}
```

To me the naming "on position" suggests a certain way a permutation acts on lists, independently from the notion of left and right (although this action does satisfy the properties of a left action). So I think either the `_on_position` or the `self_on_left` should be removed, as these terms are at odds with each other.

I would probably drop the `self_on_left` as it is simple enough to call the method on the inverse permutation instead when necessary, but your current implementation does the opposite of what `_act_on_list_on_position` does. I had not considered this before - sorry. Since you mentioned the action on polynomials, I can see why the current implementation might be preferable. In that case, you could just rename the method to `_act_on_etuple`.

In any case, left and right seem to be mixed up currently:


```
sage: S = SymmetricGroup(6)
sage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')
sage: from sage.rings.polynomial.polydict import ETuple
sage: e = ETuple([10..15])
sage: right = lambda x, p: p._act_on_etuple_on_position(x, self_on_left=False)
sage: right(e, p * q) == right(right(e, p), q)  # should be True
False
```




---

archive/issue_comments_415190.json:
```json
{
    "body": "Replying to [comment:9 tscrim]:\n> As a more broader question, it might be worthwhile to consider reimplementing generic multivariate polynomials in Cython and only convert to (lib)singular when wanting a Gr\u00f6bner basis.\n\nThis is exactly what the polydict implementation of polynomials does, no? You can construct a polynomial ring via `PolynomialRing(..., implementation='generic')` to use it, and when you want a Gr\u00f6bner basis, only then it will convert to Singular (the conversion to libsingular does not seem to be supported).\n\nOn the other hand, I cannot think of many operations on polynomials for which random access to arbitrary coefficients is important.",
    "created_at": "2020-04-25T13:06:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415190",
    "user": "https://github.com/mwageringel"
}
```

Replying to [comment:9 tscrim]:
> As a more broader question, it might be worthwhile to consider reimplementing generic multivariate polynomials in Cython and only convert to (lib)singular when wanting a Gröbner basis.

This is exactly what the polydict implementation of polynomials does, no? You can construct a polynomial ring via `PolynomialRing(..., implementation='generic')` to use it, and when you want a Gröbner basis, only then it will convert to Singular (the conversion to libsingular does not seem to be supported).

On the other hand, I cannot think of many operations on polynomials for which random access to arbitrary coefficients is important.



---

archive/issue_comments_415191.json:
```json
{
    "body": "Replying to [comment:24 gh-mwageringel]:\n> To me the naming \"on position\" suggests a certain way a permutation acts on lists, independently from the notion of left and right (although this action does satisfy the properties of a left action). So I think either the `_on_position` or the `self_on_left` should be removed, as these terms are at odds with each other.\n> \n> I would probably drop the `self_on_left` as it is simple enough to call the method on the inverse permutation instead when necessary, but your current implementation does the opposite of what `_act_on_list_on_position` does. I had not considered this before - sorry. Since you mentioned the action on polynomials, I can see why the current implementation might be preferable. In that case, you could just rename the method to `_act_on_etuple`.\n> \n> In any case, left and right seem to be mixed up currently:\n> \n> {{{\n> sage: S = SymmetricGroup(6)\n> sage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')\n> sage: from sage.rings.polynomial.polydict import ETuple\n> sage: e = ETuple([10..15])\n> sage: right = lambda x, p: p._act_on_etuple_on_position(x, self_on_left=False)\n> sage: right(e, p * q) == right(right(e, p), q)  # should be True\n> False\n> }}}\n\nI just copied what is in `_act_on_list_on_position` which claims to be a right action. Same behaviour\n\n```\nsage: S = SymmetricGroup(6)\nsage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')\nsage: right = lambda x,p: p._act_on_list_on_position(x)\nsage: e = [10..15]\nsage: right(e, p * q) == right(right(e, p), q)\nFalse\nsage: right(e, p * q) == right(right(e, q), p)\nTrue\n```\n",
    "created_at": "2020-04-25T18:32:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415191",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:24 gh-mwageringel]:
> To me the naming "on position" suggests a certain way a permutation acts on lists, independently from the notion of left and right (although this action does satisfy the properties of a left action). So I think either the `_on_position` or the `self_on_left` should be removed, as these terms are at odds with each other.
> 
> I would probably drop the `self_on_left` as it is simple enough to call the method on the inverse permutation instead when necessary, but your current implementation does the opposite of what `_act_on_list_on_position` does. I had not considered this before - sorry. Since you mentioned the action on polynomials, I can see why the current implementation might be preferable. In that case, you could just rename the method to `_act_on_etuple`.
> 
> In any case, left and right seem to be mixed up currently:
> 
> {{{
> sage: S = SymmetricGroup(6)
> sage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')
> sage: from sage.rings.polynomial.polydict import ETuple
> sage: e = ETuple([10..15])
> sage: right = lambda x, p: p._act_on_etuple_on_position(x, self_on_left=False)
> sage: right(e, p * q) == right(right(e, p), q)  # should be True
> False
> }}}

I just copied what is in `_act_on_list_on_position` which claims to be a right action. Same behaviour

```
sage: S = SymmetricGroup(6)
sage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')
sage: right = lambda x,p: p._act_on_list_on_position(x)
sage: e = [10..15]
sage: right(e, p * q) == right(right(e, p), q)
False
sage: right(e, p * q) == right(right(e, q), p)
True
```




---

archive/issue_comments_415192.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-04-25T18:43:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415192",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_415193.json:
```json
{
    "body": "Replying to [comment:26 vdelecroix]:\n> I just copied what is in `_act_on_list_on_position` which claims to be a right action. Same behaviour\n\nThe action of permutations on matrices implemented in `_act_on_` also has it the other way around, but for polynomials it works as expected:\n\n```\nsage: S = SymmetricGroup(6)\nsage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')\nsage: M = matrix.diagonal([1..6])\nsage: (M * p) * q == M * (p * q)\nFalse\nsage: R = PolynomialRing(QQ, 'x', 6)\nsage: (R.0 * p) * q == R.0 * (p * q)\nTrue\n```\n\nAm I misunderstanding something about left and right actions in Sage?",
    "created_at": "2020-04-25T19:06:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415193",
    "user": "https://github.com/mwageringel"
}
```

Replying to [comment:26 vdelecroix]:
> I just copied what is in `_act_on_list_on_position` which claims to be a right action. Same behaviour

The action of permutations on matrices implemented in `_act_on_` also has it the other way around, but for polynomials it works as expected:

```
sage: S = SymmetricGroup(6)
sage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')
sage: M = matrix.diagonal([1..6])
sage: (M * p) * q == M * (p * q)
False
sage: R = PolynomialRing(QQ, 'x', 6)
sage: (R.0 * p) * q == R.0 * (p * q)
True
```

Am I misunderstanding something about left and right actions in Sage?



---

archive/issue_comments_415194.json:
```json
{
    "body": "Replying to [comment:25 gh-mwageringel]:\n> Replying to [comment:9 tscrim]:\n> > As a more broader question, it might be worthwhile to consider reimplementing generic multivariate polynomials in Cython and only convert to (lib)singular when wanting a Gr\u00f6bner basis.\n> \n> This is exactly what the polydict implementation of polynomials does, no? You can construct a polynomial ring via `PolynomialRing(..., implementation='generic')` to use it, and when you want a Gr\u00f6bner basis, only then it will convert to Singular (the conversion to libsingular does not seem to be supported).\n\nSorry, I forgot generic is an overloaded word here and probably not the best word. What I meant was more universally shall we do this for rings that can be converted to (lib)singular, like those over **Z**.\n\n> On the other hand, I cannot think of many operations on polynomials for which random access to arbitrary coefficients is important.\n\nPerhaps you're right. I can think of a number of things where you want to iterate over the pairs of coefficients and exponents. I don't think we have a method to do that (the default iterator is quite bad, getting the list of coefficients and list of monomials and zipping them together). I will open a ticket tomorrow or the next day to try and improve the iteration.",
    "created_at": "2020-04-25T22:47:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415194",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:25 gh-mwageringel]:
> Replying to [comment:9 tscrim]:
> > As a more broader question, it might be worthwhile to consider reimplementing generic multivariate polynomials in Cython and only convert to (lib)singular when wanting a Gröbner basis.
> 
> This is exactly what the polydict implementation of polynomials does, no? You can construct a polynomial ring via `PolynomialRing(..., implementation='generic')` to use it, and when you want a Gröbner basis, only then it will convert to Singular (the conversion to libsingular does not seem to be supported).

Sorry, I forgot generic is an overloaded word here and probably not the best word. What I meant was more universally shall we do this for rings that can be converted to (lib)singular, like those over **Z**.

> On the other hand, I cannot think of many operations on polynomials for which random access to arbitrary coefficients is important.

Perhaps you're right. I can think of a number of things where you want to iterate over the pairs of coefficients and exponents. I don't think we have a method to do that (the default iterator is quite bad, getting the list of coefficients and list of monomials and zipping them together). I will open a ticket tomorrow or the next day to try and improve the iteration.



---

archive/issue_comments_415195.json:
```json
{
    "body": "Replying to [comment:28 gh-mwageringel]:\n> The action of permutations on matrices implemented in `_act_on_` also has it the other way around, but for polynomials it works as expected:\n> {{{\n> sage: S = SymmetricGroup(6)\n> sage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')\n> sage: M = matrix.diagonal([1..6])\n> sage: (M * p) * q == M * (p * q)\n> False\n> sage: R = PolynomialRing(QQ, 'x', 6)\n> sage: (R.0 * p) * q == R.0 * (p * q)\n> True\n> }}}\n> Am I misunderstanding something about left and right actions in Sage?\n\nHere is where it comes from I think:\n\n```\nsage: (M * p.matrix()) * q.matrix() == M * (p.matrix() * q.matrix())\nTrue\nsage: (M * p.matrix()) * q.matrix() == M * (p*q).matrix()\nTrue\nsage: p.matrix() * q.matrix() == (p*q).matrix()\nTrue\nsage: p.matrix() * M == M * p\nTrue\n```\n\n(An oddity that needs fixing: `p.matrix()` works but `p.to_matrix()` is a `NotImplemented`.)\nAlso Sage only knows it has a right action:\n\n```\nsage: (q * p) * M == q * (p * M)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<snip>\nTypeError: unsupported operand parent(s) for *: 'Symmetric group of order 6! as a permutation group' and 'Full MatrixSpace of 6 by 6 sparse matrices over Integer Ring'\n```\n\nSo I think the thing that needs to change in the perm group element `_act_on_` is\n\n```diff\n             elif is_Matrix(left):\n+               return left.with_permuted_columns(~self)\n+        else:\n+            if is_Matrix(left):\n                return left.with_permuted_rows(self)\n```\n\nAddendum: Because of this:\n\n```\nsage: M * p.matrix()\n[0 1 0 0 0 0]\n[0 0 2 0 0 0]\n[0 0 0 3 0 0]\n[0 0 0 0 4 0]\n[0 0 0 0 0 5]\n[6 0 0 0 0 0]\nsage: M.with_permuted_columns(~p)\n[0 1 0 0 0 0]\n[0 0 2 0 0 0]\n[0 0 0 3 0 0]\n[0 0 0 0 4 0]\n[0 0 0 0 0 5]\n[6 0 0 0 0 0]\n```\n",
    "created_at": "2020-04-25T23:08:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415195",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:28 gh-mwageringel]:
> The action of permutations on matrices implemented in `_act_on_` also has it the other way around, but for polynomials it works as expected:
> {{{
> sage: S = SymmetricGroup(6)
> sage: p, q = S('(1,2,3,4,5,6)'), S('(1,2)(3,4)(5,6)')
> sage: M = matrix.diagonal([1..6])
> sage: (M * p) * q == M * (p * q)
> False
> sage: R = PolynomialRing(QQ, 'x', 6)
> sage: (R.0 * p) * q == R.0 * (p * q)
> True
> }}}
> Am I misunderstanding something about left and right actions in Sage?

Here is where it comes from I think:

```
sage: (M * p.matrix()) * q.matrix() == M * (p.matrix() * q.matrix())
True
sage: (M * p.matrix()) * q.matrix() == M * (p*q).matrix()
True
sage: p.matrix() * q.matrix() == (p*q).matrix()
True
sage: p.matrix() * M == M * p
True
```

(An oddity that needs fixing: `p.matrix()` works but `p.to_matrix()` is a `NotImplemented`.)
Also Sage only knows it has a right action:

```
sage: (q * p) * M == q * (p * M)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<snip>
TypeError: unsupported operand parent(s) for *: 'Symmetric group of order 6! as a permutation group' and 'Full MatrixSpace of 6 by 6 sparse matrices over Integer Ring'
```

So I think the thing that needs to change in the perm group element `_act_on_` is

```diff
             elif is_Matrix(left):
+               return left.with_permuted_columns(~self)
+        else:
+            if is_Matrix(left):
                return left.with_permuted_rows(self)
```

Addendum: Because of this:

```
sage: M * p.matrix()
[0 1 0 0 0 0]
[0 0 2 0 0 0]
[0 0 0 3 0 0]
[0 0 0 0 4 0]
[0 0 0 0 0 5]
[6 0 0 0 0 0]
sage: M.with_permuted_columns(~p)
[0 1 0 0 0 0]
[0 0 2 0 0 0]
[0 0 0 3 0 0]
[0 0 0 0 4 0]
[0 0 0 0 0 5]
[6 0 0 0 0 0]
```




---

archive/issue_comments_415196.json:
```json
{
    "body": "Replying to [comment:29 tscrim]:\n> Sorry, I forgot generic is an overloaded word here and probably not the best word. What I meant was more universally shall we do this for rings that can be converted to (lib)singular, like those over **Z**.\n\nSo you are suggesting to make the `generic` implementation the default? This implementation is not usually faster than the Singular backend I think, but it depends on the use case of course.\n\n> Perhaps you're right. I can think of a number of things where you want to iterate over the pairs of coefficients and exponents. I don't think we have a method to do that (the default iterator is quite bad, getting the list of coefficients and list of monomials and zipping them together). I will open a ticket tomorrow or the next day to try and improve the iteration.\n\nThat would indeed be nice to have, as it is such a common operation. I did not know the `__iter__` method was implemented for polynomials and have always been zipping coefficients and monomials (or exponents), but it always felt odd to me, especially since this pattern fails for `CombinatorialFreeModule` elements if one does not pay attention to the sorting.\n\n\nRegarding the action on matrices, we could handle that on a new ticket, as it alters existing behavior and is not really related to the aim of this ticket.\n\nI am happy with this ticket as it is now. Except maybe there is one little detail from Travis' suggestion:\n\n\n```\n        out = self._from_dict({_Partitions.element_class(_Partitions, list(e)): R(c)\n                               for (e,c) in f.dict().items()\n```\n\n\nThe conversion `R(c)` should not be necessary here, as the coefficients should already be elements of the base ring.",
    "created_at": "2020-04-26T10:47:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415196",
    "user": "https://github.com/mwageringel"
}
```

Replying to [comment:29 tscrim]:
> Sorry, I forgot generic is an overloaded word here and probably not the best word. What I meant was more universally shall we do this for rings that can be converted to (lib)singular, like those over **Z**.

So you are suggesting to make the `generic` implementation the default? This implementation is not usually faster than the Singular backend I think, but it depends on the use case of course.

> Perhaps you're right. I can think of a number of things where you want to iterate over the pairs of coefficients and exponents. I don't think we have a method to do that (the default iterator is quite bad, getting the list of coefficients and list of monomials and zipping them together). I will open a ticket tomorrow or the next day to try and improve the iteration.

That would indeed be nice to have, as it is such a common operation. I did not know the `__iter__` method was implemented for polynomials and have always been zipping coefficients and monomials (or exponents), but it always felt odd to me, especially since this pattern fails for `CombinatorialFreeModule` elements if one does not pay attention to the sorting.


Regarding the action on matrices, we could handle that on a new ticket, as it alters existing behavior and is not really related to the aim of this ticket.

I am happy with this ticket as it is now. Except maybe there is one little detail from Travis' suggestion:


```
        out = self._from_dict({_Partitions.element_class(_Partitions, list(e)): R(c)
                               for (e,c) in f.dict().items()
```


The conversion `R(c)` should not be necessary here, as the coefficients should already be elements of the base ring.



---

archive/issue_comments_415197.json:
```json
{
    "body": "Replying to [comment:30 tscrim]:\n> (An oddity that needs fixing: `p.matrix()` works but `p.to_matrix()` is a `NotImplemented`.)\n\nDo you know where this `to_matrix` comes from? I stumbled upon this a few days ago, but could not figure out where it was defined.",
    "created_at": "2020-04-26T10:54:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415197",
    "user": "https://github.com/mwageringel"
}
```

Replying to [comment:30 tscrim]:
> (An oddity that needs fixing: `p.matrix()` works but `p.to_matrix()` is a `NotImplemented`.)

Do you know where this `to_matrix` comes from? I stumbled upon this a few days ago, but could not figure out where it was defined.



---

archive/issue_comments_415198.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-04-26T13:22:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415198",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_415199.json:
```json
{
    "body": "Replying to [comment:31 gh-mwageringel]:\n> Replying to [comment:29 tscrim]:\n> > Sorry, I forgot generic is an overloaded word here and probably not the best word. What I meant was more universally shall we do this for rings that can be converted to (lib)singular, like those over **Z**.\n> \n> So you are suggesting to make the `generic` implementation the default? This implementation is not usually faster than the Singular backend I think, but it depends on the use case of course.\n\nYes, although I am not sure if this will be a good option. However, IIRC things like multiplying polynomials is really slow and could use another library to speed that up.\n\n> > Perhaps you're right. I can think of a number of things where you want to iterate over the pairs of coefficients and exponents. I don't think we have a method to do that (the default iterator is quite bad, getting the list of coefficients and list of monomials and zipping them together). I will open a ticket tomorrow or the next day to try and improve the iteration.\n> \n> That would indeed be nice to have, as it is such a common operation. I did not know the `__iter__` method was implemented for polynomials and have always been zipping coefficients and monomials (or exponents), but it always felt odd to me, especially since this pattern fails for `CombinatorialFreeModule` elements if one does not pay attention to the sorting.\n\nThis is now #29595.\n\n> Regarding the action on matrices, we could handle that on a new ticket, as it alters existing behavior and is not really related to the aim of this ticket.\n\nI agree that it should be a separate ticket.\n\n> I am happy with this ticket as it is now. Except maybe there is one little detail from Travis' suggestion:\n> \n> {{{\n>         out = self._from_dict({_Partitions.element_class(_Partitions, list(e)): R(c)\n>                                for (e,c) in f.dict().items()\n> }}}\n> \n> The conversion `R(c)` should not be necessary here, as the coefficients should already be elements of the base ring.\n\nIf we add that conversion, then we can remove the\n\n```\nassert self.base_ring() == f.base_ring()\n```\n\nwhich I think is not a good thing to enforce.",
    "created_at": "2020-04-27T03:17:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415199",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:31 gh-mwageringel]:
> Replying to [comment:29 tscrim]:
> > Sorry, I forgot generic is an overloaded word here and probably not the best word. What I meant was more universally shall we do this for rings that can be converted to (lib)singular, like those over **Z**.
> 
> So you are suggesting to make the `generic` implementation the default? This implementation is not usually faster than the Singular backend I think, but it depends on the use case of course.

Yes, although I am not sure if this will be a good option. However, IIRC things like multiplying polynomials is really slow and could use another library to speed that up.

> > Perhaps you're right. I can think of a number of things where you want to iterate over the pairs of coefficients and exponents. I don't think we have a method to do that (the default iterator is quite bad, getting the list of coefficients and list of monomials and zipping them together). I will open a ticket tomorrow or the next day to try and improve the iteration.
> 
> That would indeed be nice to have, as it is such a common operation. I did not know the `__iter__` method was implemented for polynomials and have always been zipping coefficients and monomials (or exponents), but it always felt odd to me, especially since this pattern fails for `CombinatorialFreeModule` elements if one does not pay attention to the sorting.

This is now #29595.

> Regarding the action on matrices, we could handle that on a new ticket, as it alters existing behavior and is not really related to the aim of this ticket.

I agree that it should be a separate ticket.

> I am happy with this ticket as it is now. Except maybe there is one little detail from Travis' suggestion:
> 
> {{{
>         out = self._from_dict({_Partitions.element_class(_Partitions, list(e)): R(c)
>                                for (e,c) in f.dict().items()
> }}}
> 
> The conversion `R(c)` should not be necessary here, as the coefficients should already be elements of the base ring.

If we add that conversion, then we can remove the

```
assert self.base_ring() == f.base_ring()
```

which I think is not a good thing to enforce.



---

archive/issue_comments_415200.json:
```json
{
    "body": "Replying to [comment:32 gh-mwageringel]:\n> Replying to [comment:30 tscrim]:\n> > (An oddity that needs fixing: `p.matrix()` works but `p.to_matrix()` is a `NotImplemented`.)\n> \n> Do you know where this `to_matrix` comes from? I stumbled upon this a few days ago, but could not figure out where it was defined.\n\nIt comes from the finite Complex reflection group category. This can be easily fixed with an alias in the (finite) Coxeter group category (using the method `canonical_matrix`) and/or for the specific implementation of permutation groups.",
    "created_at": "2020-04-27T03:21:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415200",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:32 gh-mwageringel]:
> Replying to [comment:30 tscrim]:
> > (An oddity that needs fixing: `p.matrix()` works but `p.to_matrix()` is a `NotImplemented`.)
> 
> Do you know where this `to_matrix` comes from? I stumbled upon this a few days ago, but could not figure out where it was defined.

It comes from the finite Complex reflection group category. This can be easily fixed with an alias in the (finite) Coxeter group category (using the method `canonical_matrix`) and/or for the specific implementation of permutation groups.



---

archive/issue_comments_415201.json:
```json
{
    "body": "Replying to [comment:34 tscrim]:\n> Replying to [comment:31 gh-mwageringel]:\n> > Replying to [comment:29 tscrim]:\n> > I am happy with this ticket as it is now. Except maybe there is one little detail from Travis' suggestion:\n> > \n> > {{{\n> >         out = self._from_dict({_Partitions.element_class(_Partitions, list(e)): R(c)\n> >                                for (e,c) in f.dict().items()\n> > }}}\n> > \n> > The conversion `R(c)` should not be necessary here, as the coefficients should already be elements of the base ring.\n> \n> If we add that conversion, then we can remove the\n> {{{\n> assert self.base_ring() == f.base_ring()\n> }}}\n> which I think is not a good thing to enforce.\n\nIndeed, I found this line a bit weird. Though I did not touch since it was beyond the scope of the ticket.",
    "created_at": "2020-04-27T16:02:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415201",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:34 tscrim]:
> Replying to [comment:31 gh-mwageringel]:
> > Replying to [comment:29 tscrim]:
> > I am happy with this ticket as it is now. Except maybe there is one little detail from Travis' suggestion:
> > 
> > {{{
> >         out = self._from_dict({_Partitions.element_class(_Partitions, list(e)): R(c)
> >                                for (e,c) in f.dict().items()
> > }}}
> > 
> > The conversion `R(c)` should not be necessary here, as the coefficients should already be elements of the base ring.
> 
> If we add that conversion, then we can remove the
> {{{
> assert self.base_ring() == f.base_ring()
> }}}
> which I think is not a good thing to enforce.

Indeed, I found this line a bit weird. Though I did not touch since it was beyond the scope of the ticket.



---

archive/issue_comments_415202.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-04-30T19:25:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415202",
    "user": "https://github.com/mwageringel"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_415203.json:
```json
{
    "body": "Ok, it seems this is ready to be merged then? Let me set this ticket to positive, but please undo if you disagree.",
    "created_at": "2020-04-30T19:25:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415203",
    "user": "https://github.com/mwageringel"
}
```

Ok, it seems this is ready to be merged then? Let me set this ticket to positive, but please undo if you disagree.



---

archive/issue_comments_415204.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2020-05-04T06:40:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29316#issuecomment-415204",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_027086.json:
```json
{
    "actor": "@vbraun",
    "created_at": "2020-05-04T06:40:58Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/29316",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/29316#event-27086"
}
```
