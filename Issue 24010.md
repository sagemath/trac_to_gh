# Issue 24010: Implement __pow__ in the coercion model

Issue created by migration from https://trac.sagemath.org/ticket/24247

Original creator: jdemeyer

Original creation time: 2017-11-20 09:42:56




---

Comment by git created at 2017-11-20 16:26:47

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-11-20 18:13:10

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-11-21 13:17:28

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-11-21 14:17:00

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-11-21 17:38:02

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-11-24 15:00:57

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-12-05 09:18:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-12-05 10:07:51

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-12-06 16:12:53

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-12-07 10:15:59

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-12-23 13:16:38

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-12-24 09:07:07

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-12-24 09:09:35

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-12-24 09:24:16

Changing status from new to needs_review.


---

Comment by git created at 2017-12-24 13:52:59

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by nbruin created at 2017-12-25 02:41:49

Isn't `__pow__` just a right action, by either `ZZ` or `RR`?


---

Comment by jdemeyer created at 2017-12-25 09:53:38

Replying to [comment:28 nbruin]:
> Isn't `__pow__` just a right action, by either `ZZ` or `RR`?

It could be an action. But I don't really understand what you are trying to say.

Are you saying that it should be an action?

Are you saying that there _should not_ be a special method like `_pow_int`?

(Note that these are two independent questions)


---

Comment by nbruin created at 2017-12-25 19:59:37

I was really just wondering if there would be a benefit to treating it as an action. There may be other hooks that are already available in the coercion framework, but the standard binary operation code tries (if I recall correctly) to find a *common* parent, and that's not the right thing to do for powering in general. Actions, on the other hand, should come pretty close. I have no feeling for the performance implications, though. I just raised the point because a brief scanning through the contributions here didn't seem to have considered this possibility.

For `_pow_int`: given the various powering strategies that exist for different types of rings (square-multiply, frobenius, power series expansion), my guess is that it's worth having a hook for it.


---

Comment by jdemeyer created at 2017-12-26 10:47:02

Replying to [comment:30 nbruin]:
> For `_pow_int`: given the various powering strategies that exist for different types of rings (square-multiply, frobenius, power series expansion), my guess is that it's worth having a hook for it.

OK good. So we are just talking about the code which calls this method.


---

Comment by vdelecroix created at 2017-12-26 16:41:19

Close to the arguments in [comment:30 comment:30], I am not sure that finding a common parent is a good solution to handle powerings. The only reasonable assumption that could be done with powering is `(x<sup>a)</sup>b = x^(a*b)` (that is: it is a multiplicative action).

Also, the command `QQbar.gen()^(1/3)` should not try to coerce `1/3` to `QQbar`. Rational, as integers, should definitely be treated apart. Though, do we have any concrete case where exponents can be something else than integer/rational?  With respect to rational powering, this ticket raises an important question: what should be done with this coercion incoherence

```
sage: 4**(1/2)
2
sage: type(_)
<type 'sage.rings.rational.Rational'>
sage: 3**(1/2)
sqrt(3)
sage: type(_)
<type 'sage.symbolic.expression.Expression'>
```

Note also that `x^a * y^a = (x*y)^a` is wrong with rational exponents has often there is a *choice* of a root

```
sage: ((-1)^(1/3))^3
-1
sage: ((-1)^3)^(1/3)
(-1)^(1/3)
```



---

Comment by nbruin created at 2017-12-27 19:59:18

Replying to [comment:32 vdelecroix]:
> Also, the command `QQbar.gen()^(1/3)` should not try to coerce `1/3` to `QQbar`. Rational, as integers, should definitely be treated apart. Though, do we have any concrete case where exponents can be something else than integer/rational?

Yes, on anything with a real or complex analytic structure one probably wants that `x^y` is a shorthand for `exp(log(x)*y)` (although for serious use the latter is much better for understanding subtleties arising from multi-valuedness)

It does look like we might want to handle powering action by integers (no multi-valuedness problem, but may need existence or adjunction of inverses), by rationals, by appropriate completions of rationals as different actions, because of their different problems.

In principle, on a commutative multiplicative group of exponent `N` we'd even have a powering action by `ZZ/N ZZ`. I'm not so sure it's worth supporting that explicitly, though.


---

Comment by jdemeyer created at 2017-12-27 20:37:57

A lot of points are raised here.

First of all, the point of this ticket is _making possible_ various ways of implementing powering in various parents, not to actually implement it that way. For example, I don't plan to re-implement powering for `QQbar` in this ticket. What is within the scope of this ticket is _making it possible_ to implement a parent which treats powering by rationals in a specific way (by going through the coercion model which checks for actions and this `QQbar^QQ` powering should be an action).

Second, I do agree that powering by integers is special enough that there should be a default action (as suggested by Nils) which calls the special method `_pow_int`.

Third, I think that coercing to a common parent does make sense because:

1. It is consistent with all other operators. Often multiplication is treated as an action too. Still, when no action is found, coercion to a common parent is done.

2. There are several parents where a common parent for powering makes sense, in particular the various incarnations of real/complex numbers and the symbolic ring.

3. If coercion to a common parent shouldn't be done, then what should be done by default if no action is found?


---

Comment by jdemeyer created at 2017-12-27 20:40:50

Replying to [comment:32 vdelecroix]:
> With respect to rational powering, this ticket raises an important question: what should be done with this coercion incoherence
> {{{
> sage: 4**(1/2)
> 2
> sage: type(_)
> <type 'sage.rings.rational.Rational'>
> sage: 3**(1/2)
> sqrt(3)
> sage: type(_)
> <type 'sage.symbolic.expression.Expression'>
> }}}

Sorry, but that is a question about the implementation of powering for a specific parent, so not within the scope of this ticket.


---

Comment by git created at 2017-12-30 18:00:10

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-12-30 18:05:52

Changing status from needs_review to needs_work.


---

Comment by git created at 2018-01-01 18:48:26

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-01-02 17:50:55

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-01-03 11:42:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-01-03 16:54:38

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-01-04 16:30:55

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-01-04 16:41:24

Changing status from needs_work to needs_review.


---

Comment by git created at 2018-01-08 09:15:40

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2018-01-08 16:51:38

I am not sure I agree with this change:

```diff
@@ -2015,8 +2003,8 @@ cdef class Integer(sage.structure.element.EuclideanDomainElement):
 
         TESTS::
 
-            sage: complex(0,1)^2
-            (-1+0j)
+            sage: complex(0,1) ^ 2
+            -1.0
             sage: R.<t> = QQ[]
             sage: 2^t
             Traceback (most recent call last):
```

In Python, we have

```
>>> complex(0,1)**2
(-1+0j)
```

and generally, I think `x^2` should be the same as `x * x`. In this case, they are equal, but they are different types. While `complex` has all of the methods that `float` has, it is surprising to me that we do not get a `complex` result (in particular, since I thought it was suppose to be considered as an action). Also, can we add a test to check that `complex(0,1) ^ int(2)` is consistent?

For those Cython classes defining a `cpdef _pow_int`, do you need to declare that in the `.pxd` file since you are overwriting a `cdef` with a `cpdef` (see `Integer` and `RealDoubleElement`)? Or is the declaration in `ModuleElement` sufficient (but then why for its subclass `RingElement`)?

Have you looked at timings? I think this is almost certainly the way forward, but I am worried about how much of a speed regression this might have on taking integer exponentiation of, e.g., polynomials. (At least something I do in my research is combinatorial generating functions: `sum(q^s(b) for b in B)` for some set `B` and statistic `s`.)


---

Comment by jdemeyer created at 2018-01-08 18:26:50

Replying to [comment:49 tscrim]:
> I am not sure I agree with this change:
> {{{#!diff
> `@``@` -2015,8 +2003,8 `@``@` cdef class Integer(sage.structure.element.EuclideanDomainElement):
>  
>          TESTS::
>  
> -            sage: complex(0,1)^2
> -            (-1+0j)
> +            sage: complex(0,1) ^ 2
> +            -1.0
>              sage: R.<t> = QQ[]
>              sage: 2^t
>              Traceback (most recent call last):
> }}}

I thought that any operation between a Python type and a Sage parent should coerce everything to Sage. But it seems that this is not done consistently:

```
sage: parent(float(1) + 1)
<type 'float'>
```


For `complex ^ ZZ`, I think that `CDF` also makes sense as an answer: the Sage coercion model replaces `complex` by `CDF` and then does the powering `CDF ^ ZZ`. However, I understand why you would want it to return a `complex`. I'll think about this.

> Also, can we add a test to check that `complex(0,1) ^ int(2)` is consistent?

What do you mean here? That wouldn't use any Sage code.


---

Comment by jdemeyer created at 2018-01-08 18:29:45

Replying to [comment:49 tscrim]:
> For those Cython classes defining a `cpdef _pow_int`, do you need to declare that in the `.pxd` file since you are overwriting a `cdef` with a `cpdef`

If it inherits directly from `Element` (not `ModuleElement` or `MonoidElement`), then yes.

> Or is the declaration in `ModuleElement` sufficient

I guess you mean `MonoidElement` or `RingElement`. But yes, that is sufficient.


---

Comment by tscrim created at 2018-01-08 22:04:47

Replying to [comment:50 jdemeyer]:
> Replying to [comment:49 tscrim]:
> I thought that any operation between a Python type and a Sage parent should coerce everything to Sage.

I wasn't aware that this was a policy, but I usually don't think too much about Python types.

> But it seems that this is not done consistently:
> {{{
> sage: parent(float(1) + 1)
> <type 'float'>
> }}}

We probably haven't yet implemented the hooks for floats yet.

> For `complex ^ ZZ`, I think that `CDF` also makes sense as an answer: the Sage coercion model replaces `complex` by `CDF` and then does the powering `CDF ^ ZZ`. However, I understand why you would want it to return a `complex`. I'll think about this.

`CDF` would be a good target. Whatever we decide, we should add the parent as part of the test.

> > Also, can we add a test to check that `complex(0,1) ^ int(2)` is consistent?
> 
> What do you mean here? That wouldn't use any Sage code.

Ah, right, the coercion model should not be called, and we run into similar sort of discrepancies when doing things like `1 / 2` in a `.py` file.


---

Comment by tscrim created at 2018-01-08 22:13:34

Replying to [comment:51 jdemeyer]:
> Replying to [comment:49 tscrim]:
> > For those Cython classes defining a `cpdef _pow_int`, do you need to declare that in the `.pxd` file since you are overwriting a `cdef` with a `cpdef`
> 
> If it inherits directly from `Element` (not `ModuleElement` or `MonoidElement`), then yes.

Then why do you add it for `Expression`?

> > Or is the declaration in `ModuleElement` sufficient
> 
> I guess you mean `MonoidElement` or `RingElement`. But yes, that is sufficient.

Whoops, yes I do.


---

Comment by jdemeyer created at 2018-01-09 08:24:25

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2018-01-09 08:24:25

Replying to [comment:52 tscrim]:
> I wasn't aware that this was a policy, but I usually don't think too much about Python types.

Now I don't think that there is such a policy either. I _thought_ that was such a policy so I _thought_ that `CDF` would be the correct parent for `float ^ ZZ`. But I can easily fix that to return a `float` instead, so let's do that.


---

Comment by jdemeyer created at 2018-01-09 08:26:07

Replying to [comment:53 tscrim]:
> Then why do you add it for `Expression`?

No particular reason. Maybe I needed to add it at some point during the development of this ticket. I'll remove it. The `_pow_` needs to stay though since there is no default implementation.


---

Comment by git created at 2018-01-09 10:13:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2018-01-09 10:23:07

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2018-01-09 10:56:57

Replying to [comment:49 tscrim]:
> In Python, we have
> {{{
> >>> complex(0,1)**2
> (-1+0j)
> }}}

In the latest commit, I fixed this: now a non-`Element` raised to a `ZZ` power will do the powering with an `int` exponent instead. For consistency, I did this for all base types, such that `int(3) ^ (-3)` now returns a `float` instead of a `QQ` element.


---

Comment by jdemeyer created at 2018-01-09 13:05:20

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2018-01-09 13:05:20

The recent change seems to have introduced various doctest failures.


---

Comment by git created at 2018-01-09 13:53:23

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-01-09 13:53:42

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2018-01-09 14:43:31

Replying to [comment:49 tscrim]:
> Have you looked at timings?

First of all, it is important to state that this ticket only changes powering for certain parents. It allows to implement powering using the coercion model, but many parents with a custom `__pow__` still have that custom `__pow__` after applying this ticket and won't use the coercion model. This is case for polynomials for example. So we only look at a few parents where the powering actually uses the new code.

Now the timings. The conclusion seems to be that powering for equal parents is slightly faster than before but that powering with non-equal parents is slower than before. This is because the latter goes through the coercion model now.

*ZZ<sup>ZZ</sup>*

Before:

```
sage: a = ZZ(2); n = ZZ(2); timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 122 ns per loop
```


After:

```
sage: a = ZZ(2); n = ZZ(2); timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 110 ns per loop
```


*GF(2<sup>n</sup>)<sup>ZZ</sup>*

Before:

```
sage: k.<a> = GF(4, impl="ntl"); n = 2; timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 377 ns per loop
```


After:

```
sage: k.<a> = GF(4, impl="ntl"); n = 2; timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 607 ns per loop
```


*RDF<sup>RDF</sup>*

Before:

```
sage: a = RDF(2); n = RDF(2); timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 139 ns per loop
```


After:

```
sage: a = RDF(2); n = RDF(2); timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 132 ns per loop
```


*RDF<sup>ZZ</sup>*

Before:

```
sage: a = RDF(2); n = ZZ(2); timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 156 ns per loop
```


After:

```
sage: a = RDF(2); n = ZZ(2); timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 240 ns per loop
```


*ideal<sup>ZZ</sup>*

Before:

```
sage: a = ZZ.ideal(2); n = ZZ(2); timeit('a ^ n', number=10000, repeat=20)
10000 loops, best of 20: 13.2 µs per loop
```


After:

```
sage: a = ZZ.ideal(2); n = ZZ(2); timeit('a ^ n', number=10000, repeat=20)
10000 loops, best of 20: 14.6 µs per loop
```



---

Comment by jdemeyer created at 2018-01-09 14:55:09

Part of the slowdown is caused by `Action.__call__` (see #24500). After optimizing that a bit, I go from

```
sage: k.<a> = GF(4, impl="ntl"); n = 2; timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 607 ns per loop
```

to

```
sage: k.<a> = GF(4, impl="ntl"); n = 2; timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 506 ns per loop
```


and from

```
sage: a = RDF(2); n = ZZ(2); timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 240 ns per loop
```

to

```
sage: a = RDF(2); n = ZZ(2); timeit('a ^ n', number=100000, repeat=20)
100000 loops, best of 20: 182 ns per loop
```



---

Comment by jdemeyer created at 2018-01-09 15:36:57

Travis, please let me know what you think of the timings and whether #24500 should be a dependency of this ticket. Personally, I think that #24500 will be non-trivial, so I would rather not make it a dependency.


---

Comment by vdelecroix created at 2018-01-09 16:15:17

I like very much the idea of moving powering inside the coercion model. Though, it is not a binary operator `X x X -> X` (do you have any example of this beyond `NN` or `RR_+`?). I still don't understand why you would need

```
Apart from this, powering behaves like other binary operators:
coercion to a common parent is done if no action is defined. 
```



---

Comment by jdemeyer created at 2018-01-09 18:55:19

Replying to [comment:65 vdelecroix]:
> I like very much the idea of moving powering inside the coercion model. Though, it is not a binary operator `X x X -> X` (do you have any example of this beyond `NN` or `RR_+`?). I still don't understand why you would need
> {{{
> Apart from this, powering behaves like other binary operators:
> coercion to a common parent is done if no action is defined. 
> }}}

Copying from [comment:34]:


I think that coercing to a common parent does make sense because:

1. It is consistent with all other operators. Often multiplication is treated as an action too. Still, when no action is found, coercion to a common parent is done.

2. There are several parents where a common parent for powering makes sense, in particular the various incarnations of real/complex numbers and the symbolic ring.

3. If coercion to a common parent shouldn't be done, then what should be done by default if no action is found?


---

Comment by tscrim created at 2018-01-09 20:57:43

Thank for the timings and explanation. I am the most concerned with the GF(2<sup>n</sup>)<sup>ZZ</sup> timings being ~2x slower as I would expect exponentiation to be a fairly common operation. For me personally, it is not important, but I know for the number theorist using Sage, it could have a much bigger impact. However, you know that area of math/Sage better than I, so if you think it will be okay, then no objection from me.


---

Comment by jdemeyer created at 2018-01-10 08:48:15

Replying to [comment:67 tscrim]:
> Thank for the timings and explanation. I am the most concerned with the GF(2<sup>n</sup>)<sup>ZZ</sup> timings being ~2x slower

It's actually only a factor 1.61 slower but that will improve significantly after #24500. Possibly, other optimizations in the coercion model are possible.

It is also important to note that I intentionally took the worst case of `GF(4)` implemented using NTL. The default implementation for that field size is Givaro, which is not affected by this ticket. Only for `GF(2^16)` and larger is NTL the default and then the cost of the coercion becomes a much smaller fraction of the actual computation.


---

Comment by tscrim created at 2018-01-10 16:55:44

Okay, then positive review from me.

Does anyone else have any other objections or questions?


---

Comment by vdelecroix created at 2018-01-11 08:03:08

fine for me


---

Comment by jdemeyer created at 2018-01-11 14:52:03

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-01-15 22:29:32

Resolution: fixed
