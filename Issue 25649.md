# Issue 25649: Implement field_of_definition for DynamicalSystem

Issue created by migration from Trac.

Original creator: @Loops7

Original creation time: 2018-07-20 08:28:06

CC:  bhutz

For the nth iterate of a given DynamicalSystem, we provide a method that returns the field extension of Q over which all of the periodic points, critical points, or pre-images of a point are defined.


---

Comment by git created at 2018-07-26 06:41:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-26 06:42:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-07-27 05:45:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bhutz created at 2018-07-27 14:24:52

I know this is not done yet, but here are some comments:

----
base field should be more than just QQ
 - base a number field
 - base a finite field (prime field or not prime field)
 - base padic field (QQ_p)

looks like .splitting_field() is implemented for the first two, but not for p-adics. so perhaps p-adic needs to wait on that.

----
I think you are returning an 'absolute' number field and not just a number field.

----

It should be possible to also return the embedding of the base field into the new field

----
I think you want this to be

```
space = ds.domain().ambient_space()
```

----

```
where a formal periodic point is a point of exact period ``n``,
or equivalently a root of the ``n``-th dynatomic polynomial. 
```

These are not equivalent. Formal is a root of the dynamtomic which is not necessarily exact period n.

----

It should be

```
CR(f*point[1] - g*point[0]).univariate_polynomial()
```



---

Comment by @Loops7 created at 2018-07-27 20:39:53

Okay, will work to implement these changes. However, specifically on the last point, `point` will always be either a point in `ProjectiveSpace`, in which case point[1] = 1, or a point in `AffineSpace` of dimension 1, meaning point[1] is undefined, so I think it should be okay as is. With that said, I do need to add a check for the point at infinity.


---

Comment by bhutz created at 2018-07-27 21:32:53

Sure, points are *typically* normalized (over a field) so that the last coordinate is 1. But it is simple to create points where that is not true. So I don't think you should assume the points are normalized.


```
P.<x,y>=ProjectiveSpace(QQ,1)
Q=P.point([1,2], False)
Q
```



---

Comment by git created at 2018-08-02 08:48:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Loops7 created at 2018-08-02 08:50:31

Changing status from new to needs_review.


---

Comment by git created at 2018-08-08 06:51:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Loops7 created at 2018-08-08 07:00:05

Made the minor changes we talked about, and also caught an error in handling the point at infinity in the preimage code. Also noticed some odd behavior (unrelated to this ticket):


```
sage: A.<z> = AffineSpace(QQ,1)
sage: f = DynamicalSystem([z^2], A)
sage: g = DynamicalSystem([1/z^2], A)
sage: type(f[0].denominator())
<type 'sage.rings.integer.Integer'>
sage: type(g[0].denominator())
<type 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular'>
```


Namely, we get back an int when 1 is in the denominator, and a poly when 1 is in the numerator. Not sure exactly where that is stemming from as of right now.


---

Comment by bhutz created at 2018-08-08 14:18:17

Changing status from needs_review to needs_work.


---

Comment by bhutz created at 2018-08-08 14:18:17

Only came up with one fail test


```
K.<v>=QuadraticField(2)
R.<z>=K[]
L.<w>=K.extension(z^3-5)
P.<x,y>=ProjectiveSpace(L,1)
f=DynamicalSystem([x^3 + -w*x^2*y- y^3, x*y^2])
g=f.dehomogenize(1)
Q=g.domain()(1)
K, phi=g.field_of_definition_preimage(1,Q,return_embedding=True);K
```


otherwise just some minor changes
- should reassign

```
n = int(n)
```


- n should be optional for critical points, so default it to 1. In fact, I would not be opposed to removing n entirely from the critical points function. If the user wants the critical points of the nth iterate, they can call nth iterate and then critical points.

- I didn't built the docs yet, so I'll do that after you fix this last failed example.

----

To answer the random other question. The difference is


```
sage: f[0].parent()
polynomial ring
sage: g[0].parent()
fraction field of polynomial 
```


when an affine map is initialized, it remains polys if the coordinate are all poly, otherwise it coerces to the fraction field.


---

Comment by git created at 2018-08-09 05:35:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Loops7 created at 2018-08-09 05:55:13

Alright, I made the changes you mentioned, including getting rid of `n` altogether in critical, since that makes the most sense to me. The error you encountered was from the added snippet in preimage in the previous commit:



```
point = (point, 1)
```

This handled the case of a defining a `point[1]` that can be used in the construction of a polynomial given a point on the affine line. However, I corrected it to 



```
point = (point[0], 1)
```

which ensures that the new point object has the right type of object in the first slot, namely an element of the base field. 

Given our previous conversation, I also corrected the coordinate ring to be 

```
CR = ds.domain().ambient_space().coordinate_ring()
```

which fixed a couple edge cases I uncovered. 

The only failure I had left was 



```
A.<z> = AffineSpace(QQ,1)
f = DynamicalSystem_affine([1], A)
f.field_of_definition_preimage(2, A(1))
```


However, this error stems from the `nth_iterate_map()` code, since it takes `1` as an integer instead of an element of `QQ[]`. I am not sure if the correction should be made in the instantiation code of `DynamicalSystem` or just a special case in `nth_iterate_map()`, but either way it is not a part of this ticket.

I also removed the special case of splitting field being called on a constant polynomial and just returning the base field. Instead, I removed this case to make it more uniform in what objects we are returning. So if the field of definition is `QQ`, we will get back a "`NumberField` with defining polynomial `x`". One option would be to internally call splitting_field and then check if the defining polynomial of the returned number field is degree 1, so that we could return `QQ` or whatever the given base field was, but not sure if it is worth it. 

Let me know if this latest commit passes your tests as well.


---

Comment by @Loops7 created at 2018-08-09 05:58:44

Changing status from needs_work to needs_review.


---

Comment by bhutz created at 2018-08-09 13:54:07

All my tests pass with this version.

yes, your one failure is an issue for a different ticket. I've made note of that example.

In regards to  "Numberfield with defining polynomial x". I personally find that annoying and would put in a check of the field degree and return QQ if it is degree 1.

Although this led me to another interesting problem. splitting field only extends. What if the field of definition is smaller than the base_field because the coefficients of the map are actually defined over a subfield of the base field. See the next example. In this case we are not returning the object we claimed we were. We are a returning a field where all the *-points are defined, but not the minimal such field.

```
K.<v>=QuadraticField(-2)
R.<z>=PolynomialRing(K)
h=(z^2-1)
h.splitting_field('v')
```

It may be sufficient just to note in the documentation that this function only extends on so may not return the minimal such field if it is a subfield of the base. There is a plan for a function the changes the base to the minimal base for the given coefficients, but it hasn't been implemented yet. So users looking for the minimal such field would be able to first call that function and then this one.


---

Comment by git created at 2018-08-15 01:44:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-08-15 01:48:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by bhutz created at 2018-08-15 14:47:58

Changing status from needs_review to needs_work.


---

Comment by bhutz created at 2018-08-15 14:47:58

A number of issues came up in my testing;

----
why is this part of the doctests??


```
sage: R.<z> = G[]
sage: R.irreducible_element(3, algorithm = 'first_lexicographic')
z^3 + (a + 1)*z + a
```

doesn't seem like it is relevant

----
no spaces in parameter assignment such as for

```
domain = A
```

There are many instances of this for all the parameters
----

the doc says 'which all periodic points of the ``n``-th iterate are defined'. Which is not quite accurate.

either 'all fixed points of the nth iterate' or 'all points with period (dividing) n'.

----

some notebook failures

- didn't import QQ

```
P.<x,y> = ProjectiveSpace(QQ, 1)
f = DynamicalSystem([x^2, y^2], domain = P)
N.<a> = f.field_of_definition_periodic(1); N
```


- can't deal with returning the embedding

```
P.<x,y> = ProjectiveSpace(QQ, 1)
f = DynamicalSystem([x^2+y^2, y^2], domain = P)
N.<a> = f.field_of_definition_periodic(2, formal=False, return_embedding=True); N
```



----
doctests could be a little more thorough

- utilize all the parameters
- check that when changing to the field of definition you get all the points (can just count)
 * `2d-2` for critical
 * `d^n + 1` for periodic (formal = False)
 * preimages (`d^n` if not a critical point)

----
Notice that the rational_preimages function has the parameters in the opposite order


```
P.<x,y> = ProjectiveSpace(QQ, 1)
f = DynamicalSystem([x^2+y^2, y^2], domain = P)
N.<a> = f.field_of_definition_preimage(2,P(0));N
g = f.change_ring(N)
g.rational_preimages(P(0),2)
```


would be better if they matched


---

Comment by @Loops7 created at 2018-08-16 04:50:49

The reason I had the bit about the irreducible element in there was because I figured these are technically examples instead of tests, so it would give some indication as to where the defining equation of the dynamical system came from, and that we actually need a field extension. 

I now remember why I removed the QQ case in the first place- it was because of the exact embedding inconsistency you pointed out, but I guess we can just return End(QQ)(1). 

As far as the preimage parameter ordering, I initially did that to remain consistent with the other field_of_def methods, where `n` is the first parameter. It can be changed though. 



```
sage: P.<x,y> = ProjectiveSpace(QQ, 1)
sage: f = DynamicalSystem([1/3*x^3 + x*y^2, y^3], domain=P)
sage: f.critical_points()
[(1 : 0)]
sage: N.<a> = f.field_of_definition_critical(); N
Number Field in a with defining polynomial x^2 + 1
sage: g = f.change_ring(N)
sage: g.critical_points()
[(-a : 1), (a : 1), (1 : 0)]
```


Does (1:0) have multiplicity 2 here, so that we satisfy the 2d-2 requirement? If so, why?


---

Comment by bhutz created at 2018-08-16 15:43:19

For the embedding, I think it's best to use

```
ds.base_ring().embeddings(QQ)[0]
```

Since there will be a unique embedding of a degree 1 number field into QQ, this works regardless of what form the base ring is in.


Yes, infty has multiplicity 2. The binary form defining the critical points will have a factor of `y^2` in it. Alternatively, if you prefer to work with affine points, dehomogenize at coordinate 0, then infty is 0 in that affine patch and you can check that 0 is a double root of the resulting critical point polynomial.


---

Comment by git created at 2018-08-21 05:23:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Loops7 created at 2018-08-28 07:55:51

Changing status from needs_work to needs_review.


---

Comment by bhutz created at 2018-08-28 12:44:40

Changing status from needs_review to needs_work.


---

Comment by bhutz created at 2018-08-28 12:44:40

Functionality is looking good here. A few minor typographical issues

- in a number of places the INPUT specifies number fields when it works for finite fields as well.

- the comment

```
Note that the number of critical points is 2d-2, but (1:0) has multiplicity 2 in this case
```

should go before the example not after

```
EXAMPLES: 

Note that the number of critical points is 2d-2, but (1:0) has multiplicity 2 in this case::

    sage:
```


- dimension not degree in the 2 error messages

```
not implemented for affine or projective spaces of degree >1
```



---

Comment by git created at 2018-08-30 05:19:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Loops7 created at 2018-08-30 05:20:06

Changing status from needs_work to needs_review.


---

Comment by bhutz created at 2018-08-30 15:25:56

Looks good. Just made some minor doc updates. If you're fine with those, we can mark this positive.
----
New commits:


---

Comment by @Loops7 created at 2018-09-03 20:06:10

Looks good to me.


---

Comment by @Loops7 created at 2018-09-03 20:06:10

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-09-05 16:43:36

Resolution: fixed
