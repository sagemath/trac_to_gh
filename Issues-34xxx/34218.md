# Issue 34218: Implement longest_increasing_subsequence_number

archive/issues_033981.json:
```json
{
    "body": "CC:  @nadialafreniere @dcoudert\n\nFollowing the method of #31451, we implement a method that returns the number of maximal increasing subsequences of a permutation. This method is much faster than listing them all\n\n```\nsage: %time _ = sum(len(p.longest_increasing_subsequences()) for p in Permutations(8))\nCPU times: user 1.76 s, sys: 2.97 ms, total: 1.76 s\nWall time: 1.77 s\n120770\nsage: %time sum(p.longest_increasing_subsequences_number() for p in Permutations(8))\nCPU times: user 328 ms, sys: 0 ns, total: 328 ms\nWall time: 328 ms\n120770\n```\n\nIssue created by migration from https://trac.sagemath.org/ticket/34218\n\n",
    "closed_at": "2022-08-01T20:22:48Z",
    "created_at": "2022-07-25T07:16:10Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.7",
    "title": "Implement longest_increasing_subsequence_number",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/34218",
    "user": "https://github.com/videlec"
}
```
CC:  @nadialafreniere @dcoudert

Following the method of #31451, we implement a method that returns the number of maximal increasing subsequences of a permutation. This method is much faster than listing them all

```
sage: %time _ = sum(len(p.longest_increasing_subsequences()) for p in Permutations(8))
CPU times: user 1.76 s, sys: 2.97 ms, total: 1.76 s
Wall time: 1.77 s
120770
sage: %time sum(p.longest_increasing_subsequences_number() for p in Permutations(8))
CPU times: user 328 ms, sys: 0 ns, total: 328 ms
Wall time: 328 ms
120770
```

Issue created by migration from https://trac.sagemath.org/ticket/34218





---

archive/issue_comments_481879.json:
```json
{
    "body": "I tried implementing it, but I'm not convinced by the result. The method with the adjacency matrix of the digraph seems to be slower. Mainly, I think that a lot of the problem comes from taking the exponential of the adjacency matrix of the digraph (an (n+2)-by-(n+2) matrix raised to a power that is in \u03b8(\u221an) in average), and this seems to slow the process down much more than listing the longest increasing subsequences.\n\nAfter coding it, I got the following times:\n\n```\nsage: %timeit len(Permutations(100).random_element().longest_increasing_subsequences())  # Naive \n2.8 ms \u00b1 284 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\nsage: %timeit Permutations(100).random_element().longest_increasing_subsequences_number()  # new code\n4.42 ms \u00b1 42 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n```\n\nEven though I'm uploading my code to the trac, I think we might want to give up on the project. Or, if you know of a way to make it efficient, I would love to see it.\n\n---\nLast 10 new commits:",
    "created_at": "2022-07-25T20:20:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481879",
    "user": "https://github.com/nadialafreniere"
}
```

I tried implementing it, but I'm not convinced by the result. The method with the adjacency matrix of the digraph seems to be slower. Mainly, I think that a lot of the problem comes from taking the exponential of the adjacency matrix of the digraph (an (n+2)-by-(n+2) matrix raised to a power that is in θ(√n) in average), and this seems to slow the process down much more than listing the longest increasing subsequences.

After coding it, I got the following times:

```
sage: %timeit len(Permutations(100).random_element().longest_increasing_subsequences())  # Naive 
2.8 ms ± 284 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit Permutations(100).random_element().longest_increasing_subsequences_number()  # new code
4.42 ms ± 42 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
```

Even though I'm uploading my code to the trac, I think we might want to give up on the project. Or, if you know of a way to make it efficient, I would love to see it.

---
Last 10 new commits:



---

archive/issue_comments_481880.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-07-25T21:22:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481880",
    "user": "https://github.com/videlec"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_481881.json:
```json
{
    "body": "Indeed, matrix powering is not clever enough. Though one can avoid the creation of the digraph which is time consuming.\n\n---\nNew commits:",
    "created_at": "2022-07-25T21:22:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481881",
    "user": "https://github.com/videlec"
}
```

Indeed, matrix powering is not clever enough. Though one can avoid the creation of the digraph which is time consuming.

---
New commits:



---

archive/issue_comments_481882.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2022-07-25T21:23:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481882",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_481883.json:
```json
{
    "body": "At commit `a98a60f` I got\n\n```\nsage: %time sum(len(p.longest_increasing_subsequences()) for p in Permutations(8))\nCPU times: user 1.76 s, sys: 2.97 ms, total: 1.76 s\nWall time: 1.77 s\n120770\nsage: %time sum(p.longest_increasing_subsequences_number() for p in Permutations(8))\nCPU times: user 328 ms, sys: 0 ns, total: 328 ms\nWall time: 328 ms\n120770\n```",
    "created_at": "2022-07-25T21:24:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481883",
    "user": "https://github.com/videlec"
}
```

At commit `a98a60f` I got

```
sage: %time sum(len(p.longest_increasing_subsequences()) for p in Permutations(8))
CPU times: user 1.76 s, sys: 2.97 ms, total: 1.76 s
Wall time: 1.77 s
120770
sage: %time sum(p.longest_increasing_subsequences_number() for p in Permutations(8))
CPU times: user 328 ms, sys: 0 ns, total: 328 ms
Wall time: 328 ms
120770
```



---

archive/issue_comments_481884.json:
```json
{
    "body": "And same test as your [This is the Trac macro *comment:2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:2-macro) gives on my machine\n\n```\nsage: %timeit len(Permutations(100).random_element().longest_increasing_subsequences())  # Naive \n1.55 ms \u00b1 69.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\nsage: %timeit Permutations(100).random_element().longest_increasing_subsequences_number()  # new code\n122 \u00b5s \u00b1 2.38 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n```",
    "created_at": "2022-07-25T21:26:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481884",
    "user": "https://github.com/videlec"
}
```

And same test as your [This is the Trac macro *comment:2* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#comment:2-macro) gives on my machine

```
sage: %timeit len(Permutations(100).random_element().longest_increasing_subsequences())  # Naive 
1.55 ms ± 69.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: %timeit Permutations(100).random_element().longest_increasing_subsequences_number()  # new code
122 µs ± 2.38 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
```



---

archive/issue_comments_481885.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to combinatorics.",
    "created_at": "2022-07-25T21:29:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481885",
    "user": "https://github.com/videlec"
}
```

Changing component from PLEASE CHANGE to combinatorics.



---

archive/issue_comments_481886.json:
```json
{
    "body": "I was about to explain how to count the number of paths on a DAG when all arcs go from level `i` to level `i+1` in time `O(|V| + |E|)`, but your solution avoids the creation of the DAG. This is smart.\n\nYou could add a little explanation of the algorithm, at least for Nadia.\n\nFor the documentation, you could use `:meth:~.longest_increasing_subsequences`, or something like that.\n\nOtherwise, LGTM.",
    "created_at": "2022-07-25T21:37:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481886",
    "user": "https://github.com/dcoudert"
}
```

I was about to explain how to count the number of paths on a DAG when all arcs go from level `i` to level `i+1` in time `O(|V| + |E|)`, but your solution avoids the creation of the DAG. This is smart.

You could add a little explanation of the algorithm, at least for Nadia.

For the documentation, you could use `:meth:~.longest_increasing_subsequences`, or something like that.

Otherwise, LGTM.



---

archive/issue_comments_481887.json:
```json
{
    "body": "For Nadia: roughly, in the DAG, the number of paths to reach vertex `x` of column `i+1` is the sum over the predecessors of `x` (all in column `i`) of the number of paths from to source to each of these predecessors. For initialization, there is a single path to go from the source to a vertex in column 0 (a successor of the source). then, you iterate over the columns and you add the count of `x` in the current column to each of its successors.\n\nThe method of Vincent do the same computation but avoids to build the DAG.",
    "created_at": "2022-07-25T21:48:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481887",
    "user": "https://github.com/dcoudert"
}
```

For Nadia: roughly, in the DAG, the number of paths to reach vertex `x` of column `i+1` is the sum over the predecessors of `x` (all in column `i`) of the number of paths from to source to each of these predecessors. For initialization, there is a single path to go from the source to a vertex in column 0 (a successor of the source). then, you iterate over the columns and you add the count of `x` in the current column to each of its successors.

The method of Vincent do the same computation but avoids to build the DAG.



---

archive/issue_comments_481888.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-07-26T07:04:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481888",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_481889.json:
```json
{
    "body": "LGTM.",
    "created_at": "2022-07-26T08:50:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481889",
    "user": "https://github.com/dcoudert"
}
```

LGTM.



---

archive/issue_comments_481890.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2022-07-26T08:50:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481890",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_481891.json:
```json
{
    "body": "Replying to [comment:10 dcoudert]:\n> For Nadia: roughly, in the DAG, the number of paths to reach vertex `x` of column `i+1` is the sum over the predecessors of `x` (all in column `i`) of the number of paths from to source to each of these predecessors. For initialization, there is a single path to go from the source to a vertex in column 0 (a successor of the source). then, you iterate over the columns and you add the count of `x` in the current column to each of its successors.\n> \n> The method of Vincent do the same computation but avoids to build the DAG.\n\nNice job! This looks very good!",
    "created_at": "2022-07-26T10:43:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481891",
    "user": "https://github.com/nadialafreniere"
}
```

Replying to [comment:10 dcoudert]:
> For Nadia: roughly, in the DAG, the number of paths to reach vertex `x` of column `i+1` is the sum over the predecessors of `x` (all in column `i`) of the number of paths from to source to each of these predecessors. For initialization, there is a single path to go from the source to a vertex in column 0 (a successor of the source). then, you iterate over the columns and you add the count of `x` in the current column to each of its successors.
> 
> The method of Vincent do the same computation but avoids to build the DAG.

Nice job! This looks very good!



---

archive/issue_comments_481892.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2022-08-01T20:22:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34218#issuecomment-481892",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_089253.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2022-08-01T20:22:48Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/34218",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/34218#event-89253"
}
```
