# Issue 34724: echelonize() on RR matrices should not use "classical" algorithm

archive/issues_034487.json:
```json
{
    "assignees": [],
    "body": "From [sage-devel](https://groups.google.com/d/msgid/sage-devel/bec2d18e-8034-440c-8076-9a5e9ec93d2cn%40googlegroups.com):\n\nInverting RR-matrix\n\n```\nsage: m\n[-6.12323399573677e-17     -1.72508242466029]\n[    0.579682446302195  6.12323399573677e-17]\nsage: m.parent()\nFull MatrixSpace of 2 by 2 dense matrices over Real Field with 53 bits of precision\n```\n\nbecause it uses classical echelonize:\n\n```\nsage: A=m.augment(identity_matrix(RR,2))\nsage: A\n[-6.12323399573677e-17     -1.72508242466029      1.00000000000000     0.000000000000000]\n[    0.579682446302195  6.12323399573677e-17     0.000000000000000      1.00000000000000]\nsage: A.echelonize()\nsage: A\n[     1.00000000000000     0.000000000000000      4.00000000000000      1.72508242466029]\n[    0.000000000000000      1.00000000000000    -0.579682446302195 -6.12323399573676e-17]\n```\ninstead of \n\n```\nsage: A.echelonize(algorithm='scaled_partial_pivoting');A\n[     1.00000000000000     0.000000000000000  6.12323399573677e-17      1.72508242466029]\n[    0.000000000000000      1.00000000000000    -0.579682446302195 -6.12323399573677e-17]\n```\n\nInitial motivation : see this [sage-devel thread](https://groups.google.com/g/sage-devel/c/B_kE4m8qE1g), which exhibits a serious numerical error on matrix inversion.\n\nCC:  @mkoeppe\n\nBranch/Commit: **[`605968d`](https://github.com/sagemath/sagetrac-mirror/commit/605968da44842a6351f93f69dbe68088ac9d749c)**\n\nReviewer: **Nils Bruin**\n\nAuthor: **Dima Pasechnik**\n\nComponent: **linear algebra**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/34724_\n\n",
    "closed_at": "2022-11-15T23:43:19Z",
    "created_at": "2022-11-05T11:14:43Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20linear%20algebra",
        "https://github.com/sagemath/sage/labels/p%3A%202%20%E2%80%93%20critical",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.8",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "echelonize() on RR matrices should not use \"classical\" algorithm",
    "type": "issue",
    "updated_at": "2022-11-15T23:43:19Z",
    "url": "https://github.com/sagemath/sage/issues/34724",
    "user": "https://github.com/dimpase"
}
```
From [sage-devel](https://groups.google.com/d/msgid/sage-devel/bec2d18e-8034-440c-8076-9a5e9ec93d2cn%40googlegroups.com):

Inverting RR-matrix

```
sage: m
[-6.12323399573677e-17     -1.72508242466029]
[    0.579682446302195  6.12323399573677e-17]
sage: m.parent()
Full MatrixSpace of 2 by 2 dense matrices over Real Field with 53 bits of precision
```

because it uses classical echelonize:

```
sage: A=m.augment(identity_matrix(RR,2))
sage: A
[-6.12323399573677e-17     -1.72508242466029      1.00000000000000     0.000000000000000]
[    0.579682446302195  6.12323399573677e-17     0.000000000000000      1.00000000000000]
sage: A.echelonize()
sage: A
[     1.00000000000000     0.000000000000000      4.00000000000000      1.72508242466029]
[    0.000000000000000      1.00000000000000    -0.579682446302195 -6.12323399573676e-17]
```
instead of 

```
sage: A.echelonize(algorithm='scaled_partial_pivoting');A
[     1.00000000000000     0.000000000000000  6.12323399573677e-17      1.72508242466029]
[    0.000000000000000      1.00000000000000    -0.579682446302195 -6.12323399573677e-17]
```

Initial motivation : see this [sage-devel thread](https://groups.google.com/g/sage-devel/c/B_kE4m8qE1g), which exhibits a serious numerical error on matrix inversion.

CC:  @mkoeppe

Branch/Commit: **[`605968d`](https://github.com/sagemath/sagetrac-mirror/commit/605968da44842a6351f93f69dbe68088ac9d749c)**

Reviewer: **Nils Bruin**

Author: **Dima Pasechnik**

Component: **linear algebra**

_Issue created by migration from https://trac.sagemath.org/ticket/34724_





---

archive/issue_events_475397.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2022-11-05T11:14:43Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "milestone_number": null,
    "milestone_title": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475397"
}
```



---

archive/issue_events_475398.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2022-11-05T11:14:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20linear%20algebra",
    "label_color": "0000ff",
    "label_name": "c: linear algebra",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475398"
}
```



---

archive/issue_events_475399.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2022-11-05T11:14:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "label": "https://github.com/sagemath/sage/labels/p%3A%202%20%E2%80%93%20critical",
    "label_color": "ff7700",
    "label_name": "p: 2 \u2013 critical",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475399"
}
```



---

archive/issue_events_475400.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2022-11-05T11:14:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475400"
}
```



---

archive/issue_comments_560235.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -29,3 +29,5 @@\n [     1.00000000000000     0.000000000000000  6.12323399573677e-17      1.72508242466029]\n [    0.000000000000000      1.00000000000000    -0.579682446302195 -6.12323399573677e-17]\n ```\n+\n+Initial motivation : see this [sage-support thread](https://groups.google.com/g/sage-devel/c/B_kE4m8qE1g).\n``````\n",
    "created_at": "2022-11-05T12:01:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560235",
    "user": "https://github.com/EmmanuelCharpentier"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -29,3 +29,5 @@
 [     1.00000000000000     0.000000000000000  6.12323399573677e-17      1.72508242466029]
 [    0.000000000000000      1.00000000000000    -0.579682446302195 -6.12323399573677e-17]
 ```
+
+Initial motivation : see this [sage-support thread](https://groups.google.com/g/sage-devel/c/B_kE4m8qE1g).
``````




---

archive/issue_comments_560236.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -30,4 +30,4 @@\n [    0.000000000000000      1.00000000000000    -0.579682446302195 -6.12323399573677e-17]\n ```\n \n-Initial motivation : see this [sage-support thread](https://groups.google.com/g/sage-devel/c/B_kE4m8qE1g).\n+Initial motivation : see this [sage-devel thread](https://groups.google.com/g/sage-devel/c/B_kE4m8qE1g), which exhibits a serious numerical error on matrix inversion.\n``````\n",
    "created_at": "2022-11-05T12:03:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560236",
    "user": "https://github.com/EmmanuelCharpentier"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -30,4 +30,4 @@
 [    0.000000000000000      1.00000000000000    -0.579682446302195 -6.12323399573677e-17]
 ```
 
-Initial motivation : see this [sage-support thread](https://groups.google.com/g/sage-devel/c/B_kE4m8qE1g).
+Initial motivation : see this [sage-devel thread](https://groups.google.com/g/sage-devel/c/B_kE4m8qE1g), which exhibits a serious numerical error on matrix inversion.
``````




---

archive/issue_comments_560237.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nThis issue has been around and has spawned ad-hoc workarounds: [numerical_inverse](https://github.com/sagemath/sage/blob/c3028e74d80d7f8473b3e421ba6d54ab95f288f9/src/sage/schemes/riemann_surfaces/riemann_surface.py#L251). There may be more appropriate backends to tap into than the generic algorithms we have implemented, for particular implementations of some numerical types.\n\n(Of course even partial pivoting doesn't absolve you from thinking about numerical stability)",
    "created_at": "2022-11-06T00:34:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560237",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:3" align="right">comment:3</div>

This issue has been around and has spawned ad-hoc workarounds: [numerical_inverse](https://github.com/sagemath/sage/blob/c3028e74d80d7f8473b3e421ba6d54ab95f288f9/src/sage/schemes/riemann_surfaces/riemann_surface.py#L251). There may be more appropriate backends to tap into than the generic algorithms we have implemented, for particular implementations of some numerical types.

(Of course even partial pivoting doesn't absolve you from thinking about numerical stability)



---

archive/issue_comments_560238.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nReplying to [Nils Bruin](#comment:3):\n> This issue has been around and has spawned ad-hoc workarounds: [numerical_inverse](https://github.com/sagemath/sage/blob/c3028e74d80d7f8473b3e421ba6d54ab95f288f9/src/sage/schemes/riemann_surfaces/riemann_surface.py#L251). \n\n> There may be more appropriate backends to tap into than the generic algorithms we have implemented, for particular implementations of some numerical types.\n> \n> (Of course even partial pivoting doesn't absolve you from thinking about numerical stability)\n\nof course, but why such  sloppy coding in `echelonize()` ? It literally reads as \"we care about p-adics, the rest can go and die from numerical instability hell\" :-)\n\n`\u200bnumerical_inverse` must be dog-slow. (convert data to ball arithmetics, call mpmath to do LU, convert back...)\nIn general, one should do SVD for inverting, this seems to be the best for badly conditioned data.",
    "created_at": "2022-11-06T10:42:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560238",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:4" align="right">comment:4</div>

Replying to [Nils Bruin](#comment:3):
> This issue has been around and has spawned ad-hoc workarounds: [numerical_inverse](https://github.com/sagemath/sage/blob/c3028e74d80d7f8473b3e421ba6d54ab95f288f9/src/sage/schemes/riemann_surfaces/riemann_surface.py#L251). 

> There may be more appropriate backends to tap into than the generic algorithms we have implemented, for particular implementations of some numerical types.
> 
> (Of course even partial pivoting doesn't absolve you from thinking about numerical stability)

of course, but why such  sloppy coding in `echelonize()` ? It literally reads as "we care about p-adics, the rest can go and die from numerical instability hell" :-)

`​numerical_inverse` must be dog-slow. (convert data to ball arithmetics, call mpmath to do LU, convert back...)
In general, one should do SVD for inverting, this seems to be the best for badly conditioned data.



---

archive/issue_comments_560239.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nReplying to [Dima Pasechnik](#comment:4):\n> `\u200bnumerical_inverse` must be dog-slow. (convert data to ball arithmetics, call mpmath to do LU, convert back...)\n> In general, one should do SVD for inverting, this seems to be the best for badly conditioned data.\n\nWell ... the conversions are `O((n*p)^2) bitoperations for an `n x n` matrix of precision `p`, so it's not dominant. But constants matter of course :-). The code for conversion between mpmath and CC is relatively efficient because the conversion routine does know there's mpfr underneath for both.\n\nI think I ended up with and LUP decomposition because there was easy code accessible for that, whereas SVD was harder to find and/or required more complex interfacing to be written to arrive at an inverse. It's really more a tie-over until we have truly well-performing and fairly stable numerical inversion.\n\nI mainly pointed out the ad-hoc routine because I suspect these occur in other parts of sagemath as well. The current routine seems to have been stable enough (these matrices tend to not be super-badly conditioned; it's just that classical pivoting tends to be unstable even for well-conditioned matrices) and not a choke point for performance. But if we end up with something more reliable and more performant it will be worth adapting it!",
    "created_at": "2022-11-06T19:33:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560239",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:5" align="right">comment:5</div>

Replying to [Dima Pasechnik](#comment:4):
> `​numerical_inverse` must be dog-slow. (convert data to ball arithmetics, call mpmath to do LU, convert back...)
> In general, one should do SVD for inverting, this seems to be the best for badly conditioned data.

Well ... the conversions are `O((n*p)^2) bitoperations for an `n x n` matrix of precision `p`, so it's not dominant. But constants matter of course :-). The code for conversion between mpmath and CC is relatively efficient because the conversion routine does know there's mpfr underneath for both.

I think I ended up with and LUP decomposition because there was easy code accessible for that, whereas SVD was harder to find and/or required more complex interfacing to be written to arrive at an inverse. It's really more a tie-over until we have truly well-performing and fairly stable numerical inversion.

I mainly pointed out the ad-hoc routine because I suspect these occur in other parts of sagemath as well. The current routine seems to have been stable enough (these matrices tend to not be super-badly conditioned; it's just that classical pivoting tends to be unstable even for well-conditioned matrices) and not a choke point for performance. But if we end up with something more reliable and more performant it will be worth adapting it!



---

archive/issue_comments_560240.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nanyhow, what's wrong with doing\n\n```diff\n--- a/src/sage/matrix/matrix2.pyx\n+++ b/src/sage/matrix/matrix2.pyx\n@@ -7617,7 +7617,11 @@ cdef class Matrix(Matrix1):\n                 except (AttributeError, TypeError):\n                     algorithm = 'scaled_partial_pivoting_valuation'\n             else:\n-                algorithm = 'classical'\n+                try:\n+                    self.base_ring(1/2).abs()\n+                    algorithm = 'scaled_partial_pivoting'\n+                except (AttributeError, ArithmeticError, TypeError):\n+                    algorithm = 'classical'\n         try:\n             if self.base_ring() in _Fields:\n                 if algorithm in ['classical', 'partial_pivoting', 'scaled_partial_pivoting', 'scaled_partial_pivoting_valuation']:\n```\n\nThen for the case at hand we have sanity:\n\n```python\nsage: m=matrix(RR,[[-6.12323399573677e-17, -1.72508242466029], [ 0.579682446302195,  6.12323399573677e-17]])\nsage: ~m*m\n[     1.00000000000000  1.23259516440783e-32]\n[-6.16297582203915e-33      1.00000000000000]\nsage: (~m*m).norm()\n1.0\n```\nas opposed to, in the unpatched case,\n\n```python\nsage: ~m\n[     2.00000000000000      1.72508242466029]\n[   -0.579682446302196 -6.12323399573678e-17]\nsage: (~m*m).norm()\n3.719050672118565\n```",
    "created_at": "2022-11-07T12:13:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560240",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:6" align="right">comment:6</div>

anyhow, what's wrong with doing

```diff
--- a/src/sage/matrix/matrix2.pyx
+++ b/src/sage/matrix/matrix2.pyx
@@ -7617,7 +7617,11 @@ cdef class Matrix(Matrix1):
                 except (AttributeError, TypeError):
                     algorithm = 'scaled_partial_pivoting_valuation'
             else:
-                algorithm = 'classical'
+                try:
+                    self.base_ring(1/2).abs()
+                    algorithm = 'scaled_partial_pivoting'
+                except (AttributeError, ArithmeticError, TypeError):
+                    algorithm = 'classical'
         try:
             if self.base_ring() in _Fields:
                 if algorithm in ['classical', 'partial_pivoting', 'scaled_partial_pivoting', 'scaled_partial_pivoting_valuation']:
```

Then for the case at hand we have sanity:

```python
sage: m=matrix(RR,[[-6.12323399573677e-17, -1.72508242466029], [ 0.579682446302195,  6.12323399573677e-17]])
sage: ~m*m
[     1.00000000000000  1.23259516440783e-32]
[-6.16297582203915e-33      1.00000000000000]
sage: (~m*m).norm()
1.0
```
as opposed to, in the unpatched case,

```python
sage: ~m
[     2.00000000000000      1.72508242466029]
[   -0.579682446302196 -6.12323399573678e-17]
sage: (~m*m).norm()
3.719050672118565
```



---

archive/issue_comments_560241.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nReplying to [Dima Pasechnik](#comment:6):\n> anyhow, what's wrong with doing\n> \n> ```diff\n> +                try:\n> +                    self.base_ring(1/2).abs()\n> +                    algorithm = 'scaled_partial_pivoting'\n> +                except (AttributeError, ArithmeticError, TypeError):\n> +                    algorithm = 'classical'\n> ```\n\nAlternatives I can think of:\n- use category framework on the base ring to find out what to do (I wasn't able to find an apprpriate property there\n- have a property or a method on the parent that provides a default -- if that fails, fall back on the old strategy.\n- have a subclassing mechanism to provide appropriate echelonization approaches (the category framework with its \"axiom\"s does that, but I'm not sure if that's an appropriate mechanism for matrices).\n\nI would lean to the second approach as striking a reasonable balance between explicit intent in the code and avoiding overengineering. In this case, `RealField` and `ComplexField` would grow a method `_matrix_pivoting_strategy` that just returns `scaled_partial_pivoting`. Introduction of such default preference expressions could grow slowly, as needed and it limits behaviour changes to those cases where it's explicitly desired.\n\nIt would be appealing to communicate an actual callable instead of a string indicating a choice elsewhere, but that might complicate the design and introduce circular imports.",
    "created_at": "2022-11-07T16:51:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560241",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:7" align="right">comment:7</div>

Replying to [Dima Pasechnik](#comment:6):
> anyhow, what's wrong with doing
> 
> ```diff
> +                try:
> +                    self.base_ring(1/2).abs()
> +                    algorithm = 'scaled_partial_pivoting'
> +                except (AttributeError, ArithmeticError, TypeError):
> +                    algorithm = 'classical'
> ```

Alternatives I can think of:
- use category framework on the base ring to find out what to do (I wasn't able to find an apprpriate property there
- have a property or a method on the parent that provides a default -- if that fails, fall back on the old strategy.
- have a subclassing mechanism to provide appropriate echelonization approaches (the category framework with its "axiom"s does that, but I'm not sure if that's an appropriate mechanism for matrices).

I would lean to the second approach as striking a reasonable balance between explicit intent in the code and avoiding overengineering. In this case, `RealField` and `ComplexField` would grow a method `_matrix_pivoting_strategy` that just returns `scaled_partial_pivoting`. Introduction of such default preference expressions could grow slowly, as needed and it limits behaviour changes to those cases where it's explicitly desired.

It would be appealing to communicate an actual callable instead of a string indicating a choice elsewhere, but that might complicate the design and introduce circular imports.



---

archive/issue_comments_560242.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nWe can improve the heuristic by dispatching on `self.base_ring().is_exact()` - if true, we do `classical`, as before, otherwise `scaled_partial_pivoting`. In particular this will preserve \nthe current setting for `QQ`, etc.",
    "created_at": "2022-11-07T18:04:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560242",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:8" align="right">comment:8</div>

We can improve the heuristic by dispatching on `self.base_ring().is_exact()` - if true, we do `classical`, as before, otherwise `scaled_partial_pivoting`. In particular this will preserve 
the current setting for `QQ`, etc.



---

archive/issue_comments_560243.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nReplying to [Dima Pasechnik](#comment:8):\n> We can improve the heuristic by dispatching on `self.base_ring().is_exact()` - if true, we do `classical`, as before, otherwise `scaled_partial_pivoting`. In particular this will preserve \n> the current setting for `QQ`, etc.\n\nAh yes, that should be a clear improvement over the status quo.\n\nOf course, even over QQ, a classical row reduction shouldn't be the default. Some kind of multimodular approach should have much better performance, but would need care to be properly implemented. So at some point we probably need more extensive subclassing of matrix classes, with their own echelon_form implementations.\n\n**EDIT:** That subclassing has already happened. `echelonize` on a matrix over the rationals comes from `sage.matrix.matrix_rational_dense`, whereas the one over RR comes from `sage.matrix.matrix2`; same for `RealDoubleField()`. So to some extent, we are running into these problems because we didn't properly subclass matrix spaces for `RealField`, `ComplexField`, etc. As a result, the change-of-default would not affect matrices over QQ. Still, it's good to be conservative in changing the default, I think.\n\nAccording to mpfr's page, https://www.alglib.net/ for real and https://eigen.tuxfamily.org/ for complex would be pre-existing libraries to tap into. One would think having some decent multiprecision linear algebra would be worthwhile? Perhaps a GSOC project? Not a very exciting one ...",
    "created_at": "2022-11-07T20:52:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560243",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:9" align="right">comment:9</div>

Replying to [Dima Pasechnik](#comment:8):
> We can improve the heuristic by dispatching on `self.base_ring().is_exact()` - if true, we do `classical`, as before, otherwise `scaled_partial_pivoting`. In particular this will preserve 
> the current setting for `QQ`, etc.

Ah yes, that should be a clear improvement over the status quo.

Of course, even over QQ, a classical row reduction shouldn't be the default. Some kind of multimodular approach should have much better performance, but would need care to be properly implemented. So at some point we probably need more extensive subclassing of matrix classes, with their own echelon_form implementations.

**EDIT:** That subclassing has already happened. `echelonize` on a matrix over the rationals comes from `sage.matrix.matrix_rational_dense`, whereas the one over RR comes from `sage.matrix.matrix2`; same for `RealDoubleField()`. So to some extent, we are running into these problems because we didn't properly subclass matrix spaces for `RealField`, `ComplexField`, etc. As a result, the change-of-default would not affect matrices over QQ. Still, it's good to be conservative in changing the default, I think.

According to mpfr's page, https://www.alglib.net/ for real and https://eigen.tuxfamily.org/ for complex would be pre-existing libraries to tap into. One would think having some decent multiprecision linear algebra would be worthwhile? Perhaps a GSOC project? Not a very exciting one ...



---

archive/issue_comments_560244.json:
```json
{
    "body": "Branch: **[u/dimpase/matrix/fix_echelonize](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/matrix/fix_echelonize)**",
    "created_at": "2022-11-08T09:45:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560244",
    "user": "https://github.com/dimpase"
}
```

Branch: **[u/dimpase/matrix/fix_echelonize](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/matrix/fix_echelonize)**



---

archive/issue_comments_560245.json:
```json
{
    "body": "Author: **Dima Pasechnik**",
    "created_at": "2022-11-08T09:45:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560245",
    "user": "https://github.com/dimpase"
}
```

Author: **Dima Pasechnik**



---

archive/issue_comments_560246.json:
```json
{
    "body": "Commit: **[`d6a834a`](https://github.com/sagemath/sagetrac-mirror/commit/d6a834a1f1d3cd377b722bcbec97bfc1b468e252)**",
    "created_at": "2022-11-08T09:45:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560246",
    "user": "https://github.com/dimpase"
}
```

Commit: **[`d6a834a`](https://github.com/sagemath/sagetrac-mirror/commit/d6a834a1f1d3cd377b722bcbec97bfc1b468e252)**



---

archive/issue_comments_560247.json:
```json
{
    "body": "<div id=\"comment:10\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d6a834a1f1d3cd377b722bcbec97bfc1b468e252\"><code>d6a834a</code></a></td><td><code>use an appropriate alogorithm to echelonize inexact matrices</code></td></tr></table>\n",
    "created_at": "2022-11-08T09:45:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560247",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:10"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d6a834a1f1d3cd377b722bcbec97bfc1b468e252"><code>d6a834a</code></a></td><td><code>use an appropriate alogorithm to echelonize inexact matrices</code></td></tr></table>




---

archive/issue_comments_560248.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nIt's not clear how to deal with SR matrices (SR is not exact, but we can only do classic echelonize on it) like this, as SR is split out to its own package, and\nso checking whether the base ring is SR directly doesn't seem to be possible, due to this structure - as importing SR is no good.\n\nSo further subclassing (?) seems hard to aviod - any ideas?",
    "created_at": "2022-11-08T12:57:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560248",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:11" align="right">comment:11</div>

It's not clear how to deal with SR matrices (SR is not exact, but we can only do classic echelonize on it) like this, as SR is split out to its own package, and
so checking whether the base ring is SR directly doesn't seem to be possible, due to this structure - as importing SR is no good.

So further subclassing (?) seems hard to aviod - any ideas?



---

archive/issue_events_475401.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2022-11-08T12:57:04Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475401"
}
```



---

archive/issue_comments_560249.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nwhile working on it I found a juicy test bug in `pseudoinverse` for an `RR` matrix `M`.\nThe pseudoinverse in the docstring, computed with `M.pseudoinverse(algorithm=\"exact\")`,\nis very bad quality, compared to `M.pseudoinverse(algorithm=\"numpy\")`. I'm changing this test to a meaningful one.",
    "created_at": "2022-11-08T13:54:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560249",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:12" align="right">comment:12</div>

while working on it I found a juicy test bug in `pseudoinverse` for an `RR` matrix `M`.
The pseudoinverse in the docstring, computed with `M.pseudoinverse(algorithm="exact")`,
is very bad quality, compared to `M.pseudoinverse(algorithm="numpy")`. I'm changing this test to a meaningful one.



---

archive/issue_comments_560250.json:
```json
{
    "body": "Changed commit from **[`d6a834a`](https://github.com/sagemath/sagetrac-mirror/commit/d6a834a1f1d3cd377b722bcbec97bfc1b468e252)** to **[`24299ce`](https://github.com/sagemath/sagetrac-mirror/commit/24299ced2b38daef48a2002d24c1766c80d2d0e9)**",
    "created_at": "2022-11-08T16:27:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560250",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`d6a834a`](https://github.com/sagemath/sagetrac-mirror/commit/d6a834a1f1d3cd377b722bcbec97bfc1b468e252)** to **[`24299ce`](https://github.com/sagemath/sagetrac-mirror/commit/24299ced2b38daef48a2002d24c1766c80d2d0e9)**



---

archive/issue_comments_560251.json:
```json
{
    "body": "<div id=\"comment:13\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/24299ced2b38daef48a2002d24c1766c80d2d0e9\"><code>24299ce</code></a></td><td><code>work around SR being inexact, fix a silly doctest</code></td></tr></table>\n",
    "created_at": "2022-11-08T16:27:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560251",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:13"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/24299ced2b38daef48a2002d24c1766c80d2d0e9"><code>24299ce</code></a></td><td><code>work around SR being inexact, fix a silly doctest</code></td></tr></table>




---

archive/issue_comments_560252.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nReplying to [Dima Pasechnik](#comment:11):\n> So further subclassing (?) seems hard to aviod - any ideas?\n\nFor SR the subclassing has already happened:\n\n```\nsage: M=matrix(SR,2,2,[1,0,0,1])\nsage: type(M)\n<class 'sage.matrix.matrix_symbolic_dense.Matrix_symbolic_dense'>\n```\nso a stub `echelonize` implementation on `Matrix_symbolic_dense` with a different default and then just chains to the `echelonize` on super would do the trick.\n\nAlternatively, we could have a class attribute on matrix types that gives the default echelonization algorithm and then just inherit or override it on the subclass.\n\nFor RR and CC the subclassing hasn't happened yet, so there we don't have a chance of overriding the default. But then the `is_exact()` heuristic is pretty good.\n\nI think most performant matrix types would need an `echelonize` that is specific to the type of matrix, so I expect most of them to NOT chain. Indeed, for matrices over QQ there's a specific routine with its specific slew of algorithms and defaults.\n\nI'd say a straightforward guide going forward is: if you need `echelonize` to behave differently (for instance, make it have a different default), then override it and possibly chain into super if you don't mind the penalty.\n\nThe generic default depending on `is_exact` is just a matter of being nice and reducing the cases where an override is required (in this case it delays the need to subclass for `RR, CC, RealBall, ComplexBall, RealDouble` etc.)\n\nThe alternative of having a class attribute encoding the default is not very robust, especially in the face of possible method overrides on subclasses. I dislike promoting solutions that increase call depth, but in this case I think an extra layer of indirection using exactly the tools that python offers for it gives a clean and at the moment fairly easily implemented solution.",
    "created_at": "2022-11-08T16:28:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560252",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:14" align="right">comment:14</div>

Replying to [Dima Pasechnik](#comment:11):
> So further subclassing (?) seems hard to aviod - any ideas?

For SR the subclassing has already happened:

```
sage: M=matrix(SR,2,2,[1,0,0,1])
sage: type(M)
<class 'sage.matrix.matrix_symbolic_dense.Matrix_symbolic_dense'>
```
so a stub `echelonize` implementation on `Matrix_symbolic_dense` with a different default and then just chains to the `echelonize` on super would do the trick.

Alternatively, we could have a class attribute on matrix types that gives the default echelonization algorithm and then just inherit or override it on the subclass.

For RR and CC the subclassing hasn't happened yet, so there we don't have a chance of overriding the default. But then the `is_exact()` heuristic is pretty good.

I think most performant matrix types would need an `echelonize` that is specific to the type of matrix, so I expect most of them to NOT chain. Indeed, for matrices over QQ there's a specific routine with its specific slew of algorithms and defaults.

I'd say a straightforward guide going forward is: if you need `echelonize` to behave differently (for instance, make it have a different default), then override it and possibly chain into super if you don't mind the penalty.

The generic default depending on `is_exact` is just a matter of being nice and reducing the cases where an override is required (in this case it delays the need to subclass for `RR, CC, RealBall, ComplexBall, RealDouble` etc.)

The alternative of having a class attribute encoding the default is not very robust, especially in the face of possible method overrides on subclasses. I dislike promoting solutions that increase call depth, but in this case I think an extra layer of indirection using exactly the tools that python offers for it gives a clean and at the moment fairly easily implemented solution.



---

archive/issue_comments_560253.json:
```json
{
    "body": "Changed commit from **[`24299ce`](https://github.com/sagemath/sagetrac-mirror/commit/24299ced2b38daef48a2002d24c1766c80d2d0e9)** to **[`cce62c2`](https://github.com/sagemath/sagetrac-mirror/commit/cce62c225276687c4f9e331688bd638085e2dbcd)**",
    "created_at": "2022-11-08T17:42:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560253",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`24299ce`](https://github.com/sagemath/sagetrac-mirror/commit/24299ced2b38daef48a2002d24c1766c80d2d0e9)** to **[`cce62c2`](https://github.com/sagemath/sagetrac-mirror/commit/cce62c225276687c4f9e331688bd638085e2dbcd)**



---

archive/issue_comments_560254.json:
```json
{
    "body": "<div id=\"comment:15\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cce62c225276687c4f9e331688bd638085e2dbcd\"><code>cce62c2</code></a></td><td><code>use subclassed Matrix_symbolic_dense</code></td></tr></table>\n",
    "created_at": "2022-11-08T17:42:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560254",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:15"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cce62c225276687c4f9e331688bd638085e2dbcd"><code>cce62c2</code></a></td><td><code>use subclassed Matrix_symbolic_dense</code></td></tr></table>




---

archive/issue_comments_560255.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\n> so a stub echelonize implementation on Matrix_symbolic_dense with a different default and then just chains to the echelonize on super would do the trick. \n\nDoes `cce62c2` do this? It seems, yes.",
    "created_at": "2022-11-08T17:43:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560255",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:16" align="right">comment:16</div>

> so a stub echelonize implementation on Matrix_symbolic_dense with a different default and then just chains to the echelonize on super would do the trick. 

Does `cce62c2` do this? It seems, yes.



---

archive/issue_comments_560256.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nThere is numerical noise in tests, mostly pointing at better quality of linear algebra.\nE.g. in `riemann_surface` there is `numerical_inverse`, and the doctest saying\n\n```\nsage: max(abs(c) for c in (C^(-1)*C-C^0).list()) < 1e-10\nFalse\n```\n\nBut now it's almost as good and `numerical_inverse`:\n\n```\nsage: max(abs(c) for c in (numerical_inverse(C)*C-C^0).list())\n2.37143742013377e-16\nsage: max(abs(c) for c in (C^(-1)*C-C^0).list())\n4.71027737605132e-16\n```",
    "created_at": "2022-11-08T17:57:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560256",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:17" align="right">comment:17</div>

There is numerical noise in tests, mostly pointing at better quality of linear algebra.
E.g. in `riemann_surface` there is `numerical_inverse`, and the doctest saying

```
sage: max(abs(c) for c in (C^(-1)*C-C^0).list()) < 1e-10
False
```

But now it's almost as good and `numerical_inverse`:

```
sage: max(abs(c) for c in (numerical_inverse(C)*C-C^0).list())
2.37143742013377e-16
sage: max(abs(c) for c in (C^(-1)*C-C^0).list())
4.71027737605132e-16
```



---

archive/issue_comments_560257.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nI still need to add fixes for numerical noise - are you happy with the fix otherwise?",
    "created_at": "2022-11-08T18:00:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560257",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:18" align="right">comment:18</div>

I still need to add fixes for numerical noise - are you happy with the fix otherwise?



---

archive/issue_events_475402.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2022-11-08T18:00:27Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475402"
}
```



---

archive/issue_events_475403.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2022-11-08T18:00:27Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475403"
}
```



---

archive/issue_comments_560258.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nReplying to [Dima Pasechnik](#comment:16):\n> > so a stub echelonize implementation on Matrix_symbolic_dense with a different default and then just chains to the echelonize on super would do the trick. \n\n> \n> Does `cce62c2` do this? It seems, yes.\n\nNot quite. The chain call should probably respect the `algorithm` parameter by passing `algorithm=algorithm`. If you think it shouldn't be possible to select algorithm on symbolic variables, then the parameter `algorithm` should be removed from the signature. Then passing the fixed choice to super is good of course.",
    "created_at": "2022-11-08T18:03:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560258",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:19" align="right">comment:19</div>

Replying to [Dima Pasechnik](#comment:16):
> > so a stub echelonize implementation on Matrix_symbolic_dense with a different default and then just chains to the echelonize on super would do the trick. 

> 
> Does `cce62c2` do this? It seems, yes.

Not quite. The chain call should probably respect the `algorithm` parameter by passing `algorithm=algorithm`. If you think it shouldn't be possible to select algorithm on symbolic variables, then the parameter `algorithm` should be removed from the signature. Then passing the fixed choice to super is good of course.



---

archive/issue_comments_560259.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nReplying to [Dima Pasechnik](#comment:18):\n> I still need to add fixes for numerical noise - are you happy with the fix otherwise?\n\nYes! For comparing to numerical_inverse: based on some randomly generated matrices with complex numbers: it's significantly faster for many matrices; I haven't seen it slower; and the accuracy, while not exactly the same, is similar (sometimes a bit better, sometimes a bit worse, but it looks like the normal numerical noise one would expect).\n\nThis is a nice improvement. Had I read the inversion routine and that it just uses `echelonize`, and that there is a pivoting strategy for it, I would have used that rather than interface with arb.",
    "created_at": "2022-11-08T20:50:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560259",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:20" align="right">comment:20</div>

Replying to [Dima Pasechnik](#comment:18):
> I still need to add fixes for numerical noise - are you happy with the fix otherwise?

Yes! For comparing to numerical_inverse: based on some randomly generated matrices with complex numbers: it's significantly faster for many matrices; I haven't seen it slower; and the accuracy, while not exactly the same, is similar (sometimes a bit better, sometimes a bit worse, but it looks like the normal numerical noise one would expect).

This is a nice improvement. Had I read the inversion routine and that it just uses `echelonize`, and that there is a pivoting strategy for it, I would have used that rather than interface with arb.



---

archive/issue_comments_560260.json:
```json
{
    "body": "Changed commit from **[`cce62c2`](https://github.com/sagemath/sagetrac-mirror/commit/cce62c225276687c4f9e331688bd638085e2dbcd)** to **[`0c7da0a`](https://github.com/sagemath/sagetrac-mirror/commit/0c7da0a8b7a7199c6a1e3247cf8d476e5bdb3478)**",
    "created_at": "2022-11-09T13:37:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560260",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`cce62c2`](https://github.com/sagemath/sagetrac-mirror/commit/cce62c225276687c4f9e331688bd638085e2dbcd)** to **[`0c7da0a`](https://github.com/sagemath/sagetrac-mirror/commit/0c7da0a8b7a7199c6a1e3247cf8d476e5bdb3478)**



---

archive/issue_comments_560261.json:
```json
{
    "body": "<div id=\"comment:21\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0c7da0a8b7a7199c6a1e3247cf8d476e5bdb3478\"><code>0c7da0a</code></a></td><td><code>hardcode \"classical\" algorithm, add a doctest</code></td></tr></table>\n",
    "created_at": "2022-11-09T13:37:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560261",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:21"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0c7da0a8b7a7199c6a1e3247cf8d476e5bdb3478"><code>0c7da0a</code></a></td><td><code>hardcode "classical" algorithm, add a doctest</code></td></tr></table>




---

archive/issue_comments_560262.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nHow would one do subclassing for `ComplexField`, `RealField`, etc? Would it need something like [PEP 646 \u2013 Variadic Generics](https://peps.python.org/pep-0646/) ?",
    "created_at": "2022-11-09T13:42:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560262",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:22" align="right">comment:22</div>

How would one do subclassing for `ComplexField`, `RealField`, etc? Would it need something like [PEP 646 – Variadic Generics](https://peps.python.org/pep-0646/) ?



---

archive/issue_comments_560263.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nReplying to [Dima Pasechnik](#comment:22):\n> How would one do subclassing for `ComplexField`, `RealField`, etc? Would it need something like [PEP 646 \u2013 Variadic Generics](https://peps.python.org/pep-0646/) ?\n\nI would expect that a high-performance version would not be generic at all, but hardcoded instead: while some current generic matrix operations are \"in-place\", they cause a lot of memory churn due to our mpfr wrappers having an extra level of indirection. The lower-level arithmetic routines of mpfr can work truly in-place. Especially for shorter length precision (remember we use mpfr for 53 bit precision as well!).\n\nSo I would expect that a dedicated matrix type for `RealField` matrices would have the bitstrings of the entries stored contiguously, and something similar for `ComplexField`. How that would work for ball fields I don't know, but I imagine something similar is possible (I don't know if that would be worth it, though). I did some of that on an ad-hoc basis in [RiemannTheta](https://github.com/nbruin/RiemannTheta), although it's really more arrays, vectors and inner products there -- I didn't really need linear algebra.\n\nYou could probably template that code a bit, but it would probably be more on the level of cython (where you can use C++ templates if I'm not mistaken) in order to interface efficiently with mpfr.\n\nIn terms of what would be minimally required: just subclass a class \"matrix over inexact archimedian normed field\" or something like that and put appropriate functionality there. It would basically be coded in the same generic way that the current generic_matrix is implemented, just with appropriate algorithm choices (and SVD!!!). That would be more for functionality support than for efficiency gains.",
    "created_at": "2022-11-09T23:16:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560263",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:23" align="right">comment:23</div>

Replying to [Dima Pasechnik](#comment:22):
> How would one do subclassing for `ComplexField`, `RealField`, etc? Would it need something like [PEP 646 – Variadic Generics](https://peps.python.org/pep-0646/) ?

I would expect that a high-performance version would not be generic at all, but hardcoded instead: while some current generic matrix operations are "in-place", they cause a lot of memory churn due to our mpfr wrappers having an extra level of indirection. The lower-level arithmetic routines of mpfr can work truly in-place. Especially for shorter length precision (remember we use mpfr for 53 bit precision as well!).

So I would expect that a dedicated matrix type for `RealField` matrices would have the bitstrings of the entries stored contiguously, and something similar for `ComplexField`. How that would work for ball fields I don't know, but I imagine something similar is possible (I don't know if that would be worth it, though). I did some of that on an ad-hoc basis in [RiemannTheta](https://github.com/nbruin/RiemannTheta), although it's really more arrays, vectors and inner products there -- I didn't really need linear algebra.

You could probably template that code a bit, but it would probably be more on the level of cython (where you can use C++ templates if I'm not mistaken) in order to interface efficiently with mpfr.

In terms of what would be minimally required: just subclass a class "matrix over inexact archimedian normed field" or something like that and put appropriate functionality there. It would basically be coded in the same generic way that the current generic_matrix is implemented, just with appropriate algorithm choices (and SVD!!!). That would be more for functionality support than for efficiency gains.



---

archive/issue_comments_560264.json:
```json
{
    "body": "Changed commit from **[`0c7da0a`](https://github.com/sagemath/sagetrac-mirror/commit/0c7da0a8b7a7199c6a1e3247cf8d476e5bdb3478)** to **[`605968d`](https://github.com/sagemath/sagetrac-mirror/commit/605968da44842a6351f93f69dbe68088ac9d749c)**",
    "created_at": "2022-11-10T17:08:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560264",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`0c7da0a`](https://github.com/sagemath/sagetrac-mirror/commit/0c7da0a8b7a7199c6a1e3247cf8d476e5bdb3478)** to **[`605968d`](https://github.com/sagemath/sagetrac-mirror/commit/605968da44842a6351f93f69dbe68088ac9d749c)**



---

archive/issue_comments_560265.json:
```json
{
    "body": "<div id=\"comment:24\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/605968da44842a6351f93f69dbe68088ac9d749c\"><code>605968d</code></a></td><td><code>numerical noise fixes</code></td></tr></table>\n",
    "created_at": "2022-11-10T17:08:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560265",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:24"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/605968da44842a6351f93f69dbe68088ac9d749c"><code>605968d</code></a></td><td><code>numerical noise fixes</code></td></tr></table>




---

archive/issue_comments_560266.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nReplying to [Nils Bruin](#comment:23):\n[...]\n> How that would work for ball fields I don't know,\n\nAFAIK, `arb` has quite a bit of linear algebra nowadays\n(I guess, these routines are on boxed data, to make them universal, but still...)\n\nAnyhow, this ticket is now ready for review.",
    "created_at": "2022-11-10T17:12:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560266",
    "user": "https://github.com/dimpase"
}
```

<div id="comment:25" align="right">comment:25</div>

Replying to [Nils Bruin](#comment:23):
[...]
> How that would work for ball fields I don't know,

AFAIK, `arb` has quite a bit of linear algebra nowadays
(I guess, these routines are on boxed data, to make them universal, but still...)

Anyhow, this ticket is now ready for review.



---

archive/issue_comments_560267.json:
```json
{
    "body": "Reviewer: **Nils Bruin**",
    "created_at": "2022-11-10T17:12:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560267",
    "user": "https://github.com/dimpase"
}
```

Reviewer: **Nils Bruin**



---

archive/issue_comments_560268.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nReplying to [Dima Pasechnik](#comment:25):\n> Replying to [Nils Bruin](#comment:23):\n> [...]\n> > How that would work for ball fields I don't know,\n\n> AFAIK, `arb` has quite a bit of linear algebra nowadays\n> (I guess, these routines are on boxed data, to make them universal, but still...)\n\nIndeed! Some of it may have been wrapped already in `matrix_complex_ball_dense.pyx`, which I just found exists...\n\n> \n> Anyhow, this ticket is now ready for review.",
    "created_at": "2022-11-10T22:20:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560268",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:26" align="right">comment:26</div>

Replying to [Dima Pasechnik](#comment:25):
> Replying to [Nils Bruin](#comment:23):
> [...]
> > How that would work for ball fields I don't know,

> AFAIK, `arb` has quite a bit of linear algebra nowadays
> (I guess, these routines are on boxed data, to make them universal, but still...)

Indeed! Some of it may have been wrapped already in `matrix_complex_ball_dense.pyx`, which I just found exists...

> 
> Anyhow, this ticket is now ready for review.



---

archive/issue_comments_560269.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nLGTM",
    "created_at": "2022-11-10T22:33:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560269",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:27" align="right">comment:27</div>

LGTM



---

archive/issue_events_475404.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2022-11-10T22:33:03Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475404"
}
```



---

archive/issue_events_475405.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2022-11-10T22:33:03Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475405"
}
```



---

archive/issue_comments_560270.json:
```json
{
    "body": "Changed branch from **[u/dimpase/matrix/fix_echelonize](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/matrix/fix_echelonize)** to **[`605968d`](https://github.com/sagemath/sagetrac-mirror/commit/605968da44842a6351f93f69dbe68088ac9d749c)**",
    "created_at": "2022-11-15T23:43:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34724#issuecomment-560270",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[u/dimpase/matrix/fix_echelonize](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/matrix/fix_echelonize)** to **[`605968d`](https://github.com/sagemath/sagetrac-mirror/commit/605968da44842a6351f93f69dbe68088ac9d749c)**



---

archive/issue_events_475406.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2022-11-15T23:43:19Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475406"
}
```



---

archive/issue_events_475407.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "b641e6f01666f2913f885de0a832655b079ffe5a",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2022-11-15T23:43:19Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/34724",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34724#event-475407"
}
```
