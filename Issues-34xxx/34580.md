# Issue 34580: Faster implementations of combinations ranking / unranking

archive/issues_034343.json:
```json
{
    "body": "This patch implements several tweaks to the current algorithms for ranking and unranking combinations.\nIn chronological (commit) order:\n\n**Re-implement the `from_rank` function**\n\nIt is based on the paper following the pre-print on which the previous implementation was based. The new algorithm is Algorithm 6 (page 20) in https://www.mdpi.com/1999-4893/14/3/97 (I'm an author).\n\nThe algorithm is simpler (less lines of code and branching) and a little bit faster.\n\nIn addition\n- it removes some redundant checks at the beginning of the function;\n- and it ensures the check that `0 <= rank < binomial(n, k)` happens **before** the special case:\n\n```\nif k == 0:\n    return ()\n```\nThere is a bug with the current implementation where you can call\n`from_rank(dummy_rank, n, 0)` and you will always get `from_rank(0, n, 0)`.\n\nVery quick performance comparison:\n\nBefore the patch:\n\n```sage\nsage: set_random_seed(0)\nsage: test_args = [(randint(0, binomial(n, n // 2) - 1), n, n // 2) for n in [100, 1000, 10000, 50000, 100000]]\nsage: from sage.combinat.combination import from_rank\nsage: %time _ = from_rank(*test_args[0])\nCPU times: user 485 \u00b5s, sys: 20 \u00b5s, total: 505 \u00b5s\nWall time: 510 \u00b5s\nsage: %time _ = from_rank(*test_args[1])\nCPU times: user 3.85 ms, sys: 24 \u00b5s, total: 3.87 ms\nWall time: 3.9 ms\nsage: %time _ = from_rank(*test_args[2])\nCPU times: user 47.5 ms, sys: 53 \u00b5s, total: 47.5 ms\nWall time: 46.7 ms\nsage: %time _ = from_rank(*test_args[3])\nCPU times: user 329 ms, sys: 142 \u00b5s, total: 330 ms\nWall time: 335 ms\nsage: %time _ = from_rank(*test_args[4])\nCPU times: user 890 ms, sys: 132 \u00b5s, total: 890 ms\nWall time: 890 ms\n```\n\nAfter the patch:\n\n```sage\nsage: set_random_seed(0)\nsage: test_args = [(randint(0, binomial(n, n // 2) - 1), n, n // 2) for n in [100, 1000, 10000, 50000, 100000]]\nsage: from sage.combinat.combination import from_rank\nsage: %time _ = from_rank(*test_args[0])\nCPU times: user 440 \u00b5s, sys: 42 \u00b5s, total: 482 \u00b5s\nWall time: 488 \u00b5s\nsage: %time _ = from_rank(*test_args[1])\nCPU times: user 2.43 ms, sys: 0 ns, total: 2.43 ms\nWall time: 2.73 ms\nsage: %time _ = from_rank(*test_args[2])\nCPU times: user 26.9 ms, sys: 3.04 ms, total: 30 ms\nWall time: 29.6 ms\nsage: %time _ = from_rank(*test_args[3])\nCPU times: user 198 ms, sys: 116 \u00b5s, total: 198 ms\nWall time: 198 ms\nsage: %time _ = from_rank(*test_args[4])\nCPU times: user 573 ms, sys: 600 \u00b5s, total: 573 ms\nWall time: 573 ms\n```\n\n**2. We increase the performance of Combinations_set.unrank**\n\nWhereas `from_rank` unranks a combination of `range(n)` of given size `k`, the `Combinations_set.unrank` function unranks from the set of all sub-sets of `range(n)`.\nIn order to find the right value of `k` to pass to `from_rank` it has to do some work with binomial coefficients. We accelerate this work by avoiding repeated calls to the `binomial` function.\n\nBefore:\n\n```sage\nsage: set_random_seed(0)\nsage: %timeit _ = Combinations(range(100)).unrank(randint(0, 2 ** 100 - 1))\n412 \u00b5s \u00b1 15.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\nsage: %timeit _ = Combinations(range(1000)).unrank(randint(0, 2 ** 1000 - 1))\n7.68 ms \u00b1 92.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\nsage: %timeit _ = Combinations(range(10000)).unrank(randint(0, 2 ** 10000 - 1))\n960 ms \u00b1 22.4 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\nsage: %timeit _ = Combinations(range(50000)).unrank(randint(0, 2 ** 50000 - 1))\n51.6 s \u00b1 637 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\nAfter:\n\n```sage\nsage: set_random_seed(0)\nsage: %timeit _ = Combinations(range(100)).unrank(randint(0, 2 ** 100 - 1))\n288 \u00b5s \u00b1 9.18 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\nsage: %timeit _ = Combinations(range(1000)).unrank(randint(0, 2 ** 1000 - 1))\n3.14 ms \u00b1 67.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\nsage: %timeit _ = Combinations(range(10000)).unrank(randint(0, 2 ** 10000 - 1))\n38.7 ms \u00b1 755 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\nsage: %timeit _ = Combinations(range(50000)).unrank(randint(0, 2 ** 50000 - 1))\n311 ms \u00b1 6.36 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\n**3. Do the same for ranking**\n\nWe use a faster algorithm for the `rank` function.\n\nBefore:\n\n```sage\nsage: from sage.combinat.combination import rank\nsage: set_random_seed(0)\nsage: comb = Combinations(range(100)).random_element()\nsage: %timeit rank(comb, 100)\n142 \u00b5s \u00b1 1.09 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\nsage: comb = Combinations(range(1000)).random_element()\nsage: %timeit rank(comb, 1000)\n4.43 ms \u00b1 73.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\nsage: comb = Combinations(range(10000)).random_element()\nsage: %timeit rank(comb, 10000)\n865 ms \u00b1 10 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\nsage: comb = Combinations(range(50000)).random_element()\nsage: %timeit rank(comb, 50000)\n57.3 s \u00b1 1.83 s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\nAfter:\n\n```sage\nsage: from sage.combinat.combination import rank\nsage: set_random_seed(0)\nsage: comb = Combinations(range(100)).random_element()\nsage: %timeit rank(comb, 100)\n258 \u00b5s \u00b1 12.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\nsage: comb = Combinations(range(1000)).random_element()\nsage: %timeit rank(comb, 1000)\n2.91 ms \u00b1 87.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\nsage: comb = Combinations(range(10000)).random_element()\nsage: %timeit rank(comb, 10000)\n37 ms \u00b1 1.35 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\nsage: comb = Combinations(range(50000)).random_element()\nsage: %timeit rank(comb, 50000)\n293 ms \u00b1 8.29 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\nsage: comb = Combinations(range(100000)).random_element()\nsage: %timeit rank(comb, 100000)\n976 ms \u00b1 93.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\nNote that this is a bit slower for smaller values of `n` so I'm a bit hesitant about this one.\n\nThen avoid repeated calls to `binomial` in `Combinations_set.rank`.\n\nBefore:\n\n```sage\nsage: set_random_seed(0)\nsage: c = Combinations(range(100)); comb = c.random_element()\nsage: %timeit c.rank(comb)\n439 \u00b5s \u00b1 7.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\nsage: c = Combinations(range(1000)); comb = c.random_element()\nsage: %timeit c.rank(comb)\n11 ms \u00b1 110 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\nsage: c = Combinations(range(10000)); comb = c.random_element()\nsage: %timeit c.rank(comb)\n1.56 s \u00b1 128 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\nsage: c = Combinations(range(50000)); comb = c.random_element()\nsage: %timeit c.rank(comb)\n1min 10s \u00b1 3.64 s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\nAfter:\n\n```sage\nsage: set_random_seed(0)\nsage: c = Combinations(range(100)); comb = c.random_element()\nsage: %timeit c.rank(comb)\n346 \u00b5s \u00b1 6.04 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\nsage: c = Combinations(range(1000)); comb = c.random_element()\nsage: %timeit c.rank(comb)\n7.09 ms \u00b1 132 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\nsage: c = Combinations(range(10000)); comb = c.random_element()\nsage: %timeit c.rank(comb)\n343 ms \u00b1 5.96 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\nsage: c = Combinations(range(50000)); comb = c.random_element()\nsage: %timeit c.rank(comb)\n8.92 s \u00b1 443 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\n\nCC:  @agenitrini\n\nBranch: [u/MartinPepin/combination_unranking](https://github.com/sagemath/sagetrac-mirror/tree/u/MartinPepin/combination_unranking)\n\nCommit: [27281aad98dd6bf68acefe1d65ff44e84816103a](https://github.com/sagemath/sagetrac-mirror/commit/27281aad98dd6bf68acefe1d65ff44e84816103a)\n\nAuthor: Martin P\u00e9pin\n\nStatus: needs_work\n\nIssue created by migration from https://trac.sagemath.org/ticket/34580\n\n",
    "created_at": "2022-09-24T15:03:26Z",
    "labels": [
        "component: combinatorics",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Faster implementations of combinations ranking / unranking",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/34580",
    "user": "https://github.com/Kerl13"
}
```
This patch implements several tweaks to the current algorithms for ranking and unranking combinations.
In chronological (commit) order:

**Re-implement the `from_rank` function**

It is based on the paper following the pre-print on which the previous implementation was based. The new algorithm is Algorithm 6 (page 20) in https://www.mdpi.com/1999-4893/14/3/97 (I'm an author).

The algorithm is simpler (less lines of code and branching) and a little bit faster.

In addition
- it removes some redundant checks at the beginning of the function;
- and it ensures the check that `0 <= rank < binomial(n, k)` happens **before** the special case:

```
if k == 0:
    return ()
```
There is a bug with the current implementation where you can call
`from_rank(dummy_rank, n, 0)` and you will always get `from_rank(0, n, 0)`.

Very quick performance comparison:

Before the patch:

```sage
sage: set_random_seed(0)
sage: test_args = [(randint(0, binomial(n, n // 2) - 1), n, n // 2) for n in [100, 1000, 10000, 50000, 100000]]
sage: from sage.combinat.combination import from_rank
sage: %time _ = from_rank(*test_args[0])
CPU times: user 485 µs, sys: 20 µs, total: 505 µs
Wall time: 510 µs
sage: %time _ = from_rank(*test_args[1])
CPU times: user 3.85 ms, sys: 24 µs, total: 3.87 ms
Wall time: 3.9 ms
sage: %time _ = from_rank(*test_args[2])
CPU times: user 47.5 ms, sys: 53 µs, total: 47.5 ms
Wall time: 46.7 ms
sage: %time _ = from_rank(*test_args[3])
CPU times: user 329 ms, sys: 142 µs, total: 330 ms
Wall time: 335 ms
sage: %time _ = from_rank(*test_args[4])
CPU times: user 890 ms, sys: 132 µs, total: 890 ms
Wall time: 890 ms
```

After the patch:

```sage
sage: set_random_seed(0)
sage: test_args = [(randint(0, binomial(n, n // 2) - 1), n, n // 2) for n in [100, 1000, 10000, 50000, 100000]]
sage: from sage.combinat.combination import from_rank
sage: %time _ = from_rank(*test_args[0])
CPU times: user 440 µs, sys: 42 µs, total: 482 µs
Wall time: 488 µs
sage: %time _ = from_rank(*test_args[1])
CPU times: user 2.43 ms, sys: 0 ns, total: 2.43 ms
Wall time: 2.73 ms
sage: %time _ = from_rank(*test_args[2])
CPU times: user 26.9 ms, sys: 3.04 ms, total: 30 ms
Wall time: 29.6 ms
sage: %time _ = from_rank(*test_args[3])
CPU times: user 198 ms, sys: 116 µs, total: 198 ms
Wall time: 198 ms
sage: %time _ = from_rank(*test_args[4])
CPU times: user 573 ms, sys: 600 µs, total: 573 ms
Wall time: 573 ms
```

**2. We increase the performance of Combinations_set.unrank**

Whereas `from_rank` unranks a combination of `range(n)` of given size `k`, the `Combinations_set.unrank` function unranks from the set of all sub-sets of `range(n)`.
In order to find the right value of `k` to pass to `from_rank` it has to do some work with binomial coefficients. We accelerate this work by avoiding repeated calls to the `binomial` function.

Before:

```sage
sage: set_random_seed(0)
sage: %timeit _ = Combinations(range(100)).unrank(randint(0, 2 ** 100 - 1))
412 µs ± 15.7 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
sage: %timeit _ = Combinations(range(1000)).unrank(randint(0, 2 ** 1000 - 1))
7.68 ms ± 92.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit _ = Combinations(range(10000)).unrank(randint(0, 2 ** 10000 - 1))
960 ms ± 22.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: %timeit _ = Combinations(range(50000)).unrank(randint(0, 2 ** 50000 - 1))
51.6 s ± 637 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

After:

```sage
sage: set_random_seed(0)
sage: %timeit _ = Combinations(range(100)).unrank(randint(0, 2 ** 100 - 1))
288 µs ± 9.18 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
sage: %timeit _ = Combinations(range(1000)).unrank(randint(0, 2 ** 1000 - 1))
3.14 ms ± 67.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: %timeit _ = Combinations(range(10000)).unrank(randint(0, 2 ** 10000 - 1))
38.7 ms ± 755 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
sage: %timeit _ = Combinations(range(50000)).unrank(randint(0, 2 ** 50000 - 1))
311 ms ± 6.36 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

**3. Do the same for ranking**

We use a faster algorithm for the `rank` function.

Before:

```sage
sage: from sage.combinat.combination import rank
sage: set_random_seed(0)
sage: comb = Combinations(range(100)).random_element()
sage: %timeit rank(comb, 100)
142 µs ± 1.09 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
sage: comb = Combinations(range(1000)).random_element()
sage: %timeit rank(comb, 1000)
4.43 ms ± 73.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: comb = Combinations(range(10000)).random_element()
sage: %timeit rank(comb, 10000)
865 ms ± 10 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: comb = Combinations(range(50000)).random_element()
sage: %timeit rank(comb, 50000)
57.3 s ± 1.83 s per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

After:

```sage
sage: from sage.combinat.combination import rank
sage: set_random_seed(0)
sage: comb = Combinations(range(100)).random_element()
sage: %timeit rank(comb, 100)
258 µs ± 12.8 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
sage: comb = Combinations(range(1000)).random_element()
sage: %timeit rank(comb, 1000)
2.91 ms ± 87.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: comb = Combinations(range(10000)).random_element()
sage: %timeit rank(comb, 10000)
37 ms ± 1.35 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
sage: comb = Combinations(range(50000)).random_element()
sage: %timeit rank(comb, 50000)
293 ms ± 8.29 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: comb = Combinations(range(100000)).random_element()
sage: %timeit rank(comb, 100000)
976 ms ± 93.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

Note that this is a bit slower for smaller values of `n` so I'm a bit hesitant about this one.

Then avoid repeated calls to `binomial` in `Combinations_set.rank`.

Before:

```sage
sage: set_random_seed(0)
sage: c = Combinations(range(100)); comb = c.random_element()
sage: %timeit c.rank(comb)
439 µs ± 7.6 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
sage: c = Combinations(range(1000)); comb = c.random_element()
sage: %timeit c.rank(comb)
11 ms ± 110 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: c = Combinations(range(10000)); comb = c.random_element()
sage: %timeit c.rank(comb)
1.56 s ± 128 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: c = Combinations(range(50000)); comb = c.random_element()
sage: %timeit c.rank(comb)
1min 10s ± 3.64 s per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

After:

```sage
sage: set_random_seed(0)
sage: c = Combinations(range(100)); comb = c.random_element()
sage: %timeit c.rank(comb)
346 µs ± 6.04 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
sage: c = Combinations(range(1000)); comb = c.random_element()
sage: %timeit c.rank(comb)
7.09 ms ± 132 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
sage: c = Combinations(range(10000)); comb = c.random_element()
sage: %timeit c.rank(comb)
343 ms ± 5.96 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
sage: c = Combinations(range(50000)); comb = c.random_element()
sage: %timeit c.rank(comb)
8.92 s ± 443 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

CC:  @agenitrini

Branch: [u/MartinPepin/combination_unranking](https://github.com/sagemath/sagetrac-mirror/tree/u/MartinPepin/combination_unranking)

Commit: [27281aad98dd6bf68acefe1d65ff44e84816103a](https://github.com/sagemath/sagetrac-mirror/commit/27281aad98dd6bf68acefe1d65ff44e84816103a)

Author: Martin Pépin

Status: needs_work

Issue created by migration from https://trac.sagemath.org/ticket/34580





---

archive/issue_comments_688093.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-09-24T15:04:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688093",
    "user": "https://github.com/Kerl13"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_688094.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2022-09-24T19:19:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688094",
    "user": "https://github.com/Kerl13"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_688095.json:
```json
{
    "body": "<a id='comment:3'></a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n|                                                                                                                                           |                                                 |\n|-------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------|\n|[2163107](https://github.com/sagemath/sagetrac-mirror/commit/21631079c3a5f32412a2f4046d3afa3fa389a1d5)|`Always convert combination.from_rank args to ZZ`|",
    "created_at": "2022-09-24T19:32:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688095",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
Branch pushed to git repo; I updated commit sha1. New commits:
|                                                                                                                                           |                                                 |
|-------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------|
|[2163107](https://github.com/sagemath/sagetrac-mirror/commit/21631079c3a5f32412a2f4046d3afa3fa389a1d5)|`Always convert combination.from_rank args to ZZ`|



---

archive/issue_comments_688096.json:
```json
{
    "body": "Changing commit from \"[0d3b9ec386271b9690035841a5f8f09047179312](https://github.com/sagemath/sagetrac-mirror/commit/0d3b9ec386271b9690035841a5f8f09047179312)\" to \"[21631079c3a5f32412a2f4046d3afa3fa389a1d5](https://github.com/sagemath/sagetrac-mirror/commit/21631079c3a5f32412a2f4046d3afa3fa389a1d5)\"",
    "created_at": "2022-09-24T19:32:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688096",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "[0d3b9ec386271b9690035841a5f8f09047179312](https://github.com/sagemath/sagetrac-mirror/commit/0d3b9ec386271b9690035841a5f8f09047179312)" to "[21631079c3a5f32412a2f4046d3afa3fa389a1d5](https://github.com/sagemath/sagetrac-mirror/commit/21631079c3a5f32412a2f4046d3afa3fa389a1d5)"



---

archive/issue_comments_688097.json:
```json
{
    "body": "<a id='comment:4'></a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n|                                                                                                                                           |                                               |\n|-------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------|\n|[e5a4d1f](https://github.com/sagemath/sagetrac-mirror/commit/e5a4d1fcbb71079314e3bb051ae08f6830a71891)|`Combination unranking: more doc + faster algo`|\n|[fd43533](https://github.com/sagemath/sagetrac-mirror/commit/fd43533d0fed878d9c44699a605b66ed5724441f)|`Faster combinat.combination.rank algorithm`|\n|[7c7020c](https://github.com/sagemath/sagetrac-mirror/commit/7c7020cd4f389664aabb7f2f35c9a3776884184e)|`Combinations ranking: more documentation`|\n|[e540a26](https://github.com/sagemath/sagetrac-mirror/commit/e540a261c31551e1736323126be2a7e6d3d0f54f)|`Faster algorithm for combination ranking`|",
    "created_at": "2022-10-01T14:32:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688097",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
Branch pushed to git repo; I updated commit sha1. New commits:
|                                                                                                                                           |                                               |
|-------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------|
|[e5a4d1f](https://github.com/sagemath/sagetrac-mirror/commit/e5a4d1fcbb71079314e3bb051ae08f6830a71891)|`Combination unranking: more doc + faster algo`|
|[fd43533](https://github.com/sagemath/sagetrac-mirror/commit/fd43533d0fed878d9c44699a605b66ed5724441f)|`Faster combinat.combination.rank algorithm`|
|[7c7020c](https://github.com/sagemath/sagetrac-mirror/commit/7c7020cd4f389664aabb7f2f35c9a3776884184e)|`Combinations ranking: more documentation`|
|[e540a26](https://github.com/sagemath/sagetrac-mirror/commit/e540a261c31551e1736323126be2a7e6d3d0f54f)|`Faster algorithm for combination ranking`|



---

archive/issue_comments_688098.json:
```json
{
    "body": "Changing commit from \"[21631079c3a5f32412a2f4046d3afa3fa389a1d5](https://github.com/sagemath/sagetrac-mirror/commit/21631079c3a5f32412a2f4046d3afa3fa389a1d5)\" to \"[e540a261c31551e1736323126be2a7e6d3d0f54f](https://github.com/sagemath/sagetrac-mirror/commit/e540a261c31551e1736323126be2a7e6d3d0f54f)\"",
    "created_at": "2022-10-01T14:32:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688098",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "[21631079c3a5f32412a2f4046d3afa3fa389a1d5](https://github.com/sagemath/sagetrac-mirror/commit/21631079c3a5f32412a2f4046d3afa3fa389a1d5)" to "[e540a261c31551e1736323126be2a7e6d3d0f54f](https://github.com/sagemath/sagetrac-mirror/commit/e540a261c31551e1736323126be2a7e6d3d0f54f)"



---

archive/issue_events_101007.json:
```json
{
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "rename": {
        "from": "Shorter and faster implementation of combinat.combination.from_rank",
        "to": "Faster implementations of combinations ranking / unranking"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/34580#event-101007"
}
```



---

archive/issue_comments_688099.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,11 @@\n-This patch implements a simpler algorithm for combination unranking.\n+This patch implements several tweaks to the current algorithms for ranking and unranking combinations.\n+In chronological (commit) order:\n+\n+**Re-implement the `from_rank` function**\n \n It is based on the paper following the pre-print on which the previous implementation was based. The new algorithm is Algorithm 6 (page 20) in https://www.mdpi.com/1999-4893/14/3/97 (I'm an author).\n+\n+The algorithm is simpler (less lines of code and branching) and a little bit faster.\n \n In addition\n - it removes some redundant checks at the beginning of the function;\n@@ -12,8 +17,6 @@\n ```\n There is a bug with the current implementation where you can call\n `from_rank(dummy_rank, n, 0)` and you will always get `from_rank(0, n, 0)`.\n-\n----\n \n Very quick performance comparison:\n \n@@ -62,3 +65,121 @@\n CPU times: user 573 ms, sys: 600 \u00b5s, total: 573 ms\n Wall time: 573 ms\n ```\n+\n+**2. We increase the performance of Combinations_set.unrank**\n+\n+Whereas `from_rank` unranks a combination of `range(n)` of given size `k`, the `Combinations_set.unrank` function unranks from the set of all sub-sets of `range(n)`.\n+In order to find the right value of `k` to pass to `from_rank` it has to do some work with binomial coefficients. We accelerate this work by avoiding repeated calls to the `binomial` function.\n+\n+Before:\n+\n+```sage\n+sage: set_random_seed(0)\n+sage: %timeit _ = Combinations(range(100)).unrank(randint(0, 2 ** 100 - 1))\n+412 \u00b5s \u00b1 15.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n+sage: %timeit _ = Combinations(range(1000)).unrank(randint(0, 2 ** 1000 - 1))\n+7.68 ms \u00b1 92.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n+sage: %timeit _ = Combinations(range(10000)).unrank(randint(0, 2 ** 10000 - 1))\n+960 ms \u00b1 22.4 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+sage: %timeit _ = Combinations(range(50000)).unrank(randint(0, 2 ** 50000 - 1))\n+51.6 s \u00b1 637 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+```\n+\n+After:\n+\n+```sage\n+sage: set_random_seed(0)\n+sage: %timeit _ = Combinations(range(100)).unrank(randint(0, 2 ** 100 - 1))\n+288 \u00b5s \u00b1 9.18 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n+sage: %timeit _ = Combinations(range(1000)).unrank(randint(0, 2 ** 1000 - 1))\n+3.14 ms \u00b1 67.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n+sage: %timeit _ = Combinations(range(10000)).unrank(randint(0, 2 ** 10000 - 1))\n+38.7 ms \u00b1 755 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n+sage: %timeit _ = Combinations(range(50000)).unrank(randint(0, 2 ** 50000 - 1))\n+311 ms \u00b1 6.36 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+```\n+\n+**3. Do the same for ranking**\n+\n+We use a faster algorithm for the `rank` function.\n+\n+Before:\n+\n+```sage\n+sage: from sage.combinat.combination import rank\n+sage: set_random_seed(0)\n+sage: comb = Combinations(range(100)).random_element()\n+sage: %timeit rank(comb, 100)\n+142 \u00b5s \u00b1 1.09 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n+sage: comb = Combinations(range(1000)).random_element()\n+sage: %timeit rank(comb, 1000)\n+4.43 ms \u00b1 73.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n+sage: comb = Combinations(range(10000)).random_element()\n+sage: %timeit rank(comb, 10000)\n+865 ms \u00b1 10 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+sage: comb = Combinations(range(50000)).random_element()\n+sage: %timeit rank(comb, 50000)\n+57.3 s \u00b1 1.83 s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+```\n+\n+After:\n+\n+```sage\n+sage: from sage.combinat.combination import rank\n+sage: set_random_seed(0)\n+sage: comb = Combinations(range(100)).random_element()\n+sage: %timeit rank(comb, 100)\n+258 \u00b5s \u00b1 12.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n+sage: comb = Combinations(range(1000)).random_element()\n+sage: %timeit rank(comb, 1000)\n+2.91 ms \u00b1 87.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n+sage: comb = Combinations(range(10000)).random_element()\n+sage: %timeit rank(comb, 10000)\n+37 ms \u00b1 1.35 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n+sage: comb = Combinations(range(50000)).random_element()\n+sage: %timeit rank(comb, 50000)\n+293 ms \u00b1 8.29 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+sage: comb = Combinations(range(100000)).random_element()\n+sage: %timeit rank(comb, 100000)\n+976 ms \u00b1 93.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+```\n+\n+Note that this is a bit slower for smaller values of `n` so I'm a bit hesitant about this one.\n+\n+Then avoid repeated calls to `binomial` in `Combinations_set.rank`.\n+\n+Before:\n+\n+```sage\n+sage: set_random_seed(0)\n+sage: c = Combinations(range(100)); comb = c.random_element()\n+sage: %timeit c.rank(comb)\n+439 \u00b5s \u00b1 7.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n+sage: c = Combinations(range(1000)); comb = c.random_element()\n+sage: %timeit c.rank(comb)\n+11 ms \u00b1 110 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n+sage: c = Combinations(range(10000)); comb = c.random_element()\n+sage: %timeit c.rank(comb)\n+1.56 s \u00b1 128 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+sage: c = Combinations(range(50000)); comb = c.random_element()\n+sage: %timeit c.rank(comb)\n+1min 10s \u00b1 3.64 s per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+```\n+\n+After:\n+\n+```sage\n+sage: set_random_seed(0)\n+sage: c = Combinations(range(100)); comb = c.random_element()\n+sage: %timeit c.rank(comb)\n+346 \u00b5s \u00b1 6.04 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n+sage: c = Combinations(range(1000)); comb = c.random_element()\n+sage: %timeit c.rank(comb)\n+7.09 ms \u00b1 132 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n+sage: c = Combinations(range(10000)); comb = c.random_element()\n+sage: %timeit c.rank(comb)\n+343 ms \u00b1 5.96 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+sage: c = Combinations(range(50000)); comb = c.random_element()\n+sage: %timeit c.rank(comb)\n+8.92 s \u00b1 443 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n+```\n``````\n",
    "created_at": "2022-10-01T14:49:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688099",
    "user": "https://github.com/Kerl13"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,11 @@
-This patch implements a simpler algorithm for combination unranking.
+This patch implements several tweaks to the current algorithms for ranking and unranking combinations.
+In chronological (commit) order:
+
+**Re-implement the `from_rank` function**
 
 It is based on the paper following the pre-print on which the previous implementation was based. The new algorithm is Algorithm 6 (page 20) in https://www.mdpi.com/1999-4893/14/3/97 (I'm an author).
+
+The algorithm is simpler (less lines of code and branching) and a little bit faster.
 
 In addition
 - it removes some redundant checks at the beginning of the function;
@@ -12,8 +17,6 @@
 ```
 There is a bug with the current implementation where you can call
 `from_rank(dummy_rank, n, 0)` and you will always get `from_rank(0, n, 0)`.
-
----
 
 Very quick performance comparison:
 
@@ -62,3 +65,121 @@
 CPU times: user 573 ms, sys: 600 µs, total: 573 ms
 Wall time: 573 ms
 ```
+
+**2. We increase the performance of Combinations_set.unrank**
+
+Whereas `from_rank` unranks a combination of `range(n)` of given size `k`, the `Combinations_set.unrank` function unranks from the set of all sub-sets of `range(n)`.
+In order to find the right value of `k` to pass to `from_rank` it has to do some work with binomial coefficients. We accelerate this work by avoiding repeated calls to the `binomial` function.
+
+Before:
+
+```sage
+sage: set_random_seed(0)
+sage: %timeit _ = Combinations(range(100)).unrank(randint(0, 2 ** 100 - 1))
+412 µs ± 15.7 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
+sage: %timeit _ = Combinations(range(1000)).unrank(randint(0, 2 ** 1000 - 1))
+7.68 ms ± 92.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
+sage: %timeit _ = Combinations(range(10000)).unrank(randint(0, 2 ** 10000 - 1))
+960 ms ± 22.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
+sage: %timeit _ = Combinations(range(50000)).unrank(randint(0, 2 ** 50000 - 1))
+51.6 s ± 637 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
+```
+
+After:
+
+```sage
+sage: set_random_seed(0)
+sage: %timeit _ = Combinations(range(100)).unrank(randint(0, 2 ** 100 - 1))
+288 µs ± 9.18 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
+sage: %timeit _ = Combinations(range(1000)).unrank(randint(0, 2 ** 1000 - 1))
+3.14 ms ± 67.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
+sage: %timeit _ = Combinations(range(10000)).unrank(randint(0, 2 ** 10000 - 1))
+38.7 ms ± 755 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
+sage: %timeit _ = Combinations(range(50000)).unrank(randint(0, 2 ** 50000 - 1))
+311 ms ± 6.36 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
+```
+
+**3. Do the same for ranking**
+
+We use a faster algorithm for the `rank` function.
+
+Before:
+
+```sage
+sage: from sage.combinat.combination import rank
+sage: set_random_seed(0)
+sage: comb = Combinations(range(100)).random_element()
+sage: %timeit rank(comb, 100)
+142 µs ± 1.09 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
+sage: comb = Combinations(range(1000)).random_element()
+sage: %timeit rank(comb, 1000)
+4.43 ms ± 73.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
+sage: comb = Combinations(range(10000)).random_element()
+sage: %timeit rank(comb, 10000)
+865 ms ± 10 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
+sage: comb = Combinations(range(50000)).random_element()
+sage: %timeit rank(comb, 50000)
+57.3 s ± 1.83 s per loop (mean ± std. dev. of 7 runs, 1 loop each)
+```
+
+After:
+
+```sage
+sage: from sage.combinat.combination import rank
+sage: set_random_seed(0)
+sage: comb = Combinations(range(100)).random_element()
+sage: %timeit rank(comb, 100)
+258 µs ± 12.8 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
+sage: comb = Combinations(range(1000)).random_element()
+sage: %timeit rank(comb, 1000)
+2.91 ms ± 87.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
+sage: comb = Combinations(range(10000)).random_element()
+sage: %timeit rank(comb, 10000)
+37 ms ± 1.35 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
+sage: comb = Combinations(range(50000)).random_element()
+sage: %timeit rank(comb, 50000)
+293 ms ± 8.29 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
+sage: comb = Combinations(range(100000)).random_element()
+sage: %timeit rank(comb, 100000)
+976 ms ± 93.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
+```
+
+Note that this is a bit slower for smaller values of `n` so I'm a bit hesitant about this one.
+
+Then avoid repeated calls to `binomial` in `Combinations_set.rank`.
+
+Before:
+
+```sage
+sage: set_random_seed(0)
+sage: c = Combinations(range(100)); comb = c.random_element()
+sage: %timeit c.rank(comb)
+439 µs ± 7.6 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
+sage: c = Combinations(range(1000)); comb = c.random_element()
+sage: %timeit c.rank(comb)
+11 ms ± 110 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
+sage: c = Combinations(range(10000)); comb = c.random_element()
+sage: %timeit c.rank(comb)
+1.56 s ± 128 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
+sage: c = Combinations(range(50000)); comb = c.random_element()
+sage: %timeit c.rank(comb)
+1min 10s ± 3.64 s per loop (mean ± std. dev. of 7 runs, 1 loop each)
+```
+
+After:
+
+```sage
+sage: set_random_seed(0)
+sage: c = Combinations(range(100)); comb = c.random_element()
+sage: %timeit c.rank(comb)
+346 µs ± 6.04 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
+sage: c = Combinations(range(1000)); comb = c.random_element()
+sage: %timeit c.rank(comb)
+7.09 ms ± 132 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
+sage: c = Combinations(range(10000)); comb = c.random_element()
+sage: %timeit c.rank(comb)
+343 ms ± 5.96 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
+sage: c = Combinations(range(50000)); comb = c.random_element()
+sage: %timeit c.rank(comb)
+8.92 s ± 443 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
+```
``````




---

archive/issue_comments_688100.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2022-10-01T14:49:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688100",
    "user": "https://github.com/Kerl13"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_688101.json:
```json
{
    "body": "<a id='comment:6'></a>\nForgot to mention in the description that I added a few docstrings and doctests",
    "created_at": "2022-10-01T14:50:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688101",
    "user": "https://github.com/Kerl13"
}
```

<a id='comment:6'></a>
Forgot to mention in the description that I added a few docstrings and doctests



---

archive/issue_comments_688102.json:
```json
{
    "body": "<a id='comment:7'></a>\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n|                                                                                                                                           |                                                   |\n|-------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|\n|[017bc6e](https://github.com/sagemath/sagetrac-mirror/commit/017bc6e6d39052c2be85d732bb595146624dc3cb)|`Simpler and faster combinat.combination.from_rank`|\n|[7d5b95a](https://github.com/sagemath/sagetrac-mirror/commit/7d5b95a0ae0ac9e7ea47e78898c61159ca7ca0c5)|`Always convert combination.from_rank args to ZZ`|\n|[9af87bc](https://github.com/sagemath/sagetrac-mirror/commit/9af87bc621d19a568fec7fd0e1a89cb52fee3a24)|`Combination unranking: more doc + faster algo`|\n|[fa5f9c7](https://github.com/sagemath/sagetrac-mirror/commit/fa5f9c7a0fccf44875a63229687d04ffdf04306e)|`Faster combinat.combination.rank algorithm`|\n|[899fdb8](https://github.com/sagemath/sagetrac-mirror/commit/899fdb83a26d740eb19bb506737f20b6d4dcd0e6)|`Combinations ranking: more documentation`|\n|[27281aa](https://github.com/sagemath/sagetrac-mirror/commit/27281aad98dd6bf68acefe1d65ff44e84816103a)|`Faster algorithm for combination ranking`|",
    "created_at": "2022-10-02T13:24:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688102",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
|                                                                                                                                           |                                                   |
|-------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
|[017bc6e](https://github.com/sagemath/sagetrac-mirror/commit/017bc6e6d39052c2be85d732bb595146624dc3cb)|`Simpler and faster combinat.combination.from_rank`|
|[7d5b95a](https://github.com/sagemath/sagetrac-mirror/commit/7d5b95a0ae0ac9e7ea47e78898c61159ca7ca0c5)|`Always convert combination.from_rank args to ZZ`|
|[9af87bc](https://github.com/sagemath/sagetrac-mirror/commit/9af87bc621d19a568fec7fd0e1a89cb52fee3a24)|`Combination unranking: more doc + faster algo`|
|[fa5f9c7](https://github.com/sagemath/sagetrac-mirror/commit/fa5f9c7a0fccf44875a63229687d04ffdf04306e)|`Faster combinat.combination.rank algorithm`|
|[899fdb8](https://github.com/sagemath/sagetrac-mirror/commit/899fdb83a26d740eb19bb506737f20b6d4dcd0e6)|`Combinations ranking: more documentation`|
|[27281aa](https://github.com/sagemath/sagetrac-mirror/commit/27281aad98dd6bf68acefe1d65ff44e84816103a)|`Faster algorithm for combination ranking`|



---

archive/issue_comments_688103.json:
```json
{
    "body": "Changing commit from \"[e540a261c31551e1736323126be2a7e6d3d0f54f](https://github.com/sagemath/sagetrac-mirror/commit/e540a261c31551e1736323126be2a7e6d3d0f54f)\" to \"[27281aad98dd6bf68acefe1d65ff44e84816103a](https://github.com/sagemath/sagetrac-mirror/commit/27281aad98dd6bf68acefe1d65ff44e84816103a)\"",
    "created_at": "2022-10-02T13:24:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688103",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "[e540a261c31551e1736323126be2a7e6d3d0f54f](https://github.com/sagemath/sagetrac-mirror/commit/e540a261c31551e1736323126be2a7e6d3d0f54f)" to "[27281aad98dd6bf68acefe1d65ff44e84816103a](https://github.com/sagemath/sagetrac-mirror/commit/27281aad98dd6bf68acefe1d65ff44e84816103a)"



---

archive/issue_comments_688104.json:
```json
{
    "body": "<a id='comment:8'></a>\nRather than `Compute` in a docstring use `Return`. The fact that a function computes is good to know but not very relevant for its specification.",
    "created_at": "2022-10-26T20:27:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688104",
    "user": "https://github.com/videlec"
}
```

<a id='comment:8'></a>
Rather than `Compute` in a docstring use `Return`. The fact that a function computes is good to know but not very relevant for its specification.



---

archive/issue_comments_688105.json:
```json
{
    "body": "<a id='comment:9'></a>\nWhy removing  `[DGH2020]` completely from the references?",
    "created_at": "2022-10-26T20:28:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688105",
    "user": "https://github.com/videlec"
}
```

<a id='comment:9'></a>
Why removing  `[DGH2020]` completely from the references?



---

archive/issue_comments_688106.json:
```json
{
    "body": "<a id='comment:10'></a>\nInstead of\n\n```\n        # The first combination is the empty set\n        sage: c.unrank(0)\n        []\n```\nDo\n\n```\n    The first combination is the empty set::\n\n        sage: c.unrank(0)\n        []\n```\nThe syntax of documentation string is rather well described at https://doc.sagemath.org/html/en/developer/coding_basics.html",
    "created_at": "2022-10-26T20:30:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688106",
    "user": "https://github.com/videlec"
}
```

<a id='comment:10'></a>
Instead of

```
        # The first combination is the empty set
        sage: c.unrank(0)
        []
```
Do

```
    The first combination is the empty set::

        sage: c.unrank(0)
        []
```
The syntax of documentation string is rather well described at https://doc.sagemath.org/html/en/developer/coding_basics.html



---

archive/issue_comments_688107.json:
```json
{
    "body": "<a id='comment:11'></a>\nWhy is there a `*` introduced in front of \"McCaffrey\" here\n\n```diff\n@@ -546,8 +611,13 @@ def rank(comb, n, check=True):\n     Return the rank of ``comb`` in the subsets of ``range(n)`` of size ``k``\n     where ``k`` is the length of ``comb``.\n \n-    The algorithm used is based on combinadics and James McCaffrey's\n-    MSDN article. See: :wikipedia:`Combinadic`.\n+    The algorithm used is based on combinadics and is adapted from James\n+    *McCaffrey's MSDN article. It differs from McCaffrey's algorithm in the\n+    computation of binomial coefficients. Instead of calling `binomial` every\n+    time a binomial coefficientis needed, we use [GP2021]_'s trick of reusing\n+    the previous coefficient.\n+\n+    See: :wikipedia:`Combinadic`.\n```",
    "created_at": "2022-10-26T20:32:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688107",
    "user": "https://github.com/videlec"
}
```

<a id='comment:11'></a>
Why is there a `*` introduced in front of "McCaffrey" here

```diff
@@ -546,8 +611,13 @@ def rank(comb, n, check=True):
     Return the rank of ``comb`` in the subsets of ``range(n)`` of size ``k``
     where ``k`` is the length of ``comb``.
 
-    The algorithm used is based on combinadics and James McCaffrey's
-    MSDN article. See: :wikipedia:`Combinadic`.
+    The algorithm used is based on combinadics and is adapted from James
+    *McCaffrey's MSDN article. It differs from McCaffrey's algorithm in the
+    computation of binomial coefficients. Instead of calling `binomial` every
+    time a binomial coefficientis needed, we use [GP2021]_'s trick of reusing
+    the previous coefficient.
+
+    See: :wikipedia:`Combinadic`.
```



---

archive/issue_comments_688108.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2022-12-20T19:42:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/34580",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/34580#issuecomment-688108",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_review to needs_work.
