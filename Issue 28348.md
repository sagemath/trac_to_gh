# Issue 28348: Finite field roots

Issue created by migration from https://trac.sagemath.org/ticket/28585

Original creator: @theHawke

Original creation time: 2019-10-10 00:56:15




---

Comment by @theHawke created at 2019-10-10 01:08:45

Changing component from PLEASE CHANGE to finite rings.


---

Comment by @theHawke created at 2019-10-10 01:08:45

Changing type from PLEASE CHANGE to enhancement.


---

Comment by @theHawke created at 2019-10-10 01:10:34

Changing status from new to needs_review.


---

Comment by pbruin created at 2019-10-10 14:04:52

The branch points to 9.0.beta0; did you perhaps forget to push your branch?


---

Comment by git created at 2019-10-10 17:59:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @theHawke created at 2019-10-10 19:41:34

Replying to [comment:4 pbruin]:
> The branch points to 9.0.beta0; did you perhaps forget to push your branch?

Apologies, I didn't realize `git trac create` forks from develop instead of the current branch.

EDIT: Also apologies that it is not compiling, "it was working fine yesterday" and I have no idea what Cython is trying to tell me.

EDIT2: it was unicode quotes in the citation of the paper, ~600 lines down


---

Comment by git created at 2019-10-10 21:24:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-10-14 15:18:33

Hi,

Please post your benchmarks instead of writing `My tests show similar or slightly better performance at small prime moduli and significantly better performance in many cases at large prime moduli.`


---

Comment by vdelecroix created at 2019-10-14 15:19:16

The option `algorithm="AMM"` should be documented in the `INPUT` section somewhere.


---

Comment by vdelecroix created at 2019-10-14 15:22:16

There musts be tests associated to your new algorithm in the section `EXAMPLES:` and possibly `TESTS:`.


---

Comment by vdelecroix created at 2019-10-14 15:25:14

It is often better to avoid coercion (ie comparison, operation, etc of elements with distinct parents). For example
- `g**((q-1)/r) == 1` -> `(g**((q-1)/r)).is_one()`
- `A*G**lam != 1` -> `not (A*G**lam).is_one()`
- `J = 0` -> `J = K.zero()`
- `J == 0` -> `J.is_zero()`
- `g += 1` -> `g += one` where `one` would have been initialized to `K.one()`


---

Comment by vdelecroix created at 2019-10-14 15:25:22

Changing status from needs_review to needs_work.


---

Comment by git created at 2019-10-15 01:18:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-10-16 01:28:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @theHawke created at 2019-10-16 02:14:28

Replying to [comment:11 vdelecroix]:
> It is often better to avoid coercion (ie comparison, operation, etc of elements with distinct parents). For example
> - `g**((q-1)/r) == 1` -> `(g**((q-1)/r)).is_one()`
> - `A*G**lam != 1` -> `not (A*G**lam).is_one()`
> - `J = 0` -> `J = K.zero()`
> - `J == 0` -> `J.is_zero()`
> - `g += 1` -> `g += one` where `one` would have been initialized to `K.one()`

Thank you for the feedback!

I have now included the algorithm in the `INPUT`, `EXAMPLES` and `TEST` sections and I have attached my small benchmark script to this ticket.

I have also integrated your suggestions with regard to coercion, however since `J` is an exponent like `k` and `v`, I believe it should always be an integer and shouldn't be an element of `K`.

Lastly, I have expanded the algorithm to include the `self.is_one()` case.


---

Comment by @theHawke created at 2019-10-16 02:18:18

small benchmark comparing the two algorithms


---

Attachment

sample output of the benchmark


---

Comment by @theHawke created at 2019-10-16 02:19:54

Changing status from needs_work to needs_review.


---

Comment by git created at 2019-10-22 00:28:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-10-27 06:51:39

You introduced this doctest

```
sage: a._nth_root_common(4, True, "AMM", cunningham = True) # optional - cunningham
```

with no output!


---

Comment by vdelecroix created at 2019-10-27 06:55:07

It would be better to not duplicate

```
            if all:
                nthroot = g**q1overn
                L = [self]
                for i in range(1,n):
                    self *= nthroot
                    L.append(self)
                return L
```

(you could move that out of the `if/else`)


---

Comment by git created at 2019-10-27 13:16:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-10-27 17:09:33

There are trailing whitespaces in several place (ie space sign before line break). Please remove them. They appear in red if you do `git diff YOUR_BRANCH MAIN_BRANCH`.


---

Comment by vdelecroix created at 2019-10-27 17:12:54

This is ugly

```
if y.nth_root(r)**r != y: raise RuntimeError
if y.nth_root(r, algorithm='AMM')**r != y: raise RuntimeError
if (y^41).nth_root(41*r)**(41*r) != y^41: raise RuntimeError
if (y^41).nth_root(41*r, algorithm='AMM')**(41*r) != y^41: raise RuntimeError
if (y^307).nth_root(307*r)**(307*r) != y^307: raise RuntimeError
if (y^307).nth_root(307*r, algorithm='AMM')**(307*r) != y^307: raise RuntimeError
```

What about

```
for s, algo in product([1,41,307], ['Johnston', 'AMM']):
    assert (y^s).nth_root(s*r, algorithm=algo)**(s*r) == y^s
```

(you need a `from itertools import product`)


---

Comment by vdelecroix created at 2019-10-27 17:14:09

More interestingly, if AMM is faster for larger moduli why not make it the default in these cases? Would this dispatch be reasonable:
- if moduli is small just use Johnston
- if moduli is large
    - if a multiplicative generator is already available use Johnston
    - if not use AMM


---

Comment by @theHawke created at 2019-10-27 19:38:00

Replying to [comment:23 vdelecroix]:
> More interestingly, if AMM is faster for larger moduli why not make it the default in these cases? Would this dispatch be reasonable:
> - if moduli is small just use Johnston
> - if moduli is large
>     - if a multiplicative generator is already available use Johnston
>     - if not use AMM

Since AMM is actually slightly faster even at small moduli, it could also be made the default in general unless the multiplicative generator is available.

That said, I am not sure how to check whether the generator is available. There does seem to be some caching but I can't see a way to explicitly check it.


---

Comment by vdelecroix created at 2019-10-27 20:49:57

There is some caching

```
sage: R = Zmod(next_prime(2**10))
sage: r = R.multiplicative_generator()
sage: R.multiplicative_generator() is r
True
```

or finite fields

```
sage: R = GF(next_prime(2**10)**2)
sage: r = R.multiplicative_generator()
sage: R.multiplicative_generator() is r
True
```

The cache is implemented via the decorator ``@`cached_method`. To access the cache here is what could be done

```
gen = R.multiplictative_generator.cache
if gen is not None:
    # gen is the multiplicative generator
    ...
else:
    # do not trigger multiplicative generator computation
    ...
```


You should also check timings over very small moduli, e.g things like `GF(2^5)` or `GF(3^10)`.


---

Comment by @theHawke created at 2019-10-29 21:40:00

Benchmark script for comparing the two algortihms in various situations


---

Attachment

sample output of the benchmark (new version)


---

Comment by @theHawke created at 2019-10-29 22:28:52

I added a couple new tests to the benchmarks. Unless you want to set a threshold at something like 11 I don't think it is worth using Johnston for small values.

Whether a particular finite field is faster with Johnston or AMM seems to be fairly randomly distributed with AMM's advantage getting slightly larger as the fields order increases (goes up to 85% AMM better for orders below 10000).

I would suggest making the default simply depend on the availability of a cached multiplicative generator.


---

Comment by git created at 2019-10-29 22:37:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2020-01-06 14:10:03

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by vdelecroix created at 2020-10-10 21:15:23

The reference would better go in the dedicated file `$SAGE_ROOT/src/doc/en/reference/references/index.rst`. You can make citations using [ReST citations](https://thomas-cokelaer.info/tutorials/sphinx/rest_syntax.html#citations).


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by mmezzarobba created at 2021-09-18 09:57:01

no longer applies


---

Comment by mmezzarobba created at 2021-09-18 09:57:01

Changing status from needs_review to needs_work.
