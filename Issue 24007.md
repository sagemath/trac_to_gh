# Issue 24007: Fast check for C long

Issue created by migration from https://trac.sagemath.org/ticket/24244

Original creator: jdemeyer

Original creation time: 2017-11-19 19:03:19

Implement a fast variant of `pyobject_to_long`, which could be used to replace checks of the form `isinstance(x, int)`. This will help porting to Python 3 without losing too much performance.


---

Comment by git created at 2017-11-20 09:40:56

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-11-20 10:35:40

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-11-20 10:35:57

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2017-11-20 16:24:32

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-11-20 18:32:15

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-11-20 18:56:57

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2017-11-20 23:46:17

I think it would be better if `integer_check_long` and `integer_check_long_py` returned the error and `0` if it was completely successful. Then `pyobject_to_long` would then interpret the error using the `enum` and do the correct Python error raising. I feel like you are basically doing this, but in a roundabout way by passing `err`.


---

Comment by tscrim created at 2017-11-20 23:47:44

Also, in #24248, you do not even use the return `bint` of `integer_check_long_py`.


---

Comment by git created at 2017-11-21 09:21:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-11-22 05:05:10

Use case 2 could just become:

```
if integer_check_long(x, &value) == 0:
    # Conversion successful, use value
```

which feels much more natural to me.

However, I agree that use case 1 is a bit more of a hassle because you could not subsequently assign the error message (this wouldn't be a problem in, e.g., C because of the looser syntax rules). Although you can get around this by expanding out the `elif` as an `else-if` (but it looks fugly). Do you have a specific case where this does come up?


---

Comment by jdemeyer created at 2017-11-22 07:56:55

Replying to [comment:13 tscrim]:
> Use case 2 could just become:
> {{{
> if integer_check_long(x, &value) == 0:
>     # Conversion successful, use value
> }}}
> which feels much more natural to me.

Sure, I can simplify use case 1 and use case 2 individually. But I see no way to simplify things in such a way that both use cases still work. Alternatively, I could simply add another layer for use case 2 and make a new function
> {{{
> if integer_check_long_no_overflow(x, &value):
>     # Conversion successful, use value
> }}}

Finally, let me stress that this complexity shouldn't affect performance since we are dealing with `inline` functions and compilers are good at optimization.


---

Comment by jdemeyer created at 2017-11-22 08:09:24

Replying to [comment:13 tscrim]:
> Do you have a specific case where this does come up?

I don't know exactly what you mean, but you can look at my work in progress at #24247. There are various calls to `integer_check_long(_py)` there.


---

Comment by jdemeyer created at 2017-11-22 08:25:35

Let me know what you would suggest to do with this ticket.


---

Comment by tscrim created at 2017-11-22 22:15:48

Replying to [comment:15 jdemeyer]:
> Replying to [comment:13 tscrim]:
> > Do you have a specific case where this does come up?
> 
> I don't know exactly what you mean, but you can look at my work in progress at #24247. There are various calls to `integer_check_long(_py)` there.

Do you have a place on a future ticket where use case 1 applies? I see use case 2 on #24247 and this one:

```python
            if integer_check_long_py(right, &value, &err):
                if not err:
                    return (<Element>left)._pow_long(value)
                else:
                    return (<Element>left)._pow_int(right)
```

which could be simplified to

```python
            err = integer_check_long_py(right, &value):
            if not err:
                return (<Element>left)._pow_long(value)
            elif err == ERR_OVERFLOW:
                return (<Element>left)._pow_int(right)
```


However, if you see a clear benefit to take on the more complicated function description and return values, then you can set this to a positive review. I just am thinking a little bit about the potential future maintenance of this function (I also don't think there will be any [noticeable] performance difference) and the places where it is used.


---

Comment by jdemeyer created at 2017-11-23 09:03:56

Here is a concrete proposal: we keep the complicated signature for now (if anything, simply to prevent conflicts with current tickets depending on this one). Once we have a clearer idea on how these functions are used, we can revisit and change things if needed.


---

Comment by jdemeyer created at 2017-11-23 09:12:40

Replying to [comment:17 tscrim]:
> I also don't think there will be any [noticeable] performance difference

Fun observation: compiler warnings can be used to get data on how the compiler is able to optimize the code. For example, in #24247 I'm writing essentially

```
        cdef long value
        cdef int err
        if integer_check_long(y, &value, &err):
            if not err:
                return (<Element>x)._pow_long(value)
```

In this case, the compiler _does not give a warning_ that `err` and `value` might be uninitialized. This means that the compiler is able to inline and optimize all code paths of `integer_check_long` to prove that `err` and `value` are set to a known value whenever they are accessed in the code snippet above.


---

Comment by jdemeyer created at 2017-11-23 09:32:50

Changing status from needs_review to positive_review.


---

Comment by embray created at 2017-11-28 15:32:51

Oh, I just saw this from #24293 (I don't look at every ticket opened...)

As for "integer_fake" is there maybe a name for it that better reflects its purpose"?  I was thinking something like "integer_proto" (for prototype) since providing early access to the Integer prototype seems to be its primary purpose for existing.  "integer_fake" to me sounds like something for testing, or some other odd purpose.


---

Comment by jdemeyer created at 2017-11-28 15:40:20

Replying to [comment:21 embray]:
> As for "integer_fake" is there maybe a name for it that better reflects its purpose"?  I was thinking something like "integer_proto" (for prototype) since providing early access to the Integer prototype seems to be its primary purpose for existing.

I think that `integer_fake` or `integer_proto` are equally meaningless. What would "prototype" mean in this context? I don't mind changing the name, but I'm not convinced with `integer_proto` either.

> "integer_fake" to me sounds like something for testing, or some other odd purpose.

"odd purpose" totally applies here :-)


---

Comment by jdemeyer created at 2017-11-28 16:16:19

Thinking more about it, I actually like how the name sounds like it should not be used. `integer_proto` sounds too official somehow.


---

Comment by tscrim created at 2017-11-29 00:02:47

When I read `proto`(`type`), my first thought was the prototype design pattern, but that's right, in C it is called prototyping. However, since this is only mimicking that, I think `fake` is a little more accurate as to the class's purpose.


---

Comment by embray created at 2017-11-29 09:53:22

I mean, it _should_ be used, just for a specific narrow case.  Alright I won't push on it; just something called "fake" is a little jarring to me to see outside of, say, test code.


---

Comment by embray created at 2017-11-29 09:54:10

BTW, I should add, this is really cool.  Definitely something we should have done in the first place, in retrospect.


---

Comment by jdemeyer created at 2017-11-29 09:56:12

Replying to [comment:26 embray]:
> BTW, I should add, this is really cool.  Definitely something we should have done in the first place, in retrospect.

Thanks!


---

Comment by embray created at 2017-11-29 09:56:51

Okay okay, what about "integer_decl", since it's basically a forward declaration IIUC.


---

Comment by jdemeyer created at 2017-12-05 10:26:55

Replying to [comment:28 embray]:
> Okay okay, what about "integer_decl", since it's basically a forward declaration IIUC.

It's a fake forward declaration which shouldn't be used.


---

Comment by vbraun created at 2017-12-13 17:38:17

Resolution: fixed


---

Comment by jmantysalo created at 2018-04-24 17:13:29

Arghs, my typo.
