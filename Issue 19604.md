# Issue 19604: Fast polynomial evaluation for fmpz_poly/ZZX with arb input

archive/issues_019604.json:
```json
{
    "body": "CC:  slelievre\n\nSimilarly to #19822 we implement polynomial evaluation for real ball. Contrarily to the case of mpfr/mfpi it needs some non-trivial modification to `sage/rings/real_arb.pyx` because of loops in import statements.\n\nIssue created by migration from https://trac.sagemath.org/ticket/19841\n\n",
    "created_at": "2016-01-06T18:57:27Z",
    "labels": [
        "PLEASE CHANGE",
        "major",
        "enhancement"
    ],
    "title": "Fast polynomial evaluation for fmpz_poly/ZZX with arb input",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19604",
    "user": "vdelecroix"
}
```
CC:  slelievre

Similarly to #19822 we implement polynomial evaluation for real ball. Contrarily to the case of mpfr/mfpi it needs some non-trivial modification to `sage/rings/real_arb.pyx` because of loops in import statements.

Issue created by migration from https://trac.sagemath.org/ticket/19841





---

archive/issue_comments_269405.json:
```json
{
    "body": "It may be better (I'm not sure) to do that at the level of generic polynomials (using `_evaluate_polynomial()`) rather than special-casing polynomials with rational coefficients like you did for intervals. More precisely, real and complex ball could provide an implementation of `_evaluate_polynomial()` that converts the polynomial to arb's corresponding polynomial types and lets arb do the evaluation. (Actually something like that might have been a better solution in the case of mpfr/mpfi too.)",
    "created_at": "2016-03-25T10:21:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19604",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19604#issuecomment-269405",
    "user": "mmezzarobba"
}
```

It may be better (I'm not sure) to do that at the level of generic polynomials (using `_evaluate_polynomial()`) rather than special-casing polynomials with rational coefficients like you did for intervals. More precisely, real and complex ball could provide an implementation of `_evaluate_polynomial()` that converts the polynomial to arb's corresponding polynomial types and lets arb do the evaluation. (Actually something like that might have been a better solution in the case of mpfr/mpfi too.)



---

archive/issue_comments_269406.json:
```json
{
    "body": "I do not completely understand the end your comment. The code I have written was precisely to avoid any conversion. You can have a look at #19822: there is no type conversion at all (except some `NTL -> FLINT` integer conversions).\n\nI agree that we have two places for the implementation of `IntegerPolynomial.__call__(ArbType)`:\n\n1. in integer polynomials  `__call__` (as in #19822)\n\n2. in arb `_evaluate_polynomial`\n\nI have no strong opinion about what is best. Though I provided a shurtcut `p._eval_mpfr_(x)` which is useful and avoid type checking. This is does not discard using 1. or 2. for the generic call to `__call__`.",
    "created_at": "2016-03-28T01:44:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19604",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19604#issuecomment-269406",
    "user": "vdelecroix"
}
```

I do not completely understand the end your comment. The code I have written was precisely to avoid any conversion. You can have a look at #19822: there is no type conversion at all (except some `NTL -> FLINT` integer conversions).

I agree that we have two places for the implementation of `IntegerPolynomial.__call__(ArbType)`:

1. in integer polynomials  `__call__` (as in #19822)

2. in arb `_evaluate_polynomial`

I have no strong opinion about what is best. Though I provided a shurtcut `p._eval_mpfr_(x)` which is useful and avoid type checking. This is does not discard using 1. or 2. for the generic call to `__call__`.



---

archive/issue_comments_269407.json:
```json
{
    "body": "We could add some methods to arb to evaluate an fmpz_poly or fmpq_poly for arb or acb input, without conversion overhead.\n\nUsing arb's evaluation would definitely be faster at high precision for polynomials with small coefficients, even with conversion overhead, since a faster algorithm than Horner's rule will be used.",
    "created_at": "2016-03-28T12:59:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19604",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19604#issuecomment-269407",
    "user": "fredrik.johansson"
}
```

We could add some methods to arb to evaluate an fmpz_poly or fmpq_poly for arb or acb input, without conversion overhead.

Using arb's evaluation would definitely be faster at high precision for polynomials with small coefficients, even with conversion overhead, since a faster algorithm than Horner's rule will be used.



---

archive/issue_comments_269408.json:
```json
{
    "body": "Replying to [comment:3 fredrik.johansson]:\n> We could add some methods to arb to evaluate an fmpz_poly or fmpq_poly for arb or acb input, without conversion overhead.\n\nThat would be much better than doing the implementation in Sage. However, I think that a template approach would be useful here to do all kind of input/output (`NTL`, `gmp`, `fmpz`, `fmpq`, `mpfr`, `mpir`, `arb`, ...). There is an (almost dead) ticket #13358 in that direction.\n\n> Using arb's evaluation would definitely be faster at high precision for polynomials with small coefficients, even with conversion overhead, since a faster algorithm than Horner's rule will be used.\n\nRight now, my usage is for polynomial of small degree (< 10). Though the template approach would allow different algorithms as well.",
    "created_at": "2016-03-28T14:01:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19604",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19604#issuecomment-269408",
    "user": "vdelecroix"
}
```

Replying to [comment:3 fredrik.johansson]:
> We could add some methods to arb to evaluate an fmpz_poly or fmpq_poly for arb or acb input, without conversion overhead.

That would be much better than doing the implementation in Sage. However, I think that a template approach would be useful here to do all kind of input/output (`NTL`, `gmp`, `fmpz`, `fmpq`, `mpfr`, `mpir`, `arb`, ...). There is an (almost dead) ticket #13358 in that direction.

> Using arb's evaluation would definitely be faster at high precision for polynomials with small coefficients, even with conversion overhead, since a faster algorithm than Horner's rule will be used.

Right now, my usage is for polynomial of small degree (< 10). Though the template approach would allow different algorithms as well.



---

archive/issue_comments_269409.json:
```json
{
    "body": "Replying to [comment:2 vdelecroix]:\n> I do not completely understand the end your comment. The code I have written was precisely to avoid any conversion. You can have a look at #19822: there is no type conversion at all (except some `NTL -> FLINT` integer conversions).\n\nYes, I agree that your implementation must be faster. I was thinking in terms of code complexity rather than running time. But if you think the speed difference is worth it, I have no problem with that!\n\n(As for the case of balls, as Fredrik said, arb has code for polynomial evaluation that will likely work better in some cases at least. I'm not against having special code for the evaluation of polynomials with rational coefficients at arb balls, but I think we should first see if the version using `_evaluate_polynomial` is fast enough. The \u201ctemplate approach\u201d you mention looks interesting too.)",
    "created_at": "2016-03-29T08:57:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19604",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19604#issuecomment-269409",
    "user": "mmezzarobba"
}
```

Replying to [comment:2 vdelecroix]:
> I do not completely understand the end your comment. The code I have written was precisely to avoid any conversion. You can have a look at #19822: there is no type conversion at all (except some `NTL -> FLINT` integer conversions).

Yes, I agree that your implementation must be faster. I was thinking in terms of code complexity rather than running time. But if you think the speed difference is worth it, I have no problem with that!

(As for the case of balls, as Fredrik said, arb has code for polynomial evaluation that will likely work better in some cases at least. I'm not against having special code for the evaluation of polynomials with rational coefficients at arb balls, but I think we should first see if the version using `_evaluate_polynomial` is fast enough. The “template approach” you mention looks interesting too.)



---

archive/issue_comments_269410.json:
```json
{
    "body": "Changing keywords from \"\" to \"arb, polynomial\".",
    "created_at": "2019-03-08T02:58:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19604",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19604#issuecomment-269410",
    "user": "slelievre"
}
```

Changing keywords from "" to "arb, polynomial".



---

archive/issue_comments_269411.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to numerical.",
    "created_at": "2019-03-08T02:58:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19604",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19604#issuecomment-269411",
    "user": "slelievre"
}
```

Changing component from PLEASE CHANGE to numerical.
