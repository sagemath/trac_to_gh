# Issue 19123: LatticePoset: add is_vertically_decomposable

archive/issues_018886.json:
```json
{
    "body": "This patch adds a function `is_vertically_decomposable` to finite lattices.\n\nFor testing see https://oeis.org/A058800 ; for example\n\n```\nsum([1 for L in Posets(6) if L.is_lattice() and\n not LatticePoset(L).is_vertically_decomposable()])\n```\n\nreturns 7 as it should.\n\nThere is a place for possible optimization: If there is, say, covering relations `bottom -> 5`, `3 -> 8` and `7 -> top`, is suffices to show that the lattice is not vertically decomposable. This might be faster on average. Now the complexity is linear to number of covering relations.\n\nCC:  @nathanncohen @tscrim @kevindilks\n\nBranch/Commit: bf4d108440d0533d57cd433d0f0432fab630d193\n\nReviewer: Kevin Dilks\n\nAuthor: Jori M\u00e4ntysalo\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/19123\n\n",
    "closed_at": "2016-03-31T18:41:46Z",
    "created_at": "2015-09-01T14:52:35Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.0",
    "title": "LatticePoset: add is_vertically_decomposable",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19123",
    "user": "https://github.com/jm58660"
}
```
This patch adds a function `is_vertically_decomposable` to finite lattices.

For testing see https://oeis.org/A058800 ; for example

```
sum([1 for L in Posets(6) if L.is_lattice() and
 not LatticePoset(L).is_vertically_decomposable()])
```

returns 7 as it should.

There is a place for possible optimization: If there is, say, covering relations `bottom -> 5`, `3 -> 8` and `7 -> top`, is suffices to show that the lattice is not vertically decomposable. This might be faster on average. Now the complexity is linear to number of covering relations.

CC:  @nathanncohen @tscrim @kevindilks

Branch/Commit: bf4d108440d0533d57cd433d0f0432fab630d193

Reviewer: Kevin Dilks

Author: Jori Mäntysalo

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/19123





---

archive/issue_comments_258289.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-09-01T14:56:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258289",
    "user": "https://github.com/jm58660"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_258290.json:
```json
{
    "body": "<a id='comment:2'></a>Quite easy one. Nathann selected as a random victim for a possible reviewer. `:=)`\n\n---\nNew commits:",
    "created_at": "2015-09-01T14:56:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258290",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:2'></a>Quite easy one. Nathann selected as a random victim for a possible reviewer. `:=)`

---
New commits:



---

archive/issue_comments_258291.json:
```json
{
    "body": "<a id='comment:3'></a>Sounds good, but don't you think it may be useful to *know* where the poset splits? Also, why is it only defined for lattices? The algorithm works in all cases.\n\nI did not test it, but from the code's look I am not sure that it works for the chain of length 2, as the docstring indicates. Could you add a doctest for that?\n\nNathann",
    "created_at": "2015-09-01T18:25:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258291",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:3'></a>Sounds good, but don't you think it may be useful to *know* where the poset splits? Also, why is it only defined for lattices? The algorithm works in all cases.

I did not test it, but from the code's look I am not sure that it works for the chain of length 2, as the docstring indicates. Could you add a doctest for that?

Nathann



---

archive/issue_comments_258292.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-01T18:39:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258292",
    "user": "https://github.com/jm58660"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_258293.json:
```json
{
    "body": "<a id='comment:4'></a>Replying to [comment:3 ncohen]:\n\n> Sounds good, but don't you think it may be useful to *know* where the poset splits?\n\n\nYes, I think that will be usefull. For posets we have `is_connected()`, `connected_components()` and `disjoint_union()`. I guess we should have `is_vertically_decomposable()`, `vertically_indecomposable_parts()` and `vertical_sum()` for lattices.\n\nThere are of course other options, like having a function (this one, with an argument?) returning list of \"decomposition elements\". The user could then run `interval()` on them to get parts.\n\n> Also, why is it only defined for lattices? The algorithm works in all cases.\n\n\nHow should it be defined on non-connected posets? And I am not sure if this works with non-bounded posets; I thinked about bounded ones when writing this.\n\n> I did not test it, but from the code's look I am not sure that it works for the chain of length 2, as the docstring indicates. Could you add a doctest for that?\n\n\nArghs! You are right, of course. I forget the special case when writing the code. I'll correct it.\n\n(Btw, this would be nice exercise of (totally unneeded) optimization. One should not need to look for all edged of Hasse diagram to see that a poset is indecomposable.)",
    "created_at": "2015-09-01T18:39:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258293",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:4'></a>Replying to [comment:3 ncohen]:

> Sounds good, but don't you think it may be useful to *know* where the poset splits?


Yes, I think that will be usefull. For posets we have `is_connected()`, `connected_components()` and `disjoint_union()`. I guess we should have `is_vertically_decomposable()`, `vertically_indecomposable_parts()` and `vertical_sum()` for lattices.

There are of course other options, like having a function (this one, with an argument?) returning list of "decomposition elements". The user could then run `interval()` on them to get parts.

> Also, why is it only defined for lattices? The algorithm works in all cases.


How should it be defined on non-connected posets? And I am not sure if this works with non-bounded posets; I thinked about bounded ones when writing this.

> I did not test it, but from the code's look I am not sure that it works for the chain of length 2, as the docstring indicates. Could you add a doctest for that?


Arghs! You are right, of course. I forget the special case when writing the code. I'll correct it.

(Btw, this would be nice exercise of (totally unneeded) optimization. One should not need to look for all edged of Hasse diagram to see that a poset is indecomposable.)



---

archive/issue_comments_258294.json:
```json
{
    "body": "<a id='comment:5'></a>> There are of course other options, like having a function (this one, with an argument?) returning list of \"decomposition elements\". \n\n\n+1 to that.\n\n> How should it be defined on non-connected posets? And I am not sure if this works with non-bounded posets; I thinked about bounded ones when writing this.\n\n\nHmmm, okay okay... I attempted to write a definition, but indeed for non-lattices you have 1000 different corner-cases, and th definition would be a mess.\n\n> (Btw, this would be nice exercise of (totally unneeded) optimization. One should not need to look for all edged of Hasse diagram to see that a poset is indecomposable.)\n\n\nWhat do you mean? Your algorithm looks very reliable. I do not see it waste much.\n\nNathann",
    "created_at": "2015-09-01T18:45:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258294",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:5'></a>> There are of course other options, like having a function (this one, with an argument?) returning list of "decomposition elements". 


+1 to that.

> How should it be defined on non-connected posets? And I am not sure if this works with non-bounded posets; I thinked about bounded ones when writing this.


Hmmm, okay okay... I attempted to write a definition, but indeed for non-lattices you have 1000 different corner-cases, and th definition would be a mess.

> (Btw, this would be nice exercise of (totally unneeded) optimization. One should not need to look for all edged of Hasse diagram to see that a poset is indecomposable.)


What do you mean? Your algorithm looks very reliable. I do not see it waste much.

Nathann



---

archive/issue_comments_258295.json:
```json
{
    "body": "<a id='comment:6'></a>Replying to [comment:5 ncohen]:\n> > There are of course other options, like having a function (this one, with an argument?) returning list of \"decomposition elements\". \n\n> \n> +1 to that.\n\n\nOK. What should be the name of the argument? `certificate`? `give_me_the_list=True`?\n\n> > How should it be defined on non-connected posets? And I am not sure if this works with non-bounded posets; I thinked about bounded ones when writing this.\n\n> \n> Hmmm, okay okay... I attempted to write a definition, but indeed for non-lattices you have 1000 different corner-cases, and th definition would be a mess.\n\n\nExcept for the 2-element lattice there is one simple definition that generalizes this:\n\n```\nany(P.cover_relations_graph().is_cut_vertex(e) for e in P)\n```\n\nBut in any case, it is easy to move this to posets later if we want so.\n\n> > (Btw, this would be nice exercise of (totally unneeded) optimization. One should not need to look for all edged of Hasse diagram to see that a poset is indecomposable.)\n\n> \n> What do you mean? Your algorithm looks very reliable. I do not see it waste much.\n\n\nIf the poset has coverings `2 -> 6` and `4 -> 9`, then no element `3..8` can be a decomposition element. After founding, say, `2 -> 6` we could check `5 ->`, `4 ->` and so on. But after founding `4 -> 9` we should have a somewhat complicated stack to skip re-checking biggest covers of `4` and `5`. I guess that the algorithm would be slower in reality, but I am quite sure that it would be better in some theoretical meaning.",
    "created_at": "2015-09-01T20:02:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258295",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:6'></a>Replying to [comment:5 ncohen]:
> > There are of course other options, like having a function (this one, with an argument?) returning list of "decomposition elements". 

> 
> +1 to that.


OK. What should be the name of the argument? `certificate`? `give_me_the_list=True`?

> > How should it be defined on non-connected posets? And I am not sure if this works with non-bounded posets; I thinked about bounded ones when writing this.

> 
> Hmmm, okay okay... I attempted to write a definition, but indeed for non-lattices you have 1000 different corner-cases, and th definition would be a mess.


Except for the 2-element lattice there is one simple definition that generalizes this:

```
any(P.cover_relations_graph().is_cut_vertex(e) for e in P)
```

But in any case, it is easy to move this to posets later if we want so.

> > (Btw, this would be nice exercise of (totally unneeded) optimization. One should not need to look for all edged of Hasse diagram to see that a poset is indecomposable.)

> 
> What do you mean? Your algorithm looks very reliable. I do not see it waste much.


If the poset has coverings `2 -> 6` and `4 -> 9`, then no element `3..8` can be a decomposition element. After founding, say, `2 -> 6` we could check `5 ->`, `4 ->` and so on. But after founding `4 -> 9` we should have a somewhat complicated stack to skip re-checking biggest covers of `4` and `5`. I guess that the algorithm would be slower in reality, but I am quite sure that it would be better in some theoretical meaning.



---

archive/issue_comments_258296.json:
```json
{
    "body": "<a id='comment:7'></a>> OK. What should be the name of the argument? `certificate`? `give_me_the_list=True`?\n\n\nIsn't there a terminology for those points? If it is only for lattices, maybe you could have `return_cutvertices=True` or something?\n\n> Except for the 2-element lattice there is one simple definition that generalizes this:\n> \n> \n> ```\n> any(P.cover_relations_graph().is_cut_vertex(e) for e in P)\n> ```\n\n\nWouldn't work for a poset on three elements, one being greater than the two others (which are incomparable).\n\n> If the poset has coverings `2 -> 6` and `4 -> 9`, then no element `3..8` can be a decomposition element. After founding, say, `2 -> 6` we could check `5 ->`, `4 ->` and so on. But after founding `4 -> 9` we should have a somewhat complicated stack to skip re-checking biggest covers of `4` and `5`. I guess that the algorithm would be slower in reality, but I am quite sure that it would be better in some theoretical meaning.\n\n\nHMmm... Skipping some edges without additional assumption on the order in which they are returned? I do not know... This is not so bad, for the moment `:-)`\n\nNathann",
    "created_at": "2015-09-01T20:25:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258296",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:7'></a>> OK. What should be the name of the argument? `certificate`? `give_me_the_list=True`?


Isn't there a terminology for those points? If it is only for lattices, maybe you could have `return_cutvertices=True` or something?

> Except for the 2-element lattice there is one simple definition that generalizes this:
> 
> 
> ```
> any(P.cover_relations_graph().is_cut_vertex(e) for e in P)
> ```


Wouldn't work for a poset on three elements, one being greater than the two others (which are incomparable).

> If the poset has coverings `2 -> 6` and `4 -> 9`, then no element `3..8` can be a decomposition element. After founding, say, `2 -> 6` we could check `5 ->`, `4 ->` and so on. But after founding `4 -> 9` we should have a somewhat complicated stack to skip re-checking biggest covers of `4` and `5`. I guess that the algorithm would be slower in reality, but I am quite sure that it would be better in some theoretical meaning.


HMmm... Skipping some edges without additional assumption on the order in which they are returned? I do not know... This is not so bad, for the moment `:-)`

Nathann



---

archive/issue_comments_258297.json:
```json
{
    "body": "<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-02T06:44:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258297",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258298.json:
```json
{
    "body": "<a id='comment:9'></a>You don't have to write this algorithm twice to make it work in all situations. Once is enough. And if you are worried of the cost of a 'if' inside of the loop, then you should not be writing Python code.\n\nFurthermore, be careful with '::' as they are not needed after an INPUT block. Build the doc to check it.\n\nNathann",
    "created_at": "2015-09-02T06:46:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258298",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:9'></a>You don't have to write this algorithm twice to make it work in all situations. Once is enough. And if you are worried of the cost of a 'if' inside of the loop, then you should not be writing Python code.

Furthermore, be careful with '::' as they are not needed after an INPUT block. Build the doc to check it.

Nathann



---

archive/issue_comments_258299.json:
```json
{
    "body": "<a id='comment:10'></a>Now it should work with empty lattice, 1-element lattice and 2-element lattice. There is backend ready for extending the function in `lattices.py`. I may modify it as suggested by Nathann at comment 9. But the more important question:\n\nHow should we exactly define \"decomposing elements\"? Let's start with\n\n```\nPosets.ChainPoset(2).ordinal_sum(Posets.BooleanLattice(3), labels='integers')\n```\n\nIs `0` a decomposing element? What are \"components\" for the lattice? Maybe `0-1`, `1-2` and `2-9`. But then, what are components of 2-element lattice?\n\nReplying to [comment:7 ncohen]:\n> > If the poset has coverings `2 -> 6` and `4 -> 9`, then no element `3..8` can be a decomposition element. After founding, say, `2 -> 6` we could check `5 ->`, `4 ->` and so on. But after founding `4 -> 9` we should have a somewhat complicated stack to skip re-checking biggest covers of `4` and `5`. I guess that the algorithm would be slower in reality, but I am quite sure that it would be better in some theoretical meaning.\n\n> \n> HMmm... Skipping some edges without additional assumption on the order in which they are returned?\n\n\nI dont' mean that. If the lattice has `100` elements, then `0` is the bottom and `99` is the top. If the lattice has coverings `0 -> 37`, `34 -> 88` and `77 -> 99`, then it is not vertically decomposable. There might be faster way to find those coverings than going throught all elements. But the code would be much more complicated.",
    "created_at": "2015-09-02T06:56:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258299",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:10'></a>Now it should work with empty lattice, 1-element lattice and 2-element lattice. There is backend ready for extending the function in `lattices.py`. I may modify it as suggested by Nathann at comment 9. But the more important question:

How should we exactly define "decomposing elements"? Let's start with

```
Posets.ChainPoset(2).ordinal_sum(Posets.BooleanLattice(3), labels='integers')
```

Is `0` a decomposing element? What are "components" for the lattice? Maybe `0-1`, `1-2` and `2-9`. But then, what are components of 2-element lattice?

Replying to [comment:7 ncohen]:
> > If the poset has coverings `2 -> 6` and `4 -> 9`, then no element `3..8` can be a decomposition element. After founding, say, `2 -> 6` we could check `5 ->`, `4 ->` and so on. But after founding `4 -> 9` we should have a somewhat complicated stack to skip re-checking biggest covers of `4` and `5`. I guess that the algorithm would be slower in reality, but I am quite sure that it would be better in some theoretical meaning.

> 
> HMmm... Skipping some edges without additional assumption on the order in which they are returned?


I dont' mean that. If the lattice has `100` elements, then `0` is the bottom and `99` is the top. If the lattice has coverings `0 -> 37`, `34 -> 88` and `77 -> 99`, then it is not vertically decomposable. There might be faster way to find those coverings than going throught all elements. But the code would be much more complicated.



---

archive/issue_comments_258300.json:
```json
{
    "body": "<a id='comment:11'></a>Could you also add to your docstring a reference toward a textbook that defines this notion?",
    "created_at": "2015-09-02T07:11:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258300",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:11'></a>Could you also add to your docstring a reference toward a textbook that defines this notion?



---

archive/issue_comments_258301.json:
```json
{
    "body": "<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-02T10:47:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258301",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258302.json:
```json
{
    "body": "<a id='comment:13'></a>Replying to [comment:11 ncohen]:\n> Could you also add to your docstring a reference toward a textbook that defines this notion?\n\n\nDuh. Counting Finite Lattices by Heitzig and Reinhold defines it \"- - contains an element which is neither the greatest not the least element of L but comparable to every element of L.\" On the other hand, On the number of distributive lattices by Ern\u00e9 and (same) Heitzig and Reinhold says \"- - if it is either a singleton or the vertical sum of two nonempty posets - -\", and vertical sum on two two-element lattice by their definition is the two-element lattice.\n\nI select tscrim as another random victim. Travis, should we define the two-element lattice to be vertically decomposable or indecomposable?\n\n(Or raise `OtherError(\"developers don't know how to define this\")`? `:=)`)",
    "created_at": "2015-09-02T11:12:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258302",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:13'></a>Replying to [comment:11 ncohen]:
> Could you also add to your docstring a reference toward a textbook that defines this notion?


Duh. Counting Finite Lattices by Heitzig and Reinhold defines it "- - contains an element which is neither the greatest not the least element of L but comparable to every element of L." On the other hand, On the number of distributive lattices by Erné and (same) Heitzig and Reinhold says "- - if it is either a singleton or the vertical sum of two nonempty posets - -", and vertical sum on two two-element lattice by their definition is the two-element lattice.

I select tscrim as another random victim. Travis, should we define the two-element lattice to be vertically decomposable or indecomposable?

(Or raise `OtherError("developers don't know how to define this")`? `:=)`)



---

archive/issue_comments_258303.json:
```json
{
    "body": "<a id='comment:14'></a>OEIS uses the definition where the two-element lattice is vertically indecomposable: https://oeis.org/A058800. Does this suffice as a base for the definition?",
    "created_at": "2015-09-09T07:05:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258303",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:14'></a>OEIS uses the definition where the two-element lattice is vertically indecomposable: https://oeis.org/A058800. Does this suffice as a base for the definition?



---

archive/issue_comments_258304.json:
```json
{
    "body": "<a id='comment:15'></a>Helloooooooo !\n\nYeah yeah I guess. Could you just add a link in the doc toward a textbook/paper that defines it the way you use it?\n\n> (Or raise OtherError(\"developers don't know how to define this\")?\n\n\nWe have had very non-enlightening debates here about whether the empty graph is connected or not. In such a situation, I would add such a warning rather than have those stupid conversations `:-P`\nNathann",
    "created_at": "2015-09-09T07:45:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258304",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:15'></a>Helloooooooo !

Yeah yeah I guess. Could you just add a link in the doc toward a textbook/paper that defines it the way you use it?

> (Or raise OtherError("developers don't know how to define this")?


We have had very non-enlightening debates here about whether the empty graph is connected or not. In such a situation, I would add such a warning rather than have those stupid conversations `:-P`
Nathann



---

archive/issue_comments_258305.json:
```json
{
    "body": "<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-09T12:21:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258305",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258306.json:
```json
{
    "body": "<a id='comment:17'></a>This code should now work.\n\nI still don't know how to make the user interface... For posets we have boolean-valued `is_connected()` and subposets-valued `connected_components()`. But what should then be the function returning only \"decomposing elements\". I will ask in sage-devel.\n\nComments on documentation are welcome.",
    "created_at": "2015-09-09T12:29:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258306",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:17'></a>This code should now work.

I still don't know how to make the user interface... For posets we have boolean-valued `is_connected()` and subposets-valued `connected_components()`. But what should then be the function returning only "decomposing elements". I will ask in sage-devel.

Comments on documentation are welcome.



---

archive/issue_comments_258307.json:
```json
{
    "body": "<a id='comment:18'></a>return_type vs return_elements.",
    "created_at": "2015-09-09T12:39:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258307",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:18'></a>return_type vs return_elements.



---

archive/issue_comments_258308.json:
```json
{
    "body": "<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-09T12:43:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258308",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258309.json:
```json
{
    "body": "<a id='comment:20'></a>Replying to [comment:18 ncohen]:\n> return_type vs return_elements.\n\n\nBut they are different things. \"Internal\" function in `hasse_diagram.py` has only one yes/no -argument, so a Boolean seems right. \"Interface\" function in `lattices.py` has three possible inputs.",
    "created_at": "2015-09-09T12:46:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258309",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:20'></a>Replying to [comment:18 ncohen]:
> return_type vs return_elements.


But they are different things. "Internal" function in `hasse_diagram.py` has only one yes/no -argument, so a Boolean seems right. "Interface" function in `lattices.py` has three possible inputs.



---

archive/issue_comments_258310.json:
```json
{
    "body": "<a id='comment:21'></a>> But they are different things. \"Internal\" function in `hasse_diagram.py` has only one yes/no -argument, so a Boolean seems right. \"Interface\" function in `lattices.py` has three possible inputs.\n\n\nSorry, I removed my comment on the argument's type right after I posted it, it was a mistake. The one I left, however, is about the fact that the argument that appears in the doc is not the one that appears in the function's definition.\n\nNathann",
    "created_at": "2015-09-09T12:48:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258310",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:21'></a>> But they are different things. "Internal" function in `hasse_diagram.py` has only one yes/no -argument, so a Boolean seems right. "Interface" function in `lattices.py` has three possible inputs.


Sorry, I removed my comment on the argument's type right after I posted it, it was a mistake. The one I left, however, is about the fact that the argument that appears in the doc is not the one that appears in the function's definition.

Nathann



---

archive/issue_comments_258311.json:
```json
{
    "body": "<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-10T11:03:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258311",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258312.json:
```json
{
    "body": "<a id='comment:23'></a>I will wait until #17226 gets to beta, and then rebase this. (Forgot that it was not there yet.) This will also categorize the index of functions.\n\nI split the function to two parts. I will also wait if somebody comments this on sage-devel. I don't know what should be the name of argument for `vertical_decomposition()`.\n\nSo this is open for comments and *de facto* ready for review, but not *de iure* in needs_review -phase.",
    "created_at": "2015-09-10T11:09:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258312",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:23'></a>I will wait until #17226 gets to beta, and then rebase this. (Forgot that it was not there yet.) This will also categorize the index of functions.

I split the function to two parts. I will also wait if somebody comments this on sage-devel. I don't know what should be the name of argument for `vertical_decomposition()`.

So this is open for comments and *de facto* ready for review, but not *de iure* in needs_review -phase.



---

archive/issue_comments_258313.json:
```json
{
    "body": "<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-11T07:25:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258313",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258314.json:
```json
{
    "body": "<a id='comment:27'></a>OK, here is one possible way to split the functionality. Ready for review.",
    "created_at": "2015-09-11T07:28:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258314",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:27'></a>OK, here is one possible way to split the functionality. Ready for review.



---

archive/issue_comments_258315.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-11T07:28:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258315",
    "user": "https://github.com/jm58660"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_258316.json:
```json
{
    "body": "<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-14T05:00:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258316",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258317.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-14T05:04:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258317",
    "user": "https://github.com/jm58660"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_258318.json:
```json
{
    "body": "<a id='comment:29'></a>Replying to [comment:9 ncohen]:\n> You don't have to write this algorithm twice to make it work in all situations. Once is enough.\n\n\nDone this. Compiling, will change to needs_review if this seems to work.",
    "created_at": "2015-09-14T05:04:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258318",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:29'></a>Replying to [comment:9 ncohen]:
> You don't have to write this algorithm twice to make it work in all situations. Once is enough.


Done this. Compiling, will change to needs_review if this seems to work.



---

archive/issue_comments_258319.json:
```json
{
    "body": "<a id='comment:30'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-14T05:42:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258319",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:30'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258320.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-14T05:44:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258320",
    "user": "https://github.com/jm58660"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_258321.json:
```json
{
    "body": "<a id='comment:31'></a>And yes, there was a bug. Now at last this should be ready for review.\n\n(Thematic index of functions might look unnecessary for now. However, see #19197, #19197 etc.)",
    "created_at": "2015-09-14T05:44:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258321",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:31'></a>And yes, there was a bug. Now at last this should be ready for review.

(Thematic index of functions might look unnecessary for now. However, see #19197, #19197 etc.)



---

archive/issue_comments_258322.json:
```json
{
    "body": "<a id='comment:32'></a>Nathann, what about this. You already read the code and the 2-element lattice case is now documented. Hence there is two questions left:\n\n- Is the thematic index of functions OK in lattices?\n- Is this splitting of functionality OK?",
    "created_at": "2015-09-19T12:41:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258322",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:32'></a>Nathann, what about this. You already read the code and the 2-element lattice case is now documented. Hence there is two questions left:

- Is the thematic index of functions OK in lattices?
- Is this splitting of functionality OK?



---

archive/issue_comments_258323.json:
```json
{
    "body": "<a id='comment:33'></a>Jori,\n\nI thought a bit before answering your email, because the reason I had not done\nanything on the ticket during the last 6 days is that I had chosen to not work\non it anymore. I do not often \"forget\" things like tickets in needs_review: my\nmail inbox contains all the things I must attend to, and they all remain there\nuntil I do what I think I should do with them.\n\nAmong the reasons that led me there is that nothing specific makes your code\ninvalid, and I have no reason to ask you to change it just because it does not\nsuit my taste. I like things short, simple, concise. Three functions for only\none feature is beyond me, it angers me by itself.\n\nIf I were to write it, you would have one Lattice method which would directly\nwork on the hasse diagram, with a `return_recomposition` boolean flag to return\nlists instead of boolean answers. One function, 20 lines, end of the story.\n\nRight now, the Lattice method `vertical_decomposition` contains around 20 lines\nof code, none of which has the slightest interest to me. It's just wrapping\nthings into other things, and testing things that are already tested elsewhere.\n\nWhat I know, however, is that it is impossible for you to get any kind of code\ninto Sage and to work with it unless you have somebody to review your code. I\nsurely know that. Depending on what I work on, depending on the times, it is\neither easy or hard to get anything in there, and from time to time I think that\nit would be better if you were allowed to put any code that you like into Sage\nwithout needing reviewers like me who drag their feet at every occasion.\n\nAlso, I admit that I do not have the energy to discuss the implementation\ndetails endlessly, and I also hate that this process may require you to\nimplement code only because the only reviewer you have has a different taste.\n\nTruth is, I don't want to be the reason why you cannot work properly on Sage's\ncode, and I don't have a lot of ways out as not many would do the reviewing job\notherwise. So I will try this: I will implement this as is the most natural to\nme, and you can feel free to not use it if you do not like it. Let's see how it\nworks.\n\nSorry for the painful reviews.\n\nNathann\n\nP.S.: the code is at u/ncohen/19123",
    "created_at": "2015-09-20T11:33:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258323",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:33'></a>Jori,

I thought a bit before answering your email, because the reason I had not done
anything on the ticket during the last 6 days is that I had chosen to not work
on it anymore. I do not often "forget" things like tickets in needs_review: my
mail inbox contains all the things I must attend to, and they all remain there
until I do what I think I should do with them.

Among the reasons that led me there is that nothing specific makes your code
invalid, and I have no reason to ask you to change it just because it does not
suit my taste. I like things short, simple, concise. Three functions for only
one feature is beyond me, it angers me by itself.

If I were to write it, you would have one Lattice method which would directly
work on the hasse diagram, with a `return_recomposition` boolean flag to return
lists instead of boolean answers. One function, 20 lines, end of the story.

Right now, the Lattice method `vertical_decomposition` contains around 20 lines
of code, none of which has the slightest interest to me. It's just wrapping
things into other things, and testing things that are already tested elsewhere.

What I know, however, is that it is impossible for you to get any kind of code
into Sage and to work with it unless you have somebody to review your code. I
surely know that. Depending on what I work on, depending on the times, it is
either easy or hard to get anything in there, and from time to time I think that
it would be better if you were allowed to put any code that you like into Sage
without needing reviewers like me who drag their feet at every occasion.

Also, I admit that I do not have the energy to discuss the implementation
details endlessly, and I also hate that this process may require you to
implement code only because the only reviewer you have has a different taste.

Truth is, I don't want to be the reason why you cannot work properly on Sage's
code, and I don't have a lot of ways out as not many would do the reviewing job
otherwise. So I will try this: I will implement this as is the most natural to
me, and you can feel free to not use it if you do not like it. Let's see how it
works.

Sorry for the painful reviews.

Nathann

P.S.: the code is at u/ncohen/19123



---

archive/issue_comments_258324.json:
```json
{
    "body": "<a id='comment:34'></a>Hmm... I continue to think. Or hope that somebody else reviews this.\n\nI hope that having this on `hasse_diagram.py` is useful later - it can be a quick optimization before `frattini_sublattice`.",
    "created_at": "2015-09-20T15:55:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258324",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:34'></a>Hmm... I continue to think. Or hope that somebody else reviews this.

I hope that having this on `hasse_diagram.py` is useful later - it can be a quick optimization before `frattini_sublattice`.



---

archive/issue_comments_258325.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-28T16:58:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258325",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_258326.json:
```json
{
    "body": "<a id='comment:35'></a>does not apply, needs rebase",
    "created_at": "2015-09-28T16:58:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258326",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:35'></a>does not apply, needs rebase



---

archive/issue_comments_258327.json:
```json
{
    "body": "<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-09-28T17:34:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258327",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258328.json:
```json
{
    "body": "<a id='comment:37'></a>Err. Terminology nazi here: what you did is a 'merge'. A rebase is a difference operation which moves the commits around.\n\nNathann",
    "created_at": "2015-09-28T17:37:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258328",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:37'></a>Err. Terminology nazi here: what you did is a 'merge'. A rebase is a difference operation which moves the commits around.

Nathann



---

archive/issue_comments_258329.json:
```json
{
    "body": "<a id='comment:38'></a>Merged. Sorry for wrong term.",
    "created_at": "2015-09-28T17:38:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258329",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:38'></a>Merged. Sorry for wrong term.



---

archive/issue_comments_258330.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-09-28T17:38:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258330",
    "user": "https://github.com/jm58660"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_258331.json:
```json
{
    "body": "<a id='comment:39'></a>Kevin, if you are interested in docs, you might want to review this. It does some polishing together with adding little new functionality.",
    "created_at": "2015-09-30T17:45:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258331",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:39'></a>Kevin, if you are interested in docs, you might want to review this. It does some polishing together with adding little new functionality.



---

archive/issue_comments_258332.json:
```json
{
    "body": "<a id='comment:40'></a>I still think that formal definitions should come first, without being labelled as formal definitions, and then informal definitions can come after.",
    "created_at": "2015-10-10T20:56:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258332",
    "user": "https://github.com/kevindilks"
}
```

<a id='comment:40'></a>I still think that formal definitions should come first, without being labelled as formal definitions, and then informal definitions can come after.



---

archive/issue_comments_258333.json:
```json
{
    "body": "<a id='comment:41'></a>I'm not sure if I like the backend code living in `hasse_diagram.py`. Even if the code  applies to more than lattices, you seem to still be making assumptions about the poset being bounded. Plus the initial docstring there is written in a way that implies it only works for lattices.",
    "created_at": "2015-10-10T21:10:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258333",
    "user": "https://github.com/kevindilks"
}
```

<a id='comment:41'></a>I'm not sure if I like the backend code living in `hasse_diagram.py`. Even if the code  applies to more than lattices, you seem to still be making assumptions about the poset being bounded. Plus the initial docstring there is written in a way that implies it only works for lattices.



---

archive/issue_comments_258334.json:
```json
{
    "body": "<a id='comment:42'></a>Replying to [comment:40 kdilks]:\n> I still think that formal definitions should come first, without being labelled as formal definitions, and then informal definitions can come after.\n\n\nOK, I can change that.\n\nReplying to [comment:41 kdilks]:\n> I'm not sure if I like the backend code living in `hasse_diagram.py`. Even if the code  applies to more than lattices, you seem to still be making assumptions about the poset being bounded. Plus the initial docstring there is written in a way that implies it only works for lattices.\n\n\nI think that all code in `hasse_diagram.py` is \"internal\", i.e. it is user's fault if something break for direct call to it.\n\nIf this is not in `hasse_diagram.py`, then I guess it must be copied if I want to optimize `frattini_sublattice()` with it. Or `linear_extensions_number()` maybe?",
    "created_at": "2015-10-12T08:46:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258334",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:42'></a>Replying to [comment:40 kdilks]:
> I still think that formal definitions should come first, without being labelled as formal definitions, and then informal definitions can come after.


OK, I can change that.

Replying to [comment:41 kdilks]:
> I'm not sure if I like the backend code living in `hasse_diagram.py`. Even if the code  applies to more than lattices, you seem to still be making assumptions about the poset being bounded. Plus the initial docstring there is written in a way that implies it only works for lattices.


I think that all code in `hasse_diagram.py` is "internal", i.e. it is user's fault if something break for direct call to it.

If this is not in `hasse_diagram.py`, then I guess it must be copied if I want to optimize `frattini_sublattice()` with it. Or `linear_extensions_number()` maybe?



---

archive/issue_comments_258335.json:
```json
{
    "body": "<a id='comment:43'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-21T04:56:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258335",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:43'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258336.json:
```json
{
    "body": "<a id='comment:44'></a>Better docstring now?\n\nIf this seems hard one to decide, then I can split the (non-relating) part that rearranges the index of functions.",
    "created_at": "2015-10-21T04:57:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258336",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:44'></a>Better docstring now?

If this seems hard one to decide, then I can split the (non-relating) part that rearranges the index of functions.



---

archive/issue_comments_258337.json:
```json
{
    "body": "<a id='comment:45'></a>`ping -c 1 Kevin`. This could be nice to have before #18511, as this modifies the index of function.\n\n(Funny. I have a poset of dependencies between poset-related tickets.)",
    "created_at": "2015-11-01T19:15:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258337",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:45'></a>`ping -c 1 Kevin`. This could be nice to have before #18511, as this modifies the index of function.

(Funny. I have a poset of dependencies between poset-related tickets.)



---

archive/issue_comments_258338.json:
```json
{
    "body": "<a id='comment:46'></a>Replying to [comment:3 ncohen]:\n> Also, why is it only defined for lattices? The algorithm works in all cases.\n\n\nHere is a kind of followup: #19659. I think that it is most natural generalization to all posets.",
    "created_at": "2015-12-04T19:42:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258338",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:46'></a>Replying to [comment:3 ncohen]:
> Also, why is it only defined for lattices? The algorithm works in all cases.


Here is a kind of followup: #19659. I think that it is most natural generalization to all posets.



---

archive/issue_events_053133.json:
```json
{
    "actor": "https://github.com/jm58660",
    "created_at": "2016-01-11T16:12:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "milestone": "sage-7.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19123#event-53133"
}
```



---

archive/issue_comments_258339.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-01-11T16:12:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258339",
    "user": "https://github.com/jm58660"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_258340.json:
```json
{
    "body": "<a id='comment:47'></a>Documentation part (i.e. index of functions) done in #19854, so this one needs work.\n\nAlso this should be thinked about. There is also #19659 waiting, and in principle it is same thing as this one; a poset that is also a lattice can be expressed as an ordinal sum of two posets only if it vertically decomposable. At least http://users.cecs.anu.edu.au/~bdm/papers/posets.pdf by Brinkmann and McKay uses term \"vertically decomposable\" with non-lattice posets.\n\n(Actually after #19659 it is easy to make a simple function for #19215, and then use it as a \"precompiler\" for #14126. But that's another story.)",
    "created_at": "2016-01-11T16:12:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258340",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:47'></a>Documentation part (i.e. index of functions) done in #19854, so this one needs work.

Also this should be thinked about. There is also #19659 waiting, and in principle it is same thing as this one; a poset that is also a lattice can be expressed as an ordinal sum of two posets only if it vertically decomposable. At least http://users.cecs.anu.edu.au/~bdm/papers/posets.pdf by Brinkmann and McKay uses term "vertically decomposable" with non-lattice posets.

(Actually after #19659 it is easy to make a simple function for #19215, and then use it as a "precompiler" for #14126. But that's another story.)



---

archive/issue_comments_258341.json:
```json
{
    "body": "<a id='comment:48'></a>New commits:",
    "created_at": "2016-03-14T19:33:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258341",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:48'></a>New commits:



---

archive/issue_comments_258342.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-03-14T19:33:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258342",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_258343.json:
```json
{
    "body": "<a id='comment:49'></a>Minor grammatical corrections:\n\n* In `vertical_decomposition()`, 'Let `d_1, \\ldots , d_n` be elements comparable to every element of the lattice, excluding the top and bottom elements.' Should be rephrased as 'Let `d_1, \\ldots, d_n` be elements (excluding the top and bottom elements) comparable to every element of the lattice.' The original version makes it sound like the top and bottom elements are being excluded from the set of things that `d_1...d_n` need to be comparable to, instead of being excluded from the set `d_1...d_n` itself.\n\n\n* Immediately following that, 'Let `b` be THE bottom element and `t` be the top element.'\n\n* 'Informally said, this returns the lattice SPLIT INTO parts AT every single-element \"cutting point\".'\n\n* Under `INPUT:`, 'return the list OF decomposing elements'.\n\n* In the definition of `is_vertically_decomposable()`, 'A lattice is vertically decomposable if it has an element that is comparable to all elements and is NEITHER the bottom NOR the top element.'\n\nBesides that, I think I'm happy with it. I'll just need to check the rendered documentation once those changes are made.",
    "created_at": "2016-03-29T22:44:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258343",
    "user": "https://github.com/kevindilks"
}
```

<a id='comment:49'></a>Minor grammatical corrections:

* In `vertical_decomposition()`, 'Let `d_1, \ldots , d_n` be elements comparable to every element of the lattice, excluding the top and bottom elements.' Should be rephrased as 'Let `d_1, \ldots, d_n` be elements (excluding the top and bottom elements) comparable to every element of the lattice.' The original version makes it sound like the top and bottom elements are being excluded from the set of things that `d_1...d_n` need to be comparable to, instead of being excluded from the set `d_1...d_n` itself.


* Immediately following that, 'Let `b` be THE bottom element and `t` be the top element.'

* 'Informally said, this returns the lattice SPLIT INTO parts AT every single-element "cutting point".'

* Under `INPUT:`, 'return the list OF decomposing elements'.

* In the definition of `is_vertically_decomposable()`, 'A lattice is vertically decomposable if it has an element that is comparable to all elements and is NEITHER the bottom NOR the top element.'

Besides that, I think I'm happy with it. I'll just need to check the rendered documentation once those changes are made.



---

archive/issue_comments_258344.json:
```json
{
    "body": "<a id='comment:50'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-30T04:34:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258344",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:50'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_258345.json:
```json
{
    "body": "<a id='comment:51'></a>Replying to [comment:49 kdilks]:\n> Minor grammatical corrections:\n\n\nThanks! Done those.\n\n> * 'Informally said, this returns the lattice SPLIT INTO parts AT every single-element \"cutting point\".'\n\n\nThese are hard ones... In Finnish 'hila'='lattice', 'hilassani'='in my lattice' etc.",
    "created_at": "2016-03-30T04:39:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258345",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:51'></a>Replying to [comment:49 kdilks]:
> Minor grammatical corrections:


Thanks! Done those.

> * 'Informally said, this returns the lattice SPLIT INTO parts AT every single-element "cutting point".'


These are hard ones... In Finnish 'hila'='lattice', 'hilassani'='in my lattice' etc.



---

archive/issue_comments_258346.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-03-30T18:04:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258346",
    "user": "https://github.com/kevindilks"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_053134.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-03-31T18:41:46Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19123#event-53134"
}
```



---

archive/issue_comments_258347.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-03-31T18:41:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19123",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19123#issuecomment-258347",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
