# Issue 19014: Tarjan Strongly Connected Components Algorithm

archive/issues_018777.json:
```json
{
    "assignees": [],
    "body": "<div id=\"comment:0\"></div>\n\nImplement Tarjan's Strongly Connected Components algorithm. For more information, see !https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm.\n\nCC:  @nathanncohen @dcoudert\n\nComponent: **graph theory**\n\nKeywords: **Strongly connected components, Tarjan**\n\nAuthor: **Michele Borassi**\n\nBranch: **[`83b8057`](https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c)**\n\nReviewer: **David Coudert**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/19014_\n\n",
    "closed_at": "2015-08-21T01:56:19Z",
    "created_at": "2015-08-12T09:17:16Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20graph%20theory",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.9",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Tarjan Strongly Connected Components Algorithm",
    "type": "issue",
    "updated_at": "2017-06-03T10:36:58Z",
    "url": "https://github.com/sagemath/sage/issues/19014",
    "user": "https://github.com/sagetrac-borassi"
}
```
<div id="comment:0"></div>

Implement Tarjan's Strongly Connected Components algorithm. For more information, see !https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm.

CC:  @nathanncohen @dcoudert

Component: **graph theory**

Keywords: **Strongly connected components, Tarjan**

Author: **Michele Borassi**

Branch: **[`83b8057`](https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c)**

Reviewer: **David Coudert**

_Issue created by migration from https://trac.sagemath.org/ticket/19014_





---

archive/issue_events_267465.json:
```json
{
    "actor": "https://github.com/sagetrac-borassi",
    "created_at": "2015-08-12T09:17:16Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "milestone_number": null,
    "milestone_title": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267465"
}
```



---

archive/issue_events_267466.json:
```json
{
    "actor": "https://github.com/sagetrac-borassi",
    "created_at": "2015-08-12T09:17:16Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267466"
}
```



---

archive/issue_events_267467.json:
```json
{
    "actor": "https://github.com/sagetrac-borassi",
    "created_at": "2015-08-12T09:20:11Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20graph%20theory",
    "label_color": "0000ff",
    "label_name": "c: graph theory",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267467"
}
```



---

archive/issue_comments_267539.json:
```json
{
    "body": "Author: **Michele Borassi**",
    "created_at": "2015-08-12T09:20:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267539",
    "user": "https://github.com/sagetrac-borassi"
}
```

Author: **Michele Borassi**



---

archive/issue_comments_267540.json:
```json
{
    "body": "Changed keywords from none to **Strongly connected components, Tarjan**",
    "created_at": "2015-08-12T09:20:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267540",
    "user": "https://github.com/sagetrac-borassi"
}
```

Changed keywords from none to **Strongly connected components, Tarjan**



---

archive/issue_events_267468.json:
```json
{
    "actor": "https://github.com/sagetrac-borassi",
    "created_at": "2015-08-12T09:20:11Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267468"
}
```



---

archive/issue_comments_267541.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1 +1 @@\n-\n+Implement Tarjan's Strongly Connected Components algorithm. For more information, see !https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm.\n``````\n",
    "created_at": "2015-08-12T09:20:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267541",
    "user": "https://github.com/sagetrac-borassi"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1 +1 @@
-
+Implement Tarjan's Strongly Connected Components algorithm. For more information, see !https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm.
``````




---

archive/issue_comments_267542.json:
```json
{
    "body": "Branch: **[u/borassi/tarjan_strongly_connected_components_algorithm](https://github.com/sagemath/sagetrac-mirror/tree/u/borassi/tarjan_strongly_connected_components_algorithm)**",
    "created_at": "2015-08-13T13:37:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267542",
    "user": "https://github.com/sagetrac-borassi"
}
```

Branch: **[u/borassi/tarjan_strongly_connected_components_algorithm](https://github.com/sagemath/sagetrac-mirror/tree/u/borassi/tarjan_strongly_connected_components_algorithm)**



---

archive/issue_comments_267543.json:
```json
{
    "body": "Commit: **[`8df530a`](https://github.com/sagemath/sagetrac-mirror/commit/8df530ab5c761501b10ba397e361889b4be91833)**",
    "created_at": "2015-08-13T13:39:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267543",
    "user": "https://github.com/sagetrac-git"
}
```

Commit: **[`8df530a`](https://github.com/sagemath/sagetrac-mirror/commit/8df530ab5c761501b10ba397e361889b4be91833)**



---

archive/issue_comments_267544.json:
```json
{
    "body": "<div id=\"comment:3\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8df530ab5c761501b10ba397e361889b4be91833\"><code>8df530a</code></a></td><td><code>First draft of Tarjan's SCC algorithm</code></td></tr></table>\n",
    "created_at": "2015-08-13T13:39:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267544",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:3"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8df530ab5c761501b10ba397e361889b4be91833"><code>8df530a</code></a></td><td><code>First draft of Tarjan's SCC algorithm</code></td></tr></table>




---

archive/issue_events_267469.json:
```json
{
    "actor": "https://github.com/sagetrac-borassi",
    "created_at": "2015-08-13T13:49:32Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267469"
}
```



---

archive/issue_comments_267545.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nHi!\n\nI think Sage was really missing a linear-time algorithm for strongly connected components (in particular, I implemented it because I need it for other algorithms). It improves a lot the old algorithm when the graph has many components, but it is a bit slower when the graph is connected, as shown by the following examples. In any case, I removed the old algorithm: I know that it might have been faster in some rare cases, but the difference is small, and the time spent to input the graph is usually bigger than the time needed to run this algorithm.\n\nDo you like it?\n\nMichele\n\n```\nOld algorithm\nsage: g = digraphs.RandomDirectedGNM(10000,30000)\nsage: %timeit g.strongly_connected_components()\n100 loops, best of 3: 18.3 ms per loop\nNew algorithm\nsage: g = digraphs.RandomDirectedGNM(10000,30000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 5.61 s per loop\n\nOld algorithm\nsage: g = digraphs.Circuit(100000)\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 98.4 ms per loop\nNew algorithm\nsage: g = digraphs.Circuit(100000)\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 183 ms per loop\n```",
    "created_at": "2015-08-13T13:49:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267545",
    "user": "https://github.com/sagetrac-borassi"
}
```

<div id="comment:4" align="right">comment:4</div>

Hi!

I think Sage was really missing a linear-time algorithm for strongly connected components (in particular, I implemented it because I need it for other algorithms). It improves a lot the old algorithm when the graph has many components, but it is a bit slower when the graph is connected, as shown by the following examples. In any case, I removed the old algorithm: I know that it might have been faster in some rare cases, but the difference is small, and the time spent to input the graph is usually bigger than the time needed to run this algorithm.

Do you like it?

Michele

```
Old algorithm
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
100 loops, best of 3: 18.3 ms per loop
New algorithm
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 5.61 s per loop

Old algorithm
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 98.4 ms per loop
New algorithm
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 183 ms per loop
```



---

archive/issue_comments_267546.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nHello,\n\nYou have inverted the timing for GNM. I got\n\n```\nOLD algorithm\nsage: set_random_seed(0)\nsage: g = digraphs.RandomDirectedGNM(10000,30000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 7.87 s per loop\nsage: g.add_cycle(g.vertices())\nsage: %timeit g.strongly_connected_components()\n100 loops, best of 3: 21 ms per loop\nsage: g = digraphs.Circuit(100000)\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 142 ms per loop\n\nNEW algorithm\nsage: set_random_seed(0)\nsage: g = digraphs.RandomDirectedGNM(10000,30000)\nsage: %timeit g.strongly_connected_components()\n100 loops, best of 3: 21.5 ms per loop\nsage: g.add_cycle(g.vertices())\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 22.1 ms per loop\nsage: g = digraphs.Circuit(100000)\nsage: %timeit g.strongly_connected_components()\n10 loops, best of 3: 260 ms per loop\n```\n\nI agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.\n\nI have some remarks:\n- Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?\n- What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?\n- You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?\n- Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`\n- In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.\n- I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like\n\n```\nd = {i:list() for i in range(nscc)}\nfor u,i in scc.iteritems():\n    d[i].append(u)\noutput = [d[i] for i in range(nscc)]\n```\n\nDavid.",
    "created_at": "2015-08-13T16:40:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267546",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:5" align="right">comment:5</div>

Hello,

You have inverted the timing for GNM. I got

```
OLD algorithm
sage: set_random_seed(0)
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 7.87 s per loop
sage: g.add_cycle(g.vertices())
sage: %timeit g.strongly_connected_components()
100 loops, best of 3: 21 ms per loop
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 142 ms per loop

NEW algorithm
sage: set_random_seed(0)
sage: g = digraphs.RandomDirectedGNM(10000,30000)
sage: %timeit g.strongly_connected_components()
100 loops, best of 3: 21.5 ms per loop
sage: g.add_cycle(g.vertices())
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 22.1 ms per loop
sage: g = digraphs.Circuit(100000)
sage: %timeit g.strongly_connected_components()
10 loops, best of 3: 260 ms per loop
```

I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.

I have some remarks:
- Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?
- What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?
- You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?
- Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`
- In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.
- I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like

```
d = {i:list() for i in range(nscc)}
for u,i in scc.iteritems():
    d[i].append(u)
output = [d[i] for i in range(nscc)]
```

David.



---

archive/issue_comments_267547.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\n> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.\n\nIs there any slowdown for `is_strongly_connected`?\n\nNathann",
    "created_at": "2015-08-13T17:07:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267547",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:6" align="right">comment:6</div>

> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.

Is there any slowdown for `is_strongly_connected`?

Nathann



---

archive/issue_comments_267548.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nI don't see any slowdown, But there is room for improvements...\n- Without this patch\n\n```\nsage: set_random_seed(0)\nsage: D = digraphs.RandomDirectedGNM(10000,50000)\nsage: %timeit D.is_strongly_connected()\n100 loops, best of 3: 10.2 ms per loop\nsage: D.add_cycle(D.vertices())\nsage: %timeit D.is_strongly_connected()\n10 loops, best of 3: 20.9 ms per loop\n```\n- With this patch\n\n```\nsage: set_random_seed(0)\nsage: D = digraphs.RandomDirectedGNM(10000,50000)\nsage: %timeit D.is_strongly_connected()\n100 loops, best of 3: 9.98 ms per loop\nsage: D.add_cycle(D.vertices())\nsage: %timeit D.is_strongly_connected()\n10 loops, best of 3: 22 ms per loop\n```\n\nDavid.",
    "created_at": "2015-08-13T17:25:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267548",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:7" align="right">comment:7</div>

I don't see any slowdown, But there is room for improvements...
- Without this patch

```
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(10000,50000)
sage: %timeit D.is_strongly_connected()
100 loops, best of 3: 10.2 ms per loop
sage: D.add_cycle(D.vertices())
sage: %timeit D.is_strongly_connected()
10 loops, best of 3: 20.9 ms per loop
```
- With this patch

```
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(10000,50000)
sage: %timeit D.is_strongly_connected()
100 loops, best of 3: 9.98 ms per loop
sage: D.add_cycle(D.vertices())
sage: %timeit D.is_strongly_connected()
10 loops, best of 3: 22 ms per loop
```

David.



---

archive/issue_comments_267549.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nOkayokay, it seems orthogonal. Thanks!",
    "created_at": "2015-08-13T17:28:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267549",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:8" align="right">comment:8</div>

Okayokay, it seems orthogonal. Thanks!



---

archive/issue_comments_267550.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nWell, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.\nWe need a backward BFS/DFS to get ride of this dependency.",
    "created_at": "2015-08-13T17:36:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267550",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:9" align="right">comment:9</div>

Well, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.
We need a backward BFS/DFS to get ride of this dependency.



---

archive/issue_comments_267551.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nHello!\n\nI think that the method `is_strongly_connected` does not depend on this patch, and what you are proposing is already implemented in routine `is_strongly_connected` in `c_graph` (which also saves some time since it does not copy the whole graph). \n\nIndeed, this method is much simpler than computing SCCs: it performs a forward and backward visit from any node, and sees if we reach all vertices. Hence, I think it should be left as it is. For completeness, I attach the code of this routine.\n\nSoon I will correct all the issues you raised in comment 5!\n\nSee you,\n\nMichele\n\n```\n\u00a0\u00a0\u00a0 def is_strongly_connected(self):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cdef int v_int = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cdef CGraph cg = self._cg\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 # Pick one vertex\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 v_int = bitset_first(cg.active_vertices)\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if v_int == -1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return True\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 v = self.vertex_label(v_int)\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cdef int n = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for _ in self.depth_first_search(v):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 n += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if cg.num_verts != n:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return False\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 n = 0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 for _ in self.depth_first_search(v, reverse=True):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 n += 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return cg.num_verts == n\n```\nReplying to [@dcoudert](#comment%3A9):\n\n> Well, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.\n> We need a backward BFS/DFS to get ride of this dependency.",
    "created_at": "2015-08-14T08:09:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267551",
    "user": "https://github.com/sagetrac-borassi"
}
```

<div id="comment:10" align="right">comment:10</div>

Hello!

I think that the method `is_strongly_connected` does not depend on this patch, and what you are proposing is already implemented in routine `is_strongly_connected` in `c_graph` (which also saves some time since it does not copy the whole graph). 

Indeed, this method is much simpler than computing SCCs: it performs a forward and backward visit from any node, and sees if we reach all vertices. Hence, I think it should be left as it is. For completeness, I attach the code of this routine.

Soon I will correct all the issues you raised in comment 5!

See you,

Michele

```
    def is_strongly_connected(self):
        cdef int v_int = 0
        cdef CGraph cg = self._cg

        # Pick one vertex
        v_int = bitset_first(cg.active_vertices)

        if v_int == -1:
            return True

        v = self.vertex_label(v_int)

        cdef int n = 0
        for _ in self.depth_first_search(v):
            n += 1
        if cg.num_verts != n:
            return False
        n = 0
        for _ in self.depth_first_search(v, reverse=True):
            n += 1
        return cg.num_verts == n
```
Replying to [@dcoudert](#comment%3A9):

> Well, if you look at the code you will see that it is not so orthogonal: if the backend has the method, we use it. Otherwise we count the number of scc, and so we rely on this ticket.
> We need a backward BFS/DFS to get ride of this dependency.



---

archive/issue_comments_267552.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nReplying to [@dcoudert](#comment%3A5):\n\n> Hello,\n> \n> You have inverted the timing for GNM. I got\n> \n> ```\n> OLD algorithm\n> sage: set_random_seed(0)\n> sage: g = digraphs.RandomDirectedGNM(10000,30000)\n> sage: %timeit g.strongly_connected_components()\n> 1 loops, best of 3: 7.87 s per loop\n> sage: g.add_cycle(g.vertices())\n> sage: %timeit g.strongly_connected_components()\n> 100 loops, best of 3: 21 ms per loop\n> sage: g = digraphs.Circuit(100000)\n> sage: %timeit g.strongly_connected_components()\n> 10 loops, best of 3: 142 ms per loop\n> \n> NEW algorithm\n> sage: set_random_seed(0)\n> sage: g = digraphs.RandomDirectedGNM(10000,30000)\n> sage: %timeit g.strongly_connected_components()\n> 100 loops, best of 3: 21.5 ms per loop\n> sage: g.add_cycle(g.vertices())\n> sage: %timeit g.strongly_connected_components()\n> 10 loops, best of 3: 22.1 ms per loop\n> sage: g = digraphs.Circuit(100000)\n> sage: %timeit g.strongly_connected_components()\n> 10 loops, best of 3: 260 ms per loop\n> ```\n> \n> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.\n\nUps, sorry! Clearly, the fastest method was the new one.\n\n> I have some remarks:\n> - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?\n\nYes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?\n\n> - What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?\n\nYou are right: I have moved all the code in `static_sparse_graph.pyx`, and I removed the dictionary. In order to import the method to DiGraph, I used types.methodtype.\n\n> - You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?\n\nYou are right, it is an old remnant of old routines, used only in a test. I removed everything.\n\n> - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`\n\nHmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.\n\n> - In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.\n\nSince I removed the bitsets, now I use `MemoryAllocator`.\n\n> - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like\n> \n> ```\n> d = {i:list() for i in range(nscc)}\n> for u,i in scc.iteritems():\n> d[i].append(u)\n> output = [d[i] for i in range(nscc)]\n> ```\n\nWell, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.\n\n```\nWITH NUMPY\nsage: g = DiGraph(10000000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 9.44 s per loop\n\nWITH DICTIONARIES\nsage: g = DiGraph(10000000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 9.87 s per loop\n```\n> David.\n\n[1] !http://arxiv.org/abs/1507.01490",
    "created_at": "2015-08-14T09:09:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267552",
    "user": "https://github.com/sagetrac-borassi"
}
```

<div id="comment:11" align="right">comment:11</div>

Replying to [@dcoudert](#comment%3A5):

> Hello,
> 
> You have inverted the timing for GNM. I got
> 
> ```
> OLD algorithm
> sage: set_random_seed(0)
> sage: g = digraphs.RandomDirectedGNM(10000,30000)
> sage: %timeit g.strongly_connected_components()
> 1 loops, best of 3: 7.87 s per loop
> sage: g.add_cycle(g.vertices())
> sage: %timeit g.strongly_connected_components()
> 100 loops, best of 3: 21 ms per loop
> sage: g = digraphs.Circuit(100000)
> sage: %timeit g.strongly_connected_components()
> 10 loops, best of 3: 142 ms per loop
> 
> NEW algorithm
> sage: set_random_seed(0)
> sage: g = digraphs.RandomDirectedGNM(10000,30000)
> sage: %timeit g.strongly_connected_components()
> 100 loops, best of 3: 21.5 ms per loop
> sage: g.add_cycle(g.vertices())
> sage: %timeit g.strongly_connected_components()
> 10 loops, best of 3: 22.1 ms per loop
> sage: g = digraphs.Circuit(100000)
> sage: %timeit g.strongly_connected_components()
> 10 loops, best of 3: 260 ms per loop
> ```
> 
> I agree that the gain for non-strongly connected digraphs is so high that it is worth the small increase for strongly connected digraphs.

Ups, sorry! Clearly, the fastest method was the new one.

> I have some remarks:
> - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?

Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?

> - What's the need for returning a dictionary? it is immediately converted to a list of lists in `strongly_connected_components`. Do you need this feature for something else?

You are right: I have moved all the code in `static_sparse_graph.pyx`, and I removed the dictionary. In order to import the method to DiGraph, I used types.methodtype.

> - You have let another version of `strongly_connected_components` in `static_sparse_graph.pyx`. Is this method used somewhere?

You are right, it is an old remnant of old routines, used only in a test. I removed everything.

> - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`

Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.

> - In `_strongly_connected_components_digraph` you have but you don't use `MemoryAllocator`. Here also, you could use array of shorts instead of bitset.

Since I removed the bitsets, now I use `MemoryAllocator`.

> - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like
> 
> ```
> d = {i:list() for i in range(nscc)}
> for u,i in scc.iteritems():
> d[i].append(u)
> output = [d[i] for i in range(nscc)]
> ```

Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.

```
WITH NUMPY
sage: g = DiGraph(10000000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 9.44 s per loop

WITH DICTIONARIES
sage: g = DiGraph(10000000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 9.87 s per loop
```
> David.

[1] !http://arxiv.org/abs/1507.01490



---

archive/issue_comments_267553.json:
```json
{
    "body": "Changed commit from **[`8df530a`](https://github.com/sagemath/sagetrac-mirror/commit/8df530ab5c761501b10ba397e361889b4be91833)** to **[`0f855c6`](https://github.com/sagemath/sagetrac-mirror/commit/0f855c6676d6f10a6f68b64b4c2be693c08eba91)**",
    "created_at": "2015-08-14T09:17:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267553",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`8df530a`](https://github.com/sagemath/sagetrac-mirror/commit/8df530ab5c761501b10ba397e361889b4be91833)** to **[`0f855c6`](https://github.com/sagemath/sagetrac-mirror/commit/0f855c6676d6f10a6f68b64b4c2be693c08eba91)**



---

archive/issue_comments_267554.json:
```json
{
    "body": "<div id=\"comment:12\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0f855c6676d6f10a6f68b64b4c2be693c08eba91\"><code>0f855c6</code></a></td><td><code>Reviewer's suggestions</code></td></tr></table>\n",
    "created_at": "2015-08-14T09:17:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267554",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:12"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0f855c6676d6f10a6f68b64b4c2be693c08eba91"><code>0f855c6</code></a></td><td><code>Reviewer's suggestions</code></td></tr></table>




---

archive/issue_comments_267555.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\n> > I have some remarks:\n> > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?\n> \n> \n> Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?\n\nIf you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.\nWith Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.\n \n> > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`\n> \n> \n> Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.\n\nWell, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.\n \n> > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like\n> > \n> > ```\n> > d = {i:list() for i in range(nscc)}\n> > for u,i in scc.iteritems():\n> > d[i].append(u)\n> > output = [d[i] for i in range(nscc)]\n> > ```\n> \n> \n> Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.\n> \n> ```\n> WITH NUMPY\n> sage: g = DiGraph(10000000)\n> sage: %timeit g.strongly_connected_components()\n> 1 loops, best of 3: 9.44 s per loop\n> \n> WITH DICTIONARIES\n> sage: g = DiGraph(10000000)\n> sage: %timeit g.strongly_connected_components()\n> 1 loops, best of 3: 9.87 s per loop\n> ```\n\nanother option (don't know if it is faster or not)\n\n```\ncdef int i\ncdef list output = list(list() for i in range(nscc))  # We cannot use [] here\nfor i,v in enumerate(G.vertex_iterator()):\n    output[scc[i]].append(v)\n```\n\nMethod `strongly_connected_components_digraph`:\n- is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be\n- seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.\n\n\n\nGeneral comments:\n- `if visited[u] == 0:` -> `if not visited[u]`\n- `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list\n- you have broken doctests caused by this ticket. I have not tracked the dependencies.\n\n```\nsage -t --long src/sage/monoids/automatic_semigroup.py\n**********************************************************************\nFile \"src/sage/monoids/automatic_semigroup.py\", line 135, in sage.monoids.automatic_semigroup.AutomaticSemigroup\nFailed example:\n    map(sorted, M.j_classes())\nExpected:\n    [[[], [2]], [[1, 1], [1]]]\nGot:\n    [[[1], [1, 1]], [[], [2]]]\n**********************************************************************\nFile \"src/sage/monoids/automatic_semigroup.py\", line 137, in sage.monoids.automatic_semigroup.AutomaticSemigroup\nFailed example:\n    M.j_classes_of_idempotents()\nExpected:\n    [[[]], [[1, 1]]]\nGot:\n    [[[1, 1]], [[]]]\n**********************************************************************\nFile \"src/sage/monoids/automatic_semigroup.py\", line 139, in sage.monoids.automatic_semigroup.AutomaticSemigroup\nFailed example:\n    M.j_transversal_of_idempotents()\nExpected:\n    [[], [1, 1]]\nGot:\n    [[1, 1], []]\n**********************************************************************\n1 item had failures:\n   3 of  80 in sage.monoids.automatic_semigroup.AutomaticSemigroup\n    [264 tests, 3 failures, 1.94 s]\nsage -t --long src/sage/categories/finite_semigroups.py\n**********************************************************************\nFile \"src/sage/categories/finite_semigroups.py\", line 119, in sage.categories.finite_semigroups.FiniteSemigroups.ParentMethods.j_transversal_of_idempotents\nFailed example:\n    sorted(S.j_transversal_of_idempotents())\nExpected:\n    ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']\nGot:\n    ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']\n```",
    "created_at": "2015-08-14T14:24:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267555",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:13" align="right">comment:13</div>

> > I have some remarks:
> > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?
> 
> 
> Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?

If you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.
With Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.
 
> > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`
> 
> 
> Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.

Well, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.
 
> > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like
> > 
> > ```
> > d = {i:list() for i in range(nscc)}
> > for u,i in scc.iteritems():
> > d[i].append(u)
> > output = [d[i] for i in range(nscc)]
> > ```
> 
> 
> Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.
> 
> ```
> WITH NUMPY
> sage: g = DiGraph(10000000)
> sage: %timeit g.strongly_connected_components()
> 1 loops, best of 3: 9.44 s per loop
> 
> WITH DICTIONARIES
> sage: g = DiGraph(10000000)
> sage: %timeit g.strongly_connected_components()
> 1 loops, best of 3: 9.87 s per loop
> ```

another option (don't know if it is faster or not)

```
cdef int i
cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
for i,v in enumerate(G.vertex_iterator()):
    output[scc[i]].append(v)
```

Method `strongly_connected_components_digraph`:
- is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be
- seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.



General comments:
- `if visited[u] == 0:` -> `if not visited[u]`
- `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list
- you have broken doctests caused by this ticket. I have not tracked the dependencies.

```
sage -t --long src/sage/monoids/automatic_semigroup.py
**********************************************************************
File "src/sage/monoids/automatic_semigroup.py", line 135, in sage.monoids.automatic_semigroup.AutomaticSemigroup
Failed example:
    map(sorted, M.j_classes())
Expected:
    [[[], [2]], [[1, 1], [1]]]
Got:
    [[[1], [1, 1]], [[], [2]]]
**********************************************************************
File "src/sage/monoids/automatic_semigroup.py", line 137, in sage.monoids.automatic_semigroup.AutomaticSemigroup
Failed example:
    M.j_classes_of_idempotents()
Expected:
    [[[]], [[1, 1]]]
Got:
    [[[1, 1]], [[]]]
**********************************************************************
File "src/sage/monoids/automatic_semigroup.py", line 139, in sage.monoids.automatic_semigroup.AutomaticSemigroup
Failed example:
    M.j_transversal_of_idempotents()
Expected:
    [[], [1, 1]]
Got:
    [[1, 1], []]
**********************************************************************
1 item had failures:
   3 of  80 in sage.monoids.automatic_semigroup.AutomaticSemigroup
    [264 tests, 3 failures, 1.94 s]
sage -t --long src/sage/categories/finite_semigroups.py
**********************************************************************
File "src/sage/categories/finite_semigroups.py", line 119, in sage.categories.finite_semigroups.FiniteSemigroups.ParentMethods.j_transversal_of_idempotents
Failed example:
    sorted(S.j_transversal_of_idempotents())
Expected:
    ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']
Got:
    ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']
```



---

archive/issue_comments_267556.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nHello!\nLet me try to address these problems!\nThank you very much,\nMichele\n\nReplying to [@dcoudert](#comment%3A13):\n\n> > > I have some remarks:\n> > > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?\n> > > \n> > > \n> > > \n> > > \n> > \n> > \n> > Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?\n> > \n> > \n> > \n> > \n> \n> \n> If you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.\n> With Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.\n\nDone!\n\n> > > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`\n> > > \n> > > \n> > > \n> > > \n> > \n> > \n> > Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.\n> > \n> > \n> > \n> > \n> \n> \n> Well, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.\n\nOk, let's leave it as it is!\n\n> > > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like\n> > > \n> > > ```\n> > > d = {i:list() for i in range(nscc)}\n> > > for u,i in scc.iteritems():\n> > > d[i].append(u)\n> > > output = [d[i] for i in range(nscc)]\n> > > ```\n> > > \n> > > \n> > > \n> > > \n> > \n> > \n> > Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.\n> > \n> > ```\n> > WITH NUMPY\n> > sage: g = DiGraph(10000000)\n> > sage: %timeit g.strongly_connected_components()\n> > 1 loops, best of 3: 9.44 s per loop\n> > \n> > WITH DICTIONARIES\n> > sage: g = DiGraph(10000000)\n> > sage: %timeit g.strongly_connected_components()\n> > 1 loops, best of 3: 9.87 s per loop\n> > ```\n> > \n> > \n> > \n> > \n> \n> \n> another option (don't know if it is faster or not)\n> \n> ```\n> cdef int i\n> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here\n> for i,v in enumerate(G.vertex_iterator()):\n> output[scc[i]].append(v)\n> ```\n\nCool! Not only it is simpler, it is also faster!\n\n```\nsage: g = DiGraph(10000000)\nsage: %timeit g.strongly_connected_components()\n1 loops, best of 3: 7.89 s per loop\n```\n> Method `strongly_connected_components_digraph`:\n> - is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be\n> - seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.\n\nHmmm, this is the hard part of my answer...\n\nThe problem is that I will need a C algorithm working on `static_sparse_graphs` to compute the digraph of strongly connected components in linear time, with no parallel edge. I think this is the only way to do it: I know it is complicated, but I do not know any other way. Do you think I should use n dictionaries, to check for parallel edges?\n\n> General comments:\n> - `if visited[u] == 0:` -> `if not visited[u]`\n\nDone!\n\n> - `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list\n\nDone!\n\n> - you have broken doctests caused by this ticket. I have not tracked the dependencies.\n\nThe problem is the order in which strongly connected components are outputted in the list: we can change the results without any problem. In the following, I try to explain why.\n\n> ```\n> sage -t --long src/sage/monoids/automatic_semigroup.py\n> **********************************************************************\n> File \"src/sage/monoids/automatic_semigroup.py\", line 135, in sage.monoids.automatic_semigroup.[wiki:AutomaticSemigroup]\n> Failed example:\n> map(sorted, M.j_classes())\n> Expected:\n> [[[], [2]], [[1, 1], [1]]]\n> Got:\n> [[[1], [1, 1]], [[], [2]]]\n> ```\n\nThe J-classes are sets of elements in a semigroups satisfying a specific property (for more information, see http://www.liafa.jussieu.fr/~jep/PDF/HandBook.pdf). The difference amont the results is the order in which the elements are listed, but since in sets the order does not count, both results are correct.\n\n> **********************************************************************\n> File \"src/sage/monoids/automatic_semigroup.py\", line 137, in sage.monoids.automatic_semigroup.[Trac macro AutomaticSemigroup](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)\n> Failed example:\n> M.j_classes_of_idempotents()\n> Expected:\n> [[[]], [[1, 1]]]\n> Got:\n> [[[1, 1]], [[]]]\n\nHere, the difference is the order in which the two classes of idempotents are outputted. Since method j_classes_of_idempotents does not set a specific order, both results are correct.\n\n> **********************************************************************\n> File \"src/sage/monoids/automatic_semigroup.py\", line 139, in sage.monoids.automatic_semigroup.[Trac macro AutomaticSemigroup](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)\n> Failed example:\n> M.j_transversal_of_idempotents()\n> Expected:\n> [[], [1, 1]]\n> Got:\n> [[1, 1], []]\n\nHere, we simply get one element from the classes found in the previous example: the order is maintained. Hence, both results are again correct.\n\n> **********************************************************************\n> 1 item had failures:\n> 3 of  80 in sage.monoids.automatic_semigroup.[Trac macro AutomaticSemigroup](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)\n> [264 tests, 3 failures, 1.94 s]\n> sage -t --long src/sage/categories/finite_semigroups.py\n> **********************************************************************\n> File \"src/sage/categories/finite_semigroups.py\", line 119, in sage.categories.finite_semigroups.[Trac macro FiniteSemigroups](https://trac.sagemath.org/wiki/WikiMacros#FiniteSemigroups-macro).[Trac macro ParentMethods](https://trac.sagemath.org/wiki/WikiMacros#ParentMethods-macro).j_transversal_of_idempotents\n> Failed example:\n> sorted(S.j_transversal_of_idempotents())\n> Expected:\n> ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']\n> Got:\n> ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']\n> }}}\n\nHere, 'abc' is in the same class of idempotents as 'acb', and 'bc' is in the same class of idempotents as 'cb', as shown by the example before this one. Since this routine should output one idempotent per class, we are fine!",
    "created_at": "2015-08-16T17:42:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267556",
    "user": "https://github.com/sagetrac-borassi"
}
```

<div id="comment:14" align="right">comment:14</div>

Hello!
Let me try to address these problems!
Thank you very much,
Michele

Replying to [@dcoudert](#comment%3A13):

> > > I have some remarks:
> > > - Do we really need to have both `_tarjan_strongly_connected_components` and `tarjan_strongly_connected_components` ? Same for other methods. What's the motivation behind?
> > > 
> > > 
> > > 
> > > 
> > 
> > 
> > Yes, I think I need both methods. The point is that I want to implement a fast algorithm for closeness centrality ![1], and the first step is computing SCCs. In that implementation, I will first convert the graph to a `static_sparse_graph`, and then I will have to run the SCC algorithm on this graph, using the C routine `_tarjan_strongly_connected_components`. I also need the other routine to access `_tarjan_strongly_connected_components` from Python code (for instance, in a .py file). Do you have better ideas?
> > 
> > 
> > 
> > 
> 
> 
> If you plan to call these methods directly from other cython files, it make sense to split the method in two pieces.
> With Nathann we recently started to name such methods `compute_cool_stuff_C` rather than `_compute_cool_stuff`. I don't know if there is a general rule for that.

Done!

> > > - Have you tried using an array of short instead of a bitset for `in_scc_stack` ? We don't have memory issue here so we can save some operations, plus you already do that for `visited`
> > > 
> > > 
> > > 
> > > 
> > 
> > 
> > Hmmm, I should really understand better how bitset work. I used it only because I thought it was faster than standard arrays. In any case, I removed all bitsets from this code.
> > 
> > 
> > 
> > 
> 
> 
> Well, bitsets are really fast, and to be honest we save very little using an array instead. The code is shorter. This is already something.

Ok, let's leave it as it is!

> > > - I don't really see the benefit of using numpy (I don't know it). Is it just more convenient or also faster that other methods? You could use something like
> > > 
> > > ```
> > > d = {i:list() for i in range(nscc)}
> > > for u,i in scc.iteritems():
> > > d[i].append(u)
> > > output = [d[i] for i in range(nscc)]
> > > ```
> > > 
> > > 
> > > 
> > > 
> > 
> > 
> > Well, probably the problem is that I'm a theoretical guy, and if the algorithm is linear I want a linear implementation. This is why I used an array and not a dictionary (and, as far as I know, numpy is the only way to build an array of Python objects). However, if we use a dictionary, the running-time is almost the same, even when there are a lot of SCCs. I deleted numpy and now I use dictionaries.
> > 
> > ```
> > WITH NUMPY
> > sage: g = DiGraph(10000000)
> > sage: %timeit g.strongly_connected_components()
> > 1 loops, best of 3: 9.44 s per loop
> > 
> > WITH DICTIONARIES
> > sage: g = DiGraph(10000000)
> > sage: %timeit g.strongly_connected_components()
> > 1 loops, best of 3: 9.87 s per loop
> > ```
> > 
> > 
> > 
> > 
> 
> 
> another option (don't know if it is faster or not)
> 
> ```
> cdef int i
> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
> for i,v in enumerate(G.vertex_iterator()):
> output[scc[i]].append(v)
> ```

Cool! Not only it is simpler, it is also faster!

```
sage: g = DiGraph(10000000)
sage: %timeit g.strongly_connected_components()
1 loops, best of 3: 7.89 s per loop
```
> Method `strongly_connected_components_digraph`:
> - is not currently called by `DiGraph().strongly_connected_components_digraph()` and will certainly never be
> - seems more complicated than what it should. Indeed, as soon as you have a mapping `vertex->scc` you can simply iterate over the edges `(u,v)` of the input digraph and add edges `(scc[u],scc[v])` to the output digraph. I don't see the need for the `_strongly_connected_components_digraph` method and it is rather complicated.

Hmmm, this is the hard part of my answer...

The problem is that I will need a C algorithm working on `static_sparse_graphs` to compute the digraph of strongly connected components in linear time, with no parallel edge. I think this is the only way to do it: I know it is complicated, but I do not know any other way. Do you think I should use n dictionaries, to check for parallel edges?

> General comments:
> - `if visited[u] == 0:` -> `if not visited[u]`

Done!

> - `return [output, {v:scc[i] for i,v in enumerate(G.vertices())}]` -> `return output, {v:scc[i] for i,v in enumerate(G.vertices())}`  no need for explicitely creating a list

Done!

> - you have broken doctests caused by this ticket. I have not tracked the dependencies.

The problem is the order in which strongly connected components are outputted in the list: we can change the results without any problem. In the following, I try to explain why.

> ```
> sage -t --long src/sage/monoids/automatic_semigroup.py
> **********************************************************************
> File "src/sage/monoids/automatic_semigroup.py", line 135, in sage.monoids.automatic_semigroup.[wiki:AutomaticSemigroup]
> Failed example:
> map(sorted, M.j_classes())
> Expected:
> [[[], [2]], [[1, 1], [1]]]
> Got:
> [[[1], [1, 1]], [[], [2]]]
> ```

The J-classes are sets of elements in a semigroups satisfying a specific property (for more information, see http://www.liafa.jussieu.fr/~jep/PDF/HandBook.pdf). The difference amont the results is the order in which the elements are listed, but since in sets the order does not count, both results are correct.

> **********************************************************************
> File "src/sage/monoids/automatic_semigroup.py", line 137, in sage.monoids.automatic_semigroup.[Trac macro AutomaticSemigroup](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> Failed example:
> M.j_classes_of_idempotents()
> Expected:
> [[[]], [[1, 1]]]
> Got:
> [[[1, 1]], [[]]]

Here, the difference is the order in which the two classes of idempotents are outputted. Since method j_classes_of_idempotents does not set a specific order, both results are correct.

> **********************************************************************
> File "src/sage/monoids/automatic_semigroup.py", line 139, in sage.monoids.automatic_semigroup.[Trac macro AutomaticSemigroup](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> Failed example:
> M.j_transversal_of_idempotents()
> Expected:
> [[], [1, 1]]
> Got:
> [[1, 1], []]

Here, we simply get one element from the classes found in the previous example: the order is maintained. Hence, both results are again correct.

> **********************************************************************
> 1 item had failures:
> 3 of  80 in sage.monoids.automatic_semigroup.[Trac macro AutomaticSemigroup](https://trac.sagemath.org/wiki/WikiMacros#AutomaticSemigroup-macro)
> [264 tests, 3 failures, 1.94 s]
> sage -t --long src/sage/categories/finite_semigroups.py
> **********************************************************************
> File "src/sage/categories/finite_semigroups.py", line 119, in sage.categories.finite_semigroups.[Trac macro FiniteSemigroups](https://trac.sagemath.org/wiki/WikiMacros#FiniteSemigroups-macro).[Trac macro ParentMethods](https://trac.sagemath.org/wiki/WikiMacros#ParentMethods-macro).j_transversal_of_idempotents
> Failed example:
> sorted(S.j_transversal_of_idempotents())
> Expected:
> ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']
> Got:
> ['a', 'ab', 'abc', 'ac', 'b', 'bc', 'c']
> }}}

Here, 'abc' is in the same class of idempotents as 'acb', and 'bc' is in the same class of idempotents as 'cb', as shown by the example before this one. Since this routine should output one idempotent per class, we are fine!



---

archive/issue_comments_267557.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nJust a detail, for future references:\n\n```\ncdef int i\ncdef list output = list(list() for i in range(nscc))  # We cannot use [] here\nfor i,v in enumerate(G.vertex_iterator()):\noutput[scc[i]].append(v)\n\n```\nIf we use `G.vertex_iterator()`, the vertex labels are not correct (I also added an example with labels, that shows the problem). With `G.vertices()`, everything works fine.\n\nWhy?",
    "created_at": "2015-08-16T21:09:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267557",
    "user": "https://github.com/sagetrac-borassi"
}
```

<div id="comment:15" align="right">comment:15</div>

Just a detail, for future references:

```
cdef int i
cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
for i,v in enumerate(G.vertex_iterator()):
output[scc[i]].append(v)

```
If we use `G.vertex_iterator()`, the vertex labels are not correct (I also added an example with labels, that shows the problem). With `G.vertices()`, everything works fine.

Why?



---

archive/issue_comments_267558.json:
```json
{
    "body": "Changed commit from **[`0f855c6`](https://github.com/sagemath/sagetrac-mirror/commit/0f855c6676d6f10a6f68b64b4c2be693c08eba91)** to **[`cbe780c`](https://github.com/sagemath/sagetrac-mirror/commit/cbe780c0862c46304ce2b0da4c844178a9ecc8e6)**",
    "created_at": "2015-08-16T21:24:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267558",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`0f855c6`](https://github.com/sagemath/sagetrac-mirror/commit/0f855c6676d6f10a6f68b64b4c2be693c08eba91)** to **[`cbe780c`](https://github.com/sagemath/sagetrac-mirror/commit/cbe780c0862c46304ce2b0da4c844178a9ecc8e6)**



---

archive/issue_comments_267559.json:
```json
{
    "body": "<div id=\"comment:16\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1ec3f4448f12b96fc9c5e4de2bbb402176ba9c17\"><code>1ec3f44</code></a></td><td><code>Merged with beta2</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cbe780c0862c46304ce2b0da4c844178a9ecc8e6\"><code>cbe780c</code></a></td><td><code>Reviewer's suggestions and small improvements</code></td></tr></table>\n",
    "created_at": "2015-08-16T21:24:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267559",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:16"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1ec3f4448f12b96fc9c5e4de2bbb402176ba9c17"><code>1ec3f44</code></a></td><td><code>Merged with beta2</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cbe780c0862c46304ce2b0da4c844178a9ecc8e6"><code>cbe780c</code></a></td><td><code>Reviewer's suggestions and small improvements</code></td></tr></table>




---

archive/issue_comments_267560.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nbecause `G.vertices()` sorts the output (I know, I know...). I fixed something similar recently in an igraph ticket: the output of `.edge_iterator` is not the same as `.edges`.\n\nNathann",
    "created_at": "2015-08-16T21:25:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267560",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:17" align="right">comment:17</div>

because `G.vertices()` sorts the output (I know, I know...). I fixed something similar recently in an igraph ticket: the output of `.edge_iterator` is not the same as `.edges`.

Nathann



---

archive/issue_comments_267561.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nIn method `tarjan_strongly_connected_components_C`, you could do the following:\n\n```\nif visited[v]:\n   continue\n```\nand then remove one level of indentation.\n\nIn method `strongly_connected_components_digraph_C`.\n\n```\n   output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))\n   if output.edges == NULL and output.m != 0:\n       raise ValueError(\"Problem while allocating memory (edges)\")\n   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))\n   if output.neighbors == NULL and output.m != 0:\n       raise ValueError(\"Problem while allocating memory (neighbors)\")\n```\nmust be replaced by something link\n\n```\n   if output.m==0:\n      << DO APPROPRIATE OPERATIONS FOR THIS CASE >>\n      << RETURN >>\n\n   output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))\n   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))\n   if output.edges == NULL or output.neighbors == NULL:\n       raise MemoryError(\"Problem while allocating memory (edges or neighbors).\")\n```\nThis is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.\n\n\nOtherwise, the method is working very well\n\n```\nBefore\nsage: set_random_seed(0)\nsage: D = digraphs.RandomDirectedGNM(100000,500000)\nsage: D.is_strongly_connected()\nFalse\nsage: %time res = D.strongly_connected_components()\nlen(res)\nCPU times: user 3min 50s, sys: 4.28 s, total: 3min 55s\nWall time: 3min 56s\nsage: len(res)\n1413\n\nWith this patch\nsage: set_random_seed(0)\nsage: D = digraphs.RandomDirectedGNM(100000,500000)\nsage: D.is_strongly_connected()\nFalse\nsage: %time res = D.strongly_connected_components()\nCPU times: user 481 ms, sys: 16.2 ms, total: 497 ms\nWall time: 499 ms\nsage: len(res)\n1413\nsage: D.allow_multiple_edges(True)\nsage: D\nMulti-digraph on 100000 vertices\nsage: D.add_edges(D.edges())\nsage: D.size()\n1000000\nsage: %time res = D.strongly_connected_components()\nCPU times: user 566 ms, sys: 20.4 ms, total: 587 ms\nWall time: 594 ms\nsage: len(res)\n1413\n```\nand as you can see, I also tried with a multi-digraph and its working as expected.\n\nDavid.",
    "created_at": "2015-08-17T11:45:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267561",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:18" align="right">comment:18</div>

In method `tarjan_strongly_connected_components_C`, you could do the following:

```
if visited[v]:
   continue
```
and then remove one level of indentation.

In method `strongly_connected_components_digraph_C`.

```
   output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
   if output.edges == NULL and output.m != 0:
       raise ValueError("Problem while allocating memory (edges)")
   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
   if output.neighbors == NULL and output.m != 0:
       raise ValueError("Problem while allocating memory (neighbors)")
```
must be replaced by something link

```
   if output.m==0:
      << DO APPROPRIATE OPERATIONS FOR THIS CASE >>
      << RETURN >>

   output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
   output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
   if output.edges == NULL or output.neighbors == NULL:
       raise MemoryError("Problem while allocating memory (edges or neighbors).")
```
This is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.


Otherwise, the method is working very well

```
Before
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(100000,500000)
sage: D.is_strongly_connected()
False
sage: %time res = D.strongly_connected_components()
len(res)
CPU times: user 3min 50s, sys: 4.28 s, total: 3min 55s
Wall time: 3min 56s
sage: len(res)
1413

With this patch
sage: set_random_seed(0)
sage: D = digraphs.RandomDirectedGNM(100000,500000)
sage: D.is_strongly_connected()
False
sage: %time res = D.strongly_connected_components()
CPU times: user 481 ms, sys: 16.2 ms, total: 497 ms
Wall time: 499 ms
sage: len(res)
1413
sage: D.allow_multiple_edges(True)
sage: D
Multi-digraph on 100000 vertices
sage: D.add_edges(D.edges())
sage: D.size()
1000000
sage: %time res = D.strongly_connected_components()
CPU times: user 566 ms, sys: 20.4 ms, total: 587 ms
Wall time: 594 ms
sage: len(res)
1413
```
and as you can see, I also tried with a multi-digraph and its working as expected.

David.



---

archive/issue_events_267470.json:
```json
{
    "actor": "https://github.com/dcoudert",
    "created_at": "2015-08-17T11:45:03Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267470"
}
```



---

archive/issue_events_267471.json:
```json
{
    "actor": "https://github.com/dcoudert",
    "created_at": "2015-08-17T11:45:03Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267471"
}
```



---

archive/issue_comments_267562.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nDone!\n\n> \n> In method `tarjan_strongly_connected_components_C`, you could do the following:\n> \n> ```\n> if visited[v]:\n> continue\n> ```\n> and then remove one level of indentation.\n\nProbably, you meant\n\n```\nif visited[u]:\n    continue\n```\nbecause the line `if visited[v]:` is followed by an else. Correct?\n\n> In method `strongly_connected_components_digraph_C`.\n> \n> ```\n> output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))\n> if output.edges == NULL and output.m != 0:\n> raise ValueError(\"Problem while allocating memory (edges)\")\n> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))\n> if output.neighbors == NULL and output.m != 0:\n> raise ValueError(\"Problem while allocating memory (neighbors)\")\n> ```\n> must be replaced by something link\n> \n> ```\n> if output.m==0:\n> << DO APPROPRIATE OPERATIONS FOR THIS CASE >>\n> << RETURN >>\n> \n> output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))\n> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))\n> if output.edges == NULL or output.neighbors == NULL:\n> raise MemoryError(\"Problem while allocating memory (edges or neighbors).\")\n> ```\n> This is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.\n\nHmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?\n\n[1] !http://stackoverflow.com/questions/1073157/zero-size-malloc",
    "created_at": "2015-08-17T14:56:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267562",
    "user": "https://github.com/sagetrac-borassi"
}
```

<div id="comment:19" align="right">comment:19</div>

Done!

> 
> In method `tarjan_strongly_connected_components_C`, you could do the following:
> 
> ```
> if visited[v]:
> continue
> ```
> and then remove one level of indentation.

Probably, you meant

```
if visited[u]:
    continue
```
because the line `if visited[v]:` is followed by an else. Correct?

> In method `strongly_connected_components_digraph_C`.
> 
> ```
> output.edges = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
> if output.edges == NULL and output.m != 0:
> raise ValueError("Problem while allocating memory (edges)")
> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
> if output.neighbors == NULL and output.m != 0:
> raise ValueError("Problem while allocating memory (neighbors)")
> ```
> must be replaced by something link
> 
> ```
> if output.m==0:
> << DO APPROPRIATE OPERATIONS FOR THIS CASE >>
> << RETURN >>
> 
> output.edges     = <uint32_t *> sage_malloc(m*sizeof(uint32_t))
> output.neighbors = <uint32_t **> sage_malloc((1+<int>output.n)*sizeof(uint32_t *))
> if output.edges == NULL or output.neighbors == NULL:
> raise MemoryError("Problem while allocating memory (edges or neighbors).")
> ```
> This is not only a cosmetic change since when `m==0` you allow `output.neighbors==NULL` before the instruction `output.neighbors[0] = output.edges`. So your code is currently not safe.

Hmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?

[1] !http://stackoverflow.com/questions/1073157/zero-size-malloc



---

archive/issue_comments_267563.json:
```json
{
    "body": "<div id=\"comment:20\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/417476495e176150d2ba92bed3b6b894314fc185\"><code>4174764</code></a></td><td><code>Reviewer's suggestions</code></td></tr></table>\n",
    "created_at": "2015-08-17T15:10:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267563",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:20"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/417476495e176150d2ba92bed3b6b894314fc185"><code>4174764</code></a></td><td><code>Reviewer's suggestions</code></td></tr></table>




---

archive/issue_comments_267564.json:
```json
{
    "body": "Changed commit from **[`cbe780c`](https://github.com/sagemath/sagetrac-mirror/commit/cbe780c0862c46304ce2b0da4c844178a9ecc8e6)** to **[`4174764`](https://github.com/sagemath/sagetrac-mirror/commit/417476495e176150d2ba92bed3b6b894314fc185)**",
    "created_at": "2015-08-17T15:10:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267564",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`cbe780c`](https://github.com/sagemath/sagetrac-mirror/commit/cbe780c0862c46304ce2b0da4c844178a9ecc8e6)** to **[`4174764`](https://github.com/sagemath/sagetrac-mirror/commit/417476495e176150d2ba92bed3b6b894314fc185)**



---

archive/issue_comments_267565.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\n> because the line `if visited[v]:` is followed by an else. Correct?\n\nyou did the correct modification.\n \n> > In method `strongly_connected_components_digraph_C`.\n> \n> ...\n> \n> Hmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?\n> \n> [1] !http://stackoverflow.com/questions/1073157/zero-size-malloc\n\nI have checked in files `sage/ext/memory_allocator.pyx`. It uses methods like `check_allocarray` which can be found in `memory.pxd`. These methods ensure that if `n==0` then the returned pointer is `NULL`, and this is compiler independent. Furthermore, these methods raise an error if something goes wrong with malloc. So no need for opening a ticket, it's already done ;)\nSo if you want to be on the safe side and to ease your life, use the memory allocator and/or the `check_alloc` methods, depending on the context.\nIn your code, it means that you can call\n\n```\noutput.edges = <uint32_t *> check_allocarray(m, sizeof(uint32_t))\n```\nand then remove the NULL test.\n\nOf course, what you did for the case `m==0` is also important. \n\nDavid.",
    "created_at": "2015-08-17T16:17:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267565",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:21" align="right">comment:21</div>

> because the line `if visited[v]:` is followed by an else. Correct?

you did the correct modification.
 
> > In method `strongly_connected_components_digraph_C`.
> 
> ...
> 
> Hmm, I did as you said, but the same problem might occur also in `init_short_digraph`: if there are no edges, we set `edges=malloc(0)`, and in the next line we test if edges is `NULL`. The result of `malloc(0)` depends on the compiler implementation ![1], so for some compilers it might output `NULL` by default. Do you think we should open a ticket solving this issue?
> 
> [1] !http://stackoverflow.com/questions/1073157/zero-size-malloc

I have checked in files `sage/ext/memory_allocator.pyx`. It uses methods like `check_allocarray` which can be found in `memory.pxd`. These methods ensure that if `n==0` then the returned pointer is `NULL`, and this is compiler independent. Furthermore, these methods raise an error if something goes wrong with malloc. So no need for opening a ticket, it's already done ;)
So if you want to be on the safe side and to ease your life, use the memory allocator and/or the `check_alloc` methods, depending on the context.
In your code, it means that you can call

```
output.edges = <uint32_t *> check_allocarray(m, sizeof(uint32_t))
```
and then remove the NULL test.

Of course, what you did for the case `m==0` is also important. 

David.



---

archive/issue_comments_267566.json:
```json
{
    "body": "<div id=\"comment:22\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0c190242582acd62e4a43449194df95205c90622\"><code>0c19024</code></a></td><td><code>Use check_allocarray</code></td></tr></table>\n",
    "created_at": "2015-08-17T17:02:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267566",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:22"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0c190242582acd62e4a43449194df95205c90622"><code>0c19024</code></a></td><td><code>Use check_allocarray</code></td></tr></table>




---

archive/issue_comments_267567.json:
```json
{
    "body": "Changed commit from **[`4174764`](https://github.com/sagemath/sagetrac-mirror/commit/417476495e176150d2ba92bed3b6b894314fc185)** to **[`0c19024`](https://github.com/sagemath/sagetrac-mirror/commit/0c190242582acd62e4a43449194df95205c90622)**",
    "created_at": "2015-08-17T17:02:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267567",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`4174764`](https://github.com/sagemath/sagetrac-mirror/commit/417476495e176150d2ba92bed3b6b894314fc185)** to **[`0c19024`](https://github.com/sagemath/sagetrac-mirror/commit/0c190242582acd62e4a43449194df95205c90622)**



---

archive/issue_events_267472.json:
```json
{
    "actor": "https://github.com/sagetrac-borassi",
    "created_at": "2015-08-17T17:02:59Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267472"
}
```



---

archive/issue_events_267473.json:
```json
{
    "actor": "https://github.com/sagetrac-borassi",
    "created_at": "2015-08-17T17:02:59Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267473"
}
```



---

archive/issue_comments_267568.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nDone!",
    "created_at": "2015-08-17T17:02:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267568",
    "user": "https://github.com/sagetrac-borassi"
}
```

<div id="comment:23" align="right">comment:23</div>

Done!



---

archive/issue_comments_267569.json:
```json
{
    "body": "Reviewer: **David Coudert**",
    "created_at": "2015-08-17T18:43:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267569",
    "user": "https://github.com/dcoudert"
}
```

Reviewer: **David Coudert**



---

archive/issue_comments_267570.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nGood.\nDavid.",
    "created_at": "2015-08-17T18:43:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267570",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:24" align="right">comment:24</div>

Good.
David.



---

archive/issue_events_267474.json:
```json
{
    "actor": "https://github.com/dcoudert",
    "created_at": "2015-08-17T18:43:09Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267474"
}
```



---

archive/issue_events_267475.json:
```json
{
    "actor": "https://github.com/dcoudert",
    "created_at": "2015-08-17T18:43:09Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267475"
}
```



---

archive/issue_comments_267571.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nI'll take it this is caused by this ticket:\n\nhttp://build.sagemath.org/release/builders/%20%20slow%20AIMS%20%20%28Debian%207%2064%20bit%29%20incremental/builds/40/steps/compile/logs/stdio",
    "created_at": "2015-08-18T21:33:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267571",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:25" align="right">comment:25</div>

I'll take it this is caused by this ticket:

http://build.sagemath.org/release/builders/%20%20slow%20AIMS%20%20%28Debian%207%2064%20bit%29%20incremental/builds/40/steps/compile/logs/stdio



---

archive/issue_events_267476.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-08-18T21:33:26Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267476"
}
```



---

archive/issue_events_267477.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-08-18T21:33:26Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267477"
}
```



---

archive/issue_comments_267572.json:
```json
{
    "body": "Changed commit from **[`0c19024`](https://github.com/sagemath/sagetrac-mirror/commit/0c190242582acd62e4a43449194df95205c90622)** to **[`9167071`](https://github.com/sagemath/sagetrac-mirror/commit/9167071e5e8408c33125b551168d43c5f4539d19)**",
    "created_at": "2015-08-18T22:12:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267572",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`0c19024`](https://github.com/sagemath/sagetrac-mirror/commit/0c190242582acd62e4a43449194df95205c90622)** to **[`9167071`](https://github.com/sagemath/sagetrac-mirror/commit/9167071e5e8408c33125b551168d43c5f4539d19)**



---

archive/issue_comments_267573.json:
```json
{
    "body": "<div id=\"comment:26\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9167071e5e8408c33125b551168d43c5f4539d19\"><code>9167071</code></a></td><td><code>Used limits instead of stdint to find maximum int value</code></td></tr></table>\n",
    "created_at": "2015-08-18T22:12:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267573",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:26"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9167071e5e8408c33125b551168d43c5f4539d19"><code>9167071</code></a></td><td><code>Used limits instead of stdint to find maximum int value</code></td></tr></table>




---

archive/issue_comments_267574.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nYes, I think the problem is caused by this ticket, because I changed the language of `static_sparse_graph` from C to C++ (I needed vectors). In particular, I think the problem was the use of `stdint` library, as explained in [1]. I replaced this library with `limits`, and now it should work.\n\n[1] !http://stackoverflow.com/questions/3233054/error-int32-max-was-not-declared-in-this-scope",
    "created_at": "2015-08-18T22:16:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267574",
    "user": "https://github.com/sagetrac-borassi"
}
```

<div id="comment:27" align="right">comment:27</div>

Yes, I think the problem is caused by this ticket, because I changed the language of `static_sparse_graph` from C to C++ (I needed vectors). In particular, I think the problem was the use of `stdint` library, as explained in [1]. I replaced this library with `limits`, and now it should work.

[1] !http://stackoverflow.com/questions/3233054/error-int32-max-was-not-declared-in-this-scope



---

archive/issue_comments_267575.json:
```json
{
    "body": "<div id=\"comment:28\" align=\"right\">comment:28</div>\n\nHello,\n\ncould you change in the doctest of `tarjan_strongly_connected_components`\n\n```\n       sage: for i in range(100):                                     # long\n       ...        g = digraphs.RandomDirectedGNP(100,.05)\n```\nwith\n\n```\n       sage: for i in range(100):                                     # long\n       ....:      g = digraphs.RandomDirectedGNP(100,.05)\n```\nso use `...` with `....:` for continuation.\nSorry to miss it before.\nAnd also you can now change `for i in range(100)` with something small in all test.\n\nDavid.",
    "created_at": "2015-08-19T06:49:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267575",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:28" align="right">comment:28</div>

Hello,

could you change in the doctest of `tarjan_strongly_connected_components`

```
       sage: for i in range(100):                                     # long
       ...        g = digraphs.RandomDirectedGNP(100,.05)
```
with

```
       sage: for i in range(100):                                     # long
       ....:      g = digraphs.RandomDirectedGNP(100,.05)
```
so use `...` with `....:` for continuation.
Sorry to miss it before.
And also you can now change `for i in range(100)` with something small in all test.

David.



---

archive/issue_comments_267576.json:
```json
{
    "body": "Changed commit from **[`9167071`](https://github.com/sagemath/sagetrac-mirror/commit/9167071e5e8408c33125b551168d43c5f4539d19)** to **[`83b8057`](https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c)**",
    "created_at": "2015-08-19T08:08:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267576",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`9167071`](https://github.com/sagemath/sagetrac-mirror/commit/9167071e5e8408c33125b551168d43c5f4539d19)** to **[`83b8057`](https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c)**



---

archive/issue_comments_267577.json:
```json
{
    "body": "<div id=\"comment:29\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c\"><code>83b8057</code></a></td><td><code>Small corrections</code></td></tr></table>\n",
    "created_at": "2015-08-19T08:08:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267577",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:29"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c"><code>83b8057</code></a></td><td><code>Small corrections</code></td></tr></table>




---

archive/issue_events_267478.json:
```json
{
    "actor": "https://github.com/sagetrac-borassi",
    "created_at": "2015-08-19T08:13:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267478"
}
```



---

archive/issue_events_267479.json:
```json
{
    "actor": "https://github.com/sagetrac-borassi",
    "created_at": "2015-08-19T08:13:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267479"
}
```



---

archive/issue_comments_267578.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nDone!",
    "created_at": "2015-08-19T08:13:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267578",
    "user": "https://github.com/sagetrac-borassi"
}
```

<div id="comment:30" align="right">comment:30</div>

Done!



---

archive/issue_events_267480.json:
```json
{
    "actor": "https://github.com/dcoudert",
    "created_at": "2015-08-19T09:59:56Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267480"
}
```



---

archive/issue_events_267481.json:
```json
{
    "actor": "https://github.com/dcoudert",
    "created_at": "2015-08-19T09:59:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267481"
}
```



---

archive/issue_comments_267579.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">comment:31</div>\n\nThis patch passes all tests/docbuild/etc. on my mac.\n\nDavid.",
    "created_at": "2015-08-19T09:59:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267579",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:31" align="right">comment:31</div>

This patch passes all tests/docbuild/etc. on my mac.

David.



---

archive/issue_comments_267580.json:
```json
{
    "body": "Changed branch from **[u/borassi/tarjan_strongly_connected_components_algorithm](https://github.com/sagemath/sagetrac-mirror/tree/u/borassi/tarjan_strongly_connected_components_algorithm)** to **[`83b8057`](https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c)**",
    "created_at": "2015-08-21T01:56:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267580",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[u/borassi/tarjan_strongly_connected_components_algorithm](https://github.com/sagemath/sagetrac-mirror/tree/u/borassi/tarjan_strongly_connected_components_algorithm)** to **[`83b8057`](https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c)**



---

archive/issue_events_267482.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-08-21T01:56:19Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267482"
}
```



---

archive/issue_events_267483.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "06caecc18fcaca3700bea6c696db217f383b46d3",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2015-08-21T01:56:19Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/19014#event-267483"
}
```



---

archive/issue_comments_267581.json:
```json
{
    "body": "Changed commit from **[`83b8057`](https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c)** to none",
    "created_at": "2017-06-02T09:38:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267581",
    "user": "https://github.com/jdemeyer"
}
```

Changed commit from **[`83b8057`](https://github.com/sagemath/sagetrac-mirror/commit/83b80570cb8a41975fbe856d8a319a54c43ee63c)** to none



---

archive/issue_comments_267582.json:
```json
{
    "body": "<div id=\"comment:33\" align=\"right\">comment:33</div>\n\nReplying to [@dcoudert](#comment%3A13):\n> \n> ```\n> cdef int i\n> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here\n> for i,v in enumerate(G.vertex_iterator()):\n>     output[scc[i]].append(v)\n> ```\n\nWhy the `# We cannot use [] here`??? I am changing this in #23123 to use `[]`.",
    "created_at": "2017-06-02T09:38:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267582",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:33" align="right">comment:33</div>

Replying to [@dcoudert](#comment%3A13):
> 
> ```
> cdef int i
> cdef list output = list(list() for i in range(nscc))  # We cannot use [] here
> for i,v in enumerate(G.vertex_iterator()):
>     output[scc[i]].append(v)
> ```

Why the `# We cannot use [] here`??? I am changing this in #23123 to use `[]`.



---

archive/issue_comments_267583.json:
```json
{
    "body": "<div id=\"comment:34\" align=\"right\">comment:34</div>\n\nIf I remember well (but it was 2 years ago), at the time Michele implemented the method,  the `output` list was containing `nscc` pointers to the same (empty) list when using `[]`.",
    "created_at": "2017-06-03T10:36:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/19014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/19014#issuecomment-267583",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:34" align="right">comment:34</div>

If I remember well (but it was 2 years ago), at the time Michele implemented the method,  the `output` list was containing `nscc` pointers to the same (empty) list when using `[]`.
