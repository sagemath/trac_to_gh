# Issue 19628: lazy_import breaks CachedRepresentation

archive/issues_019391.json:
```json
{
    "body": "CC:  @vbraun @jdemeyer mmezzaroba simonking @nthiery\n\n`NN` is a lazy_import and therefore we have\n\n```\nsage: NonNegativeIntegerSemiring() == NN\nFalse\n```\nbut\n\n```\nsage: NN == NonNegativeIntegerSemiring()\nTrue\nsage: NonNegativeIntegerSemiring() == NN._get_object()\nTrue\n```\n\nThis gives problems with `CachedRepresentation`:\n\n```\nsage: from sage.misc.lazy_import import LazyImport\nsage: lazyZZ = LazyImport('sage.rings.integer_ring', 'ZZ')\nsage: PolynomialRing(lazyZZ, 'x') is PolynomialRing(ZZ, 'x')\nFalse\n```\n\nIssue created by migration from https://trac.sagemath.org/ticket/19628\n\n",
    "closed_at": "2018-02-22T17:40:52Z",
    "created_at": "2015-11-27T10:28:35Z",
    "labels": [
        "component: coercion",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.0",
    "title": "lazy_import breaks CachedRepresentation",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19628",
    "user": "https://github.com/cheuberg"
}
```
CC:  @vbraun @jdemeyer mmezzaroba simonking @nthiery

`NN` is a lazy_import and therefore we have

```
sage: NonNegativeIntegerSemiring() == NN
False
```
but

```
sage: NN == NonNegativeIntegerSemiring()
True
sage: NonNegativeIntegerSemiring() == NN._get_object()
True
```

This gives problems with `CachedRepresentation`:

```
sage: from sage.misc.lazy_import import LazyImport
sage: lazyZZ = LazyImport('sage.rings.integer_ring', 'ZZ')
sage: PolynomialRing(lazyZZ, 'x') is PolynomialRing(ZZ, 'x')
False
```

Issue created by migration from https://trac.sagemath.org/ticket/19628





---

archive/issue_comments_266254.json:
```json
{
    "body": "The attached branch is the one which exhibits the error.",
    "created_at": "2015-11-27T10:29:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266254",
    "user": "https://github.com/cheuberg"
}
```

The attached branch is the one which exhibits the error.



---

archive/issue_comments_266255.json:
```json
{
    "body": "Changing component from numerical to coercion.",
    "created_at": "2015-11-27T12:59:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266255",
    "user": "https://github.com/jdemeyer"
}
```

Changing component from numerical to coercion.



---

archive/issue_comments_266256.json:
```json
{
    "body": "Should we special-case `LazyImport` in `WithEqualityById`?",
    "created_at": "2015-11-27T13:55:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266256",
    "user": "https://github.com/jdemeyer"
}
```

Should we special-case `LazyImport` in `WithEqualityById`?



---

archive/issue_comments_266257.json:
```json
{
    "body": "There are many subtle problems with lazy_import and some of them are fairly fundamental. The basic take-away is: don't lazy_import objects, but lazy_import functions that produce objects (`NN` is problematic but `NonNegativeIntegerSemiring()` is not).\n\n`LazyImport` objects try to be as transparent as possible, but obviously won't succeed perfectly. They try to remove themselves once non-trivially accessed (that is, basically when one of their attributes gets accessed), and essentially LazyImport objects should *only* be used to look up attributes on.\n\nMany of our `LazyImport` objects get further imported erroneously. For instance, importing a `LazyImport` object from elsewhere via a `from ... import <LazyImportObject>` doesn't work properly, because the LazyImport object doesn't get an opportunity to know about the new namespace in which it gets imported. An example is `NN` as referenced here.\n\nIf we insert a little helper function into `sage.misc.lazy_import` (it has to be there because `lazy_import` doesn't offer a `pxd`):\n\n```\ndef att(a):\n    cdef LazyImport b\n    b = a\n    return {\"_object\": b._object,\n            \"_module\": b._module,\n            \"_name\": b._name,\n            \"_as_name\": b._as_name,\n            \"_namespace\": b._namespace,\n            \"_at_startup\": b._at_startup,\n            \"_deprecation\": b._deprecation}\n```\nthen you can see from\n\n```\nsage: sage.misc.lazy_import.att(NN)['_namespace']['__name__']\n'sage.rings.semirings.all'\nsage: sage.misc.lazy_import.att(NN)['_name']\n'NN'\nsage: sage.misc.lazy_import.att(NN)['_as_name']\n'NN'\n```\nthat accessing `NN` in the toplevel scope will never resolve. On every access, the `LazyImport` object will dutifully search the `sage.rings.semirings.all` scope to replace its occurrence there (which only happens the first time of course), but that's not the binding through which it gets accessed afterwards.\n\nIf instead you do (and this is how NN should be imported into the toplevel if at all):\n\n```\nsage: lazy_import(sage.misc.lazy_import.att(NN)['_module'], sage.misc.lazy_import.att(NN)['_name'])\nsage: type(NN)\n<type 'sage.misc.lazy_import.LazyImport'>\nsage: NN\nNon negative integer semiring\nsage: type(NN)\n<class 'sage.rings.semirings.non_negative_integer_semiring.NonNegativeIntegerSemiring_with_category'>\n```\nAs you can see, basically even\n\n```\nfrom sage.rings.semirings.non_negative_integer_semiring import NN\n```\nis an erroneous use of a `LazyImport` object, because it does not amount to attribute lookup.\n\nThe reason why mathematically interesting objects themselves should probably not be lazily imported, but only their access functions is because\n\n```\nsage: { NN : 1 }\n```\nwill always be problematic: The LazyImport object doesn't get a chance to remove itself.\n\nOn the other hand, accessing the object via `NonNegativeIntegerSemiring()` works nicely.\n\nOf course, `NonNegativeIntegerSemiring` itself is incorrectly imported.\n\nWe could clean up scopes (but that should happen in basically all `__all__` files etc.) via something along the lines of:\n\n```\nscope=globals()\nfor name,value in scope.iteritems():\n    if isinstance(value,sage.misc.lazy_import.LazyImport):\n        T= sage.misc.lazy_import.att(value)\n        if T['_namespace'] is not scope:\n            scope[name] = sage.misc.lazy_import.LazyImport(T['_module'],T['_name'],T['_as_name'],scope,T['_at_startup'],T['_deprecation'])\n```\n\nRather than hobbling EqualityById to accommodate for the hack that is `LazyImport`, we should avoid erroneous use of `LazyImport`. The problem with `EqualityById` is just a symptom of a general problem. There are many tickets about this, see e.g. #12482",
    "created_at": "2015-11-27T19:52:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266257",
    "user": "https://github.com/nbruin"
}
```

There are many subtle problems with lazy_import and some of them are fairly fundamental. The basic take-away is: don't lazy_import objects, but lazy_import functions that produce objects (`NN` is problematic but `NonNegativeIntegerSemiring()` is not).

`LazyImport` objects try to be as transparent as possible, but obviously won't succeed perfectly. They try to remove themselves once non-trivially accessed (that is, basically when one of their attributes gets accessed), and essentially LazyImport objects should *only* be used to look up attributes on.

Many of our `LazyImport` objects get further imported erroneously. For instance, importing a `LazyImport` object from elsewhere via a `from ... import <LazyImportObject>` doesn't work properly, because the LazyImport object doesn't get an opportunity to know about the new namespace in which it gets imported. An example is `NN` as referenced here.

If we insert a little helper function into `sage.misc.lazy_import` (it has to be there because `lazy_import` doesn't offer a `pxd`):

```
def att(a):
    cdef LazyImport b
    b = a
    return {"_object": b._object,
            "_module": b._module,
            "_name": b._name,
            "_as_name": b._as_name,
            "_namespace": b._namespace,
            "_at_startup": b._at_startup,
            "_deprecation": b._deprecation}
```
then you can see from

```
sage: sage.misc.lazy_import.att(NN)['_namespace']['__name__']
'sage.rings.semirings.all'
sage: sage.misc.lazy_import.att(NN)['_name']
'NN'
sage: sage.misc.lazy_import.att(NN)['_as_name']
'NN'
```
that accessing `NN` in the toplevel scope will never resolve. On every access, the `LazyImport` object will dutifully search the `sage.rings.semirings.all` scope to replace its occurrence there (which only happens the first time of course), but that's not the binding through which it gets accessed afterwards.

If instead you do (and this is how NN should be imported into the toplevel if at all):

```
sage: lazy_import(sage.misc.lazy_import.att(NN)['_module'], sage.misc.lazy_import.att(NN)['_name'])
sage: type(NN)
<type 'sage.misc.lazy_import.LazyImport'>
sage: NN
Non negative integer semiring
sage: type(NN)
<class 'sage.rings.semirings.non_negative_integer_semiring.NonNegativeIntegerSemiring_with_category'>
```
As you can see, basically even

```
from sage.rings.semirings.non_negative_integer_semiring import NN
```
is an erroneous use of a `LazyImport` object, because it does not amount to attribute lookup.

The reason why mathematically interesting objects themselves should probably not be lazily imported, but only their access functions is because

```
sage: { NN : 1 }
```
will always be problematic: The LazyImport object doesn't get a chance to remove itself.

On the other hand, accessing the object via `NonNegativeIntegerSemiring()` works nicely.

Of course, `NonNegativeIntegerSemiring` itself is incorrectly imported.

We could clean up scopes (but that should happen in basically all `__all__` files etc.) via something along the lines of:

```
scope=globals()
for name,value in scope.iteritems():
    if isinstance(value,sage.misc.lazy_import.LazyImport):
        T= sage.misc.lazy_import.att(value)
        if T['_namespace'] is not scope:
            scope[name] = sage.misc.lazy_import.LazyImport(T['_module'],T['_name'],T['_as_name'],scope,T['_at_startup'],T['_deprecation'])
```

Rather than hobbling EqualityById to accommodate for the hack that is `LazyImport`, we should avoid erroneous use of `LazyImport`. The problem with `EqualityById` is just a symptom of a general problem. There are many tickets about this, see e.g. #12482



---

archive/issue_comments_266258.json:
```json
{
    "body": "Replying to [comment:12 nbruin]:\n> We could clean up scopes (but that should happen in basically all `__all__` files etc.)\n\nOf course, now the question becomes: which scopes? If you can hand me a list of `dict`s which contain all relevant lazy imports, we can indeed do something.\n\n> There are many tickets about this, see e.g. #12482\n\nThanks for the pointer, I fixed this.",
    "created_at": "2015-11-30T09:04:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266258",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:12 nbruin]:
> We could clean up scopes (but that should happen in basically all `__all__` files etc.)

Of course, now the question becomes: which scopes? If you can hand me a list of `dict`s which contain all relevant lazy imports, we can indeed do something.

> There are many tickets about this, see e.g. #12482

Thanks for the pointer, I fixed this.



---

archive/issue_comments_266259.json:
```json
{
    "body": "One thing which we could easily do is to change `cached_function()` and friends to automatically dereference lazy imports. This will fix at least the problem with `CachedRepresentation` I think.",
    "created_at": "2015-11-30T09:10:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266259",
    "user": "https://github.com/jdemeyer"
}
```

One thing which we could easily do is to change `cached_function()` and friends to automatically dereference lazy imports. This will fix at least the problem with `CachedRepresentation` I think.



---

archive/issue_comments_266260.json:
```json
{
    "body": "Still if we agree that it can't be done safely then maybe it's a bad idea?\n\nAn alternative might be to have a proxy object that, instead of trying to look like the original object, relies on the preparser to replace it? E.g. the preparser replaces `NN` with `NonNegativeIntegerSemiring()`. And library code would be forced to import from the original location.",
    "created_at": "2015-11-30T09:17:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266260",
    "user": "https://github.com/vbraun"
}
```

Still if we agree that it can't be done safely then maybe it's a bad idea?

An alternative might be to have a proxy object that, instead of trying to look like the original object, relies on the preparser to replace it? E.g. the preparser replaces `NN` with `NonNegativeIntegerSemiring()`. And library code would be forced to import from the original location.



---

archive/issue_comments_266261.json:
```json
{
    "body": "Replying to [comment:16 vbraun]:\n> Still if we agree that it can't be done safely then maybe it's a bad idea?\n\nWhat do the two \"it\"s refer to in this sentence?\n\nFixing cached functions can be done safely. We already pre-process arguments to cached functions in `src/sage/misc/function_mangling.pyx`, so it's not hard to also dereference lazy imports there. Of course this does not fix every single use-case of lazy imports, but this is still an important use-case.\n\nAutomatically \"fixing\" lazy imports in `globals()`-like dicts can be done, but there the hard problem is to determine which dicts should be processed.\n\n> An alternative might be to have a proxy object that, instead of trying to look like the original object, relies on the preparser to replace it? E.g. the preparser replaces `NN` with `NonNegativeIntegerSemiring()`.\n\n\nI'm not convinced that we want to involve the preparser for this. What if somebody writes\n\n```\nsage: NN = some_completely_unrelated_object\nsage: f(NN)\n```\nyou don't want this to be replaced by\n\n```\nsage: NonNegativeIntegerSemiring() = some_completely_unrelated_object\nsage: f(NonNegativeIntegerSemiring())\n```",
    "created_at": "2015-11-30T09:41:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266261",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:16 vbraun]:
> Still if we agree that it can't be done safely then maybe it's a bad idea?

What do the two "it"s refer to in this sentence?

Fixing cached functions can be done safely. We already pre-process arguments to cached functions in `src/sage/misc/function_mangling.pyx`, so it's not hard to also dereference lazy imports there. Of course this does not fix every single use-case of lazy imports, but this is still an important use-case.

Automatically "fixing" lazy imports in `globals()`-like dicts can be done, but there the hard problem is to determine which dicts should be processed.

> An alternative might be to have a proxy object that, instead of trying to look like the original object, relies on the preparser to replace it? E.g. the preparser replaces `NN` with `NonNegativeIntegerSemiring()`.


I'm not convinced that we want to involve the preparser for this. What if somebody writes

```
sage: NN = some_completely_unrelated_object
sage: f(NN)
```
you don't want this to be replaced by

```
sage: NonNegativeIntegerSemiring() = some_completely_unrelated_object
sage: f(NonNegativeIntegerSemiring())
```



---

archive/issue_comments_266262.json:
```json
{
    "body": "Replying to [comment:13 jdemeyer]:\n\n> Of course, now the question becomes: which scopes? If you can hand me a list of `dict`s which contain all relevant lazy imports, we can indeed do something.\n\n\nAll scopes that `from ... import` a symbol that is a `LazyImport`. That includes many \"all\" files. Each of those should basically finish with a\n\n```\nsage.misc.lazy_import.fix_sloppily_constructed_namespace(globals())\n```\n(and then we should hope that no fancy shenanigans have happened with the bindings during module initialization)\n\nWe should consider how badly this affects startup times. In time-critical bits, it may be better to use a fresh `lazy_import` command instead instead of fixing the namespace afterwards.\n\nOne could run this process on `[m for m in sys.modules().itervalues() if m is not None]` (there are quite some entries in there that are None. I don't know what they're doing there. Vanilla python has that too), but we'd really be meddling with data that isn't ours, so I'd expect that to lead to more fragileness.\n\nThe namespaces registered under `sys.modules()` would certainly provide a good starting point for assessing the scale of the problem.",
    "created_at": "2015-11-30T16:44:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266262",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:13 jdemeyer]:

> Of course, now the question becomes: which scopes? If you can hand me a list of `dict`s which contain all relevant lazy imports, we can indeed do something.


All scopes that `from ... import` a symbol that is a `LazyImport`. That includes many "all" files. Each of those should basically finish with a

```
sage.misc.lazy_import.fix_sloppily_constructed_namespace(globals())
```
(and then we should hope that no fancy shenanigans have happened with the bindings during module initialization)

We should consider how badly this affects startup times. In time-critical bits, it may be better to use a fresh `lazy_import` command instead instead of fixing the namespace afterwards.

One could run this process on `[m for m in sys.modules().itervalues() if m is not None]` (there are quite some entries in there that are None. I don't know what they're doing there. Vanilla python has that too), but we'd really be meddling with data that isn't ours, so I'd expect that to lead to more fragileness.

The namespaces registered under `sys.modules()` would certainly provide a good starting point for assessing the scale of the problem.



---

archive/issue_comments_266263.json:
```json
{
    "body": "Replying to [comment:18 jdemeyer]:\n> What if somebody writes\n> \n> ```\n> sage: NN = some_completely_unrelated_object\n> sage: f(NN)\n> ```\n\n\nThat would be perfectly fine. The preparser can't be a regex but has to look at the AST, of course. IPython already has support for that. Its also easier to implement since it leverages the Python parser.",
    "created_at": "2015-11-30T16:58:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266263",
    "user": "https://github.com/vbraun"
}
```

Replying to [comment:18 jdemeyer]:
> What if somebody writes
> 
> ```
> sage: NN = some_completely_unrelated_object
> sage: f(NN)
> ```


That would be perfectly fine. The preparser can't be a regex but has to look at the AST, of course. IPython already has support for that. Its also easier to implement since it leverages the Python parser.



---

archive/issue_comments_266264.json:
```json
{
    "body": "Replying to [comment:18 jdemeyer]:\n> > Still if we agree that it can't be done safely then maybe it's a bad idea?\n\n> What do the two \"it\"s refer to in this sentence?\n\nBoth \"it\" refer to \"import of any object for which 'is'-comparison matters\". As opposed to factory functions.",
    "created_at": "2015-11-30T17:02:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266264",
    "user": "https://github.com/vbraun"
}
```

Replying to [comment:18 jdemeyer]:
> > Still if we agree that it can't be done safely then maybe it's a bad idea?

> What do the two "it"s refer to in this sentence?

Both "it" refer to "import of any object for which 'is'-comparison matters". As opposed to factory functions.



---

archive/issue_comments_266265.json:
```json
{
    "body": "OK, and these are the counts for lazy_import objects bound in scopes that is not theirs:\n\n```\nfrom sage.misc.lazy_import import LazyImport,att #that's the helper function\ndef misbound_lazies(S):\n  return [k for k,v in S.iteritems() if type(v) is LazyImport and att(v)['_namespace'] is not S]\nM=[(k,len(misbound_lazies(m.__dict__))) for k,m in sys.modules.iteritems() if m is not None]\n```\n\n```\nsage: [m for m in M if m[1] > 0]\n[('sage.combinat.tableau_tuple', 1),\n ('sage.libs.linbox.linbox', 1),\n ('sage.groups.libgap_mixin', 1),\n ('__main__', 190),\n ('sage.categories.all', 1),\n ('sage.combinat.all', 34),\n ('sage.calculus.all', 1),\n ('sage.geometry.all', 3),\n ('sage.functions.piecewise', 1),\n ('sage.structure.sage_object', 1),\n ('sage.combinat.partition_tuple', 1),\n ('sage.modular.arithgroup.congroup_generic', 1),\n ('sage.schemes.all', 6),\n ('sage.rings.all', 3),\n ('sage.functions.special', 1),\n ('sage.functions.airy', 1),\n ('sage.all_cmdline', 190),\n ('sage.libs.pari.gen_py', 4),\n ('sage.structure.coerce', 1),\n ('sage.functions.bessel', 1),\n ('sage.functions.orthogonal_polys', 1),\n ('sage.numerical.interactive_simplex_method', 1),\n ('sage.combinat.integer_vectors_mod_permgroup', 1),\n ('sage.groups.all', 10),\n ('sage.combinat.crystals.tensor_product', 1),\n ('sage.combinat.composition', 1),\n ('sage.categories.groups', 1),\n ('sage.combinat.partition', 1),\n ('sage.all', 165)]\nsage: len(set(flatten([misbound_lazies(m.__dict__) for m in sys.modules.values() if m is not None])))\n195\n```\nSo, assuming that symbol name is a good indication, there seem to be about 195 distinct lazy_import objects around that are bound in wrong scopes.\n\nMost frequently occurring:\n\n```\nsage: L=[misbound_lazies(m.__dict__) for m in sys.modules.values() if m is not None]\nsage: sorted(Counter(flatten(L)).items(),key=lambda a:a[1])[-20:]\n[('WehlerK3Surface', 4),\n ('ClusterQuiver', 4),\n ('CrystalOfNakajimaMonomials', 4),\n ('KostkaFoulkesPolynomial', 4),\n ('polytopes', 4),\n ('ExtendedAffineWeylGroup', 4),\n ('QuaternionMatrixGroupGF3', 4),\n ('KirillovReshetikhinTableaux', 4),\n ('CrystalOfGeneralizedYoungWalls', 4),\n ('maxima_calculus', 4),\n ('AffineCrystalFromClassical', 4),\n ('ClusterSeed', 4),\n ('QuiverMutationType', 4),\n ('maxima', 4),\n ('NonNegativeIntegerSemiring', 5),\n ('Polyhedron', 5),\n ('MatrixGroup', 5),\n ('AsymptoticRing', 5),\n ('cartesian_product', 7),\n ('NN', 9)]\n```",
    "created_at": "2015-11-30T17:05:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266265",
    "user": "https://github.com/nbruin"
}
```

OK, and these are the counts for lazy_import objects bound in scopes that is not theirs:

```
from sage.misc.lazy_import import LazyImport,att #that's the helper function
def misbound_lazies(S):
  return [k for k,v in S.iteritems() if type(v) is LazyImport and att(v)['_namespace'] is not S]
M=[(k,len(misbound_lazies(m.__dict__))) for k,m in sys.modules.iteritems() if m is not None]
```

```
sage: [m for m in M if m[1] > 0]
[('sage.combinat.tableau_tuple', 1),
 ('sage.libs.linbox.linbox', 1),
 ('sage.groups.libgap_mixin', 1),
 ('__main__', 190),
 ('sage.categories.all', 1),
 ('sage.combinat.all', 34),
 ('sage.calculus.all', 1),
 ('sage.geometry.all', 3),
 ('sage.functions.piecewise', 1),
 ('sage.structure.sage_object', 1),
 ('sage.combinat.partition_tuple', 1),
 ('sage.modular.arithgroup.congroup_generic', 1),
 ('sage.schemes.all', 6),
 ('sage.rings.all', 3),
 ('sage.functions.special', 1),
 ('sage.functions.airy', 1),
 ('sage.all_cmdline', 190),
 ('sage.libs.pari.gen_py', 4),
 ('sage.structure.coerce', 1),
 ('sage.functions.bessel', 1),
 ('sage.functions.orthogonal_polys', 1),
 ('sage.numerical.interactive_simplex_method', 1),
 ('sage.combinat.integer_vectors_mod_permgroup', 1),
 ('sage.groups.all', 10),
 ('sage.combinat.crystals.tensor_product', 1),
 ('sage.combinat.composition', 1),
 ('sage.categories.groups', 1),
 ('sage.combinat.partition', 1),
 ('sage.all', 165)]
sage: len(set(flatten([misbound_lazies(m.__dict__) for m in sys.modules.values() if m is not None])))
195
```
So, assuming that symbol name is a good indication, there seem to be about 195 distinct lazy_import objects around that are bound in wrong scopes.

Most frequently occurring:

```
sage: L=[misbound_lazies(m.__dict__) for m in sys.modules.values() if m is not None]
sage: sorted(Counter(flatten(L)).items(),key=lambda a:a[1])[-20:]
[('WehlerK3Surface', 4),
 ('ClusterQuiver', 4),
 ('CrystalOfNakajimaMonomials', 4),
 ('KostkaFoulkesPolynomial', 4),
 ('polytopes', 4),
 ('ExtendedAffineWeylGroup', 4),
 ('QuaternionMatrixGroupGF3', 4),
 ('KirillovReshetikhinTableaux', 4),
 ('CrystalOfGeneralizedYoungWalls', 4),
 ('maxima_calculus', 4),
 ('AffineCrystalFromClassical', 4),
 ('ClusterSeed', 4),
 ('QuiverMutationType', 4),
 ('maxima', 4),
 ('NonNegativeIntegerSemiring', 5),
 ('Polyhedron', 5),
 ('MatrixGroup', 5),
 ('AsymptoticRing', 5),
 ('cartesian_product', 7),
 ('NN', 9)]
```



---

archive/issue_comments_266266.json:
```json
{
    "body": "Replying to [comment:21 vbraun]:\n> Both \"it\" refer to \"import of any object for which 'is'-comparison matters\". As opposed to factory functions.\n\n\nNow the question becomes: to what extent does equality matter? One of my proposals is to fix lazy imports in cached functions. That would seriously reduce the extent to which equality matters. It would certainly fix this:\n\n```\nsage: from sage.misc.lazy_import import LazyImport\nsage: lazyZZ = LazyImport('sage.rings.integer_ring', 'ZZ')\nsage: PolynomialRing(lazyZZ, 'x') is PolynomialRing(ZZ, 'x')\nFalse\n```\n\nWhat do you think about this?",
    "created_at": "2015-11-30T18:09:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266266",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:21 vbraun]:
> Both "it" refer to "import of any object for which 'is'-comparison matters". As opposed to factory functions.


Now the question becomes: to what extent does equality matter? One of my proposals is to fix lazy imports in cached functions. That would seriously reduce the extent to which equality matters. It would certainly fix this:

```
sage: from sage.misc.lazy_import import LazyImport
sage: lazyZZ = LazyImport('sage.rings.integer_ring', 'ZZ')
sage: PolynomialRing(lazyZZ, 'x') is PolynomialRing(ZZ, 'x')
False
```

What do you think about this?



---

archive/issue_comments_266267.json:
```json
{
    "body": "Replying to [comment:23 jdemeyer]:\n> Now the question becomes: to what extent does equality matter? One of my proposals is to fix lazy imports in cached functions. That would seriously reduce the extent to which equality matters. It would certainly fix this:\n> \n> ```\n> sage: from sage.misc.lazy_import import LazyImport\n> sage: lazyZZ = LazyImport('sage.rings.integer_ring', 'ZZ')\n> sage: PolynomialRing(lazyZZ, 'x') is PolynomialRing(ZZ, 'x')\n> False\n> ```\n> What do you think about this?\n\nI know that Robert Bradshaw did not endorse the use of `LazyImport` for imports like this. The intended usage scenario was really just to replace \"import\" with a few extensions to support \"from .. import ..\" for functions/classes/submodules. He was fully aware that the shim that `LazyImport` objects provide is imperfect. In his opinion, you shouldn't import `ZZ` this way. You can lazy-import sage.rings.integer_ring as integer_ring and then address ZZ as integer_ring.ZZ.\n\nYou can of course try to extend the use of lazy_import and see if you can get it to work for things like NN as well. However, you'll find (as some examples have shown) that it's always fundamentally problematic. I think we're better off rooting out the \"bad use\" than trying to (imperfectly) support it. It would be nice to support lazy importing like this fully, but I think it would require hacking python to an uncomfortable degree.\n\nThe problem isn't huge: I think `NN` is the worst symbol like this. Perhaps we can just not lazily import it? or otherwise make it accessible via an accessor function or via a lazily imported namespace (rather than importing NN lazily itself).\n\nFor a pretty complete tally: (so we're talking about 291 objects)\n\n```\nsage: def lazy_names(S):\n....:      return [k for k,v in S.iteritems() if type(v) is LazyImport]\nsage: L=[lazy_names(m.__dict__) for m in sys.modules.values() if m is not None]\nsage: len(Counter(flatten(L)))\n291\n```\nThere are a lot of interesting bindings there, though:\n\n```\nsage: type(sage.misc.misc.SAGE_ROOT)\n<type 'sage.misc.lazy_import.LazyImport'>\n```\n\nTo see the types of these lazy import objects:\n\n```\nfrom sage.misc.lazy_import import LazyImport,att\nfrom collections import Counter\ndef lazy_objects(S):\n  return [v for k,v in S.iteritems() if type(v) is LazyImport]\n\nL=[lazy_objects(m.__dict__) for m in sys.modules.values() if m is not None]\nO=[]\nfor l in L: O.extend(l)\n%cpaste\nfor o in O: #try to load all objects\n  try:\n    _=repr(o)\n  except:\n    pass\n--\nCounter([type(att(o)[\"_object\"]) for o in O])\n```\nWhich gives:\n\n```\nsage: list(Counter([type(att(o)[\"_object\"]) for o in O]))\n[<class 'sage.rings.semirings.non_negative_integer_semiring.NonNegativeIntegerSemiring_with_category'>,\n <type 'sage.misc.inherit_comparison.InheritComparisonMetaclass'>,\n <type 'sage.misc.lazy_import.LazyImport'>,\n <class 'sage.combinat.cluster_algebra_quiver.quiver_mutation_type.QuiverMutationTypeFactory'>,\n <type 'module'>,\n <class 'sage.modular.arithgroup.congroup_sl2z.SL2Z_class_with_category'>,\n <class 'sage.categories.cartesian_product.CartesianProductFunctor'>,\n <type 'dict'>,\n <class 'sage.combinat.finite_state_machine_generators.AutomatonGenerators'>,\n <class 'sage.geometry.hyperplane_arrangement.library.HyperplaneArrangementLibrary'>,\n <type 'instance'>,\n <class 'sage.combinat.finite_state_machine_generators.TransducerGenerators'>,\n <class 'sage.libs.gap.libgap.Gap'>,\n <type 'bool'>,\n <type 'str'>,\n <class 'sage.dev.sagedev_wrapper.SageDevWrapper'>,\n <type 'NoneType'>,\n <type 'sage.misc.classcall_metaclass.ClasscallMetaclass'>,\n <class 'sage.interfaces.genus2reduction.Genus2reduction'>,\n <type 'function'>,\n <class 'sage.interfaces.maxima_lib.MaximaLib'>,\n <type 'builtin_function_or_method'>,\n <type 'list'>,\n <type 'type'>,\n <class 'sage.databases.findstat.FindStat'>,\n <class 'sage.rings.invariant_theory.InvariantTheoryFactory'>,\n <class 'sage.misc.inherit_comparison.InheritComparisonClasscallMetaclass'>,\n <class 'abc.ABCMeta'>]\n```\nMost of these objects are straightforward callables, that are unlikely to be used as objects to be worked with. The remaining objects could be investigated if they need to by lazily imported by themselves or whether some surrounding scope can be lazily imported instead.",
    "created_at": "2015-11-30T18:54:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266267",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:23 jdemeyer]:
> Now the question becomes: to what extent does equality matter? One of my proposals is to fix lazy imports in cached functions. That would seriously reduce the extent to which equality matters. It would certainly fix this:
> 
> ```
> sage: from sage.misc.lazy_import import LazyImport
> sage: lazyZZ = LazyImport('sage.rings.integer_ring', 'ZZ')
> sage: PolynomialRing(lazyZZ, 'x') is PolynomialRing(ZZ, 'x')
> False
> ```
> What do you think about this?

I know that Robert Bradshaw did not endorse the use of `LazyImport` for imports like this. The intended usage scenario was really just to replace "import" with a few extensions to support "from .. import .." for functions/classes/submodules. He was fully aware that the shim that `LazyImport` objects provide is imperfect. In his opinion, you shouldn't import `ZZ` this way. You can lazy-import sage.rings.integer_ring as integer_ring and then address ZZ as integer_ring.ZZ.

You can of course try to extend the use of lazy_import and see if you can get it to work for things like NN as well. However, you'll find (as some examples have shown) that it's always fundamentally problematic. I think we're better off rooting out the "bad use" than trying to (imperfectly) support it. It would be nice to support lazy importing like this fully, but I think it would require hacking python to an uncomfortable degree.

The problem isn't huge: I think `NN` is the worst symbol like this. Perhaps we can just not lazily import it? or otherwise make it accessible via an accessor function or via a lazily imported namespace (rather than importing NN lazily itself).

For a pretty complete tally: (so we're talking about 291 objects)

```
sage: def lazy_names(S):
....:      return [k for k,v in S.iteritems() if type(v) is LazyImport]
sage: L=[lazy_names(m.__dict__) for m in sys.modules.values() if m is not None]
sage: len(Counter(flatten(L)))
291
```
There are a lot of interesting bindings there, though:

```
sage: type(sage.misc.misc.SAGE_ROOT)
<type 'sage.misc.lazy_import.LazyImport'>
```

To see the types of these lazy import objects:

```
from sage.misc.lazy_import import LazyImport,att
from collections import Counter
def lazy_objects(S):
  return [v for k,v in S.iteritems() if type(v) is LazyImport]

L=[lazy_objects(m.__dict__) for m in sys.modules.values() if m is not None]
O=[]
for l in L: O.extend(l)
%cpaste
for o in O: #try to load all objects
  try:
    _=repr(o)
  except:
    pass
--
Counter([type(att(o)["_object"]) for o in O])
```
Which gives:

```
sage: list(Counter([type(att(o)["_object"]) for o in O]))
[<class 'sage.rings.semirings.non_negative_integer_semiring.NonNegativeIntegerSemiring_with_category'>,
 <type 'sage.misc.inherit_comparison.InheritComparisonMetaclass'>,
 <type 'sage.misc.lazy_import.LazyImport'>,
 <class 'sage.combinat.cluster_algebra_quiver.quiver_mutation_type.QuiverMutationTypeFactory'>,
 <type 'module'>,
 <class 'sage.modular.arithgroup.congroup_sl2z.SL2Z_class_with_category'>,
 <class 'sage.categories.cartesian_product.CartesianProductFunctor'>,
 <type 'dict'>,
 <class 'sage.combinat.finite_state_machine_generators.AutomatonGenerators'>,
 <class 'sage.geometry.hyperplane_arrangement.library.HyperplaneArrangementLibrary'>,
 <type 'instance'>,
 <class 'sage.combinat.finite_state_machine_generators.TransducerGenerators'>,
 <class 'sage.libs.gap.libgap.Gap'>,
 <type 'bool'>,
 <type 'str'>,
 <class 'sage.dev.sagedev_wrapper.SageDevWrapper'>,
 <type 'NoneType'>,
 <type 'sage.misc.classcall_metaclass.ClasscallMetaclass'>,
 <class 'sage.interfaces.genus2reduction.Genus2reduction'>,
 <type 'function'>,
 <class 'sage.interfaces.maxima_lib.MaximaLib'>,
 <type 'builtin_function_or_method'>,
 <type 'list'>,
 <type 'type'>,
 <class 'sage.databases.findstat.FindStat'>,
 <class 'sage.rings.invariant_theory.InvariantTheoryFactory'>,
 <class 'sage.misc.inherit_comparison.InheritComparisonClasscallMetaclass'>,
 <class 'abc.ABCMeta'>]
```
Most of these objects are straightforward callables, that are unlikely to be used as objects to be worked with. The remaining objects could be investigated if they need to by lazily imported by themselves or whether some surrounding scope can be lazily imported instead.



---

archive/issue_comments_266268.json:
```json
{
    "body": "Replying to [comment:24 nbruin]:\n> Replying to [comment:23 jdemeyer]:\n> > Now the question becomes: to what extent does equality matter? One of my proposals is to fix lazy imports in cached functions. That would seriously reduce the extent to which equality matters. It would certainly fix this:\n> > \n> > ```\n> > sage: from sage.misc.lazy_import import LazyImport\n> > sage: lazyZZ = LazyImport('sage.rings.integer_ring', 'ZZ')\n> > sage: PolynomialRing(lazyZZ, 'x') is PolynomialRing(ZZ, 'x')\n> > False\n> > ```\n> > What do you think about this?\n\n> I know that Robert Bradshaw did not endorse the use of `LazyImport` for imports like this.\nSure, it was just to give some kind of \"worst case\" example, with no namespace binding at all.",
    "created_at": "2015-11-30T19:18:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266268",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:24 nbruin]:
> Replying to [comment:23 jdemeyer]:
> > Now the question becomes: to what extent does equality matter? One of my proposals is to fix lazy imports in cached functions. That would seriously reduce the extent to which equality matters. It would certainly fix this:
> > 
> > ```
> > sage: from sage.misc.lazy_import import LazyImport
> > sage: lazyZZ = LazyImport('sage.rings.integer_ring', 'ZZ')
> > sage: PolynomialRing(lazyZZ, 'x') is PolynomialRing(ZZ, 'x')
> > False
> > ```
> > What do you think about this?

> I know that Robert Bradshaw did not endorse the use of `LazyImport` for imports like this.
Sure, it was just to give some kind of "worst case" example, with no namespace binding at all.



---

archive/issue_comments_266269.json:
```json
{
    "body": "Replying to [comment:24 nbruin]:\n> You can of course try to extend the use of lazy_import and see if you can get it to work for things like NN as well.\n\n\nI would certainly like to try that. It would be a pity if rings (like `NN`) are fundamentally incompatible with `lazy_import`. Consider `arb` for example: it makes sense to define a global `RBF` (for real ball field), analogous to `RR`. It also makes a lot of sense to lazily import this: it's unlikely to be commonly used, it would save an import of at least 2 Python modules and it would save the loading of the external library `libarb`.",
    "created_at": "2015-11-30T19:25:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266269",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:24 nbruin]:
> You can of course try to extend the use of lazy_import and see if you can get it to work for things like NN as well.


I would certainly like to try that. It would be a pity if rings (like `NN`) are fundamentally incompatible with `lazy_import`. Consider `arb` for example: it makes sense to define a global `RBF` (for real ball field), analogous to `RR`. It also makes a lot of sense to lazily import this: it's unlikely to be commonly used, it would save an import of at least 2 Python modules and it would save the loading of the external library `libarb`.



---

archive/issue_comments_266270.json:
```json
{
    "body": "Replying to [comment:26 jdemeyer]:\n> Replying to [comment:24 nbruin]:\n> > You can of course try to extend the use of lazy_import and see if you can get it to work for things like NN as well.\n\n> \n> I would certainly like to try that. It would be a pity if rings (like `NN`) are fundamentally incompatible with `lazy_import`. Consider `arb` for example: it makes sense to define a global `RBF` (for real ball field), analogous to `RR`. It also makes a lot of sense to lazily import this: it's unlikely to be commonly used, it would save an import of at least 2 Python modules and it would save the loading of the external library `libarb`.\n\n\nWe can do that at the cost of a namespace:\n\n```\nrealballfield.RBF\nnatural_numbers.NN\n```\n(where `realballfield` and `natural_numbers` can be lazily imported) or at the cost of an accessor function (lazily imported):\n\n```\nRealBallField()\nNaturalNumbers()\n```\nThe fact that\n\n```\nD=dict()\nD[NN]=1\nD[NN]=2\n```\nwill never work properly makes trying to pretend otherwise a non-starter in my opinion. You'd have to reach too deeply into python (you probably wouldn't even be able to distinguish between the \"initialization\" code where the Lazy object needs to be passed and genuine access, where you do need to dereference).\n\nWe could reach into various sage infrastructures and special-case LazyImports there, but in my opinion that would just increase the surprise factor when other constructs fail.",
    "created_at": "2015-11-30T19:49:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266270",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:26 jdemeyer]:
> Replying to [comment:24 nbruin]:
> > You can of course try to extend the use of lazy_import and see if you can get it to work for things like NN as well.

> 
> I would certainly like to try that. It would be a pity if rings (like `NN`) are fundamentally incompatible with `lazy_import`. Consider `arb` for example: it makes sense to define a global `RBF` (for real ball field), analogous to `RR`. It also makes a lot of sense to lazily import this: it's unlikely to be commonly used, it would save an import of at least 2 Python modules and it would save the loading of the external library `libarb`.


We can do that at the cost of a namespace:

```
realballfield.RBF
natural_numbers.NN
```
(where `realballfield` and `natural_numbers` can be lazily imported) or at the cost of an accessor function (lazily imported):

```
RealBallField()
NaturalNumbers()
```
The fact that

```
D=dict()
D[NN]=1
D[NN]=2
```
will never work properly makes trying to pretend otherwise a non-starter in my opinion. You'd have to reach too deeply into python (you probably wouldn't even be able to distinguish between the "initialization" code where the Lazy object needs to be passed and genuine access, where you do need to dereference).

We could reach into various sage infrastructures and special-case LazyImports there, but in my opinion that would just increase the surprise factor when other constructs fail.



---

archive/issue_comments_266271.json:
```json
{
    "body": "Replying to [comment:27 nbruin]:\n> You'd have to reach too deeply into python\n\n\nAre you thinking of `ma_lookup()`? That *could* work, but I agree that it would be a major hack.",
    "created_at": "2015-11-30T19:55:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266271",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:27 nbruin]:
> You'd have to reach too deeply into python


Are you thinking of `ma_lookup()`? That *could* work, but I agree that it would be a major hack.



---

archive/issue_comments_266272.json:
```json
{
    "body": "Replying to [comment:28 jdemeyer]:\n> Are you thinking of `ma_lookup()`? That *could* work, but I agree that it would be a major hack.\n\n\nThat would be one hook. But there's more.\n\n```\nsage: lazy_import(\"sage.rings.integer_ring\",\"ZZ\")\nsage: id(ZZ)\n140457737914168\nsage: ZZ\nInteger Ring\nsage: id(ZZ)\n140458433423744\n```\nNote that the user didn't rebind ZZ and yet its identity has changed. That can affect all kinds of things. You'd basically need `LazyImport` to be transparent for being put into argument lists as well. And that's just horrible (and undebuggable!). I think it would be a major maintainability penalty to try and support that kind of stuff, for relatively little gain. I would say the minor inconvenience for users that objects supported by code that is lazily imported cannot be available straight away in the top namespace is preferable.\n\nBut perhaps your experiments end up indicating something else.",
    "created_at": "2015-11-30T20:28:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266272",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:28 jdemeyer]:
> Are you thinking of `ma_lookup()`? That *could* work, but I agree that it would be a major hack.


That would be one hook. But there's more.

```
sage: lazy_import("sage.rings.integer_ring","ZZ")
sage: id(ZZ)
140457737914168
sage: ZZ
Integer Ring
sage: id(ZZ)
140458433423744
```
Note that the user didn't rebind ZZ and yet its identity has changed. That can affect all kinds of things. You'd basically need `LazyImport` to be transparent for being put into argument lists as well. And that's just horrible (and undebuggable!). I think it would be a major maintainability penalty to try and support that kind of stuff, for relatively little gain. I would say the minor inconvenience for users that objects supported by code that is lazily imported cannot be available straight away in the top namespace is preferable.

But perhaps your experiments end up indicating something else.



---

archive/issue_comments_266273.json:
```json
{
    "body": "Replying to [comment:29 nbruin]:\n> I would say the minor inconvenience for users that objects supported by code that is lazily imported cannot be available straight away in the top namespace is preferable.\n\n\nSo, what's your proposal then? Close this ticket as wontfix and change the lazy_import of `NN` (and similar objects) to a \"real\" import?\n\n> But perhaps your experiments end up indicating something else.\n\nWhich \"experiments\" do you mean? You mean with `ma_lookup()`?",
    "created_at": "2015-12-01T10:12:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266273",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:29 nbruin]:
> I would say the minor inconvenience for users that objects supported by code that is lazily imported cannot be available straight away in the top namespace is preferable.


So, what's your proposal then? Close this ticket as wontfix and change the lazy_import of `NN` (and similar objects) to a "real" import?

> But perhaps your experiments end up indicating something else.

Which "experiments" do you mean? You mean with `ma_lookup()`?



---

archive/issue_comments_266274.json:
```json
{
    "body": "Replying to [comment:30 jdemeyer]:\n> So, what's your proposal then? Close this ticket as wontfix and change the lazy_import of `NN` (and similar objects) to a \"real\" import?\n\n\nYes. Or if NN is too expensive to import at startup, adapt the places where NN is accessed (the count above shows about 10 modules (including `__main__` and I think some double counting) that reference it via a lazy import) in a way that triggers the import as soon as NN is accessed (i.e., either by accessing NN through a namespace that's lazily imported or via an accessor function). I don't see a reasonable alternative while maintaining a semantics model that at least resembles that of python.\n\nThe other thing we should do is clean up the mess of mis-lazy_imported objects. As the list above shows, a lot of lazy_imports don't have a chance of ever clearing themselves up. The penalty of accessing an object through a lazy_import isn't that high, but the problem is these things compound. We already have lazy_imports that point to lazy_imports.\n\nI propose:\n- adding a function that gives access to the lazy_import cdef attributes (probably just by returning a dict that has their values)\n- including a doctest that tests if lazy_import objects in sys.modules dicts reference their own scope.\n\nbut perhaps that's better handled on a different ticket.",
    "created_at": "2015-12-01T17:42:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266274",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:30 jdemeyer]:
> So, what's your proposal then? Close this ticket as wontfix and change the lazy_import of `NN` (and similar objects) to a "real" import?


Yes. Or if NN is too expensive to import at startup, adapt the places where NN is accessed (the count above shows about 10 modules (including `__main__` and I think some double counting) that reference it via a lazy import) in a way that triggers the import as soon as NN is accessed (i.e., either by accessing NN through a namespace that's lazily imported or via an accessor function). I don't see a reasonable alternative while maintaining a semantics model that at least resembles that of python.

The other thing we should do is clean up the mess of mis-lazy_imported objects. As the list above shows, a lot of lazy_imports don't have a chance of ever clearing themselves up. The penalty of accessing an object through a lazy_import isn't that high, but the problem is these things compound. We already have lazy_imports that point to lazy_imports.

I propose:
- adding a function that gives access to the lazy_import cdef attributes (probably just by returning a dict that has their values)
- including a doctest that tests if lazy_import objects in sys.modules dicts reference their own scope.

but perhaps that's better handled on a different ticket.



---

archive/issue_comments_266275.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-04-06T15:12:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266275",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_266276.json:
```json
{
    "body": "New commits:",
    "created_at": "2017-04-06T15:12:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266276",
    "user": "https://github.com/jdemeyer"
}
```

New commits:



---

archive/issue_events_053948.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2017-04-06T18:44:34Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "milestone": "sage-8.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19628#event-53948"
}
```



---

archive/issue_comments_266277.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-05-27T21:54:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266277",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_266278.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-05-27T21:55:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266278",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_266279.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-06-06T09:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266279",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_266280.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-06-06T12:08:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266280",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_266281.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-06-18T09:26:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266281",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_266282.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-02-21T13:06:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266282",
    "user": "https://github.com/embray"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_266283.json:
```json
{
    "body": "I haven't read all the comments on this ticket, but the problem statement is clear and the proposed fix makes perfect sense.",
    "created_at": "2018-02-21T13:06:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266283",
    "user": "https://github.com/embray"
}
```

I haven't read all the comments on this ticket, but the problem statement is clear and the proposed fix makes perfect sense.



---

archive/issue_events_053949.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2018-02-22T17:40:52Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19628#event-53949"
}
```



---

archive/issue_comments_266284.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-02-22T17:40:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19628",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19628#issuecomment-266284",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
