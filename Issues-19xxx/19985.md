# Issue 19985: Add is_partial_cube

archive/issues_019748.json:
```json
{
    "body": "This ticket adds a method `is_partial_cube` to the `Graph` class, which checks whether a graph is a partial cube. A partial cube is a graph that can be isometrically embedded into a hypercube, i.e., its vertices can be labelled with (0,1)-vectors of some fixed length such that the distance between any two vertices in the graph equals the Hamming distance of their labels. If requested, this labelling can also be returned by the method.\n\nThe code for this method comes from the PADS library by David Eppstein, which is available at http://www.ics.uci.edu/~eppstein/PADS/. The library is available under the MIT license, and I have also obtained permission from the author via email. The algorithm in question has been described in a paper available at http://arxiv.org/pdf/0705.1025.pdf.\n\nThe code has been changed to utilize Sage's structures (namely graphs, digraphs and disjoint sets). However, specialized breadth-first and depth-first search methods for graphs from the PADS library have also been added.\n\nCC:  @nathanncohen\n\nKeywords: graphs partial cubes\n\nReviewer: Nathann Cohen\n\nAuthor: Jano\u0161 Vidali\n\nBranch: 5a054a67e3ba364a113a4323a1c2404b5d263239\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/19985\n\n",
    "closed_at": "2016-02-11T23:26:32Z",
    "created_at": "2016-01-30T12:59:13Z",
    "labels": [
        "component: graph theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.1",
    "title": "Add is_partial_cube",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19985",
    "user": "https://github.com/jaanos"
}
```
This ticket adds a method `is_partial_cube` to the `Graph` class, which checks whether a graph is a partial cube. A partial cube is a graph that can be isometrically embedded into a hypercube, i.e., its vertices can be labelled with (0,1)-vectors of some fixed length such that the distance between any two vertices in the graph equals the Hamming distance of their labels. If requested, this labelling can also be returned by the method.

The code for this method comes from the PADS library by David Eppstein, which is available at http://www.ics.uci.edu/~eppstein/PADS/. The library is available under the MIT license, and I have also obtained permission from the author via email. The algorithm in question has been described in a paper available at http://arxiv.org/pdf/0705.1025.pdf.

The code has been changed to utilize Sage's structures (namely graphs, digraphs and disjoint sets). However, specialized breadth-first and depth-first search methods for graphs from the PADS library have also been added.

CC:  @nathanncohen

Keywords: graphs partial cubes

Reviewer: Nathann Cohen

Author: Janoš Vidali

Branch: 5a054a67e3ba364a113a4323a1c2404b5d263239

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/19985





---

archive/issue_comments_288822.json:
```json
{
    "body": "<a id='comment:2'></a>Before this goes into review, here are some notes and questions:\n\n* Currently, there are no docstrings for the new methods - of course I will add them, but the current commit was intended just for testing whether the method works as expected.\n* Should I mention in the doc that the code has originally been made available under the MIT license?\n* The new BFS method is named `breadth_first_level_search`. It generates dictionaries whose keys are vertices at each level of the search, and values are sets of neighbours on the next level for each key vertex. This way, a vertex may appear in multiple sets on the same level - this is needed to correctly produce the labellings.\n* The new DFS method is named `depth_first_traversal`. It generates the edges followed on both ways of the depth-first search, together with the information on the direction taken (`True` for forward, `False` for backward). The method is used in the final verification step of the algorithm. Although the existing DFS could be adapted to work this way if requested, I chose to keep this a separate method to avoid needlessly degrading the performance of algorithms utilizing the generic DFS.\n* If a `certificate` is requested, the method raises an `EmptySetError` describing what went wrong in case the graph is not a partial cube, and returns a dictionary mapping vertices to (0,1)-strings otherwise. Is this OK, or should I change to returning pairs, as with other methods returning a certificate? Should I use some exception other than `EmptySetError`? I chose this as it is also used in `traveling_salesman_problem`.\n\nJano\u0161\n\n---\nNew commits:",
    "created_at": "2016-01-30T13:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288822",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:2'></a>Before this goes into review, here are some notes and questions:

* Currently, there are no docstrings for the new methods - of course I will add them, but the current commit was intended just for testing whether the method works as expected.
* Should I mention in the doc that the code has originally been made available under the MIT license?
* The new BFS method is named `breadth_first_level_search`. It generates dictionaries whose keys are vertices at each level of the search, and values are sets of neighbours on the next level for each key vertex. This way, a vertex may appear in multiple sets on the same level - this is needed to correctly produce the labellings.
* The new DFS method is named `depth_first_traversal`. It generates the edges followed on both ways of the depth-first search, together with the information on the direction taken (`True` for forward, `False` for backward). The method is used in the final verification step of the algorithm. Although the existing DFS could be adapted to work this way if requested, I chose to keep this a separate method to avoid needlessly degrading the performance of algorithms utilizing the generic DFS.
* If a `certificate` is requested, the method raises an `EmptySetError` describing what went wrong in case the graph is not a partial cube, and returns a dictionary mapping vertices to (0,1)-strings otherwise. Is this OK, or should I change to returning pairs, as with other methods returning a certificate? Should I use some exception other than `EmptySetError`? I chose this as it is also used in `traveling_salesman_problem`.

Janoš

---
New commits:



---

archive/issue_comments_288823.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2016-01-30T13:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288823",
    "user": "https://github.com/jaanos"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_288824.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to graph theory.",
    "created_at": "2016-01-30T13:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288824",
    "user": "https://github.com/jaanos"
}
```

Changing component from PLEASE CHANGE to graph theory.



---

archive/issue_comments_288825.json:
```json
{
    "body": "Changing keywords from \"\" to \"graphs partial cubes\".",
    "created_at": "2016-01-30T13:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288825",
    "user": "https://github.com/jaanos"
}
```

Changing keywords from "" to "graphs partial cubes".



---

archive/issue_comments_288826.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2016-01-30T13:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288826",
    "user": "https://github.com/jaanos"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_288827.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,8 @@\n+This ticket adds a method `is_partial_cube` to the `Graph` class, which checks whether a graph is a partial cube. A partial cube is a graph that can be isometrically embedded into a hypercube, i.e., its vertices can be labelled with (0,1)-vectors of some fixed length such that the distance between any two vertices in the graph equals the Hamming distance of their labels. If requested, this labelling can also be returned by the method.\n \n+The code for this method comes from the PADS library by David Eppstein, which is available at http://www.ics.uci.edu/~eppstein/PADS/. The library is available under the MIT license, and I have also obtained permission from the author via email. The algorithm in question has been described in a paper available at http://arxiv.org/pdf/0705.1025.pdf.\n+\n+The code has been changed to utilize Sage's structures (namely graphs, digraphs and disjoint sets). However, specialized breadth-first and depth-first search methods for graphs from the PADS library have also been added.\n \n Comment: 1\n \n``````\n",
    "created_at": "2016-01-30T13:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288827",
    "user": "https://github.com/jaanos"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,8 @@
+This ticket adds a method `is_partial_cube` to the `Graph` class, which checks whether a graph is a partial cube. A partial cube is a graph that can be isometrically embedded into a hypercube, i.e., its vertices can be labelled with (0,1)-vectors of some fixed length such that the distance between any two vertices in the graph equals the Hamming distance of their labels. If requested, this labelling can also be returned by the method.
 
+The code for this method comes from the PADS library by David Eppstein, which is available at http://www.ics.uci.edu/~eppstein/PADS/. The library is available under the MIT license, and I have also obtained permission from the author via email. The algorithm in question has been described in a paper available at http://arxiv.org/pdf/0705.1025.pdf.
+
+The code has been changed to utilize Sage's structures (namely graphs, digraphs and disjoint sets). However, specialized breadth-first and depth-first search methods for graphs from the PADS library have also been added.
 
 Comment: 1
 
``````




---

archive/issue_comments_288828.json:
```json
{
    "body": "<a id='comment:3'></a>Hello,\n\n> * Should I mention in the doc that the code has originally been made available under the MIT license?\n\n\nI do not think that you *must* mention the original license. You can say somewhere that this implementation is an adaptation of his code, however. Though you can ask on sage-devel if you prefer.\n\n> * The new BFS method is named `breadth_first_level_search`. It generates dictionaries whose keys are vertices at each level of the search, and values are sets of neighbours on the next level for each key vertex. This way, a vertex may appear in multiple sets on the same level - this is needed to correctly produce the labellings.\n\n\nThis method is very specific to you use, and cannot be a public function of GenericGraph with a name like that. You can turn it into a private function if you prefer.\n\nI have not looked at the code inside, but depending on your performance needs, you could prefer an implementation that does not require you to rewrite the BFS. Something like that:\n\n```\nsage: bfs = list(g.breadth_first_search(0,report_distance=True))\nsage: layers = [set() for _ in range(bfs[-1][1]+2)]\nsage: for x,d in bfs:\n....:     layers[d].add(x)\nsage: next_level_neighbors = {v:layers[d+1].intersection(g.neighbors(v)) for d,L in enumerate(layers) for v in L}\n```\n\n> * The new DFS method is named `depth_first_traversal`. It generates the edges followed on both ways of the depth-first search, together with the information on the direction taken (`True` for forward, `False` for backward). The method is used in the final verification step of the algorithm. Although the existing DFS could be adapted to work this way if requested, I chose to keep this a separate method to avoid needlessly degrading the performance of algorithms utilizing the generic DFS.\n\n\nSame remark here for the name. We can't have `.depth_first_search` and `.depth_first_traversal` simultaneously, and doing different things.\n\n> * If a `certificate` is requested, the method raises an `EmptySetError` describing what went wrong in case the graph is not a partial cube, and returns a dictionary mapping vertices to (0,1)-strings otherwise.\n\n\n`EmptySetError`? Isn't the certificate usually set to `None` or to the empty dictionary when it goes wrong? Your code at #19586 raises no exception.\n\n> Is this OK, or should I change to returning pairs, as with other methods returning a certificate?\n\n\nYou don't have to return a list of pairs, a certificate can be whatever you like.\n\n> Should I use some exception other than `EmptySetError`? I chose this as it is also used in `traveling_salesman_problem`.\n\n\nOh. Well, this `EmptySetError` is a recent trend to mean that \"a search occured, and found nothing\". Which 'can' make sense for a hamiltonian cycle. Here, an `EmptySetError` would make me thing that the algorithm is doing something enumerative like trying all labellings.\n\nAbout the implementation: this code looks long, and perhaps tricky: if you prefer you can also move it to an independent file (like it's done for 'graphs/graph_decompositions/graph_products.pyx'). The other advantage of that is that it give you more room to write doc, if you need it.\n\nNathann",
    "created_at": "2016-01-30T16:19:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288828",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:3'></a>Hello,

> * Should I mention in the doc that the code has originally been made available under the MIT license?


I do not think that you *must* mention the original license. You can say somewhere that this implementation is an adaptation of his code, however. Though you can ask on sage-devel if you prefer.

> * The new BFS method is named `breadth_first_level_search`. It generates dictionaries whose keys are vertices at each level of the search, and values are sets of neighbours on the next level for each key vertex. This way, a vertex may appear in multiple sets on the same level - this is needed to correctly produce the labellings.


This method is very specific to you use, and cannot be a public function of GenericGraph with a name like that. You can turn it into a private function if you prefer.

I have not looked at the code inside, but depending on your performance needs, you could prefer an implementation that does not require you to rewrite the BFS. Something like that:

```
sage: bfs = list(g.breadth_first_search(0,report_distance=True))
sage: layers = [set() for _ in range(bfs[-1][1]+2)]
sage: for x,d in bfs:
....:     layers[d].add(x)
sage: next_level_neighbors = {v:layers[d+1].intersection(g.neighbors(v)) for d,L in enumerate(layers) for v in L}
```

> * The new DFS method is named `depth_first_traversal`. It generates the edges followed on both ways of the depth-first search, together with the information on the direction taken (`True` for forward, `False` for backward). The method is used in the final verification step of the algorithm. Although the existing DFS could be adapted to work this way if requested, I chose to keep this a separate method to avoid needlessly degrading the performance of algorithms utilizing the generic DFS.


Same remark here for the name. We can't have `.depth_first_search` and `.depth_first_traversal` simultaneously, and doing different things.

> * If a `certificate` is requested, the method raises an `EmptySetError` describing what went wrong in case the graph is not a partial cube, and returns a dictionary mapping vertices to (0,1)-strings otherwise.


`EmptySetError`? Isn't the certificate usually set to `None` or to the empty dictionary when it goes wrong? Your code at #19586 raises no exception.

> Is this OK, or should I change to returning pairs, as with other methods returning a certificate?


You don't have to return a list of pairs, a certificate can be whatever you like.

> Should I use some exception other than `EmptySetError`? I chose this as it is also used in `traveling_salesman_problem`.


Oh. Well, this `EmptySetError` is a recent trend to mean that "a search occured, and found nothing". Which 'can' make sense for a hamiltonian cycle. Here, an `EmptySetError` would make me thing that the algorithm is doing something enumerative like trying all labellings.

About the implementation: this code looks long, and perhaps tricky: if you prefer you can also move it to an independent file (like it's done for 'graphs/graph_decompositions/graph_products.pyx'). The other advantage of that is that it give you more room to write doc, if you need it.

Nathann



---

archive/issue_comments_288829.json:
```json
{
    "body": "<a id='comment:4'></a>Also: please only put the bare minimum in a try/except.\n\nThough I know I can't convince you of the wisdom of that until you fought for hours with an exception that was raised where you did not expect it.",
    "created_at": "2016-01-30T16:55:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288829",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:4'></a>Also: please only put the bare minimum in a try/except.

Though I know I can't convince you of the wisdom of that until you fought for hours with an exception that was raised where you did not expect it.



---

archive/issue_comments_288830.json:
```json
{
    "body": "<a id='comment:5'></a>Hi!\n\nThanks for the suggestions and comments, I will address them when I have time (not today). As I said, the current code closely follows the original (including exceptions) and was mainly meant for testing, so I'm willing to change it to a more acceptable form.\n\n> About the implementation: this code looks long, and perhaps tricky: if you prefer you can also move it to an independent file (like it's done for 'graphs/graph_decompositions/graph_products.pyx'). The other advantage of that is that it give you more room to write doc, if you need it.\n\n\nI agree that this will probably be the best solution - then the file can also contain the search functions. Are there any additional steps needed when adding a new file?\n\nJano\u0161",
    "created_at": "2016-01-31T17:55:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288830",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:5'></a>Hi!

Thanks for the suggestions and comments, I will address them when I have time (not today). As I said, the current code closely follows the original (including exceptions) and was mainly meant for testing, so I'm willing to change it to a more acceptable form.

> About the implementation: this code looks long, and perhaps tricky: if you prefer you can also move it to an independent file (like it's done for 'graphs/graph_decompositions/graph_products.pyx'). The other advantage of that is that it give you more room to write doc, if you need it.


I agree that this will probably be the best solution - then the file can also contain the search functions. Are there any additional steps needed when adding a new file?

Janoš



---

archive/issue_comments_288831.json:
```json
{
    "body": "<a id='comment:6'></a>Hello,\n\n> I agree that this will probably be the best solution - then the file can also contain the search functions. Are there any additional steps needed when adding a new file?\n\n\nNot really for the code itself. For the doc, however, there is that:\n\n    http://doc.sagemath.org/html/en/developer/sage_manuals.html#adding-a-new-file\n\nNathann",
    "created_at": "2016-01-31T18:05:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288831",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:6'></a>Hello,

> I agree that this will probably be the best solution - then the file can also contain the search functions. Are there any additional steps needed when adding a new file?


Not really for the code itself. For the doc, however, there is that:

    http://doc.sagemath.org/html/en/developer/sage_manuals.html#adding-a-new-file

Nathann



---

archive/issue_comments_288832.json:
```json
{
    "body": "<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2016-02-01T20:32:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288832",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_288833.json:
```json
{
    "body": "Changing status from needs_info to needs_work.",
    "created_at": "2016-02-01T20:48:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288833",
    "user": "https://github.com/jaanos"
}
```

Changing status from needs_info to needs_work.



---

archive/issue_comments_288834.json:
```json
{
    "body": "<a id='comment:8'></a>Hi!\n\nI've moved the functions to a new file and added the documentation. However, the last test in the docstring of `is_partial_cube` is not formatted properly in `graph.html` when I compile the documentation (but it looks fine in `partial_cube.html`). Any idea why?\n\nJano\u0161",
    "created_at": "2016-02-01T20:48:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288834",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:8'></a>Hi!

I've moved the functions to a new file and added the documentation. However, the last test in the docstring of `is_partial_cube` is not formatted properly in `graph.html` when I compile the documentation (but it looks fine in `partial_cube.html`). Any idea why?

Janoš



---

archive/issue_comments_288835.json:
```json
{
    "body": "<a id='comment:9'></a>I cannot tell: could you have run the compilation but missed an error? When I compiled your doc, I got something like that:\n\n```\nOSError: [graphs   ] /home/ncohen/.Sage/local/lib/python2.7/site-packages/sage/graphs/partial_cube.py:docstring of sage.graphs.partial_cube.is_partial_cube:19: WARNING: duplicate citation Eppstein2008, other instance in /home/ncohen/.Sage/src/doc/en/reference/graphs/sage/graphs/graph.rst\n```\n\nPerhaps the doc does not compile, and so the page you are looking at is never refreshed? I don't see anything wrong in its code.\n\nBy the way: the 'trick' here is to move the 'reference' section into the module's doc. This way, sphinx will not see it defined in two functions: the one in `partial_cube`, and the one (equal to it) in `graph.py`.\n\n\"Welcome to Sage development. If it's your first night here: you can't trust sphinx\"\n\nNathann\n\nNathann",
    "created_at": "2016-02-02T12:51:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288835",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:9'></a>I cannot tell: could you have run the compilation but missed an error? When I compiled your doc, I got something like that:

```
OSError: [graphs   ] /home/ncohen/.Sage/local/lib/python2.7/site-packages/sage/graphs/partial_cube.py:docstring of sage.graphs.partial_cube.is_partial_cube:19: WARNING: duplicate citation Eppstein2008, other instance in /home/ncohen/.Sage/src/doc/en/reference/graphs/sage/graphs/graph.rst
```

Perhaps the doc does not compile, and so the page you are looking at is never refreshed? I don't see anything wrong in its code.

By the way: the 'trick' here is to move the 'reference' section into the module's doc. This way, sphinx will not see it defined in two functions: the one in `partial_cube`, and the one (equal to it) in `graph.py`.

"Welcome to Sage development. If it's your first night here: you can't trust sphinx"

Nathann

Nathann



---

archive/issue_comments_288836.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-02T13:50:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288836",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288837.json:
```json
{
    "body": "<a id='comment:11'></a>OK, I fixed that, and now it looks fine.",
    "created_at": "2016-02-02T13:52:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288837",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:11'></a>OK, I fixed that, and now it looks fine.



---

archive/issue_comments_288838.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-02-02T13:52:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288838",
    "user": "https://github.com/jaanos"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_288839.json:
```json
{
    "body": "<a id='comment:12'></a>Propably a stupid question, as I know very little graph theory, but: Isn't the definition \"isometrically embedded into a hypercube\" defined also for non-connected graphs? I.e. it equals to definition by Hamming distance only when the graph is connected.\n\nAnd a kind of bikeshedding: A user writing `G.is_partial_cube?` will get help that does not define partial cube but says what is the complexity and who invented algorithm.",
    "created_at": "2016-02-02T20:46:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288839",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:12'></a>Propably a stupid question, as I know very little graph theory, but: Isn't the definition "isometrically embedded into a hypercube" defined also for non-connected graphs? I.e. it equals to definition by Hamming distance only when the graph is connected.

And a kind of bikeshedding: A user writing `G.is_partial_cube?` will get help that does not define partial cube but says what is the complexity and who invented algorithm.



---

archive/issue_comments_288840.json:
```json
{
    "body": "<a id='comment:13'></a>Hi!\n\nReplying to [comment:12 jmantysalo]:\n> Propably a stupid question, as I know very little graph theory, but: Isn't the definition \"isometrically embedded into a hypercube\" defined also for non-connected graphs? I.e. it equals to definition by Hamming distance only when the graph is connected.\n\n\nIt is, but clearly no disconnected graph G can be isometrically embeded into a connected graph H, as two vertices in distinct connected components of G will not be connected by any shortest path in H.\n\n> And a kind of bikeshedding: A user writing `G.is_partial_cube?` will get help that does not define partial cube but says what is the complexity and who invented algorithm.\n\n\nYes, I should change that.\n\nBy the way, should I be worried about the failing plugin on the buildbot? The log is not very helpful in telling me what exactly went wrong.\n\nJano\u0161",
    "created_at": "2016-02-02T21:39:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288840",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:13'></a>Hi!

Replying to [comment:12 jmantysalo]:
> Propably a stupid question, as I know very little graph theory, but: Isn't the definition "isometrically embedded into a hypercube" defined also for non-connected graphs? I.e. it equals to definition by Hamming distance only when the graph is connected.


It is, but clearly no disconnected graph G can be isometrically embeded into a connected graph H, as two vertices in distinct connected components of G will not be connected by any shortest path in H.

> And a kind of bikeshedding: A user writing `G.is_partial_cube?` will get help that does not define partial cube but says what is the complexity and who invented algorithm.


Yes, I should change that.

By the way, should I be worried about the failing plugin on the buildbot? The log is not very helpful in telling me what exactly went wrong.

Janoš



---

archive/issue_comments_288841.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-02T21:44:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288841",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288842.json:
```json
{
    "body": "<a id='comment:15'></a>Fails on empty graph:\n\n```\nsage: G = Graph()\nsage: G.is_partial_cube()\nZeroDivisionError: integer division or modulo by zero\n```\n\n(Empty set, zero, graph without any edge etc. are corner cases that are almost always good to check.)",
    "created_at": "2016-02-03T05:57:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288842",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:15'></a>Fails on empty graph:

```
sage: G = Graph()
sage: G.is_partial_cube()
ZeroDivisionError: integer division or modulo by zero
```

(Empty set, zero, graph without any edge etc. are corner cases that are almost always good to check.)



---

archive/issue_comments_288843.json:
```json
{
    "body": "<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-03T09:35:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288843",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288844.json:
```json
{
    "body": "<a id='comment:17'></a>Hi!\n\n> Fails on empty graph:\n\n\nWhoops, fixed. Thanks for pointing it out!\n\n> (Empty set, zero, graph without any edge etc. are corner cases that are almost always good to check.)\n\n\nEdgeless graphs work - a graph with a single vertex is already a hypercube, while larger empty graphs are disconnected and therefore are not partial cubes.\n\nJano\u0161",
    "created_at": "2016-02-03T09:38:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288844",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:17'></a>Hi!

> Fails on empty graph:


Whoops, fixed. Thanks for pointing it out!

> (Empty set, zero, graph without any edge etc. are corner cases that are almost always good to check.)


Edgeless graphs work - a graph with a single vertex is already a hypercube, while larger empty graphs are disconnected and therefore are not partial cubes.

Janoš



---

archive/issue_comments_288845.json:
```json
{
    "body": "<a id='comment:18'></a>I have no more comments.\n\nI did some tests, like testing that cartesian products of partial cubes are partial cubes, and found no errors.\n\nI read the code. It seems complicated due to nature of algorithm using bitwise operators. However, it has good comments inside.\n\nI am unsure if I can not put this to positive review. Nathann, how rigorously should a reviewer read the code?",
    "created_at": "2016-02-04T09:18:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288845",
    "user": "https://github.com/jm58660"
}
```

<a id='comment:18'></a>I have no more comments.

I did some tests, like testing that cartesian products of partial cubes are partial cubes, and found no errors.

I read the code. It seems complicated due to nature of algorithm using bitwise operators. However, it has good comments inside.

I am unsure if I can not put this to positive review. Nathann, how rigorously should a reviewer read the code?



---

archive/issue_comments_288846.json:
```json
{
    "body": "<a id='comment:19'></a>Yo,\n\n> I am unsure if I can not put this to positive review. Nathann, how rigorously should a reviewer read the code?\n\n\nThere is no rule about that, as you can expect. The same way that paper reviewers sometimes do a serious job and sometimes only browse through the text. Both are called 'reviews'. Some tickets are also `positively reviewed` mostly because the reviewer and authors are good friends, and don't want to bother with details.\n\nHere the 'form' of the code seems good (doc formatting, new module, imports, index of functions), and from what I read of Jano\u0161' code I'm the one who needs to double-check when I am about to make a comment.\n\nI would not give this ticket a positive review before I understand the algorithm and its implementation, however. And perhaps outline what it does in the module's doc while I am at it. If you give this patch a positive review, however, that's fine by me and there is nothing I can/will do against it. Everybody has his own way of reviewing things.\n\nWe have very strict rules about where double columns should be put, and a ticket is easily set to `needs_work` because of that. But there is no way to check how honestly a reviewer inspects the mathematical code, so there we have to trust each other.\n\nLife.\n\nNathann",
    "created_at": "2016-02-04T09:52:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288846",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:19'></a>Yo,

> I am unsure if I can not put this to positive review. Nathann, how rigorously should a reviewer read the code?


There is no rule about that, as you can expect. The same way that paper reviewers sometimes do a serious job and sometimes only browse through the text. Both are called 'reviews'. Some tickets are also `positively reviewed` mostly because the reviewer and authors are good friends, and don't want to bother with details.

Here the 'form' of the code seems good (doc formatting, new module, imports, index of functions), and from what I read of Janoš' code I'm the one who needs to double-check when I am about to make a comment.

I would not give this ticket a positive review before I understand the algorithm and its implementation, however. And perhaps outline what it does in the module's doc while I am at it. If you give this patch a positive review, however, that's fine by me and there is nothing I can/will do against it. Everybody has his own way of reviewing things.

We have very strict rules about where double columns should be put, and a ticket is easily set to `needs_work` because of that. But there is no way to check how honestly a reviewer inspects the mathematical code, so there we have to trust each other.

Life.

Nathann



---

archive/issue_comments_288847.json:
```json
{
    "body": "<a id='comment:20'></a>Hello,\n\nHere is a first-pass review.\n\n- Has a simpler expression:\n  {{{\n  -    CG = DiGraph({v: {w: (v, w) for w in G[v]} for v in G})\n  +    CG = DiGraph(G)\n  }}}\n\n- That's a full graph copy, right? `O_o`\n  {{{\n  +        if not Graph(CG).is_bipartite():\n  }}}\n\n  Wouldn't it be better to maintain the undirected graph too? At this level, I\n  would almost be tempted by `GenericGraph.is_bipartite(CG)` `O_o`\n\n- `CG/UF/NL` I saw that they were the names from the original source code, but\n  would you mind 'expanding' them?\n\n- Don't know if that interests you, but by relabelling the graph on `0,...,n`\n  you could use lists instead of dictionaries, e.g. for `bitvec`.\n\n- Computing the number of connected components is not necessary to initialize\n  the graphs, and has a linear-time cost.\n  {{{\n  -        NG = DiGraph(labeled.connected_components_number())\n  +        NG = DiGraph()\n  }}}\n\n- What about `NG.has_edge(vi,wi)`?\n  {{{\n  +                if wi in NG.neighbors_out(vi):\n  }}}\n\n- As you do not seem to do anything with the dictionaries stored in `action`,\n  could you turn them into sets instead?\n  {{{\n  -    action = {v: {} for v in g}\n  +    action = {v: set() for v in g}\n  }}}\n\n- What is the purpose of all the code that appears after this line?\n  {{{\n  +    g = DiGraph({v: {w: UF.find((v, w)) for w in G[v]} for v in G})\n  }}}\n  It does not appear in `partial_cube.py` but in `medium.py`, and I do not see\n  what you need it for.\n\nNathann",
    "created_at": "2016-02-06T09:51:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288847",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:20'></a>Hello,

Here is a first-pass review.

- Has a simpler expression:
  {{{
  -    CG = DiGraph({v: {w: (v, w) for w in G[v]} for v in G})
  +    CG = DiGraph(G)
  }}}

- That's a full graph copy, right? `O_o`
  {{{
  +        if not Graph(CG).is_bipartite():
  }}}

  Wouldn't it be better to maintain the undirected graph too? At this level, I
  would almost be tempted by `GenericGraph.is_bipartite(CG)` `O_o`

- `CG/UF/NL` I saw that they were the names from the original source code, but
  would you mind 'expanding' them?

- Don't know if that interests you, but by relabelling the graph on `0,...,n`
  you could use lists instead of dictionaries, e.g. for `bitvec`.

- Computing the number of connected components is not necessary to initialize
  the graphs, and has a linear-time cost.
  {{{
  -        NG = DiGraph(labeled.connected_components_number())
  +        NG = DiGraph()
  }}}

- What about `NG.has_edge(vi,wi)`?
  {{{
  +                if wi in NG.neighbors_out(vi):
  }}}

- As you do not seem to do anything with the dictionaries stored in `action`,
  could you turn them into sets instead?
  {{{
  -    action = {v: {} for v in g}
  +    action = {v: set() for v in g}
  }}}

- What is the purpose of all the code that appears after this line?
  {{{
  +    g = DiGraph({v: {w: UF.find((v, w)) for w in G[v]} for v in G})
  }}}
  It does not appear in `partial_cube.py` but in `medium.py`, and I do not see
  what you need it for.

Nathann



---

archive/issue_comments_288848.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2016-02-06T09:51:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288848",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_288849.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-06T19:48:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288849",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288850.json:
```json
{
    "body": "<a id='comment:22'></a>Hi!\n\n> - Has a simpler expression:\n>   {{{\n>   -    CG = DiGraph({v: {w: (v, w) for w in G[v]} for v in G})\n>   +    CG = DiGraph(G)\n>   }}}\n\n\nThe point here is to set edge labels. Simply constructing a `DiGraph` from `G` will keep the old edge labels (if any).\n\n> - That's a full graph copy, right? `O_o`\n>   {{{\n>   +        if not Graph(CG).is_bipartite():\n>   }}}\n> \n>   Wouldn't it be better to maintain the undirected graph too? At this level, I\n>   would almost be tempted by `GenericGraph.is_bipartite(CG)` `O_o`\n\n\nI *think* it may be actually enough to check that the original graph is bipartite, and then also all contractions must be bipartite. I will ask the author, just to be sure.\n\n> - `CG/UF/NL` I saw that they were the names from the original source code, but\n>   would you mind 'expanding' them?\n\n\nOK, they are now `contracted`, `unionfind` and `available` now, and `LG` and `NG` have been changed to `level` and `newgraph`, respectively.\n\n> - Don't know if that interests you, but by relabelling the graph on `0,...,n`\n>   you could use lists instead of dictionaries, e.g. for `bitvec`.\n\n\nI could, but since we might be building a dictionary as a certificate anyway, I don't think there's much gain here.\n\n> - Computing the number of connected components is not necessary to initialize\n>   the graphs, and has a linear-time cost.\n>   {{{\n>   -        NG = DiGraph(labeled.connected_components_number())\n>   +        NG = DiGraph()\n>   }}}\n> \n> - What about `NG.has_edge(vi,wi)`?\n>   {{{\n>   +                if wi in NG.neighbors_out(vi):\n>   }}}\n\n\nOK, both changed.\n\n> - As you do not seem to do anything with the dictionaries stored in `action`,\n>   could you turn them into sets instead?\n>   {{{\n>   -    action = {v: {} for v in g}\n>   +    action = {v: set() for v in g}\n>   }}}\n\n\nThe original algorithm used the values in the dictionaries to reconstruct the graph. Indeed, here we don't use them, so I changed the dictionaries to sets.\n\n> - What is the purpose of all the code that appears after this line?\n>   {{{\n>   +    g = DiGraph({v: {w: UF.find((v, w)) for w in G[v]} for v in G})\n>   }}}\n>   It does not appear in `partial_cube.py` but in `medium.py`, and I do not see\n>   what you need it for.\n\n\nIn the case the graph is not a partial cube, the first part of the algorithm may still produce a labelling, which then needs to be checked (see for example Lemma 11 in the paper). An example would be a graph with graph6 string `Fs_Wo` - this fails the check that no two edges on the same vertex should have the same label.\n\nJano\u0161",
    "created_at": "2016-02-06T19:50:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288850",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:22'></a>Hi!

> - Has a simpler expression:
>   {{{
>   -    CG = DiGraph({v: {w: (v, w) for w in G[v]} for v in G})
>   +    CG = DiGraph(G)
>   }}}


The point here is to set edge labels. Simply constructing a `DiGraph` from `G` will keep the old edge labels (if any).

> - That's a full graph copy, right? `O_o`
>   {{{
>   +        if not Graph(CG).is_bipartite():
>   }}}
> 
>   Wouldn't it be better to maintain the undirected graph too? At this level, I
>   would almost be tempted by `GenericGraph.is_bipartite(CG)` `O_o`


I *think* it may be actually enough to check that the original graph is bipartite, and then also all contractions must be bipartite. I will ask the author, just to be sure.

> - `CG/UF/NL` I saw that they were the names from the original source code, but
>   would you mind 'expanding' them?


OK, they are now `contracted`, `unionfind` and `available` now, and `LG` and `NG` have been changed to `level` and `newgraph`, respectively.

> - Don't know if that interests you, but by relabelling the graph on `0,...,n`
>   you could use lists instead of dictionaries, e.g. for `bitvec`.


I could, but since we might be building a dictionary as a certificate anyway, I don't think there's much gain here.

> - Computing the number of connected components is not necessary to initialize
>   the graphs, and has a linear-time cost.
>   {{{
>   -        NG = DiGraph(labeled.connected_components_number())
>   +        NG = DiGraph()
>   }}}
> 
> - What about `NG.has_edge(vi,wi)`?
>   {{{
>   +                if wi in NG.neighbors_out(vi):
>   }}}


OK, both changed.

> - As you do not seem to do anything with the dictionaries stored in `action`,
>   could you turn them into sets instead?
>   {{{
>   -    action = {v: {} for v in g}
>   +    action = {v: set() for v in g}
>   }}}


The original algorithm used the values in the dictionaries to reconstruct the graph. Indeed, here we don't use them, so I changed the dictionaries to sets.

> - What is the purpose of all the code that appears after this line?
>   {{{
>   +    g = DiGraph({v: {w: UF.find((v, w)) for w in G[v]} for v in G})
>   }}}
>   It does not appear in `partial_cube.py` but in `medium.py`, and I do not see
>   what you need it for.


In the case the graph is not a partial cube, the first part of the algorithm may still produce a labelling, which then needs to be checked (see for example Lemma 11 in the paper). An example would be a graph with graph6 string `Fs_Wo` - this fails the check that no two edges on the same vertex should have the same label.

Janoš



---

archive/issue_comments_288851.json:
```json
{
    "body": "<a id='comment:23'></a>Hellooooo,\n\n> The point here is to set edge labels. Simply constructing a `DiGraph` from `G` will keep the old edge labels (if any).\n\n\nDead right, my mistake.\n\n> I *think* it may be actually enough to check that the original graph is bipartite, and then also all contractions must be bipartite. I will ask the author, just to be sure.\n\n\nOkay !\n\n> OK, they are now `contracted`, `unionfind` and `available` now, and `LG` and `NG` have been changed to `level` and `newgraph`, respectively.\n\n\nThanks,\n\n> I could, but since we might be building a dictionary as a certificate anyway, I don't think there's much gain here.\n\n\nOkayokay. I thought a bit about it, and it would be much more troublesome than I first expected indeed.\n\n> In the case the graph is not a partial cube, the first part of the algorithm may still produce a labelling, which then needs to be checked (see for example Lemma 11 in the paper). An example would be a graph with graph6 string `Fs_Wo` - this fails the check that no two edges on the same vertex should have the same label.\n\n\nI thought a bit about this, and it does not seem very hard to check that a vertex labelling is correct (a sample of code that does it follows) but perhaps this code is 'theoretically' `n^2log(n)` instead of `n^2`. Considering the efficiency of Python (the `n^2` part) and the efficiency of the `log(n)` part (bitwise operations), however, I wonder if it could not be faster than another Python `n^2` implementation. What do you think?\n\nThis code assumes what I believe we can assume: that after the labelling is picked, two adjacent vertices differ by one 'bit' and that this bit is the edge's label. This amounts to being sure that the graph is indeed a *subgraph* of a high-dimension cube, but not that it is isometric. In order to check that it is isometric, I believe that it is sufficient to run the following code.\n\n```python\ndef check_labelling(G):\n    # Assumptions:\n    #\n    # - We assume that the vertices are integers, whose base-2 representation\n    #   represents the coordinates\n    #\n    # - We also assume that every edge corresponds to the switching of one bit\n    #   in that base-2 representation or a vertex' name\n\n    # This dictionary associates to each vertex the set of bits whose switching\n    # yields one of its neighbors:\n\n    action = {v: set() for v in G}\n    for u,v in G.edge_iterator(labels=False):\n        diff = u^v\n        action[u].add(diff)\n        action[v].add(diff)\n\n    action_bitset = {v: sum(action[v]) for v in G}\n\n    # We now check that, for every pair u,v of vertices, there is a neighbor u'\n    # of u such that:\n    #     hamming_distance(u,v) = hammin_distance(u',v) + 1\n\n    for u in G:\n        for v in G:\n            diff = u^v\n            if (action_bitset[u] & diff == 0 and\n                u != v):\n                return False\n\n    return True\n```\n\nExample in Sage:\n\n```\nsage: g = graphs.CubeGraph(5).relabel(lambda x:Integer(x,base=2),inplace=False)\nsage: check_labelling(g)\nTrue\nsage: g.delete_edge(8,24)\nsage: check_labelling(g)\nFalse\n```\n\nPlease tell me what you think,\n\nNathann",
    "created_at": "2016-02-07T11:02:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288851",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:23'></a>Hellooooo,

> The point here is to set edge labels. Simply constructing a `DiGraph` from `G` will keep the old edge labels (if any).


Dead right, my mistake.

> I *think* it may be actually enough to check that the original graph is bipartite, and then also all contractions must be bipartite. I will ask the author, just to be sure.


Okay !

> OK, they are now `contracted`, `unionfind` and `available` now, and `LG` and `NG` have been changed to `level` and `newgraph`, respectively.


Thanks,

> I could, but since we might be building a dictionary as a certificate anyway, I don't think there's much gain here.


Okayokay. I thought a bit about it, and it would be much more troublesome than I first expected indeed.

> In the case the graph is not a partial cube, the first part of the algorithm may still produce a labelling, which then needs to be checked (see for example Lemma 11 in the paper). An example would be a graph with graph6 string `Fs_Wo` - this fails the check that no two edges on the same vertex should have the same label.


I thought a bit about this, and it does not seem very hard to check that a vertex labelling is correct (a sample of code that does it follows) but perhaps this code is 'theoretically' `n^2log(n)` instead of `n^2`. Considering the efficiency of Python (the `n^2` part) and the efficiency of the `log(n)` part (bitwise operations), however, I wonder if it could not be faster than another Python `n^2` implementation. What do you think?

This code assumes what I believe we can assume: that after the labelling is picked, two adjacent vertices differ by one 'bit' and that this bit is the edge's label. This amounts to being sure that the graph is indeed a *subgraph* of a high-dimension cube, but not that it is isometric. In order to check that it is isometric, I believe that it is sufficient to run the following code.

```python
def check_labelling(G):
    # Assumptions:
    #
    # - We assume that the vertices are integers, whose base-2 representation
    #   represents the coordinates
    #
    # - We also assume that every edge corresponds to the switching of one bit
    #   in that base-2 representation or a vertex' name

    # This dictionary associates to each vertex the set of bits whose switching
    # yields one of its neighbors:

    action = {v: set() for v in G}
    for u,v in G.edge_iterator(labels=False):
        diff = u^v
        action[u].add(diff)
        action[v].add(diff)

    action_bitset = {v: sum(action[v]) for v in G}

    # We now check that, for every pair u,v of vertices, there is a neighbor u'
    # of u such that:
    #     hamming_distance(u,v) = hammin_distance(u',v) + 1

    for u in G:
        for v in G:
            diff = u^v
            if (action_bitset[u] & diff == 0 and
                u != v):
                return False

    return True
```

Example in Sage:

```
sage: g = graphs.CubeGraph(5).relabel(lambda x:Integer(x,base=2),inplace=False)
sage: check_labelling(g)
True
sage: g.delete_edge(8,24)
sage: check_labelling(g)
False
```

Please tell me what you think,

Nathann



---

archive/issue_comments_288852.json:
```json
{
    "body": "<a id='comment:24'></a>Err.. My mistake, when the graph is a tree that's a `n^3` algorithm `:-/`\n\nNathann",
    "created_at": "2016-02-07T11:09:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288852",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:24'></a>Err.. My mistake, when the graph is a tree that's a `n^3` algorithm `:-/`

Nathann



---

archive/issue_comments_288853.json:
```json
{
    "body": "<a id='comment:25'></a>That code was apparently a naive implementation of Lemma 13. Only it isn't easy to read through his fancy definitions. Re-defining an 'oriented rooted tree' is particularly bad move. Anyway. I have to read more.",
    "created_at": "2016-02-07T12:25:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288853",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:25'></a>That code was apparently a naive implementation of Lemma 13. Only it isn't easy to read through his fancy definitions. Re-defining an 'oriented rooted tree' is particularly bad move. Anyway. I have to read more.



---

archive/issue_comments_288854.json:
```json
{
    "body": "<a id='comment:26'></a>This being said, isn't this of complexity `nm` already?\n\n```\n+        for v, w in contracted.edge_iterator(labels = False):\n+            diff = bitvec[v]^bitvec[w]\n```\n\nAnother small thing: `len(contracted[v])` should be `contracted.out_degree(v)` (does not build the list of neighbors).",
    "created_at": "2016-02-07T18:46:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288854",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:26'></a>This being said, isn't this of complexity `nm` already?

```
+        for v, w in contracted.edge_iterator(labels = False):
+            diff = bitvec[v]^bitvec[w]
```

Another small thing: `len(contracted[v])` should be `contracted.out_degree(v)` (does not build the list of neighbors).



---

archive/issue_comments_288855.json:
```json
{
    "body": "<a id='comment:27'></a>Hi!\n\n> This being said, isn't this of complexity `nm` already?\n> \n> \n> ```\n> +        for v, w in contracted.edge_iterator(labels = False):\n> +            diff = bitvec[v]^bitvec[w]\n> ```\n\n\nThe paper assumes that a machine word can store `log(n)` bits, so bitwise operations can be done in `O(d/log(n))` time, where `d` is the degree of the root (these sum up to at most `n-1` over all iterations of the contraction loop). Since the number of edges is checked to be `O(n log(n))`, the total time needed for bitwise operations is `O(n^2)`. Of course, failing this assumption, the time complexity here is indeed `O(nm) = O(n^2 log(n))`.\n\n> Another small thing: `len(contracted[v])` should be `contracted.out_degree(v)` (does not build the list of neighbors).\n\n\nWill take care of that.\n\nJano\u0161",
    "created_at": "2016-02-08T00:02:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288855",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:27'></a>Hi!

> This being said, isn't this of complexity `nm` already?
> 
> 
> ```
> +        for v, w in contracted.edge_iterator(labels = False):
> +            diff = bitvec[v]^bitvec[w]
> ```


The paper assumes that a machine word can store `log(n)` bits, so bitwise operations can be done in `O(d/log(n))` time, where `d` is the degree of the root (these sum up to at most `n-1` over all iterations of the contraction loop). Since the number of edges is checked to be `O(n log(n))`, the total time needed for bitwise operations is `O(n^2)`. Of course, failing this assumption, the time complexity here is indeed `O(nm) = O(n^2 log(n))`.

> Another small thing: `len(contracted[v])` should be `contracted.out_degree(v)` (does not build the list of neighbors).


Will take care of that.

Janoš



---

archive/issue_comments_288856.json:
```json
{
    "body": "<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-08T00:42:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288856",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288857.json:
```json
{
    "body": "<a id='comment:29'></a>OK, bipartiteness is now only checked once, without needing to make any copies.\n\nShould we perhaps mention that the algorithm is really `O(n^2 log(n))`, only for all practical purposes it can be considered a quadratic algorithm?\n\nJano\u0161",
    "created_at": "2016-02-08T00:48:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288857",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:29'></a>OK, bipartiteness is now only checked once, without needing to make any copies.

Should we perhaps mention that the algorithm is really `O(n^2 log(n))`, only for all practical purposes it can be considered a quadratic algorithm?

Janoš



---

archive/issue_comments_288858.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2016-02-08T00:48:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288858",
    "user": "https://github.com/jaanos"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_288859.json:
```json
{
    "body": "<a id='comment:30'></a>Hello,\n\n> OK, bipartiteness is now only checked once, without needing to make any copies.\n\n\nOkay, cool !\n\n> Should we perhaps mention that the algorithm is really `O(n^2 log(n))`, only for all practical purposes it can be considered a quadratic algorithm?\n\n\nYeah probably, though that assumption is rather 'fair'. Don't bother for the moment. I am not done understanding the algorithm, and I will probably add some doc eventually.\n\nNathann",
    "created_at": "2016-02-08T09:28:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288859",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:30'></a>Hello,

> OK, bipartiteness is now only checked once, without needing to make any copies.


Okay, cool !

> Should we perhaps mention that the algorithm is really `O(n^2 log(n))`, only for all practical purposes it can be considered a quadratic algorithm?


Yeah probably, though that assumption is rather 'fair'. Don't bother for the moment. I am not done understanding the algorithm, and I will probably add some doc eventually.

Nathann



---

archive/issue_comments_288860.json:
```json
{
    "body": "<a id='comment:31'></a>Sorry but what do you mean by `Pos` in `StatesForPos`? All I can think of is `position` and I have no idea of what it means in this context `O_o`",
    "created_at": "2016-02-08T09:48:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288860",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:31'></a>Sorry but what do you mean by `Pos` in `StatesForPos`? All I can think of is `position` and I have no idea of what it means in this context `O_o`



---

archive/issue_comments_288861.json:
```json
{
    "body": "<a id='comment:32'></a>Is this right?\n\n- `activeForState -> state_to_smallest_active_token`; and\n- `statesForPos -> active_token_to_states`",
    "created_at": "2016-02-08T10:01:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288861",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:32'></a>Is this right?

- `activeForState -> state_to_smallest_active_token`; and
- `statesForPos -> active_token_to_states`



---

archive/issue_comments_288862.json:
```json
{
    "body": "<a id='comment:33'></a>Hello again !\n\nI added a commit at public/19985 that contains some doc. I am not done understanding the 'checking' part of the algorithm. You are of course welcome to discuss any of the changes.\n\nNathann",
    "created_at": "2016-02-08T14:55:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288862",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:33'></a>Hello again !

I added a commit at public/19985 that contains some doc. I am not done understanding the 'checking' part of the algorithm. You are of course welcome to discuss any of the changes.

Nathann



---

archive/issue_comments_288863.json:
```json
{
    "body": "<a id='comment:34'></a>Hi!\n\n> Is this right?\n> \n> - `activeForState -> state_to_smallest_active_token`; and\n> - `statesForPos -> active_token_to_states`\n\n\nYes, that seems right. `Pos` apparently refers to the position in the `activeTokens` list.\n\nYour changes look fine, so I'm changing to your branch (Sage is still compiling for me though, so I haven't tested yet). Thanks for extending the documentation!\n\nJano\u0161",
    "created_at": "2016-02-08T15:55:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288863",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:34'></a>Hi!

> Is this right?
> 
> - `activeForState -> state_to_smallest_active_token`; and
> - `statesForPos -> active_token_to_states`


Yes, that seems right. `Pos` apparently refers to the position in the `activeTokens` list.

Your changes look fine, so I'm changing to your branch (Sage is still compiling for me though, so I haven't tested yet). Thanks for extending the documentation!

Janoš



---

archive/issue_comments_288864.json:
```json
{
    "body": "<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-08T20:08:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288864",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288865.json:
```json
{
    "body": "<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-10T10:44:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288865",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288866.json:
```json
{
    "body": "<a id='comment:37'></a>Sorry for the slow review, I'm still trying to make sense of the last block of the algorithm, the one which relies on a DFS.\n\nIs there any reason to keep `neighbors` and `ignore_direction` in your DFS/BFS routines? You do not use them.\n\nNathann",
    "created_at": "2016-02-10T10:45:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288866",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:37'></a>Sorry for the slow review, I'm still trying to make sense of the last block of the algorithm, the one which relies on a DFS.

Is there any reason to keep `neighbors` and `ignore_direction` in your DFS/BFS routines? You do not use them.

Nathann



---

archive/issue_comments_288867.json:
```json
{
    "body": "<a id='comment:38'></a>OH. Just got it. \n\nChocolate works wonders.\n\nAnd I do eat a *lot* of it.\n\nNathann",
    "created_at": "2016-02-10T12:38:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288867",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:38'></a>OH. Just got it. 

Chocolate works wonders.

And I do eat a *lot* of it.

Nathann



---

archive/issue_comments_288868.json:
```json
{
    "body": "<a id='comment:39'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-10T13:22:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288868",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:39'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288869.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2016-02-10T13:23:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288869",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_288870.json:
```json
{
    "body": "<a id='comment:40'></a>Hello Jano\u0161 !\n\nI finally understood the last block of code, and updated the doc. I'm setting this to `needs_info` pending your answer about the useless parameters of bfs/dfs.\n\nNathann",
    "created_at": "2016-02-10T13:23:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288870",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:40'></a>Hello Janoš !

I finally understood the last block of code, and updated the doc. I'm setting this to `needs_info` pending your answer about the useless parameters of bfs/dfs.

Nathann



---

archive/issue_comments_288871.json:
```json
{
    "body": "<a id='comment:41'></a>Hi!\n\n> Is there any reason to keep `neighbors` and `ignore_direction` in your DFS/BFS routines? You do not use them.\n\n\nNo, you can remove them. They are a remnant of the first commit, when these functions were still in `generic_graph.py`.\n\nJano\u0161",
    "created_at": "2016-02-10T15:30:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288871",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:41'></a>Hi!

> Is there any reason to keep `neighbors` and `ignore_direction` in your DFS/BFS routines? You do not use them.


No, you can remove them. They are a remnant of the first commit, when these functions were still in `generic_graph.py`.

Janoš



---

archive/issue_comments_288872.json:
```json
{
    "body": "<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-10T15:38:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288872",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288873.json:
```json
{
    "body": "<a id='comment:43'></a>Yo !\n\nIf you agree with the branch in its current status, you can set the ticket to `positive_review`. Thanks for this code !\n\nNathan",
    "created_at": "2016-02-10T15:39:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288873",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:43'></a>Yo !

If you agree with the branch in its current status, you can set the ticket to `positive_review`. Thanks for this code !

Nathan



---

archive/issue_comments_288874.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2016-02-10T15:39:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288874",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_288875.json:
```json
{
    "body": "<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-10T22:46:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288875",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_288876.json:
```json
{
    "body": "<a id='comment:45'></a>Hi!\n\nI've made some small fixes - nothing critical, so I guess it's OK if I set the ticket to `positive_review`. Thanks again for reviewing and writing the documentation!\n\nJano\u0161",
    "created_at": "2016-02-10T22:50:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288876",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:45'></a>Hi!

I've made some small fixes - nothing critical, so I guess it's OK if I set the ticket to `positive_review`. Thanks again for reviewing and writing the documentation!

Janoš



---

archive/issue_comments_288877.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-02-10T22:50:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288877",
    "user": "https://github.com/jaanos"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_054507.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-02-11T23:26:32Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19985#event-54507"
}
```



---

archive/issue_comments_288878.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-02-11T23:26:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288878",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_288879.json:
```json
{
    "body": "<a id='comment:47'></a>Thank you all guys!",
    "created_at": "2016-02-12T00:42:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19985",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19985#issuecomment-288879",
    "user": "https://github.com/jaanos"
}
```

<a id='comment:47'></a>Thank you all guys!
