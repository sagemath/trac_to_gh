# Issue 19108: Implement Python 3 style comparison in the coercion framework

archive/issues_018871.json:
```json
{
    "body": "CC:  @jdemeyer\n\nCurrently to implement comparison for an element, you either need to implement `_cmp_` or `_richcmp_`. For developers accustom to Python 3's method of implementing each comparison operator, we should have `_lt_`, `_le_`, etc.\n\nIssue created by migration from https://trac.sagemath.org/ticket/19108\n\n",
    "closed_at": "2016-08-30T13:32:25Z",
    "created_at": "2015-08-28T02:30:32Z",
    "labels": [
        "component: coercion"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "Implement Python 3 style comparison in the coercion framework",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19108",
    "user": "https://github.com/ohanar"
}
```
CC:  @jdemeyer

Currently to implement comparison for an element, you either need to implement `_cmp_` or `_richcmp_`. For developers accustom to Python 3's method of implementing each comparison operator, we should have `_lt_`, `_le_`, etc.

Issue created by migration from https://trac.sagemath.org/ticket/19108





---

archive/issue_comments_257997.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-08-28T02:30:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-257997",
    "user": "https://github.com/ohanar"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_257998.json:
```json
{
    "body": "I'm open to feedback on implementation details. In particular, this could also naturally go into the category framework, however I was afraid of the performance penalty of doing that.",
    "created_at": "2015-08-28T02:32:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-257998",
    "user": "https://github.com/ohanar"
}
```

I'm open to feedback on implementation details. In particular, this could also naturally go into the category framework, however I was afraid of the performance penalty of doing that.



---

archive/issue_comments_257999.json:
```json
{
    "body": "Replying to [ticket:19108 ohanar]:\n> Additionally, for most elements where comparison makes sense, there is the overwhelming notion that such a comparison is a partial order.\n\nWhy do you think that? I would guess that comparison is in most cases a *total* order, with partial orders being the exception.\n\nThere is also #18305, which tries to solve the same problem in a different way.",
    "created_at": "2015-08-28T06:01:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-257999",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [ticket:19108 ohanar]:
> Additionally, for most elements where comparison makes sense, there is the overwhelming notion that such a comparison is a partial order.

Why do you think that? I would guess that comparison is in most cases a *total* order, with partial orders being the exception.

There is also #18305, which tries to solve the same problem in a different way.



---

archive/issue_comments_258000.json:
```json
{
    "body": "I don't understand why the `Parent` becomes involved at all. That needs more justification.",
    "created_at": "2015-08-28T06:10:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258000",
    "user": "https://github.com/jdemeyer"
}
```

I don't understand why the `Parent` becomes involved at all. That needs more justification.



---

archive/issue_comments_258001.json:
```json
{
    "body": "Replying to [comment:3 jdemeyer]:\n> Replying to [ticket:19108 ohanar]:\n> > Additionally, for most elements where comparison makes sense, there is the overwhelming notion that such a comparison is a partial order.\n\n> Why do you think that? I would guess that comparison is in most cases a *total* order, with partial orders being the exception.\n\nSets are a common example (e.g. ideals, set and integer partitions, etc) of where you have a partial order but not a total order.\n\nIt doesn't really matter though, it would just add one extra rule (namely that you can deduce `_eq_` from `_lt_` and `_gt_`), which wouldn't really make it any easier or harder to implement either a total order or partial order.\n\n\n> \n> There is also #18305, which tries to solve the same problem in a different way.\n\n\nIt solves part of the problem (not the partial/total ordering thing), and I think it is a bit more confusing for new developers who have a python 3 background (since they have to learn about `_richcmp_`). In some sense the two approaches are complementary.",
    "created_at": "2015-08-28T20:48:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258001",
    "user": "https://github.com/ohanar"
}
```

Replying to [comment:3 jdemeyer]:
> Replying to [ticket:19108 ohanar]:
> > Additionally, for most elements where comparison makes sense, there is the overwhelming notion that such a comparison is a partial order.

> Why do you think that? I would guess that comparison is in most cases a *total* order, with partial orders being the exception.

Sets are a common example (e.g. ideals, set and integer partitions, etc) of where you have a partial order but not a total order.

It doesn't really matter though, it would just add one extra rule (namely that you can deduce `_eq_` from `_lt_` and `_gt_`), which wouldn't really make it any easier or harder to implement either a total order or partial order.


> 
> There is also #18305, which tries to solve the same problem in a different way.


It solves part of the problem (not the partial/total ordering thing), and I think it is a bit more confusing for new developers who have a python 3 background (since they have to learn about `_richcmp_`). In some sense the two approaches are complementary.



---

archive/issue_comments_258002.json:
```json
{
    "body": "Replying to [comment:4 jdemeyer]:\n> I don't understand why the `Parent` becomes involved at all. That needs more justification.\n\n\nIt is for caching the partial/total order resolution. Otherwise, each time you compare two elements, the default `_richcmp_` method would need to determine which comparison operators are implemented by the underlying element and then how to use those to give an answer for the requested comparison operator.\n\nI'm rebuilding this branch at the moment and once I'll do that I'll do some performance tests between enabling/disabling the cache.",
    "created_at": "2015-08-28T20:53:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258002",
    "user": "https://github.com/ohanar"
}
```

Replying to [comment:4 jdemeyer]:
> I don't understand why the `Parent` becomes involved at all. That needs more justification.


It is for caching the partial/total order resolution. Otherwise, each time you compare two elements, the default `_richcmp_` method would need to determine which comparison operators are implemented by the underlying element and then how to use those to give an answer for the requested comparison operator.

I'm rebuilding this branch at the moment and once I'll do that I'll do some performance tests between enabling/disabling the cache.



---

archive/issue_comments_258003.json:
```json
{
    "body": "Ok, some very quick performance tests, using the following class:\n\n```python\nclass MyElt(Element):\n    def _le_(self, other):\n        return True\nP = Parent()\ne = MyElt(P)\n```\nWith caching enabled I get the following:\n\n```python\nsage: timeit('e <= e', number=10**7, repeat=10)\n10000000 loops, best of 10: 301 ns per loop\nsage: timeit('e == e', number=10**7, repeat=10)\n10000000 loops, best of 10: 427 ns per loop\n```\nWithout caching I get the following:\n\n```python\nsage: timeit('e <= e', number=10**7, repeat=10)\n10000000 loops, best of 10: 494 ns per loop\nsage: timeit('e == e', number=10**7, repeat=10)\n10000000 loops, best of 10: 636 ns per loop\n```\n\nGiven that I've only implemented `_le_`, the equality operator will call the `_le_` method twice, so from both examples we can see that the call to that function takes around 130-140 ns. Hence, the actual raw time before we get to calling the element's `_le_` goes up from around 160-170 ns when caching on the parent to around 360-370 ns when not caching on the parent.\n\nGranted, I didn't do any real changes to the partial/total order resolution other than just disabling caching, so you could improve the non-cached situation a bit, but my guess is that you would only get it down to around 300 ns or so depending on the operator that is asked for and the operators the element class provides (obviously, if you asked for an operator that the underlying element class provides, then you could short circuit much faster, and get close to the uncached performance).",
    "created_at": "2015-08-28T21:23:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258003",
    "user": "https://github.com/ohanar"
}
```

Ok, some very quick performance tests, using the following class:

```python
class MyElt(Element):
    def _le_(self, other):
        return True
P = Parent()
e = MyElt(P)
```
With caching enabled I get the following:

```python
sage: timeit('e <= e', number=10**7, repeat=10)
10000000 loops, best of 10: 301 ns per loop
sage: timeit('e == e', number=10**7, repeat=10)
10000000 loops, best of 10: 427 ns per loop
```
Without caching I get the following:

```python
sage: timeit('e <= e', number=10**7, repeat=10)
10000000 loops, best of 10: 494 ns per loop
sage: timeit('e == e', number=10**7, repeat=10)
10000000 loops, best of 10: 636 ns per loop
```

Given that I've only implemented `_le_`, the equality operator will call the `_le_` method twice, so from both examples we can see that the call to that function takes around 130-140 ns. Hence, the actual raw time before we get to calling the element's `_le_` goes up from around 160-170 ns when caching on the parent to around 360-370 ns when not caching on the parent.

Granted, I didn't do any real changes to the partial/total order resolution other than just disabling caching, so you could improve the non-cached situation a bit, but my guess is that you would only get it down to around 300 ns or so depending on the operator that is asked for and the operators the element class provides (obviously, if you asked for an operator that the underlying element class provides, then you could short circuit much faster, and get close to the uncached performance).



---

archive/issue_comments_258004.json:
```json
{
    "body": "Replying to [comment:6 ohanar]:\n> Replying to [comment:4 jdemeyer]:\n> > I don't understand why the `Parent` becomes involved at all. That needs more justification.\n\n> \n> It is for caching the partial/total order resolution.\n\nWhy do you assume that every element with the same parent uses the same comparison functions?\n\nIf you want caching, it should be on the `type()` of the `Element`, not the parent.",
    "created_at": "2015-08-29T15:28:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258004",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:6 ohanar]:
> Replying to [comment:4 jdemeyer]:
> > I don't understand why the `Parent` becomes involved at all. That needs more justification.

> 
> It is for caching the partial/total order resolution.

Why do you assume that every element with the same parent uses the same comparison functions?

If you want caching, it should be on the `type()` of the `Element`, not the parent.



---

archive/issue_comments_258005.json:
```json
{
    "body": "Yes, you are right.\n\nThinking about it a bit more, I think it would make better sense to split off the partial/total order stuff into metaclasses, I'll split those into another ticket when I get around it.",
    "created_at": "2015-08-30T20:45:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258005",
    "user": "https://github.com/ohanar"
}
```

Yes, you are right.

Thinking about it a bit more, I think it would make better sense to split off the partial/total order stuff into metaclasses, I'll split those into another ticket when I get around it.



---

archive/issue_comments_258006.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-08-30T20:45:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258006",
    "user": "https://github.com/ohanar"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_258007.json:
```json
{
    "body": "This looks like an over-engineered solution to the problem of implementing comparison for plain Python classes.\n\nA better solution would be to add better support for `_richmp_`. This is what I did in #21128.",
    "created_at": "2016-07-29T12:08:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258007",
    "user": "https://github.com/jdemeyer"
}
```

This looks like an over-engineered solution to the problem of implementing comparison for plain Python classes.

A better solution would be to add better support for `_richmp_`. This is what I did in #21128.



---

archive/issue_events_053099.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2016-07-29T14:43:18Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19108#event-53099"
}
```



---

archive/issue_comments_258008.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2016-07-29T14:43:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258008",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_258009.json:
```json
{
    "body": "Determined to be invalid/duplicate/wontfix (closing as \"wontfix\" as a catch-all resolution).",
    "created_at": "2016-08-30T13:32:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258009",
    "user": "https://github.com/embray"
}
```

Determined to be invalid/duplicate/wontfix (closing as "wontfix" as a catch-all resolution).



---

archive/issue_comments_258010.json:
```json
{
    "body": "Resolution: wontfix",
    "created_at": "2016-08-30T13:32:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19108#issuecomment-258010",
    "user": "https://github.com/embray"
}
```

Resolution: wontfix



---

archive/issue_events_053100.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2016-08-30T13:32:25Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/19108",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19108#event-53100"
}
```
