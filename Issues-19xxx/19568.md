# Issue 19568: RBF(x) should have the precision of RBF

archive/issues_019331.json:
```json
{
    "body": "In general `arb` balls can have a precision different from their parent. Though, when converting to a ball parent, the precision should be set to the precision of the parent. Especially when the input is an integer or or a rational.\n\nBecause of this, we get strange behavior such as\n\n```\nsage: from sage.rings.real_arb import RealBallField\nsage: a = RealBallField(20)(1.3)\nsage: b = RealBallField(53)(1.3)\nsage: a.identical(b)\nTrue\nsage: (a+0).identical(b+0)\nFalse\n```\n\nThis ticket proposes to make it so that when `R(x)` is called the result is a ball with the exact precision of `R`.\n\nCC:  @videlec @mezzarobba @cheuberg\n\nBranch: [u/jdemeyer/arb_balls_should_have_the_precision_of_the_parent](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/arb_balls_should_have_the_precision_of_the_parent)\n\nCommit: [9a25f5e197275cc75b68d678104d307def4b7e1c](https://github.com/sagemath/sagetrac-mirror/commit/9a25f5e197275cc75b68d678104d307def4b7e1c)\n\nAuthor: Jeroen Demeyer\n\nStatus: needs_work\n\nIssue created by migration from https://trac.sagemath.org/ticket/19568\n\n",
    "created_at": "2015-11-11T06:14:30Z",
    "labels": [
        "component: interfaces",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.2",
    "title": "RBF(x) should have the precision of RBF",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19568",
    "user": "https://github.com/jdemeyer"
}
```
In general `arb` balls can have a precision different from their parent. Though, when converting to a ball parent, the precision should be set to the precision of the parent. Especially when the input is an integer or or a rational.

Because of this, we get strange behavior such as

```
sage: from sage.rings.real_arb import RealBallField
sage: a = RealBallField(20)(1.3)
sage: b = RealBallField(53)(1.3)
sage: a.identical(b)
True
sage: (a+0).identical(b+0)
False
```

This ticket proposes to make it so that when `R(x)` is called the result is a ball with the exact precision of `R`.

CC:  @videlec @mezzarobba @cheuberg

Branch: [u/jdemeyer/arb_balls_should_have_the_precision_of_the_parent](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/arb_balls_should_have_the_precision_of_the_parent)

Commit: [9a25f5e197275cc75b68d678104d307def4b7e1c](https://github.com/sagemath/sagetrac-mirror/commit/9a25f5e197275cc75b68d678104d307def4b7e1c)

Author: Jeroen Demeyer

Status: needs_work

Issue created by migration from https://trac.sagemath.org/ticket/19568





---

archive/issue_comments_354616.json:
```json
{
    "body": "Branch: [u/jdemeyer/arb_balls_should_have_the_precision_of_the_parent](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/arb_balls_should_have_the_precision_of_the_parent)",
    "created_at": "2015-11-11T06:52:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354616",
    "user": "https://github.com/jdemeyer"
}
```

Branch: [u/jdemeyer/arb_balls_should_have_the_precision_of_the_parent](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/arb_balls_should_have_the_precision_of_the_parent)



---

archive/issue_comments_354617.json:
```json
{
    "body": "Commit: [638f7f581a72056c39d013e4b46cce500176a710](https://github.com/sagemath/sagetrac-mirror/commit/638f7f581a72056c39d013e4b46cce500176a710)",
    "created_at": "2015-11-11T06:53:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354617",
    "user": "https://github.com/jdemeyer"
}
```

Commit: [638f7f581a72056c39d013e4b46cce500176a710](https://github.com/sagemath/sagetrac-mirror/commit/638f7f581a72056c39d013e4b46cce500176a710)



---

archive/issue_comments_354618.json:
```json
{
    "body": "<a id='comment:2'></a>\nLast 10 new commits:\n|                                                                                                                                          |                                       |\n|------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------|\n|[ab117da](https://github.com/sagemath/sagetrac-mirror/commit/ab117da4dc913caa7b9d57fd8959d22e28f15230)|`complex_ball: abort() --> sig_error()`|\n|[1ee8c16](https://github.com/sagemath/sagetrac-mirror/commit/1ee8c1657c081e8ffc9957c995792e203cb65433)|`ref manual: rm reference to arb being optional`|\n|[865e6d5](https://github.com/sagemath/sagetrac-mirror/commit/865e6d5ae80590baf2aa0c761ba77c8fc089db2c)|`{real,complex}_arb: more doc on precision issues`|\n|[d289538](https://github.com/sagemath/sagetrac-mirror/commit/d289538d98f08caf9d58acc487efff41c3fc91b4)|`{real,complex}_arb: move SEEALSO blocks after EXAMPLES`|\n|[fe1b071](https://github.com/sagemath/sagetrac-mirror/commit/fe1b071710c82fef5cb3558aaa37a5caae8a7d22)|`RealBall: clarify doc of upper(), lower(), endpoints()`|\n|[a38574a](https://github.com/sagemath/sagetrac-mirror/commit/a38574a114130513855929c881e841b0ebffa19a)|`complex_arb is no longer experimental`|\n|[d5af324](https://github.com/sagemath/sagetrac-mirror/commit/d5af324cfc7c998a11c91b98d00521c2f664502c)|`{real,complex}_arb: minor doc fixes`|\n|[f43e94a](https://github.com/sagemath/sagetrac-mirror/commit/f43e94a46bc9c0f03ba63ee8538384180d89d306)|`RealBall: minor change to __hash__`|\n|[7e6b5d0](https://github.com/sagemath/sagetrac-mirror/commit/7e6b5d049ce0107880171d156f3da2f16d480476)|`real_arb: minor doc fix`|\n|[638f7f5](https://github.com/sagemath/sagetrac-mirror/commit/638f7f581a72056c39d013e4b46cce500176a710)|`Always round balls to the precision of the parent`|",
    "created_at": "2015-11-11T06:53:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354618",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>
Last 10 new commits:
|                                                                                                                                          |                                       |
|------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------|
|[ab117da](https://github.com/sagemath/sagetrac-mirror/commit/ab117da4dc913caa7b9d57fd8959d22e28f15230)|`complex_ball: abort() --> sig_error()`|
|[1ee8c16](https://github.com/sagemath/sagetrac-mirror/commit/1ee8c1657c081e8ffc9957c995792e203cb65433)|`ref manual: rm reference to arb being optional`|
|[865e6d5](https://github.com/sagemath/sagetrac-mirror/commit/865e6d5ae80590baf2aa0c761ba77c8fc089db2c)|`{real,complex}_arb: more doc on precision issues`|
|[d289538](https://github.com/sagemath/sagetrac-mirror/commit/d289538d98f08caf9d58acc487efff41c3fc91b4)|`{real,complex}_arb: move SEEALSO blocks after EXAMPLES`|
|[fe1b071](https://github.com/sagemath/sagetrac-mirror/commit/fe1b071710c82fef5cb3558aaa37a5caae8a7d22)|`RealBall: clarify doc of upper(), lower(), endpoints()`|
|[a38574a](https://github.com/sagemath/sagetrac-mirror/commit/a38574a114130513855929c881e841b0ebffa19a)|`complex_arb is no longer experimental`|
|[d5af324](https://github.com/sagemath/sagetrac-mirror/commit/d5af324cfc7c998a11c91b98d00521c2f664502c)|`{real,complex}_arb: minor doc fixes`|
|[f43e94a](https://github.com/sagemath/sagetrac-mirror/commit/f43e94a46bc9c0f03ba63ee8538384180d89d306)|`RealBall: minor change to __hash__`|
|[7e6b5d0](https://github.com/sagemath/sagetrac-mirror/commit/7e6b5d049ce0107880171d156f3da2f16d480476)|`real_arb: minor doc fix`|
|[638f7f5](https://github.com/sagemath/sagetrac-mirror/commit/638f7f581a72056c39d013e4b46cce500176a710)|`Always round balls to the precision of the parent`|



---

archive/issue_comments_354619.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-11-11T06:53:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354619",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_354620.json:
```json
{
    "body": "<a id='comment:3'></a>\nIMO saying that \u201carb balls can have a precision different from their parent\u201d isn't the right way to think about the issue. For example, `RealBallField(100)(1)` and `RealBallField(200)(1)` both have midpoints whose mantissa fits on 1 bit and zero radius: what is their \u201cprecision\u201d? The way I view it, they have none by themselves, and having `RealBallField`s of different precisions is just a convenient way of specifying the precision at which the results of operations on balls should be rounded.\n\nI don't find the way things currently work particularly confusing, while I think it can be useful in \u201cadvanced\u201d use (to compute the result of a subtraction involving cancellation, say). I should also say that real balls won't really \u201chave the precision of their parent\u201d even after your change: at the very least it will still be possible to create balls whose midpoint's precision is less than the precision of the parent\u2014and that's a good thing, but I'm not sure it is less confusing than the behavior you are trying to change.\n\nSo personally I'm certainly not going to give this ticket positive_review. That being said, I have no strong objection either to rounding integers etc. by default when creating new balls. It just makes things a bit less flexible for no good reason.",
    "created_at": "2015-11-11T09:35:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354620",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:3'></a>
IMO saying that “arb balls can have a precision different from their parent” isn't the right way to think about the issue. For example, `RealBallField(100)(1)` and `RealBallField(200)(1)` both have midpoints whose mantissa fits on 1 bit and zero radius: what is their “precision”? The way I view it, they have none by themselves, and having `RealBallField`s of different precisions is just a convenient way of specifying the precision at which the results of operations on balls should be rounded.

I don't find the way things currently work particularly confusing, while I think it can be useful in “advanced” use (to compute the result of a subtraction involving cancellation, say). I should also say that real balls won't really “have the precision of their parent” even after your change: at the very least it will still be possible to create balls whose midpoint's precision is less than the precision of the parent—and that's a good thing, but I'm not sure it is less confusing than the behavior you are trying to change.

So personally I'm certainly not going to give this ticket positive_review. That being said, I have no strong objection either to rounding integers etc. by default when creating new balls. It just makes things a bit less flexible for no good reason.



---

archive/issue_comments_354621.json:
```json
{
    "body": "<a id='comment:4'></a>\nReplying to [mmezzarobba](#comment%3A3):\n> IMO saying that \u201carb balls can have a precision different from their parent\u201d isn't the right way to think about the issue. For example, `RealBallField(100)(1)` and `RealBallField(200)(1)` both have midpoints whose mantissa fits on 1 bit and zero radius: what is their \u201cprecision\u201d?\n\nBy definition, the precision is the precision of the parent. There is nothing confusing about this. It is exactly like everything else in Sage.\n \n> I don't find the way things currently work particularly confusing, while I think it can be useful in \u201cadvanced\u201d use (to compute the result of a subtraction involving cancellation, say).\n\nWe shouldn't aim in the first place to \"advanced\" use, we should aim in the first place for intuitive use. This means in particular being compatible with the rest of Sage.\n\n> I should also say that real balls won't really \u201chave the precision of their parent\u201d even after your change: at the very least it will still be possible to create balls whose midpoint's precision is less than the precision of the parent\u2014and that's a good thing\n\nThat's an implementation detail. It doesn't matter from the user's point of view.\n\n> So personally I'm certainly not going to give this ticket positive_review. That being said, I have no strong objection either to rounding integers etc. by default when creating new balls. It just makes things a bit less flexible for no good reason.\n\nThere is a good reason, read the ticket description.",
    "created_at": "2015-11-11T17:01:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354621",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
Replying to [mmezzarobba](#comment%3A3):
> IMO saying that “arb balls can have a precision different from their parent” isn't the right way to think about the issue. For example, `RealBallField(100)(1)` and `RealBallField(200)(1)` both have midpoints whose mantissa fits on 1 bit and zero radius: what is their “precision”?

By definition, the precision is the precision of the parent. There is nothing confusing about this. It is exactly like everything else in Sage.
 
> I don't find the way things currently work particularly confusing, while I think it can be useful in “advanced” use (to compute the result of a subtraction involving cancellation, say).

We shouldn't aim in the first place to "advanced" use, we should aim in the first place for intuitive use. This means in particular being compatible with the rest of Sage.

> I should also say that real balls won't really “have the precision of their parent” even after your change: at the very least it will still be possible to create balls whose midpoint's precision is less than the precision of the parent—and that's a good thing

That's an implementation detail. It doesn't matter from the user's point of view.

> So personally I'm certainly not going to give this ticket positive_review. That being said, I have no strong objection either to rounding integers etc. by default when creating new balls. It just makes things a bit less flexible for no good reason.

There is a good reason, read the ticket description.



---

archive/issue_comments_354622.json:
```json
{
    "body": "<a id='comment:5'></a>\nIn case it's not clear: my main objection is really that you're doing things too much different from other numerical rings in Sage.",
    "created_at": "2015-11-11T17:03:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354622",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
In case it's not clear: my main objection is really that you're doing things too much different from other numerical rings in Sage.



---

archive/issue_comments_354623.json:
```json
{
    "body": "<a id='comment:6'></a>\nReplying to [jdemeyer](#comment%3A4):\n> There is a good reason, read the ticket description.\n\n\nEquality of balls is rare, it only holds if either the objects are identical (`is` is a subset of `==`) or if both balls are exact and equal. As `RBF(1.3)` is not exact, it should not be surprising that `a+0 == b+0` returns `True`.\n\nA similar example --- and this is not related to the purpose of the ticket as far as I can understand it --- is\n\n```\nsage: a = RBF(1.3)\nsage: a == a\nTrue\nsage: a + 1 == a + 1\nFalse\n```",
    "created_at": "2015-11-12T14:53:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354623",
    "user": "https://github.com/cheuberg"
}
```

<a id='comment:6'></a>
Replying to [jdemeyer](#comment%3A4):
> There is a good reason, read the ticket description.


Equality of balls is rare, it only holds if either the objects are identical (`is` is a subset of `==`) or if both balls are exact and equal. As `RBF(1.3)` is not exact, it should not be surprising that `a+0 == b+0` returns `True`.

A similar example --- and this is not related to the purpose of the ticket as far as I can understand it --- is

```
sage: a = RBF(1.3)
sage: a == a
True
sage: a + 1 == a + 1
False
```



---

archive/issue_comments_354624.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [cheuberg](#comment%3A6):\n> Replying to [jdemeyer](#comment%3A4):\n> > There is a good reason, read the ticket description.\n\n> \n> Equality of balls is rare, it only holds if either the objects are identical (`is` is a subset of `==`) or if both balls are exact and equal.\n\nOK, then it's just my example which is wrong.",
    "created_at": "2015-11-12T16:44:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354624",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>
Replying to [cheuberg](#comment%3A6):
> Replying to [jdemeyer](#comment%3A4):
> > There is a good reason, read the ticket description.

> 
> Equality of balls is rare, it only holds if either the objects are identical (`is` is a subset of `==`) or if both balls are exact and equal.

OK, then it's just my example which is wrong.



---

archive/issue_comments_354625.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,10 +1,12 @@\n The fact that `arb` balls can have a precision different from their parent is really confusing. It's different from anything else in Sage and leads to strange things like\n \n ```\n-sage: a = RealBallField(20)(1.3)\n-sage: b = RealBallField(53)(1.3)\n-sage: a == b\n+sage: from sage.rings.real_arb import RealBallField\n+sage: sage: from sage.rings.real_arb import RealBallField\n+sage: sage: a = RealBallField(20)(1.3)\n+sage: sage: b = RealBallField(53)(1.3)\n+sage: a.identical(b)\n True\n-sage: a+0 == b+0\n+sage: (a+0).identical(b+0)\n False\n ```\n``````\n",
    "created_at": "2015-11-12T16:44:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354625",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,10 +1,12 @@
 The fact that `arb` balls can have a precision different from their parent is really confusing. It's different from anything else in Sage and leads to strange things like
 
 ```
-sage: a = RealBallField(20)(1.3)
-sage: b = RealBallField(53)(1.3)
-sage: a == b
+sage: from sage.rings.real_arb import RealBallField
+sage: sage: from sage.rings.real_arb import RealBallField
+sage: sage: a = RealBallField(20)(1.3)
+sage: sage: b = RealBallField(53)(1.3)
+sage: a.identical(b)
 True
-sage: a+0 == b+0
+sage: (a+0).identical(b+0)
 False
 ```
``````




---

archive/issue_comments_354626.json:
```json
{
    "body": "<a id='comment:8'></a>\nReplying to [jdemeyer](#comment%3A7):\n> Equality of balls is rare, it only holds if either the objects are identical\n\nSeriously? Even more crazy `arb` stuff:\n\n```\nsage: from sage.rings.real_arb import RBF\nsage: a = RBF(1/3)\nsage: b = RBF(1/3)\nsage: a.identical(b)\nTrue\nsage: a == b\nFalse\nsage: a == a\nTrue\n```",
    "created_at": "2015-11-12T16:46:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354626",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
Replying to [jdemeyer](#comment%3A7):
> Equality of balls is rare, it only holds if either the objects are identical

Seriously? Even more crazy `arb` stuff:

```
sage: from sage.rings.real_arb import RBF
sage: a = RBF(1/3)
sage: b = RBF(1/3)
sage: a.identical(b)
True
sage: a == b
False
sage: a == a
True
```



---

archive/issue_comments_354627.json:
```json
{
    "body": "<a id='comment:9'></a>\nReplying to [jdemeyer](#comment%3A8):\n> Replying to [jdemeyer](#comment%3A7):\n> > Equality of balls is rare, it only holds if either the objects are identical\n\n> Seriously? Even more crazy `arb` stuff:\n> {{{\n> sage: from sage.rings.real_arb import RBF\n> sage: a = RBF(1/3)\n> sage: b = RBF(1/3)\n> sage: a.identical(b)\n> True\n> sage: a == b\n> False\n> sage: a == a\n> True\n> }}}\n\nWhich of the above do you consider crazy?",
    "created_at": "2015-11-12T17:30:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354627",
    "user": "https://github.com/cheuberg"
}
```

<a id='comment:9'></a>
Replying to [jdemeyer](#comment%3A8):
> Replying to [jdemeyer](#comment%3A7):
> > Equality of balls is rare, it only holds if either the objects are identical

> Seriously? Even more crazy `arb` stuff:
> {{{
> sage: from sage.rings.real_arb import RBF
> sage: a = RBF(1/3)
> sage: b = RBF(1/3)
> sage: a.identical(b)
> True
> sage: a == b
> False
> sage: a == a
> True
> }}}

Which of the above do you consider crazy?



---

archive/issue_comments_354628.json:
```json
{
    "body": "<a id='comment:10'></a>\nReplying to [cheuberg](#comment%3A9):\n> Replying to [jdemeyer](#comment%3A8):\n> > Replying to [jdemeyer](#comment%3A7):\n> > > Equality of balls is rare, it only holds if either the objects are identical\n\n> > Seriously? Even more crazy `arb` stuff:\n> > {{{\n> > sage: from sage.rings.real_arb import RBF\n> > sage: a = RBF(1/3)\n> > sage: b = RBF(1/3)\n> > sage: a.identical(b)\n> > True\n> > sage: a == b\n> > False\n> > sage: a == a\n> > True\n> > }}}\n\n> Which of the above do you consider crazy?\n\n```\nsage: a == a\nTrue\n```",
    "created_at": "2015-11-12T17:45:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354628",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:10'></a>
Replying to [cheuberg](#comment%3A9):
> Replying to [jdemeyer](#comment%3A8):
> > Replying to [jdemeyer](#comment%3A7):
> > > Equality of balls is rare, it only holds if either the objects are identical

> > Seriously? Even more crazy `arb` stuff:
> > {{{
> > sage: from sage.rings.real_arb import RBF
> > sage: a = RBF(1/3)
> > sage: b = RBF(1/3)
> > sage: a.identical(b)
> > True
> > sage: a == b
> > False
> > sage: a == a
> > True
> > }}}

> Which of the above do you consider crazy?

```
sage: a == a
True
```



---

archive/issue_comments_354629.json:
```json
{
    "body": "<a id='comment:11'></a>\nReplying to [jdemeyer](#comment%3A10):\n> Replying to [cheuberg](#comment%3A9):\n> > Replying to [jdemeyer](#comment%3A8):\n> > Which of the above do you consider crazy?\n\n> {{{\n> sage: a == a\n> True\n> }}}\n\nWe discussed this behaviour (introduced for consistency with the aliasing of input arguments) in #17194, starting at[comment:63](#comment%3A63):ticket:17194.",
    "created_at": "2015-11-13T05:32:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354629",
    "user": "https://github.com/cheuberg"
}
```

<a id='comment:11'></a>
Replying to [jdemeyer](#comment%3A10):
> Replying to [cheuberg](#comment%3A9):
> > Replying to [jdemeyer](#comment%3A8):
> > Which of the above do you consider crazy?

> {{{
> sage: a == a
> True
> }}}

We discussed this behaviour (introduced for consistency with the aliasing of input arguments) in #17194, starting at[comment:63](#comment%3A63):ticket:17194.



---

archive/issue_comments_354630.json:
```json
{
    "body": "<a id='comment:12'></a>\nRight. It is consistent with the \"equal pointers means equal values\" idea though, so at least there is some justification.",
    "created_at": "2015-11-13T06:10:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354630",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:12'></a>
Right. It is consistent with the "equal pointers means equal values" idea though, so at least there is some justification.



---

archive/issue_comments_354631.json:
```json
{
    "body": "<a id='comment:13'></a>\nComparison of floating point numbers is generally wrought with precision issues and best avoided, so  if thats all then I'd rather stay as close to the libarb behavior as possible, whatever it is. Balls (like intervals and normal floats) are just a tool, none of them are \"real numbers\". But if a Sage arb computation doesn't map directly to a libarb computation then I'd be very confused.",
    "created_at": "2015-11-26T19:20:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354631",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:13'></a>
Comparison of floating point numbers is generally wrought with precision issues and best avoided, so  if thats all then I'd rather stay as close to the libarb behavior as possible, whatever it is. Balls (like intervals and normal floats) are just a tool, none of them are "real numbers". But if a Sage arb computation doesn't map directly to a libarb computation then I'd be very confused.



---

archive/issue_comments_354632.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -10,3 +10,5 @@\n sage: (a+0).identical(b+0)\n False\n ```\n+\n+I propose to handle precision in `arb` the same way as for example `RR` or `RIF`. This means that the precision is determined by the parent: an element has the precision of its parent.\n``````\n",
    "created_at": "2015-11-27T06:38:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354632",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -10,3 +10,5 @@
 sage: (a+0).identical(b+0)
 False
 ```
+
+I propose to handle precision in `arb` the same way as for example `RR` or `RIF`. This means that the precision is determined by the parent: an element has the precision of its parent.
``````




---

archive/issue_comments_354633.json:
```json
{
    "body": "<a id='comment:14'></a>\nReplying to [vbraun](#comment%3A13):\n> But if a Sage arb computation doesn't map directly to a libarb computation then I'd be very confused.\n\n\nThis ticket isn't really about whether or not a Sage computation maps to a libarb computation. It's more about *how* it maps to a libarb computation.\n\nMore precisely, it's about the meaning of precision: currently, `arb` handles precision in a way which is completely different from anything else in Sage (the precision of an element can be different from the precision of the parent). This has consequences such as `a` and `a + 0` not always being the same.\n\nOn this ticket, I propose to handle precision in `arb` the same way as for example `RR` or `RIF`. This means that the precision is determined by the parent: an element has the precision of its parent.",
    "created_at": "2015-11-27T06:38:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354633",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:14'></a>
Replying to [vbraun](#comment%3A13):
> But if a Sage arb computation doesn't map directly to a libarb computation then I'd be very confused.


This ticket isn't really about whether or not a Sage computation maps to a libarb computation. It's more about *how* it maps to a libarb computation.

More precisely, it's about the meaning of precision: currently, `arb` handles precision in a way which is completely different from anything else in Sage (the precision of an element can be different from the precision of the parent). This has consequences such as `a` and `a + 0` not always being the same.

On this ticket, I propose to handle precision in `arb` the same way as for example `RR` or `RIF`. This means that the precision is determined by the parent: an element has the precision of its parent.



---

archive/issue_comments_354634.json:
```json
{
    "body": "<a id='comment:15'></a>\nThe way I understand it, what this ticket really does is not to make \u201cthe precision of arb balls\u201d that of their parent, but to round newly created balls to the precision of their parent by default. IMO this is a regression compared to the existing implementation (so I'd be in favor of closing the present ticket as wontfix), but a small one (so I'm not going to further argue against it, I just won't review it).\n\nIncidentally, I don't see how \u201c`arb` handles precision in a way which is completely different from anything else in Sage\u201d. For example, you can have power series truncated at any order in a `PowerSeriesRing` with any `default_prec`.",
    "created_at": "2015-11-27T08:49:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354634",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:15'></a>
The way I understand it, what this ticket really does is not to make “the precision of arb balls” that of their parent, but to round newly created balls to the precision of their parent by default. IMO this is a regression compared to the existing implementation (so I'd be in favor of closing the present ticket as wontfix), but a small one (so I'm not going to further argue against it, I just won't review it).

Incidentally, I don't see how “`arb` handles precision in a way which is completely different from anything else in Sage”. For example, you can have power series truncated at any order in a `PowerSeriesRing` with any `default_prec`.



---

archive/issue_comments_354635.json:
```json
{
    "body": "<a id='comment:16'></a>\nReplying to [jdemeyer](#comment%3A14):\n> This ticket isn't really about whether or not a Sage computation maps to a libarb computation. It's more about *how* it maps to a libarb computation.\n\n\nThats of course technically true, but you know what I meant: \n\nIf a Sage arb computation maps to a libarb computation with additional manual rounding thrown in then I'd be very confused.",
    "created_at": "2015-11-27T08:52:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354635",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:16'></a>
Replying to [jdemeyer](#comment%3A14):
> This ticket isn't really about whether or not a Sage computation maps to a libarb computation. It's more about *how* it maps to a libarb computation.


Thats of course technically true, but you know what I meant: 

If a Sage arb computation maps to a libarb computation with additional manual rounding thrown in then I'd be very confused.



---

archive/issue_comments_354636.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [vbraun](#comment%3A16):\n> If a Sage arb computation maps to a libarb computation with additional manual rounding thrown in then I'd be very confused.\n\n\nWell, both `acb_set_fmpz` and `acb_set_round_fmpz` are `arb` API functions, so it's matter of choosing between them. It's not \"manual rounding thrown in\", it's just calling a different function.\n\nBut even then, I think that it doesn't really matter how `libarb` does stuff internally: that's an implementation detail. What I propose here is simply to handle precision in `arb` the same way we handle precision in `RR` and `RIF`.",
    "created_at": "2015-11-27T09:14:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354636",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:17'></a>
Replying to [vbraun](#comment%3A16):
> If a Sage arb computation maps to a libarb computation with additional manual rounding thrown in then I'd be very confused.


Well, both `acb_set_fmpz` and `acb_set_round_fmpz` are `arb` API functions, so it's matter of choosing between them. It's not "manual rounding thrown in", it's just calling a different function.

But even then, I think that it doesn't really matter how `libarb` does stuff internally: that's an implementation detail. What I propose here is simply to handle precision in `arb` the same way we handle precision in `RR` and `RIF`.



---

archive/issue_comments_354637.json:
```json
{
    "body": "<a id='comment:18'></a>\nReplying to [mmezzarobba](#comment%3A15):\n> The way I understand it, what this ticket really does is not to make \u201cthe precision of arb balls\u201d that of their parent, but to round newly created balls to the precision of their parent by default.\n\n\nI really don't understand the difference between those 2 things. Yes, I propose to \"round newly created balls to the precision of their parent by default\". But that's just the implementation I need to achieve that the precision of arb balls is that of their parent.",
    "created_at": "2015-11-27T09:18:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354637",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:18'></a>
Replying to [mmezzarobba](#comment%3A15):
> The way I understand it, what this ticket really does is not to make “the precision of arb balls” that of their parent, but to round newly created balls to the precision of their parent by default.


I really don't understand the difference between those 2 things. Yes, I propose to "round newly created balls to the precision of their parent by default". But that's just the implementation I need to achieve that the precision of arb balls is that of their parent.



---

archive/issue_comments_354638.json:
```json
{
    "body": "<a id='comment:19'></a>\nReplying to [mmezzarobba](#comment%3A15):\n> Incidentally, I don't see how \u201c`arb` handles precision in a way which is completely different from anything else in Sage\u201d.\n\nOK, let me explain: in `arb`, parents have a precision. Also elements have a precision, which can be *different* from the precision of the parent. But, when doing any operation, the result gets rounded to the precision of the parent. There is nothing in Sage which works this way.\n\nThis leads to things like\n\n```\nsage: from sage.rings.real_arb import RBF\nsage: a = RBF(3^100)\nsage: a.identical(a+0)\nFalse\n```\nI don't know any Sage ring element which changes when adding `0`.\n\nThe difference with `PowerSeriesRing` is that the parent doesn't have a precision, only a *default* precision. A `PowerSeriesRing` can contain elements of any precision and that precision is taken into account when doing arithmetic:\n\n```\nsage: R.<x> = PowerSeriesRing(QQ)\nsage: a = x + O(x^30); a\nx + O(x^30)\nsage: a + 0\nx + O(x^30)\nsage: a = x + O(x^10); a\nx + O(x^10)\nsage: a + 0\nx + O(x^10)\n```\n\nThe equivalent of what `arb` currently does would be\n\n```\nsage: R.<x> = PowerSeriesRing(QQ)\nsage: a = x + O(x^30); a\nx + O(x^30)\nsage: a + 0\nx + O(x^20)\n```",
    "created_at": "2015-11-27T09:29:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354638",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:19'></a>
Replying to [mmezzarobba](#comment%3A15):
> Incidentally, I don't see how “`arb` handles precision in a way which is completely different from anything else in Sage”.

OK, let me explain: in `arb`, parents have a precision. Also elements have a precision, which can be *different* from the precision of the parent. But, when doing any operation, the result gets rounded to the precision of the parent. There is nothing in Sage which works this way.

This leads to things like

```
sage: from sage.rings.real_arb import RBF
sage: a = RBF(3^100)
sage: a.identical(a+0)
False
```
I don't know any Sage ring element which changes when adding `0`.

The difference with `PowerSeriesRing` is that the parent doesn't have a precision, only a *default* precision. A `PowerSeriesRing` can contain elements of any precision and that precision is taken into account when doing arithmetic:

```
sage: R.<x> = PowerSeriesRing(QQ)
sage: a = x + O(x^30); a
x + O(x^30)
sage: a + 0
x + O(x^30)
sage: a = x + O(x^10); a
x + O(x^10)
sage: a + 0
x + O(x^10)
```

The equivalent of what `arb` currently does would be

```
sage: R.<x> = PowerSeriesRing(QQ)
sage: a = x + O(x^30); a
x + O(x^30)
sage: a + 0
x + O(x^20)
```



---

archive/issue_comments_354639.json:
```json
{
    "body": "<a id='comment:20'></a>\nReplying to [jdemeyer](#comment%3A19):\n> The difference with `PowerSeriesRing` is that the parent doesn't have a precision, only a *default* precision. A `PowerSeriesRing` can contain elements of any precision and that precision is taken into account when doing arithmetic:\n\n\nYes, I agree that the analogy is not perfect. But I believe the example of power series rings shows that there is no single way of handling precision that is used uniformly across all sage parents, and that what we do with ball fields is not *completely* different from *anything* else in sage.\n\nThe way I view it, balls (elements) do not need a precision, because their accuracy is determined by their diameter. Only operations between balls have a precision, provided by the parent. It is up to the implementation of each operation to decide how large the mantissa of the center of its result needs to be, and this size may or may not be the precision of the operation (as far as I know, arb doesn't guarantee anything regarding the relation between these two quantities).",
    "created_at": "2015-11-27T09:55:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354639",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:20'></a>
Replying to [jdemeyer](#comment%3A19):
> The difference with `PowerSeriesRing` is that the parent doesn't have a precision, only a *default* precision. A `PowerSeriesRing` can contain elements of any precision and that precision is taken into account when doing arithmetic:


Yes, I agree that the analogy is not perfect. But I believe the example of power series rings shows that there is no single way of handling precision that is used uniformly across all sage parents, and that what we do with ball fields is not *completely* different from *anything* else in sage.

The way I view it, balls (elements) do not need a precision, because their accuracy is determined by their diameter. Only operations between balls have a precision, provided by the parent. It is up to the implementation of each operation to decide how large the mantissa of the center of its result needs to be, and this size may or may not be the precision of the operation (as far as I know, arb doesn't guarantee anything regarding the relation between these two quantities).



---

archive/issue_comments_354640.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [mmezzarobba](#comment%3A20):\n> I believe the example of power series rings shows that there is no single way of handling precision that is used uniformly across all sage parents\n\nWell, also keep in mind that the \"precision\" in power series (or p-adics, which are analogous) is more of an \"algebraic\" nature. You can see `O(x^n)` as modding out by the ideal `(x^n)`. There is no such thing for floating-point numbers and it would make a lot of sense to handle precision in `RBF` the same way as other floating-point rings such as `RR` and `RIF`.\n\n> and that what we do with ball fields is not *completely* different from *anything* else in sage.\n\nMaybe not *completely* different, but certainly *significantly* different.\n\nThat's also the reason why I got so confused with the `round()` function when reviewing #19152. I think that most people who use `RealBallField` will have the same confusion as me. I just see no reason why you insist on doing things differently for `arb`.",
    "created_at": "2015-11-27T10:13:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354640",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:21'></a>
Replying to [mmezzarobba](#comment%3A20):
> I believe the example of power series rings shows that there is no single way of handling precision that is used uniformly across all sage parents

Well, also keep in mind that the "precision" in power series (or p-adics, which are analogous) is more of an "algebraic" nature. You can see `O(x^n)` as modding out by the ideal `(x^n)`. There is no such thing for floating-point numbers and it would make a lot of sense to handle precision in `RBF` the same way as other floating-point rings such as `RR` and `RIF`.

> and that what we do with ball fields is not *completely* different from *anything* else in sage.

Maybe not *completely* different, but certainly *significantly* different.

That's also the reason why I got so confused with the `round()` function when reviewing #19152. I think that most people who use `RealBallField` will have the same confusion as me. I just see no reason why you insist on doing things differently for `arb`.



---

archive/issue_comments_354641.json:
```json
{
    "body": "<a id='comment:22'></a>\n> It is up to the implementation of each operation to decide how large the mantissa of the center of its result needs to be, and this size may or may not be the precision of the operation (as far as I know, arb doesn't guarantee anything regarding the relation between these two quantities).\n\n\nYou are right, the `arb` documentation is lacking: [https://github.com/fredrik-johansson/arb/issues/65](https://github.com/fredrik-johansson/arb/issues/65)",
    "created_at": "2015-11-27T10:21:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354641",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:22'></a>
> It is up to the implementation of each operation to decide how large the mantissa of the center of its result needs to be, and this size may or may not be the precision of the operation (as far as I know, arb doesn't guarantee anything regarding the relation between these two quantities).


You are right, the `arb` documentation is lacking: [https://github.com/fredrik-johansson/arb/issues/65](https://github.com/fredrik-johansson/arb/issues/65)



---

archive/issue_comments_354642.json:
```json
{
    "body": "Changing commit from \"[638f7f581a72056c39d013e4b46cce500176a710](https://github.com/sagemath/sagetrac-mirror/commit/638f7f581a72056c39d013e4b46cce500176a710)\" to \"[86783ae13a27695a8d5172e469bea48dbda40f23](https://github.com/sagemath/sagetrac-mirror/commit/86783ae13a27695a8d5172e469bea48dbda40f23)\"",
    "created_at": "2015-12-10T15:15:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354642",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "[638f7f581a72056c39d013e4b46cce500176a710](https://github.com/sagemath/sagetrac-mirror/commit/638f7f581a72056c39d013e4b46cce500176a710)" to "[86783ae13a27695a8d5172e469bea48dbda40f23](https://github.com/sagemath/sagetrac-mirror/commit/86783ae13a27695a8d5172e469bea48dbda40f23)"



---

archive/issue_comments_354643.json:
```json
{
    "body": "<a id='comment:23'></a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n|                                                                                                                                          |                                                                                     |\n|------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|\n|[86783ae](https://github.com/sagemath/sagetrac-mirror/commit/86783ae13a27695a8d5172e469bea48dbda40f23)|`Merge tag '6.10.rc0' into t/19568/arb_balls_should_have_the_precision_of_the_parent`|",
    "created_at": "2015-12-10T15:15:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354643",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:23'></a>
Branch pushed to git repo; I updated commit sha1. New commits:
|                                                                                                                                          |                                                                                     |
|------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|
|[86783ae](https://github.com/sagemath/sagetrac-mirror/commit/86783ae13a27695a8d5172e469bea48dbda40f23)|`Merge tag '6.10.rc0' into t/19568/arb_balls_should_have_the_precision_of_the_parent`|



---

archive/issue_comments_354644.json:
```json
{
    "body": "Changing dependencies from \"#19152\" to \"\"",
    "created_at": "2015-12-10T15:16:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354644",
    "user": "https://github.com/jdemeyer"
}
```

Changing dependencies from "#19152" to ""



---

archive/issue_comments_354645.json:
```json
{
    "body": "Changing commit from \"[86783ae13a27695a8d5172e469bea48dbda40f23](https://github.com/sagemath/sagetrac-mirror/commit/86783ae13a27695a8d5172e469bea48dbda40f23)\" to \"[9a25f5e197275cc75b68d678104d307def4b7e1c](https://github.com/sagemath/sagetrac-mirror/commit/9a25f5e197275cc75b68d678104d307def4b7e1c)\"",
    "created_at": "2016-02-05T10:12:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354645",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "[86783ae13a27695a8d5172e469bea48dbda40f23](https://github.com/sagemath/sagetrac-mirror/commit/86783ae13a27695a8d5172e469bea48dbda40f23)" to "[9a25f5e197275cc75b68d678104d307def4b7e1c](https://github.com/sagemath/sagetrac-mirror/commit/9a25f5e197275cc75b68d678104d307def4b7e1c)"



---

archive/issue_comments_354646.json:
```json
{
    "body": "<a id='comment:25'></a>\nBranch pushed to git repo; I updated commit sha1. New commits:\n|                                                                                                                                          |                                                                                      |\n|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|\n|[9a25f5e](https://github.com/sagemath/sagetrac-mirror/commit/9a25f5e197275cc75b68d678104d307def4b7e1c)|`Merge tag '7.1.beta2' into t/19568/arb_balls_should_have_the_precision_of_the_parent`|",
    "created_at": "2016-02-05T10:12:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354646",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:25'></a>
Branch pushed to git repo; I updated commit sha1. New commits:
|                                                                                                                                          |                                                                                      |
|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
|[9a25f5e](https://github.com/sagemath/sagetrac-mirror/commit/9a25f5e197275cc75b68d678104d307def4b7e1c)|`Merge tag '7.1.beta2' into t/19568/arb_balls_should_have_the_precision_of_the_parent`|



---

archive/issue_comments_354647.json:
```json
{
    "body": "<a id='comment:26'></a>\nMerge conflict.",
    "created_at": "2017-01-12T06:47:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354647",
    "user": "https://github.com/cheuberg"
}
```

<a id='comment:26'></a>
Merge conflict.



---

archive/issue_comments_354648.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-01-12T06:47:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354648",
    "user": "https://github.com/cheuberg"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_354649.json:
```json
{
    "body": "<a id='comment:27'></a>\n`@`cheuberg: do you actually care about this ticket? If you do, then I will try to fix it.",
    "created_at": "2017-01-12T08:17:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354649",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:27'></a>
`@`cheuberg: do you actually care about this ticket? If you do, then I will try to fix it.



---

archive/issue_comments_354650.json:
```json
{
    "body": "<a id='comment:28'></a>\nReplying to [jdemeyer](#comment%3A27):\n> `@`cheuberg: do you actually care about this ticket? If you do, then I will try to fix it.\n\nI am not convinced by the idea; so the answer is probably no, sorry. The ticket just turned up on a patchbot which I am experimenting with.",
    "created_at": "2017-01-17T08:05:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354650",
    "user": "https://github.com/cheuberg"
}
```

<a id='comment:28'></a>
Replying to [jdemeyer](#comment%3A27):
> `@`cheuberg: do you actually care about this ticket? If you do, then I will try to fix it.

I am not convinced by the idea; so the answer is probably no, sorry. The ticket just turned up on a patchbot which I am experimenting with.



---

archive/issue_comments_354651.json:
```json
{
    "body": "<a id='comment:29'></a>\nCC vdelecroix because you are working on various arb tickets.",
    "created_at": "2017-12-04T13:45:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354651",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:29'></a>
CC vdelecroix because you are working on various arb tickets.



---

archive/issue_comments_354652.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -2,9 +2,8 @@\n \n ```\n sage: from sage.rings.real_arb import RealBallField\n-sage: sage: from sage.rings.real_arb import RealBallField\n-sage: sage: a = RealBallField(20)(1.3)\n-sage: sage: b = RealBallField(53)(1.3)\n+sage: a = RealBallField(20)(1.3)\n+sage: b = RealBallField(53)(1.3)\n sage: a.identical(b)\n True\n sage: (a+0).identical(b+0)\n``````\n",
    "created_at": "2017-12-04T13:46:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354652",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -2,9 +2,8 @@
 
 ```
 sage: from sage.rings.real_arb import RealBallField
-sage: sage: from sage.rings.real_arb import RealBallField
-sage: sage: a = RealBallField(20)(1.3)
-sage: sage: b = RealBallField(53)(1.3)
+sage: a = RealBallField(20)(1.3)
+sage: b = RealBallField(53)(1.3)
 sage: a.identical(b)
 True
 sage: (a+0).identical(b+0)
``````




---

archive/issue_comments_354653.json:
```json
{
    "body": "<a id='comment:31'></a>\nI am not sure that I would accept the proposal of this ticket in its current form. As already discussed above, the concept of precisions are very different in `mpfr` (`mpc`/`mpfi`) and `arb`. Namely, in `mpfr` this is a guaranteed precision of the result whereas in `arb` it is mostly a working precision. In `arb` the only way that you can achieve tight result in the output is to make a loop with increasing precision. This is reflected in the fact that in `mpfr_XXX` function there is no precision argument whereas all `arb_XXX` ends with a `long prec`.\n\nI have no magic solution, but:\n- working with `mpfr` and `arb` are not the the same thing\n- in some situation it does make sense to truncate arb balls to fit the parent's precision (like when the input is an integer) but not always (when you are lucky and get more precision, why would you truncate it)",
    "created_at": "2017-12-04T16:08:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354653",
    "user": "https://github.com/videlec"
}
```

<a id='comment:31'></a>
I am not sure that I would accept the proposal of this ticket in its current form. As already discussed above, the concept of precisions are very different in `mpfr` (`mpc`/`mpfi`) and `arb`. Namely, in `mpfr` this is a guaranteed precision of the result whereas in `arb` it is mostly a working precision. In `arb` the only way that you can achieve tight result in the output is to make a loop with increasing precision. This is reflected in the fact that in `mpfr_XXX` function there is no precision argument whereas all `arb_XXX` ends with a `long prec`.

I have no magic solution, but:
- working with `mpfr` and `arb` are not the the same thing
- in some situation it does make sense to truncate arb balls to fit the parent's precision (like when the input is an integer) but not always (when you are lucky and get more precision, why would you truncate it)



---

archive/issue_comments_354654.json:
```json
{
    "body": "<a id='comment:32'></a>\nReplying to [vdelecroix](#comment%3A31):\n> As already discussed above, the concept of precisions are very different in `mpfr` (`mpc`/`mpfi`) and `arb`.\n\n\nI would say that this is an implementation detail of the library which should not affect how Sage deals with these objects.",
    "created_at": "2017-12-04T16:38:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354654",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:32'></a>
Replying to [vdelecroix](#comment%3A31):
> As already discussed above, the concept of precisions are very different in `mpfr` (`mpc`/`mpfi`) and `arb`.


I would say that this is an implementation detail of the library which should not affect how Sage deals with these objects.



---

archive/issue_comments_354655.json:
```json
{
    "body": "<a id='comment:33'></a>\nReplying to [vdelecroix](#comment%3A31):\n> when you are lucky and get more precision, why would you truncate it\n\n\nWith that argument, you might as well use larger precision for everything everywhere. I mean, we *could* change `RR` such that `RR(some_large_int)` stores the integer with full precision. We don't do that because everybody expects that elements of `RR` have only 53 bits of precision.\n\nI really don't see why arb balls should be different. And that is really my main concern for this ticket: perhaps the arb semantics make sense in a certain way. But the arb semantics are really surprising because they are different from anything else in Sage.",
    "created_at": "2017-12-04T16:42:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354655",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:33'></a>
Replying to [vdelecroix](#comment%3A31):
> when you are lucky and get more precision, why would you truncate it


With that argument, you might as well use larger precision for everything everywhere. I mean, we *could* change `RR` such that `RR(some_large_int)` stores the integer with full precision. We don't do that because everybody expects that elements of `RR` have only 53 bits of precision.

I really don't see why arb balls should be different. And that is really my main concern for this ticket: perhaps the arb semantics make sense in a certain way. But the arb semantics are really surprising because they are different from anything else in Sage.



---

archive/issue_comments_354656.json:
```json
{
    "body": "<a id='comment:34'></a>\nReplying to [jdemeyer](#comment%3A33):\n> Replying to [vdelecroix](#comment%3A31):\n> > when you are lucky and get more precision, why would you truncate it\n\n> \n> With that argument, you might as well use larger precision for everything everywhere. I mean, we *could* change `RR` such that `RR(some_large_int)` stores the integer with full precision. We don't do that because everybody expects that elements of `RR` have only 53 bits of precision.\n\n\nAs I already said `RBF(some_large_int)` **should** truncate the entry but currently does not (it uses `arb_set_fmpz`). I am a big +1 for such a change in our arb interface. There are two different questions:\n\n1. the semantic of `RBF(something)`: in this case I would like the truncation to always operate\n2. the semantic of `my_ball.some_function()`: where I do not know what is the best solution\n\n> I really don't see why arb balls should be different. And that is really my main concern for this ticket: perhaps the arb semantics make sense in a certain way. But the arb semantics are really surprising because they are different from anything else in Sage.\n\n\nThey are different in the case 2. above. If you compute the logarithm of `my_ball`, you have no idea a priori of the precision of `log(my_ball)`. This is not the case in `mpfr` where the precision is somehow statically encoded in the datastructure. You can always extend/truncate the result but this is rather artificial. The exact reason why I do not like it.",
    "created_at": "2017-12-04T16:58:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354656",
    "user": "https://github.com/videlec"
}
```

<a id='comment:34'></a>
Replying to [jdemeyer](#comment%3A33):
> Replying to [vdelecroix](#comment%3A31):
> > when you are lucky and get more precision, why would you truncate it

> 
> With that argument, you might as well use larger precision for everything everywhere. I mean, we *could* change `RR` such that `RR(some_large_int)` stores the integer with full precision. We don't do that because everybody expects that elements of `RR` have only 53 bits of precision.


As I already said `RBF(some_large_int)` **should** truncate the entry but currently does not (it uses `arb_set_fmpz`). I am a big +1 for such a change in our arb interface. There are two different questions:

1. the semantic of `RBF(something)`: in this case I would like the truncation to always operate
2. the semantic of `my_ball.some_function()`: where I do not know what is the best solution

> I really don't see why arb balls should be different. And that is really my main concern for this ticket: perhaps the arb semantics make sense in a certain way. But the arb semantics are really surprising because they are different from anything else in Sage.


They are different in the case 2. above. If you compute the logarithm of `my_ball`, you have no idea a priori of the precision of `log(my_ball)`. This is not the case in `mpfr` where the precision is somehow statically encoded in the datastructure. You can always extend/truncate the result but this is rather artificial. The exact reason why I do not like it.



---

archive/issue_comments_354657.json:
```json
{
    "body": "<a id='comment:35'></a>\nFWIW, after now a few years of regularly working with RBF/CBF, I am more and more convinced that the current implementation is better than truncating every time. In particular, it allows you to compare balls belonging to different parents in a meaningful way, even though they get coerced to the parent with the lower precision.",
    "created_at": "2017-12-04T17:00:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354657",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:35'></a>
FWIW, after now a few years of regularly working with RBF/CBF, I am more and more convinced that the current implementation is better than truncating every time. In particular, it allows you to compare balls belonging to different parents in a meaningful way, even though they get coerced to the parent with the lower precision.



---

archive/issue_comments_354658.json:
```json
{
    "body": "<a id='comment:36'></a>\nReplying to [vdelecroix](#comment%3A34):\n> As I already said `RBF(some_large_int)` **should** truncate the entry but currently does not (it uses `arb_set_fmpz`). I am a big +1 for such a change in our arb interface.\n\n\nThat is exactly what this ticket is about... and nothing else. So I clearly missed something in your comment [comment:31]",
    "created_at": "2017-12-04T21:17:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354658",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:36'></a>
Replying to [vdelecroix](#comment%3A34):
> As I already said `RBF(some_large_int)` **should** truncate the entry but currently does not (it uses `arb_set_fmpz`). I am a big +1 for such a change in our arb interface.


That is exactly what this ticket is about... and nothing else. So I clearly missed something in your comment [comment:31]



---

archive/issue_comments_354659.json:
```json
{
    "body": "<a id='comment:37'></a>\nThe title says ` arb balls should have the precision of the parent` which is more general than what I proposed. I changed the description accordingly.",
    "created_at": "2017-12-05T07:33:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354659",
    "user": "https://github.com/videlec"
}
```

<a id='comment:37'></a>
The title says ` arb balls should have the precision of the parent` which is more general than what I proposed. I changed the description accordingly.



---

archive/issue_events_061204.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2017-12-05T07:33:38Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "milestone": "sage-8.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19568#event-61204"
}
```



---

archive/issue_events_061205.json:
```json
{
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "rename": {
        "from": "arb balls should have the precision of the parent",
        "to": "RBF(x) should have the precision of RBF"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19568#event-61205"
}
```



---

archive/issue_comments_354660.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,6 @@\n-The fact that `arb` balls can have a precision different from their parent is really confusing. It's different from anything else in Sage and leads to strange things like\n+In general `arb` balls can have a precision different from their parent. Though, when converting to a parent, the precision should be set to the one of the parent. Especially when the input is an integer or or a rational.\n+\n+Because of this, we get strage behavior such as\n \n ```\n sage: from sage.rings.real_arb import RealBallField\n@@ -10,4 +12,4 @@\n False\n ```\n \n-I propose to handle precision in `arb` the same way as for example `RR` or `RIF`. This means that the precision is determined by the parent: an element has the precision of its parent.\n+This ticket proposes to make it so that when `R(x)` is called the result is a ball with the exact precision of `R`.\n``````\n",
    "created_at": "2017-12-05T07:33:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354660",
    "user": "https://github.com/videlec"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,6 @@
-The fact that `arb` balls can have a precision different from their parent is really confusing. It's different from anything else in Sage and leads to strange things like
+In general `arb` balls can have a precision different from their parent. Though, when converting to a parent, the precision should be set to the one of the parent. Especially when the input is an integer or or a rational.
+
+Because of this, we get strage behavior such as
 
 ```
 sage: from sage.rings.real_arb import RealBallField
@@ -10,4 +12,4 @@
 False
 ```
 
-I propose to handle precision in `arb` the same way as for example `RR` or `RIF`. This means that the precision is determined by the parent: an element has the precision of its parent.
+This ticket proposes to make it so that when `R(x)` is called the result is a ball with the exact precision of `R`.
``````




---

archive/issue_comments_354661.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n-In general `arb` balls can have a precision different from their parent. Though, when converting to a parent, the precision should be set to the one of the parent. Especially when the input is an integer or or a rational.\n+In general `arb` balls can have a precision different from their parent. Though, when converting to a ball parent, the precision should be set to the precision of the parent. Especially when the input is an integer or or a rational.\n \n Because of this, we get strage behavior such as\n \n``````\n",
    "created_at": "2017-12-05T07:36:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354661",
    "user": "https://github.com/videlec"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
-In general `arb` balls can have a precision different from their parent. Though, when converting to a parent, the precision should be set to the one of the parent. Especially when the input is an integer or or a rational.
+In general `arb` balls can have a precision different from their parent. Though, when converting to a ball parent, the precision should be set to the precision of the parent. Especially when the input is an integer or or a rational.
 
 Because of this, we get strage behavior such as
 
``````




---

archive/issue_comments_354662.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,6 @@\n In general `arb` balls can have a precision different from their parent. Though, when converting to a ball parent, the precision should be set to the precision of the parent. Especially when the input is an integer or or a rational.\n \n-Because of this, we get strage behavior such as\n+Because of this, we get strange behavior such as\n \n ```\n sage: from sage.rings.real_arb import RealBallField\n``````\n",
    "created_at": "2017-12-05T07:38:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354662",
    "user": "https://github.com/videlec"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,6 @@
 In general `arb` balls can have a precision different from their parent. Though, when converting to a ball parent, the precision should be set to the precision of the parent. Especially when the input is an integer or or a rational.
 
-Because of this, we get strage behavior such as
+Because of this, we get strange behavior such as
 
 ```
 sage: from sage.rings.real_arb import RealBallField
``````




---

archive/issue_comments_354663.json:
```json
{
    "body": "<a id='comment:40'></a>\nReplying to [vdelecroix](#comment%3A31):\n> Namely, in `mpfr` this is a guaranteed precision of the result whereas in `arb` it is mostly a working precision. In `arb` the only way that you can achieve tight result in the output is to make a loop with increasing precision. This is reflected in the fact that in `mpfr_XXX` function there is no precision argument whereas all `arb_XXX` ends with a `long prec`.\n\n\nAren't you confusing two things here?\n\nWhen I say \"precision\" I mean the number of bits stored in the data structure, regardless of how these bits were obtained. This is a priori unrelated to the error margin (the difference between the mathematical result and the output number).\n\nMPFR makes guarantees about both: you know how many bits the output number has and you know that the number is exactly rounded.\n\nWith arb, you still know the number of bits which is used to represent the midpoint of the output ball. That is, the `prec` argument of the function which was called. This is clearly documented in http://arblib.org/using.html:\n\n> Given a ball [m\u00b1r] with m\u2208R (not necessarily a floating-point number), we can always round m to a nearby floating-point number that has at most most prec bits in the component u, and add an upper bound for the rounding error to r. In Arb, ball functions that take a prec argument as input (e.g. arb_add()) always round their output to prec bits. Some functions are always exact (e.g. arb_neg()), and thus do not take a prec argument.\n\n\nSo I think that \"says arb balls should have the precision of the parent\" is equivalent to \"RBF(x) should have the precision of RBF\" unless I am misunderstanding something.",
    "created_at": "2017-12-05T08:49:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19568",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19568#issuecomment-354663",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:40'></a>
Replying to [vdelecroix](#comment%3A31):
> Namely, in `mpfr` this is a guaranteed precision of the result whereas in `arb` it is mostly a working precision. In `arb` the only way that you can achieve tight result in the output is to make a loop with increasing precision. This is reflected in the fact that in `mpfr_XXX` function there is no precision argument whereas all `arb_XXX` ends with a `long prec`.


Aren't you confusing two things here?

When I say "precision" I mean the number of bits stored in the data structure, regardless of how these bits were obtained. This is a priori unrelated to the error margin (the difference between the mathematical result and the output number).

MPFR makes guarantees about both: you know how many bits the output number has and you know that the number is exactly rounded.

With arb, you still know the number of bits which is used to represent the midpoint of the output ball. That is, the `prec` argument of the function which was called. This is clearly documented in http://arblib.org/using.html:

> Given a ball [m±r] with m∈R (not necessarily a floating-point number), we can always round m to a nearby floating-point number that has at most most prec bits in the component u, and add an upper bound for the rounding error to r. In Arb, ball functions that take a prec argument as input (e.g. arb_add()) always round their output to prec bits. Some functions are always exact (e.g. arb_neg()), and thus do not take a prec argument.


So I think that "says arb balls should have the precision of the parent" is equivalent to "RBF(x) should have the precision of RBF" unless I am misunderstanding something.
