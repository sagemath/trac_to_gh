# Issue 19613: Implement basic representations of semigroups

archive/issues_019376.json:
```json
{
    "body": "We provide a basic implementation of representations of semigroups with a distinguished basis.\n\nAssignee: sage-combinat\n\nCC:  sage-combinat @nthiery @avirmaux\n\nKeywords: representation, semigroups,\n\nBranch/Commit: f8b1e3040199be23644dc67c4236018bf6a89b8f\n\nReviewer: Darij Grinberg\n\nAuthor: Travis Scrimshaw\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/19613\n\n",
    "closed_at": "2016-01-30T21:04:55Z",
    "created_at": "2015-11-22T05:52:30Z",
    "labels": [
        "component: group theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.1",
    "title": "Implement basic representations of semigroups",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19613",
    "user": "https://github.com/tscrim"
}
```
We provide a basic implementation of representations of semigroups with a distinguished basis.

Assignee: sage-combinat

CC:  sage-combinat @nthiery @avirmaux

Keywords: representation, semigroups,

Branch/Commit: f8b1e3040199be23644dc67c4236018bf6a89b8f

Reviewer: Darij Grinberg

Author: Travis Scrimshaw

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/19613





---

archive/issue_comments_352276.json:
```json
{
    "body": "Changing branch from \"\" to \"public/representations/basic_implementation-19613\"",
    "created_at": "2015-11-22T05:54:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352276",
    "user": "https://github.com/tscrim"
}
```

Changing branch from "" to "public/representations/basic_implementation-19613"



---

archive/issue_comments_352277.json:
```json
{
    "body": "<a id='comment:1'></a>This is a first step to an implementation of group (co)homology.\n\n---\nNew commits:",
    "created_at": "2015-11-22T05:54:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352277",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:1'></a>This is a first step to an implementation of group (co)homology.

---
New commits:



---

archive/issue_comments_352278.json:
```json
{
    "body": "Changing commit from \"\" to \"0d510228773b6f7899c09e405f93a963595f0af0\"",
    "created_at": "2015-11-22T05:54:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352278",
    "user": "https://github.com/tscrim"
}
```

Changing commit from "" to "0d510228773b6f7899c09e405f93a963595f0af0"



---

archive/issue_comments_352279.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-11-22T05:54:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352279",
    "user": "https://github.com/tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_352280.json:
```json
{
    "body": "<a id='comment:2'></a>This is promising to be really useful!\n\nA few first impressions (Sage is compiling doc, so I can't really edit):\n\nCan you document the `left_repr` keyword in the `regular_representation` method in `semigroups.py`?\n\nIn the `_acted_upon_` of `TrivialRepresentation`, I would use a `sum` method instead of the `sum` function (I hope it would involve less indirection/ducktyping).\n\nDoes the `RegularRepresentation` allow both multiplying by elements of the semigroup and multiplying by elements of the semigroup algebra? (And if so, please doctest both.)\n\nI have recently wrotten some really sloppy code to build a finite semigroup out of a multiplication table (I hoped to use it on #19892, but then I found that semigroups lack the support for that, so I ended up avoiding it). I'm wondering -- would this be useful for this patch? At the very least it could give us a way to doctest the methods. I could polish the code and submit it here; I just want to make sure it won't be in vain, as I have a hard time believing that there is no such thing in Sage already...",
    "created_at": "2016-01-22T03:06:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352280",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:2'></a>This is promising to be really useful!

A few first impressions (Sage is compiling doc, so I can't really edit):

Can you document the `left_repr` keyword in the `regular_representation` method in `semigroups.py`?

In the `_acted_upon_` of `TrivialRepresentation`, I would use a `sum` method instead of the `sum` function (I hope it would involve less indirection/ducktyping).

Does the `RegularRepresentation` allow both multiplying by elements of the semigroup and multiplying by elements of the semigroup algebra? (And if so, please doctest both.)

I have recently wrotten some really sloppy code to build a finite semigroup out of a multiplication table (I hoped to use it on #19892, but then I found that semigroups lack the support for that, so I ended up avoiding it). I'm wondering -- would this be useful for this patch? At the very least it could give us a way to doctest the methods. I could polish the code and submit it here; I just want to make sure it won't be in vain, as I have a hard time believing that there is no such thing in Sage already...



---

archive/issue_comments_352281.json:
```json
{
    "body": "<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-23T21:41:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352281",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_352282.json:
```json
{
    "body": "Changing commit from \"0d510228773b6f7899c09e405f93a963595f0af0\" to \"9f2ff6e14f3376d420dbe87715a0bd112e0ccdb7\"",
    "created_at": "2016-01-23T21:41:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352282",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "0d510228773b6f7899c09e405f93a963595f0af0" to "9f2ff6e14f3376d420dbe87715a0bd112e0ccdb7"



---

archive/issue_comments_352283.json:
```json
{
    "body": "<a id='comment:4'></a>Replying to [comment:2 darij]:\n> Can you document the `left_repr` keyword in the `regular_representation` method in `semigroups.py`?\n\n\nAdded.\n\n> In the `_acted_upon_` of `TrivialRepresentation`, I would use a `sum` method instead of the `sum` function (I hope it would involve less indirection/ducktyping).\n\n\nThat isn't ducktyping (it's the python `sum` not the symbolic `sum` that is at the top-level interface). Also, all `self.base_ring().sum(elts)` does is call `sum(elts, self.zero())` so it involves one further level of indirection.\n\n> Does the `RegularRepresentation` allow both multiplying by elements of the semigroup and multiplying by elements of the semigroup algebra? (And if so, please doctest both.)\n\n\nYes, and I added some doctests about this. I also caught a few bugs with these doctests.\n\n> I have recently wrotten some really sloppy code to build a finite semigroup out of a multiplication table (I hoped to use it on #19892, but then I found that semigroups lack the support for that, so I ended up avoiding it). I'm wondering -- would this be useful for this patch? At the very least it could give us a way to doctest the methods. I could polish the code and submit it here; I just want to make sure it won't be in vain, as I have a hard time believing that there is no such thing in Sage already...\n\n\nThere is code in `algebras/finite_dimensional_algebras` which essentially does that. We probably could separate that code into the semigroup part and the algebra part (and combine it with your code). However, I think that is better for a separate ticket because it won't directly apply to this (could be good for extensive testing of this, but I think that could be overkill).",
    "created_at": "2016-01-23T21:47:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352283",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:4'></a>Replying to [comment:2 darij]:
> Can you document the `left_repr` keyword in the `regular_representation` method in `semigroups.py`?


Added.

> In the `_acted_upon_` of `TrivialRepresentation`, I would use a `sum` method instead of the `sum` function (I hope it would involve less indirection/ducktyping).


That isn't ducktyping (it's the python `sum` not the symbolic `sum` that is at the top-level interface). Also, all `self.base_ring().sum(elts)` does is call `sum(elts, self.zero())` so it involves one further level of indirection.

> Does the `RegularRepresentation` allow both multiplying by elements of the semigroup and multiplying by elements of the semigroup algebra? (And if so, please doctest both.)


Yes, and I added some doctests about this. I also caught a few bugs with these doctests.

> I have recently wrotten some really sloppy code to build a finite semigroup out of a multiplication table (I hoped to use it on #19892, but then I found that semigroups lack the support for that, so I ended up avoiding it). I'm wondering -- would this be useful for this patch? At the very least it could give us a way to doctest the methods. I could polish the code and submit it here; I just want to make sure it won't be in vain, as I have a hard time believing that there is no such thing in Sage already...


There is code in `algebras/finite_dimensional_algebras` which essentially does that. We probably could separate that code into the semigroup part and the algebra part (and combine it with your code). However, I think that is better for a separate ticket because it won't directly apply to this (could be good for extensive testing of this, but I think that could be overkill).



---

archive/issue_comments_352284.json:
```json
{
    "body": "<a id='comment:5'></a>Hmm, I really need to get my pile of semigroup code into Sage. But this should not stop you from making progress in the mean time. In case you'd have the occasion to spend a couple days in Paris, I'd be happy to do a coding sprint with you on this topic.\n\nFor building a variety of semigroups, you can use `sage.monoids.automatic_semigroup.AutomaticSemigroup`.\n\nFor info: I am currently working on an improved GAP-Sage interface allowing to easily wrap all kind of GAP parents, including semigroups:\n\n    https://github.com/nthiery/sage-gap-semantic-interface\n\nBut here again, don't hold your breath!\n\nCheers,",
    "created_at": "2016-01-23T22:16:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352284",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>Hmm, I really need to get my pile of semigroup code into Sage. But this should not stop you from making progress in the mean time. In case you'd have the occasion to spend a couple days in Paris, I'd be happy to do a coding sprint with you on this topic.

For building a variety of semigroups, you can use `sage.monoids.automatic_semigroup.AutomaticSemigroup`.

For info: I am currently working on an improved GAP-Sage interface allowing to easily wrap all kind of GAP parents, including semigroups:

    https://github.com/nthiery/sage-gap-semantic-interface

But here again, don't hold your breath!

Cheers,



---

archive/issue_comments_352285.json:
```json
{
    "body": "<a id='comment:6'></a>Replying to [comment:4 tscrim]:\n> Replying to [comment:2 darij]:\n> > Can you document the `left_repr` keyword in the `regular_representation` method in `semigroups.py`?\n\n> \n> Added.\n\n\nOK, weird. Why do you call it `left` one time and `left_repr` another? Also, it is still undocumented one time in `semigroups.py` (there are two `regular_representation` methods in that file; sorry for missing that).\n\n> > In the `_acted_upon_` of `TrivialRepresentation`, I would use a `sum` method instead of the `sum` function (I hope it would involve less indirection/ducktyping).\n\n> \n> That isn't ducktyping (it's the python `sum` not the symbolic `sum` that is at the top-level interface). Also, all `self.base_ring().sum(elts)` does is call `sum(elts, self.zero())` so it involves one further level of indirection.\n\n\nAh, you're perfectly right.\n\n\n> > I have recently wrotten some really sloppy code to build a finite semigroup out of a multiplication table (I hoped to use it on #19892, but then I found that semigroups lack the support for that, so I ended up avoiding it). I'm wondering -- would this be useful for this patch? At the very least it could give us a way to doctest the methods. I could polish the code and submit it here; I just want to make sure it won't be in vain, as I have a hard time believing that there is no such thing in Sage already...\n\n> \n> There is code in `algebras/finite_dimensional_algebras` which essentially does that. We probably could separate that code into the semigroup part and the algebra part (and combine it with your code). However, I think that is better for a separate ticket because it won't directly apply to this (could be good for extensive testing of this, but I think that could be overkill).\n\n\nI guess you're right -- groups are probably enough for doctesting.\n\nI am aware of `algebras/finite_dimensional_algebras` being essentially the linear version of what I wanted to do. (This is what I ended up using in #19892, since I really cared about the face semigroup algebra, not the face semigroup.) Still I wanted the non-linear version, since having a semigroup algebra without its semigroup looks really weird.\n\nNicolas, is this something you have in your code?",
    "created_at": "2016-01-23T22:47:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352285",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:6'></a>Replying to [comment:4 tscrim]:
> Replying to [comment:2 darij]:
> > Can you document the `left_repr` keyword in the `regular_representation` method in `semigroups.py`?

> 
> Added.


OK, weird. Why do you call it `left` one time and `left_repr` another? Also, it is still undocumented one time in `semigroups.py` (there are two `regular_representation` methods in that file; sorry for missing that).

> > In the `_acted_upon_` of `TrivialRepresentation`, I would use a `sum` method instead of the `sum` function (I hope it would involve less indirection/ducktyping).

> 
> That isn't ducktyping (it's the python `sum` not the symbolic `sum` that is at the top-level interface). Also, all `self.base_ring().sum(elts)` does is call `sum(elts, self.zero())` so it involves one further level of indirection.


Ah, you're perfectly right.


> > I have recently wrotten some really sloppy code to build a finite semigroup out of a multiplication table (I hoped to use it on #19892, but then I found that semigroups lack the support for that, so I ended up avoiding it). I'm wondering -- would this be useful for this patch? At the very least it could give us a way to doctest the methods. I could polish the code and submit it here; I just want to make sure it won't be in vain, as I have a hard time believing that there is no such thing in Sage already...

> 
> There is code in `algebras/finite_dimensional_algebras` which essentially does that. We probably could separate that code into the semigroup part and the algebra part (and combine it with your code). However, I think that is better for a separate ticket because it won't directly apply to this (could be good for extensive testing of this, but I think that could be overkill).


I guess you're right -- groups are probably enough for doctesting.

I am aware of `algebras/finite_dimensional_algebras` being essentially the linear version of what I wanted to do. (This is what I ended up using in #19892, since I really cared about the face semigroup algebra, not the face semigroup.) Still I wanted the non-linear version, since having a semigroup algebra without its semigroup looks really weird.

Nicolas, is this something you have in your code?



---

archive/issue_comments_352286.json:
```json
{
    "body": "Changing keywords from \"representation\" to \"representation, semigroups,\".",
    "created_at": "2016-01-23T22:47:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352286",
    "user": "https://github.com/darijgr"
}
```

Changing keywords from "representation" to "representation, semigroups,".



---

archive/issue_events_053921.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2016-01-23T22:47:11Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "milestone": "sage-7.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19613#event-53921"
}
```



---

archive/issue_comments_352287.json:
```json
{
    "body": "<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-24T03:50:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352287",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_352288.json:
```json
{
    "body": "Changing commit from \"9f2ff6e14f3376d420dbe87715a0bd112e0ccdb7\" to \"99de16fca5c2c66b622a358c4de577f165aa7718\"",
    "created_at": "2016-01-24T03:50:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352288",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "9f2ff6e14f3376d420dbe87715a0bd112e0ccdb7" to "99de16fca5c2c66b622a358c4de577f165aa7718"



---

archive/issue_comments_352289.json:
```json
{
    "body": "<a id='comment:8'></a>`@`darij Now both methods use `left` and are documented.\n\nWhat I am suggesting is refactor the multiplication code for the fin-dim algebras into a finite semigroup (well, really finite magma because the product does not have to be associative). Then we would make a fin-dim algebra to be the algebra of a finite semigroup (magma).\n\n`@`nthiery I will should have some time before (and I think after but need to double-check) Days 74, and I would be happy to do some coding sprints with you.\n\nPS - How were the Sage-GAP days?",
    "created_at": "2016-01-24T04:05:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352289",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>`@`darij Now both methods use `left` and are documented.

What I am suggesting is refactor the multiplication code for the fin-dim algebras into a finite semigroup (well, really finite magma because the product does not have to be associative). Then we would make a fin-dim algebra to be the algebra of a finite semigroup (magma).

`@`nthiery I will should have some time before (and I think after but need to double-check) Days 74, and I would be happy to do some coding sprints with you.

PS - How were the Sage-GAP days?



---

archive/issue_comments_352290.json:
```json
{
    "body": "<a id='comment:9'></a>Replying to [comment:8 tscrim]:\n> What I am suggesting is refactor the multiplication code for the fin-dim algebras into a finite semigroup (well, really finite magma because the product does not have to be associative). Then we would make a fin-dim algebra to be the algebra of a finite semigroup (magma).\n\n\nThis is for darij specific use case, right? Not all fin dim algebra come from a finite semigroup/magma.\n \n> `@`nthiery I will should have some time before (and I think after but need to double-check) Days 74, and I would be happy to do some coding sprints with you.\n\n\nSounds good!\n\n> PS - How were the Sage-GAP days?\n\n\nIt was good to meet and share with the GAP people. And to have time to focus on one coding sprint!",
    "created_at": "2016-01-24T13:10:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352290",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:9'></a>Replying to [comment:8 tscrim]:
> What I am suggesting is refactor the multiplication code for the fin-dim algebras into a finite semigroup (well, really finite magma because the product does not have to be associative). Then we would make a fin-dim algebra to be the algebra of a finite semigroup (magma).


This is for darij specific use case, right? Not all fin dim algebra come from a finite semigroup/magma.
 
> `@`nthiery I will should have some time before (and I think after but need to double-check) Days 74, and I would be happy to do some coding sprints with you.


Sounds good!

> PS - How were the Sage-GAP days?


It was good to meet and share with the GAP people. And to have time to focus on one coding sprint!



---

archive/issue_comments_352291.json:
```json
{
    "body": "Changing commit from \"99de16fca5c2c66b622a358c4de577f165aa7718\" to \"38529351ae5581559a6a33a6fc6fe825b974ef81\"",
    "created_at": "2016-01-28T05:11:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352291",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "99de16fca5c2c66b622a358c4de577f165aa7718" to "38529351ae5581559a6a33a6fc6fe825b974ef81"



---

archive/issue_comments_352292.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-28T05:11:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352292",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_352293.json:
```json
{
    "body": "<a id='comment:11'></a>I've reviewed the ticket up to `TrivialRepresentation`. However, exposing `self._module` the way I've done it is incompatible with your implementation of `TrivialRepresentation`, and this is a design question I feel is in need of discussion. What do you think is the right way?\n\n1. Unexpose `self._module`, since any method that uses linear algebra on `self._module` can just as well use it on `self`.\n\n2. Set `self._module = self` for a `TrivialRepresentation`.\n\n3. Implement `TrivialRepresentation` using the general `Representation` constructor.\n\nI don't see anything wrong with either of these options, but I am not the one to judge. A caveat with 1 is that coders need to be dissuaded from using `self._module` in their code (and this is a tricky thing to do, because not everyone will have a `TrivialRepresentation` in their doctests). Option 2 might incur endless loops or unwanted memory persistence, but I don't know. Option 3 feels like overkill, but it's the most straightforward thing.\n\nSpeaking of endless loops, do you have an idea why this gives one?\n\n```\nsage: G = groups.permutation.Dihedral(4)\nsage: R = G.regular_representation(left=False)\nsage: x = R.an_element()\nsage: x*x\n```\n\nOh, and one more thing. I think `TrivialRepresentation` might need a `left` option. Even if the action itself doesn't care, future code might (e.g., taking the direct sum of two representations might start off by checking whether both have the same left-right-ness, and tada you've got a pointless error when you try to add a right representation to the trivial one).",
    "created_at": "2016-01-28T05:18:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352293",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:11'></a>I've reviewed the ticket up to `TrivialRepresentation`. However, exposing `self._module` the way I've done it is incompatible with your implementation of `TrivialRepresentation`, and this is a design question I feel is in need of discussion. What do you think is the right way?

1. Unexpose `self._module`, since any method that uses linear algebra on `self._module` can just as well use it on `self`.

2. Set `self._module = self` for a `TrivialRepresentation`.

3. Implement `TrivialRepresentation` using the general `Representation` constructor.

I don't see anything wrong with either of these options, but I am not the one to judge. A caveat with 1 is that coders need to be dissuaded from using `self._module` in their code (and this is a tricky thing to do, because not everyone will have a `TrivialRepresentation` in their doctests). Option 2 might incur endless loops or unwanted memory persistence, but I don't know. Option 3 feels like overkill, but it's the most straightforward thing.

Speaking of endless loops, do you have an idea why this gives one?

```
sage: G = groups.permutation.Dihedral(4)
sage: R = G.regular_representation(left=False)
sage: x = R.an_element()
sage: x*x
```

Oh, and one more thing. I think `TrivialRepresentation` might need a `left` option. Even if the action itself doesn't care, future code might (e.g., taking the direct sum of two representations might start off by checking whether both have the same left-right-ness, and tada you've got a pointless error when you try to add a right representation to the trivial one).



---

archive/issue_comments_352294.json:
```json
{
    "body": "<a id='comment:12'></a>Replying to [comment:11 darij]:\n> I've reviewed the ticket up to `TrivialRepresentation`.\n\n\nThank you for doing the review. (I guess I should review your face semigroup ticket...)\n\n> However, exposing `self._module` the way I've done it is incompatible with your implementation of `TrivialRepresentation`, and this is a design question I feel is in need of discussion. What do you think is the right way?\n> \n> 1. Unexpose `self._module`, since any method that uses linear algebra on `self._module` can just as well use it on `self`.\n> \n> 2. Set `self._module = self` for a `TrivialRepresentation`.\n> \n> 3. Implement `TrivialRepresentation` using the general `Representation` constructor.\n\n\nI would go with 1. I did not expose it because the representation behaves like a module (you better not say something about ducktyping here) and it is there only for internal use. You're getting to one of the reasons why `TrivialRepresentation` is not a subclass of `Representation`. If you really feel that it should be exposed, then I would have `module()` return `self` so there is a consistent API. (Unfortunately I don't think we have the infrastructure in place to setup the necessary coercions.)\n\n> Speaking of endless loops, do you have an idea why this gives one?\n> \n> ```\n> sage: G = groups.permutation.Dihedral(4)\n> sage: R = G.regular_representation(left=False)\n> sage: x = R.an_element()\n> sage: x*x\n> ```\n\n\nNo, and from the code, there does not seem to be a reason why this should happen. (This should result in an error though.) I will investigate this.\n\n> Oh, and one more thing. I think `TrivialRepresentation` might need a `left` option. Even if the action itself doesn't care, future code might (e.g., taking the direct sum of two representations might start off by checking whether both have the same left-right-ness, and tada you've got a pointless error when you try to add a right representation to the trivial one).\n\n\nIf future code cares, then the future code can deal with creating the error/extra complexity. However, we can consider it as simultaneously a right and left representation, so I don't think this would be an issue.\n\nActually, given these recent changes, it reminded me why I had `left_repr`. I actually think `left_repr` is more descriptive, and so we should change all of the `left` to `left_repr`. Your thoughts?",
    "created_at": "2016-01-28T05:55:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352294",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:12'></a>Replying to [comment:11 darij]:
> I've reviewed the ticket up to `TrivialRepresentation`.


Thank you for doing the review. (I guess I should review your face semigroup ticket...)

> However, exposing `self._module` the way I've done it is incompatible with your implementation of `TrivialRepresentation`, and this is a design question I feel is in need of discussion. What do you think is the right way?
> 
> 1. Unexpose `self._module`, since any method that uses linear algebra on `self._module` can just as well use it on `self`.
> 
> 2. Set `self._module = self` for a `TrivialRepresentation`.
> 
> 3. Implement `TrivialRepresentation` using the general `Representation` constructor.


I would go with 1. I did not expose it because the representation behaves like a module (you better not say something about ducktyping here) and it is there only for internal use. You're getting to one of the reasons why `TrivialRepresentation` is not a subclass of `Representation`. If you really feel that it should be exposed, then I would have `module()` return `self` so there is a consistent API. (Unfortunately I don't think we have the infrastructure in place to setup the necessary coercions.)

> Speaking of endless loops, do you have an idea why this gives one?
> 
> ```
> sage: G = groups.permutation.Dihedral(4)
> sage: R = G.regular_representation(left=False)
> sage: x = R.an_element()
> sage: x*x
> ```


No, and from the code, there does not seem to be a reason why this should happen. (This should result in an error though.) I will investigate this.

> Oh, and one more thing. I think `TrivialRepresentation` might need a `left` option. Even if the action itself doesn't care, future code might (e.g., taking the direct sum of two representations might start off by checking whether both have the same left-right-ness, and tada you've got a pointless error when you try to add a right representation to the trivial one).


If future code cares, then the future code can deal with creating the error/extra complexity. However, we can consider it as simultaneously a right and left representation, so I don't think this would be an issue.

Actually, given these recent changes, it reminded me why I had `left_repr`. I actually think `left_repr` is more descriptive, and so we should change all of the `left` to `left_repr`. Your thoughts?



---

archive/issue_comments_352295.json:
```json
{
    "body": "<a id='comment:13'></a>Replying to [comment:12 tscrim]:\n> Replying to [comment:11 darij]:\n> > I've reviewed the ticket up to `TrivialRepresentation`.\n\n> \n> Thank you for doing the review. (I guess I should review your face semigroup ticket...)\n\n\nI think that's already (almost) done, but thank you :)\n\n> I would go with 1. I did not expose it because the representation behaves like a module (you better not say something about ducktyping here) and it is there only for internal use. You're getting to one of the reasons why `TrivialRepresentation` is not a subclass of `Representation`. If you really feel that it should be exposed, then I would have `module()` return `self` so there is a consistent API. (Unfortunately I don't think we have the infrastructure in place to setup the necessary coercions.)\n\n\nWait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.\n\nI have thought about these things again and here are my suggestions:\n\nS1. It is fine for `Representation` to treat `self._module` as an implementation detail that might not get inherited, but please document this in the `init` sourcecode (just a # comment saying that `self._module` might not exist).\n\nS2. Please document in the docstring that the trivial representation is both left and right.\n\nS3. At some point we will need a way to tell if a given representation is left or right. I think this should be a property (not underscored) which is a boolean or `None` (for two-sided). Do you agree?\n\nS4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?\n\n> > Speaking of endless loops, do you have an idea why this gives one?\n> > \n> > ```\n> > sage: G = groups.permutation.Dihedral(4)\n> > sage: R = G.regular_representation(left=False)\n> > sage: x = R.an_element()\n> > sage: x*x\n> > ```\n\n> \n> No, and from the code, there does not seem to be a reason why this should happen. (This should result in an error though.) I will investigate this.\n\n\nYes, it should result in an error, just not in an exceeded recursion limit. Not a bug per se, but hell does it smell fishy. Then again, a quick look at the implementation of coercion in `parent.pyx` convinced me to be amazed at the fact that coercion works at all... (EDIT for clarity: In no way does this need to be solved for a positive review of this ticket; this is really a different story.)\n\n> If future code cares, then the future code can deal with creating the error/extra complexity. However, we can consider it as simultaneously a right and left representation, so I don't think this would be an issue.\n\n\nAgreed -- just wanting it to be explicit.\n\n> Actually, given these recent changes, it reminded me why I had `left_repr`. I actually think `left_repr` is more descriptive, and so we should change all of the `left` to `left_repr`. Your thoughts?\n\n\nI'm fine with `left_repr` or with anything, as long as it is the same keyword everywhere.",
    "created_at": "2016-01-28T17:48:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352295",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:13'></a>Replying to [comment:12 tscrim]:
> Replying to [comment:11 darij]:
> > I've reviewed the ticket up to `TrivialRepresentation`.

> 
> Thank you for doing the review. (I guess I should review your face semigroup ticket...)


I think that's already (almost) done, but thank you :)

> I would go with 1. I did not expose it because the representation behaves like a module (you better not say something about ducktyping here) and it is there only for internal use. You're getting to one of the reasons why `TrivialRepresentation` is not a subclass of `Representation`. If you really feel that it should be exposed, then I would have `module()` return `self` so there is a consistent API. (Unfortunately I don't think we have the infrastructure in place to setup the necessary coercions.)


Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.

I have thought about these things again and here are my suggestions:

S1. It is fine for `Representation` to treat `self._module` as an implementation detail that might not get inherited, but please document this in the `init` sourcecode (just a # comment saying that `self._module` might not exist).

S2. Please document in the docstring that the trivial representation is both left and right.

S3. At some point we will need a way to tell if a given representation is left or right. I think this should be a property (not underscored) which is a boolean or `None` (for two-sided). Do you agree?

S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?

> > Speaking of endless loops, do you have an idea why this gives one?
> > 
> > ```
> > sage: G = groups.permutation.Dihedral(4)
> > sage: R = G.regular_representation(left=False)
> > sage: x = R.an_element()
> > sage: x*x
> > ```

> 
> No, and from the code, there does not seem to be a reason why this should happen. (This should result in an error though.) I will investigate this.


Yes, it should result in an error, just not in an exceeded recursion limit. Not a bug per se, but hell does it smell fishy. Then again, a quick look at the implementation of coercion in `parent.pyx` convinced me to be amazed at the fact that coercion works at all... (EDIT for clarity: In no way does this need to be solved for a positive review of this ticket; this is really a different story.)

> If future code cares, then the future code can deal with creating the error/extra complexity. However, we can consider it as simultaneously a right and left representation, so I don't think this would be an issue.


Agreed -- just wanting it to be explicit.

> Actually, given these recent changes, it reminded me why I had `left_repr`. I actually think `left_repr` is more descriptive, and so we should change all of the `left` to `left_repr`. Your thoughts?


I'm fine with `left_repr` or with anything, as long as it is the same keyword everywhere.



---

archive/issue_comments_352296.json:
```json
{
    "body": "<a id='comment:14'></a>Replying to [comment:13 darij]:\n> Replying to [comment:12 tscrim]:\n> > I would go with 1. I did not expose it because the representation behaves like a module (you better not say something about ducktyping here) and it is there only for internal use. You're getting to one of the reasons why `TrivialRepresentation` is not a subclass of `Representation`. If you really feel that it should be exposed, then I would have `module()` return `self` so there is a consistent API. (Unfortunately I don't think we have the infrastructure in place to setup the necessary coercions.)\n\n> \n> Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.\n\n\nWhy should it? They are completely different implementations. This isn't even ducktyping, it is just about having a common API because all it is really about is just overloading `*`. However, after thinking about it a bit, there is some benefit for having a common base class for `Representation` and `TrivialRepresentation`, but there is no strong reason to force common base classes. (Ideally, this would be handled with a category, but I think we need more discussion and examples to see what the best way to do this will be.)\n\n> I have thought about these things again and here are my suggestions:\n> \n> S1. It is fine for `Representation` to treat `self._module` as an implementation detail that might not get inherited, but please document this in the `init` sourcecode (just a # comment saying that `self._module` might not exist).\n\n\n`self._module` will always exist because `TrivialRepresentation` will not inherit from `Representation`. `Representation` is a slight variant of what is sometimes called a [decorator pattern](https://en.wikipedia.org/wiki/Decorator_pattern), whereas `TrivialRepresentation` is a direct subclass of CFM. As they have very different implementations, there should not be a subclass relationship `Representation` to `TrivialRepresentation`.\n\n> S2. Please document in the docstring that the trivial representation is both left and right.\n\n\nWill do.\n\n> S3. At some point we will need a way to tell if a given representation is left or right. I think this should be a property (not underscored) which is a boolean or `None` (for two-sided). Do you agree?\n\n\nIf anything, this should be a method, not an (hidden) attribute. However, I do agree we need something. Althought AFAIK this is the first time we have a left but not necessarily a right module.\n\n> S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?\n\n\nThis will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.\n\n(I'm waiting for `7.1.beta1` to come out before I make any changes. You know as soon as I bump my Sage to beta0, beta1 will be released...)",
    "created_at": "2016-01-28T20:00:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352296",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:14'></a>Replying to [comment:13 darij]:
> Replying to [comment:12 tscrim]:
> > I would go with 1. I did not expose it because the representation behaves like a module (you better not say something about ducktyping here) and it is there only for internal use. You're getting to one of the reasons why `TrivialRepresentation` is not a subclass of `Representation`. If you really feel that it should be exposed, then I would have `module()` return `self` so there is a consistent API. (Unfortunately I don't think we have the infrastructure in place to setup the necessary coercions.)

> 
> Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.


Why should it? They are completely different implementations. This isn't even ducktyping, it is just about having a common API because all it is really about is just overloading `*`. However, after thinking about it a bit, there is some benefit for having a common base class for `Representation` and `TrivialRepresentation`, but there is no strong reason to force common base classes. (Ideally, this would be handled with a category, but I think we need more discussion and examples to see what the best way to do this will be.)

> I have thought about these things again and here are my suggestions:
> 
> S1. It is fine for `Representation` to treat `self._module` as an implementation detail that might not get inherited, but please document this in the `init` sourcecode (just a # comment saying that `self._module` might not exist).


`self._module` will always exist because `TrivialRepresentation` will not inherit from `Representation`. `Representation` is a slight variant of what is sometimes called a [decorator pattern](https://en.wikipedia.org/wiki/Decorator_pattern), whereas `TrivialRepresentation` is a direct subclass of CFM. As they have very different implementations, there should not be a subclass relationship `Representation` to `TrivialRepresentation`.

> S2. Please document in the docstring that the trivial representation is both left and right.


Will do.

> S3. At some point we will need a way to tell if a given representation is left or right. I think this should be a property (not underscored) which is a boolean or `None` (for two-sided). Do you agree?


If anything, this should be a method, not an (hidden) attribute. However, I do agree we need something. Althought AFAIK this is the first time we have a left but not necessarily a right module.

> S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?


This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.

(I'm waiting for `7.1.beta1` to come out before I make any changes. You know as soon as I bump my Sage to beta0, beta1 will be released...)



---

archive/issue_comments_352297.json:
```json
{
    "body": "<a id='comment:15'></a>Replying to [comment:14 tscrim]:\n> Replying to [comment:13 darij]:\n> > Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.\n\n> \n> Why should it? They are completely different implementations.\n\n\nImplementations yes, but the underlying concepts should be of the same type. One of the next steps will be a direct sum of two representations, for example. You do want to be able to add a regular and a trivial representation, I assume?\n\n> > S3. At some point we will need a way to tell if a given representation is left or right. I think this should be a property (not underscored) which is a boolean or `None` (for two-sided). Do you agree?\n  \n> \n> If anything, this should be a method, not an (hidden) attribute. However, I do agree we need something. Althought AFAIK this is the first time we have a left but not necessarily a right module.\n> \n> > S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?\n  \n> \n> This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.\n\n\nYou multiply all the entries of that `dict` with `sum(scalar.coefficients())`. If this sum is 0, then it's suddenly a `dict` full of zeroes.\n> \n> (I'm waiting for `7.1.beta1` to come out before I make any changes. You know as soon as I bump my Sage to beta0, beta1 will be released...)\n\nI know that feeling :)",
    "created_at": "2016-01-28T20:40:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352297",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:15'></a>Replying to [comment:14 tscrim]:
> Replying to [comment:13 darij]:
> > Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.

> 
> Why should it? They are completely different implementations.


Implementations yes, but the underlying concepts should be of the same type. One of the next steps will be a direct sum of two representations, for example. You do want to be able to add a regular and a trivial representation, I assume?

> > S3. At some point we will need a way to tell if a given representation is left or right. I think this should be a property (not underscored) which is a boolean or `None` (for two-sided). Do you agree?
  
> 
> If anything, this should be a method, not an (hidden) attribute. However, I do agree we need something. Althought AFAIK this is the first time we have a left but not necessarily a right module.
> 
> > S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?
  
> 
> This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.


You multiply all the entries of that `dict` with `sum(scalar.coefficients())`. If this sum is 0, then it's suddenly a `dict` full of zeroes.
> 
> (I'm waiting for `7.1.beta1` to come out before I make any changes. You know as soon as I bump my Sage to beta0, beta1 will be released...)

I know that feeling :)



---

archive/issue_comments_352298.json:
```json
{
    "body": "<a id='comment:16'></a>Replying to [comment:15 darij]:\n> Replying to [comment:14 tscrim]:\n> > Replying to [comment:13 darij]:\n> > > Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.\n\n> > \n> > Why should it? They are completely different implementations.\n\n> \n> Implementations yes, but the underlying concepts should be of the same type. One of the next steps will be a direct sum of two representations, for example. You do want to be able to add a regular and a trivial representation, I assume?\n\n\nThat is more about having a common API. Anyways, `Representation` and `TrivialRepresentation` will have a common ABC, so I think this issue is moot.\n\n> > > S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?\n  \n> > \n> > This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.\n\n> \n> You multiply all the entries of that `dict` with `sum(scalar.coefficients())`. If this sum is 0, then it's suddenly a `dict` full of zeroes.\n\n\n`_from_dict` has an optional argument to check for removing zeros (whose default is `True`). So this isn't an issue.\n\n> > (I'm waiting for `7.1.beta1` to come out before I make any changes. You know as soon as I bump my Sage to beta0, beta1 will be released...)\n\n> I know that feeling :)\n\nIt is just released in fact.",
    "created_at": "2016-01-28T21:48:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352298",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:16'></a>Replying to [comment:15 darij]:
> Replying to [comment:14 tscrim]:
> > Replying to [comment:13 darij]:
> > > Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.

> > 
> > Why should it? They are completely different implementations.

> 
> Implementations yes, but the underlying concepts should be of the same type. One of the next steps will be a direct sum of two representations, for example. You do want to be able to add a regular and a trivial representation, I assume?


That is more about having a common API. Anyways, `Representation` and `TrivialRepresentation` will have a common ABC, so I think this issue is moot.

> > > S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?
  
> > 
> > This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.

> 
> You multiply all the entries of that `dict` with `sum(scalar.coefficients())`. If this sum is 0, then it's suddenly a `dict` full of zeroes.


`_from_dict` has an optional argument to check for removing zeros (whose default is `True`). So this isn't an issue.

> > (I'm waiting for `7.1.beta1` to come out before I make any changes. You know as soon as I bump my Sage to beta0, beta1 will be released...)

> I know that feeling :)

It is just released in fact.



---

archive/issue_comments_352299.json:
```json
{
    "body": "<a id='comment:17'></a>Replying to [comment:16 tscrim]:\n> Replying to [comment:15 darij]:\n> > Replying to [comment:14 tscrim]:\n> > > Replying to [comment:13 darij]:\n> > > > Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.\n\n> > > \n> > > Why should it? They are completely different implementations.\n\n> > \n> > Implementations yes, but the underlying concepts should be of the same type. One of the next steps will be a direct sum of two representations, for example. You do want to be able to add a regular and a trivial representation, I assume?\n\n> \n> That is more about having a common API. Anyways, `Representation` and `TrivialRepresentation` will have a common ABC, so I think this issue is moot.\n\n\nAh, perfect.\n\n> > > > S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?\n  \n> > > \n> > > This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.\n\n> > \n> > You multiply all the entries of that `dict` with `sum(scalar.coefficients())`. If this sum is 0, then it's suddenly a `dict` full of zeroes.\n\n> \n> `_from_dict` has an optional argument to check for removing zeros (whose default is `True`). So this isn't an issue.\n\n\nOh! I forgot the semantics of `_from_dict`; so it's not as low-level as I expected. You are right!",
    "created_at": "2016-01-28T21:50:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352299",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:17'></a>Replying to [comment:16 tscrim]:
> Replying to [comment:15 darij]:
> > Replying to [comment:14 tscrim]:
> > > Replying to [comment:13 darij]:
> > > > Wait, what? `TrivialRepresentation` does not inherit from `Representation`? This I really don't like. Particularly if you don't expose `self._module`, there should be no reason to keep the trivial one out of it.

> > > 
> > > Why should it? They are completely different implementations.

> > 
> > Implementations yes, but the underlying concepts should be of the same type. One of the next steps will be a direct sum of two representations, for example. You do want to be able to add a regular and a trivial representation, I assume?

> 
> That is more about having a common API. Anyways, `Representation` and `TrivialRepresentation` will have a common ABC, so I think this issue is moot.


Ah, perfect.

> > > > S4. In the `_acted_upon_` of `TrivialRepresentation`, does `_from_dict(d)` do the right thing when `d == 0` ?
  
> > > 
> > > This will never happen as `monomial_coefficients` returns a `dict`. However, I do see a potential when acting on the zero element. I will check/doctest this.

> > 
> > You multiply all the entries of that `dict` with `sum(scalar.coefficients())`. If this sum is 0, then it's suddenly a `dict` full of zeroes.

> 
> `_from_dict` has an optional argument to check for removing zeros (whose default is `True`). So this isn't an issue.


Oh! I forgot the semantics of `_from_dict`; so it's not as low-level as I expected. You are right!



---

archive/issue_comments_352300.json:
```json
{
    "body": "<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-29T06:08:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352300",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_352301.json:
```json
{
    "body": "Changing commit from \"38529351ae5581559a6a33a6fc6fe825b974ef81\" to \"446f369a6e1bdaaa94e607db4285353e1a7f5438\"",
    "created_at": "2016-01-29T06:08:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352301",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "38529351ae5581559a6a33a6fc6fe825b974ef81" to "446f369a6e1bdaaa94e607db4285353e1a7f5438"



---

archive/issue_comments_352302.json:
```json
{
    "body": "<a id='comment:19'></a>Taken care of all of the above.\n\nThe `x * x` issue appears with just a combinatorial free module:\n\n```\nsage: C = CombinatorialFreeModule(ZZ, ['a','b'])\nsage: x = C.an_element()\nsage: x * x  # BOOM\n```\nso it is unrelated to this ticket.",
    "created_at": "2016-01-29T06:14:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352302",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:19'></a>Taken care of all of the above.

The `x * x` issue appears with just a combinatorial free module:

```
sage: C = CombinatorialFreeModule(ZZ, ['a','b'])
sage: x = C.an_element()
sage: x * x  # BOOM
```
so it is unrelated to this ticket.



---

archive/issue_comments_352303.json:
```json
{
    "body": "<a id='comment:20'></a>Just a tiny comment: please use side=\"left\" rather than left=True, for consistency with what's done elsewhere (Coxeter groups, cayley graphs, ...).\n\nCheers,",
    "created_at": "2016-01-29T08:45:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352303",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:20'></a>Just a tiny comment: please use side="left" rather than left=True, for consistency with what's done elsewhere (Coxeter groups, cayley graphs, ...).

Cheers,



---

archive/issue_comments_352304.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-29T15:28:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352304",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_352305.json:
```json
{
    "body": "Changing commit from \"446f369a6e1bdaaa94e607db4285353e1a7f5438\" to \"51ae764bac944dcfaf7959000eac6d137ab3f2d4\"",
    "created_at": "2016-01-29T15:28:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352305",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "446f369a6e1bdaaa94e607db4285353e1a7f5438" to "51ae764bac944dcfaf7959000eac6d137ab3f2d4"



---

archive/issue_comments_352306.json:
```json
{
    "body": "<a id='comment:22'></a>Replying to [comment:20 nthiery]:\n> Just a tiny comment: please use side=\"left\" rather than left=True, for consistency with what's done elsewhere (Coxeter groups, cayley graphs, ...).\n\n\nDone. I also added a method to `Representation` exposing the side.",
    "created_at": "2016-01-29T15:29:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352306",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:22'></a>Replying to [comment:20 nthiery]:
> Just a tiny comment: please use side="left" rather than left=True, for consistency with what's done elsewhere (Coxeter groups, cayley graphs, ...).


Done. I also added a method to `Representation` exposing the side.



---

archive/issue_comments_352307.json:
```json
{
    "body": "<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-29T21:36:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352307",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_352308.json:
```json
{
    "body": "Changing commit from \"51ae764bac944dcfaf7959000eac6d137ab3f2d4\" to \"3a89f371c3346f1a6528bb8722570412ad1a50cc\"",
    "created_at": "2016-01-29T21:36:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352308",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "51ae764bac944dcfaf7959000eac6d137ab3f2d4" to "3a89f371c3346f1a6528bb8722570412ad1a50cc"



---

archive/issue_comments_352309.json:
```json
{
    "body": "<a id='comment:24'></a>Shouldn't the `side` method be on the ABC rather than on the implementation? (It might well be an abstract method, but it should be available, at least if we are serious about the ABC.)\n\nAs far as everything else is concerned, this LGTM!\n\n---\nNew commits:\n|                                                                                                                                          |                                |\n|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------|\n|[3a89f37](http://git.sagemath.org/sage.git/commit/?id=3a89f371c3346f1a6528bb8722570412ad1a50cc)|`minor doc improvements, -1 bug`|\n---\nNew commits:",
    "created_at": "2016-01-29T21:36:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352309",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:24'></a>Shouldn't the `side` method be on the ABC rather than on the implementation? (It might well be an abstract method, but it should be available, at least if we are serious about the ABC.)

As far as everything else is concerned, this LGTM!

---
New commits:
|                                                                                                                                          |                                |
|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------|
|[3a89f37](http://git.sagemath.org/sage.git/commit/?id=3a89f371c3346f1a6528bb8722570412ad1a50cc)|`minor doc improvements, -1 bug`|
---
New commits:



---

archive/issue_comments_352310.json:
```json
{
    "body": "Changing commit from \"3a89f371c3346f1a6528bb8722570412ad1a50cc\" to \"3e6a1f6f2b5090799cc0763fc54aef05849c357b\"",
    "created_at": "2016-01-30T02:10:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352310",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "3a89f371c3346f1a6528bb8722570412ad1a50cc" to "3e6a1f6f2b5090799cc0763fc54aef05849c357b"



---

archive/issue_comments_352311.json:
```json
{
    "body": "<a id='comment:25'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-30T02:10:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352311",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:25'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_352312.json:
```json
{
    "body": "<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-30T02:13:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352312",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_352313.json:
```json
{
    "body": "Changing commit from \"3e6a1f6f2b5090799cc0763fc54aef05849c357b\" to \"f8b1e3040199be23644dc67c4236018bf6a89b8f\"",
    "created_at": "2016-01-30T02:13:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352313",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "3e6a1f6f2b5090799cc0763fc54aef05849c357b" to "f8b1e3040199be23644dc67c4236018bf6a89b8f"



---

archive/issue_comments_352314.json:
```json
{
    "body": "<a id='comment:27'></a>Thank you! The code now LGTM. Does it LGTY?",
    "created_at": "2016-01-30T02:14:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352314",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:27'></a>Thank you! The code now LGTM. Does it LGTY?



---

archive/issue_comments_352315.json:
```json
{
    "body": "Changing reviewer from \"\" to \"Darij Grinberg\"",
    "created_at": "2016-01-30T02:14:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352315",
    "user": "https://github.com/darijgr"
}
```

Changing reviewer from "" to "Darij Grinberg"



---

archive/issue_comments_352316.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-01-30T02:14:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352316",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_352317.json:
```json
{
    "body": "<a id='comment:28'></a>Yes. Thank you for doing the review.",
    "created_at": "2016-01-30T02:14:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352317",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:28'></a>Yes. Thank you for doing the review.



---

archive/issue_comments_352318.json:
```json
{
    "body": "<a id='comment:29'></a>Thanks for one of the most useful 500-line patches Sage has!",
    "created_at": "2016-01-30T02:16:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352318",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:29'></a>Thanks for one of the most useful 500-line patches Sage has!



---

archive/issue_comments_352319.json:
```json
{
    "body": "Changing branch from \"public/representations/basic_implementation-19613\" to \"f8b1e3040199be23644dc67c4236018bf6a89b8f\"",
    "created_at": "2016-01-30T21:04:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352319",
    "user": "https://github.com/vbraun"
}
```

Changing branch from "public/representations/basic_implementation-19613" to "f8b1e3040199be23644dc67c4236018bf6a89b8f"



---

archive/issue_events_053922.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-01-30T21:04:55Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/19613#event-53922"
}
```



---

archive/issue_comments_352320.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-01-30T21:04:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19613",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19613#issuecomment-352320",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
