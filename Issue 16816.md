# Issue 16816: Add function for direct sum of posets

Issue created by migration from Trac.

Original creator: jmantysalo

Original creation time: 2014-09-27 14:41:42

CC:  ncohen

Sage has no function for direct sum of posets. What kind of function it should be?

Let's say that poset `P` has elements `a` and `b`, `Q` has elements `c` and `d`. Then sum on P and Q could have elements

1) a,b,c,d. Function would check that there are no common elements.
2) (1,a),(1,b),(2,c),(2,c). Optional parameter would change first element of tuples.
3) 0,1,2,3. Function would just make poset isomorphic to P+Q with integer elements.

Now, it would be nice to have also sum of arbitrary number of posets. So function could be something like

`P.direct_sum(Q)` (case 1 as default?)

`P.direct_sum(Q, labeling='default')` (case 2 / default)

`P.direct_sum(Q, labeling=lambda n: chr(ord('a')+n))` (case 2 / non-default)

`P.direct_sum(Q, labeling='plain')` (case 3)

and if possible, accept something like

`P1.direct_sum(P2, P3, P4, labeling=...)`

Does this sound reasonable?


---

Comment by jmantysalo created at 2014-09-27 17:37:38

Something like this:


```
def sum_of_posets(self, other, labeling=None):
    if not hasattr(other,'hasse_diagram'):
        raise ValueError('The input is not a finite poset.')
    if labeling==None:
        # Check for duplicates. Slow, just for an example.
        for i in self.list():
            for j in other.list():
                if i==j:
                    raise ValueError('What should be type of this error?')
        elements=self.list()+other.list()
        coverings=self.cover_relations()+other.cover_relations()
        return Poset( (elements, coverings) )
    if labeling=='linear':
        return sum_of_posets(self.canonical_label(), other.canonical_label().relabel(lambda x: x+self.cardinality()))
    if type(labeling) is tuple and len(labeling)==2:
        return Poset( ([(labeling[0],x) for x in self.list()]+[(labeling[1],x) for x in other.list()], [[(labeling[0],x[0]),(labeling[0],x[1])] for x in self.cover_relations()]+[[(labeling[1],x[0]),(labeling[1],x[1])] for x in other.cover_relations()]) )
    raise ValueError("Labeling must be 'linear' or tuple of two elements")
```


For testing try for example


```
P1=Posets.PentagonPoset(facade=True).relabel(lambda x: x+10)
P2=Poset({0:[1,2],1:[3,4]})

sum_of_posets(P1, P2, labeling=('a', 'b')).show(figsize=4, vertex_size=1000)
sum_of_posets(P1, P2, labeling='linear').show(figsize=4, vertex_size=1000)
sum_of_posets(P1, P2).show(figsize=4, vertex_size=1000)
sum_of_posets(P1, P1)
```


Another question: should ordinal sum be part of same function with keyword like `type='ordinal'` or distinct function?


---

Comment by ncohen created at 2014-09-29 08:34:18

Hello !

We already have a `Graph.disjoint_union` that accepts this kind of parameter. If you want to have a similar feature at `Poset` level I suggest that you only expose this function. The code would just be :

```
return Poset(self.hasse_diagram().disjoint_union(other.hasse_diagram()))
```


Then, if you want to have more ways to tune the result through the points' name, the best would be to change the Graph function itself, which would consequently give the same feature to the Poset function.

Nathann


---

Comment by jmantysalo created at 2014-09-29 08:45:22

Replying to [comment:3 ncohen]:

> Then, if you want to have more ways to tune the result through the points' name, the best would be to change the Graph function itself, which would consequently give the same feature to the Poset function.

True. I must learn functions provided by (di)graphs and expand them if necessary.

> We already have a `Graph.disjoint_union` that accepts this kind of parameter. If you want to have a similar feature at `Poset` level I suggest that you only expose this function. The code would just be :
> {{{
> return Poset(self.hasse_diagram().disjoint_union(other.hasse_diagram()))
> }}}

This breaks at least with


```
P1=Posets.PentagonPoset(facade=True)
P1=Posets.PentagonPoset(facade=False)
P=Poset(P1.hasse_diagram().disjoint_union(P2.hasse_diagram()))
P.show()
```


But I'll add checks as necessary. I guess it is OK to simply refuce summing up facade and non-facade poset.


---

Comment by ncohen created at 2014-09-29 08:47:31

Yo !

> This breaks at least with
> 
> {{{
> P1=Posets.PentagonPoset(facade=True)
> P1=Posets.PentagonPoset(facade=False)
> P=Poset(P1.hasse_diagram().disjoint_union(P2.hasse_diagram()))
> P.show()
> }}}
> 
> But I'll add checks as necessary. I guess it is OK to simply refuce summing up facade and non-facade poset.

It works on my computer: beware, in your code both posets are named P1. So P2 is defined only on your computer.

Nathann


---

Comment by jmantysalo created at 2014-09-29 10:52:56

Function could then be something like


```
def direct_sum(self, other, relabel=None):
    if not hasattr(other, 'hasse_diagram'):
        raise ValueError('The input is not a finite poset.')
    if relabel == None:
        elements=self.list()+other.list()
        if len(elements) != len(set(elements)):
            raise ValueError("Posets contain equal elements. Try relabel='pairs' or relabel='linear'.")
        return Poset(self.hasse_diagram().union(other.hasse_diagram()))
    if relabel == 'pairs':
        return Poset(self.hasse_diagram().disjoint_union(other.hasse_diagram()))
    if relabel == 'linear':
        return Poset(self._hasse_diagram.disjoint_union(other.hasse_diagram(), verbose_relabel=False))
```


1) Why I must say `other.hasse_diagram()` on last line, `other._hasse_diagram` should work. Again some copy-immutable -thing?

2) What should be the name of parameter and values for it? `verbose_relabel` to be consistent with graphs? Default value for it?


---

Comment by ncohen created at 2014-09-29 11:43:36

Hello !

> Function could then be something like

1) Besides checking that `other` is a !Poset, I do not understand why this function should do anything else than calling the graph routine. And it would be that routine's job to check that the input is correct.

2) I believe that the default behaviour should be "pairs", because it is the behaviour that keeps the most information. And people can force `relabel="integers"` if they like.

> 1) Why I must say `other.hasse_diagram()` on last line, `other._hasse_diagram` should work. Again some copy-immutable -thing?

Because of that:


```
sage: Poset(DiGraph({"a":["b"]})).hasse_diagram().vertices()
['a', 'b']
sage: Poset(DiGraph({"a":["b"]}))._hasse_diagram.vertices()  
[0, 1]
```


> 2) What should be the name of parameter and values for it? `verbose_relabel` to be consistent with graphs? Default value for it?

I don't really know... `verbose_relabel` in the !Graph function is not a very good name, so perhaps we should change it. What about `Poset.relabel(labels="pairs")` by default, and `labels="integers"` otherwise ? And we could update the graph function with it. That also involves deprecating the old parameter name.

Nathann


---

Comment by jmantysalo created at 2014-09-29 12:19:03

Then it would be like


```
def direct_sum(self, other, labels='pairs'):
    """
    Docs here...
    
    Examples: ...

    Now we want literally direct sum with elements untouched:
    sage: P1=Poset({'a':['b']})
    sage: P2=Poset({'c':['d']})
    sage: P=P1.direct_sum(P2).relabel(lambda x: x[1])
    sage: P.list()
    ['a', 'b', 'c', 'd']
    """
    if not hasattr(other, 'hasse_diagram'):
        raise ValueError('The input is not a finite poset.')
    if labels == 'pairs':
        return Poset(self.hasse_diagram().disjoint_union(other.hasse_diagram()))
    if labels == 'integers':
        return Poset(self.hasse_diagram().disjoint_union(other.hasse_diagram(), verbose_relabel=False))
```


E: And of course throw ValueError if labels not in ['pairs', 'integers']


---

Comment by ncohen created at 2014-09-29 13:55:24

It could even be 

```
def direct_sum(self, other, labels='pairs'):
    if not hasattr(other, 'hasse_diagram'):
        raise ValueError('The input is not a finite poset.')
    return Poset(self.hasse_diagram().disjoint_union(other.hasse_diagram(), labels=labels))
```


Of course right now `Graph.disjoint_union` has no `labels` argument, but we have something called `sage.misc.decorators.rename_keyword` precisely for this reason (to change the name of an argument and handle the deprecation warnings). And then the graph function would understand this labels argument as it is clearer anyway.

The thing is that checking the value of the keyword should be done only once. Preferably in the graph method.

Nathann


---

Comment by jmantysalo created at 2014-09-29 14:32:03

Replying to [comment:9 ncohen]:

> It could even be 
> {{{
> def direct_sum(self, other, labels='pairs'):
>     if not hasattr(other, 'hasse_diagram'):
>         raise ValueError('The input is not a finite poset.')
>     return Poset(self.hasse_diagram().disjoint_union(other.hasse_diagram(), labels=labels))
> }}}
> 
> Of course right now `Graph.disjoint_union` has no `labels` argument, but we have something called `sage.misc.decorators.rename_keyword` precisely for this reason (to change the name of an argument and handle the deprecation warnings). And then the graph function would understand this labels argument as it is clearer anyway.

But on documentation it seems that `rename_keyword` is only able to change name of argument. Here we should also change value from `True` to `pairs` and from `False` to `integers`.


> The thing is that checking the value of the keyword should be done only once. Preferably in the graph method.

Sounds reasonable.

Other things: Enumerative Combinatorics by Richard P. Stanley uses "disjoint union" as preferable name. It is also used on graphs, so it is probably best to use here also.

I'll make some kind of commit just to show what I'm now thinking.


---

Comment by ncohen created at 2014-09-29 14:34:47

Yo !

> But on documentation it seems that `rename_keyword` is only able to change name of argument. Here we should also change value from `True` to `pairs` and from `False` to `integers`.

Oh. That's right. Then the deprecation will have to be done manually `^^;`

> Other things: Enumerative Combinatorics by Richard P. Stanley uses "disjoint union" as preferable name. It is also used on graphs, so it is probably best to use here also.

+1

Nathann


---

Comment by jmantysalo created at 2014-09-29 14:45:16

Replying to [comment:11 ncohen]:

> > But on documentation it seems that `rename_keyword` is only able to change name of argument. Here we should also change value from `True` to `pairs` and from `False` to `integers`.
> 
> Oh. That's right. Then the deprecation will have to be done manually `^^;`

How? http://www.sagemath.org/doc/developer/coding_in_python.html#deprecation does not tell.

----
New commits:


---

Comment by ncohen created at 2014-09-29 15:38:14

> How? http://www.sagemath.org/doc/developer/coding_in_python.html#deprecation does not tell.

Welll...


```
def disjoint_union(self,other,labels="pairs",verbose_relabel=None)
    if verbose_relabel is not None:
        deprecation(ticket_number, message)
        if verbose_relabel:
            labels="pairs"
        else:
            labels="integers"
    <do whatever you want considering 'labels' only>    
```


Nathann


---

Comment by git created at 2014-09-29 19:37:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2014-09-29 19:44:26

Done deprecation. (But `ordinal_sum` is not ready.)

There is a (mostly theoretical, i hope) problem. What if somebody says just `.disjoint_union(G, False)`?


---

Comment by git created at 2014-09-30 06:40:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-09-30 07:54:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2014-09-30 07:57:35

Changing status from new to needs_review.


---

Comment by jmantysalo created at 2014-09-30 07:57:35

Works. But how to check if class of P is meet- or join-semilattice without ugly code like this?


---

Comment by ncohen created at 2014-09-30 08:45:32

Yo !
> Done deprecation.

Thanks.

> There is a (mostly theoretical, i hope) problem. What if somebody says just `.disjoint_union(G, False)`?

If that worries you, just add the new keyword *after* the old one in the function's definition.

Nathann


---

Comment by ncohen created at 2014-09-30 08:55:24

> Works. But how to check if class of P is meet- or join-semilattice without ugly code like this?

I am not sure that you can. The way you do it is wrong, however, for when you do `type(other) == type(MeetSemilattice({}))` you create a semilattice object for nothing. What you need is the 'isinstance' Python function.

Then you will probably have to do something like that:


```
if isinstance(self, LatticePoset) and isinstance(other, LatticePoset):
   return a_lattice
elif isinstance(self, MeetSemilattice) and isinstance(other, MeetSemilattice):
   return a_join_semilattice
elif isinstance(self, JoinSemilattice) and isinstance(other, JoinSemilattice):
   return a_join_semilattice
else:
   return a_poset
```


The 'if' will execute a bit more code than in your layout, but considering the operations involved here we do not care at all, the speed loss is nonexistent. And it is *much* clearer to read.

Nathann


---

Comment by ncohen created at 2014-09-30 09:16:02

Changing status from needs_review to needs_work.


---

Comment by ncohen created at 2014-09-30 09:16:02

Review of your branch in its current state:

1) Lines are 100 characters long: we try to keep it 80characters max

2) It may not be visible to you with the text editor you use, but the lines you skipped are actually filled with spaces.
http://programmers.stackexchange.com/questions/121555/why-is-trailing-whitespace-a-big-deal

3) Please remove those `\` at the end of the lines in the documentation. If the doc does not build properly, it is because this is incorrect

```
INPUT:

    - a very long
    line of doc
```


But this will work:


```
INPUT:

    - a very long
      line of doc
```


Sphinx (the software that builds the doc) is not very pleasant software to work with.

3) I usually write `If ``labels='pairs'``` instead of `If labels='pairs'` in the doc because it is actual Python code, but it is probably up to you. Same for mathematical things like ``(0,x)``.

4) The doc of ordinal sum claims that it returns a lattice. It does not.

5) What about an "elif" ?


```
        else:
            if labels != 'pairs':
```


6) please use `isinstance` instead of `type` or `in LatticePosets()`. The latter is related to categories: it is probably safe to use by itself but it is a bit weird to see some calls to 'type' and then category queries.

7) It is a bit weird to see that the elements labelled with 1 are smaller than the elements labelled with 0:


```
sage: p1=posets.ChainPoset(1)                            
sage: p1.ordinal_sum(p1).is_greater_than((0,0),(1,0))
True
sage: p1.ordinal_sum(p1).is_greater_than((1,0),(0,0))
False
```


8) The description of "labels" is written in a slightly incorrect english `^^;`

Nathann


---

Comment by jmantysalo created at 2014-09-30 09:17:30

Replying to [comment:20 ncohen]:

> > There is a (mostly theoretical, i hope) problem. What if somebody says just `.disjoint_union(G, False)`?
> 
> If that worries you, just add the new keyword *after* the old one in the function's definition.

But then one cannot say `.disjoint_union(G, 'integers')`. Maybe I don't worry that much.

As for another post: After `x=42` for example `isinstance(x, LatticePosets)` says `False`, but `isinstance(x, LatticePoset)` gives error message.


---

Comment by ncohen created at 2014-09-30 09:26:26

> But then one cannot say `.disjoint_union(G, 'integers')`. Maybe I don't worry that much.

I think you worry too much, but if you just need to be soothed then I would say that it is better this way: some people may be expected to already use `.disjoint_union(G,True)` while nobody is using `.disjoint_union(G,'pairs')` are you are creating the syntax.

> As for another post: After `x=42` for example `isinstance(x, LatticePosets)` says `False`, but `isinstance(x, LatticePoset)` gives error message.

That's because the combinat guys cannot be trusted to implement anything reliably.

The error message tells you that `LatticePoset` is not a class, and indeed it is a function. `LatticePoset??` tells you that it returns `FiniteLatticePoset` objects, and if you want to know where to find this class, it is defined there:

```
sage: import_statements("FiniteLatticePoset")
from sage.combinat.posets.lattices import FiniteLatticePoset
```


then:

```
sage: from sage.combinat.posets.lattices import FiniteLatticePoset
sage: x=42
sage: isinstance(x,FiniteLatticePoset)                                         
False
```


Nathann


---

Comment by git created at 2014-09-30 10:34:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2014-09-30 10:41:30

1-3a: Done `egrep '.{80}'` and `egrep ' $'`, corrected.

3b, 5-6) I did as you suggested. I'll unite style when doing The Grand Poset Documentation Polishing.

4) I don't understand. If you input lattices to ordinal sum, you get lattices.

7) Which one is logical for A.ordinal_sum(B): to have "A up and B down" or "B up"? I don't know.

8) I'm quite sure about that. But how?


---

Comment by ncohen created at 2014-09-30 11:11:03

Hello !

> 4) I don't understand. If you input lattices to ordinal sum, you get lattices.

I am an idiot, sorry. I misread the doc.

> 7) Which one is logical for A.ordinal_sum(B): to have "A up and B down" or "B up"? I don't know.

This I do not know. But I would have expected the set of points `(1,x)` to be greater than the ones labelled with `(0,x)`

> 8) I'm quite sure about that. But how?

Ask the guy in your office (if any) to read it, and if not I will do it before setting the branch to `positive_review`.

Nathann


---

Comment by jmantysalo created at 2014-09-30 13:20:38

Replying to [comment:27 ncohen]:

> > 7) Which one is logical for A.ordinal_sum(B): to have "A up and B down" or "B up"? I don't know.
> 
> This I do not know. But I would have expected the set of points `(1,x)` to be greater than the ones labelled with `(0,x)`

You are right on that. On the other hand, somehow for `A.something(B)` it sounds natural to have `(0,x)` be element of A and `(1,y)` be element of B. From that I can deduce that `A.ordinal_sum(B)` should have elements of B of on "up" and elements of A on "down".

> > 8) I'm quite sure about that. But how?
> 
> Ask the guy in your office (if any) to read it, and if not I will do it before setting the branch to `positive_review`.

Done this. I'll continue when he replies.


---

Comment by git created at 2014-10-01 07:25:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2014-10-01 07:27:47

Proofreader didn't found problems, so I copied explanation from graphs. Also changed order of ordinal_sum.


---

Comment by jmantysalo created at 2014-10-01 07:27:47

Changing status from needs_work to needs_review.


---

Comment by ncohen created at 2014-10-01 08:49:07

Hellooooo !

Here is a commit on top of yours. Set the ticket to `positive_review` if you agree with it:

1) some english (has->have) and some commas
2) Rewrote '0,v' as ```(0,v)``` so that it appears as code in the doc. As you also wrote 'integers', it may have led to believe that '0,v' is a string.
3) Changes like that

```diff
-        if isinstance(self, FiniteMeetSemilattice) and \
-        isinstance(other, FiniteMeetSemilattice):
+        if (isinstance(self, FiniteMeetSemilattice) and
+            isinstance(other, FiniteMeetSemilattice)):
```

  code is easier to read when everything is aligned vertically.

4) Entries in the INPUT section should appear in the same order as the arguments that the function accepts. So I reversed the order of `verbose_relabel` and `labels`.

5) The tests did not pass in the graph/ folder because of function `join`. So I did to it what you had already done to `disjoint_union` and deprecated the old flag.

Nathann
----
New commits:


---

Comment by jmantysalo created at 2014-10-01 10:01:58

Changing status from needs_review to positive_review.


---

Comment by jmantysalo created at 2014-10-01 10:01:58

Seems good.


---

Comment by vbraun created at 2014-10-15 11:57:42

author, reviewer name


---

Comment by vbraun created at 2014-10-15 11:57:42

Changing status from positive_review to needs_work.


---

Comment by ncohen created at 2014-10-15 12:00:16

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2014-10-15 18:15:25

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2014-10-15 18:15:25

Merge conflict, probably with #16998


---

Comment by jmantysalo created at 2014-10-16 15:40:32

Stupid question, but how to see the conflict, and how to resolve? Checkout newest beta, make changes, and then try committing again?


---

Comment by vbraun created at 2014-10-16 15:47:28

#16998 is not in any released beta. The easiest solution is to wait for 6.4.beta7. You can also merge #16998 into your own branch and fix the conflict there.


---

Comment by git created at 2014-11-04 14:16:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-11-04 14:47:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2014-11-04 14:47:59

Now it seems to work.


---

Comment by jmantysalo created at 2014-11-04 14:47:59

Changing status from needs_work to needs_review.


---

Comment by ncohen created at 2014-11-04 15:49:28

Some doctests are broken

```
sage -t --long src/sage/combinat/cluster_algebra_quiver/quiver.py  # 1 doctest failed
sage -t --long src/sage/combinat/cluster_algebra_quiver/cluster_seed.py  # 1 doctest failed
sage -t --long src/sage/combinat/cluster_algebra_quiver/quiver_mutation_type.py  # 1 doctest failed
```


It is a bit painful to work on those classes because they are used in unexpected places and you don't know where unless you test all of Sage `:-/`

Nathann


---

Comment by git created at 2014-11-04 20:42:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2014-11-04 22:05:01

Goooooooooooooooooood to go !

Nathann


---

Comment by ncohen created at 2014-11-04 22:05:01

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-11-15 16:22:29

Resolution: fixed
