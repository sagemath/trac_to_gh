# Issue 16532: Conversion RR -> QQ wrong for exact integers

Issue created by migration from https://trac.sagemath.org/ticket/16769

Original creator: jdemeyer

Original creation time: 2014-08-06 08:12:24

This real number can be exactly represented by the integer (and also rational) `2^54`, so this is off by one:

```
sage: QQ(RR(2^54))
18014398509481983
```


The underlying function called by `QQ()` is `simplest_rational`:

```
sage: RR(2^54).simplest_rational()
18014398509481983
```



---

Comment by ajagekar.akshay created at 2016-02-06 17:48:44

` RR(2^54) ` is an exact integer although not an instance of `Integer` here. Conversion of `RealNumber` to `Rational` should yield its integral value. What if we check whether `RR(2^54)` or any `RealNumber` in general is an exact integer before returning it as `Rational` ?


---

Comment by jdemeyer created at 2016-02-06 20:24:11

Replying to [comment:3 ajagekar.akshay]:
> ` RR(2^54) ` is an exact integer although not an instance of `Integer` here. Conversion of `RealNumber` to `Rational` should yield its integral value. What if we check whether `RR(2^54)` or any `RealNumber` in general is an exact integer before returning it as `Rational` ?

That would solve this particular case but I'm doubting if that is general enough.


---

Comment by ajagekar.akshay created at 2016-02-07 07:11:13

Replying to [comment:4 jdemeyer]:
> Replying to [comment:3 ajagekar.akshay]:
> > ` RR(2^54) ` is an exact integer although not an instance of `Integer` here. Conversion of `RealNumber` to `Rational` should yield its integral value. What if we check whether `RR(2^54)` or any `RealNumber` in general is an exact integer before returning it as `Rational` ?
> 
> That would solve this particular case but I'm doubting if that is general enough.
Can you give some examples where this will not work ?


---

Comment by nbruin created at 2016-02-07 22:11:46

Any element of RR of absolute value at least 2<sup>52</sup> can be expressed "exactly" as an integer:

```
sage: a=RR(2^52)
sage: s,m,e=a.sign_mantissa_exponent()
sage: s,m,e
(1, 4503599627370496, 0)
sage: s*m*2^e == a
True
```

simply because `e` will be non-negative for such numbers.
Indeed, any float can be expressed exactly as a rational number: it's the number `s*m*2^e` that is used internally. The reason why we're not using that is basically this:

```
sage: a=RR(1/3)
sage: s,m,e=a.sign_mantissa_exponent()
sage: s*m*2^e
6004799503160661/18014398509481984
```

It's much nicer to get `1/3` back.

Indeed, the definition of "simplest rational" doesn't seem so useful anymore by the time you enter the range where the denominator is guaranteed to be 1. However, depending on getting an exact number back after going through RR is almost certainly a bug somewhere. So I don't think we should go out of our way to guarantee it. If you absolutely want access to the internal representation, there's `sign_mantissa_exponent` anyway.

The key is, the map `ZZ->RR` is not injective. So any section in the other direction is not going to compose to the identity on `ZZ`. It's basically an implementation detail that `ZZ(2^54)` maps to an element in `RR` that internally is represented by something that amounts to exactly that integer.
