# Issue 24702: solve should not convert floating point to rationals when solving

archive/issues_024702.json:
```json
{
    "body": "CC:  tmonteil rws\n\nThe following (obtained on 8.2.beta6) is very bad\n\n```\nsage: solve(1.0 * x^2 - 1.5*x + 2.0, x)\n[x == -1/4*I*sqrt(23) + 3/4, x == 1/4*I*sqrt(23) + 3/4]\n```\n\nThe input is an equation with floating point numbers (likely to be approximations). The answer obtained are exact symbolic expressions.\n\nIssue created by migration from https://trac.sagemath.org/ticket/24939\n\n",
    "created_at": "2018-03-10T09:56:22Z",
    "labels": [
        "basic arithmetic",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.2",
    "title": "solve should not convert floating point to rationals when solving",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/24702",
    "user": "vdelecroix"
}
```
CC:  tmonteil rws

The following (obtained on 8.2.beta6) is very bad

```
sage: solve(1.0 * x^2 - 1.5*x + 2.0, x)
[x == -1/4*I*sqrt(23) + 3/4, x == 1/4*I*sqrt(23) + 3/4]
```

The input is an equation with floating point numbers (likely to be approximations). The answer obtained are exact symbolic expressions.

Issue created by migration from https://trac.sagemath.org/ticket/24939





---

archive/issue_comments_346753.json:
```json
{
    "body": "We are following Maxima's lead here:\n\n```\n(%i3) solve(1.0 * x^2 - 1.5*x + 2.0, x);\n\nrat: replaced 2.0 by 2/1 = 2.0\n\nrat: replaced -1.5 by -3/2 = -1.5\n\nrat: replaced 1.0 by 1/1 = 1.0\n                        sqrt(23) %i - 3      sqrt(23) %i + 3\n(%o3)            [x = - ---------------, x = ---------------]\n                               4                    4\n```\n\nNote that our documentation states: `Whenever possible, answers will be symbolic, but with systems of equations, at times approximations will be given by Maxima, due to the underlying algorithm`.\n\nThe workaround would be to use SymPy:\n\n```\nsage: solve(1.0 * x^2 - 1.5*x + 2.0, x, algorithm='sympy')\n[x == (0.750000000000000 - 1.19895788082818*I),\n x == (0.750000000000000 + 1.19895788082818*I)]\nsage: solve(1.13157771r * x^2 - 1.2241351312r*x + 2.0000401231r, x, algorithm='s\n....: ympy')\n[x == (0.540897509902347 - 1.21445837087478*I),\n x == (0.540897509902347 + 1.21445837087478*I)]\n```\n",
    "created_at": "2018-03-10T13:52:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346753",
    "user": "rws"
}
```

We are following Maxima's lead here:

```
(%i3) solve(1.0 * x^2 - 1.5*x + 2.0, x);

rat: replaced 2.0 by 2/1 = 2.0

rat: replaced -1.5 by -3/2 = -1.5

rat: replaced 1.0 by 1/1 = 1.0
                        sqrt(23) %i - 3      sqrt(23) %i + 3
(%o3)            [x = - ---------------, x = ---------------]
                               4                    4
```

Note that our documentation states: `Whenever possible, answers will be symbolic, but with systems of equations, at times approximations will be given by Maxima, due to the underlying algorithm`.

The workaround would be to use SymPy:

```
sage: solve(1.0 * x^2 - 1.5*x + 2.0, x, algorithm='sympy')
[x == (0.750000000000000 - 1.19895788082818*I),
 x == (0.750000000000000 + 1.19895788082818*I)]
sage: solve(1.13157771r * x^2 - 1.2241351312r*x + 2.0000401231r, x, algorithm='s
....: ympy')
[x == (0.540897509902347 - 1.21445837087478*I),
 x == (0.540897509902347 + 1.21445837087478*I)]
```




---

archive/issue_comments_346754.json:
```json
{
    "body": "Changing priority from major to minor.",
    "created_at": "2018-03-10T13:52:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346754",
    "user": "rws"
}
```

Changing priority from major to minor.



---

archive/issue_comments_346755.json:
```json
{
    "body": "Replying to [comment:2 rws]:\n> We are following Maxima's lead here:\n> {{{\n> <SNIP>\n> }}}\n> Note that our documentation states: `Whenever possible, answers will be symbolic, but with systems of equations, at times approximations will be given by Maxima, due to the underlying algorithm`.\n\nThough it make no sense in the present situation! And the meaning of \"symbolic\" is anyway very vague.\n\n> The workaround would be to use SymPy:\n> {{{\n> <SNIP>\n> }}}\n\nMuch better :-)",
    "created_at": "2018-03-10T13:55:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346755",
    "user": "vdelecroix"
}
```

Replying to [comment:2 rws]:
> We are following Maxima's lead here:
> {{{
> <SNIP>
> }}}
> Note that our documentation states: `Whenever possible, answers will be symbolic, but with systems of equations, at times approximations will be given by Maxima, due to the underlying algorithm`.

Though it make no sense in the present situation! And the meaning of "symbolic" is anyway very vague.

> The workaround would be to use SymPy:
> {{{
> <SNIP>
> }}}

Much better :-)



---

archive/issue_comments_346756.json:
```json
{
    "body": "Finally, see polynomial_element.pyx the roots() member where I inserted fast code that avoids calling Maxima for degree 2. I would be interested in taking over solving every polynomial that's possible in Pynac if I had support for it. It would make QQbar faster, because QQbar uses that code in roots() too.",
    "created_at": "2018-03-10T13:59:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346756",
    "user": "rws"
}
```

Finally, see polynomial_element.pyx the roots() member where I inserted fast code that avoids calling Maxima for degree 2. I would be interested in taking over solving every polynomial that's possible in Pynac if I had support for it. It would make QQbar faster, because QQbar uses that code in roots() too.



---

archive/issue_comments_346757.json:
```json
{
    "body": "Replying to [comment:4 rws]:\n> Finally, see polynomial_element.pyx the roots() member where I inserted fast code that avoids calling Maxima for degree 2. I would be interested in taking over solving every polynomial that's possible in Pynac if I had support for it. It would make QQbar faster, because QQbar uses that code in roots() too.\n\nThis code in `polynomial_element.pyx` is numerically unstable. You should not try to reinvent the wheel here\n\n```\nsage: coeffs = [85.37r, -59.22r, 10.27r]\nsage: RDFx = RDF['x']\nsage: pRDF = RDFx(coeffs)\nsage: r1, r2 = pRDF.roots(multiplicities=False)\nsage: coeffs[2] * r1^2 + coeffs[1] * r1 + coeffs[0]\n0.0\n```\n\nthe same with SR\n\n```\nsage: coeffs = [85.37r, -59.22r, 10.27r]\nsage: SRx = SR['x']\nsage: pSR = SRx(coeffs)\nsage: r1, r2 = pSR.roots(multiplicities=False)\nsage: coeffs[2] * r1^2 + coeffs[1] * r1 + coeffs[0]\n1.4210854715202004e-14\n```\n\n\nMoreover having `import SR` any time `roots` is called is slowing down everything and is a very bad practice. You should have used the special method `_roots_univariate_polynomial` that has to be implemented directly into the ring. See #24942.",
    "created_at": "2018-03-10T15:17:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346757",
    "user": "vdelecroix"
}
```

Replying to [comment:4 rws]:
> Finally, see polynomial_element.pyx the roots() member where I inserted fast code that avoids calling Maxima for degree 2. I would be interested in taking over solving every polynomial that's possible in Pynac if I had support for it. It would make QQbar faster, because QQbar uses that code in roots() too.

This code in `polynomial_element.pyx` is numerically unstable. You should not try to reinvent the wheel here

```
sage: coeffs = [85.37r, -59.22r, 10.27r]
sage: RDFx = RDF['x']
sage: pRDF = RDFx(coeffs)
sage: r1, r2 = pRDF.roots(multiplicities=False)
sage: coeffs[2] * r1^2 + coeffs[1] * r1 + coeffs[0]
0.0
```

the same with SR

```
sage: coeffs = [85.37r, -59.22r, 10.27r]
sage: SRx = SR['x']
sage: pSR = SRx(coeffs)
sage: r1, r2 = pSR.roots(multiplicities=False)
sage: coeffs[2] * r1^2 + coeffs[1] * r1 + coeffs[0]
1.4210854715202004e-14
```


Moreover having `import SR` any time `roots` is called is slowing down everything and is a very bad practice. You should have used the special method `_roots_univariate_polynomial` that has to be implemented directly into the ring. See #24942.



---

archive/issue_comments_346758.json:
```json
{
    "body": "Replying to [comment:5 vdelecroix]:\n> Replying to [comment:4 rws]:\n> Moreover having `import SR` any time `roots` is called is slowing down everything and is a very bad practice. You should have used the special method `_roots_univariate_polynomial` that has to be implemented directly into the ring. See #24942.\n\nTo be clear: anything specific to `SR` has to go in `symbolic/` and not invade the whole Sage code. This code was badly intrusive.",
    "created_at": "2018-03-10T15:20:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346758",
    "user": "vdelecroix"
}
```

Replying to [comment:5 vdelecroix]:
> Replying to [comment:4 rws]:
> Moreover having `import SR` any time `roots` is called is slowing down everything and is a very bad practice. You should have used the special method `_roots_univariate_polynomial` that has to be implemented directly into the ring. See #24942.

To be clear: anything specific to `SR` has to go in `symbolic/` and not invade the whole Sage code. This code was badly intrusive.



---

archive/issue_comments_346759.json:
```json
{
    "body": "Replying to [comment:6 vdelecroix]:\n> To be clear: anything specific to `SR` has to go in `symbolic/` and not invade the whole Sage code. This code was badly intrusive.\n\nTo be clear as well: that specialization was not introduced by me. I merely added a shortcut that no longer used Maxima.",
    "created_at": "2018-03-10T15:59:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346759",
    "user": "rws"
}
```

Replying to [comment:6 vdelecroix]:
> To be clear: anything specific to `SR` has to go in `symbolic/` and not invade the whole Sage code. This code was badly intrusive.

To be clear as well: that specialization was not introduced by me. I merely added a shortcut that no longer used Maxima.



---

archive/issue_comments_346760.json:
```json
{
    "body": "Replying to [comment:7 rws]:\n> Replying to [comment:6 vdelecroix]:\n> > To be clear: anything specific to `SR` has to go in `symbolic/` and not invade the whole Sage code. This code was badly intrusive.\n> \n> To be clear as well: that specialization was not introduced by me. I merely added a shortcut that no longer used Maxima.\n\nActually, this is not only true for `SR` but for some other rings as well! This `roots` code is a mess...",
    "created_at": "2018-03-10T16:04:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346760",
    "user": "vdelecroix"
}
```

Replying to [comment:7 rws]:
> Replying to [comment:6 vdelecroix]:
> > To be clear: anything specific to `SR` has to go in `symbolic/` and not invade the whole Sage code. This code was badly intrusive.
> 
> To be clear as well: that specialization was not introduced by me. I merely added a shortcut that no longer used Maxima.

Actually, this is not only true for `SR` but for some other rings as well! This `roots` code is a mess...



---

archive/issue_comments_346761.json:
```json
{
    "body": "Coming back to the original problem the solution would be to insert a shortcut for inexact polynomial input in solve that uses other methods. The default `algorithm` of solve at the moment is Maxima so the documentation should explain that with such input other methods are used. Specifically, I would not try to implement this by turning a switch on/off in Maxima because Sage's own root finding methods are probably better suited for all the possible inexact Sage number types.",
    "created_at": "2018-03-25T05:56:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346761",
    "user": "rws"
}
```

Coming back to the original problem the solution would be to insert a shortcut for inexact polynomial input in solve that uses other methods. The default `algorithm` of solve at the moment is Maxima so the documentation should explain that with such input other methods are used. Specifically, I would not try to implement this by turning a switch on/off in Maxima because Sage's own root finding methods are probably better suited for all the possible inexact Sage number types.



---

archive/issue_comments_346762.json:
```json
{
    "body": "See `Expression.is_exact()`.",
    "created_at": "2018-03-25T05:59:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24702",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24702#issuecomment-346762",
    "user": "rws"
}
```

See `Expression.is_exact()`.
