# Issue 23588: speed up in poset constructor

Issue created by migration from https://trac.sagemath.org/ticket/23825

Original creator: mantepse

Original creation time: 2017-09-11 06:45:31

CC:  jmantysalo

For my application, I have to speed up the poset constructor.  It seems that some time is wasted there because the same computation is done three times:  the digraph is computed in the `Poset` function in line 657, then the Hasse diagram is computed in `FinitePoset.__classcall__` in line 922 and again in `FinitePoset.__init__` in line 1003, see below.


```
sage: %lprun -f Poset -f sage.combinat.posets.posets.FinitePoset.__classcall__ -f sage.combinat.posets.posets.FinitePoset.__init__ [pi.permutation_po
....: set() for pi in Permutations(7)]
Timer unit: 1e-06 s

Total time: 17.5408 s
File: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/combinat/posets/posets.py
Function: Poset at line 288

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   288                                           def Poset(data=None, element_labels=None, cover_relations=False, linear_extension=False, category=None, facade=None, key=None):
   ...
   628                                               # Avoiding some errors from the user when data should be a pair
   629      5040        22646      4.5      0.1      if (element_labels is not None and
   630                                                   not isinstance(element_labels, dict) and
   631                                                   not isinstance(element_labels, list)):
   632                                                   raise TypeError("element_labels should be a dict or a list if "+
   633                                                                    "different from None. (Did you intend data to be "+
   634                                                                    "equal to a pair ?)")
   635                                           
   636                                               #Convert data to a DiGraph
   637      5040        19279      3.8      0.1      elements = None
   638      5040        17104      3.4      0.1      D = {}
   639      5040        36953      7.3      0.2      if isinstance(data, FinitePoset):
   640                                                   if element_labels is None and category is None and facade is None and linear_extension == data._with_linear_extension:
   641                                                       return data
   642                                                   if not linear_extension:
   643                                                       P = FinitePoset(data, elements=None, category=category, facade=facade)
   644                                                       if element_labels is not None:
   645                                                           P = P.relabel(element_labels)
   646                                                       return P
   647                                                   else:
   648                                                       if element_labels is None:
   649                                                           return FinitePoset(data, elements=data._elements, category=category, facade=facade)
   650                                                       else:
   651                                                           return FinitePoset(data, elements=element_labels, category=category, facade=facade)
   652      5040        20209      4.0      0.1      elif data is None: # type 0
   653                                                   D = DiGraph()
   654      5040        26617      5.3      0.2      elif isinstance(data, DiGraph): # type 4
   655                                                   D = copy.deepcopy(data)
   656      5040        20884      4.1      0.1      elif isinstance(data, dict): # type 3: dictionary of upper covers
   657      5040      3598070    713.9     20.5          D = DiGraph(data, format="dict_of_lists")
   658                                               elif isinstance(data,(list,tuple)): # types 1, 2, 3 (list/tuple)
   659                                                   if len(data) == 2: # types 1 or 2
   660                                                       if callable(data[1]): # type 2
   661                                                           elements, function = data
   662                                                           relations = []
   663                                                           for x in elements:
   664                                                               for y in elements:
   665                                                                   if function(x,y) is True:
   666                                                                       relations.append([x,y])
   667                                                       else: # type 1
   668                                                           elements, relations = data
   669                                                           # check that relations are relations
   670                                                           for r in relations:
   671                                                               try:
   672                                                                   u, v = r
   673                                                               except ValueError:
   674                                                                   raise TypeError("not a list of relations")
   675                                                       D = DiGraph()
   676                                                       D.add_vertices(elements)
   677                                                       D.add_edges(relations, loops=False)
   678                                                   elif len(data) > 2:
   679                                                       # type 3, list/tuple of upper covers
   680                                                       D = DiGraph(dict([[Integer(i),data[i]] for i in range(len(data))]),
   681                                                                   format="dict_of_lists")
   682                                                   else:
   683                                                       raise ValueError("not valid poset data")
   684                                           
   685                                               # DEBUG: At this point D should be a DiGraph.
   686      5040        28334      5.6      0.2      assert isinstance(D, DiGraph), "BUG: D should be a digraph."
   687                                           
   688                                               # Determine cover relations, if necessary.
   689      5040        20458      4.1      0.1      if cover_relations is False:
   690      5040        79271     15.7      0.5          from sage.graphs.generic_graph_pyx import transitive_reduction_acyclic
   691      5040      5755687   1142.0     32.8          D = transitive_reduction_acyclic(D)
   692                                           
   693                                               # Check that the digraph does not contain loops, multiple edges
   694                                               # and is transitively reduced.
   695      5040        66978     13.3      0.4      if D.has_loops():
   696                                                   raise ValueError("Hasse diagram contains loops")
   697      5040        61200     12.1      0.3      elif D.has_multiple_edges():
   698                                                   raise ValueError("Hasse diagram contains multiple edges")
   699      5040        22248      4.4      0.1      elif cover_relations is True and not D.is_transitively_reduced():
   700                                                   raise ValueError("Hasse diagram is not transitively reduced")
   701                                           
   702      5040        18747      3.7      0.1      if element_labels is not None:
   703                                                   D = D.relabel(element_labels, inplace=False)
   704                                           
   705      5040        17168      3.4      0.1      if linear_extension:
   706                                                   if element_labels is not None:
   707                                                       elements = element_labels
   708                                                   elif elements is None:
   709                                                       # Compute a linear extension of the poset (a topological sort).
   710                                                       try:
   711                                                           elements = D.topological_sort()
   712                                                       except Exception:
   713                                                           raise ValueError("Hasse diagram contains cycles")
   714                                               else:
   715      5040        17670      3.5      0.1          elements = None
   716      5040      7691234   1526.0     43.8      return FinitePoset(D, elements=elements, category=category, facade=facade, key=key)

Total time: 7.33872 s
File: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/combinat/posets/posets.py
Function: __classcall__ at line 878

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   878                                               @staticmethod
   879                                               def __classcall__(cls, hasse_diagram, elements=None, category=None, facade=None, key=None):
   ...
   908      5040        35303      7.0      0.5          assert isinstance(hasse_diagram, (FinitePoset, DiGraph))
   909      5040        27521      5.5      0.4          if isinstance(hasse_diagram, FinitePoset):
   910                                                       if category is None:
   911                                                           category = hasse_diagram.category()
   912                                                       if facade is None:
   913                                                           facade = hasse_diagram in Sets().Facade()
   914                                                       if elements is None:
   915                                                           relabel = {i:x for i,x in enumerate(hasse_diagram._elements)}
   916                                                       else:
   917                                                           elements = tuple(elements)
   918                                                           relabel = {i:x for i,x in enumerate(elements)}
   919                                                       hasse_diagram = hasse_diagram._hasse_diagram.relabel(relabel, inplace=False)
   920                                                       hasse_diagram = hasse_diagram.copy(immutable=True)
   921                                                   else:
   922      5040      4586635    910.0     62.5              hasse_diagram = HasseDiagram(hasse_diagram, data_structure="static_sparse")
   923      5040        22245      4.4      0.3              if facade is None:
   924      5040        18596      3.7      0.3                  facade = True
   925      5040        16902      3.4      0.2              if elements is not None:
   926                                                           elements = tuple(elements)
   927                                                   # Standardize the category by letting the Facade axiom be carried
   928                                                   #   by the facade variable
   929      5040        16436      3.3      0.2          if category is not None and category.is_subcategory(Sets().Facade()):
   930                                                       category = category._without_axiom("Facade")
   931      5040       517530    102.7      7.1          category = Category.join([FinitePosets().or_subcategory(category), FiniteEnumeratedSets()])
   932      5040        38150      7.6      0.5          return super(FinitePoset, cls).__classcall__(cls, hasse_diagram=hasse_diagram,
   933      5040        17758      3.5      0.2                                                       elements=elements,
   934      5040        16711      3.3      0.2                                                       category=category, facade=facade,
   935      5040      2024938    401.8     27.6                                                       key=key)

Total time: 0.409331 s
File: /home/martin/sage-develop/local/lib/python2.7/site-packages/sage/combinat/posets/posets.py
Function: __init__ at line 937

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   937                                               def __init__(self, hasse_diagram, elements, category, facade, key):
   ...
   986       138        32129    232.8      7.8          Parent.__init__(self, category=category, facade=facade)
   987       138          718      5.2      0.2          if elements is None:
   988       138          753      5.5      0.2              self._with_linear_extension = False
   989                                                       # Compute a linear extension of the poset (a topological sort).
   990       138          558      4.0      0.1              try:
   991       138         6075     44.0      1.5                  elements = tuple(hasse_diagram.topological_sort())
   992                                                       except Exception:
   993                                                           raise ValueError("Hasse diagram contains cycles")
   994                                                   else:
   995                                                       self._with_linear_extension = True
   996                                                   # Work around the fact that, currently, when a DiGraph is
   997                                                   # created with Integer's as vertices, those vertices are
   998                                                   # converted to plain int's. This is a bit abusive.
   999       138         5482     39.7      1.3          self._elements = tuple(Integer(i) if isinstance(i,int) else i for i in elements)
  1000                                                   # Relabel using the linear_extension.
  1001                                                   # So range(len(D)) becomes a linear extension of the poset.
  1002       138         2967     21.5      0.7          rdict = {self._elements[i]: i for i in range(len(self._elements))}
  1003       138       353762   2563.5     86.4          self._hasse_diagram = HasseDiagram(hasse_diagram.relabel(rdict, inplace=False), data_structure="static_sparse")
  1004       138          985      7.1      0.2          self._element_to_vertex_dict = dict( (self._elements[i], i)
  1005       138         5197     37.7      1.3                                               for i in range(len(self._elements)) )
  1006       138          705      5.1      0.2          self._is_facade = facade
sage: 
```



---

Comment by jmantysalo created at 2017-09-11 07:24:07

See also #18776 and #20434.


---

Comment by chapoton created at 2020-09-18 19:18:51

Changing keywords from "" to "poset".
