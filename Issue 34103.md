# Issue 34103: LazyFamily: Accept category keyword

Issue created by migration from https://trac.sagemath.org/ticket/34340

Original creator: mkoeppe

Original creation time: 2022-08-11 04:16:31

CC:  tscrim

Currently a `LazyFamily` is in `EnumeratedSets`, so at most countable.


---

Comment by mkoeppe created at 2022-08-14 22:36:58

New commits:


---

Comment by git created at 2022-08-14 23:49:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-15 03:04:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-15 03:13:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-15 03:21:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-15 03:43:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-15 03:48:57

Changing status from new to needs_review.


---

Comment by tscrim created at 2022-08-15 04:57:59

The main part of your changes LGTM, it is good to have this extra flexibility. I just have some issues with the docstring you changed.

For the first paragraph, I am not a fan of giving implementation details to the more casual user in the docstring. If they care about such details, then they almost certainly are already looking at the code. I know it was there previously, but now it has been given more prominence. So I think the first paragraph about the function being a factory should go last (although I really would like to remove it altogether).

The second paragraph is good (I am not counting the one-line description as a paragraph).

I don't really understand the third paragraph, even what you are trying to  say. My thought is that it will be far too technical and likely should be removed. Although it would be worthwhile to state that iterating through the object returns the values rather than the keys.

I don't understand the second part of the fourth paragraph. I think I know what you are trying to say, but that is not anything that belongs in this documentation. It seems like a code comment for within the category. I don't think the first sentence is even necessary (this is true for nearly every object in Sage).

I would change `.. NOTE::` -> `.. WARNING::`.


---

Comment by mkoeppe created at 2022-08-15 05:13:50

It boils down to this: When the function is not injective, there is a subtle conflict between methods such as `__len__` according to the `collections.abc` and `cardinality` from `Sets.ParentMethods`. Arguably, `__len__` should return the number of keys, whereas `cardinality` definitely must return the cardinality of the set (values)


---

Comment by git created at 2022-08-15 05:15:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-15 05:33:51

Unfortunately I don't see how that is in the documentation (beyond the `.. WARNING::`; also ``__iter__`` -> ```__iter__``` in there). Nor does that seem to be true that is is `values()`:

```
sage: F = Family([1,1,1])
sage: F
Family (1, 1, 1)
sage: F.cardinality()
3
```

The `__len__` also redirects from `cardinality()` by default (from the category). Or perhaps that is your point, that it is different than what you would expect as a set (of values). Since this is a mapping, it is a set of pairs `(k, v)`, so the cardinality for me is consistent.


---

Comment by mkoeppe created at 2022-08-15 05:37:58

Replying to [comment:17 tscrim]:
> The `__len__` also redirects from `cardinality()` by default (from the category). Or perhaps that is your point, that it is different than what you would expect as a set (of values). Since this is a mapping, it is a set of pairs `(k, v)`, so the cardinality for me is consistent.

But the elements according to other methods of the `Sets` protocol are not `(k, v)`; they are `v`.


---

Comment by git created at 2022-08-15 05:40:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-15 05:42:58

Replying to [comment:17 tscrim]:
> Unfortunately I don't see how that is in the documentation 

Yes, `__len__` is not explained there yet because it's still unclear.


---

Comment by mkoeppe created at 2022-08-15 05:45:55

Replying to [comment:17 tscrim]:
> Nor does that seem to be true that is is `values()`:
> {{{
> sage: F = Family([1,1,1])
> sage: F
> Family (1, 1, 1)
> sage: F.cardinality()
> 3
> }}}

Yes, that's wrong, and that's why I added the warning.


---

Comment by tscrim created at 2022-08-15 05:49:19

Replying to [comment:18 mkoeppe]:
> Replying to [comment:17 tscrim]:
> > The `__len__` also redirects from `cardinality()` by default (from the category). Or perhaps that is your point, that it is different than what you would expect as a set (of values). Since this is a mapping, it is a set of pairs `(k, v)`, so the cardinality for me is consistent.
> 
> But the elements according to other methods of the `Sets` protocol are not `(k, v)`; they are `v`.

Okay, I think I understand better what you want to say. I think you can say the same thing as

```
Note that for most set operations, this is considered as the set
of values; for instance, containment. There are some it is considered
as a map, such as its cardinality.
```



---

Comment by mkoeppe created at 2022-08-15 05:50:46

Strong -1 on giving `cardinality` semantics that differs from what the category guarantees


---

Comment by tscrim created at 2022-08-15 05:51:26

Replying to [comment:21 mkoeppe]:
> Replying to [comment:17 tscrim]:
> > Nor does that seem to be true that is is `values()`:
> > {{{
> > sage: F = Family([1,1,1])
> > sage: F
> > Family (1, 1, 1)
> > sage: F.cardinality()
> > 3
> > }}}
> 
> Yes, that's wrong, and that's why I added the warning.

My point is that it is not wrong, but the implementation, mainly iteration, is just over the values. That is an implementation detail that is separate from its mathematical definition (nor do I think we should ascribe mathematical definitions to all implementations).


---

Comment by mkoeppe created at 2022-08-15 05:52:57

This makes no sense. `cardinality` is mathematical cardinality. We define it for this purpose. This method is not part of Python semantics, so it does not have to be compatible with it


---

Comment by tscrim created at 2022-08-15 05:53:48

Replying to [comment:23 mkoeppe]:
> Strong -1 on giving `cardinality` semantics that differs from what the category guarantees

But it does not differ here. Strictly speaking, it is not a set of values, but a function. We have just chosen the iteration to be over the values as that is what is most convenient for a lot of code.


---

Comment by mkoeppe created at 2022-08-15 05:54:49

If it is a function, what are the elements?


---

Comment by tscrim created at 2022-08-15 05:55:07

Note also that the documentation uses round brackets `()`, not squiggly `{}` for defining a family, which makes it a sequence (wrt some fixed total order on the index set).


---

Comment by tscrim created at 2022-08-15 05:55:29

A function `f(u) = v` is a set of pairs `{(u, v)}`.


---

Comment by mkoeppe created at 2022-08-15 05:57:31

But `(u,v)` is not an element of the family in the sense of `__contains__` (which is a method of the `Sets().ParentMethods()` protocol): `(u,v) in f` will give `False`. `v in f` gives `True`.


---

Comment by tscrim created at 2022-08-15 06:01:00

Yes, you are correct that it is breaking the usual semantics of a set with the containment. However this is extremely convenient to have and we have (many) other programming models for when we want everything to confirm. Furthermore, what would you consider a sequence to be? Is it not a set? What is its cardinality?


---

Comment by mkoeppe created at 2022-08-15 06:02:48

Replying to [comment:31 tscrim]:
> Yes, you are correct that it is breaking the usual semantics of a set with the containment.

No, it just means that the interpretation that a Family "is" a function makes no sense.


---

Comment by mkoeppe created at 2022-08-15 06:04:22

A `Sequence` in Sage is not a Parent, so none of this reasoning applies.


---

Comment by mkoeppe created at 2022-08-15 06:05:03

A `Family` is a `Parent` in the `Sets()` category. It's clear that its elements are (the values). It has to satisfy this protocol and not some vague version of it.


---

Comment by tscrim created at 2022-08-15 06:08:10

Replying to [comment:32 mkoeppe]:
> Replying to [comment:31 tscrim]:
> > Yes, you are correct that it is breaking the usual semantics of a set with the containment.
> 
> No, it just means that the interpretation that a Family "is" a function makes no sense.

It is for mathematical purposes. Since you are trying to make a mathematical point that the cardinality is wrong, we should apply that definition. When it comes to programming, we want an implementation that has features that make a behave like many different objects. How I understand your argument is we should always strictly apply mathematical definitions to programming constructs. What I draw from this is your argument implies we should remove certain features that are extremely useful and need to be fast as they are used in tight loops.


---

Comment by mkoeppe created at 2022-08-15 06:08:25

I think it's instructive to look at https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes to answer what contract `__len__`, `__iter__`, `__contains__` have to satisfy.


---

Comment by tscrim created at 2022-08-15 06:11:14

Replying to [comment:34 mkoeppe]:
> It's clear that its elements are (the values).

This is not true. Otherwise we would have no need for the `keys()`. 

> It has to satisfy this protocol and not some vague version of it.

We should generally follow it, but sometimes there are very good reasons for breaking things. This is one of those times.


---

Comment by mkoeppe created at 2022-08-15 06:12:48

Replying to [comment:35 tscrim]:
> Replying to [comment:32 mkoeppe]:
> > No, it just means that the interpretation that a Family "is" a function makes no sense.
> 
> It is for mathematical purposes. Since you are trying to make a mathematical point that the cardinality is wrong, we should apply that definition.

Here's a mathematical definition of a family that's better for us (= the programming context in which Family is used):

It "is" a set which "has" additionally a map from a (possibly ordered) set of keys onto it.


---

Comment by tscrim created at 2022-08-15 06:13:07

Replying to [comment:33 mkoeppe]:
> A `Sequence` in Sage is not a Parent, so none of this reasoning applies.

I meant a mathematical sequence. What would you do if you needed it to also be a `Parent`? I suspect you would end up with the `Family` implementation.


---

Comment by mkoeppe created at 2022-08-15 06:15:05

Replying to [comment:37 tscrim]:
> Replying to [comment:34 mkoeppe]:
> > It's clear that its elements are (the values).
> 
> This is not true. Otherwise we would have no need for the `keys()`. 

elements as in Element vs. Parent.

(key, value) pairs are definitely not element of this parent.


---

Comment by tscrim created at 2022-08-15 06:17:05

I think every `Family` is a facade parent. So the elements don't even know about the family.


---

Comment by mkoeppe created at 2022-08-15 06:20:26

comment:30.


---

Comment by tscrim created at 2022-08-15 06:26:55

Replying to [comment:38 mkoeppe]:
> Replying to [comment:35 tscrim]:
> > Replying to [comment:32 mkoeppe]:
> > > No, it just means that the interpretation that a Family "is" a function makes no sense.
> > 
> > It is for mathematical purposes. Since you are trying to make a mathematical point that the cardinality is wrong, we should apply that definition.
> 
> Here's a mathematical definition of a family that's better for us (= the programming context in which Family is used):
> 
> It "is" a set which "has" additionally a map from a (possibly ordered) set of keys onto it.

Okay, I think I can get behind this as a definition. However, this makes computing the `cardinality()` potentially very expensive. I am also not sure about getting rid of the sequence/function-like aspect it had, but I currently do not have a use-case for it.

I am also opposed to making everything extremely mathematically strict and rigorous. Again, there are times when it is useful to break that. I think we should instead just simply document that for most things it behaves like a function (as it is, just written `f[x]` instead of `f(x)`), but others, such as its iteration and containment, is based on the set of its values.


---

Comment by mkoeppe created at 2022-08-15 06:27:32

Replying to [comment:35 tscrim]:
> What I draw from this is your argument implies we should remove certain features that are extremely useful and need to be fast as they are used in tight loops.

I think in most existing use cases of `Family`, the map is actually injective. 
It would make sense to me to add to `Family` a keyword `is_injective` (default `True` =  unchecked promise that it is injective) that enables a fast straightforward mplementation.


---

Comment by tscrim created at 2022-08-15 06:27:55

Replying to [comment:42 mkoeppe]:
> comment:30.

comment:37.


---

Comment by tscrim created at 2022-08-15 06:30:22

IIRC, the only reason a `Family` is a `Parent` is because it needs to play nicely with things that expect a `Parent` as input (which includes immutability and hashability).


---

Comment by mkoeppe created at 2022-08-15 06:34:15

In my use case of `Family` it's very useful that it's a `Parent` (hence this ticket)


---

Comment by mkoeppe created at 2022-08-15 06:37:17

Replying to [comment:44 mkoeppe]:
> I think in most existing use cases of `Family`, the map is actually injective. 
> It would make sense to me to add to `Family` a keyword `is_injective` (default `True` =  unchecked promise that it is injective) that enables a fast straightforward implementation. 

In particular, `ImageSubobject` already knows how to handle `is_injective`


---

Comment by tscrim created at 2022-08-15 06:49:44

I am still not very happy with effectively deprecating functionality that would not be replaced with something else. IMO, it is not a bug. It seems like you are essentially proposing to make `Family` be duplicate code of `ImageSubobject`. However, I see their behaviors as complementary.

To me, a `Family` is a `Parent` and hasbable version of `dict`, which is suppose to be a model of a map (to this point, in the C++ STL, it is called `map`). In a strict mathematical world, we would iterate over and check containment in `F.values()`. Yet for the cases that we use it, we typically want the values and check containment within either the keys or values (even Python's `dict` does not follow its set-theoretic containment check).

Hence, if we just document these behaviors clearly (and not call them wrong), it will be sufficient to deter the user who is using this to model something that they shouldn't be. We can redirect the user to other objects, such as `ImageSubobject` if they, e.g., really want the cardinality of the values.


---

Comment by mkoeppe created at 2022-08-15 06:51:31

Replying to [comment:49 tscrim]:
> I am still not very happy with effectively deprecating functionality 

which one?


---

Comment by mkoeppe created at 2022-08-15 06:56:14

Replying to [comment:49 tscrim]:
> It seems like you are essentially proposing to make `Family` be duplicate code of `ImageSubobject`.

Not really, it has a different API (no `keys`). But it can be used for implementing `LazyFamily` to avoid code duplication.


---

Comment by tscrim created at 2022-08-15 06:59:34

Replying to [comment:51 mkoeppe]:
> Replying to [comment:49 tscrim]:
> > It seems like you are essentially proposing to make `Family` be duplicate code of `ImageSubobject`.
> 
> Not really, it has a different API (no `keys`). But it can be used for implementing `LazyFamily` to avoid code duplication.

Surely you have access to the defining map and its codomain. Or are you looking for something that ducktypes with `dict`?


---

Comment by tscrim created at 2022-08-15 07:03:12

Replying to [comment:50 mkoeppe]:
> Replying to [comment:49 tscrim]:
> > I am still not very happy with effectively deprecating functionality 
> 
> which one?

The function/sequence like behavior with `cardinality()` and iteration. Why I see it as an effective deprecation is the `.. WARNING::` saying it could be wrong, changing the definition in comment:38, adding `is_injective` in comment:44, etc. What this amounts to is saying "we need to change the behavior when the map is not injective." Paraphrasing that would be "we will remove this functionality (because it is wrong)."


---

Comment by mkoeppe created at 2022-08-15 07:11:28

All examples in `family.py` are injective. I'd say it's just a hidden assumption in the code, and clarifying it and handling both the injective and non-injective case correctly would be an improvement. I don't see it as deprecating anything. The interpretation of `cardinality` in the non-injective case just does not hold up.


---

Comment by mkoeppe created at 2022-08-15 07:20:34

Replying to [comment:49 tscrim]:
> To me, a `Family` is a `Parent` and hasbable version of `dict`, which is suppose to be a model of a map (to this point, in the C++ STL, it is called `map`).

The comparison with C++ STL map is not very useful. Its elements are pairs. Calling `iterator` gives pairs.

Python `dict` does not have this behavior. Calling `iter` iterates through its keys.

And `Family` has neither behavior of the two. Calling `iter` iterates through values.


---

Comment by tscrim created at 2022-08-15 07:29:16

Replying to [comment:54 mkoeppe]:
> All examples in `family.py` are injective. I'd say it's just a hidden assumption in the code, and clarifying it and handling both the injective and non-injective case correctly would be an improvement. I don't see it as deprecating anything. The interpretation of `cardinality` in the non-injective case just does not hold up.

I think it is clear I disagree with this. A lack of evidence does not mean something can never happen. In the use-cases we care about, it is injective, but there is no documentation about this being a requirement. Given its role generally as a `dict` object, the `cardinality()` works where `__len__` cannot and it is consistent with that.


---

Comment by mkoeppe created at 2022-08-15 07:33:02

The comparison with `dict` is misleading. If one wanted a hashable version of `dict`, it would have been easy to just implement something compatible with `dict`. But `Family` was clearly designed for a different purpose - namely something that "is" a set of values, not only "has" a set of values.


---

Comment by mkoeppe created at 2022-08-15 07:44:03

Anyway, it's late here. I'll play with the implementation in the next days and see if I can check if there's any non-injective use in the Sage library. This will give us more information.


---

Comment by mkoeppe created at 2022-08-15 07:44:03

Changing status from needs_review to needs_info.


---

Comment by tscrim created at 2022-08-15 07:44:27

IIRC, it was meant to be a hashable `dict` that also worked for infinite objects and had `Parent`-like behavior (I think for removing code duplication from inheriting stuff from categories too). It was chosen to iterate over the values rather than the keys (and check containment) because that was what was convenient for the majority of use cases.

However, that is not the only times where it is used. A `Family` is used to handle `dict` inputs to `UniqueRepresentation` in `LieAlgebrasWithStructureCoefficients`. Now it is not being used there as a set (or even allowing it to be infinite), but just a convenient tool to handle the hashing. If you are insistent on making sure that `Family` strictly conforms with your mathematical definition of it, then you will need to change the places in Sage where it is not conforming with your definition and make sure there is a replacement for the current behavior.


---

Comment by mkoeppe created at 2022-08-15 15:43:42

I doubt that in such use cases the method `cardinality` is used.


---

Comment by git created at 2022-08-15 22:10:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-15 23:43:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-15 23:48:27

I think it can be dangerous to make such claims about code in the wild, especially something as a low-level tool like this. I am still generally opposed to considering a `Family`. Or has your argument actually become that `ImageSubset` is duplicating the functionality and intent of `Family`? API's being different is not a valid argument against this latter claim; it is just one easy to add method. I still strongly contend this is meant to be a `dict`-like structure that complements `ImageSubset`.


---

Comment by mkoeppe created at 2022-08-15 23:53:27

The crucial difference is equality.

Two `ImageSubset`s are equal if they have the same elements.

Two `Family`s are equal if they have the same keys and map (whatever that means in detail).


---

Comment by tscrim created at 2022-08-15 23:57:23

Which further makes my point that it is `dict`-like and not `set`-like.


---

Comment by mkoeppe created at 2022-08-16 00:00:09

It is only dict-like in that it has two methods `keys` and `values`, that's all. Code that uses Family like a dict will have to use these methods. Using `cardinality` just makes no sense.


---

Comment by mkoeppe created at 2022-08-16 00:04:05

Some failures with the current code

```
sage -t --random-seed=251178244497158028621407850304141794068 src/sage/algebras/jordan_algebra.py  # Timed out
sage -t --random-seed=251178244497158028621407850304141794068 src/sage/quivers/path_semigroup.py  # 1 doctest failed
sage -t --random-seed=251178244497158028621407850304141794068 src/sage/algebras/yangian.py  # Timed out
sage -t --random-seed=251178244497158028621407850304141794068 src/sage/algebras/lie_algebras/abelian.py  # 5 doctests failed
```



---

Comment by tscrim created at 2022-08-16 00:06:15

Replying to [comment:66 mkoeppe]:
> It is only dict-like in that it has two methods `keys` and `values`, that's all. Code that uses Family like a dict will have to use these methods. Using `cardinality` just makes no sense.

Equality is also `dict`-like (i.e., it is being treated as a map), which you just made a point about. Hence its `__len__` should follow suit, and it would be extremely strange to have `cardinality()` different from that.


---

Comment by mkoeppe created at 2022-08-16 00:13:19

Replying to [comment:68 tscrim]:
> Replying to [comment:66 mkoeppe]:
> > It is only dict-like in that it has two methods `keys` and `values`, that's all. Code that uses Family like a dict will have to use these methods. Using `cardinality` just makes no sense.
> 
> Equality is also `dict`-like (i.e., it is being treated as a map), which you just made a point about. Hence its `__len__` should follow suit

No, this does not follow at all.

Think about it in terms of algebraic structures. For example, a group has a stricter notion of equality than the underlying set. But the notion of cardinality is set-theoretic. A group cannot just modify the concept of cardinality.


---

Comment by tscrim created at 2022-08-16 00:25:34

That's a non-sequitur. The issue is about the mathematical definition of a `Family` and the tension of that with some of the implementation details.

The design and many of the core implementation features are about emulating `dict` that is a `Parent`. We have other things, namely `ImageSubset` when we want to think of it as a set of values with a map attached. In fact, a core part of your argument is things that are in `Sets` should follow the same protocols, which include equality. Equality of sets means `X` and `Y` are each contained within each other. comment:64 rightly points out that equality of `Family` is not this, which is because it is `dict`-like, so it is treated mathematically as a set of pairs `(k, v)` defining map. I agree with you that it abuses containment and iteration for programmatic convenience. I would not be opposed to changing this behavior if it was not so fully ingrained within Sage. The documentation is very clear about it being a `dict`-like structure too as it uses sequence notation, not set notation.


---

Comment by mkoeppe created at 2022-08-16 00:26:52

Replying to [comment:68 tscrim]:
> it would be extremely strange to have `cardinality()` different from [`__len__`]

I do agree with this part, so I retract what I said in comment:15 regarding this.

`__len__` should be the same as `cardinality`.
And this is compatible with `__iter__` (which must iterate over the elements of the set - no duplicates!)


---

Comment by mkoeppe created at 2022-08-16 00:31:49

Replying to [comment:70 tscrim]:
> In fact, a core part of your argument is things that are in `Sets` should follow the same protocols, which include equality. Equality of sets means `X` and `Y` are each contained within each other.

Yes, this is exactly what being in the category guarantees.

> comment:64 rightly points out that equality of `Family` is not this, which is because it is `dict`-like, so it is treated mathematically as a set of pairs `(k, v)` defining map. 

No, the interpretation that it "is" a set of pairs (= the pairs the elements) does not hold up. I've explained it before in comment:55.

What are elements? They are what `__iter__` produces, and they are the idempotents under `_element_constructor_`. 

These are clearly the values, not key-value pairs.


---

Comment by mkoeppe created at 2022-08-16 00:33:51

So, as I continue to use the definition of Family from comment:38, 
the map onto ``self`` is the additional structure of a Family, just like the group law is the additional structure of a Group.


---

Comment by mkoeppe created at 2022-08-16 00:35:54

The additional structure changes what is equal, but it cannot change cardinality.


---

Comment by tscrim created at 2022-08-16 01:00:49

This sounds like it would introduce a major inconsistency: Two things are equal (by taking the set-of-values) with different cardinalities! If we are not going to replace it by `ImageSubset`, then we are going to have to live with some inconsistency. It is a much smaller one to simply state that iteration and containment is done on its values.

Additionally, `Family` doesn't have an `_element_constructor_`, nor does it support the `__call__` syntax (it raises a `NotImplementedError`). It uses `F[x]` instead of `F(x)` to be used as a `dict` replacement.


---

Comment by tscrim created at 2022-08-16 01:01:21

Furthermore, because it is a façade parent, it doesn't technically have elements either.


---

Comment by mkoeppe created at 2022-08-16 01:02:36

Replying to [comment:75 tscrim]:
> This sounds like it would introduce a major inconsistency: Two things are equal (by taking the set-of-values) with different cardinalities!

No, why would you think so?


---

Comment by mkoeppe created at 2022-08-16 01:04:05

Replying to [comment:75 tscrim]:
> Additionally, `Family` doesn't have an `_element_constructor_`

`LazyFamily` now does.


---

Comment by tscrim created at 2022-08-16 01:07:10

Replying to [comment:77 mkoeppe]:
> Replying to [comment:75 tscrim]:
> > This sounds like it would introduce a major inconsistency: Two things are equal (by taking the set-of-values) with different cardinalities!
> 
> No, why would you think so?

I misread what you said, sorry about that.

Actually, since you are changing the category (to `SetsWithMaps`), we do not have to have the cardinality agree with `Sets`. This is not the same relation as for, e.g., `Groups` to `Sets`. It is not intrinsic to the set.


---

Comment by tscrim created at 2022-08-16 01:08:16

Replying to [comment:78 mkoeppe]:
> Replying to [comment:75 tscrim]:
> > Additionally, `Family` doesn't have an `_element_constructor_`
> 
> `LazyFamily` now does.

I don't think it is valid to use something you implemented as justification for what you think it should do.


---

Comment by mkoeppe created at 2022-08-16 01:09:27

Replying to [comment:72 mkoeppe]:
> What are elements? They are what `__iter__` produces

How about this one?


---

Comment by tscrim created at 2022-08-16 01:12:09

Replying to [comment:81 mkoeppe]:
> Replying to [comment:72 mkoeppe]:
> > What are elements? They are what `__iter__` produces
> 
> How about this one?

As I have repeatedly said, it is an abuse that we should document, but we have it because it is so convenient for the uses of this class.


---

Comment by mkoeppe created at 2022-08-16 01:14:16

Sorry, Travis, your theory that key-value pairs are somehow the elements is completely unsubstantiated. There is no place in the code where key-value pairs even appear. Dicts at least have an `__items__` method, but a `Family` does not.


---

Comment by mkoeppe created at 2022-08-16 01:27:56

Replying to [comment:79 tscrim]:
> Actually, since you are changing the category (to `SetsWithMaps`) [...]

You may want to develop this line of reasoning a bit further if you want to use it.


---

Comment by tscrim created at 2022-08-16 01:31:52

Replying to [comment:83 mkoeppe]:
> Sorry, Travis, your theory that key-value pairs are somehow the elements is completely unsubstantiated. There is no place in the code where key-value pairs even appear. Dicts at least have an `__items__` method, but a `Family` does not.

You mean in spite of all of the classes' documentation, the `cardinality()`, the equality, the `__getitem__()`, and the `keys()`? One implementation even stores a `dict`; the `TrivialFamily` does not because it is wasteful.

IIRC, not having an `items()` comes from the fact this was implemented in Python2, when `items()` had to result in a list and there was not a reasonable way to make sense of this when the family was infinite. Now that we are allowed to return iterators for it, we can add this.

Honestly, I don't think this was ever meant to be treated so precisely as an object in `Sets`. What I do not support is removing functionality and increasing code duplication (without a good reason; the reasoning you have given does not meet that standard to me).


---

Comment by tscrim created at 2022-08-16 01:33:41

Replying to [comment:84 mkoeppe]:
> Replying to [comment:79 tscrim]:
> > Actually, since you are changing the category (to `SetsWithMaps`) [...]
> 
> You may want to develop this line of reasoning a bit further if you want to use it. 

What do you mean by "use it" here? As justification for this argument (which I would then read your statement as very passive-aggressive)? Or do you mean to implement a new object that would be a replacement for the functionality of `Family` that you are trying to remove?


---

Comment by mkoeppe created at 2022-08-16 01:35:10

Replying to [comment:85 tscrim]:
> Replying to [comment:83 mkoeppe]:
> > Sorry, Travis, your theory that key-value pairs are somehow the elements is completely unsubstantiated. There is no place in the code where key-value pairs even appear. Dicts at least have an `__items__` method, but a `Family` does not.
> 
> You mean in spite of all of the classes' documentation, the `cardinality()`, the equality, the `__getitem__()`, and the `keys()`? One implementation even stores a `dict`

Yes, there are no key-value pairs anywhere in this code.


---

Comment by mkoeppe created at 2022-08-16 01:36:04

And, more importantly, nothing in the API uses key-value pairs, and hence no code that uses a `Family` can refer to key-values.


---

Comment by tscrim created at 2022-08-16 01:40:01

Replying to [comment:88 mkoeppe]:
> And, more importantly, nothing in the API uses key-value pairs, and hence no code that uses a `Family` can refer to key-values.

So this doesn't count:

```
[(k, F[k]) for k in F.keys()]
```

which is just a slight modification of

```
[(k, d[k]) for k in d]
```

for a `dict` `d`?

A `dict` only has one thing that returns the pairs, which is `items()`. The key-value pairs are also implicit in the equality comparison; more explicitly when it not a lazy family (comparing the `_enumeration` or `_dictionary`).


---

Comment by mkoeppe created at 2022-08-16 01:45:10

Replying to [comment:89 tscrim]:
> Replying to [comment:88 mkoeppe]:
> > And, more importantly, nothing in the API uses key-value pairs, and hence no code that uses a `Family` can refer to key-values.
> 
> So this doesn't count:
> {{{
> [(k, F[k]) for k in F.keys()]
> }}}

It's iterating over the keys. What's your point?


---

Comment by mkoeppe created at 2022-08-16 01:49:47

Even with this ticket, a `Family` will continue to have `keys` and `__getitem__` methods in case this was unclear.


---

Comment by tscrim created at 2022-08-16 01:56:14

Replying to [comment:90 mkoeppe]:
> Replying to [comment:89 tscrim]:
> > Replying to [comment:88 mkoeppe]:
> > > And, more importantly, nothing in the API uses key-value pairs, and hence no code that uses a `Family` can refer to key-values.
> > 
> > So this doesn't count:
> > {{{
> > [(k, F[k]) for k in F.keys()]
> > }}}
> 
> It's iterating over the keys. What's your point?

It has a very similar API to `dict` with an easy way to produce key-value pairs. With Python3, this is less useful for `dict` (as it doesn't create a new list of values but simply iterates over them), but `Family` was not written in that era.


---

Comment by mkoeppe created at 2022-08-16 02:01:07

Would you say that the behavior of `dict.__iter__` to iterate over keys, not key-value pairs, "is an abuse that we should document, but we have it because it is so convenient for the uses of this class?"


---

Comment by tscrim created at 2022-08-16 02:04:55

Replying to [comment:91 mkoeppe]:
> Even with this ticket, a `Family` will continue to have `keys` and `__getitem__` methods in case this was unclear.

That's not the issue. You are at least strongly suggesting to change the behavior of `cardinality()` because it doesn't match the description you using as an object in `Sets`. So functionally it becomes no different than `ImageSubset` with an extra check on the defining map. Thus we should replace `Family` with `ImageSubset` (as a façade parent) and equality checks with checking the map (which contains both the keys and the values). This not only is more complicated to use (and potentially slower), it also does not have the ability to define an infinite sequence indexed by some enumerated set.


---

Comment by tscrim created at 2022-08-16 02:06:18

Replying to [comment:93 mkoeppe]:
> Would you say that the behavior of `dict.__iter__` to iterate over keys, not key-value pairs, "is an abuse that we should document, but we have it because it is so convenient for the uses of this class?"

If it was an object in `Sets`, yes I would.


---

Comment by mkoeppe created at 2022-08-16 02:10:16

But as a subclass of `collections.abc.Collection`, do you see an abuse?


---

Comment by tscrim created at 2022-08-16 02:16:27

That doesn't have anywhere near such precise definitions. All that is required is those methods are implemented. I don't think there is any consistency requirements. There are natural ones we impose, such as the length of the result of `__iter__` is the same as `__len__`, but note that both have to be implemented by the programmer.


---

Comment by mkoeppe created at 2022-08-16 02:16:45

Replying to [comment:94 tscrim]:
> it also does not have the ability to define an infinite sequence indexed by some enumerated set.

Oh I see. You are concerned that you will not be able to iterate over `values()` any more and see duplicate elements that may be appearing in this use case?


---

Comment by mkoeppe created at 2022-08-16 02:28:42

Replying to [comment:95 tscrim]:
> Replying to [comment:93 mkoeppe]:
> > Would you say that the behavior of `dict.__iter__` to iterate over keys, not key-value pairs, "is an abuse that we should document, but we have it because it is so convenient for the uses of this class?"
> 
> If it was an object in `Sets`, yes I would.

Why precisely does it matter to you whether this question is asked about a parent in `Sets`?


---

Comment by tscrim created at 2022-08-16 02:32:08

Replying to [comment:98 mkoeppe]:
> Replying to [comment:94 tscrim]:
> > it also does not have the ability to define an infinite sequence indexed by some enumerated set.
> 
> Oh I see. You are concerned that you will not be able to iterate over `values()` any more and see duplicate elements that may be appearing in this use case?

Yes, that would be the functionality that would be lost if we ended up replacing `Family` by `ImageSubset`.


---

Comment by tscrim created at 2022-08-16 02:33:32

Replying to [comment:99 mkoeppe]:
> Replying to [comment:95 tscrim]:
> > Replying to [comment:93 mkoeppe]:
> > > Would you say that the behavior of `dict.__iter__` to iterate over keys, not key-value pairs, "is an abuse that we should document, but we have it because it is so convenient for the uses of this class?"
> > 
> > If it was an object in `Sets`, yes I would.
> 
> Why precisely does it matter to you whether this question is asked about a parent in `Sets`?

My understand is this was the starting point for your argument for saying things are wrong: `Family` is in `Sets` but (its values are) not respecting the mathematical description.


---

Comment by mkoeppe created at 2022-08-16 02:33:44

Replying to [comment:100 tscrim]:
> if we ended up replacing `Family` by `ImageSubset`.

My branch does not do this, why do you speculate about it?


---

Comment by mkoeppe created at 2022-08-16 02:41:33

Replying to [comment:100 tscrim]:
> Replying to [comment:98 mkoeppe]:
> > Replying to [comment:94 tscrim]:
> > > it also does not have the ability to define an infinite sequence indexed by some enumerated set.
> > 
> > Oh I see. You are concerned that you will not be able to iterate over `values()` any more and see duplicate elements that may be appearing in this use case?
> 
> Yes, that would be the functionality that would be lost

OK then, I propose the following. I revert the changes to the `values()` method so that it is not an `ImageSubobject` as proposed but gives an iterable that runs parallel to `keys`. (I can also throw in an `items()` method.)

Then there could be a separate method `as_set` that would return the `ImageSubobject`.


---

Comment by mkoeppe created at 2022-08-16 02:43:44

But I would still do the change to `cardinality`. It is dictated by `__iter__` and `cardinality` as part of the `EnumeratedSets()` category. 

`cardinality` is clearly not needed for the use case of modeling infinite sequences or really anything that needs the key-value association.


---

Comment by git created at 2022-08-16 02:52:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-16 02:56:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-16 03:01:49

Replying to [comment:102 mkoeppe]:
> Replying to [comment:100 tscrim]:
> > if we ended up replacing `Family` by `ImageSubset`.
> 
> My branch does not do this, why do you speculate about it?

comment:94. As long as you say the `cardinality()` may be wrong or talk about the function being injective, this holds.


---

Comment by tscrim created at 2022-08-16 03:08:54

I think we are at least getting closer to a solution we are both content with. Thank you for discussing this with me.

I am not sure I agree with keeping a reference to the result of `as_set`, much less have it be created on initialization of the `LazyFamily`. Why can't this construction just be done in `as_set()` (and make that an ``@`cached_method`)?

I don't think the `_element_constructor_` will work. You also forgot to change the `values()` code from `items()`.

I am not sure how I feel about the redirect with `__iter__`. I will need to profile this as I think we should make sure this is as fast as possible.


---

Comment by mkoeppe created at 2022-08-16 03:11:42

Replying to [comment:108 tscrim]:
> I am not sure I agree with keeping a reference to the result of `as_set`, much less have it be created on initialization of the `LazyFamily`. Why can't this construction just be done in `as_set()` (and make that an ``@`cached_method`)?

It allows me to delegate to the `ImageSubobject` methods.
But sure, the same thing could be done with cached_method.


---

Comment by git created at 2022-08-16 03:13:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-16 03:16:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-16 03:20:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-16 03:25:01

Replying to [comment:108 tscrim]:
> I don't think the `_element_constructor_` will work.

Yes, this needs a bit more work in `ImageSubobject` so that the relevant case is handled


---

Comment by git created at 2022-08-16 03:37:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-16 05:30:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-16 05:56:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-16 22:57:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-16 23:44:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-17 22:07:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-18 16:51:39

Changing status from needs_info to needs_work.


---

Comment by git created at 2022-08-18 18:19:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-18 18:22:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-18 19:10:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-18 19:26:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-18 20:47:50

Replying to [comment:108 tscrim]:
> I think we are at least getting closer to a solution we are both content with. Thank you for discussing this with me.

Likewise thanks for the discussion. It has helped clarify that the semantics needs to be documented not just by text but by defining an appropriate category. 

Here's an attempt for this, just two singleton categories `Families` and `EnumeratedFamilies`, though I have the feeling there should be a functorial construction


---

Comment by git created at 2022-08-18 23:41:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-18 23:46:55

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2022-08-18 23:48:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-19 00:33:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-19 00:38:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-19 05:14:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-17 16:21:40

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2022-09-17 16:22:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-17 16:31:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-18 05:15:59


```
sage -t --random-seed=143738364655453723155583373959896127051 src/sage/combinat/root_system/type_G.py  # 1 doctest failed
sage -t --random-seed=143738364655453723155583373959896127051 src/sage/sets/family.py  # 6 doctests failed
```

