# Issue 24273: Function field factorization does not pass on proof parameter

Issue created by migration from https://trac.sagemath.org/ticket/24510

Original creator: saraedum

Original creation time: 2018-01-10 23:32:57

CC:  swewers


```
NotImplementedError                       Traceback (most recent call last)
<ipython-input-6-327b611cc15f> in <module>()
----> 1 Y.compute_semistable_reduction()

/home/user/MCLF/mclf/semistable_reduction/superell.pyc in
compute_semistable_reduction(self)
    229             print "into %s lower
components."%len(Z.lower_components())
    230             print "The upper components are: "
--> 231             for W in Z.upper_components():
    232                 print W                   
    233                 if W.field_of_constants_degree() > 1:

/home/user/MCLF/mclf/semistable_reduction/reduction_trees.pyc in
upper_components(self, u)
    549         upper_components = []
    550         for Z in lower_components:
--> 551             upper_components += Z.upper_components()
    552         self._upper_components[u] = upper_components
    553         return upper_components                     

/home/user/MCLF/mclf/semistable_reduction/reduction_trees.pyc in
upper_components(self)
    868         FY = self.reduction_tree().curve().function_field()
    869         FYL = base_change_of_function_field(FY, self.base_field())
--> 870         upper_valuations = [FYL.valuation(w) for w in
v.mac_lane_approximants(FYL.polynomial())]
    871         return [UpperComponent(self, w) for w in upper_valuations]
    872                                                                   

/home/user/sage-develop/local/lib/python2.7/site-packages/sage/rings/valuation/valuation.pyc
in mac_lane_approximants(self, G, assume_squarefree, require_final_EF, re
quired_precision, require_incomparability, require_maximal_degree, algorithm)
    772                    forest = tree,                                    
    773                    map_function = lambda x: [x],
--> 774                    reduce_init = []).run_serial()
    775         else:                                    
    776             raise NotImplementedError(algorithm)

/home/user/sage-develop/local/lib/python2.7/site-packages/sage/parallel/map_reduce.pyc
in run_serial(self)
   1495         return functools.reduce(self.reduce_function,
   1496                                 (self.map_function(x) for x in
self._forest),
-> 1497                                 self.reduce_init())
   1498
   1499

/home/user/sage-develop/local/lib/python2.7/site-packages/sage/parallel/map_reduce.pyc
in <genexpr>((x,))
   1494         import functools
   1495         return functools.reduce(self.reduce_function,
-> 1496                                 (self.map_function(x) for x in
self._forest),
   1497                                 self.reduce_init())
   1498
/home/user/sage-develop/local/lib/python2.7/site-packages/sage/combinat/backtrack.pyc
in search_forest_iterator(roots, children, algorithm)
    240
    241         yield node
--> 242         stack.append( iter(children(node)) )
    243                                             
    244 class SearchForest(Parent):

/home/user/sage-develop/local/lib/python2.7/site-packages/sage/rings/valuation/valuation.pyc
in create_children(node)
    745                              valuations=node.valuations,
    746                              check=False,
--> 747
principal_part_bound=node.principal_part_bound)
    748             for w, bound, principal_part_bound, coefficients,
valuations in augmentations:
    749                 ef = bound == w.E()*w.F()

/home/user/sage-develop/local/lib/python2.7/site-packages/sage/rings/valuation/inductive_valuation.pyc
in mac_lane_step(self, G, principal_part_bound, assume_squarefr
ee, assume_equivalence_irreducible, report_degree_bounds_and_caches,
coefficients, valuations, check)
    748         ret = []
    749
--> 750         F = self.equivalence_decomposition(G,
assume_not_equivalence_unit=True, coefficients=coefficients,
valuations=valuations, compute_unit=False, degree_b
ound=principal_part_bound)
    751         assert len(F), "%s equivalence-decomposes as an
equivalence-unit %s"%(G, F)
    752         if len(F) == 1 and F[0][1] == 1 and F[0][0].degree() ==
G.degree():

/home/user/sage-develop/local/lib/python2.7/site-packages/sage/rings/valuation/inductive_valuation.pyc
in equivalence_decomposition(self, f, assume_not_equivalence_un
it, coefficients, valuations, compute_unit, degree_bound)   
   1210
   1211         valuation, phi_divides, F = self._equivalence_reduction(f,
coefficients=coefficients, valuations=valuations, degree_bound=degree_bound)
-> 1212         F = F.factor()
   1213         from sage.misc.misc import verbose
   1214         verbose("%s factors as %s = %s in reduction"%(f, F.prod(), F),
level=20)

/home/user/sage-develop/src/sage/rings/polynomial/polynomial_element.pyx in
sage.rings.polynomial.polynomial_element.Polynomial.factor
(build/cythonized/sage/rings/po
lynomial/polynomial_element.c:37439)()
   4088         R = self._parent.base_ring()
   4089         if hasattr(R, '_factor_univariate_polynomial'):              
-> 4090             return R._factor_univariate_polynomial(self, **kwargs)
   4091
   4092         G = None                                 

/home/user/sage-develop/local/lib/python2.7/site-packages/sage/rings/fraction_field.pyc
in _factor_univariate_polynomial(self, f)
    870         # This fails silently over some base fields, see #23642, so we
convert
    871         # to the function field and factor there.
--> 872         return
f.change_ring(self.function_field()).factor().base_change(f.parent())
    873
    874     def function_field(self):

/home/user/sage-develop/src/sage/rings/polynomial/polynomial_element.pyx in
sage.rings.polynomial.polynomial_element.Polynomial.factor
(build/cythonized/sage/rings/po
lynomial/polynomial_element.c:37439)()
   4088         R = self._parent.base_ring()
   4089         if hasattr(R, '_factor_univariate_polynomial'):
-> 4090             return R._factor_univariate_polynomial(self, **kwargs)
   4091
   4092         G = None
/home/user/sage-develop/local/lib/python2.7/site-packages/sage/rings/function_field/function_field.pyc
in _factor_univariate_polynomial(self, f, proof)
   2396
   2397         F, d = self._to_bivariate_polynomial(f)
-> 2398         fac = F.factor()                    
   2399         x = f.parent().gen()
   2400         t = f.parent().base_ring().gen()

/home/user/sage-develop/local/lib/python2.7/site-packages/sage/rings/polynomial/multi_polynomial_element.pyc
in factor(self, proof)
   1729                 raise NotImplementedError("Factorization of
multivariate polynomials over prime fields with characteristic > 2^29 is not
implemented.")
   1730         if proof:
-> 1731             raise NotImplementedError("proof = True factorization not
implemented.  Call factor with proof=False.")
   1732
   1733         R._singular_().set_ring()

NotImplementedError: proof = True factorization not implemented.  Call factor
with proof=False.


---

Comment by saraedum created at 2018-01-12 15:47:15

There is a followup ticket to fix the resulting error, #24533.


---

Comment by saraedum created at 2018-01-12 15:47:15

Changing status from new to needs_review.


---

Comment by tscrim created at 2018-01-12 17:55:54

New commits:


---

Comment by tscrim created at 2018-01-12 17:57:25

The docstring for the test makes it seem like you added a test showing that something does not work. You should also add something referencing this ticket saying what is being tested.


---

Comment by tscrim created at 2018-01-12 17:57:25

Changing status from needs_review to needs_work.


---

Comment by saraedum created at 2018-01-12 18:10:23

I sort of see your point but I don't think it's worth it here. How would I do that? By putting a `proof=True` and `proof=False` there and showing that they are different? I don't think that this makes any sense for a future reader of the code. If this test ever breaks whoever breaks it will just say that "one exception got replaced by another".

I don't want to doctest a non-helpful exception message but I just want to track somewhere that this does still not work.


---

Comment by saraedum created at 2018-01-12 18:10:23

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2018-01-12 18:19:05

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2018-01-12 18:19:05

I said doc_string_, not doctest. Without this ticket, I would not understand the point of that test from your current docstring and test. So perhaps something like

```
We check that ``proof`` parameter is passed to the underlying polynomial
(see :trac:`24510`). However, factoring over a function field over a tower
of finite fields does not work yet (see :trac:`24533`)::
```



---

Comment by git created at 2018-01-12 23:22:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2018-01-12 23:22:37

Ok. Fixed now.
----
New commits:


---

Comment by saraedum created at 2018-01-12 23:22:49

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2018-01-13 16:17:47

Thank you.


---

Comment by tscrim created at 2018-01-13 16:17:47

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-01-15 22:28:44

Resolution: fixed
