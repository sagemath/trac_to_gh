# Issue 16031: Better normalization for function field elements

Issue created by migration from https://trac.sagemath.org/ticket/16268

Original creator: cremona

Original creation time: 2014-04-29 15:00:38

CC:  tscrim cheuberg etn40ff jakobkroeker bhutz slelievre

If K is a field then K(u), the function field, has a reduce() method which cancels the gcd but does not put into a canonical form by (for example) dividing through by the leading coefficient of the denominator to make the denominator monic.  This means that equal elements may have different hashes, and hence that putting function field elements into a set does not work as a mathematician would expect.  For example:

```
sage: Ku.<u> = FractionField(PolynomialRing(QQ,'u'))
sage: a = 27*u^2+81*u+243
sage: b = 27*u-81
sage: c = u^2 + 3*u + 9
sage: d = u-3
sage: s = a/b
sage: t = c/d
sage: s==t
True
sage: len(Set([s,t]))
2
```



---

Comment by emassop created at 2014-04-29 16:29:25

The normalization would already be much better if `PolynomialRing(QQ, 'u')` had a 'better' gcd, like the one implemented for QQ in #10771, which would yield `gcd(27*u^2+81*u+243, 27*u-81)==27`. However the gcd from flint in src/sage/rings/polynomial/polynomial_rational_flint.pyx is monic. 

Ku could also figure out that it is also `FractionField(PolynomialRing(ZZ, 'u'))`, which has a better reduce.


---

Comment by git created at 2014-04-30 08:11:44

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2014-04-30 08:14:14

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by cremona created at 2014-04-30 08:15:14

Thanks, Robert, I will review this.  I had already started by patching the reduce function but had not yet discoivered where the automatic calling of reduction was actually happening.  Your solution -- keeping reduce() and normalise() separate -- looks better.


---

Comment by robertwb created at 2014-04-30 08:15:35

Changing status from new to needs_review.


---

Comment by emassop created at 2014-04-30 12:42:35

As of yet the documentation at normalize is incorrect. It reads "Returns a normalized representation of self". However it does not return anything.

Also, shouldn't normalize in `FractionFieldElement` throw a not-implemented-exception or so? Or at least have a warning in its documentation that it might not actually normalize? For instance in `FractionField(PolynomialRing(QQ, 'x,y'))`, calling reduce is still insufficient to do the normalization.


---

Comment by cremona created at 2014-05-02 14:15:02

What is happening here?  There are/were two commits by Robert Bradshaw but suddenly the branch name has changed to an emassop name.  I assume that this means the emassop is doing something, so I will hold back.
----
New commits:


---

Comment by emassop created at 2014-05-02 15:27:30

I changed the documentation to not say "return". Then did `git trac push`, but apparently something went wrong, since it only changed the branch name without picking up on the new commithash (and hence the summary of my commit). I was hoping trac-user "git" would pick it up with some delay, but apparently not.

I'm not going to change more, as I'm unfamiliar with the conventions about what normalize in `FractionFieldElement` should do when its not actually guaranteeing that numerator and denominator are the same for a == b after calling normalize on both.


---

Comment by git created at 2014-05-04 18:32:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by emassop created at 2014-05-04 19:11:30

I couldn't help myself and hacked a bit on this.
* Removed normalize from generic `FractionFieldElement`, as I don't think it can live up to the behaviour in its documentation. For instance (2x)/(2x+1) and (-2x)/(-2x-1) in Q(ZZ[x]) did not have the same normalisation. I doubt this can be fixed for general rings.
* Removed call to reduce for non-exact rings, as reduces' documentation says "Automatically called for exact rings, but because it may be numerically unstable for inexact rings it must be called manually in that case."
* Raise `NotImplementedError` in generic `FractionFieldElement.__hash__` except when the denominator is 1. In this exceptional case the hash necessarily agrees with the hash of the corresponding element of the integral domain and therefore can be computed without any trouble.

I (re)implemented hashing for elements of Q(R[X]) with R an integral domain, by passing from Q(R[X]) to Q(Q(R)[X]), reducing to the case of this bug. I haven't pushed this, as I don't like the architecture in my patch and that should probably be a separate bug anyway. There should probably be separate bug reports for many kinds of rings.


---

Comment by rws created at 2014-05-10 09:51:55

Changing status from needs_review to needs_work.


---

Comment by rws created at 2014-05-10 09:51:55

patchbot:

```
sage -t --long src/sage/tests/book_schilling_zabrocki_kschur_primer.py  # 28 doctests failed
sage -t --long src/sage/combinat/sf/macdonald.py  # 8 doctests failed
sage -t --long src/sage/algebras/iwahori_hecke_algebra.py  # 1 doctest failed
sage -t --long src/sage/combinat/sf/sfa.py  # 8 doctests failed
sage -t --long src/sage/combinat/k_tableau.py  # 2 doctests failed
sage -t --long src/sage/schemes/projective/projective_morphism.py  # 1 doctest failed
sage -t --long src/sage/matrix/matrix2.pyx  # 6 doctests failed
sage -t --long src/sage/combinat/sf/k_dual.py  # 52 doctests failed
sage -t --long src/sage/rings/function_field/function_field.py  # 32 doctests failed
sage -t --long src/sage/combinat/sf/llt.py  # 49 doctests failed
sage -t --long src/sage/schemes/elliptic_curves/ell_point.py  # 8 doctests failed
sage -t --long src/sage/combinat/sf/new_kschur.py  # 10 doctests failed
sage -t --long src/sage/combinat/sf/jack.py  # 72 doctests failed
sage -t --long src/sage/rings/polynomial/multi_polynomial_ideal.py  # Killed due to terminate
sage -t --long src/sage/combinat/sf/sf.py  # 15 doctests failed
sage -t --long src/sage/combinat/sf/hall_littlewood.py  # 39 doctests failed
sage -t --long src/sage/modules/free_module_element.pyx  # 4 doctests failed
sage -t --long src/sage/modules/free_module.py  # 2 doctests failed
sage -t --long src/sage/combinat/cluster_algebra_quiver/cluster_seed.py  # 32 doctests failed
sage -t --long src/sage/schemes/toric/ideal.py  # 1 doctest failed
sage -t --long src/sage/categories/pushout.py  # 2 doctests failed
sage -t --long src/sage/categories/quotient_fields.py  # 3 doctests failed
sage -t --long src/sage/matrix/strassen.pyx  # 2 doctests failed
sage -t --long src/sage/calculus/wester.py  # 1 doctest failed
sage -t --long src/sage/algebras/quatalg/quaternion_algebra_element.pyx  # 6 doctests failed
sage -t --long src/sage/schemes/plane_conics/con_field.py  # 5 doctests failed
sage -t --long src/sage/combinat/free_module.py  # 2 doctests failed
sage -t --long src/sage/combinat/species/recursive_species.py  # 1 doctest failed
sage -t --long src/sage/rings/function_field/function_field_ideal.py  # 18 doctests failed
sage -t --long src/sage/combinat/sf/dual.py  # 4 doctests failed
sage -t --long src/sage/rings/function_field/function_field_order.py  # 6 doctests failed
sage -t --long src/sage/combinat/species/product_species.py  # 1 doctest failed
sage -t --long src/sage/combinat/species/species.py  # 2 doctests failed
sage -t --long src/sage/modules/matrix_morphism.py  # 1 doctest failed
sage -t --long src/sage/rings/function_field/function_field_element.pyx  # 10 doctests failed
sage -t --long src/sage/modules/free_quadratic_module.py  # 1 doctest failed
sage -t --long src/sage/rings/polynomial/polynomial_element_generic.py  # 1 doctest failed
sage -t --long src/sage/rings/fraction_field_element.pyx  # 3 doctests failed
sage -t --long src/sage/matrix/tests.py  # 2 doctests failed
sage -t --long src/sage/categories/function_fields.py  # 1 doctest failed
sage -t --long src/sage/combinat/species/sum_species.py  # 1 doctest failed
sage -t --long src/sage/rings/function_field/constructor.py  # 2 doctests failed
```



---

Comment by emassop created at 2014-06-09 19:36:35

#15297 is related


---

Comment by emassop created at 2014-09-16 14:18:56

#16993 is related.


---

Comment by emassop created at 2014-09-16 14:19:54

Also, I sadly don't currently have time to work on this. In fact, I don't think I'll have time until spring.


---

Comment by jakobkroeker created at 2017-03-04 00:37:01

ping


---

Comment by mmezzarobba created at 2018-04-23 17:21:04

Replying to [comment:5 cremona]:
> Thanks, Robert, I will review this.  I had already started by patching the reduce function but had not yet discoivered where the automatic calling of reduction was actually happening.  Your solution -- keeping reduce() and normalise() separate -- looks better.

IMO having `reduce()` normalize the leading coefficient is actually a better choice, because it helps limiting coefficient blow-up in computations with rational functions.

Here is another attempt that does that. See the commit messages for more information. (Addendum: this fixes #16993. Fixing #15297 in full generality requires more work, but could be done as a follow-up.)
----
New commits:


---

Comment by mmezzarobba created at 2018-04-23 17:21:04

Changing status from needs_work to needs_review.


---

Comment by git created at 2018-04-24 07:07:58

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-04-24 12:48:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-04-24 15:41:28

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2018-04-24 15:42:56

Replying to [comment:26 git]:
> ||[77dc9e1](https://git.sagemath.org/sage.git/commit/?id=77dc9e1eda2e55bc4dcbe8556cf138f75086289d)||`FractionFieldElement: merge reduce() and normalize()`||

Replaced a nbsp by a plain ascii space; all tests passed before.


---

Comment by git created at 2018-04-25 06:42:29

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2018-04-25 06:43:17

Replying to [comment:28 git]:
> Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
> ||[daec622](https://git.sagemath.org/sage.git/commit/?id=daec622b57a0b75e4241e7d406880cfab73272c1)||`#16268 boring doctest updates`||
> ||[3cf5014](https://git.sagemath.org/sage.git/commit/?id=3cf5014d43785fd384204981ead86702a3ea1662)||`#16268 other doctest updates`||

Updated an optional test.


---

Comment by git created at 2018-05-11 18:33:20

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-05-11 18:46:33

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2018-05-12 06:22:55

Changing status from needs_review to needs_work.


---

Comment by git created at 2018-05-12 06:43:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-12 08:13:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2018-05-12 08:13:54

Changing status from needs_work to needs_review.


---

Comment by mmezzarobba created at 2018-05-12 08:17:29

The only nontrivial doctest update in the last commit should be the one in `endPN_automorphism_group.three_stable_points()`; I think it is correct, but it would be nice if someone who actually understands what it is about could double-check.


---

Comment by bhutz created at 2018-05-12 18:39:53

Yes, the doc test change in three_stable_points is fine.


---

Comment by emassop created at 2018-05-12 19:47:46

In [c16d55a247b21d6c46d00f603ca21d7d6d64db19](https://git.sagemath.org/sage.git/commit/?id=c16d55a247b21d6c46d00f603ca21d7d6d64db19), "EXAMPLES::" became "EXAMPLES:". IIRC double colons are needed to use the examples in a doctest, or at least for formatting of the documentation (per https://devguide.python.org/documenting/#source-code). Please put the double colons back.

In [7c8a45abecdf5224c9f0a324447ba69db22057b5](https://git.sagemath.org/sage.git/commit/?id=7c8a45abecdf5224c9f0a324447ba69db22057b5) hashes are computed for inexact rings without reduction. This means that python-equal fraction field elements can have distinct hashes, violating the preconditions of hashing in python. I would prefer to err on the side of caution and raise an exception rather than introducing a pathway for bugs that will be hard to find. If you decide to go the other way, please consider removing [198c0596630bb4ecc200e62c55715441e6f38d5c](https://git.sagemath.org/sage.git/commit/?id=198c0596630bb4ecc200e62c55715441e6f38d5c) from the history as its intended effect is completely undone.


---

Comment by mmezzarobba created at 2018-05-14 10:40:07

Thanks for your comments!

Replying to [comment:38 emassop]:
> In [c16d55a247b21d6c46d00f603ca21d7d6d64db19](https://git.sagemath.org/sage.git/commit/?id=c16d55a247b21d6c46d00f603ca21d7d6d64db19), "EXAMPLES::" became "EXAMPLES:". IIRC double colons are needed to use the examples in a doctest, or at least for formatting of the documentation (per https://devguide.python.org/documenting/#source-code). Please put the double colons back.

They are still there, after the introductory sentence instead of the "EXAMPLES:" heading.

> In [7c8a45abecdf5224c9f0a324447ba69db22057b5](https://git.sagemath.org/sage.git/commit/?id=7c8a45abecdf5224c9f0a324447ba69db22057b5) hashes are computed for inexact rings without reduction. This means that python-equal fraction field elements can have distinct hashes, violating the preconditions of hashing in python. I would prefer to err on the side of caution and raise an exception rather than introducing a pathway for bugs that will be hard to find. If you decide to go the other way, please consider removing [198c0596630bb4ecc200e62c55715441e6f38d5c](https://git.sagemath.org/sage.git/commit/?id=198c0596630bb4ecc200e62c55715441e6f38d5c) from the history as its intended effect is completely undone.

I don't like that either. But over an inexact ring, the precondition of hashing would be violated anyway, because of the round-off errors during the computation of the reduction and the equality test. So what I'm suggesting in order to move forward is to keep the broken hash in this case, to be closer to bug-for-bug compatibility with the historic implementation...

This issue with equality appears almost everywhere in Sage, and unfortunately, I think we have to live with it. The only real fix IMO would be to drop the use of `==` for mathematical equality, define it to mean “syntactic” equality of the data structures (after normalization when relevant) instead, and introduce a separate method for mathematical equality. But that's not going to happen without a Sage fork at least, I guess...


---

Comment by emassop created at 2018-05-15 10:53:13

Regarding EXAMPLES: Ah, I didn't notice that. Sorry.


Regarding hashing: How about emitting a warning? (sage.misc.superseded.warning?) Then computations keep working bug-for-bug, but the user is at least made aware that something may be going wrong. I can't recall if there was a policy for or against this.

I am aware that in general sage does not guarantee "`x == y` implies `hash(x) == hash(y)`", but if I recall correctly, it did strive to uphold this implication when `x` and `y` have the same parent.


A point on API: Although I can believe that always making the denominator monic is a good thing, merging `normalize` into `reduce` means that there no longer is a method that guarantees a normal form. Instead `reduce` now maybe normalizes the numerator and denominator or maybe not, depending on the implementation. Would it perhaps make sense to have a bool `_normalized` (instead of or in addition to `_reduced`) that gets set when `reduce` has succeeded at normalization? This doesn't have to be done as part of this bug though.


---

Comment by mmezzarobba created at 2018-05-15 18:44:31

Replying to [comment:41 emassop]:
> Regarding hashing: How about emitting a warning? (sage.misc.superseded.warning?) Then computations keep working bug-for-bug, but the user is at least made aware that something may be going wrong. I can't recall if there was a policy for or against this.

I'll try that and look again at the test failures to see what makes sense.

> I am aware that in general sage does not guarantee "`x == y` implies `hash(x) == hash(y)`", but if I recall correctly, it did strive to uphold this implication when `x` and `y` have the same parent.

Yes. But even that is not always possible, unfortunately.

> A point on API: Although I can believe that always making the denominator monic is a good thing, merging `normalize` into `reduce` means that there no longer is a method that guarantees a normal form. Instead `reduce` now maybe normalizes the numerator and denominator or maybe not, depending on the implementation.

Depending whether we are working with univariate rational function over a field or not, actually, isn't it?

> Would it perhaps make sense to have a bool `_normalized` (instead of or in addition to `_reduced`) that gets set when `reduce` has succeeded at normalization? This doesn't have to be done as part of this bug though.

I'm not sure. This is also related to the issue of provinding a normal form for more general fraction field elements (starting with rational functions over non-fields, I guess), and hence I agree that this would best be kept for another ticket.


---

Comment by emassop created at 2018-05-15 21:16:57

Replying to [comment:42 mmezzarobba]:
> > Regarding hashing: How about emitting a warning? (sage.misc.superseded.warning?) Then computations keep working bug-for-bug, but the user is at least made aware that something may be going wrong. I can't recall if there was a policy for or against this.
> I'll try that and look again at the test failures to see what makes sense.

Thanks, I'll wait for the result.

> > A point on API: Although I can believe that always making the denominator monic is a good thing, merging `normalize` into `reduce` means that there no longer is a method that guarantees a normal form. Instead `reduce` now maybe normalizes the numerator and denominator or maybe not, depending on the implementation.
> 
> Depending whether we are working with univariate rational function over a field or not, actually, isn't it?
>
> > Would it perhaps make sense to have a bool `_normalized` (instead of or in addition to `_reduced`) that gets set when `reduce` has succeeded at normalization? This doesn't have to be done as part of this bug though.
> 
> I'm not sure. This is also related to the issue of providing a normal form for more general fraction field elements (starting with rational functions over non-fields, I guess), and hence I agree that this would best be kept for another ticket.

With the current implementation "is this a univariate rational function over a field" is the criterion, yes. The point is that the criterion changes when the implementation changes, and no one will know except by looking at the code for their specific kind of base ring.

(For instance the present normalization easily generalizes to the multivariate case by looking at the leading coefficient for some [monomial order](https://en.wikipedia.org/wiki/Monomial_order).)

I was hoping for a convincing argument on why making `reduce` more powerful is better than keeping `normalize` around, as my initial preference would be towards `normalize` because I generally prefer explicit over implicit.


---

Comment by mmezzarobba created at 2018-05-17 14:26:59

Replying to [comment:43 emassop]:
> > I'll try that and look again at the test failures to see what makes sense.
> 
> Thanks, I'll wait for the result.

Ok, the only failures I'm seeing are in `src/sage/modular/modform_hecketriangle/` and apparently come from the fact that `FormsRingElement` inherits from `UniqueRepresentation` but is sometimes called on fractions with floating-point coefficients. I guess it would be possible to port it to `UniqueFactory` and somehow preprocess the arguments to avoid the warning.

However, I wonder if it wouldn't be better to keep `__hash__()` as it is now, and have `==` over inexact rings return `True` only when the fractions are equal _without reduction_. Then, hashing would be consistent with equality, the (arguably valid) use case of indexing a table by inexact fractions would work without warning, and hashing wouldn't break the promise that fractions over inexact ring are not automatically reduced. For `==`, this would consistent with the semantics of equality in “difficult” cases like interval arithmetic and symbolic expressions, where `a == b` may return `False` in cases where `a` and `b` are actually equal but that could not be verified. (Not for `!=`, though, but I don't see what we could do about that.)

What do you think?

> With the current implementation "is this a univariate rational function over a field" is the criterion, yes. The point is that the criterion changes when the implementation changes, and no one will know except by looking at the code for their specific kind of base ring.
> 
> (For instance the present normalization easily generalizes to the multivariate case by looking at the leading coefficient for some [monomial order](https://en.wikipedia.org/wiki/Monomial_order).)
> 
> I was hoping for a convincing argument on why making `reduce` more powerful is better than keeping `normalize` around, as my initial preference would be towards `normalize` because I generally prefer explicit over implicit.

Essentially, I agree with you. I'm just saying that I'd rather keep that question for later, and address it once we have a way of normalizing in more general situations, probably along the lines of what you suggested at #16993.


---

Comment by mmezzarobba created at 2018-05-18 06:18:18

FWIW, all tests pass with

```diff

}}}diff --git a/src/sage/modular/modform_hecketriangle/graded_ring_element.py b/src/sage/modular/modform_hecketriangle/graded_ring_element.py
index be3b1e614b..5b41348c07 100644
--- a/src/sage/modular/modform_hecketriangle/graded_ring_element.py
+++ b/src/sage/modular/modform_hecketriangle/graded_ring_element.py
@@ -156,7 +156,7 @@ class FormsRingElement(six.with_metaclass(
             sage: MeromorphicModularFormsRing()(-1/x) == MeromorphicModularFormsRing()(1/(-x))
             True
             sage: MeromorphicModularFormsRing(base_ring=CC)(-1/x) == MeromorphicModularFormsRing()(1/(-x))
-            True
+            False
         """
         if op not in [op_EQ, op_NE]:
             return NotImplemented
diff --git a/src/sage/rings/fraction_field_element.pyx b/src/sage/rings/fraction_field_element.pyx
index 3013a7b3af..3b221ddf4b 100644
--- a/src/sage/rings/fraction_field_element.pyx
+++ b/src/sage/rings/fraction_field_element.pyx
@@ -894,14 +894,16 @@ cdef class FractionFieldElement(FieldElement):
             True
         """
         cdef FractionFieldElement other = other_
-        if ((op == Py_EQ or op == Py_NE)
-                and self.__denominator == other.__denominator):
-            return richcmp(self.__numerator, other.__numerator, op)
-        else:
-            return richcmp(
-                    self.__numerator * other.__denominator,
-                    self.__denominator * other.__numerator,
-                    op)
+        if (op == Py_EQ or op == Py_NE):
+            if self.__denominator == other.__denominator:
+                return richcmp(self.__numerator, other.__numerator, op)
+            elif not self._parent.is_exact():
+                # over inexact rings, compare unreduced representations
+                return op == Py_NE
+        return richcmp(
+                self.__numerator * other.__denominator,
+                self.__denominator * other.__numerator,
+                op)
 
     def valuation(self, v=None):
         """
@@ -1150,7 +1152,8 @@ cdef class FractionFieldElement_1poly_field(FractionFieldElement):
         if op == Py_EQ or op == Py_NE:
             if self.__denominator == other.__denominator:
                 return richcmp(self.__numerator, other.__numerator, op)
-            elif self._is_reduced and other._is_reduced:
+            elif (self._is_reduced and other._is_reduced
+                    or not self._parent.is_exact()):
                 return op == Py_NE
         return richcmp(
                 self.__numerator * other.__denominator,


---

Comment by git created at 2018-05-19 09:01:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2018-05-19 09:04:01

Rebased on the last beta due to a minor conflict.


---

Comment by git created at 2018-05-29 08:58:24

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mmezzarobba created at 2018-05-29 09:05:43

Replying to [comment:48 git]:
> Branch pushed to git repo; I updated commit sha1. This was a forced push.

Rebased and fixed minor test failure.


---

Comment by git created at 2018-06-10 12:48:01

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mmezzarobba created at 2018-06-10 12:49:22

Rebased on 8.3.beta5 to add a minor doctest update.


---

Comment by saraedum created at 2018-06-11 06:20:45

This seems wrong:

```diff
-            ((1 + O(2)))/((1 + O(2^5))*x)
+            ((1 + O(2)))/((1 + O(2))*x)
```


But let's discuss this at #25318.


---

Comment by mmezzarobba created at 2018-06-11 08:50:27

Replying to [comment:52 saraedum]:
> This seems wrong:
> {{{#!diff
> -            ((1 + O(2)))/((1 + O(2^5))*x)
> +            ((1 + O(2)))/((1 + O(2))*x)
> }}}
> 
> But let's discuss this at #25318.

Why? Isn't it the same result, just written in a different way?


---

Comment by saraedum created at 2018-06-11 15:21:33

Oops, sorry. I guess you're right.

Replying to [comment:53 mmezzarobba]:
> Replying to [comment:52 saraedum]:
> > This seems wrong:
> > {{{#!diff
> > -            ((1 + O(2)))/((1 + O(2^5))*x)
> > +            ((1 + O(2)))/((1 + O(2))*x)
> > }}}
> > 
> > But let's discuss this at #25318.
> 
> Why? Isn't it the same result, just written in a different way?


---

Comment by git created at 2018-06-24 11:36:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2018-07-02 08:09:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by saraedum created at 2018-07-03 15:34:21

If you are confident that the output in the doctests is still correct (I did not check all of them) then feel free to set this to positive review.


---

Comment by mmezzarobba created at 2018-07-03 16:40:02

Thank you!


---

Comment by mmezzarobba created at 2018-07-03 16:40:02

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-08-09 21:32:25

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2018-08-09 21:32:25

Merge conflict


---

Comment by mmezzarobba created at 2018-08-14 13:56:05

Replying to [comment:60 vbraun]:
> Merge conflict

Should be fixed. Back to needs_review mainly for the patchbot; there shouldn't be any nontrivial changes to review.


---

Comment by mmezzarobba created at 2018-08-14 13:56:05

Changing status from needs_work to needs_review.


---

Comment by git created at 2018-08-14 14:07:38

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by mmezzarobba created at 2018-08-15 08:52:17

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-08-25 11:01:33

Resolution: fixed


---

Comment by mkoeppe created at 2018-09-14 04:35:34

#16993 should probably be closed as a dup of this ticket.

Also, should there be a follow-up ticket for the desirable further improvements mentioned in the ticket description?


---

Comment by mmezzarobba created at 2018-09-22 14:41:37

Replying to [comment:65 mkoeppe]:
> #16993 should probably be closed as a dup of this ticket.

Yes, thanks, I had forgotten to do that.

> Also, should there be a follow-up ticket for the desirable further improvements mentioned in the ticket description?

Please go ahead if you want to open additional tickets and/or work on these improvements. (I have little time to work on them myself at the moment, unfortunately, but feel free to ping me if some follow-up ticket needs review.)


---

Comment by mkoeppe created at 2018-09-22 19:18:34

Follow-up ticket at #26339
