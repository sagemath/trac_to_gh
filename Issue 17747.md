# Issue 17747: Dedicated RR.__contains__() and CC.__contains__()

Issue created by migration from https://trac.sagemath.org/ticket/17984

Original creator: rws

Original creation time: 2015-03-18 09:59:31

CC:  tmonteil

In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.

Moreover, until now Maxima is used for this which is slow and completely unnecessary.


---

Comment by rws created at 2015-03-18 10:01:42

Changing status from new to needs_review.


---

Comment by rws created at 2015-03-18 10:01:42

New commits:


---

Comment by jdemeyer created at 2015-03-18 13:11:41

Replying to [ticket:17984 rws]:
> In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`

Can you clarify this please?


---

Comment by jdemeyer created at 2015-03-18 13:13:55


```
sage: RealField(10)(1/3) in RR
True
sage: RealField(10)(1/3) in CC
False
```



---

Comment by jdemeyer created at 2015-03-18 13:13:55

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2015-03-18 13:14:16

Why this???

```
sage: [1,2,3] in CC
True
```



---

Comment by jdemeyer created at 2015-03-18 13:14:41

I also think this is wrong:

```
sage: NaN in RR
True
```



---

Comment by jdemeyer created at 2015-03-18 13:19:49

Also please explain why you use `ComplexField()` in the code for `RR`.


---

Comment by rws created at 2015-03-18 14:40:41

Replying to [comment:3 jdemeyer]:
> Replying to [ticket:17984 rws]:
> > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`
> 
> Can you clarify this please?

See comment 28 of #12967.


---

Comment by rws created at 2015-03-18 15:05:54

Replying to [comment:4 jdemeyer]:
> {{{
> sage: RealField(10)(1/3) in RR
> True
> sage: RealField(10)(1/3) in CC
> False
> }}}
Clever. But before I fix this: What about the doctests? Do you think that any of them gives a wrong result? Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?


---

Comment by rws created at 2015-03-18 15:25:05

Replying to [comment:6 jdemeyer]:
> I also think this is wrong:
> {{{
> sage: NaN in RR
> True
> }}}
If so, then I think this is wrong, too:

```
sage: RR(NaN)
NaN
sage: type(_)
<type 'sage.rings.real_mpfr.RealNumber'>
```



---

Comment by git created at 2015-03-18 16:27:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by rws created at 2015-03-18 16:29:12

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-03-18 16:34:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2015-03-18 16:43:44

Replying to [comment:9 rws]:
> Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?

Yes, I think precision should be ignored for `contains`, therefore don't use `numerical_approx()` but a conversion like `RR(foo)` or `CC(foo)`.


---

Comment by jdemeyer created at 2015-03-18 16:45:20

Replying to [comment:10 rws]:
> If so, then I think this is wrong, too:
> {{{
> sage: RR(NaN)
> NaN
> sage: type(_)
> <type 'sage.rings.real_mpfr.RealNumber'>
> }}}

I don't think the above is wrong, it is possible to represent `NaN` by a `RealNumber`, but that doesn't mean that `NaN` can be considered as element of `RR`.


---

Comment by rws created at 2015-03-18 17:31:01

Replying to [comment:8 rws]:
> Replying to [comment:3 jdemeyer]:
> > Replying to [ticket:17984 rws]:
> > > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`
> > 
> > Can you clarify this please?
> 
> See comment 28 of #12967.
Ah, seems I was chasing ghosts there. Nevertheless the ticket makes sense because of the unreliability of the construction `bool(item==self(item))` for determining elementship.


---

Comment by rws created at 2015-03-19 07:33:37

I'm still pondering if this doctest is wrong:

```
            sage: pi in RIF # there is no element of RIF equal to pi
            False
```



---

Comment by pbruin created at 2015-03-19 09:55:25

Replying to [comment:17 rws]:
> I'm still pondering if this doctest is wrong:
> {{{
>             sage: pi in RIF # there is no element of RIF equal to pi
>             False
> }}}
The answer `False` seems correct to me.  The only numbers that can be represented exactly in `RIF` (i.e. as intervals of length 0) are elements of *Z*[1/2].


---

Comment by rws created at 2015-03-19 14:19:10

Comments 35-44 of #12967 deal with this issue. Apologies for splitting this up.


---

Comment by pbruin created at 2015-03-19 14:41:47

I guess the first basic question is how to resolve the following inconsistency:

```
sage: bool(RR(pi) == pi)
True
sage: bool(RR(sqrt(2)) == sqrt(2))
False
```

The second basic question is, if we agree on what the correct result is, is this also the result that `x in RR` should return?

Personally I would answer the second question with "yes", if only for consistency; there is undoubtedly a lot of code using `x in P` that expects this behaviour, and it would be very inconvenient to change this just for `P = RR` and `P = CC` because of what users intuitively expect when typing `x in RR`.

The first question is harder.  One could argue that `bool(RR(pi) == pi)` should indeed return `True` because the two numbers become equal when converting to the lowest common precision (just as is done when comparing elements of two instances of `RealField` with different precision).  On the other hand, this is dangerous due to rounding errors:

```
sage: def t(x): return bool(RR(x) == x)
sage: t(sqrt(2))
False
sage: t(sqrt(3))
False
sage: t(sqrt(3) - sqrt(2))
True
```

Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.  Unfortunately this moves `RR` a bit further away from the mathematical field *R* than it already is, but I guess that is better than pretending that `RR` is a general-purpose model for *R*.


---

Comment by rws created at 2015-03-20 10:12:55

Replying to [comment:20 pbruin]:
> I guess the first basic question is how to resolve the following inconsistency:
> {{{
> sage: bool(RR(pi) == pi)
> True
> sage: bool(RR(sqrt(2)) == sqrt(2))
> False
> }}}
>...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. 
And inexact elements compare the precision? And this condition would be the same for other inexact fields?

This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship. So we again have special code, though it's special for inexact fields and it's not necessary to write it for every class.


---

Comment by pbruin created at 2015-03-20 10:57:09

Replying to [comment:21 rws]:
> Replying to [comment:20 pbruin]:
> > I guess the first basic question is how to resolve the following inconsistency:
> > {{{
> > sage: bool(RR(pi) == pi)
> > True
> > sage: bool(RR(sqrt(2)) == sqrt(2))
> > False
> > }}}
> >...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. 
> And inexact elements compare the precision? And this condition would be the same for other inexact fields?
I didn't say anytyhing about the case where `x` is an element of an inexact ring.  Currently (I think), if `x.parent() == RealField(m)`, then `x in RealField(n)` will return `True` regardless of `m` and `n`.  This could be changed of course, but that would break the general "philosophy" that Sage has been following so far (elements are compared in the ring with the lowest precision).
> This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship.
I don't understand this; the fact that `x` can be converted into `RR` does not imply that it is an element of `RR`.  The element `RR(x)` is just some candidate for "the element of `RR` that is equal to `x`", but we don't yet know if `x` and `RR(x)` are indeed equal in a meaningful way.  I guess you are talking about the case where `x.parent() is SR`.  Doesn't `bool(RR(x) == x)` then compare two elements of `SR`, one being the original `x` and the other being the result of converting to `RR` and back?  These can still be compared in a non-trivial way.


---

Comment by rws created at 2015-03-20 13:50:57

Never mind. My mistake was to think that I needed `RR` to check your condition, but I can just check if `RR(x)` has finite precision.


---

Comment by rws created at 2015-03-21 07:25:42

Replying to [comment:20 pbruin]:
> Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.
Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.

So, either no integers and rationals are `in RR`, or `RR` elements must carry an exact flag that is set to `False` when an operation with an inexact element is performed, or, most probably, I'm missing something about how to spot elements with exact representation in `RR/CC`. I cannot imagine you would mean `1` is exactly representable in `RR` because `1 == RR(1)`, since that would obviously be circular with your definition.


---

Comment by pbruin created at 2015-03-21 07:57:30

Replying to [comment:24 rws]:
> Replying to [comment:20 pbruin]:
> > Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.
> Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.
Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.

Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.  The interpretation "an element of `RR` is a real number with some error" is just interpretation.  One could say that what is inexact about `RR` are not the elements themselves, but the operations; rounding has to take place because this subset is not closed under the usual operations.

A related `sage-devel` discussion: https://groups.google.com/forum/#!topic/sage-devel/1gPkeL_X5dw


---

Comment by rws created at 2015-03-21 08:52:18

Replying to [comment:25 pbruin]:
> Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.
So this would be similar (equal?) to what was recently said about `RIF` in https://groups.google.com/d/topic/sage-devel/9MHkb4cUUHM/discussion

> Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.
So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.


---

Comment by rws created at 2015-03-21 09:01:03

> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.
Note that at the moment `1/5 == RR(1/5)`.


---

Comment by rws created at 2015-03-21 09:53:56

Replying to [comment:26 rws]:
> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.
Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.


---

Comment by vdelecroix created at 2015-03-21 10:01:16

Replying to [comment:28 rws]:
> Replying to [comment:26 rws]:
> > So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.
> Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.

This method makes sense in `RIF` but not in `RR`: a number is exact in `RIF` if the associated interval is a singleton. This is very different from the proposition of having a method `RR.is_exactly_representable(...)`.

I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field

``` 
sage: RR.is_field()
True
sage: RR in Fields()
True
```


Vincent


---

Comment by rws created at 2015-03-21 14:04:58

Replying to [comment:29 vdelecroix]:
> I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field
What would be consequences of removing it from the set (apart from documentation issues)?


---

Comment by rws created at 2015-03-21 14:04:58

Changing status from needs_review to needs_info.


---

Comment by rws created at 2015-05-24 16:03:26

Ping?


---

Comment by rws created at 2015-09-20 13:47:56

Changing status from needs_info to needs_work.


---

Comment by rws created at 2015-09-20 13:47:56

This issue has come up again with working on #19040. This is intolerable. I will have to have a new attempt at this, maybe I understand the arguments better now.


---

Comment by rws created at 2015-09-20 13:47:56

Changing type from enhancement to defect.


---

Comment by rws created at 2015-09-20 15:48:25

The solution is quite simple with #19040 (which is no completely here yet).
----
New commits:


---

Comment by rws created at 2018-01-15 08:36:56

Unexpectedly it looks like we get a much more correct fix whenever we'll have #24456.
