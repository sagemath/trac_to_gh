# Issue 17747: Dedicated RR.__contains__() and CC.__contains__()

archive/issues_017747.json:
```json
{
    "body": "CC:  tmonteil\n\nIn the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.\n\nMoreover, until now Maxima is used for this which is slow and completely unnecessary.\n\nIssue created by migration from https://trac.sagemath.org/ticket/17984\n\n",
    "created_at": "2015-03-18T09:59:31Z",
    "labels": [
        "component: basic arithmetic"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.9",
    "title": "Dedicated RR.__contains__() and CC.__contains__()",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17747",
    "user": "https://github.com/rwst"
}
```
CC:  tmonteil

In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC` despite `bool(RR/CC(sqrt(3))==sqrt(3))` being `False`. In order to fix the bug fix (in a separate ticket) dedicated `__contains__` methods for both rings are needed.

Moreover, until now Maxima is used for this which is slow and completely unnecessary.

Issue created by migration from https://trac.sagemath.org/ticket/17984





---

archive/issue_comments_237438.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-03-18T10:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237438",
    "user": "https://github.com/rwst"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_237439.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-03-18T10:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237439",
    "user": "https://github.com/rwst"
}
```

New commits:



---

archive/issue_comments_237440.json:
```json
{
    "body": "Replying to [ticket:17984 rws]:\n> In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`\n\n\nCan you clarify this please?",
    "created_at": "2015-03-18T13:11:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237440",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [ticket:17984 rws]:
> In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`


Can you clarify this please?



---

archive/issue_comments_237441.json:
```json
{
    "body": "```\nsage: RealField(10)(1/3) in RR\nTrue\nsage: RealField(10)(1/3) in CC\nFalse\n```",
    "created_at": "2015-03-18T13:13:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237441",
    "user": "https://github.com/jdemeyer"
}
```

```
sage: RealField(10)(1/3) in RR
True
sage: RealField(10)(1/3) in CC
False
```



---

archive/issue_comments_237442.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-03-18T13:13:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237442",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_237443.json:
```json
{
    "body": "Why this???\n\n```\nsage: [1,2,3] in CC\nTrue\n```",
    "created_at": "2015-03-18T13:14:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237443",
    "user": "https://github.com/jdemeyer"
}
```

Why this???

```
sage: [1,2,3] in CC
True
```



---

archive/issue_comments_237444.json:
```json
{
    "body": "I also think this is wrong:\n\n```\nsage: NaN in RR\nTrue\n```",
    "created_at": "2015-03-18T13:14:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237444",
    "user": "https://github.com/jdemeyer"
}
```

I also think this is wrong:

```
sage: NaN in RR
True
```



---

archive/issue_comments_237445.json:
```json
{
    "body": "Also please explain why you use `ComplexField()` in the code for `RR`.",
    "created_at": "2015-03-18T13:19:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237445",
    "user": "https://github.com/jdemeyer"
}
```

Also please explain why you use `ComplexField()` in the code for `RR`.



---

archive/issue_comments_237446.json:
```json
{
    "body": "Replying to [comment:3 jdemeyer]:\n> Replying to [ticket:17984 rws]:\n> > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`\n\n> \n> Can you clarify this please?\n\n\nSee comment 28 of #12967.",
    "created_at": "2015-03-18T14:40:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237446",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:3 jdemeyer]:
> Replying to [ticket:17984 rws]:
> > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`

> 
> Can you clarify this please?


See comment 28 of #12967.



---

archive/issue_comments_237447.json:
```json
{
    "body": "Replying to [comment:4 jdemeyer]:\n> {{{\n> sage: RealField(10)(1/3) in RR\n> True\n> sage: RealField(10)(1/3) in CC\n> False\n> }}}\nClever. But before I fix this: What about the doctests? Do you think that any of them gives a wrong result? Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?",
    "created_at": "2015-03-18T15:05:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237447",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:4 jdemeyer]:
> {{{
> sage: RealField(10)(1/3) in RR
> True
> sage: RealField(10)(1/3) in CC
> False
> }}}
Clever. But before I fix this: What about the doctests? Do you think that any of them gives a wrong result? Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?



---

archive/issue_comments_237448.json:
```json
{
    "body": "Replying to [comment:6 jdemeyer]:\n> I also think this is wrong:\n> \n> ```\n> sage: NaN in RR\n> True\n> ```\n\nIf so, then I think this is wrong, too:\n\n```\nsage: RR(NaN)\nNaN\nsage: type(_)\n<type 'sage.rings.real_mpfr.RealNumber'>\n```",
    "created_at": "2015-03-18T15:25:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237448",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:6 jdemeyer]:
> I also think this is wrong:
> 
> ```
> sage: NaN in RR
> True
> ```

If so, then I think this is wrong, too:

```
sage: RR(NaN)
NaN
sage: type(_)
<type 'sage.rings.real_mpfr.RealNumber'>
```



---

archive/issue_comments_237449.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-18T16:27:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237449",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_237450.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-03-18T16:29:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237450",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_237451.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-18T16:34:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237451",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_237452.json:
```json
{
    "body": "Replying to [comment:9 rws]:\n> Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?\n\n\nYes, I think precision should be ignored for `contains`, therefore don't use `numerical_approx()` but a conversion like `RR(foo)` or `CC(foo)`.",
    "created_at": "2015-03-18T16:43:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237452",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:9 rws]:
> Do you agree that precision issue should be ignored when it comes to the behaviour of the `contains` function?


Yes, I think precision should be ignored for `contains`, therefore don't use `numerical_approx()` but a conversion like `RR(foo)` or `CC(foo)`.



---

archive/issue_comments_237453.json:
```json
{
    "body": "Replying to [comment:10 rws]:\n> If so, then I think this is wrong, too:\n> \n> ```\n> sage: RR(NaN)\n> NaN\n> sage: type(_)\n> <type 'sage.rings.real_mpfr.RealNumber'>\n> ```\n\n\nI don't think the above is wrong, it is possible to represent `NaN` by a `RealNumber`, but that doesn't mean that `NaN` can be considered as element of `RR`.",
    "created_at": "2015-03-18T16:45:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237453",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:10 rws]:
> If so, then I think this is wrong, too:
> 
> ```
> sage: RR(NaN)
> NaN
> sage: type(_)
> <type 'sage.rings.real_mpfr.RealNumber'>
> ```


I don't think the above is wrong, it is possible to represent `NaN` by a `RealNumber`, but that doesn't mean that `NaN` can be considered as element of `RR`.



---

archive/issue_comments_237454.json:
```json
{
    "body": "Replying to [comment:8 rws]:\n> Replying to [comment:3 jdemeyer]:\n> > Replying to [ticket:17984 rws]:\n> > > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`\n\n> > \n> > Can you clarify this please?\n\n> \n> See comment 28 of #12967.\n\nAh, seems I was chasing ghosts there. Nevertheless the ticket makes sense because of the unreliability of the construction `bool(item==self(item))` for determining elementship.",
    "created_at": "2015-03-18T17:31:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237454",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:8 rws]:
> Replying to [comment:3 jdemeyer]:
> > Replying to [ticket:17984 rws]:
> > > In the catch-all `structure/parent.pyx:Parent.__contains__` we depend on a bug to get the right result for, e.g. `sqrt(3) in RR/CC`

> > 
> > Can you clarify this please?

> 
> See comment 28 of #12967.

Ah, seems I was chasing ghosts there. Nevertheless the ticket makes sense because of the unreliability of the construction `bool(item==self(item))` for determining elementship.



---

archive/issue_comments_237455.json:
```json
{
    "body": "I'm still pondering if this doctest is wrong:\n\n```\n            sage: pi in RIF # there is no element of RIF equal to pi\n            False\n```",
    "created_at": "2015-03-19T07:33:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237455",
    "user": "https://github.com/rwst"
}
```

I'm still pondering if this doctest is wrong:

```
            sage: pi in RIF # there is no element of RIF equal to pi
            False
```



---

archive/issue_comments_237456.json:
```json
{
    "body": "Replying to [comment:17 rws]:\n> I'm still pondering if this doctest is wrong:\n> \n> ```\n>             sage: pi in RIF # there is no element of RIF equal to pi\n>             False\n> ```\n\nThe answer `False` seems correct to me.  The only numbers that can be represented exactly in `RIF` (i.e. as intervals of length 0) are elements of **Z**[1/2].",
    "created_at": "2015-03-19T09:55:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237456",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:17 rws]:
> I'm still pondering if this doctest is wrong:
> 
> ```
>             sage: pi in RIF # there is no element of RIF equal to pi
>             False
> ```

The answer `False` seems correct to me.  The only numbers that can be represented exactly in `RIF` (i.e. as intervals of length 0) are elements of **Z**[1/2].



---

archive/issue_comments_237457.json:
```json
{
    "body": "Comments 35-44 of #12967 deal with this issue. Apologies for splitting this up.",
    "created_at": "2015-03-19T14:19:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237457",
    "user": "https://github.com/rwst"
}
```

Comments 35-44 of #12967 deal with this issue. Apologies for splitting this up.



---

archive/issue_comments_237458.json:
```json
{
    "body": "I guess the first basic question is how to resolve the following inconsistency:\n\n```\nsage: bool(RR(pi) == pi)\nTrue\nsage: bool(RR(sqrt(2)) == sqrt(2))\nFalse\n```\nThe second basic question is, if we agree on what the correct result is, is this also the result that `x in RR` should return?\n\nPersonally I would answer the second question with \"yes\", if only for consistency; there is undoubtedly a lot of code using `x in P` that expects this behaviour, and it would be very inconvenient to change this just for `P = RR` and `P = CC` because of what users intuitively expect when typing `x in RR`.\n\nThe first question is harder.  One could argue that `bool(RR(pi) == pi)` should indeed return `True` because the two numbers become equal when converting to the lowest common precision (just as is done when comparing elements of two instances of `RealField` with different precision).  On the other hand, this is dangerous due to rounding errors:\n\n```\nsage: def t(x): return bool(RR(x) == x)\nsage: t(sqrt(2))\nFalse\nsage: t(sqrt(3))\nFalse\nsage: t(sqrt(3) - sqrt(2))\nTrue\n```\nHence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.  Unfortunately this moves `RR` a bit further away from the mathematical field **R** than it already is, but I guess that is better than pretending that `RR` is a general-purpose model for **R**.",
    "created_at": "2015-03-19T14:41:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237458",
    "user": "https://github.com/pjbruin"
}
```

I guess the first basic question is how to resolve the following inconsistency:

```
sage: bool(RR(pi) == pi)
True
sage: bool(RR(sqrt(2)) == sqrt(2))
False
```
The second basic question is, if we agree on what the correct result is, is this also the result that `x in RR` should return?

Personally I would answer the second question with "yes", if only for consistency; there is undoubtedly a lot of code using `x in P` that expects this behaviour, and it would be very inconvenient to change this just for `P = RR` and `P = CC` because of what users intuitively expect when typing `x in RR`.

The first question is harder.  One could argue that `bool(RR(pi) == pi)` should indeed return `True` because the two numbers become equal when converting to the lowest common precision (just as is done when comparing elements of two instances of `RealField` with different precision).  On the other hand, this is dangerous due to rounding errors:

```
sage: def t(x): return bool(RR(x) == x)
sage: t(sqrt(2))
False
sage: t(sqrt(3))
False
sage: t(sqrt(3) - sqrt(2))
True
```
Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.  Unfortunately this moves `RR` a bit further away from the mathematical field **R** than it already is, but I guess that is better than pretending that `RR` is a general-purpose model for **R**.



---

archive/issue_comments_237459.json:
```json
{
    "body": "Replying to [comment:20 pbruin]:\n> I guess the first basic question is how to resolve the following inconsistency:\n> \n> ```\n> sage: bool(RR(pi) == pi)\n> True\n> sage: bool(RR(sqrt(2)) == sqrt(2))\n> False\n> ```\n\n>...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. \nAnd inexact elements compare the precision? And this condition would be the same for other inexact fields?\n\nThis looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship. So we again have special code, though it's special for inexact fields and it's not necessary to write it for every class.",
    "created_at": "2015-03-20T10:12:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237459",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:20 pbruin]:
> I guess the first basic question is how to resolve the following inconsistency:
> 
> ```
> sage: bool(RR(pi) == pi)
> True
> sage: bool(RR(sqrt(2)) == sqrt(2))
> False
> ```

>...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. 
And inexact elements compare the precision? And this condition would be the same for other inexact fields?

This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship. So we again have special code, though it's special for inexact fields and it's not necessary to write it for every class.



---

archive/issue_comments_237460.json:
```json
{
    "body": "Replying to [comment:21 rws]:\n> Replying to [comment:20 pbruin]:\n> > I guess the first basic question is how to resolve the following inconsistency:\n> > \n> > ```\n> > sage: bool(RR(pi) == pi)\n> > True\n> > sage: bool(RR(sqrt(2)) == sqrt(2))\n> > False\n> > ```\n\n> >...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. \n> And inexact elements compare the precision? And this condition would be the same for other inexact fields?\n\nI didn't say anytyhing about the case where `x` is an element of an inexact ring.  Currently (I think), if `x.parent() == RealField(m)`, then `x in RealField(n)` will return `True` regardless of `m` and `n`.  This could be changed of course, but that would break the general \"philosophy\" that Sage has been following so far (elements are compared in the ring with the lowest precision).\n> This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship.\n\nI don't understand this; the fact that `x` can be converted into `RR` does not imply that it is an element of `RR`.  The element `RR(x)` is just some candidate for \"the element of `RR` that is equal to `x`\", but we don't yet know if `x` and `RR(x)` are indeed equal in a meaningful way.  I guess you are talking about the case where `x.parent() is SR`.  Doesn't `bool(RR(x) == x)` then compare two elements of `SR`, one being the original `x` and the other being the result of converting to `RR` and back?  These can still be compared in a non-trivial way.",
    "created_at": "2015-03-20T10:57:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237460",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:21 rws]:
> Replying to [comment:20 pbruin]:
> > I guess the first basic question is how to resolve the following inconsistency:
> > 
> > ```
> > sage: bool(RR(pi) == pi)
> > True
> > sage: bool(RR(sqrt(2)) == sqrt(2))
> > False
> > ```

> >...Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`. 
> And inexact elements compare the precision? And this condition would be the same for other inexact fields?

I didn't say anytyhing about the case where `x` is an element of an inexact ring.  Currently (I think), if `x.parent() == RealField(m)`, then `x in RealField(n)` will return `True` regardless of `m` and `n`.  This could be changed of course, but that would break the general "philosophy" that Sage has been following so far (elements are compared in the ring with the lowest precision).
> This looks nice, but at the moment that we check the relation (in `Expression.__nonzero__`) the conversion to `RR` has already happened. That means we cannot use the relation to determine elementship.

I don't understand this; the fact that `x` can be converted into `RR` does not imply that it is an element of `RR`.  The element `RR(x)` is just some candidate for "the element of `RR` that is equal to `x`", but we don't yet know if `x` and `RR(x)` are indeed equal in a meaningful way.  I guess you are talking about the case where `x.parent() is SR`.  Doesn't `bool(RR(x) == x)` then compare two elements of `SR`, one being the original `x` and the other being the result of converting to `RR` and back?  These can still be compared in a non-trivial way.



---

archive/issue_comments_237461.json:
```json
{
    "body": "Never mind. My mistake was to think that I needed `RR` to check your condition, but I can just check if `RR(x)` has finite precision.",
    "created_at": "2015-03-20T13:50:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237461",
    "user": "https://github.com/rwst"
}
```

Never mind. My mistake was to think that I needed `RR` to check your condition, but I can just check if `RR(x)` has finite precision.



---

archive/issue_comments_237462.json:
```json
{
    "body": "Replying to [comment:20 pbruin]:\n> Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.\n\nCan you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.\n\nSo, either no integers and rationals are `in RR`, or `RR` elements must carry an exact flag that is set to `False` when an operation with an inexact element is performed, or, most probably, I'm missing something about how to spot elements with exact representation in `RR/CC`. I cannot imagine you would mean `1` is exactly representable in `RR` because `1 == RR(1)`, since that would obviously be circular with your definition.",
    "created_at": "2015-03-21T07:25:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237462",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:20 pbruin]:
> Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.

Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.

So, either no integers and rationals are `in RR`, or `RR` elements must carry an exact flag that is set to `False` when an operation with an inexact element is performed, or, most probably, I'm missing something about how to spot elements with exact representation in `RR/CC`. I cannot imagine you would mean `1` is exactly representable in `RR` because `1 == RR(1)`, since that would obviously be circular with your definition.



---

archive/issue_comments_237463.json:
```json
{
    "body": "Replying to [comment:24 rws]:\n> Replying to [comment:20 pbruin]:\n> > Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.\n\n> Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.\nElements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.\n\nDifferent people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.  The interpretation \"an element of `RR` is a real number with some error\" is just interpretation.  One could say that what is inexact about `RR` are not the elements themselves, but the operations; rounding has to take place because this subset is not closed under the usual operations.\n\nA related `sage-devel` discussion: https://groups.google.com/forum/#!topic/sage-devel/1gPkeL_X5dw",
    "created_at": "2015-03-21T07:57:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237463",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:24 rws]:
> Replying to [comment:20 pbruin]:
> > Hence I am tending towards the opinion that if `x` is some exact element, then `bool(RR(x) == x)` should return `True` if and only if `x` is exactly representable in `RR`.

> Can you please help me with this definition? In my understanding an exact representation has infinite precision (or another bit of information that makes it different from an inexact element). But everything in `RR` has finite `precision()`, even `oo` and `NaN` which by definition are special.
Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.

Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.  The interpretation "an element of `RR` is a real number with some error" is just interpretation.  One could say that what is inexact about `RR` are not the elements themselves, but the operations; rounding has to take place because this subset is not closed under the usual operations.

A related `sage-devel` discussion: https://groups.google.com/forum/#!topic/sage-devel/1gPkeL_X5dw



---

archive/issue_comments_237464.json:
```json
{
    "body": "Replying to [comment:25 pbruin]:\n> Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.\n\nSo this would be similar (equal?) to what was recently said about `RIF` in https://groups.google.com/d/topic/sage-devel/9MHkb4cUUHM/discussion\n\n> Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.\n\nSo, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.",
    "created_at": "2015-03-21T08:52:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237464",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:25 pbruin]:
> Elements of `RR` (except infinities and `NaN`) are certain fractions whose numerator and denominator are bounded and whose denominator is a power of 2.  Hence 1/16 is representable in `RR`, but 1/3 is not.

So this would be similar (equal?) to what was recently said about `RIF` in https://groups.google.com/d/topic/sage-devel/9MHkb4cUUHM/discussion

> Different people have different viewpoints about this, but above I was thinking of elements of `RR` (again except infinities and `NaN`) as exactly representing a certain subset of (mathematical) real numbers.

So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.



---

archive/issue_comments_237465.json:
```json
{
    "body": "> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.\n\nNote that at the moment `1/5 == RR(1/5)`.",
    "created_at": "2015-03-21T09:01:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237465",
    "user": "https://github.com/rwst"
}
```

> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.

Note that at the moment `1/5 == RR(1/5)`.



---

archive/issue_comments_237466.json:
```json
{
    "body": "Replying to [comment:26 rws]:\n> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.\n\nAh okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.",
    "created_at": "2015-03-21T09:53:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237466",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:26 rws]:
> So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.

Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.



---

archive/issue_comments_237467.json:
```json
{
    "body": "Replying to [comment:28 rws]:\n> Replying to [comment:26 rws]:\n> > So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.\n\n> Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.\n\nThis method makes sense in `RIF` but not in `RR`: a number is exact in `RIF` if the associated interval is a singleton. This is very different from the proposition of having a method `RR.is_exactly_representable(...)`.\n\nI do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field\n\n``` \nsage: RR.is_field()\nTrue\nsage: RR in Fields()\nTrue\n```\n\nVincent",
    "created_at": "2015-03-21T10:01:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237467",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:28 rws]:
> Replying to [comment:26 rws]:
> > So, pragmatically, every inexact ring needs a method `is_exactly_representable(item)` in order to determine usefully if `bool(item == RR(item))`.

> Ah okay, `RIF(1/5).is_exact` is implemented so we need the same method elsewhere.

This method makes sense in `RIF` but not in `RR`: a number is exact in `RIF` if the associated interval is a singleton. This is very different from the proposition of having a method `RR.is_exactly_representable(...)`.

I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field

``` 
sage: RR.is_field()
True
sage: RR in Fields()
True
```

Vincent



---

archive/issue_comments_237468.json:
```json
{
    "body": "Replying to [comment:29 vdelecroix]:\n> I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field\n\nWhat would be consequences of removing it from the set (apart from documentation issues)?",
    "created_at": "2015-03-21T14:04:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237468",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:29 vdelecroix]:
> I do not like the fact that we treat `RR` as a subset of the real numbers and at the same time a field

What would be consequences of removing it from the set (apart from documentation issues)?



---

archive/issue_comments_237469.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-03-21T14:04:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237469",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_237470.json:
```json
{
    "body": "Ping?",
    "created_at": "2015-05-24T16:03:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237470",
    "user": "https://github.com/rwst"
}
```

Ping?



---

archive/issue_comments_237471.json:
```json
{
    "body": "Changing status from needs_info to needs_work.",
    "created_at": "2015-09-20T13:47:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237471",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_info to needs_work.



---

archive/issue_comments_237472.json:
```json
{
    "body": "This issue has come up again with working on #19040. This is intolerable. I will have to have a new attempt at this, maybe I understand the arguments better now.",
    "created_at": "2015-09-20T13:47:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237472",
    "user": "https://github.com/rwst"
}
```

This issue has come up again with working on #19040. This is intolerable. I will have to have a new attempt at this, maybe I understand the arguments better now.



---

archive/issue_comments_237473.json:
```json
{
    "body": "Changing type from enhancement to defect.",
    "created_at": "2015-09-20T13:47:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237473",
    "user": "https://github.com/rwst"
}
```

Changing type from enhancement to defect.



---

archive/issue_events_051126.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-09-20T13:47:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "milestone": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17747#event-51126"
}
```



---

archive/issue_comments_237474.json:
```json
{
    "body": "The solution is quite simple with #19040 (which is no completely here yet).\n\n---\nNew commits:",
    "created_at": "2015-09-20T15:48:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237474",
    "user": "https://github.com/rwst"
}
```

The solution is quite simple with #19040 (which is no completely here yet).

---
New commits:



---

archive/issue_comments_237475.json:
```json
{
    "body": "Unexpectedly it looks like we get a much more correct fix whenever we'll have #24456.",
    "created_at": "2018-01-15T08:36:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17747",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17747#issuecomment-237475",
    "user": "https://github.com/rwst"
}
```

Unexpectedly it looks like we get a much more correct fix whenever we'll have #24456.
