# Issue 30840: incorrect determinant of a symbolic matrix

Issue created by migration from https://trac.sagemath.org/ticket/31077

Original creator: @DaveWitteMorris

Original creation time: 2020-12-18 18:56:16

CC:  mjo fchapoton burcin rws behackl kcrisman

Keywords: determinant

As discussed on [sagedevel](https://groups.google.com/g/sage-devel/c/cuYVxld88Ng/m/nNfV4jxBBAAJ), the following determinant is 0, but that's not what sage says:

```
sage: a,b,c,d,e,z = var("a b c d e z") 
....: L = Matrix([
....:     [-a, 1, 0, 0, 0, -4*d/z, 0, 0, 0], 
....:     [1, a - b - 1, 1, 0, 4*d/z, 0, 0, 0, 0], 
....:     [0, 1, b - c + 2, b, 0, 0, 0, 0, 0], 
....:     [0, 0, b, c - 3, 0, 0, 0, 0, 2*e], 
....:     [0, d*z, 0, 0, a, -1, 0, 0, 0], 
....:     [-d*z, 0, 0, 0, -1, -a + b + 1, -1, 0, 0], 
....:     [0, 0, 0, 0, 0, -1, -b + c - 2, -b, 0], 
....:     [0, 0, 0, 0, 0, 0, -b, -c + 3, -e], 
....:     [0, 0, 0, e, 0, 0, 0, -2*e, 0]]) 
....: L.det().factor() # should be 0, but it's not
4*a*b^2*d*e^2*(z + 1)*(z - 1)/z
```

To confirm that the determinant is 0, just multiply the matrix by z, which multiplies the determinant by z<sup>9</sup>:

```
sage: (z*L).det()
0
```

(Calculating in a `LaurentPolynomialRing` also verifies that the determinant is 0.)


---

Comment by @DaveWitteMorris created at 2020-12-18 19:59:58

This seems to be a maxima bug (or a bug in the maxima interface):

```
sage: f(x) = L._maxima_(maxima).charpoly('x')._sage_().expand()
sage: f(0).factor()                                                                                                                                         
4*a*b^2*d*e^2*(z + 1)*(z - 1)/z
```



---

Comment by mantepse created at 2020-12-18 20:15:43

More precisely, it seems to be within the expand method:

```
sage: var = 'A0123456789'
sage: p = L._maxima_(maxima).charpoly(var)._sage_()
sage: fricas(p).series(A0123456789=0) -  fricas(p.expand()).series(A0123456789=0)
         2   2 2        2   2        2   2 2      2   2
  - 4 a b d e z  + 4 a b d e    - 4 b d e z  + 4 b d e
  --------------------------- + ----------------------- A0123456789
               z                           z
+ 
               11
  O(A0123456789  )

```



---

Comment by @DaveWitteMorris created at 2020-12-18 22:56:05

Right, it seems that the problem is with `expand`, and has nothing to do with determinants.  It shows up if I directly define E to be the expression that is called `f(x)` above.

```
sage: E1 = """-4*(a - x)*b^2*d*e^2*z - (b^2*x + ((b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2
....: ))*(a - b + x - 1) - 2*e^2 + (c + x - 3)*x)*(a - x) + (2*e^2 - (c + x - 3)*x)*(b - c + x +
....:  2))*b^2 + (4*b^2*d*e^2*z - ((b^2*x + ((b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(
....: a - b + x - 1) - 2*e^2 + (c + x - 3)*x)*(a - x) + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))
....: *b^2 - ((b^2*x + ((b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(a - b + x - 1) - 2*e^
....: 2 + (c + x - 3)*x)*(a - x) + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(c - x - 3) + 2*(b^2
....: *e - (b - c + x + 2)*(c + x - 3)*e + ((b^2*e - (b - c + x + 2)*(c + x - 3)*e)*(a - b + x -
....:  1) + (c + x - 3)*e)*(a - x))*e)*(b - c - x + 2))*(a - b - x - 1) - (b^2*x + ((b^2*x + (2*
....: e^2 - (c + x - 3)*x)*(b - c + x + 2))*(a - b + x - 1) - 2*e^2 + (c + x - 3)*x)*(a - x) + (
....: 2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(c - x - 3) - 2*(b^2*e - (b - c + x + 2)*(c + x - 
....: 3)*e + ((b^2*e - (b - c + x + 2)*(c + x - 3)*e)*(a - b + x - 1) + (c + x - 3)*e)*(a - x))*
....: e + 4*(((b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(a - b + x - 1) - 2*e^2 + (c + x
....:  - 3)*x)*b^2*d*z + b^2*e^2 - (((b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(a - b + 
....: x - 1) - 2*e^2 + (c + x - 3)*x)*(c - x - 3)*d*z + 2*((b^2*e - (b - c + x + 2)*(c + x - 3)*
....: e)*(a - b + x - 1) + (c + x - 3)*e)*d*e*z)*(b - c - x + 2))*d/z)*(a + x) + ((b^2*x + ((b^2
....: *x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(a - b + x - 1) - 2*e^2 + (c + x - 3)*x)*(a 
....: - x) + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(c - x - 3) + 2*(b^2*e - (b - c + x + 2)*(
....: c + x - """                                                                               
sage: E2 = """3)*e + ((b^2*e - (b - c + x + 2)*(c + x - 3)*e)*(a - b + x - 1) + (c + x - 3)*e)*(
....: a - x))*e)*(b - c - x + 2) - 4*((a - x)*b^2*e^2 - (b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c 
....: + x + 2))*b^2*d*z - (b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(a - x)*(c - x - 3)*
....: d*z - 2*(b^2*e - (b - c + x + 2)*(c + x - 3)*e)*(a - x)*d*e*z - ((b^2*x + (2*e^2 - (c + x 
....: - 3)*x)*(b - c + x + 2))*(a - x)*b^2*d*z - ((b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 
....: 2))*(a - x)*(c - x - 3)*d*z + 2*(b^2*e - (b - c + x + 2)*(c + x - 3)*e)*(a - x)*d*e*z)*(b 
....: - c - x + 2))*(a - b - x - 1) + ((b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(c - x 
....: - 3)*d*z + 2*(b^2*e - (b - c + x + 2)*(c + x - 3)*e)*d*e*z)*(b - c - x + 2) + 4*((b^2*x + 
....: (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*b^2*d^2*z^2 - ((b^2*x + (2*e^2 - (c + x - 3)*x)*(
....: b - c + x + 2))*(c - x - 3)*d^2*z^2 + 2*(b^2*e - (b - c + x + 2)*(c + x - 3)*e)*d^2*e*z^2)
....: *(b - c - x + 2))*d/z)*d/z + 4*((b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*b^2*d*z 
....: - ((b^2*x + (2*e^2 - (c + x - 3)*x)*(b - c + x + 2))*(c - x - 3)*d*z + 2*(b^2*e - (b - c +
....:  x + 2)*(c + x - 3)*e)*d*e*z)*(b - c - x + 2))*d/z"""                                     
sage: E = SR(E1 + E2)                                                                           
sage: E.expand().subs(x=0)                                                                      
4*a*b^2*d*z*e^2 - 4*a*b^2*d*e^2/z
sage: E.subs(x=0).expand()                                                                      
0
```

If that is really true, then we should change the title of this ticket.


---

Comment by @DaveWitteMorris created at 2020-12-19 04:49:36

Here is a shorter expression that I think illustrates the bug in `expand`. I was unable to make it any shorter.

```
sage: var("a b c d e x z")
(a, b, c, d, e, x, z)
sage: E = ((((((b^2*x + (e^2 - c)*(b - c + x + 1))*(a - b + x - 1) + (x + 1))*(a - x) + e)
....: *(c - x - 3) + e)*(b - c - x + 1))*(a - b - x - 1) + (a - b + x - 1 )*d/z)*(a + x)
sage: E.expand().subs(x=0, a=2, b=0, c=0, e=0)
2*d*z - 12
sage: E.expand().subs(x=0) - E.subs(x=0).expand()                                               
a^2*d*z - a*b*d*z - a*d*z - a^2*d/z + a*b*d/z + a*d/z
sage: E.expand().is_polynomial(z)
True
sage: E.expand() - E.subs(z = 1/z).expand()
0
```

The expression `E` is a polynomial in `a,b,c,d,x` and `1/z`, so expanding it cannot yield a term (such as `2*d*z`) with a positive power of `z`. But `expand` actually makes all powers of `z` positive (as indicated by `is_polynomial(z)` being `True`). In fact, the final line seems to indicate that `expand` is somehow confusing `z` with `1/z`.


---

Comment by @DaveWitteMorris created at 2020-12-19 04:49:36

Changing keywords from "determinant" to "expand".


---

Comment by @DaveWitteMorris created at 2020-12-19 04:49:36

Changing priority from major to critical.


---

Comment by mantepse created at 2020-12-19 12:05:18

This means that it is a bug in pynac.  I don't know how to report this.

A tiny bit shorter, by setting `d=1`:

```
sage: F = (((((b^2*x + (e^2 - c)*(b - c + x + 1))*(a - b + x - 1) + x + 1)*(a - x) + e)*(c - x - 3) + e)*(a - b - x - 1)*(b - c - x + 1) + (a - b + x - 1)/z)*(a + x)
sage: F.expand().is_polynomial(z)
True
sage: F.is_polynomial(z)
False
```



---

Comment by mantepse created at 2020-12-19 12:38:15

Slightly simpler:

```
sage: var("A B C x")
(A, B, C, x)
sage: G = ((((((B^2 + C^2)*(B^2 + x) + A + B)*(A + x + 1) + A + 1)*(C^2 + A) + A)*(A + C + 1) + A)*(B^2 + A + 1)*(A + B + x) + (A + B + 1)/x)*(A + 1)
sage: G.is_polynomial(x)
False
sage: G.expand().is_polynomial(x)
True
```



---

Comment by mantepse created at 2020-12-20 17:45:27

Yet a very tiny bit simpler:

```
sage: var("A B C x")
(A, B, C, x)
sage: p = A^2*B^2*C^3*x^2 + A^2*B^2*C^2*x^3 + A^2*B^2*C^2*x^2 + A^2*C^3*x^3 + A^5*B^2 + A^2*B^2*C^3 + A^3*B^2*C*x + A^2*B^2*C^2*x + A^3*B^2*x^2 + A^4*x^3 + A^3*C*x^3 + A^4*C^2 + A^2*B^2*C^2 + A^3*C^3 + A^3*B^2*x + B^2*C^3*x + A^3*C*x^2 + A^2*C^2*x^2 + A*C^3*x^2 + A*C^2*x^3 + C^3*x^3 + A^3*B^2 + A^2*B*C^2 + A*B*C^3 + A*B*C^2*x + B^2*C^2*x + A^3*x^2 + C^3*x^2 + A^2*x^3 + B^2*x^3 + A*C*x^3 + C^2*x^3 + A^4 + A^3*C + A^2*C^2 + B^2*C^2 + A*C^3 + B*C^3 + A^2*B*x + A*B*C*x + A*C*x^2 + B*C*x^2 + C^2*x^2 + A^2*B + B^2*C + B*C^2 + C^3 + A*B*x + A*x^2 + C*x^2 + x^3 + A^2 + B^2 + A*C + B*C + C^2 + B*x + x^2 + B + C + x + 1
sage: G = (((A + B + x) * (A + B^2 + 1) * p + (A + B + 1)/x)*(A+1))

sage: G.expand().is_polynomial(x) != G.is_polynomial(x)
True
```



---

Comment by dimpase created at 2021-01-24 22:29:04

just in case, it's not fixed by #30446


---

Comment by slelievre created at 2021-02-19 03:20:36

This 4x4 symbolic determinant with denominators also goes wrong.

Tried the following with Sage 9.3.beta5, 9.3.beta6, 9.3.beta7:

```
sage: N = 4
sage: t, x, y, z = (SR.var(s, N) for s in 'txyz')
sage: f = lambda i, j: (x[i] - x[j])*(y[i] - y[j])*(z[i] - z[j])/(t[i] - t[j])
sage: A = matrix(SR, N, lambda i, j: f(i, j) if i != j else 0)
sage: A_det = A.det()
sage: txyz = t + x + y + z
sage: vv = dict(zip(txyz, list(range(N))*4))
sage: A.subs(vv).det(), A_det().subs(vv)
(0, -3072)
```


Computing `len(str(A_det))` gave varied results, all near 5.8 million.

Repeating the sequence "start Sage, define `N`, `t`, `x`, `y`, `z`,
`f`, `A`, `A_det`, compute that length" various times gave
5794243, 5775526, 5783134, 5771824, 5775730, 5810160, 5820599...

Computing `A_det.subs(vv)` after that also gave several values: -3072, 6144, 9216.


---

Comment by @DaveWitteMorris created at 2021-02-22 21:15:29

patch mul::expand to eliminate call to poly_mul_expand


---

Attachment

The attached patch `mul_expand.patch` works for me (and causes no doctest failures).  It solves all of the problems on this ticket and also the bug reported in #31411. If other people have the same experience, then I think it is a viable workaround until we fix the real problem, so perhaps we should make this ticket a blocker.

In effect, the patch just comments out a call to `poly_mul_expand`, so that seems to be where the problem is. The pynac code for this function is short, so it should be easy to find the bug if that's where it is. But the problem may be upstream in `singular` or `libgiac`.

Here is a more detailed explanation of my experience after the patch is applied.

* For the original issue on this ticket, `L.det()` gives `0`.
* For `E` as in comment:5, 
    * `E.expand().subs(x=0, a=2, b=0, c=0, e=0)` gives `2*d/z - 12`
    * `E.expand().subs(x=0) - E.subs(x=0).expand()` gives `0`
    * `E.expand().subs(z=1/z).is_polynomial(z)` gives `True`
* For `A` and `A_det` as in comment:12, 
    * `A.subs(vv).det(), A_det().subs(vv)` gives `(0, 0)`
    * `len(str(A_det))` gives `942027`
* For `A` and `B` as in #31411,
    * `bool((A*B).expand()==(A*B.expand()).expand())` gives `True`
    * `((A*B).expand())/((A*B.expand()).expand())` gives `1`


---

Comment by @DaveWitteMorris created at 2021-02-22 21:18:40

Changing status from new to needs_review.


---

Comment by @DaveWitteMorris created at 2021-02-23 20:19:09

This is a very bad bug, so I am raising the priority to blocker.

Sage is silently returning mathematically wrong answers any time it expands a product `A * B` where `A` and `B` are long sums (more than about 400 terms in total) such that one of the sums has a term where at least one of the factors has a negative exponent. The patch `mul_expand.patch` gets rid of the mathematical error by eliminating an incorrect optimization. The drawback is that sage may run slower and use more memory. 

It should be pretty easy to write a better patch that restores the optimization in cases where it is correct, so I will work on that.  But an optimization for the general case might  not be ready for 9.3.

----

Explanation of the bug:
In order to take advantage of optimizations in `singular`'s handling of products of large polynomials, pynac converts the product `A * B` into a product of multivariate polynomials, and asks `singular` to do the calculation.
To do this, pynac uses the `ex::to_canonical` method, which claims to turn any expression into a polynomial, by replacing some subexpressions with new variables.  (For example, `x^2 + a*cos(y)^3` could be encoded as `x^2 + a*c^3`, where `c` stands for `cos(y)`.) The bug is that the result is sometimes actually a _Laurent_ polynomial, not a true polynomial, because some of the exponents could be negative. This causes a problem when the supposed "polynomial" is sent to `singular`, which seems to think it is getting a genuine polynomial (i.e., a `CanonicalForm` in `singular`'s terminology). I have not yet checked the details of what has happening, but it seems that `singular` does indeed get a polynomial, because all negative exponents are silently converted to positive. I don't know exactly where this happens, and I don't understand why no error is raised -- I will look into those questions.

My "it should be pretty easy" comment above is the suggestion that we could send the product to `singular` only in cases where none of the exponents are negative. If there is a CAS that optimizes multiplication of multivariate Laurent polynomials over `Q`, then the other cases could also be optimized with very little additional work. (How efficient is `sage`'s code for the `_mul_` method of `LaurentPolynomial_mpair`?)


---

Comment by @DaveWitteMorris created at 2021-02-23 20:19:09

Changing priority from critical to blocker.


---

Comment by mantepse created at 2021-02-23 20:28:45

You are a true hero!


---

Comment by slelievre created at 2021-02-23 21:14:24

Thanks a lot for this fix! Can you turn your patch into a branch?


---

Comment by @DaveWitteMorris created at 2021-02-23 21:57:36

Thanks (both of you) for the encouragement. I pushed a branch.
----
New commits:


---

Comment by kcrisman created at 2021-02-23 22:28:55

Well done - that was a very subtle bug indeed, and finding exactly what happened is great.


---

Comment by @mwageringel created at 2021-02-24 21:58:40

Replying to [comment:15 gh-DaveWitteMorris]:
> (How efficient is `sage`'s code for the `_mul_` method of `LaurentPolynomial_mpair`?)

Laurent polynomials in Sage are represented by libsingular polynomials together with an offset exponent vector, so I assume that it would be quite ok.


---

Comment by @DaveWitteMorris created at 2021-02-24 22:16:37

Thanks, that's good to know. I'll try to find time to write a PR in the next few days.


---

Comment by mantepse created at 2021-02-25 09:44:23

Would it make sense to compare with the ginac code?  I do not understand cpp code, but it seems that the two `mul::expand` routines have diverged a fair bit.  I guess a big difference is that ginac doesn't call singular, but given the bug, is it worth it?


---

Comment by slelievre created at 2021-02-25 10:50:56

Determinants are often computed to check whether (or for which
values of parameters) they are zero; factoring would help more
than expanding for that.

Regarding denominators and Singular, a solution might be to detect
denominators in each row, collect them, ask Singular to compute
a denominatorless determinant, and divide back afterwards.


---

Comment by slelievre created at 2021-02-25 10:59:04

Even if a follow-up ticket might restore a fixed optimisation,
this should go in -- ideally with doctests.


---

Comment by @DaveWitteMorris created at 2021-02-26 03:11:37

I hope to have a correct fix (with doctests) ready in a few days, so I don't think we should merge the current patch. It was just written to test whether I was on the right track, and to provide a backup plan if a real fix was too hard.

_Correction:_ The rationale that I gave for using (Laurent) polynomials was incorrect.  Using a single variable to represent a complicated expression can give a big savings in space and time, even if the handling of (Laurent) polynomials is not particularly efficient. It eliminates the need to copy the expression every time two terms are multiplied (and there are `n^2` multiplications when two sums of length `n` are multiplied). So I think it is worth trying to re-enable this.

----

PS I think I now understand the two issues that I left open at the end of the next-to-last paragraph of comment:15:

1) The `ex::to_canonical` method uses singular's `CanonicalForm::power` method to calculate a power `a^n`. This `power` method does not allow `n` to be negative, and starts with a check for that. However, the check is `ASSERT( n >= 0, "illegal exponent" )`, and I think sage uses compile flags that disable debugging, and therefore disable this `assert` statement. So the check is not performed.  That is why no error is raised.    (My quick impression is that the `singular` source code has hundreds of assert statements that should be raising errors. I don't know whether there is anything we can do about this.)

2) The `CanonicalForm::power` method uses repeated squaring to calculate `a^n`. This will always result in raising `a` to a positive power, even if `n` is negative. That is why the negative exponent turns into a positive one. In fact, the way the code is written means that the result will always be precisely `a^abs(n)`.


---

Comment by @DaveWitteMorris created at 2021-02-27 06:32:13

This simple patch allows the `singular` optimization to be used in the cases where it works (i.e., when the exponents are positive). It would be more work to enable an optimization (by using Laurent series) for negative exponents, so that can be a follow-up ticket. I think that extension would be an enhancement, not a bug fix, so certainly not critical, and I do not intend to work on it soon, but it's great if someone else is interested.
----
New commits:


---

Comment by dimpase created at 2021-02-27 11:51:34

Why 400 in `if (s > 400) {...` ?

So this problem is not triggered if `s<401`? Or doesit mean to avoid using this code branch for `s<401`?


---

Comment by @DaveWitteMorris created at 2021-02-27 18:51:15

400 was in the original code.  I think the point is that the overhead of translating to a polynomial is not worth the trouble for short sums, so `poly_mul_expand` should not be called unless `s` is large. A comment in the code says that the condition `s > 400` is "probably too simple", but making a more more intelligent choice would be a different ticket.

The negative-exponent bug arose whenever `poly_mul_expand` was called with a negative exponent. Because of the condition `s > 400`, this only happened for long sums (see comment:21). When I was searching for the bug, I changed 400 to 2, so that the problem was visible in very short sums, which made it easier to diagnose.


---

Comment by @DaveWitteMorris created at 2021-02-27 20:48:14

A patchbot failed the doctest that I wrote to test the patch. I think it is because the patchbot didn't rebuild pynac after loading the patch (so the patch to pynac didn't do anything). Is there something I can do to get the patchbots to test the patch?


---

Comment by @DaveWitteMorris created at 2021-03-01 05:44:30

FWIW, `sage -t -l --optional=sage --all` doesn't give me any unexpected doctest failures on MacOS 10.15.7 or Ubuntu 20.04 (`CoCalc`).


---

Comment by @DaveWitteMorris created at 2021-03-02 03:20:54

Changing status from needs_review to needs_work.


---

Comment by @DaveWitteMorris created at 2021-03-02 03:20:54

I just noticed that the same problem probably happens in another (nearby) place in the file. I fixed the problem for rational exponents, but I think the same thing could happen for irrational exponents. I plan to upload a fix soon.


---

Comment by @DaveWitteMorris created at 2021-03-10 07:39:55

Changing priority from blocker to major.


---

Comment by @DaveWitteMorris created at 2021-03-10 07:39:55

Ticket #31411 reveals two other bugs in `poly_mul_expand`. I opened blocker ticket #31479 to disable the use of this function until all of the bugs have been fixed (and metaticket #31478 to track the progress), so it is not an urgent problem.


---

Comment by mkoeppe created at 2021-05-10 17:42:09

Moving to 9.4, as 9.3 has been released.
