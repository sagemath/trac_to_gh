# Issue 20208: Iteration through Coxeter groups

archive/issues_020208.json:
```json
{
    "body": "CC:  tscrim chapoton nthiery vripoll\n\nThe algorithm in chevie is very different from the algorithm we currently have:\n\n```\nForEachElement:=function(W,f)local l,g;\n  if not IsFinite(W) then Error(\"only for finite Coxeter groups\");\n  elif W.nbGeneratingReflections=0 then f(W.identity);return;\n  fi;\n  l:=List([0..W.nbGeneratingReflections],i->\n        ReflectionSubgroup(W,W.reflectionsLabels{[1..i]}));\n  l:=List([1..Length(l)-1],i->ReducedRightCosetRepresentatives(l[i+1],l[i]));\n  g:=function(x,v)local y;\n    if Length(v)=0 then f(x);\n    else for y in v[1] do g(x*y,v{[2..Length(v)]});od;\n    fi;\n  end;\n  g(W.identity,l);\nend;\n```\n\n\nWe should also implement that algorithm (maybe even with hard-coded coset representatives in the finite case) so that we can see if this is indeed faster.\n\nIssue created by migration from https://trac.sagemath.org/ticket/20445\n\n",
    "created_at": "2016-04-14T10:09:16Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.3",
    "title": "Iteration through Coxeter groups",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20208",
    "user": "stumpc5"
}
```
CC:  tscrim chapoton nthiery vripoll

The algorithm in chevie is very different from the algorithm we currently have:

```
ForEachElement:=function(W,f)local l,g;
  if not IsFinite(W) then Error("only for finite Coxeter groups");
  elif W.nbGeneratingReflections=0 then f(W.identity);return;
  fi;
  l:=List([0..W.nbGeneratingReflections],i->
        ReflectionSubgroup(W,W.reflectionsLabels{[1..i]}));
  l:=List([1..Length(l)-1],i->ReducedRightCosetRepresentatives(l[i+1],l[i]));
  g:=function(x,v)local y;
    if Length(v)=0 then f(x);
    else for y in v[1] do g(x*y,v{[2..Length(v)]});od;
    fi;
  end;
  g(W.identity,l);
end;
```


We should also implement that algorithm (maybe even with hard-coded coset representatives in the finite case) so that we can see if this is indeed faster.

Issue created by migration from https://trac.sagemath.org/ticket/20445





---

archive/issue_comments_278477.json:
```json
{
    "body": "\n```\n###########################################################################\n#\n# N.B. a difference with older versions of Chevie is that IsLeftDescending and\n# FirstLeftDescending  return  an  index  in  the  list  of  generators, not a\n# reflectionName,  for  efficiency.  LeftDescentSet  still  returns  names  of\n# reflections.\n#\n###########################################################################\n\n##  generic reduction of FirstLeftDescending to IsLeftDescending\n##  in practical implementations of Coxeter groups this routine can often\n##  be overriden by a more efficient one.\n\nAbsCoxOps.FirstLeftDescending:=function(W, x)local i,ILD;\n  ILD:=W.operations.IsLeftDescending; # avoid dispatching overhead\n  for i in W.generatingReflections do if ILD(W,x,i) then return i; fi; od;\n  return false;\nend;\n```\n",
    "created_at": "2016-04-15T05:37:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278477",
    "user": "stumpc5"
}
```


```
###########################################################################
#
# N.B. a difference with older versions of Chevie is that IsLeftDescending and
# FirstLeftDescending  return  an  index  in  the  list  of  generators, not a
# reflectionName,  for  efficiency.  LeftDescentSet  still  returns  names  of
# reflections.
#
###########################################################################

##  generic reduction of FirstLeftDescending to IsLeftDescending
##  in practical implementations of Coxeter groups this routine can often
##  be overriden by a more efficient one.

AbsCoxOps.FirstLeftDescending:=function(W, x)local i,ILD;
  ILD:=W.operations.IsLeftDescending; # avoid dispatching overhead
  for i in W.generatingReflections do if ILD(W,x,i) then return i; fi; od;
  return false;
end;
```




---

archive/issue_comments_278478.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-15T18:56:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278478",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278479.json:
```json
{
    "body": "Last 10 new commits:",
    "created_at": "2016-04-15T18:56:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278479",
    "user": "stumpc5"
}
```

Last 10 new commits:



---

archive/issue_comments_278480.json:
```json
{
    "body": "Travis, I implemented a first version of the algoritm, getting all needed cosets in E7 takes 2/3 of our iteration time, but constructing the elements in the end takes about 30secs. If you find the time, I am sure you see how to speed the algorithm. The function is `parabolic_iteration`.",
    "created_at": "2016-04-15T18:58:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278480",
    "user": "stumpc5"
}
```

Travis, I implemented a first version of the algoritm, getting all needed cosets in E7 takes 2/3 of our iteration time, but constructing the elements in the end takes about 30secs. If you find the time, I am sure you see how to speed the algorithm. The function is `parabolic_iteration`.



---

archive/issue_comments_278481.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-16T11:26:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278481",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278482.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-17T15:10:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278482",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278483.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-17T16:15:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278483",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278484.json:
```json
{
    "body": "\n```\nsage: timeit(\"for w in W.iteration('depth',False): pass\",number=5)\n5 loops, best of 3: 6.33 s per loop\nsage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration\nsage: timeit(\"for w in parabolic_iteration(W): pass\",number=5)    \n5 loops, best of 3: 4.28 s per loop\n```\n\nOkay, I can now get down quite a bit from our last weeks algorithm. Drawback is that it needs quite some memory (for E8, we have to keep E7 in memory). I provide an alternative in which order the parabolic is computed, but that doesn't seem to speed the computation.\n\n* If `@`tscrim looks at the code and improves it further, we might beat the 5 minutes for E8!\n* The code can also perfectly be paralellized!",
    "created_at": "2016-04-17T16:16:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278484",
    "user": "stumpc5"
}
```


```
sage: timeit("for w in W.iteration('depth',False): pass",number=5)
5 loops, best of 3: 6.33 s per loop
sage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration
sage: timeit("for w in parabolic_iteration(W): pass",number=5)    
5 loops, best of 3: 4.28 s per loop
```

Okay, I can now get down quite a bit from our last weeks algorithm. Drawback is that it needs quite some memory (for E8, we have to keep E7 in memory). I provide an alternative in which order the parabolic is computed, but that doesn't seem to speed the computation.

* If `@`tscrim looks at the code and improves it further, we might beat the 5 minutes for E8!
* The code can also perfectly be paralellized!



---

archive/issue_comments_278485.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-17T19:42:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278485",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278486.json:
```json
{
    "body": "I locally reimplemented the multiplication of `PermutationGroupElement`. This resulted in\n\n```\nsage: W = ReflectionGroup(['E',7])                                                \nsage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration\nsage: timeit(\"for w in parabolic_iteration(W): pass\",number=5)                    \n5 loops, best of 3: 2.4 s per loop\n```\n\nIf we provide a very restricted implementation of permutations ourselves, we might get down further quite a bit. Remark: the algorithm without the multiplication and creation of new permutation group elements only takes `.5sec`, so there is a lot to improve still.",
    "created_at": "2016-04-18T13:05:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278486",
    "user": "stumpc5"
}
```

I locally reimplemented the multiplication of `PermutationGroupElement`. This resulted in

```
sage: W = ReflectionGroup(['E',7])                                                
sage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration
sage: timeit("for w in parabolic_iteration(W): pass",number=5)                    
5 loops, best of 3: 2.4 s per loop
```

If we provide a very restricted implementation of permutations ourselves, we might get down further quite a bit. Remark: the algorithm without the multiplication and creation of new permutation group elements only takes `.5sec`, so there is a lot to improve still.



---

archive/issue_comments_278487.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-18T13:08:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278487",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278488.json:
```json
{
    "body": "I just redid the computations and it seems to be about twice as fast as in gap3:\n\n```\nsage: W = ReflectionGroup(['E',7])\nsage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration\nsage: timeit(\"for w in parabolic_iteration(W): pass\",number=5)\n5 loops, best of 3: 1.56 s per loop\nsage: timeit(\"for w in parabolic_iteration(W): pass\",number=5)\n5 loops, best of 3: 1.43 s per loop\nsage: W = ReflectionGroup(['E',8])\nsage: %time for w in parabolic_iteration(W): pass\n\nCPU times: user 9min 12s, sys: 3.81 s, total: 9min 16s\nWall time: 9min 16s\n```\n\nSo we are slowly approaching the 5min...",
    "created_at": "2016-04-19T20:06:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278488",
    "user": "stumpc5"
}
```

I just redid the computations and it seems to be about twice as fast as in gap3:

```
sage: W = ReflectionGroup(['E',7])
sage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration
sage: timeit("for w in parabolic_iteration(W): pass",number=5)
5 loops, best of 3: 1.56 s per loop
sage: timeit("for w in parabolic_iteration(W): pass",number=5)
5 loops, best of 3: 1.43 s per loop
sage: W = ReflectionGroup(['E',8])
sage: %time for w in parabolic_iteration(W): pass

CPU times: user 9min 12s, sys: 3.81 s, total: 9min 16s
Wall time: 9min 16s
```

So we are slowly approaching the 5min...



---

archive/issue_comments_278489.json:
```json
{
    "body": "Took 3.5Gb of RAM with this ticket, but on my laptop, this is what I got:\n\n```\nsage: W = ReflectionGroup(['E',8])\nsage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration\nsage: %time for w in parabolic_iteration(W): pass\nCPU times: user 4min 23s, sys: 604 ms, total: 4min 23s\nWall time: 4min 23s\n```\n",
    "created_at": "2016-04-20T04:53:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278489",
    "user": "tscrim"
}
```

Took 3.5Gb of RAM with this ticket, but on my laptop, this is what I got:

```
sage: W = ReflectionGroup(['E',8])
sage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration
sage: %time for w in parabolic_iteration(W): pass
CPU times: user 4min 23s, sys: 604 ms, total: 4min 23s
Wall time: 4min 23s
```




---

archive/issue_comments_278490.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-20T07:19:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278490",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278491.json:
```json
{
    "body": "Replying to [comment:15 tscrim]:\n    CPU times: user 4min 23s, sys: 604 ms, total: 4min 23s\n    Wall time: 4min 23s\n\nGreat, I believe you can claim to be the first person ever who iterated through E8 in less than 5 minutes! (I was expecting that since 1. your computer was about twice as fast as mine last week, and 2. you took ~8 minutes to iter through E8 in chevie, and my code is about twice as fast as the chevie code.)\n\n1. I would really like to see how to implement our own permutation group elements with only what we need. I would hope that to again result in some speedup. One question there: we have w(-\\beta) = -w(\\beta), so we would not need to record the complete permutation on all roots, but on the positive roots would be enough. That would speed several computations such as creating new elements and testing for equality), but it would have the drawback that we constantly need to work mod N (N=nr of positive roots), e.g., we would have such checks and mod's when multiplying two permutations.\n\n2. We should get your parallelization to work with this so that people can then use many cores to actually do stuff with the elements in type E8.",
    "created_at": "2016-04-20T09:25:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278491",
    "user": "stumpc5"
}
```

Replying to [comment:15 tscrim]:
    CPU times: user 4min 23s, sys: 604 ms, total: 4min 23s
    Wall time: 4min 23s

Great, I believe you can claim to be the first person ever who iterated through E8 in less than 5 minutes! (I was expecting that since 1. your computer was about twice as fast as mine last week, and 2. you took ~8 minutes to iter through E8 in chevie, and my code is about twice as fast as the chevie code.)

1. I would really like to see how to implement our own permutation group elements with only what we need. I would hope that to again result in some speedup. One question there: we have w(-\beta) = -w(\beta), so we would not need to record the complete permutation on all roots, but on the positive roots would be enough. That would speed several computations such as creating new elements and testing for equality), but it would have the drawback that we constantly need to work mod N (N=nr of positive roots), e.g., we would have such checks and mod's when multiplying two permutations.

2. We should get your parallelization to work with this so that people can then use many cores to actually do stuff with the elements in type E8.



---

archive/issue_comments_278492.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-21T15:23:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278492",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278493.json:
```json
{
    "body": "Travis, could you also now run\n\n```\nsage: W = ReflectionGroup(['E',8])\nsage: %time for w in W.iteration(\"depth\",False): pass\n```\n\nIt now also uses the local multiplication, so it should also speed quite a bit. On my machine, it's only 1.5 times as slow.",
    "created_at": "2016-04-21T15:25:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278493",
    "user": "stumpc5"
}
```

Travis, could you also now run

```
sage: W = ReflectionGroup(['E',8])
sage: %time for w in W.iteration("depth",False): pass
```

It now also uses the local multiplication, so it should also speed quite a bit. On my machine, it's only 1.5 times as slow.



---

archive/issue_comments_278494.json:
```json
{
    "body": "With doing other things on my laptop:\n\n```\nsage: W = ReflectionGroup(['E',8])\nsage: %time for w in W.iteration(\"depth\",False): pass\nCPU times: user 6min 39s, sys: 22.5 ms, total: 6min 39s\nWall time: 6min 39s\n```\n",
    "created_at": "2016-04-21T15:43:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278494",
    "user": "tscrim"
}
```

With doing other things on my laptop:

```
sage: W = ReflectionGroup(['E',8])
sage: %time for w in W.iteration("depth",False): pass
CPU times: user 6min 39s, sys: 22.5 ms, total: 6min 39s
Wall time: 6min 39s
```




---

archive/issue_comments_278495.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-10T19:36:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278495",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278496.json:
```json
{
    "body": "`@`Nicolas: I just now see that you (I think) accidentally edited my comment (comment 5 above from here) instead of replying three weeks ago. Could you quickly recheck?",
    "created_at": "2016-05-10T20:08:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278496",
    "user": "stumpc5"
}
```

`@`Nicolas: I just now see that you (I think) accidentally edited my comment (comment 5 above from here) instead of replying three weeks ago. Could you quickly recheck?



---

archive/issue_comments_278497.json:
```json
{
    "body": "Replying to [comment:17 stumpc5]:\n> 1. I would really like to see how to implement our own permutation group elements with only what we need. I would hope that to again result in some speedup. One question there: we have w(-\\beta) = -w(\\beta), so we would not need to record the complete permutation on all roots, but on the positive roots would be enough. That would speed several computations such as creating new elements and testing for equality), but it would have the drawback that we constantly need to work mod N (N=nr of positive roots), e.g., we would have such checks and mod's when multiplying two permutations.\n\nThis business sounds of the same nature as what we have for affine\npermutations (in window notation). Would there be a way to use the\nsame implementation behind the scene?\n\nCheers,\n                               Nicolas",
    "created_at": "2016-05-11T07:43:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278497",
    "user": "nthiery"
}
```

Replying to [comment:17 stumpc5]:
> 1. I would really like to see how to implement our own permutation group elements with only what we need. I would hope that to again result in some speedup. One question there: we have w(-\beta) = -w(\beta), so we would not need to record the complete permutation on all roots, but on the positive roots would be enough. That would speed several computations such as creating new elements and testing for equality), but it would have the drawback that we constantly need to work mod N (N=nr of positive roots), e.g., we would have such checks and mod's when multiplying two permutations.

This business sounds of the same nature as what we have for affine
permutations (in window notation). Would there be a way to use the
same implementation behind the scene?

Cheers,
                               Nicolas



---

archive/issue_comments_278498.json:
```json
{
    "body": "Replying to [comment:22 stumpc5]:\n> `@`Nicolas: I just now see that you (I think) accidentally edited my comment (comment 5 above from here) instead of replying three weeks ago. Could you quickly recheck?\n\nOops, reverted!",
    "created_at": "2016-05-11T07:43:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278498",
    "user": "nthiery"
}
```

Replying to [comment:22 stumpc5]:
> `@`Nicolas: I just now see that you (I think) accidentally edited my comment (comment 5 above from here) instead of replying three weeks ago. Could you quickly recheck?

Oops, reverted!



---

archive/issue_comments_278499.json:
```json
{
    "body": "Replying to [comment:23 nthiery]:\n> Replying to [comment:17 stumpc5]:\n> This business sounds of the same nature as what we have for affine\n> permutations (in window notation). Would there be a way to use the\n> same implementation behind the scene?\n\nAnd also with colored permutations, isn't it? The main difference is that here (and also in signed permutations) one works mod N, for colored permutations one works \"+N mod kN\", and for affine permutation one does not work mod anything.\n\nI would propose to first work out the implementation here and then see if we can use it also in the other places. I only don't see how to actually do the implementation in an optimal way, so some support of yours and/or Travis is appreciated.\n\nSome concrete questions:\n\n1. It seems that we should use the same data structure as for `PermutationGroupElement`:\n   {{{\n       self.perm = <int *>sig_malloc(sizeof(int) * self.N)\n   }}}\n   Do you agree? Can we even get anything significantly better than sticking to `PermutationGroupElement` if we do it ourselves? This also asks whether we can do better when multiplying elements, I do not see what\n   {{{\n    cdef PermutationGroupElement prod = PermutationGroupElement.__new__(PermutationGroupElement)\n   }}}\n   does or how long it takes, see the method `_new_mul_` in `reflection_group_c.pyx`.\n\n3. It seems that we are using `PermutationGroupElement` in a few places (when talking to `GAP3`}), but this might just be that we need the cycle string representation for that.",
    "created_at": "2016-05-11T08:21:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278499",
    "user": "stumpc5"
}
```

Replying to [comment:23 nthiery]:
> Replying to [comment:17 stumpc5]:
> This business sounds of the same nature as what we have for affine
> permutations (in window notation). Would there be a way to use the
> same implementation behind the scene?

And also with colored permutations, isn't it? The main difference is that here (and also in signed permutations) one works mod N, for colored permutations one works "+N mod kN", and for affine permutation one does not work mod anything.

I would propose to first work out the implementation here and then see if we can use it also in the other places. I only don't see how to actually do the implementation in an optimal way, so some support of yours and/or Travis is appreciated.

Some concrete questions:

1. It seems that we should use the same data structure as for `PermutationGroupElement`:
   {{{
       self.perm = <int *>sig_malloc(sizeof(int) * self.N)
   }}}
   Do you agree? Can we even get anything significantly better than sticking to `PermutationGroupElement` if we do it ourselves? This also asks whether we can do better when multiplying elements, I do not see what
   {{{
    cdef PermutationGroupElement prod = PermutationGroupElement.__new__(PermutationGroupElement)
   }}}
   does or how long it takes, see the method `_new_mul_` in `reflection_group_c.pyx`.

3. It seems that we are using `PermutationGroupElement` in a few places (when talking to `GAP3`}), but this might just be that we need the cycle string representation for that.



---

archive/issue_comments_278500.json:
```json
{
    "body": "`@`Travis: Could you have a brief look at the `_new_mul_` in `reflection_group_c.pyx` to check whether I am missing something, or whether I could use that as a first improvement in this algorithm.\n\nI indeed plan to have this ticket only contain the improvements for now (then having plenty of options for iterating through finite Coxeter groups), postponing the work and testing for a new data structure to a new ticket.",
    "created_at": "2016-05-11T08:33:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278500",
    "user": "stumpc5"
}
```

`@`Travis: Could you have a brief look at the `_new_mul_` in `reflection_group_c.pyx` to check whether I am missing something, or whether I could use that as a first improvement in this algorithm.

I indeed plan to have this ticket only contain the improvements for now (then having plenty of options for iterating through finite Coxeter groups), postponing the work and testing for a new data structure to a new ticket.



---

archive/issue_comments_278501.json:
```json
{
    "body": "Replying to [comment:25 stumpc5]:\n> I would propose to first work out the implementation here and then see if we can use it also in the other places. I only don't see how to actually do the implementation in an optimal way, so some support of yours and/or Travis is appreciated.\n\nI'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.\n\n> Some concrete questions:\n> \n> 1. It seems that we should use the same data structure as for `PermutationGroupElement`:\n>    {{{\n>        self.perm = <int *>sig_malloc(sizeof(int) * self.N)\n>    }}}\n>    Do you agree? Can we even get anything significantly better than sticking to `PermutationGroupElement` if we do it ourselves?\n\nI think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.\n\n>    This also asks whether we can do better when multiplying elements, I do not see what\n>    {{{\n>     cdef PermutationGroupElement prod = PermutationGroupElement.__new__(PermutationGroupElement)\n>    }}}\n>    does or how long it takes, see the method `_new_mul_` in `reflection_group_c.pyx`.\n\nThis creates a new element in memory, but it does not call the `__init__`. It is essential and done in Python kernel, so we won't get any better.\n\n> 3. It seems that we are using `PermutationGroupElement` in a few places (when talking to `GAP3`}), but this might just be that we need the cycle string representation for that.\n\nGAP4 doesn't store things as cycle strings AFAIK, and so I doubt GAP3 does either.Replying to [comment:25 stumpc5]:\n> I would propose to first work out the implementation here and then see if we can use it also in the other places. I only don't see how to actually do the implementation in an optimal way, so some support of yours and/or Travis is appreciated.\n\nI'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.\n\n> Some concrete questions:\n> \n> 1. It seems that we should use the same data structure as for `PermutationGroupElement`:\n>    {{{\n>        self.perm = <int *>sig_malloc(sizeof(int) * self.N)\n>    }}}\n>    Do you agree? Can we even get anything significantly better than sticking to `PermutationGroupElement` if we do it ourselves?\n\nI think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.\n\n>    This also asks whether we can do better when multiplying elements, I do not see what\n>    {{{\n>     cdef PermutationGroupElement prod = PermutationGroupElement.__new__(PermutationGroupElement)\n>    }}}\n>    does or how long it takes, see the method `_new_mul_` in `reflection_group_c.pyx`.\n\nThis creates a new element in memory, but it does not call the `__init__`. It is essential and done in Python kernel, so we won't get any better.\n\n> 3. It seems that we are using `PermutationGroupElement` in a few places (when talking to `GAP3`}), but this might just be that we need the cycle string representation for that.\n\nGAP4 doesn't store things as cycle strings AFAIK, and so I doubt GAP3 does either. We could very likely replace these calls with something better (if we are calling GAP3).",
    "created_at": "2016-05-11T14:49:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278501",
    "user": "tscrim"
}
```

Replying to [comment:25 stumpc5]:
> I would propose to first work out the implementation here and then see if we can use it also in the other places. I only don't see how to actually do the implementation in an optimal way, so some support of yours and/or Travis is appreciated.

I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.

> Some concrete questions:
> 
> 1. It seems that we should use the same data structure as for `PermutationGroupElement`:
>    {{{
>        self.perm = <int *>sig_malloc(sizeof(int) * self.N)
>    }}}
>    Do you agree? Can we even get anything significantly better than sticking to `PermutationGroupElement` if we do it ourselves?

I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.

>    This also asks whether we can do better when multiplying elements, I do not see what
>    {{{
>     cdef PermutationGroupElement prod = PermutationGroupElement.__new__(PermutationGroupElement)
>    }}}
>    does or how long it takes, see the method `_new_mul_` in `reflection_group_c.pyx`.

This creates a new element in memory, but it does not call the `__init__`. It is essential and done in Python kernel, so we won't get any better.

> 3. It seems that we are using `PermutationGroupElement` in a few places (when talking to `GAP3`}), but this might just be that we need the cycle string representation for that.

GAP4 doesn't store things as cycle strings AFAIK, and so I doubt GAP3 does either.Replying to [comment:25 stumpc5]:
> I would propose to first work out the implementation here and then see if we can use it also in the other places. I only don't see how to actually do the implementation in an optimal way, so some support of yours and/or Travis is appreciated.

I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.

> Some concrete questions:
> 
> 1. It seems that we should use the same data structure as for `PermutationGroupElement`:
>    {{{
>        self.perm = <int *>sig_malloc(sizeof(int) * self.N)
>    }}}
>    Do you agree? Can we even get anything significantly better than sticking to `PermutationGroupElement` if we do it ourselves?

I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.

>    This also asks whether we can do better when multiplying elements, I do not see what
>    {{{
>     cdef PermutationGroupElement prod = PermutationGroupElement.__new__(PermutationGroupElement)
>    }}}
>    does or how long it takes, see the method `_new_mul_` in `reflection_group_c.pyx`.

This creates a new element in memory, but it does not call the `__init__`. It is essential and done in Python kernel, so we won't get any better.

> 3. It seems that we are using `PermutationGroupElement` in a few places (when talking to `GAP3`}), but this might just be that we need the cycle string representation for that.

GAP4 doesn't store things as cycle strings AFAIK, and so I doubt GAP3 does either. We could very likely replace these calls with something better (if we are calling GAP3).



---

archive/issue_comments_278502.json:
```json
{
    "body": "Replying to [comment:27 tscrim]:\n> Replying to [comment:25 stumpc5]:\n> I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.\n\nLet me quickly ask: by \"create our own separate project where we write all of this independently (in, say, C/C++)\" you mean implementing this permutation group element there and then use it from our sage implementation, right?\n\nI'd be happy to follow and help with than whenever you find the time, but at first I will likely only be watching you doing it...",
    "created_at": "2016-05-12T08:52:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278502",
    "user": "stumpc5"
}
```

Replying to [comment:27 tscrim]:
> Replying to [comment:25 stumpc5]:
> I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.

Let me quickly ask: by "create our own separate project where we write all of this independently (in, say, C/C++)" you mean implementing this permutation group element there and then use it from our sage implementation, right?

I'd be happy to follow and help with than whenever you find the time, but at first I will likely only be watching you doing it...



---

archive/issue_comments_278503.json:
```json
{
    "body": "Replying to [comment:27 tscrim]:\n> I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.\n\nWe can discuss this in Meudon.\n\n> I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.\n\nFor the record: I just checked, and the data structure for permutation\ngroup elements is just a reference to the parent and a C-list of ints;\nplus a few slots which are unused by default (e.g. a reference to a\ngap element). So the only overhead is copying over the reference to\nthe parent, and a bit of extra memory allocation\n\nOf course, the parent itself has stuff about GAP and categories, but\nthat's initialized once for all, and does not influence arithmetic on\nelements.\n\nCheers,\n                             Nicolas",
    "created_at": "2016-05-16T08:50:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278503",
    "user": "nthiery"
}
```

Replying to [comment:27 tscrim]:
> I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.

We can discuss this in Meudon.

> I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.

For the record: I just checked, and the data structure for permutation
group elements is just a reference to the parent and a C-list of ints;
plus a few slots which are unused by default (e.g. a reference to a
gap element). So the only overhead is copying over the reference to
the parent, and a bit of extra memory allocation

Of course, the parent itself has stuff about GAP and categories, but
that's initialized once for all, and does not influence arithmetic on
elements.

Cheers,
                             Nicolas



---

archive/issue_comments_278504.json:
```json
{
    "body": "Replying to [comment:29 nthiery]:\n> Replying to [comment:27 tscrim]:\n> > I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.\n> \n> We can discuss this in Meudon.\n\nSounds good.\n\n> > I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.\n> \n> For the record: I just checked, and the data structure for permutation\n> group elements is just a reference to the parent and a C-list of ints;\n> plus a few slots which are unused by default (e.g. a reference to a\n> gap element). So the only overhead is copying over the reference to\n> the parent, and a bit of extra memory allocation\n> \n> Of course, the parent itself has stuff about GAP and categories, but\n> that's initialized once for all, and does not influence arithmetic on\n> elements.\n\nI am partially worried about how much these extra copy operations cost on the E<sub>8</sub> iteration scale, as well as the inherent overhead of the generated code from Cython. Plus I like having code where we completely control the memory allocations. It might end up that we really don't see much of an improvement, but I think it is worth trying.",
    "created_at": "2016-05-16T14:01:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278504",
    "user": "tscrim"
}
```

Replying to [comment:29 nthiery]:
> Replying to [comment:27 tscrim]:
> > I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.
> 
> We can discuss this in Meudon.

Sounds good.

> > I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.
> 
> For the record: I just checked, and the data structure for permutation
> group elements is just a reference to the parent and a C-list of ints;
> plus a few slots which are unused by default (e.g. a reference to a
> gap element). So the only overhead is copying over the reference to
> the parent, and a bit of extra memory allocation
> 
> Of course, the parent itself has stuff about GAP and categories, but
> that's initialized once for all, and does not influence arithmetic on
> elements.

I am partially worried about how much these extra copy operations cost on the E<sub>8</sub> iteration scale, as well as the inherent overhead of the generated code from Cython. Plus I like having code where we completely control the memory allocations. It might end up that we really don't see much of an improvement, but I think it is worth trying.



---

archive/issue_comments_278505.json:
```json
{
    "body": "New commits:",
    "created_at": "2018-05-28T10:51:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278505",
    "user": "tscrim"
}
```

New commits:



---

archive/issue_comments_278506.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-28T14:59:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278506",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278507.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-05-28T14:59:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278507",
    "user": "tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_278508.json:
```json
{
    "body": "some failing doctests, missing `optional gap3`",
    "created_at": "2018-05-28T19:09:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278508",
    "user": "chapoton"
}
```

some failing doctests, missing `optional gap3`



---

archive/issue_comments_278509.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-28T20:28:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278509",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278510.json:
```json
{
    "body": "Fixed.",
    "created_at": "2018-05-28T20:28:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278510",
    "user": "tscrim"
}
```

Fixed.



---

archive/issue_comments_278511.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-30T15:28:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278511",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_278512.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-05-30T15:36:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278512",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_278513.json:
```json
{
    "body": "looked through Travis' changes...",
    "created_at": "2018-05-30T15:39:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278513",
    "user": "stumpc5"
}
```

looked through Travis' changes...



---

archive/issue_comments_278514.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-05-30T15:39:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278514",
    "user": "stumpc5"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_278515.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-05-31T17:25:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20208",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20208#issuecomment-278515",
    "user": "vbraun"
}
```

Resolution: fixed
