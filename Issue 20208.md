# Issue 20208: Iteration through Coxeter groups

Issue created by migration from Trac.

Original creator: stumpc5

Original creation time: 2016-04-14 10:09:16

CC:  tscrim chapoton nthiery vripoll

The algorithm in chevie is very different from the algorithm we currently have:

```
ForEachElement:=function(W,f)local l,g;
  if not IsFinite(W) then Error("only for finite Coxeter groups");
  elif W.nbGeneratingReflections=0 then f(W.identity);return;
  fi;
  l:=List([0..W.nbGeneratingReflections],i->
        ReflectionSubgroup(W,W.reflectionsLabels{[1..i]}));
  l:=List([1..Length(l)-1],i->ReducedRightCosetRepresentatives(l[i+1],l[i]));
  g:=function(x,v)local y;
    if Length(v)=0 then f(x);
    else for y in v[1] do g(x*y,v{[2..Length(v)]});od;
    fi;
  end;
  g(W.identity,l);
end;
```


We should also implement that algorithm (maybe even with hard-coded coset representatives in the finite case) so that we can see if this is indeed faster.


---

Comment by stumpc5 created at 2016-04-15 05:37:11


```
###########################################################################
#
# N.B. a difference with older versions of Chevie is that IsLeftDescending and
# FirstLeftDescending  return  an  index  in  the  list  of  generators, not a
# reflectionName,  for  efficiency.  LeftDescentSet  still  returns  names  of
# reflections.
#
###########################################################################

##  generic reduction of FirstLeftDescending to IsLeftDescending
##  in practical implementations of Coxeter groups this routine can often
##  be overriden by a more efficient one.

AbsCoxOps.FirstLeftDescending:=function(W, x)local i,ILD;
  ILD:=W.operations.IsLeftDescending; # avoid dispatching overhead
  for i in W.generatingReflections do if ILD(W,x,i) then return i; fi; od;
  return false;
end;
```



---

Comment by git created at 2016-04-15 18:56:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2016-04-15 18:56:59

Last 10 new commits:


---

Comment by stumpc5 created at 2016-04-15 18:58:41

Travis, I implemented a first version of the algoritm, getting all needed cosets in E7 takes 2/3 of our iteration time, but constructing the elements in the end takes about 30secs. If you find the time, I am sure you see how to speed the algorithm. The function is `parabolic_iteration`.


---

Comment by git created at 2016-04-16 11:26:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-04-17 15:10:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-04-17 16:15:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2016-04-17 16:16:34


```
sage: timeit("for w in W.iteration('depth',False): pass",number=5)
5 loops, best of 3: 6.33 s per loop
sage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration
sage: timeit("for w in parabolic_iteration(W): pass",number=5)    
5 loops, best of 3: 4.28 s per loop
```

Okay, I can now get down quite a bit from our last weeks algorithm. Drawback is that it needs quite some memory (for E8, we have to keep E7 in memory). I provide an alternative in which order the parabolic is computed, but that doesn't seem to speed the computation.

* If `@`tscrim looks at the code and improves it further, we might beat the 5 minutes for E8!
* The code can also perfectly be paralellized!


---

Comment by git created at 2016-04-17 19:42:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2016-04-18 13:05:16

I locally reimplemented the multiplication of `PermutationGroupElement`. This resulted in

```
sage: W = ReflectionGroup(['E',7])                                                
sage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration
sage: timeit("for w in parabolic_iteration(W): pass",number=5)                    
5 loops, best of 3: 2.4 s per loop
```

If we provide a very restricted implementation of permutations ourselves, we might get down further quite a bit. Remark: the algorithm without the multiplication and creation of new permutation group elements only takes `.5sec`, so there is a lot to improve still.


---

Comment by git created at 2016-04-18 13:08:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2016-04-19 20:06:42

I just redid the computations and it seems to be about twice as fast as in gap3:

```
sage: W = ReflectionGroup(['E',7])
sage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration
sage: timeit("for w in parabolic_iteration(W): pass",number=5)
5 loops, best of 3: 1.56 s per loop
sage: timeit("for w in parabolic_iteration(W): pass",number=5)
5 loops, best of 3: 1.43 s per loop
sage: W = ReflectionGroup(['E',8])
sage: %time for w in parabolic_iteration(W): pass

CPU times: user 9min 12s, sys: 3.81 s, total: 9min 16s
Wall time: 9min 16s
```

So we are slowly approaching the 5min...


---

Comment by tscrim created at 2016-04-20 04:53:34

Took 3.5Gb of RAM with this ticket, but on my laptop, this is what I got:

```
sage: W = ReflectionGroup(['E',8])
sage: from sage.combinat.root_system.reflection_group_c import parabolic_iteration
sage: %time for w in parabolic_iteration(W): pass
CPU times: user 4min 23s, sys: 604 ms, total: 4min 23s
Wall time: 4min 23s
```



---

Comment by git created at 2016-04-20 07:19:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2016-04-20 09:25:07

Replying to [comment:15 tscrim]:
    CPU times: user 4min 23s, sys: 604 ms, total: 4min 23s
    Wall time: 4min 23s

Great, I believe you can claim to be the first person ever who iterated through E8 in less than 5 minutes! (I was expecting that since 1. your computer was about twice as fast as mine last week, and 2. you took ~8 minutes to iter through E8 in chevie, and my code is about twice as fast as the chevie code.)

1. I would really like to see how to implement our own permutation group elements with only what we need. I would hope that to again result in some speedup. One question there: we have w(-\beta) = -w(\beta), so we would not need to record the complete permutation on all roots, but on the positive roots would be enough. That would speed several computations such as creating new elements and testing for equality), but it would have the drawback that we constantly need to work mod N (N=nr of positive roots), e.g., we would have such checks and mod's when multiplying two permutations.

2. We should get your parallelization to work with this so that people can then use many cores to actually do stuff with the elements in type E8.


---

Comment by git created at 2016-04-21 15:23:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2016-04-21 15:25:11

Travis, could you also now run

```
sage: W = ReflectionGroup(['E',8])
sage: %time for w in W.iteration("depth",False): pass
```

It now also uses the local multiplication, so it should also speed quite a bit. On my machine, it's only 1.5 times as slow.


---

Comment by tscrim created at 2016-04-21 15:43:18

With doing other things on my laptop:

```
sage: W = ReflectionGroup(['E',8])
sage: %time for w in W.iteration("depth",False): pass
CPU times: user 6min 39s, sys: 22.5 ms, total: 6min 39s
Wall time: 6min 39s
```



---

Comment by git created at 2016-05-10 19:36:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by stumpc5 created at 2016-05-10 20:08:02

`@`Nicolas: I just now see that you (I think) accidentally edited my comment (comment 5 above from here) instead of replying three weeks ago. Could you quickly recheck?


---

Comment by nthiery created at 2016-05-11 07:43:38

Replying to [comment:17 stumpc5]:
> 1. I would really like to see how to implement our own permutation group elements with only what we need. I would hope that to again result in some speedup. One question there: we have w(-\beta) = -w(\beta), so we would not need to record the complete permutation on all roots, but on the positive roots would be enough. That would speed several computations such as creating new elements and testing for equality), but it would have the drawback that we constantly need to work mod N (N=nr of positive roots), e.g., we would have such checks and mod's when multiplying two permutations.

This business sounds of the same nature as what we have for affine
permutations (in window notation). Would there be a way to use the
same implementation behind the scene?

Cheers,
                               Nicolas


---

Comment by nthiery created at 2016-05-11 07:43:58

Replying to [comment:22 stumpc5]:
> `@`Nicolas: I just now see that you (I think) accidentally edited my comment (comment 5 above from here) instead of replying three weeks ago. Could you quickly recheck?

Oops, reverted!


---

Comment by stumpc5 created at 2016-05-11 08:21:57

Replying to [comment:23 nthiery]:
> Replying to [comment:17 stumpc5]:
> This business sounds of the same nature as what we have for affine
> permutations (in window notation). Would there be a way to use the
> same implementation behind the scene?

And also with colored permutations, isn't it? The main difference is that here (and also in signed permutations) one works mod N, for colored permutations one works "+N mod kN", and for affine permutation one does not work mod anything.

I would propose to first work out the implementation here and then see if we can use it also in the other places. I only don't see how to actually do the implementation in an optimal way, so some support of yours and/or Travis is appreciated.

Some concrete questions:

1. It seems that we should use the same data structure as for `PermutationGroupElement`:
   {{{
       self.perm = <int *>sig_malloc(sizeof(int) * self.N)
   }}}
   Do you agree? Can we even get anything significantly better than sticking to `PermutationGroupElement` if we do it ourselves? This also asks whether we can do better when multiplying elements, I do not see what
   {{{
    cdef PermutationGroupElement prod = PermutationGroupElement.__new__(PermutationGroupElement)
   }}}
   does or how long it takes, see the method `_new_mul_` in `reflection_group_c.pyx`.

3. It seems that we are using `PermutationGroupElement` in a few places (when talking to `GAP3`}), but this might just be that we need the cycle string representation for that.


---

Comment by stumpc5 created at 2016-05-11 08:33:56

`@`Travis: Could you have a brief look at the `_new_mul_` in `reflection_group_c.pyx` to check whether I am missing something, or whether I could use that as a first improvement in this algorithm.

I indeed plan to have this ticket only contain the improvements for now (then having plenty of options for iterating through finite Coxeter groups), postponing the work and testing for a new data structure to a new ticket.


---

Comment by tscrim created at 2016-05-11 14:49:15

Replying to [comment:25 stumpc5]:
> I would propose to first work out the implementation here and then see if we can use it also in the other places. I only don't see how to actually do the implementation in an optimal way, so some support of yours and/or Travis is appreciated.

I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.

> Some concrete questions:
> 
> 1. It seems that we should use the same data structure as for `PermutationGroupElement`:
>    {{{
>        self.perm = <int *>sig_malloc(sizeof(int) * self.N)
>    }}}
>    Do you agree? Can we even get anything significantly better than sticking to `PermutationGroupElement` if we do it ourselves?

I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.

>    This also asks whether we can do better when multiplying elements, I do not see what
>    {{{
>     cdef PermutationGroupElement prod = PermutationGroupElement.__new__(PermutationGroupElement)
>    }}}
>    does or how long it takes, see the method `_new_mul_` in `reflection_group_c.pyx`.

This creates a new element in memory, but it does not call the `__init__`. It is essential and done in Python kernel, so we won't get any better.

> 3. It seems that we are using `PermutationGroupElement` in a few places (when talking to `GAP3`}), but this might just be that we need the cycle string representation for that.

GAP4 doesn't store things as cycle strings AFAIK, and so I doubt GAP3 does either.Replying to [comment:25 stumpc5]:
> I would propose to first work out the implementation here and then see if we can use it also in the other places. I only don't see how to actually do the implementation in an optimal way, so some support of yours and/or Travis is appreciated.

I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.

> Some concrete questions:
> 
> 1. It seems that we should use the same data structure as for `PermutationGroupElement`:
>    {{{
>        self.perm = <int *>sig_malloc(sizeof(int) * self.N)
>    }}}
>    Do you agree? Can we even get anything significantly better than sticking to `PermutationGroupElement` if we do it ourselves?

I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.

>    This also asks whether we can do better when multiplying elements, I do not see what
>    {{{
>     cdef PermutationGroupElement prod = PermutationGroupElement.__new__(PermutationGroupElement)
>    }}}
>    does or how long it takes, see the method `_new_mul_` in `reflection_group_c.pyx`.

This creates a new element in memory, but it does not call the `__init__`. It is essential and done in Python kernel, so we won't get any better.

> 3. It seems that we are using `PermutationGroupElement` in a few places (when talking to `GAP3`}), but this might just be that we need the cycle string representation for that.

GAP4 doesn't store things as cycle strings AFAIK, and so I doubt GAP3 does either. We could very likely replace these calls with something better (if we are calling GAP3).


---

Comment by stumpc5 created at 2016-05-12 08:52:07

Replying to [comment:27 tscrim]:
> Replying to [comment:25 stumpc5]:
> I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.

Let me quickly ask: by "create our own separate project where we write all of this independently (in, say, C/C++)" you mean implementing this permutation group element there and then use it from our sage implementation, right?

I'd be happy to follow and help with than whenever you find the time, but at first I will likely only be watching you doing it...


---

Comment by nthiery created at 2016-05-16 08:50:05

Replying to [comment:27 tscrim]:
> I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.

We can discuss this in Meudon.

> I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.

For the record: I just checked, and the data structure for permutation
group elements is just a reference to the parent and a C-list of ints;
plus a few slots which are unused by default (e.g. a reference to a
gap element). So the only overhead is copying over the reference to
the parent, and a bit of extra memory allocation

Of course, the parent itself has stuff about GAP and categories, but
that's initialized once for all, and does not influence arithmetic on
elements.

Cheers,
                             Nicolas


---

Comment by tscrim created at 2016-05-16 14:01:40

Replying to [comment:29 nthiery]:
> Replying to [comment:27 tscrim]:
> > I'm really starting to consider that what we should do is create our own separate project where we write all of this independently (in, say, C/C++). At this stage, I'm somewhat concerned with the additional overhead that Cython could impose and the lack of complete memory control. Although I cannot commit serious time to working on this for then next two weeks (I will be in grading and math mode). Over the summer starting in June, I should be able to do so.
> 
> We can discuss this in Meudon.

Sounds good.

> > I think we can avoid a bit of overhead of maintaining the GAP and category information. Although it is hard to tell how much of an impact this will have on things.
> 
> For the record: I just checked, and the data structure for permutation
> group elements is just a reference to the parent and a C-list of ints;
> plus a few slots which are unused by default (e.g. a reference to a
> gap element). So the only overhead is copying over the reference to
> the parent, and a bit of extra memory allocation
> 
> Of course, the parent itself has stuff about GAP and categories, but
> that's initialized once for all, and does not influence arithmetic on
> elements.

I am partially worried about how much these extra copy operations cost on the E<sub>8</sub> iteration scale, as well as the inherent overhead of the generated code from Cython. Plus I like having code where we completely control the memory allocations. It might end up that we really don't see much of an improvement, but I think it is worth trying.


---

Comment by tscrim created at 2018-05-28 10:51:17

New commits:


---

Comment by git created at 2018-05-28 14:59:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-05-28 14:59:41

Changing status from new to needs_review.


---

Comment by chapoton created at 2018-05-28 19:09:57

some failing doctests, missing `optional gap3`


---

Comment by git created at 2018-05-28 20:28:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-05-28 20:28:40

Fixed.


---

Comment by git created at 2018-05-30 15:28:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-05-30 15:36:35

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by stumpc5 created at 2018-05-30 15:39:34

looked through Travis' changes...


---

Comment by stumpc5 created at 2018-05-30 15:39:34

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-05-31 17:25:50

Resolution: fixed
