# Issue 30136: Parent methods tensor vs. tensor_product

Issue created by migration from https://trac.sagemath.org/ticket/30373

Original creator: mkoeppe

Original creation time: 2020-08-16 00:12:20

CC:  tscrim egourgoulhon @mjungmath jhpalmieri chapoton

We unify the use of `tensor` vs. `tensor_product` in parent classes.

Current situation:

Category `ModulesWithBasis` provides a parent method `tensor` to construct a tensor product of modules.

```
sage: C = CombinatorialFreeModule(QQ, ['x', 'y'])                                                                                                                
sage: C.tensor(C)                                                                                                                                                
Free module generated by {'x', 'y'} over Rational Field # Free module generated by {'x', 'y'} over Rational Field
```

It is not implemented completely for `FreeModule`

```
sage: V = FreeModule(QQ, 2)                                                                                                                                      
sage: V.tensor(V)                                                                                                                                                
AttributeError: type object 'FreeModule_ambient_field_with_category' has no attribute 'Tensor'
sage: 
```


In contrast, `FiniteRankFreeModule` (which is not in `ModulesWithBasis`) uses a parent method `tensor` to construct elements.

```
sage: F.tensor((2, 2))                                                                                                                                           
Type-(2,2) tensor on the 2-dimensional vector space over the Rational Field
```


`FilteredVectorSpace` has both `tensor` (from `ModulesWithBasis`) and `tensor_product`, but only the latter works.

```
sage: FV = FilteredVectorSpace(2)                                                                                                                                
sage: FV.tensor_product(FV)                                                                                                                                      
QQ^4
sage: FV.tensor(FV)                                                                                                                                              
AttributeError: type object 'FilteredVectorSpace_class_with_category' has no attribute 'Tensor'
```

The same is true for `FreeQuadraticModule_integer_symmetric`:

```
sage: L = IntegralLattice(Matrix(ZZ, 2, [2,1,1,-2]))                                                                                                             
sage: L.tensor_product(L)                                                                                                                                        
Lattice of degree 4 and rank 4 over Integer Ring
Standard basis 
Inner product matrix:
[ 4  2  2  1]
[ 2 -4  1 -2]
[ 2  1 -4 -2]
[ 1 -2 -2  4]
sage: L.tensor(L)                                                                                                                                                
AttributeError: type object 'FreeQuadraticModule_integer_symmetric_with_categor' has no attribute 'Tensor'
```



---

Comment by jhpalmieri created at 2021-01-20 18:43:58

A few other things to think about:
- In the first example, `C.tensor(C, C)` works as expected. In contrast, the `tensor` function doesn't take multiple inputs, but instead an iterable: `tensor([C,C,C])` instead of `tensor(C, C, C)`. I would prefer a consistent syntax.
- What about tensoring elements together? Right now the `tensor` function works on elements, although the documentation doesn't make this clear. I am happy for this to continue, but again, the syntax is different for `tensor([a,b,c])` vs. `a.tensor(b,c)`.


---

Comment by @mjungmath created at 2021-01-21 18:01:49

Replying to [comment:6 jhpalmieri]:
> A few other things to think about:
> - In the first example, `C.tensor(C, C)` works as expected. In contrast, the `tensor` function doesn't take multiple inputs, but instead an iterable: `tensor([C,C,C])` instead of `tensor(C, C, C)`. I would prefer a consistent syntax.

+1. I don't have a strong opinion which one we choose. Multiple inputs feels more flexible (and doesn't need an additional bracket).

> - What about tensoring elements together? Right now the `tensor` function works on elements, although the documentation doesn't make this clear. I am happy for this to continue, but again, the syntax is different for `tensor([a,b,c])` vs. `a.tensor(b,c)`.

I like that behavior, too. However, it feels to me like this behavior was not intended and just works because the element provides a `tensor` method (that's probably why it's not mentioned in the documentation). From a mathematical-categorial viewpoint this behavior is anyway unexpected (functors usually do not act on objects of objects).

If we want to promote this, which I would agree with, the syntax should indeed be the same.

This might also be a good opportunity to introduce the ``@`` notation you have proposed in [here](https://trac.sagemath.org/ticket/30244#comment:3) which I really like (so +1 from my side, too).

As for `FiniteRankFreeModule`, introducing methods like `tensor_product` and `tensor_power` is readily done (I already finished the former).

So, should we split the task into several pieces, and I provide the `FiniteRankFreeModule` add-on? You just have to tell me which syntax you prefer.


---

Comment by mkoeppe created at 2021-01-21 18:10:23

Replying to [comment:7 gh-mjungmath]:
> This might also be a good opportunity to introduce the ``@`` notation you have proposed in [here](https://trac.sagemath.org/ticket/30244#comment:3) which I really like (so +1 from my side, too).

-1 on this - as per discussion in #30244, ``@`` should be for tensor contraction, not tensor product


---

Comment by @mjungmath created at 2021-01-21 18:15:24

Replying to [comment:8 mkoeppe]:
> Replying to [comment:7 gh-mjungmath]:
> > This might also be a good opportunity to introduce the ``@`` notation you have proposed in [here](https://trac.sagemath.org/ticket/30244#comment:3) which I really like (so +1 from my side, too).
> 
> -1 on this - as per discussion in #30244, ``@`` should be for tensor contraction, not tensor product

But the idea in principle remains, doesn't it? What about `#` instead? That's already the symbol for tensor products as in `categories/tensor.py`.

Arrrg, that's commenting...


---

Comment by mkoeppe created at 2021-01-21 18:18:34

Python has only a fixed set of binary operators available. One can resort to overloading something that's rarely used otherwise. In #30244 I suggested `&` as a possibility, but I am not sure if it's a good idea.


---

Comment by @mjungmath created at 2021-01-21 18:21:56

Replying to [comment:10 mkoeppe]:
> Python has only a fixed set of binary operators available. One can resort to overloading something that's rarely used otherwise. In #30244 I suggested `&` as a possibility, but I am not sure if it's a good idea.

It feels rather uncanonical. But tensor products seem to be used quite frequently, so if there's no better bet...

What's your opinion on the syntax?

Should I open another ticket to provide `tensor_product`, `tensor_power` for `FiniteRankFreeModule` or just push it into here as open branch?


---

Comment by jhpalmieri created at 2021-01-21 18:50:40

We should make people use the unicode `⊗` for tensor product.

More seriously, if we can switch the syntax to `tensor(a,b,c,...)` with no extra brackets, that would be nice. I don't know if any of the tensor constructors take optional arguments, so I don't know how hard that would be to implement.


---

Comment by @mjungmath created at 2021-01-21 21:15:56

I've opened a ticket for the `FiniteRankFreeModule` case: #31276.


---

Comment by tscrim created at 2021-01-22 01:12:52

Multiple inputs can also be really annoying when you want to create a list dynamically as you then have to add a `*` and possibly extra parentheses. The easiest thing to do is to support both behaviors. This is simple enough to implement.

The tensor unicode would be good, except it would depend on how the Python interpreter takes that. Most likely, we would need to implement another find-replace case in the preparser to go to some overloaded infix operator such as `&`.


---

Comment by @mjungmath created at 2021-01-22 23:54:28

Speaking of shortcuts for operations: what about using `^` for the wedge product? There is nothing more appropriate than that!

If that meets your approval, I'll open a ticket for this.


---

Comment by jhpalmieri created at 2021-01-23 00:02:16

I find it too easily confused with the exponentiation operator, so I would not like to see it featured prominently in doctests.


---

Comment by @mjungmath created at 2021-01-23 00:22:27

So far, the `^` is not supported for exterior algebras:


```
sage: M = FiniteRankFreeModule(QQ, 3)
sage: AM = M.dual_exterior_power(2)
sage: a = AM.an_element()
sage: a^2
Traceback (most recent call last)
...
TypeError: unsupported operand parent(s) for ^: '2nd exterior power of the dual of the 3-dimensional vector space over the Rational Field' and 'Integer Ring'
```


But I agree. One would rather expect `a^3 == a.wedge(a).wedge(a)` if supported.

Mh, one minute ago, I thought it was an ingenious idea. :D


---

Comment by tscrim created at 2021-01-23 05:51:19

Replying to [comment:16 jhpalmieri]:
> I find it too easily confused with the exponentiation operator, so I would not like to see it featured prominently in doctests.

However, I think it would be a nice syntactic sugar since `a ^ b`, for a,b in an exterior algebra, as exponentiation does not make sense.


---

Comment by @mjungmath created at 2021-01-23 09:48:19

Replying to [comment:18 tscrim]:
> Replying to [comment:16 jhpalmieri]:
> > I find it too easily confused with the exponentiation operator, so I would not like to see it featured prominently in doctests.
> 
> However, I think it would be a nice syntactic sugar since `a ^ b`, for a,b in an exterior algebra, as exponentiation does not make sense.

How do we treat `^` with integers then? As a wedge product, this is the simple multiplication. And I still agree, that this case can easily be confused with the exponential since exponentiation is the standard behavior of Sage anywhere else.


---

Comment by egourgoulhon created at 2021-01-23 10:23:39

Replying to [comment:12 jhpalmieri]:
> We should make people use the unicode `⊗` for tensor product.
A relevant ticket here: #30473


---

Comment by egourgoulhon created at 2021-01-23 10:29:55

Replying to [comment:19 gh-mjungmath]:
> Replying to [comment:18 tscrim]:
> > 
> > However, I think it would be a nice syntactic sugar since `a ^ b`, for a,b in an exterior algebra, as exponentiation does not make sense.
> 
> How do we treat `^` with integers then? As a wedge product, this is the simple multiplication. And I still agree, that this case can easily be confused with the exponential since exponentiation is the standard behavior of Sage anywhere else.

+1 (and IMHO `a^b` looks too far from a wedge product).


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by git created at 2022-08-23 16:50:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-23 17:10:54

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2022-08-23 17:18:53

Looks like the element classes also need to get `tensor_product` methods.

I'd welcome comments in this early stage whether this is going in a good direction


---

Comment by egourgoulhon created at 2022-08-23 20:39:28

Replying to [comment:31 mkoeppe]:
> Looks like the element classes also need to get `tensor_product` methods.
> 
> I'd welcome comments in this early stage whether this is going in a good direction

FWIW, in `FiniteRankFreeModule`'s, the element tensor product is implemented via the operator `*`, i.e. via the method `__mul__`.


---

Comment by mkoeppe created at 2022-09-04 19:48:10

The branch of #34448 shows the necessary workarounds in `sage.tensors` if we wanted to keep `tensor` (not `tensor_product`) as the name of the method that implements the action of `TensorProductFunctor`: The method `FiniteRankFreeModule.tensor` would have to double both as that and as the method that construct an element.

Any thoughts which of the 2 ways to go?


---

Comment by tscrim created at 2022-09-04 23:31:21

The  `tensor()` method is something used by the `tensor` functor as the hook within each class to build the tensor product IIRC. So it is a little more special of a method.


---

Comment by mkoeppe created at 2022-09-04 23:33:03

Yes, exactly. The branch here on the ticket changes it:

```
diff --git a/src/sage/categories/tensor.py b/src/sage/categories/tensor.py
index 67c4e64..18109d0 100644
--- a/src/sage/categories/tensor.py
+++ b/src/sage/categories/tensor.py
@@ -48,7 +48,7 @@ class TensorProductFunctor(CovariantFunctorialConstruction):
 
         sage: TestSuite(tensor).run()
     """
-    _functor_name = "tensor"
+    _functor_name = "tensor_product"
     _functor_category = "TensorProducts"
     symbol = " # "
     unicode_symbol = f" {unicode_otimes} "
```



---

Comment by git created at 2022-09-05 00:16:12

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2022-09-05 00:18:03

I see. It wasn’t entirely clear that was the proposal.

I am maybe marginally in favor of `tensor` since we say “A tensor B” and it would create slightly tension with the functor being called `tensor` In the global namespace. For the middle example, another way out of this would be to check the types of the input.

IMO, the last two examples in the ticket description perhaps should fail because the result doesn’t know about its tensor product construction. Yes, `QQ^2 (x) QQ^2 = QQ^2 (+) QQ^2 = QQ^4`, where `=` means isomorphic as `QQ`-vector spaces here, but there are two separate canonical projections onto `QQ^2` in the middle case and a functoral way to lift up `QQ^2` endomorphisms in the first case. There are also different structures if we have additional structure, such as a grading. TL;DR they are losing information that the result of `tensor` (Perhaps implicitly) is assuming is preserved.


---

Comment by mkoeppe created at 2022-09-05 00:32:55

The problem is that we have the clash with `FiniteRankFreeModule.tensor`.


---

Comment by mkoeppe created at 2022-09-05 00:33:49

Replying to [comment:40 Travis Scrimshaw]:
> For the middle example, another way out of this would be to check the types of the input.

Ah, I see that is what you referred to already.


---

Comment by mkoeppe created at 2022-09-05 00:35:41

So yes, in the branch of #34448 I fix the clash by checking types. But I'm not sure if this a clean enough solution.


---

Comment by git created at 2022-09-05 00:38:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-05 00:40:46

Replying to [comment:40 Travis Scrimshaw]:
> IMO, the last two examples in the ticket description perhaps should fail because the result doesn’t know about its tensor product construction. 

I haven't looked at these examples in detail, but your explanation makes sense. Nothing for this ticket though.


---

Comment by tscrim created at 2022-09-05 00:43:08

Replying to [comment:43 Matthias Köppe]:
> So yes, in the branch of #34448 I fix the clash by checking types. But I'm not sure if this a clean enough solution.

Indeed, it is not the most clean solution, but it is a side effect of English (and Python) that we cannot easily distinguish between “a tensor in” and “the tensor with” in such a concise way.


---

Comment by mkoeppe created at 2022-09-05 00:43:40

Replying to [comment:40 Travis Scrimshaw]:
> I am maybe marginally in favor of `tensor` since we say “A tensor B” and it would create slightly tension with the functor being called `tensor` In the global namespace. 

We could of course make `tensor` a non-deprecated alias and document that classes are allowed to overload it for additional idiomatic uses.


---

Comment by tscrim created at 2022-09-05 00:45:49

Replying to [comment:45 Matthias Köppe]:
> Replying to [comment:40 Travis Scrimshaw]:
> > IMO, the last two examples in the ticket description perhaps should fail because the result doesn’t know about its tensor product construction. 
> 
> I haven't looked at these examples in detail, but your explanation makes sense. Nothing for this ticket though.

If we rename it to `tensor_product`, then it starts working in a way that is incompatible with the tensor functor. It’s not a really big problem, but it could run into subtleties with `tensor([C, FV])` versus `tensor([FV, C])` with one of them working (and returning a wrong answer depending on the implementation that I haven’t checked) and the other not.


---

Comment by mkoeppe created at 2022-09-05 00:47:14

Hm? No, the tensor functor calls the method given in its `_functor_name`. That's what the change in comment:38 is for.


---

Comment by mkoeppe created at 2022-09-05 00:49:42

Oh, I think I get what you are saying: These two examples are undisciplined tensor products that don't comply with the guarantees of the functor?


---

Comment by tscrim created at 2022-09-05 00:54:22

Replying to [comment:49 Matthias Köppe]:
> Hm? No, the tensor functor calls the method given in its `_functor_name`. That's what the change in comment:38 is for.

Right, and `FV` and `L` from the description have a `tensor_product` method already. This could potentially take a CFM `C` and return, say, a filtered vector space (with the right methods), but not the other way around. Even if both worked (which is also possible), they would result in very different implementations. Although since tensor products in general are not “commutative,” we can wave it away, but it would mean more brittle code.


---

Comment by tscrim created at 2022-09-05 00:55:02

Replying to [comment:50 Matthias Köppe]:
> Oh, I think I get what you are saying: These two examples are undisciplined tensor products that don't comply with the guarantees of the functor?

Yes, that’s right. Sorry if I wasn’t explaining clearly enough.


---

Comment by mkoeppe created at 2022-09-05 00:57:10

By the way, `FilteredVectorSpace` appears to be the only consumer of `sage.modules.tensor_operations`, which can probably be eliminated


---

Comment by git created at 2022-09-05 03:17:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-05 03:17:22

Here's an attempt


---

Comment by git created at 2022-09-05 05:00:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-05 05:51:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-05 13:50:13

I don’t like this fallback for two reasons:

1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
2. (More of a worry since I haven’t checked it.) It returns an object that suggests there is less structure than their might be because of a lack of an implementation. Does this preserve the algebra structure when we take a tensor product of algebras?


---

Comment by mkoeppe created at 2022-09-05 13:57:57

Replying to [comment:60 Travis Scrimshaw]:
> I don’t like this fallback for two reasons:
> 
> 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.

The result doesn't have to know because it does not advertise itself as a tensor product.


---

Comment by tscrim created at 2022-09-05 14:04:02

Replying to [comment:61 Matthias Köppe]:
> Replying to [comment:60 Travis Scrimshaw]:
> > I don’t like this fallback for two reasons:
> > 
> > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> 
> The result doesn't have to know because it does not advertise itself as a tensor product.

That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.


---

Comment by tscrim created at 2022-09-05 14:05:17

Let me put it another way, the result is not in the codomain of the functor.


---

Comment by mkoeppe created at 2022-09-05 14:06:40

Replying to [comment:62 Travis Scrimshaw]:
> Replying to [comment:61 Matthias Köppe]:
> > Replying to [comment:60 Travis Scrimshaw]:
> > > I don’t like this fallback for two reasons:
> > > 
> > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> > 
> > The result doesn't have to know because it does not advertise itself as a tensor product.
> 
> That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.

Suppose as a user I want to construct it anyway. What should I do then?


---

Comment by mkoeppe created at 2022-09-05 14:07:36

Replying to [comment:63 Travis Scrimshaw]:
> Let me put it another way, the result is not in the codomain of the functor.

I think you're conflating mathematical structure with implementation here.


---

Comment by tscrim created at 2022-09-05 14:09:41

Replying to [comment:64 Matthias Köppe]:
> Replying to [comment:62 Travis Scrimshaw]:
> > Replying to [comment:61 Matthias Köppe]:
> > > Replying to [comment:60 Travis Scrimshaw]:
> > > > I don’t like this fallback for two reasons:
> > > > 
> > > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> > > 
> > > The result doesn't have to know because it does not advertise itself as a tensor product.
> > 
> > That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.
> 
> Suppose as a user I want to construct it anyway. What should I do then?

The class needs to have its own hook separate from the hook that the functor uses.


---

Comment by tscrim created at 2022-09-05 14:14:33

Replying to [comment:65 Matthias Köppe]:
> Replying to [comment:63 Travis Scrimshaw]:
> > Let me put it another way, the result is not in the codomain of the functor.
> 
> I think you're conflating mathematical structure with implementation here.

How so? The result does not know it is a tensor product of modules, and there is no canonical way to deconstruct a vector space into a tensor product. For example, a 1-dimensional module could be a `n`-fold tensor product of itself `n` times. There are no canonical isomorphisms between these spaces. These are also not even isomorphic as graded vector spaces in general either (one needs a grading shift).


---

Comment by mkoeppe created at 2022-09-05 14:20:43

Mathematically an object *is* a tensor product if there *exists* a construction of it using the tensor functor.

In an implementation, we generally cannot know if something exists. An object is marked *as* a tensor product when the implementation has marked it as such. Like everything, this is subject to the implementation restrictions.


---

Comment by mkoeppe created at 2022-09-05 14:22:42

Replying to [comment:66 Travis Scrimshaw]:
> Replying to [comment:64 Matthias Köppe]:
> > Replying to [comment:62 Travis Scrimshaw]:
> > > Replying to [comment:61 Matthias Köppe]:
> > > > Replying to [comment:60 Travis Scrimshaw]:
> > > > > I don’t like this fallback for two reasons:
> > > > > 
> > > > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> > > > 
> > > > The result doesn't have to know because it does not advertise itself as a tensor product.
> > > 
> > > That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.
> > 
> > Suppose as a user I want to construct it anyway. What should I do then?
> 
> The class needs to have its own hook separate from the hook that the functor uses.

No, as a user. Suppose there is no such specific implementation. What should the user do?


---

Comment by tscrim created at 2022-09-07 04:43:10

Replying to [comment:68 Matthias Köppe]:
> Mathematically an object *is* a tensor product if there *exists* a construction of it using the tensor functor.

Then every object is a tensor product since we can always tensor with a 1-dimensional module. If we wanted to talk in that level of generality, there is no category of tensor products, Cartesean products, etc.

> In an implementation, we generally cannot know if something exists. An object is marked *as* a tensor product when the implementation has marked it as such. Like everything, this is subject to the implementation restrictions.

Indeed, the category also contains some implementation requirements. (I would argue the tensor products category is the category with a distinguished tensor product construction, parallel to `ModulesWithBasis`.) Consequently, the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.

More concretely, if I had code that does:

```python
T = tensor([V,W])
for F in T.tensor_factors():
     print(F)
```

This should work whenever `T` is constructed because the codomain is `Cat.TensorProducts()`, where `Cat` is the meet of the categories of `V` and `W`. However, with changing the name, the functor now would work but the code would fail with `FilteredVectorSpace`s.


---

Comment by tscrim created at 2022-09-07 04:50:36

Replying to [comment:69 Matthias Köppe]:
> Replying to [comment:66 Travis Scrimshaw]:
> > Replying to [comment:64 Matthias Köppe]:
> > > Replying to [comment:62 Travis Scrimshaw]:
> > > > Replying to [comment:61 Matthias Köppe]:
> > > > > Replying to [comment:60 Travis Scrimshaw]:
> > > > > > I don’t like this fallback for two reasons:
> > > > > > 
> > > > > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> > > > > 
> > > > > The result doesn't have to know because it does not advertise itself as a tensor product.
> > > > 
> > > > That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.
> > > 
> > > Suppose as a user I want to construct it anyway. What should I do then?
> > 
> > The class needs to have its own hook separate from the hook that the functor uses.
> 
> No, as a user. Suppose there is no such specific implementation. What should the user do?

My guess is stop wishing for magical coding fairies and implement it. There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. (Another version: How do you build a matrix from a tensor product of two matrices? There are two main ways to do this that are equivalent as they amount to choosing a different order of the isomorphism.) If a class `Foo` wants to know that a tensor product of two of itself can again be realized as an object `Foo`, then it needs to implement that and chose a specific isomorphism.


---

Comment by mkoeppe created at 2022-09-07 04:51:09

Replying to [comment:70 Travis Scrimshaw]:
> the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.

No, I think this is too strict to be useful.


---

Comment by mkoeppe created at 2022-09-07 04:52:33

Replying to [comment:71 Travis Scrimshaw]:
> Replying to [comment:69 Matthias Köppe]:
> > No, as a user. Suppose there is no such specific implementation. What should the user do?
> 
> My guess is stop wishing for magical coding fairies and implement it. 

No, no, users wouldn't like to be talked to like that.


---

Comment by mkoeppe created at 2022-09-07 04:59:29

We often want to identify 1-fold tensor products with the base module -- and the base module won't have the `tensor_factors` method. For example, this is what `sage.tensor.modules` and `sage.manifolds.differentiable` do.


---

Comment by tscrim created at 2022-09-07 05:06:48

Replying to [comment:72 Matthias Köppe]:
> Replying to [comment:70 Travis Scrimshaw]:
> > the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.
> 
> No, I think this is too strict to be useful. 

That an object in the codomain of a functor (or any morphism) must support what is required by that codomain (and should be an object such that `X in Cat` returns `True`)? I find this to actually be quite useful as I can expect certain properties to be there.

Consider the equivalent scenario: I have a function `f: ZZ -> QQ[‘s’]` that returned `0` as an integer and all non-zero elements as polynomials. You now have to write special checks for `0` rather than have it behave uniformly.


---

Comment by mkoeppe created at 2022-09-07 05:11:35

Replying to [comment:75 Travis Scrimshaw]:
> Replying to [comment:72 Matthias Köppe]:
> > Replying to [comment:70 Travis Scrimshaw]:
> > > the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.
> > 
> > No, I think this is too strict to be useful. 
> 
> That an object in the codomain of a functor (or any morphism) must support what is required by that codomain (and should be an object such that `X in Cat` returns `True`)? I find this to actually be quite useful as I can expect certain properties to be there.

There's always a tradeoff. Identifications such as the ones that I mentioned in comment:74 are also quite useful.


---

Comment by tscrim created at 2022-09-07 05:15:24

Replying to [comment:73 Matthias Köppe]:
> Replying to [comment:71 Travis Scrimshaw]:
> > Replying to [comment:69 Matthias Köppe]:
> > > No, as a user. Suppose there is no such specific implementation. What should the user do?
> > 
> > My guess is stop wishing for magical coding fairies and implement it. 
> 
> No, no, users wouldn't like to be talked to like that.

Of course I wouldn’t necessarily tell them in that way. However, unless somebody actually writes the code, then it doesn’t magically come into existence. Unfortunately, this is not the Dire Straights song “Money for Nothing”; Also Hell is full of 10 year olds who wished for exactly the same thing with the holophonor.

In this case, I believe it is impossible to implement in the level of generality you want because it amounts to making a canonical choice where there is not one.


---

Comment by mkoeppe created at 2022-09-07 05:17:15

Replying to [comment:71 Travis Scrimshaw]:
> There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 

It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.


---

Comment by tscrim created at 2022-09-07 05:18:09

Replying to [comment:76 Matthias Köppe]:
> Replying to [comment:75 Travis Scrimshaw]:
> > Replying to [comment:72 Matthias Köppe]:
> > > Replying to [comment:70 Travis Scrimshaw]:
> > > > the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.
> > > 
> > > No, I think this is too strict to be useful. 
> > 
> > That an object in the codomain of a functor (or any morphism) must support what is required by that codomain (and should be an object such that `X in Cat` returns `True`)? I find this to actually be quite useful as I can expect certain properties to be there.
> 
> There's always a tradeoff. Identifications such as the ones that I mentioned in comment:74 are also quite useful. 

I agree that they are useful, but you need a canonical way to do it in general. The point is that you are making an identification based upon a specific choice of isomorphism. Individual classes are allowed to make that choice, which you are implicitly doing when you have either a `as_foo()` method or `Foo(T)` in your code.


---

Comment by tscrim created at 2022-09-07 05:19:44

Replying to [comment:78 Matthias Köppe]:
> Replying to [comment:71 Travis Scrimshaw]:
> > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> 
> It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.

But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.


---

Comment by mkoeppe created at 2022-09-07 05:23:25

I think in comment:79 you replied to the wrong comment.


---

Comment by tscrim created at 2022-09-07 05:27:00

Replying to [comment:81 Matthias Köppe]:
> I think in comment:79 you replied to the wrong comment.

It applies to both comment:76 and comment:74. I just chose the more recent one.


---

Comment by mkoeppe created at 2022-09-07 05:29:24

Replying to [comment:80 Travis Scrimshaw]:
> Replying to [comment:78 Matthias Köppe]:
> > Replying to [comment:71 Travis Scrimshaw]:
> > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> > 
> > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.
> But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.

No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.


---

Comment by mkoeppe created at 2022-09-07 05:30:45

Replying to [comment:82 Travis Scrimshaw]:
> Replying to [comment:81 Matthias Köppe]:
> > I think in comment:79 you replied to the wrong comment.
> 
> It applies to both comment:76 and comment:74. I just chose the more recent one.

Wait, you are concerned about the identification of a module M with its 1-fold tensor product not being canonical?


---

Comment by mkoeppe created at 2022-09-07 05:39:35

For the question of 1-fold tensor products, there's by the way an old ticket: #18349


---

Comment by tscrim created at 2022-09-07 05:56:45

Replying to [comment:83 Matthias Köppe]:
> Replying to [comment:80 Travis Scrimshaw]:
> > Replying to [comment:78 Matthias Köppe]:
> > > Replying to [comment:71 Travis Scrimshaw]:
> > > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> > > 
> > > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.
> > But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.
> 
> No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.

Sorry, that was a bad phrasing on my part. You are asking for returning **R**<sup>6</sup> to be okay, which you have had to make a (non-canonical) choice of a isomorphism that they user has no control over. The tensor product category has a special distinguished choice of construction as a tensor product, analogous to `ModulesWithBasis` being modules with a distinguished choice of a basis.


---

Comment by tscrim created at 2022-09-07 06:02:04

Replying to [comment:84 Matthias Köppe]:
> Replying to [comment:82 Travis Scrimshaw]:
> > Replying to [comment:81 Matthias Köppe]:
> > > I think in comment:79 you replied to the wrong comment.
> > 
> > It applies to both comment:76 and comment:74. I just chose the more recent one.
> 
> Wait, you are concerned about the identification of a module M with its 1-fold tensor product not being canonical?

Not specifically for the 1-fold tensor products, but more generally. This code is expected to work for arbitrary tensor products with no special cases, right? (I can also tell you about the troubles I’ve had with `PartitionTuples` of length 1 versus `Partitions`, which motivates my desire for uniformity.)


---

Comment by mkoeppe created at 2022-09-07 15:31:14

Replying to [comment:86 Travis Scrimshaw]:
> Replying to [comment:83 Matthias Köppe]:
> > Replying to [comment:80 Travis Scrimshaw]:
> > > Replying to [comment:78 Matthias Köppe]:
> > > > Replying to [comment:71 Travis Scrimshaw]:
> > > > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> > > > 
> > > > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.
> > > But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.
> > 
> > No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.
> 
> Sorry, that was a bad phrasing on my part. You are asking for returning **R**<sup>6</sup> to be okay

No


---

Comment by mkoeppe created at 2022-09-07 15:32:13

Replying to [comment:77 Travis Scrimshaw]:
> Unfortunately, this is not the Dire Straights song “Money for Nothing”

I do appreciate the attempt to engage in intergenerational dialogue


---

Comment by tscrim created at 2022-09-07 23:19:04

Replying to [comment:88 Matthias Köppe]:
> Replying to [comment:86 Travis Scrimshaw]:
> > Replying to [comment:83 Matthias Köppe]:
> > > Replying to [comment:80 Travis Scrimshaw]:
> > > > Replying to [comment:78 Matthias Köppe]:
> > > > > Replying to [comment:71 Travis Scrimshaw]:
> > > > > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> > > > > 
> > > > > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.
> > > > But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.
> > > 
> > > No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.
> > 
> > Sorry, that was a bad phrasing on my part. You are asking for returning **R**<sup>6</sup> to be okay
> 
> No

Then if you rename the functor hook to `tensor_product`, then `FilteredVectorSpace`'s method of that name would have a bug.


---

Comment by tscrim created at 2022-09-07 23:24:53

Replying to [comment:89 Matthias Köppe]:
> Replying to [comment:77 Travis Scrimshaw]:
> > Unfortunately, this is not the Dire Straights song “Money for Nothing”
> 
> I do appreciate the attempt to engage in intergenerational dialogue

Actually, that is music I like. `;)` Or should I say I appreciate that there's "No One Like You" that I appreciate to have these discussions with.
