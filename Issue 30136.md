# Issue 30136: Parent methods tensor vs. tensor_product

archive/issues_030136.json:
```json
{
    "body": "CC:  tscrim egourgoulhon @mjungmath jhpalmieri chapoton\n\nWe unify the use of `tensor` vs. `tensor_product` in parent classes.\n\nCurrent situation:\n\nCategory `ModulesWithBasis` provides a parent method `tensor` to construct a tensor product of modules.\n\n```\nsage: C = CombinatorialFreeModule(QQ, ['x', 'y'])                                                                                                                \nsage: C.tensor(C)                                                                                                                                                \nFree module generated by {'x', 'y'} over Rational Field # Free module generated by {'x', 'y'} over Rational Field\n```\n\nIt is not implemented completely for `FreeModule`\n\n```\nsage: V = FreeModule(QQ, 2)                                                                                                                                      \nsage: V.tensor(V)                                                                                                                                                \nAttributeError: type object 'FreeModule_ambient_field_with_category' has no attribute 'Tensor'\nsage: \n```\n\n\nIn contrast, `FiniteRankFreeModule` (which is not in `ModulesWithBasis`) uses a parent method `tensor` to construct elements.\n\n```\nsage: F.tensor((2, 2))                                                                                                                                           \nType-(2,2) tensor on the 2-dimensional vector space over the Rational Field\n```\n\n\n`FilteredVectorSpace` has both `tensor` (from `ModulesWithBasis`) and `tensor_product`, but only the latter works.\n\n```\nsage: FV = FilteredVectorSpace(2)                                                                                                                                \nsage: FV.tensor_product(FV)                                                                                                                                      \nQQ^4\nsage: FV.tensor(FV)                                                                                                                                              \nAttributeError: type object 'FilteredVectorSpace_class_with_category' has no attribute 'Tensor'\n```\n\nThe same is true for `FreeQuadraticModule_integer_symmetric`:\n\n```\nsage: L = IntegralLattice(Matrix(ZZ, 2, [2,1,1,-2]))                                                                                                             \nsage: L.tensor_product(L)                                                                                                                                        \nLattice of degree 4 and rank 4 over Integer Ring\nStandard basis \nInner product matrix:\n[ 4  2  2  1]\n[ 2 -4  1 -2]\n[ 2  1 -4 -2]\n[ 1 -2 -2  4]\nsage: L.tensor(L)                                                                                                                                                \nAttributeError: type object 'FreeQuadraticModule_integer_symmetric_with_categor' has no attribute 'Tensor'\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/30373\n\n",
    "created_at": "2020-08-16T00:12:20Z",
    "labels": [
        "linear algebra",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Parent methods tensor vs. tensor_product",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/30136",
    "user": "mkoeppe"
}
```
CC:  tscrim egourgoulhon @mjungmath jhpalmieri chapoton

We unify the use of `tensor` vs. `tensor_product` in parent classes.

Current situation:

Category `ModulesWithBasis` provides a parent method `tensor` to construct a tensor product of modules.

```
sage: C = CombinatorialFreeModule(QQ, ['x', 'y'])                                                                                                                
sage: C.tensor(C)                                                                                                                                                
Free module generated by {'x', 'y'} over Rational Field # Free module generated by {'x', 'y'} over Rational Field
```

It is not implemented completely for `FreeModule`

```
sage: V = FreeModule(QQ, 2)                                                                                                                                      
sage: V.tensor(V)                                                                                                                                                
AttributeError: type object 'FreeModule_ambient_field_with_category' has no attribute 'Tensor'
sage: 
```


In contrast, `FiniteRankFreeModule` (which is not in `ModulesWithBasis`) uses a parent method `tensor` to construct elements.

```
sage: F.tensor((2, 2))                                                                                                                                           
Type-(2,2) tensor on the 2-dimensional vector space over the Rational Field
```


`FilteredVectorSpace` has both `tensor` (from `ModulesWithBasis`) and `tensor_product`, but only the latter works.

```
sage: FV = FilteredVectorSpace(2)                                                                                                                                
sage: FV.tensor_product(FV)                                                                                                                                      
QQ^4
sage: FV.tensor(FV)                                                                                                                                              
AttributeError: type object 'FilteredVectorSpace_class_with_category' has no attribute 'Tensor'
```

The same is true for `FreeQuadraticModule_integer_symmetric`:

```
sage: L = IntegralLattice(Matrix(ZZ, 2, [2,1,1,-2]))                                                                                                             
sage: L.tensor_product(L)                                                                                                                                        
Lattice of degree 4 and rank 4 over Integer Ring
Standard basis 
Inner product matrix:
[ 4  2  2  1]
[ 2 -4  1 -2]
[ 2  1 -4 -2]
[ 1 -2 -2  4]
sage: L.tensor(L)                                                                                                                                                
AttributeError: type object 'FreeQuadraticModule_integer_symmetric_with_categor' has no attribute 'Tensor'
```


Issue created by migration from https://trac.sagemath.org/ticket/30373





---

archive/issue_comments_429254.json:
```json
{
    "body": "A few other things to think about:\n- In the first example, `C.tensor(C, C)` works as expected. In contrast, the `tensor` function doesn't take multiple inputs, but instead an iterable: `tensor([C,C,C])` instead of `tensor(C, C, C)`. I would prefer a consistent syntax.\n- What about tensoring elements together? Right now the `tensor` function works on elements, although the documentation doesn't make this clear. I am happy for this to continue, but again, the syntax is different for `tensor([a,b,c])` vs. `a.tensor(b,c)`.",
    "created_at": "2021-01-20T18:43:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429254",
    "user": "jhpalmieri"
}
```

A few other things to think about:
- In the first example, `C.tensor(C, C)` works as expected. In contrast, the `tensor` function doesn't take multiple inputs, but instead an iterable: `tensor([C,C,C])` instead of `tensor(C, C, C)`. I would prefer a consistent syntax.
- What about tensoring elements together? Right now the `tensor` function works on elements, although the documentation doesn't make this clear. I am happy for this to continue, but again, the syntax is different for `tensor([a,b,c])` vs. `a.tensor(b,c)`.



---

archive/issue_comments_429255.json:
```json
{
    "body": "Replying to [comment:6 jhpalmieri]:\n> A few other things to think about:\n> - In the first example, `C.tensor(C, C)` works as expected. In contrast, the `tensor` function doesn't take multiple inputs, but instead an iterable: `tensor([C,C,C])` instead of `tensor(C, C, C)`. I would prefer a consistent syntax.\n\n+1. I don't have a strong opinion which one we choose. Multiple inputs feels more flexible (and doesn't need an additional bracket).\n\n> - What about tensoring elements together? Right now the `tensor` function works on elements, although the documentation doesn't make this clear. I am happy for this to continue, but again, the syntax is different for `tensor([a,b,c])` vs. `a.tensor(b,c)`.\n\nI like that behavior, too. However, it feels to me like this behavior was not intended and just works because the element provides a `tensor` method (that's probably why it's not mentioned in the documentation). From a mathematical-categorial viewpoint this behavior is anyway unexpected (functors usually do not act on objects of objects).\n\nIf we want to promote this, which I would agree with, the syntax should indeed be the same.\n\nThis might also be a good opportunity to introduce the ``@`` notation you have proposed in [here](https://trac.sagemath.org/ticket/30244#comment:3) which I really like (so +1 from my side, too).\n\nAs for `FiniteRankFreeModule`, introducing methods like `tensor_product` and `tensor_power` is readily done (I already finished the former).\n\nSo, should we split the task into several pieces, and I provide the `FiniteRankFreeModule` add-on? You just have to tell me which syntax you prefer.",
    "created_at": "2021-01-21T18:01:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429255",
    "user": "@mjungmath"
}
```

Replying to [comment:6 jhpalmieri]:
> A few other things to think about:
> - In the first example, `C.tensor(C, C)` works as expected. In contrast, the `tensor` function doesn't take multiple inputs, but instead an iterable: `tensor([C,C,C])` instead of `tensor(C, C, C)`. I would prefer a consistent syntax.

+1. I don't have a strong opinion which one we choose. Multiple inputs feels more flexible (and doesn't need an additional bracket).

> - What about tensoring elements together? Right now the `tensor` function works on elements, although the documentation doesn't make this clear. I am happy for this to continue, but again, the syntax is different for `tensor([a,b,c])` vs. `a.tensor(b,c)`.

I like that behavior, too. However, it feels to me like this behavior was not intended and just works because the element provides a `tensor` method (that's probably why it's not mentioned in the documentation). From a mathematical-categorial viewpoint this behavior is anyway unexpected (functors usually do not act on objects of objects).

If we want to promote this, which I would agree with, the syntax should indeed be the same.

This might also be a good opportunity to introduce the ``@`` notation you have proposed in [here](https://trac.sagemath.org/ticket/30244#comment:3) which I really like (so +1 from my side, too).

As for `FiniteRankFreeModule`, introducing methods like `tensor_product` and `tensor_power` is readily done (I already finished the former).

So, should we split the task into several pieces, and I provide the `FiniteRankFreeModule` add-on? You just have to tell me which syntax you prefer.



---

archive/issue_comments_429256.json:
```json
{
    "body": "Replying to [comment:7 gh-mjungmath]:\n> This might also be a good opportunity to introduce the ``@`` notation you have proposed in [here](https://trac.sagemath.org/ticket/30244#comment:3) which I really like (so +1 from my side, too).\n\n-1 on this - as per discussion in #30244, ``@`` should be for tensor contraction, not tensor product",
    "created_at": "2021-01-21T18:10:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429256",
    "user": "mkoeppe"
}
```

Replying to [comment:7 gh-mjungmath]:
> This might also be a good opportunity to introduce the ``@`` notation you have proposed in [here](https://trac.sagemath.org/ticket/30244#comment:3) which I really like (so +1 from my side, too).

-1 on this - as per discussion in #30244, ``@`` should be for tensor contraction, not tensor product



---

archive/issue_comments_429257.json:
```json
{
    "body": "Replying to [comment:8 mkoeppe]:\n> Replying to [comment:7 gh-mjungmath]:\n> > This might also be a good opportunity to introduce the ``@`` notation you have proposed in [here](https://trac.sagemath.org/ticket/30244#comment:3) which I really like (so +1 from my side, too).\n> \n> -1 on this - as per discussion in #30244, ``@`` should be for tensor contraction, not tensor product\n\nBut the idea in principle remains, doesn't it? What about `#` instead? That's already the symbol for tensor products as in `categories/tensor.py`.\n\nArrrg, that's commenting...",
    "created_at": "2021-01-21T18:15:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429257",
    "user": "@mjungmath"
}
```

Replying to [comment:8 mkoeppe]:
> Replying to [comment:7 gh-mjungmath]:
> > This might also be a good opportunity to introduce the ``@`` notation you have proposed in [here](https://trac.sagemath.org/ticket/30244#comment:3) which I really like (so +1 from my side, too).
> 
> -1 on this - as per discussion in #30244, ``@`` should be for tensor contraction, not tensor product

But the idea in principle remains, doesn't it? What about `#` instead? That's already the symbol for tensor products as in `categories/tensor.py`.

Arrrg, that's commenting...



---

archive/issue_comments_429258.json:
```json
{
    "body": "Python has only a fixed set of binary operators available. One can resort to overloading something that's rarely used otherwise. In #30244 I suggested `&` as a possibility, but I am not sure if it's a good idea.",
    "created_at": "2021-01-21T18:18:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429258",
    "user": "mkoeppe"
}
```

Python has only a fixed set of binary operators available. One can resort to overloading something that's rarely used otherwise. In #30244 I suggested `&` as a possibility, but I am not sure if it's a good idea.



---

archive/issue_comments_429259.json:
```json
{
    "body": "Replying to [comment:10 mkoeppe]:\n> Python has only a fixed set of binary operators available. One can resort to overloading something that's rarely used otherwise. In #30244 I suggested `&` as a possibility, but I am not sure if it's a good idea.\n\nIt feels rather uncanonical. But tensor products seem to be used quite frequently, so if there's no better bet...\n\nWhat's your opinion on the syntax?\n\nShould I open another ticket to provide `tensor_product`, `tensor_power` for `FiniteRankFreeModule` or just push it into here as open branch?",
    "created_at": "2021-01-21T18:21:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429259",
    "user": "@mjungmath"
}
```

Replying to [comment:10 mkoeppe]:
> Python has only a fixed set of binary operators available. One can resort to overloading something that's rarely used otherwise. In #30244 I suggested `&` as a possibility, but I am not sure if it's a good idea.

It feels rather uncanonical. But tensor products seem to be used quite frequently, so if there's no better bet...

What's your opinion on the syntax?

Should I open another ticket to provide `tensor_product`, `tensor_power` for `FiniteRankFreeModule` or just push it into here as open branch?



---

archive/issue_comments_429260.json:
```json
{
    "body": "We should make people use the unicode `\u2297` for tensor product.\n\nMore seriously, if we can switch the syntax to `tensor(a,b,c,...)` with no extra brackets, that would be nice. I don't know if any of the tensor constructors take optional arguments, so I don't know how hard that would be to implement.",
    "created_at": "2021-01-21T18:50:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429260",
    "user": "jhpalmieri"
}
```

We should make people use the unicode `⊗` for tensor product.

More seriously, if we can switch the syntax to `tensor(a,b,c,...)` with no extra brackets, that would be nice. I don't know if any of the tensor constructors take optional arguments, so I don't know how hard that would be to implement.



---

archive/issue_comments_429261.json:
```json
{
    "body": "I've opened a ticket for the `FiniteRankFreeModule` case: #31276.",
    "created_at": "2021-01-21T21:15:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429261",
    "user": "@mjungmath"
}
```

I've opened a ticket for the `FiniteRankFreeModule` case: #31276.



---

archive/issue_comments_429262.json:
```json
{
    "body": "Multiple inputs can also be really annoying when you want to create a list dynamically as you then have to add a `*` and possibly extra parentheses. The easiest thing to do is to support both behaviors. This is simple enough to implement.\n\nThe tensor unicode would be good, except it would depend on how the Python interpreter takes that. Most likely, we would need to implement another find-replace case in the preparser to go to some overloaded infix operator such as `&`.",
    "created_at": "2021-01-22T01:12:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429262",
    "user": "tscrim"
}
```

Multiple inputs can also be really annoying when you want to create a list dynamically as you then have to add a `*` and possibly extra parentheses. The easiest thing to do is to support both behaviors. This is simple enough to implement.

The tensor unicode would be good, except it would depend on how the Python interpreter takes that. Most likely, we would need to implement another find-replace case in the preparser to go to some overloaded infix operator such as `&`.



---

archive/issue_comments_429263.json:
```json
{
    "body": "Speaking of shortcuts for operations: what about using `^` for the wedge product? There is nothing more appropriate than that!\n\nIf that meets your approval, I'll open a ticket for this.",
    "created_at": "2021-01-22T23:54:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429263",
    "user": "@mjungmath"
}
```

Speaking of shortcuts for operations: what about using `^` for the wedge product? There is nothing more appropriate than that!

If that meets your approval, I'll open a ticket for this.



---

archive/issue_comments_429264.json:
```json
{
    "body": "I find it too easily confused with the exponentiation operator, so I would not like to see it featured prominently in doctests.",
    "created_at": "2021-01-23T00:02:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429264",
    "user": "jhpalmieri"
}
```

I find it too easily confused with the exponentiation operator, so I would not like to see it featured prominently in doctests.



---

archive/issue_comments_429265.json:
```json
{
    "body": "So far, the `^` is not supported for exterior algebras:\n\n\n```\nsage: M = FiniteRankFreeModule(QQ, 3)\nsage: AM = M.dual_exterior_power(2)\nsage: a = AM.an_element()\nsage: a^2\nTraceback (most recent call last)\n...\nTypeError: unsupported operand parent(s) for ^: '2nd exterior power of the dual of the 3-dimensional vector space over the Rational Field' and 'Integer Ring'\n```\n\n\nBut I agree. One would rather expect `a^3 == a.wedge(a).wedge(a)` if supported.\n\nMh, one minute ago, I thought it was an ingenious idea. :D",
    "created_at": "2021-01-23T00:22:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429265",
    "user": "@mjungmath"
}
```

So far, the `^` is not supported for exterior algebras:


```
sage: M = FiniteRankFreeModule(QQ, 3)
sage: AM = M.dual_exterior_power(2)
sage: a = AM.an_element()
sage: a^2
Traceback (most recent call last)
...
TypeError: unsupported operand parent(s) for ^: '2nd exterior power of the dual of the 3-dimensional vector space over the Rational Field' and 'Integer Ring'
```


But I agree. One would rather expect `a^3 == a.wedge(a).wedge(a)` if supported.

Mh, one minute ago, I thought it was an ingenious idea. :D



---

archive/issue_comments_429266.json:
```json
{
    "body": "Replying to [comment:16 jhpalmieri]:\n> I find it too easily confused with the exponentiation operator, so I would not like to see it featured prominently in doctests.\n\nHowever, I think it would be a nice syntactic sugar since `a ^ b`, for a,b in an exterior algebra, as exponentiation does not make sense.",
    "created_at": "2021-01-23T05:51:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429266",
    "user": "tscrim"
}
```

Replying to [comment:16 jhpalmieri]:
> I find it too easily confused with the exponentiation operator, so I would not like to see it featured prominently in doctests.

However, I think it would be a nice syntactic sugar since `a ^ b`, for a,b in an exterior algebra, as exponentiation does not make sense.



---

archive/issue_comments_429267.json:
```json
{
    "body": "Replying to [comment:18 tscrim]:\n> Replying to [comment:16 jhpalmieri]:\n> > I find it too easily confused with the exponentiation operator, so I would not like to see it featured prominently in doctests.\n> \n> However, I think it would be a nice syntactic sugar since `a ^ b`, for a,b in an exterior algebra, as exponentiation does not make sense.\n\nHow do we treat `^` with integers then? As a wedge product, this is the simple multiplication. And I still agree, that this case can easily be confused with the exponential since exponentiation is the standard behavior of Sage anywhere else.",
    "created_at": "2021-01-23T09:48:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429267",
    "user": "@mjungmath"
}
```

Replying to [comment:18 tscrim]:
> Replying to [comment:16 jhpalmieri]:
> > I find it too easily confused with the exponentiation operator, so I would not like to see it featured prominently in doctests.
> 
> However, I think it would be a nice syntactic sugar since `a ^ b`, for a,b in an exterior algebra, as exponentiation does not make sense.

How do we treat `^` with integers then? As a wedge product, this is the simple multiplication. And I still agree, that this case can easily be confused with the exponential since exponentiation is the standard behavior of Sage anywhere else.



---

archive/issue_comments_429268.json:
```json
{
    "body": "Replying to [comment:12 jhpalmieri]:\n> We should make people use the unicode `\u2297` for tensor product.\nA relevant ticket here: #30473",
    "created_at": "2021-01-23T10:23:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429268",
    "user": "egourgoulhon"
}
```

Replying to [comment:12 jhpalmieri]:
> We should make people use the unicode `⊗` for tensor product.
A relevant ticket here: #30473



---

archive/issue_comments_429269.json:
```json
{
    "body": "Replying to [comment:19 gh-mjungmath]:\n> Replying to [comment:18 tscrim]:\n> > \n> > However, I think it would be a nice syntactic sugar since `a ^ b`, for a,b in an exterior algebra, as exponentiation does not make sense.\n> \n> How do we treat `^` with integers then? As a wedge product, this is the simple multiplication. And I still agree, that this case can easily be confused with the exponential since exponentiation is the standard behavior of Sage anywhere else.\n\n+1 (and IMHO `a^b` looks too far from a wedge product).",
    "created_at": "2021-01-23T10:29:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429269",
    "user": "egourgoulhon"
}
```

Replying to [comment:19 gh-mjungmath]:
> Replying to [comment:18 tscrim]:
> > 
> > However, I think it would be a nice syntactic sugar since `a ^ b`, for a,b in an exterior algebra, as exponentiation does not make sense.
> 
> How do we treat `^` with integers then? As a wedge product, this is the simple multiplication. And I still agree, that this case can easily be confused with the exponential since exponentiation is the standard behavior of Sage anywhere else.

+1 (and IMHO `a^b` looks too far from a wedge product).



---

archive/issue_comments_429270.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429270",
    "user": "mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_429271.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-08-23T16:50:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429271",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_429272.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2022-08-23T17:10:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429272",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_429273.json:
```json
{
    "body": "Looks like the element classes also need to get `tensor_product` methods.\n\nI'd welcome comments in this early stage whether this is going in a good direction",
    "created_at": "2022-08-23T17:18:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429273",
    "user": "mkoeppe"
}
```

Looks like the element classes also need to get `tensor_product` methods.

I'd welcome comments in this early stage whether this is going in a good direction



---

archive/issue_comments_429274.json:
```json
{
    "body": "Replying to [comment:31 mkoeppe]:\n> Looks like the element classes also need to get `tensor_product` methods.\n> \n> I'd welcome comments in this early stage whether this is going in a good direction\n\nFWIW, in `FiniteRankFreeModule`'s, the element tensor product is implemented via the operator `*`, i.e. via the method `__mul__`.",
    "created_at": "2022-08-23T20:39:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429274",
    "user": "egourgoulhon"
}
```

Replying to [comment:31 mkoeppe]:
> Looks like the element classes also need to get `tensor_product` methods.
> 
> I'd welcome comments in this early stage whether this is going in a good direction

FWIW, in `FiniteRankFreeModule`'s, the element tensor product is implemented via the operator `*`, i.e. via the method `__mul__`.



---

archive/issue_comments_429275.json:
```json
{
    "body": "The branch of #34448 shows the necessary workarounds in `sage.tensors` if we wanted to keep `tensor` (not `tensor_product`) as the name of the method that implements the action of `TensorProductFunctor`: The method `FiniteRankFreeModule.tensor` would have to double both as that and as the method that construct an element.\n\nAny thoughts which of the 2 ways to go?",
    "created_at": "2022-09-04T19:48:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429275",
    "user": "mkoeppe"
}
```

The branch of #34448 shows the necessary workarounds in `sage.tensors` if we wanted to keep `tensor` (not `tensor_product`) as the name of the method that implements the action of `TensorProductFunctor`: The method `FiniteRankFreeModule.tensor` would have to double both as that and as the method that construct an element.

Any thoughts which of the 2 ways to go?



---

archive/issue_comments_429276.json:
```json
{
    "body": "The  `tensor()` method is something used by the `tensor` functor as the hook within each class to build the tensor product IIRC. So it is a little more special of a method.",
    "created_at": "2022-09-04T23:31:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429276",
    "user": "tscrim"
}
```

The  `tensor()` method is something used by the `tensor` functor as the hook within each class to build the tensor product IIRC. So it is a little more special of a method.



---

archive/issue_comments_429277.json:
```json
{
    "body": "Yes, exactly. The branch here on the ticket changes it:\n\n```\ndiff --git a/src/sage/categories/tensor.py b/src/sage/categories/tensor.py\nindex 67c4e64..18109d0 100644\n--- a/src/sage/categories/tensor.py\n+++ b/src/sage/categories/tensor.py\n@@ -48,7 +48,7 @@ class TensorProductFunctor(CovariantFunctorialConstruction):\n \n         sage: TestSuite(tensor).run()\n     \"\"\"\n-    _functor_name = \"tensor\"\n+    _functor_name = \"tensor_product\"\n     _functor_category = \"TensorProducts\"\n     symbol = \" # \"\n     unicode_symbol = f\" {unicode_otimes} \"\n```\n",
    "created_at": "2022-09-04T23:33:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429277",
    "user": "mkoeppe"
}
```

Yes, exactly. The branch here on the ticket changes it:

```
diff --git a/src/sage/categories/tensor.py b/src/sage/categories/tensor.py
index 67c4e64..18109d0 100644
--- a/src/sage/categories/tensor.py
+++ b/src/sage/categories/tensor.py
@@ -48,7 +48,7 @@ class TensorProductFunctor(CovariantFunctorialConstruction):
 
         sage: TestSuite(tensor).run()
     """
-    _functor_name = "tensor"
+    _functor_name = "tensor_product"
     _functor_category = "TensorProducts"
     symbol = " # "
     unicode_symbol = f" {unicode_otimes} "
```




---

archive/issue_comments_429278.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2022-09-05T00:16:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429278",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_429279.json:
```json
{
    "body": "I see. It wasn\u2019t entirely clear that was the proposal.\n\nI am maybe marginally in favor of `tensor` since we say \u201cA tensor B\u201d and it would create slightly tension with the functor being called `tensor` In the global namespace. For the middle example, another way out of this would be to check the types of the input.\n\nIMO, the last two examples in the ticket description perhaps should fail because the result doesn\u2019t know about its tensor product construction. Yes, `QQ^2 (x) QQ^2 = QQ^2 (+) QQ^2 = QQ^4`, where `=` means isomorphic as `QQ`-vector spaces here, but there are two separate canonical projections onto `QQ^2` in the middle case and a functoral way to lift up `QQ^2` endomorphisms in the first case. There are also different structures if we have additional structure, such as a grading. TL;DR they are losing information that the result of `tensor` (Perhaps implicitly) is assuming is preserved.",
    "created_at": "2022-09-05T00:18:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429279",
    "user": "tscrim"
}
```

I see. It wasn’t entirely clear that was the proposal.

I am maybe marginally in favor of `tensor` since we say “A tensor B” and it would create slightly tension with the functor being called `tensor` In the global namespace. For the middle example, another way out of this would be to check the types of the input.

IMO, the last two examples in the ticket description perhaps should fail because the result doesn’t know about its tensor product construction. Yes, `QQ^2 (x) QQ^2 = QQ^2 (+) QQ^2 = QQ^4`, where `=` means isomorphic as `QQ`-vector spaces here, but there are two separate canonical projections onto `QQ^2` in the middle case and a functoral way to lift up `QQ^2` endomorphisms in the first case. There are also different structures if we have additional structure, such as a grading. TL;DR they are losing information that the result of `tensor` (Perhaps implicitly) is assuming is preserved.



---

archive/issue_comments_429280.json:
```json
{
    "body": "The problem is that we have the clash with `FiniteRankFreeModule.tensor`.",
    "created_at": "2022-09-05T00:32:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429280",
    "user": "mkoeppe"
}
```

The problem is that we have the clash with `FiniteRankFreeModule.tensor`.



---

archive/issue_comments_429281.json:
```json
{
    "body": "Replying to [comment:40 Travis Scrimshaw]:\n> For the middle example, another way out of this would be to check the types of the input.\n\nAh, I see that is what you referred to already.",
    "created_at": "2022-09-05T00:33:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429281",
    "user": "mkoeppe"
}
```

Replying to [comment:40 Travis Scrimshaw]:
> For the middle example, another way out of this would be to check the types of the input.

Ah, I see that is what you referred to already.



---

archive/issue_comments_429282.json:
```json
{
    "body": "So yes, in the branch of #34448 I fix the clash by checking types. But I'm not sure if this a clean enough solution.",
    "created_at": "2022-09-05T00:35:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429282",
    "user": "mkoeppe"
}
```

So yes, in the branch of #34448 I fix the clash by checking types. But I'm not sure if this a clean enough solution.



---

archive/issue_comments_429283.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-05T00:38:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429283",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_429284.json:
```json
{
    "body": "Replying to [comment:40 Travis Scrimshaw]:\n> IMO, the last two examples in the ticket description perhaps should fail because the result doesn\u2019t know about its tensor product construction. \n\nI haven't looked at these examples in detail, but your explanation makes sense. Nothing for this ticket though.",
    "created_at": "2022-09-05T00:40:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429284",
    "user": "mkoeppe"
}
```

Replying to [comment:40 Travis Scrimshaw]:
> IMO, the last two examples in the ticket description perhaps should fail because the result doesn’t know about its tensor product construction. 

I haven't looked at these examples in detail, but your explanation makes sense. Nothing for this ticket though.



---

archive/issue_comments_429285.json:
```json
{
    "body": "Replying to [comment:43 Matthias K\u00f6ppe]:\n> So yes, in the branch of #34448 I fix the clash by checking types. But I'm not sure if this a clean enough solution.\n\nIndeed, it is not the most clean solution, but it is a side effect of English (and Python) that we cannot easily distinguish between \u201ca tensor in\u201d and \u201cthe tensor with\u201d in such a concise way.",
    "created_at": "2022-09-05T00:43:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429285",
    "user": "tscrim"
}
```

Replying to [comment:43 Matthias Köppe]:
> So yes, in the branch of #34448 I fix the clash by checking types. But I'm not sure if this a clean enough solution.

Indeed, it is not the most clean solution, but it is a side effect of English (and Python) that we cannot easily distinguish between “a tensor in” and “the tensor with” in such a concise way.



---

archive/issue_comments_429286.json:
```json
{
    "body": "Replying to [comment:40 Travis Scrimshaw]:\n> I am maybe marginally in favor of `tensor` since we say \u201cA tensor B\u201d and it would create slightly tension with the functor being called `tensor` In the global namespace. \n\nWe could of course make `tensor` a non-deprecated alias and document that classes are allowed to overload it for additional idiomatic uses.",
    "created_at": "2022-09-05T00:43:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429286",
    "user": "mkoeppe"
}
```

Replying to [comment:40 Travis Scrimshaw]:
> I am maybe marginally in favor of `tensor` since we say “A tensor B” and it would create slightly tension with the functor being called `tensor` In the global namespace. 

We could of course make `tensor` a non-deprecated alias and document that classes are allowed to overload it for additional idiomatic uses.



---

archive/issue_comments_429287.json:
```json
{
    "body": "Replying to [comment:45 Matthias K\u00f6ppe]:\n> Replying to [comment:40 Travis Scrimshaw]:\n> > IMO, the last two examples in the ticket description perhaps should fail because the result doesn\u2019t know about its tensor product construction. \n> \n> I haven't looked at these examples in detail, but your explanation makes sense. Nothing for this ticket though.\n\nIf we rename it to `tensor_product`, then it starts working in a way that is incompatible with the tensor functor. It\u2019s not a really big problem, but it could run into subtleties with `tensor([C, FV])` versus `tensor([FV, C])` with one of them working (and returning a wrong answer depending on the implementation that I haven\u2019t checked) and the other not.",
    "created_at": "2022-09-05T00:45:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429287",
    "user": "tscrim"
}
```

Replying to [comment:45 Matthias Köppe]:
> Replying to [comment:40 Travis Scrimshaw]:
> > IMO, the last two examples in the ticket description perhaps should fail because the result doesn’t know about its tensor product construction. 
> 
> I haven't looked at these examples in detail, but your explanation makes sense. Nothing for this ticket though.

If we rename it to `tensor_product`, then it starts working in a way that is incompatible with the tensor functor. It’s not a really big problem, but it could run into subtleties with `tensor([C, FV])` versus `tensor([FV, C])` with one of them working (and returning a wrong answer depending on the implementation that I haven’t checked) and the other not.



---

archive/issue_comments_429288.json:
```json
{
    "body": "Hm? No, the tensor functor calls the method given in its `_functor_name`. That's what the change in comment:38 is for.",
    "created_at": "2022-09-05T00:47:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429288",
    "user": "mkoeppe"
}
```

Hm? No, the tensor functor calls the method given in its `_functor_name`. That's what the change in comment:38 is for.



---

archive/issue_comments_429289.json:
```json
{
    "body": "Oh, I think I get what you are saying: These two examples are undisciplined tensor products that don't comply with the guarantees of the functor?",
    "created_at": "2022-09-05T00:49:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429289",
    "user": "mkoeppe"
}
```

Oh, I think I get what you are saying: These two examples are undisciplined tensor products that don't comply with the guarantees of the functor?



---

archive/issue_comments_429290.json:
```json
{
    "body": "Replying to [comment:49 Matthias K\u00f6ppe]:\n> Hm? No, the tensor functor calls the method given in its `_functor_name`. That's what the change in comment:38 is for.\n\nRight, and `FV` and `L` from the description have a `tensor_product` method already. This could potentially take a CFM `C` and return, say, a filtered vector space (with the right methods), but not the other way around. Even if both worked (which is also possible), they would result in very different implementations. Although since tensor products in general are not \u201ccommutative,\u201d we can wave it away, but it would mean more brittle code.",
    "created_at": "2022-09-05T00:54:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429290",
    "user": "tscrim"
}
```

Replying to [comment:49 Matthias Köppe]:
> Hm? No, the tensor functor calls the method given in its `_functor_name`. That's what the change in comment:38 is for.

Right, and `FV` and `L` from the description have a `tensor_product` method already. This could potentially take a CFM `C` and return, say, a filtered vector space (with the right methods), but not the other way around. Even if both worked (which is also possible), they would result in very different implementations. Although since tensor products in general are not “commutative,” we can wave it away, but it would mean more brittle code.



---

archive/issue_comments_429291.json:
```json
{
    "body": "Replying to [comment:50 Matthias K\u00f6ppe]:\n> Oh, I think I get what you are saying: These two examples are undisciplined tensor products that don't comply with the guarantees of the functor?\n\nYes, that\u2019s right. Sorry if I wasn\u2019t explaining clearly enough.",
    "created_at": "2022-09-05T00:55:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429291",
    "user": "tscrim"
}
```

Replying to [comment:50 Matthias Köppe]:
> Oh, I think I get what you are saying: These two examples are undisciplined tensor products that don't comply with the guarantees of the functor?

Yes, that’s right. Sorry if I wasn’t explaining clearly enough.



---

archive/issue_comments_429292.json:
```json
{
    "body": "By the way, `FilteredVectorSpace` appears to be the only consumer of `sage.modules.tensor_operations`, which can probably be eliminated",
    "created_at": "2022-09-05T00:57:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429292",
    "user": "mkoeppe"
}
```

By the way, `FilteredVectorSpace` appears to be the only consumer of `sage.modules.tensor_operations`, which can probably be eliminated



---

archive/issue_comments_429293.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-05T03:17:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429293",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_429294.json:
```json
{
    "body": "Here's an attempt",
    "created_at": "2022-09-05T03:17:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429294",
    "user": "mkoeppe"
}
```

Here's an attempt



---

archive/issue_comments_429295.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-05T05:00:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429295",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_429296.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-05T05:51:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429296",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_429297.json:
```json
{
    "body": "I don\u2019t like this fallback for two reasons:\n\n1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn\u2019t know how it was built as a tensor product.\n2. (More of a worry since I haven\u2019t checked it.) It returns an object that suggests there is less structure than their might be because of a lack of an implementation. Does this preserve the algebra structure when we take a tensor product of algebras?",
    "created_at": "2022-09-05T13:50:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429297",
    "user": "tscrim"
}
```

I don’t like this fallback for two reasons:

1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
2. (More of a worry since I haven’t checked it.) It returns an object that suggests there is less structure than their might be because of a lack of an implementation. Does this preserve the algebra structure when we take a tensor product of algebras?



---

archive/issue_comments_429298.json:
```json
{
    "body": "Replying to [comment:60 Travis Scrimshaw]:\n> I don\u2019t like this fallback for two reasons:\n> \n> 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn\u2019t know how it was built as a tensor product.\n\nThe result doesn't have to know because it does not advertise itself as a tensor product.",
    "created_at": "2022-09-05T13:57:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429298",
    "user": "mkoeppe"
}
```

Replying to [comment:60 Travis Scrimshaw]:
> I don’t like this fallback for two reasons:
> 
> 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.

The result doesn't have to know because it does not advertise itself as a tensor product.



---

archive/issue_comments_429299.json:
```json
{
    "body": "Replying to [comment:61 Matthias K\u00f6ppe]:\n> Replying to [comment:60 Travis Scrimshaw]:\n> > I don\u2019t like this fallback for two reasons:\n> > \n> > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn\u2019t know how it was built as a tensor product.\n> \n> The result doesn't have to know because it does not advertise itself as a tensor product.\n\nThat is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.",
    "created_at": "2022-09-05T14:04:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429299",
    "user": "tscrim"
}
```

Replying to [comment:61 Matthias Köppe]:
> Replying to [comment:60 Travis Scrimshaw]:
> > I don’t like this fallback for two reasons:
> > 
> > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> 
> The result doesn't have to know because it does not advertise itself as a tensor product.

That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.



---

archive/issue_comments_429300.json:
```json
{
    "body": "Let me put it another way, the result is not in the codomain of the functor.",
    "created_at": "2022-09-05T14:05:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429300",
    "user": "tscrim"
}
```

Let me put it another way, the result is not in the codomain of the functor.



---

archive/issue_comments_429301.json:
```json
{
    "body": "Replying to [comment:62 Travis Scrimshaw]:\n> Replying to [comment:61 Matthias K\u00f6ppe]:\n> > Replying to [comment:60 Travis Scrimshaw]:\n> > > I don\u2019t like this fallback for two reasons:\n> > > \n> > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn\u2019t know how it was built as a tensor product.\n> > \n> > The result doesn't have to know because it does not advertise itself as a tensor product.\n> \n> That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.\n\nSuppose as a user I want to construct it anyway. What should I do then?",
    "created_at": "2022-09-05T14:06:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429301",
    "user": "mkoeppe"
}
```

Replying to [comment:62 Travis Scrimshaw]:
> Replying to [comment:61 Matthias Köppe]:
> > Replying to [comment:60 Travis Scrimshaw]:
> > > I don’t like this fallback for two reasons:
> > > 
> > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> > 
> > The result doesn't have to know because it does not advertise itself as a tensor product.
> 
> That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.

Suppose as a user I want to construct it anyway. What should I do then?



---

archive/issue_comments_429302.json:
```json
{
    "body": "Replying to [comment:63 Travis Scrimshaw]:\n> Let me put it another way, the result is not in the codomain of the functor.\n\nI think you're conflating mathematical structure with implementation here.",
    "created_at": "2022-09-05T14:07:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429302",
    "user": "mkoeppe"
}
```

Replying to [comment:63 Travis Scrimshaw]:
> Let me put it another way, the result is not in the codomain of the functor.

I think you're conflating mathematical structure with implementation here.



---

archive/issue_comments_429303.json:
```json
{
    "body": "Replying to [comment:64 Matthias K\u00f6ppe]:\n> Replying to [comment:62 Travis Scrimshaw]:\n> > Replying to [comment:61 Matthias K\u00f6ppe]:\n> > > Replying to [comment:60 Travis Scrimshaw]:\n> > > > I don\u2019t like this fallback for two reasons:\n> > > > \n> > > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn\u2019t know how it was built as a tensor product.\n> > > \n> > > The result doesn't have to know because it does not advertise itself as a tensor product.\n> > \n> > That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.\n> \n> Suppose as a user I want to construct it anyway. What should I do then?\n\nThe class needs to have its own hook separate from the hook that the functor uses.",
    "created_at": "2022-09-05T14:09:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429303",
    "user": "tscrim"
}
```

Replying to [comment:64 Matthias Köppe]:
> Replying to [comment:62 Travis Scrimshaw]:
> > Replying to [comment:61 Matthias Köppe]:
> > > Replying to [comment:60 Travis Scrimshaw]:
> > > > I don’t like this fallback for two reasons:
> > > > 
> > > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> > > 
> > > The result doesn't have to know because it does not advertise itself as a tensor product.
> > 
> > That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.
> 
> Suppose as a user I want to construct it anyway. What should I do then?

The class needs to have its own hook separate from the hook that the functor uses.



---

archive/issue_comments_429304.json:
```json
{
    "body": "Replying to [comment:65 Matthias K\u00f6ppe]:\n> Replying to [comment:63 Travis Scrimshaw]:\n> > Let me put it another way, the result is not in the codomain of the functor.\n> \n> I think you're conflating mathematical structure with implementation here.\n\nHow so? The result does not know it is a tensor product of modules, and there is no canonical way to deconstruct a vector space into a tensor product. For example, a 1-dimensional module could be a `n`-fold tensor product of itself `n` times. There are no canonical isomorphisms between these spaces. These are also not even isomorphic as graded vector spaces in general either (one needs a grading shift).",
    "created_at": "2022-09-05T14:14:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429304",
    "user": "tscrim"
}
```

Replying to [comment:65 Matthias Köppe]:
> Replying to [comment:63 Travis Scrimshaw]:
> > Let me put it another way, the result is not in the codomain of the functor.
> 
> I think you're conflating mathematical structure with implementation here.

How so? The result does not know it is a tensor product of modules, and there is no canonical way to deconstruct a vector space into a tensor product. For example, a 1-dimensional module could be a `n`-fold tensor product of itself `n` times. There are no canonical isomorphisms between these spaces. These are also not even isomorphic as graded vector spaces in general either (one needs a grading shift).



---

archive/issue_comments_429305.json:
```json
{
    "body": "Mathematically an object *is* a tensor product if there *exists* a construction of it using the tensor functor.\n\nIn an implementation, we generally cannot know if something exists. An object is marked *as* a tensor product when the implementation has marked it as such. Like everything, this is subject to the implementation restrictions.",
    "created_at": "2022-09-05T14:20:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429305",
    "user": "mkoeppe"
}
```

Mathematically an object *is* a tensor product if there *exists* a construction of it using the tensor functor.

In an implementation, we generally cannot know if something exists. An object is marked *as* a tensor product when the implementation has marked it as such. Like everything, this is subject to the implementation restrictions.



---

archive/issue_comments_429306.json:
```json
{
    "body": "Replying to [comment:66 Travis Scrimshaw]:\n> Replying to [comment:64 Matthias K\u00f6ppe]:\n> > Replying to [comment:62 Travis Scrimshaw]:\n> > > Replying to [comment:61 Matthias K\u00f6ppe]:\n> > > > Replying to [comment:60 Travis Scrimshaw]:\n> > > > > I don\u2019t like this fallback for two reasons:\n> > > > > \n> > > > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn\u2019t know how it was built as a tensor product.\n> > > > \n> > > > The result doesn't have to know because it does not advertise itself as a tensor product.\n> > > \n> > > That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.\n> > \n> > Suppose as a user I want to construct it anyway. What should I do then?\n> \n> The class needs to have its own hook separate from the hook that the functor uses.\n\nNo, as a user. Suppose there is no such specific implementation. What should the user do?",
    "created_at": "2022-09-05T14:22:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429306",
    "user": "mkoeppe"
}
```

Replying to [comment:66 Travis Scrimshaw]:
> Replying to [comment:64 Matthias Köppe]:
> > Replying to [comment:62 Travis Scrimshaw]:
> > > Replying to [comment:61 Matthias Köppe]:
> > > > Replying to [comment:60 Travis Scrimshaw]:
> > > > > I don’t like this fallback for two reasons:
> > > > > 
> > > > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> > > > 
> > > > The result doesn't have to know because it does not advertise itself as a tensor product.
> > > 
> > > That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.
> > 
> > Suppose as a user I want to construct it anyway. What should I do then?
> 
> The class needs to have its own hook separate from the hook that the functor uses.

No, as a user. Suppose there is no such specific implementation. What should the user do?



---

archive/issue_comments_429307.json:
```json
{
    "body": "Replying to [comment:68 Matthias K\u00f6ppe]:\n> Mathematically an object *is* a tensor product if there *exists* a construction of it using the tensor functor.\n\nThen every object is a tensor product since we can always tensor with a 1-dimensional module. If we wanted to talk in that level of generality, there is no category of tensor products, Cartesean products, etc.\n\n> In an implementation, we generally cannot know if something exists. An object is marked *as* a tensor product when the implementation has marked it as such. Like everything, this is subject to the implementation restrictions.\n\nIndeed, the category also contains some implementation requirements. (I would argue the tensor products category is the category with a distinguished tensor product construction, parallel to `ModulesWithBasis`.) Consequently, the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category\u2019s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.\n\nMore concretely, if I had code that does:\n\n```python\nT = tensor([V,W])\nfor F in T.tensor_factors():\n     print(F)\n```\n\nThis should work whenever `T` is constructed because the codomain is `Cat.TensorProducts()`, where `Cat` is the meet of the categories of `V` and `W`. However, with changing the name, the functor now would work but the code would fail with `FilteredVectorSpace`s.",
    "created_at": "2022-09-07T04:43:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429307",
    "user": "tscrim"
}
```

Replying to [comment:68 Matthias Köppe]:
> Mathematically an object *is* a tensor product if there *exists* a construction of it using the tensor functor.

Then every object is a tensor product since we can always tensor with a 1-dimensional module. If we wanted to talk in that level of generality, there is no category of tensor products, Cartesean products, etc.

> In an implementation, we generally cannot know if something exists. An object is marked *as* a tensor product when the implementation has marked it as such. Like everything, this is subject to the implementation restrictions.

Indeed, the category also contains some implementation requirements. (I would argue the tensor products category is the category with a distinguished tensor product construction, parallel to `ModulesWithBasis`.) Consequently, the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.

More concretely, if I had code that does:

```python
T = tensor([V,W])
for F in T.tensor_factors():
     print(F)
```

This should work whenever `T` is constructed because the codomain is `Cat.TensorProducts()`, where `Cat` is the meet of the categories of `V` and `W`. However, with changing the name, the functor now would work but the code would fail with `FilteredVectorSpace`s.



---

archive/issue_comments_429308.json:
```json
{
    "body": "Replying to [comment:69 Matthias K\u00f6ppe]:\n> Replying to [comment:66 Travis Scrimshaw]:\n> > Replying to [comment:64 Matthias K\u00f6ppe]:\n> > > Replying to [comment:62 Travis Scrimshaw]:\n> > > > Replying to [comment:61 Matthias K\u00f6ppe]:\n> > > > > Replying to [comment:60 Travis Scrimshaw]:\n> > > > > > I don\u2019t like this fallback for two reasons:\n> > > > > > \n> > > > > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn\u2019t know how it was built as a tensor product.\n> > > > > \n> > > > > The result doesn't have to know because it does not advertise itself as a tensor product.\n> > > > \n> > > > That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.\n> > > \n> > > Suppose as a user I want to construct it anyway. What should I do then?\n> > \n> > The class needs to have its own hook separate from the hook that the functor uses.\n> \n> No, as a user. Suppose there is no such specific implementation. What should the user do?\n\nMy guess is stop wishing for magical coding fairies and implement it. There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. (Another version: How do you build a matrix from a tensor product of two matrices? There are two main ways to do this that are equivalent as they amount to choosing a different order of the isomorphism.) If a class `Foo` wants to know that a tensor product of two of itself can again be realized as an object `Foo`, then it needs to implement that and chose a specific isomorphism.",
    "created_at": "2022-09-07T04:50:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429308",
    "user": "tscrim"
}
```

Replying to [comment:69 Matthias Köppe]:
> Replying to [comment:66 Travis Scrimshaw]:
> > Replying to [comment:64 Matthias Köppe]:
> > > Replying to [comment:62 Travis Scrimshaw]:
> > > > Replying to [comment:61 Matthias Köppe]:
> > > > > Replying to [comment:60 Travis Scrimshaw]:
> > > > > > I don’t like this fallback for two reasons:
> > > > > > 
> > > > > > 1. It runs into the same problem with `FilteredVectorSpace.tensor_product` I gave in comment:40, it doesn’t know how it was built as a tensor product.
> > > > > 
> > > > > The result doesn't have to know because it does not advertise itself as a tensor product.
> > > > 
> > > > That is the problem. If I build an object as a tensor product (via the `tensor` functor), then it should know that because I wanted it to know that explicitly. It should advertise itself as a tensor product.
> > > 
> > > Suppose as a user I want to construct it anyway. What should I do then?
> > 
> > The class needs to have its own hook separate from the hook that the functor uses.
> 
> No, as a user. Suppose there is no such specific implementation. What should the user do?

My guess is stop wishing for magical coding fairies and implement it. There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. (Another version: How do you build a matrix from a tensor product of two matrices? There are two main ways to do this that are equivalent as they amount to choosing a different order of the isomorphism.) If a class `Foo` wants to know that a tensor product of two of itself can again be realized as an object `Foo`, then it needs to implement that and chose a specific isomorphism.



---

archive/issue_comments_429309.json:
```json
{
    "body": "Replying to [comment:70 Travis Scrimshaw]:\n> the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category\u2019s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.\n\nNo, I think this is too strict to be useful.",
    "created_at": "2022-09-07T04:51:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429309",
    "user": "mkoeppe"
}
```

Replying to [comment:70 Travis Scrimshaw]:
> the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.

No, I think this is too strict to be useful.



---

archive/issue_comments_429310.json:
```json
{
    "body": "Replying to [comment:71 Travis Scrimshaw]:\n> Replying to [comment:69 Matthias K\u00f6ppe]:\n> > No, as a user. Suppose there is no such specific implementation. What should the user do?\n> \n> My guess is stop wishing for magical coding fairies and implement it. \n\nNo, no, users wouldn't like to be talked to like that.",
    "created_at": "2022-09-07T04:52:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429310",
    "user": "mkoeppe"
}
```

Replying to [comment:71 Travis Scrimshaw]:
> Replying to [comment:69 Matthias Köppe]:
> > No, as a user. Suppose there is no such specific implementation. What should the user do?
> 
> My guess is stop wishing for magical coding fairies and implement it. 

No, no, users wouldn't like to be talked to like that.



---

archive/issue_comments_429311.json:
```json
{
    "body": "We often want to identify 1-fold tensor products with the base module -- and the base module won't have the `tensor_factors` method. For example, this is what `sage.tensor.modules` and `sage.manifolds.differentiable` do.",
    "created_at": "2022-09-07T04:59:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429311",
    "user": "mkoeppe"
}
```

We often want to identify 1-fold tensor products with the base module -- and the base module won't have the `tensor_factors` method. For example, this is what `sage.tensor.modules` and `sage.manifolds.differentiable` do.



---

archive/issue_comments_429312.json:
```json
{
    "body": "Replying to [comment:72 Matthias K\u00f6ppe]:\n> Replying to [comment:70 Travis Scrimshaw]:\n> > the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category\u2019s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.\n> \n> No, I think this is too strict to be useful. \n\nThat an object in the codomain of a functor (or any morphism) must support what is required by that codomain (and should be an object such that `X in Cat` returns `True`)? I find this to actually be quite useful as I can expect certain properties to be there.\n\nConsider the equivalent scenario: I have a function `f: ZZ -> QQ[\u2018s\u2019]` that returned `0` as an integer and all non-zero elements as polynomials. You now have to write special checks for `0` rather than have it behave uniformly.",
    "created_at": "2022-09-07T05:06:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429312",
    "user": "tscrim"
}
```

Replying to [comment:72 Matthias Köppe]:
> Replying to [comment:70 Travis Scrimshaw]:
> > the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.
> 
> No, I think this is too strict to be useful. 

That an object in the codomain of a functor (or any morphism) must support what is required by that codomain (and should be an object such that `X in Cat` returns `True`)? I find this to actually be quite useful as I can expect certain properties to be there.

Consider the equivalent scenario: I have a function `f: ZZ -> QQ[‘s’]` that returned `0` as an integer and all non-zero elements as polynomials. You now have to write special checks for `0` rather than have it behave uniformly.



---

archive/issue_comments_429313.json:
```json
{
    "body": "Replying to [comment:75 Travis Scrimshaw]:\n> Replying to [comment:72 Matthias K\u00f6ppe]:\n> > Replying to [comment:70 Travis Scrimshaw]:\n> > > the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category\u2019s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.\n> > \n> > No, I think this is too strict to be useful. \n> \n> That an object in the codomain of a functor (or any morphism) must support what is required by that codomain (and should be an object such that `X in Cat` returns `True`)? I find this to actually be quite useful as I can expect certain properties to be there.\n\nThere's always a tradeoff. Identifications such as the ones that I mentioned in comment:74 are also quite useful.",
    "created_at": "2022-09-07T05:11:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429313",
    "user": "mkoeppe"
}
```

Replying to [comment:75 Travis Scrimshaw]:
> Replying to [comment:72 Matthias Köppe]:
> > Replying to [comment:70 Travis Scrimshaw]:
> > > the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.
> > 
> > No, I think this is too strict to be useful. 
> 
> That an object in the codomain of a functor (or any morphism) must support what is required by that codomain (and should be an object such that `X in Cat` returns `True`)? I find this to actually be quite useful as I can expect certain properties to be there.

There's always a tradeoff. Identifications such as the ones that I mentioned in comment:74 are also quite useful.



---

archive/issue_comments_429314.json:
```json
{
    "body": "Replying to [comment:73 Matthias K\u00f6ppe]:\n> Replying to [comment:71 Travis Scrimshaw]:\n> > Replying to [comment:69 Matthias K\u00f6ppe]:\n> > > No, as a user. Suppose there is no such specific implementation. What should the user do?\n> > \n> > My guess is stop wishing for magical coding fairies and implement it. \n> \n> No, no, users wouldn't like to be talked to like that.\n\nOf course I wouldn\u2019t necessarily tell them in that way. However, unless somebody actually writes the code, then it doesn\u2019t magically come into existence. Unfortunately, this is not the Dire Straights song \u201cMoney for Nothing\u201d; Also Hell is full of 10 year olds who wished for exactly the same thing with the holophonor.\n\nIn this case, I believe it is impossible to implement in the level of generality you want because it amounts to making a canonical choice where there is not one.",
    "created_at": "2022-09-07T05:15:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429314",
    "user": "tscrim"
}
```

Replying to [comment:73 Matthias Köppe]:
> Replying to [comment:71 Travis Scrimshaw]:
> > Replying to [comment:69 Matthias Köppe]:
> > > No, as a user. Suppose there is no such specific implementation. What should the user do?
> > 
> > My guess is stop wishing for magical coding fairies and implement it. 
> 
> No, no, users wouldn't like to be talked to like that.

Of course I wouldn’t necessarily tell them in that way. However, unless somebody actually writes the code, then it doesn’t magically come into existence. Unfortunately, this is not the Dire Straights song “Money for Nothing”; Also Hell is full of 10 year olds who wished for exactly the same thing with the holophonor.

In this case, I believe it is impossible to implement in the level of generality you want because it amounts to making a canonical choice where there is not one.



---

archive/issue_comments_429315.json:
```json
{
    "body": "Replying to [comment:71 Travis Scrimshaw]:\n> There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. \n\nIt does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.",
    "created_at": "2022-09-07T05:17:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429315",
    "user": "mkoeppe"
}
```

Replying to [comment:71 Travis Scrimshaw]:
> There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 

It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.



---

archive/issue_comments_429316.json:
```json
{
    "body": "Replying to [comment:76 Matthias K\u00f6ppe]:\n> Replying to [comment:75 Travis Scrimshaw]:\n> > Replying to [comment:72 Matthias K\u00f6ppe]:\n> > > Replying to [comment:70 Travis Scrimshaw]:\n> > > > the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category\u2019s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.\n> > > \n> > > No, I think this is too strict to be useful. \n> > \n> > That an object in the codomain of a functor (or any morphism) must support what is required by that codomain (and should be an object such that `X in Cat` returns `True`)? I find this to actually be quite useful as I can expect certain properties to be there.\n> \n> There's always a tradeoff. Identifications such as the ones that I mentioned in comment:74 are also quite useful. \n\nI agree that they are useful, but you need a canonical way to do it in general. The point is that you are making an identification based upon a specific choice of isomorphism. Individual classes are allowed to make that choice, which you are implicitly doing when you have either a `as_foo()` method or `Foo(T)` in your code.",
    "created_at": "2022-09-07T05:18:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429316",
    "user": "tscrim"
}
```

Replying to [comment:76 Matthias Köppe]:
> Replying to [comment:75 Travis Scrimshaw]:
> > Replying to [comment:72 Matthias Köppe]:
> > > Replying to [comment:70 Travis Scrimshaw]:
> > > > the result of the functor is promising certain implementation details with its codomain: such objects have methods via the category’s `ParentMethods` and provide an implementation of the corresponding ``@`abstract_methods`.
> > > 
> > > No, I think this is too strict to be useful. 
> > 
> > That an object in the codomain of a functor (or any morphism) must support what is required by that codomain (and should be an object such that `X in Cat` returns `True`)? I find this to actually be quite useful as I can expect certain properties to be there.
> 
> There's always a tradeoff. Identifications such as the ones that I mentioned in comment:74 are also quite useful. 

I agree that they are useful, but you need a canonical way to do it in general. The point is that you are making an identification based upon a specific choice of isomorphism. Individual classes are allowed to make that choice, which you are implicitly doing when you have either a `as_foo()` method or `Foo(T)` in your code.



---

archive/issue_comments_429317.json:
```json
{
    "body": "Replying to [comment:78 Matthias K\u00f6ppe]:\n> Replying to [comment:71 Travis Scrimshaw]:\n> > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. \n> \n> It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.\n\nBut that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.",
    "created_at": "2022-09-07T05:19:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429317",
    "user": "tscrim"
}
```

Replying to [comment:78 Matthias Köppe]:
> Replying to [comment:71 Travis Scrimshaw]:
> > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> 
> It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.

But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.



---

archive/issue_comments_429318.json:
```json
{
    "body": "I think in comment:79 you replied to the wrong comment.",
    "created_at": "2022-09-07T05:23:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429318",
    "user": "mkoeppe"
}
```

I think in comment:79 you replied to the wrong comment.



---

archive/issue_comments_429319.json:
```json
{
    "body": "Replying to [comment:81 Matthias K\u00f6ppe]:\n> I think in comment:79 you replied to the wrong comment.\n\nIt applies to both comment:76 and comment:74. I just chose the more recent one.",
    "created_at": "2022-09-07T05:27:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429319",
    "user": "tscrim"
}
```

Replying to [comment:81 Matthias Köppe]:
> I think in comment:79 you replied to the wrong comment.

It applies to both comment:76 and comment:74. I just chose the more recent one.



---

archive/issue_comments_429320.json:
```json
{
    "body": "Replying to [comment:80 Travis Scrimshaw]:\n> Replying to [comment:78 Matthias K\u00f6ppe]:\n> > Replying to [comment:71 Travis Scrimshaw]:\n> > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. \n> > \n> > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.\n> But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.\n\nNo, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.",
    "created_at": "2022-09-07T05:29:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429320",
    "user": "mkoeppe"
}
```

Replying to [comment:80 Travis Scrimshaw]:
> Replying to [comment:78 Matthias Köppe]:
> > Replying to [comment:71 Travis Scrimshaw]:
> > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> > 
> > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.
> But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.

No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.



---

archive/issue_comments_429321.json:
```json
{
    "body": "Replying to [comment:82 Travis Scrimshaw]:\n> Replying to [comment:81 Matthias K\u00f6ppe]:\n> > I think in comment:79 you replied to the wrong comment.\n> \n> It applies to both comment:76 and comment:74. I just chose the more recent one.\n\nWait, you are concerned about the identification of a module M with its 1-fold tensor product not being canonical?",
    "created_at": "2022-09-07T05:30:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429321",
    "user": "mkoeppe"
}
```

Replying to [comment:82 Travis Scrimshaw]:
> Replying to [comment:81 Matthias Köppe]:
> > I think in comment:79 you replied to the wrong comment.
> 
> It applies to both comment:76 and comment:74. I just chose the more recent one.

Wait, you are concerned about the identification of a module M with its 1-fold tensor product not being canonical?



---

archive/issue_comments_429322.json:
```json
{
    "body": "For the question of 1-fold tensor products, there's by the way an old ticket: #18349",
    "created_at": "2022-09-07T05:39:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429322",
    "user": "mkoeppe"
}
```

For the question of 1-fold tensor products, there's by the way an old ticket: #18349



---

archive/issue_comments_429323.json:
```json
{
    "body": "Replying to [comment:83 Matthias K\u00f6ppe]:\n> Replying to [comment:80 Travis Scrimshaw]:\n> > Replying to [comment:78 Matthias K\u00f6ppe]:\n> > > Replying to [comment:71 Travis Scrimshaw]:\n> > > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. \n> > > \n> > > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.\n> > But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.\n> \n> No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.\n\nSorry, that was a bad phrasing on my part. You are asking for returning **R**<sup>6</sup> to be okay, which you have had to make a (non-canonical) choice of a isomorphism that they user has no control over. The tensor product category has a special distinguished choice of construction as a tensor product, analogous to `ModulesWithBasis` being modules with a distinguished choice of a basis.",
    "created_at": "2022-09-07T05:56:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429323",
    "user": "tscrim"
}
```

Replying to [comment:83 Matthias Köppe]:
> Replying to [comment:80 Travis Scrimshaw]:
> > Replying to [comment:78 Matthias Köppe]:
> > > Replying to [comment:71 Travis Scrimshaw]:
> > > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> > > 
> > > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.
> > But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.
> 
> No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.

Sorry, that was a bad phrasing on my part. You are asking for returning **R**<sup>6</sup> to be okay, which you have had to make a (non-canonical) choice of a isomorphism that they user has no control over. The tensor product category has a special distinguished choice of construction as a tensor product, analogous to `ModulesWithBasis` being modules with a distinguished choice of a basis.



---

archive/issue_comments_429324.json:
```json
{
    "body": "Replying to [comment:84 Matthias K\u00f6ppe]:\n> Replying to [comment:82 Travis Scrimshaw]:\n> > Replying to [comment:81 Matthias K\u00f6ppe]:\n> > > I think in comment:79 you replied to the wrong comment.\n> > \n> > It applies to both comment:76 and comment:74. I just chose the more recent one.\n> \n> Wait, you are concerned about the identification of a module M with its 1-fold tensor product not being canonical?\n\nNot specifically for the 1-fold tensor products, but more generally. This code is expected to work for arbitrary tensor products with no special cases, right? (I can also tell you about the troubles I\u2019ve had with `PartitionTuples` of length 1 versus `Partitions`, which motivates my desire for uniformity.)",
    "created_at": "2022-09-07T06:02:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429324",
    "user": "tscrim"
}
```

Replying to [comment:84 Matthias Köppe]:
> Replying to [comment:82 Travis Scrimshaw]:
> > Replying to [comment:81 Matthias Köppe]:
> > > I think in comment:79 you replied to the wrong comment.
> > 
> > It applies to both comment:76 and comment:74. I just chose the more recent one.
> 
> Wait, you are concerned about the identification of a module M with its 1-fold tensor product not being canonical?

Not specifically for the 1-fold tensor products, but more generally. This code is expected to work for arbitrary tensor products with no special cases, right? (I can also tell you about the troubles I’ve had with `PartitionTuples` of length 1 versus `Partitions`, which motivates my desire for uniformity.)



---

archive/issue_comments_429325.json:
```json
{
    "body": "Replying to [comment:86 Travis Scrimshaw]:\n> Replying to [comment:83 Matthias K\u00f6ppe]:\n> > Replying to [comment:80 Travis Scrimshaw]:\n> > > Replying to [comment:78 Matthias K\u00f6ppe]:\n> > > > Replying to [comment:71 Travis Scrimshaw]:\n> > > > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. \n> > > > \n> > > > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.\n> > > But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.\n> > \n> > No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.\n> \n> Sorry, that was a bad phrasing on my part. You are asking for returning **R**<sup>6</sup> to be okay\n\nNo",
    "created_at": "2022-09-07T15:31:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429325",
    "user": "mkoeppe"
}
```

Replying to [comment:86 Travis Scrimshaw]:
> Replying to [comment:83 Matthias Köppe]:
> > Replying to [comment:80 Travis Scrimshaw]:
> > > Replying to [comment:78 Matthias Köppe]:
> > > > Replying to [comment:71 Travis Scrimshaw]:
> > > > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> > > > 
> > > > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.
> > > But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.
> > 
> > No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.
> 
> Sorry, that was a bad phrasing on my part. You are asking for returning **R**<sup>6</sup> to be okay

No



---

archive/issue_comments_429326.json:
```json
{
    "body": "Replying to [comment:77 Travis Scrimshaw]:\n> Unfortunately, this is not the Dire Straights song \u201cMoney for Nothing\u201d\n\nI do appreciate the attempt to engage in intergenerational dialogue",
    "created_at": "2022-09-07T15:32:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429326",
    "user": "mkoeppe"
}
```

Replying to [comment:77 Travis Scrimshaw]:
> Unfortunately, this is not the Dire Straights song “Money for Nothing”

I do appreciate the attempt to engage in intergenerational dialogue



---

archive/issue_comments_429327.json:
```json
{
    "body": "Replying to [comment:88 Matthias K\u00f6ppe]:\n> Replying to [comment:86 Travis Scrimshaw]:\n> > Replying to [comment:83 Matthias K\u00f6ppe]:\n> > > Replying to [comment:80 Travis Scrimshaw]:\n> > > > Replying to [comment:78 Matthias K\u00f6ppe]:\n> > > > > Replying to [comment:71 Travis Scrimshaw]:\n> > > > > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. \n> > > > > \n> > > > > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.\n> > > > But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.\n> > > \n> > > No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.\n> > \n> > Sorry, that was a bad phrasing on my part. You are asking for returning **R**<sup>6</sup> to be okay\n> \n> No\n\nThen if you rename the functor hook to `tensor_product`, then `FilteredVectorSpace`'s method of that name would have a bug.",
    "created_at": "2022-09-07T23:19:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429327",
    "user": "tscrim"
}
```

Replying to [comment:88 Matthias Köppe]:
> Replying to [comment:86 Travis Scrimshaw]:
> > Replying to [comment:83 Matthias Köppe]:
> > > Replying to [comment:80 Travis Scrimshaw]:
> > > > Replying to [comment:78 Matthias Köppe]:
> > > > > Replying to [comment:71 Travis Scrimshaw]:
> > > > > > There is no generic way to give a tensor product the structure of a specific type of module. This essentially amounts to saying there is a canonical isomorphism between, e.g., **R**<sup>2</sup> (x) **R**<sup>3</sup> = **R**<sup>6</sup>. 
> > > > > 
> > > > > It does not have to be canonical to be useful. And in fact one wouldn't construct that but rather construct a free module whose basis is indexed by the cartesian product of the input index sets.
> > > > But that is doing what is mandated by the category. It is holding onto the knowledge of how it is constructed. What you are asking for is something to return the equivalent of **R**<sup>6</sup>.
> > > 
> > > No, I don't think this resembles anything what I'm asking for. I think we've lost the context somewhere on the way here.
> > 
> > Sorry, that was a bad phrasing on my part. You are asking for returning **R**<sup>6</sup> to be okay
> 
> No

Then if you rename the functor hook to `tensor_product`, then `FilteredVectorSpace`'s method of that name would have a bug.



---

archive/issue_comments_429328.json:
```json
{
    "body": "Replying to [comment:89 Matthias K\u00f6ppe]:\n> Replying to [comment:77 Travis Scrimshaw]:\n> > Unfortunately, this is not the Dire Straights song \u201cMoney for Nothing\u201d\n> \n> I do appreciate the attempt to engage in intergenerational dialogue\n\nActually, that is music I like. `;)` Or should I say I appreciate that there's \"No One Like You\" that I appreciate to have these discussions with.",
    "created_at": "2022-09-07T23:24:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30136",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30136#issuecomment-429328",
    "user": "tscrim"
}
```

Replying to [comment:89 Matthias Köppe]:
> Replying to [comment:77 Travis Scrimshaw]:
> > Unfortunately, this is not the Dire Straights song “Money for Nothing”
> 
> I do appreciate the attempt to engage in intergenerational dialogue

Actually, that is music I like. `;)` Or should I say I appreciate that there's "No One Like You" that I appreciate to have these discussions with.
