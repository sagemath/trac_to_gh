# Issue 28294: bliss canonical labels ignores edge labels

Issue created by migration from https://trac.sagemath.org/ticket/28531

Original creator: vdelecroix

Original creation time: 2019-09-23 17:28:58

CC:  dcoudert

We consider below a path of 3 vertices. The two edges carry different labels. In particular it has no automorphism. Below bliss simply ignores the edge labels

```

sage: for algo in ['sage', 'bliss']:
....:     G = Graph([(0,1,2),(0,2,1)])
....:     H = Graph([(0,1,1),(1,2,2)])
....:     Gcan, Gmap = G.canonical_label(edge_labels=True, certificate=True, algorithm=algo)
....:     Hcan, Hmap = H.canonical_label(edge_labels=True, certificate=True, algorithm=algo)
....:     print(sorted(Gcan.edges()) == sorted(Hcan.edges()))
True
False
```

(note: instead of comparing the sorted list of edges, one can alternatively set `weighted=True` in the constructors)


---

Comment by dcoudert created at 2019-09-24 14:15:40

By default, `bliss` use edge labels, but it's true we must pass the parameter from method `canonical_label` of `generic_graph.py`.

My understanding of what is done with bliss is:
1. assign a unique id to each possible edge label. 
2. use method `bliss_graph_from_labelled_edges` to build a graph in which each label is modeled with a distinct gadget of vertices and edges.
3. compute the canonical form of this modified graph
4. extract edge labels corresponding to gadgets.

We have to check if these constructions are ok


---

Comment by dcoudert created at 2019-09-24 16:19:41

There is a brief description page 60 of the documentation of `nauty` (http://pallini.di.uniroma1.it/nug26.pdf).
Roughly, a label is a color. If we have `2^d-1` colors, we make a new graph with n*d vertices, d copies of the vertices, and a path connecting the copies of vertex u. Then, if we have edge `(u, v, id)` in the original graph, we take id in binary and add an edge between the ith copy of u and v for each bit of id set to 1.   Then the automorphism group of the original graph is the action of the automorphism of the new graph on the first copies of the vertices.

The code is not nice, but so far I don't see obvious error...


---

Comment by vdelecroix created at 2019-10-18 03:36:46

I think that I identified at least one mistake for graphs (not oriented). The "big graph" encoding the edge colors has vertex set `V x {0, 1, ..., log(num labels)}` where `V` are the vertices of the original graph. Each `V x {i}` should be thought as a layer. Now, the encoding assumes that one can recognize the element in each layer with the actual set `V x {0, 1, ..., log(num labels)}`. To do so, one adds edges from `(v, i)` to `(v, i+1)`. However, this encoding does not make any difference between up and down (ie `0` and `log(num)`) since edges are not oriented. One simple fix is to add an extra vertex that links to all vertices of the layer `V x {0}`.

I am fixing it now and cleaning the code (you are right: this code is a mess).


---

Comment by vdelecroix created at 2019-10-18 06:38:36

Much more dramatic: the edge labels of the graph are mapped to integers in a random fashion in `canonical_form` (the mapping depends on how the graph does its enumeration of edges). In particular, there is no way to guarantee that this mapping will be the same on distinct graphs with the same edge labels.

If we don't require the edge labels to form a total order I don't see how we can fix it.


---

Comment by vdelecroix created at 2019-10-18 06:52:22

At least the attached branch does the job (for edge labels endowed with a total order).
----
New commits:


---

Comment by vdelecroix created at 2019-10-18 06:52:22

Changing status from new to needs_review.


---

Comment by dcoudert created at 2019-10-18 07:34:00

This may fail with Python 3

```diff
+        lab_to_index = {lab:i for i,lab in enumerate(sorted(set(G.edge_labels())))}
```

Edge labels can be of different types, and so cannot always be sorted. I have no suitable solution for this issue :(


---

Comment by vdelecroix created at 2019-10-18 15:18:55

I don't mind that it fails. The current code returns wrong answers in Python 2 which is much worse than failing.

I see two solutions:
- Store a universal list "all objects in Sage up to equality" -> "integers" which is nonsense. You seem to want that kind of feature in comment:6.
- Use more or less what I wrote and specify in the function that canonical labels reaquires a total order on edge labels. I think it is better to raise an error when we detect that they are not. If the user has funny labels, she should provide a dictionary `labels -> integer` to the function. Inside `Graph.is_isomorphic` we can work around this issue easily since we have all labels in hand. In short
  - `is_isomorphic` will work as usual
  - `canonical_label` will work only if the edge labels can be totally sorted.

If solution 2 is acceptable to you I will polish the branch. If not I will add a stopgap to `canonical_label` when `edge_labels=True`.


---

Comment by dcoudert created at 2019-10-18 17:22:42

Let's go for solution 2. Don't forget to add a note explaining that.

If we want to add more freedom (do we really want that?), in case the sorting fail, we could try to work with the string representation of the labels....

Also, have you noticed that parameter `use_edge_labels` is not passed to methods in `bliss.pyx` by methods in `generic_graph.py` ?


---

Comment by vdelecroix created at 2019-10-19 01:29:35

Replying to [comment:8 dcoudert]:
> Let's go for solution 2. Don't forget to add a note explaining that.
> 
> If we want to add more freedom (do we really want that?), in case the sorting fail, we could try to work with the string representation of the labels....

To me it sounds that it would be less freedom since the computer will perform something that you might not want. It is much better to raise an error in case of doubt that the user can fix by providing the relevant mapping `edge label -> integer`.

> Also, have you noticed that parameter `use_edge_labels` is not passed to methods in `bliss.pyx` by methods in `generic_graph.py` ?

No. One more bug.


---

Comment by git created at 2019-10-22 05:56:14

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2019-10-22 05:56:34

Ready for review.


---

Comment by vdelecroix created at 2019-10-22 05:57:08

(I finally relied on string comparison when the edges are not hashable and sortable)


---

Comment by dcoudert created at 2019-10-22 07:24:39

Seems OK. A few comments.


```diff
         Pnr = len(partition)
-        for i in range(len(partition)):
+        for i in range(Pnr):
```

and in the else block right after, no need to set `Pnr = 1` (not used).

in `bliss_digraph_from_labelled_edges`, you could do the same modification as in `bliss_graph_from_labelled_edges` for the `# vertex partition gives colors` block, no ?

in `canonical_form`

```diff
     else:
-        for x,y,lab in G.edge_iterator(labels=True):
+        for x,y in G.edge_iterator(labels=False):
```



---

Comment by git created at 2019-10-22 14:56:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2019-10-22 14:57:51

done


---

Comment by vdelecroix created at 2019-10-23 02:04:13

Patchbot failures have nothing to do with the ticket changes...


---

Comment by dcoudert created at 2019-10-23 07:37:25

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2019-10-23 07:37:25

LGTM.


---

Comment by vbraun created at 2019-10-26 22:20:28

Resolution: fixed
