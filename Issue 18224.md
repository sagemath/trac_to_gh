# Issue 18224: Implement Field._gcd_univariate_polynomial()

archive/issues_018224.json:
```json
{
    "body": "CC:  saraedum\n\nKeywords: polynomial gcd\n\nWe implement `Field._gcd_univariate_polynomial()` using the standard Euclidean algorithm.  This is much faster than the existing Python method `Fields.ParentMethods._gcd_univariate_polynomial()` (which calls `EuclideanDomains.ElementMethods.gcd()`).  (The `_gcd_univariate_polynomial` mechanism was introduced in #13442.)\n\nThe following bug can then be fixed by just removing `PolynomialRealDense.gcd()`, which does not take into account the case where one of the arguments of `gcd` is zero:\n\n```\nsage: R.<x> = RR[]\nsage: x.gcd(R.zero())\nTraceback (most recent call last):\n...\nTypeError: 'MinusInfinity' object cannot be interpreted as an index\n```\n\nRemoving this method *without* implementing `Field._gcd_univariate_polynomial()` (falling back on Python code) is about twice as slow; with this ticket there is no slowdown.\n\nIssue created by migration from https://trac.sagemath.org/ticket/18461\n\n",
    "created_at": "2015-05-20T16:33:12Z",
    "labels": [
        "basic arithmetic",
        "minor",
        "enhancement"
    ],
    "title": "Implement Field._gcd_univariate_polynomial()",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18224",
    "user": "pbruin"
}
```
CC:  saraedum

Keywords: polynomial gcd

We implement `Field._gcd_univariate_polynomial()` using the standard Euclidean algorithm.  This is much faster than the existing Python method `Fields.ParentMethods._gcd_univariate_polynomial()` (which calls `EuclideanDomains.ElementMethods.gcd()`).  (The `_gcd_univariate_polynomial` mechanism was introduced in #13442.)

The following bug can then be fixed by just removing `PolynomialRealDense.gcd()`, which does not take into account the case where one of the arguments of `gcd` is zero:

```
sage: R.<x> = RR[]
sage: x.gcd(R.zero())
Traceback (most recent call last):
...
TypeError: 'MinusInfinity' object cannot be interpreted as an index
```

Removing this method *without* implementing `Field._gcd_univariate_polynomial()` (falling back on Python code) is about twice as slow; with this ticket there is no slowdown.

Issue created by migration from https://trac.sagemath.org/ticket/18461





---

archive/issue_comments_246170.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-05-20T18:52:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18224",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18224#issuecomment-246170",
    "user": "pbruin"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_246171.json:
```json
{
    "body": "This looks good to me. Yet, I have not been able to reproduce the slowdown you mention without the new method: May you give some details?",
    "created_at": "2015-05-21T07:46:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18224",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18224#issuecomment-246171",
    "user": "bruno"
}
```

This looks good to me. Yet, I have not been able to reproduce the slowdown you mention without the new method: May you give some details?



---

archive/issue_comments_246172.json:
```json
{
    "body": "I just tested again with the following setup:\n\n```\nR.<x> = RR[]\nz = R.zero()\nf = x^2 + 3\ng = x^3 + 5\n```\n\nWith this branch (i.e. with `Field._gcd_univariate_polynomial`):\n\n```\nsage: %timeit z.gcd(z)\nThe slowest run took 37.08 times longer than the fastest. This could mean that an intermediate result is being cached \n1000000 loops, best of 3: 1.77 \u00b5s per loop\nsage: %timeit x.gcd(z)\nThe slowest run took 22.57 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 4.34 \u00b5s per loop\nsage: %timeit z.gcd(x)\nThe slowest run took 66.36 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 10.5 \u00b5s per loop\nsage: %timeit x.gcd(x)\nThe slowest run took 13.64 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 11.1 \u00b5s per loop\nsage: %timeit f.gcd(g)\nThe slowest run took 24.83 times longer than the fastest. This could mean that an intermediate result is being cached \n10000 loops, best of 3: 33.6 \u00b5s per loop\n```\n\nWith this branch after removing `Field._gcd_univariate_polynomial`:\n\n```\nsage: %timeit z.gcd(z)\nThe slowest run took 16.42 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 6.81 \u00b5s per loop\nsage: %timeit x.gcd(z)\nThe slowest run took 92.70 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 11.4 \u00b5s per loop\nsage: %timeit z.gcd(x)\nThe slowest run took 15.38 times longer than the fastest. This could mean that an intermediate result is being cached \n100000 loops, best of 3: 19.2 \u00b5s per loop\nsage: %timeit x.gcd(x)\nThe slowest run took 4.43 times longer than the fastest. This could mean that an intermediate result is being cached \n10000 loops, best of 3: 19.9 \u00b5s per loop\nsage: %timeit f.gcd(g)\nThe slowest run took 4.04 times longer than the fastest. This could mean that an intermediate result is being cached \n10000 loops, best of 3: 42.7 \u00b5s per loop\n```\n\nI don't have an explanation for the discrepancy between the slowest and fastest runs; as far as I know there is no caching.\n\nFor complicated polynomials, the difference is undoubtedly smaller because most time is spent in `quo_rem`, which is not touched by this branch.",
    "created_at": "2015-05-21T09:23:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18224",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18224#issuecomment-246172",
    "user": "pbruin"
}
```

I just tested again with the following setup:

```
R.<x> = RR[]
z = R.zero()
f = x^2 + 3
g = x^3 + 5
```

With this branch (i.e. with `Field._gcd_univariate_polynomial`):

```
sage: %timeit z.gcd(z)
The slowest run took 37.08 times longer than the fastest. This could mean that an intermediate result is being cached 
1000000 loops, best of 3: 1.77 µs per loop
sage: %timeit x.gcd(z)
The slowest run took 22.57 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 4.34 µs per loop
sage: %timeit z.gcd(x)
The slowest run took 66.36 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 10.5 µs per loop
sage: %timeit x.gcd(x)
The slowest run took 13.64 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 11.1 µs per loop
sage: %timeit f.gcd(g)
The slowest run took 24.83 times longer than the fastest. This could mean that an intermediate result is being cached 
10000 loops, best of 3: 33.6 µs per loop
```

With this branch after removing `Field._gcd_univariate_polynomial`:

```
sage: %timeit z.gcd(z)
The slowest run took 16.42 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 6.81 µs per loop
sage: %timeit x.gcd(z)
The slowest run took 92.70 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 11.4 µs per loop
sage: %timeit z.gcd(x)
The slowest run took 15.38 times longer than the fastest. This could mean that an intermediate result is being cached 
100000 loops, best of 3: 19.2 µs per loop
sage: %timeit x.gcd(x)
The slowest run took 4.43 times longer than the fastest. This could mean that an intermediate result is being cached 
10000 loops, best of 3: 19.9 µs per loop
sage: %timeit f.gcd(g)
The slowest run took 4.04 times longer than the fastest. This could mean that an intermediate result is being cached 
10000 loops, best of 3: 42.7 µs per loop
```

I don't have an explanation for the discrepancy between the slowest and fastest runs; as far as I know there is no caching.

For complicated polynomials, the difference is undoubtedly smaller because most time is spent in `quo_rem`, which is not touched by this branch.



---

archive/issue_comments_246173.json:
```json
{
    "body": "Ok, I reproduced the same slowdown if `Field._gcd_univariate_polynomial` is removed. Passes all tests, fine for me!",
    "created_at": "2015-05-21T09:39:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18224",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18224#issuecomment-246173",
    "user": "bruno"
}
```

Ok, I reproduced the same slowdown if `Field._gcd_univariate_polynomial` is removed. Passes all tests, fine for me!



---

archive/issue_comments_246174.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-05-21T09:39:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18224",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18224#issuecomment-246174",
    "user": "bruno"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_246175.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-05-21T18:30:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18224",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18224#issuecomment-246175",
    "user": "vbraun"
}
```

Resolution: fixed
