# Issue 21162: Provide ctypes.util.find_library compatibility with Cygwin

Issue created by migration from Trac.

Original creator: 

Original creation time: 2016-09-02 14:27:45

CC:  jhpalmieri

Keywords: windows cygwin

The function `ctypes.util.find_library` does not currently work on Cygwin (though there is a patch I'm going to try to get upstream into Python...eventually...).

I'm not sure the approach I've taken is necessarily the best.  I added a `find_library` function to `sage.misc.misc` which by default is just the original `ctypes.util.find_library`, but uses the Cygwin version on Cygwin (and has the potential to have other platform-specific versions).

I don't think `sage.misc.misc` is necessarily the best place for this, but I do think it would be good (if there isn't already) if Sage had a place for platform/python-version compatibility wrappers.  I think it's definitely better to provide workarounds directly in Sage wherever possible, rather than relying on upstream patches.  And having a compatibility module for Python issues specifically is generally pretty straightforward.

That said, I don't know that there are currently many examples of this in Sage.  Or if there are they're scattered about at random.

This also fixes one related test that fails on Cygwin (on Cygwin libc is found in cygwin.dll, not in a file with "libc" in the name).


---

Comment by embray created at 2016-09-02 14:27:53

Changing type from PLEASE CHANGE to defect.


---

Comment by embray created at 2016-09-02 14:27:53

Changing status from new to needs_review.


---

Comment by git created at 2016-09-02 14:28:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2016-09-02 14:49:24

A better place for this might be `src/sage/misc/sage_ostools.py`


---

Comment by jdemeyer created at 2016-09-02 14:52:53

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2016-09-02 14:52:53

From https://docs.python.org/2/library/subprocess.html#subprocess.Popen.wait

> Warning
> 
> This will deadlock when using stdout=PIPE and/or stderr=PIPE and the child process generates enough output to a pipe such that it blocks waiting for the OS pipe buffer to accept more data. Use communicate() to avoid that.


---

Comment by jdemeyer created at 2016-09-02 15:44:33

`ctypes` is a standard Python library, right? So there is not much hope of pushing this change upstream I guess...


---

Comment by embray created at 2016-09-02 18:01:32

Well, there _is_ hope, it just won't likely land anytime soon.  You're right about the `Popen.wait`  That code is all backwards--it should close the streams first.


---

Comment by git created at 2017-01-05 12:26:09

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by embray created at 2017-01-05 12:28:24

Changing status from needs_work to needs_review.


---

Comment by embray created at 2017-01-05 12:28:24

Rebased, and moved things around a bit so that this is in a new `sage.misc.compat` module, which I think makes sense to have.

Will still be nice to get this fixed upstream in Python, which I will try to do.  But it will probably take a while, and probably won't even happen except in Python 3.


---

Comment by jdemeyer created at 2017-01-05 13:10:34

Alternative solution to the original problem: don't use `ctypes.util.find_library` in the Sage library. It is used only in one place. It turns out that this can easily be avoided because:

1. You could replace the usage of `ctypes` by Cython.

2. The only line where `ctypes` is needed is to call `self._libc().signal(SIGPROF, SIG_DFL)` but that could be replaced by Python's `signal.signal()` instead. I might be missing something, but that should work too...


---

Comment by embray created at 2017-01-05 17:47:33

That's not the only place where it's used (though I agree that using it for signal is superfluous).  The other is to get libprofiler if it is installed.  An advantage of using ctypes, I guess, is that it make a runtime feature check and not actually have it as a dependency.

In any case the work is already done--there are actually other places where this could be useful.  Sage has its own code somewhere for finding library paths (at least, I think I've seen that before), which could probably be stripped out and replaced with `find_library`.


---

Comment by jdemeyer created at 2017-01-06 11:10:04

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-01-06 11:10:04

This definitely needs a doctest. I don't feel like installing `gperftools` just to test this.

I suggest to add a doctest to the module docstring, to ensure that `find_library` will be tested both on Cygwin and non-Cygwin systems.


---

Comment by embray created at 2017-01-06 12:54:26

FWIW the doctests in gperftools do test this, and they pass.  I don't think you need gperftools installed just to test it.  But I don't mind adding a module-level doctest.

Alternatively, for better consistency across platforms, it might be better if our own `find_library` wrapper were defined in all cases.  In most cases it would then just defer to the implementation in ctypes.  Then I can put the doctest in the function docstring.


---

Comment by jdemeyer created at 2017-01-06 13:25:30

Replying to [comment:12 embray]:
> FWIW the doctests in gperftools do test this, and they pass.

Right, but then you only test `find_library` if you run the optional `gperftools` tests.

> Alternatively, for better consistency across platforms, it might be better if our own `find_library` wrapper were defined in all cases.

I don't care much. I just want a non-optional doctest one way or another.


---

Comment by git created at 2017-03-30 14:08:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2017-03-30 14:09:36

Just remembered I updated this a little bit ago.  How's this look now?


---

Comment by embray created at 2017-03-30 14:09:36

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2017-04-12 16:31:01

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2017-04-12 16:31:01

Needs a (trivial) rebase.


---

Comment by git created at 2017-04-13 09:35:28

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by embray created at 2017-04-13 09:35:50

Changing status from needs_work to needs_review.


---

Comment by embray created at 2017-04-13 09:35:50

Rebased.


---

Comment by embray created at 2017-04-21 12:23:02

Changing priority from minor to blocker.


---

Comment by jdemeyer created at 2017-04-21 14:50:10

Is there any particular reason that you are wrapping `ctypes.find_library` in the non-Cygwin case too? Couldn't you do something like

```
from ctypes import find_library

if CYGWIN:
    def find_library(...):
        ...
```



---

Comment by embray created at 2017-04-21 16:25:59

Replying to [comment:13 jdemeyer]:
> Replying to [comment:12 embray]:
> > FWIW the doctests in gperftools do test this, and they pass.
> 
> Right, but then you only test `find_library` if you run the optional `gperftools` tests.
> 
> > Alternatively, for better consistency across platforms, it might be better if our own `find_library` wrapper were defined in all cases.
> 
> I don't care much. I just want a non-optional doctest one way or another.


---

Comment by jdemeyer created at 2017-04-22 18:39:40

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-04-23 16:56:09

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2017-04-23 16:56:09

On OSX:

```
sage -t --long src/sage/misc/compat.py
**********************************************************************
File "src/sage/misc/compat.py", line 66, in sage.misc.compat
Failed example:
    find_library('Singular')
Expected:
    '...Singular...'
Got:
    <BLANKLINE>
**********************************************************************
1 item had failures:
   1 of   3 in sage.misc.compat
    [2 tests, 1 failure, 0.46 s]
```



---

Comment by embray created at 2017-04-24 12:40:19

I don't know what to do about this.  Why would it not work on OSX, using the built-in `find_library` from ctypes?  Is that known not to work?  Is there some way I can just skip this test on OSX?


---

Comment by embray created at 2017-04-24 12:56:42

I don't know much about OSX, but looking at [`dyld_find`](https://hg.python.org/cpython/file/tip/Lib/ctypes/macholib/dyld.py#l116) (on top of which `find_library` is implemented on OSX), I'm not sure it will find dylibs in `$SAGE_LOCAL` without tweaking this a bit, or at least fiddling with one of the environment variables it reads from?


---

Comment by tscrim created at 2017-04-26 15:45:45

John, do you have an idea about this?


---

Comment by jhpalmieri created at 2017-04-26 20:22:25

I think `embray` is right: `dyld_find` looks in certain hard-coded locations for libraries. If I try `find_library('Singular')` from the command line, it fails unless I add a line

```
os.environ['DYLD_LIBRARY_PATH'] = os.path.join(os.environ['SAGE_LOCAL'], 'lib')
```

(This is probably not the right way to do it, we should set the environment in `sage-env` or `sage.env` or something, but anyway...)


---

Comment by jhpalmieri created at 2017-04-26 20:24:18

Or maybe we shouldn't set the environment globally, but instead just for this one doctest, unless there is some other reason for imposing a value for `DYLD_LIBRARY_PATH` everywhere.

Edit: or set the variable in the code for Sage's version of `find_library`.


---

Comment by embray created at 2017-05-02 07:11:09

Definitely not just for the doctest.  It occurs to me that the `find_library` function probably just doesn't actually work properly in Sage on OSX for this reason, but there previously weren't any tests that were affected by that.  So I think it needs to be wrapped on OSX too.  The wrapper can just set that environment variable temporarily, or some other such hack.


---

Comment by git created at 2017-05-02 07:44:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2017-05-02 07:49:28

Added what I think should make this function work properly on OSX, but not tested.  Is there an easy way I personally can check if this worked?  I don't actually see any OSX machines listed among the patchbots...

FWIW, this does work on Linux because it tries a number of different strategies to find libraries on Linux, one of which is to actually call `ld` with the `--trace` flag which will actually print out whatever library gcc finds for the given library name.  And because sage-env sets `LDFLAGS` we get the right result for libraries installed in Sage.


---

Comment by embray created at 2017-05-02 07:49:28

Changing status from needs_work to needs_review.


---

Comment by jhpalmieri created at 2017-05-02 15:57:56

This works for me on OS X:

```
sage: from sage.misc.compat import find_library
sage: find_library('Singular')
'/Users/palmieri/Desktop/Sage_stuff/git/sage/local/lib/libSingular.dylib'
```



---

Comment by embray created at 2017-05-03 08:58:14

Awesome, thanks for checking.  Would you set this as positive review then?


---

Comment by jhpalmieri created at 2017-05-03 18:07:14

I'm curious about a few things. First, why use

```
if sys.platform == 'cygwin':
    def _find_library(name):
        ...
elif ...
    def _find_library(name):
```

as compared to

```
def _find_library(name):
    if sys.platform == 'cygwin':
        ...
    elif
        ...
```

or


```
def find_library(name):
    if sys.platform == 'cygwin':
        ...
    elif
        ...
```

?

Second, is the resulting version of `find_library` different enough from the standard Python one that it should have a new name?

Third, why use `sage_wraps`? It conceals the new docstring and source code when doing introspection.

Fourth, is there any particular reason the copyright is in William Stein's name, not yours?


---

Comment by jhpalmieri created at 2017-05-03 18:10:25

Fifth, is there any reason to prefer one string formatting method over another? In the Cygwin branch, you use `.format` and in the Darwin branch you use `"%s:%s" % (...)`.


---

Comment by embray created at 2017-05-04 16:45:06

Replying to [comment:34 jhpalmieri]:
> I'm curious about a few things. First, why use

This is a normal pattern, especially for a system compatibility module like this.  Think of it like an `#ifdef` in C.  This defines different implementations of the function for different platforms, rather that having one big implementation with per-platform implementations in an if-statement.

> Second, is the resulting version of `find_library` different enough from the standard Python one that it should have a new name?

No, it is the same thing.  Again, the point of this is to provide a compatible replacement.

> Third, why use `sage_wraps`? It conceals the new docstring and source code when doing introspection.

The docstring here is for developer documentation, not user documentation.  Again, this is just providing a replacement for the system builtin which is missing / buggy / incomplete in the default implementation.

> Fourth, is there any particular reason the copyright is in William Stein's name, not yours?

I probably copied it from somewhere else.  Frankly, I don't care. I hereby give copyright of my code to William Stein.


---

Comment by jhpalmieri created at 2017-05-04 19:33:31

Replying to [comment:36 embray]:
> Replying to [comment:34 jhpalmieri]:
> > I'm curious about a few things. First, why use
> 
> This is a normal pattern, especially for a system compatibility module like this.

Okay.

> > Second, is the resulting version of `find_library` different enough from the standard Python one that it should have a new name?
> 
> No, it is the same thing.

Okay.

> > Third, why use `sage_wraps`? It conceals the new docstring and source code when doing introspection.
> 
> The docstring here is for developer documentation, not user documentation.  Again, this is just providing a replacement for the system builtin which is missing / buggy / incomplete in the default implementation.

The original function has no documentation, so by using `sage_wraps`, you conceal useful information and at least from the documentation point of view, gain nothing. What do you gain by using `sage_wraps`? It seems like it would be better to skip `sage_wraps`.

You should also add to the docstring something like "This provides a replacement for the Python function ctypes.util.find_library, adding ...". It will be much easier to maintain if future users know why the changes were made.

Finally, Sage development policy is that every function and method should have a docstring which includes an EXAMPLES block. Please add those to both instances of `_find_library`.


---

Comment by embray created at 2017-05-05 09:02:06

Replying to [comment:37 jhpalmieri]:
> The original function has no documentation, so by using `sage_wraps`, you conceal useful information and at least from the documentation point of view, gain nothing. What do you gain by using `sage_wraps`? It seems like it would be better to skip `sage_wraps`.

Ah, I didn't even notice that it has no existing documentation.  In that case, I'll rewrite the docstring to be more useful.

> You should also add to the docstring something like "This provides a replacement for the Python function ctypes.util.find_library, adding ...". It will be much easier to maintain if future users know why the changes were made.

The docstring or a comment?  I don't think all development-related notes belong in the docstrings themselves.  I'll add something though.

> Finally, Sage development policy is that every function and method should have a docstring which includes an EXAMPLES block. Please add those to both instances of `_find_library`.

`_find_library` is an internal detail--it would only make sense on the public `find_library`.  That said, while I don't mind doing so, I'm not really sure that should apply here.  This `compat` module is intended for internal use, to provide cross-platform compatibility wrappers to standard functionality in Python in a single place.  This isn't meant to be documented as part of some API that users should discover, and could even go away depending on how the implementation in Python is improved in the future.  In any case, the doctest that's already in there serves as example enough, so would it just be a matter of changing its heading to "EXAMPLE:"?


---

Comment by jhpalmieri created at 2017-05-05 16:11:51

Replying to [comment:38 embray]:
> > Finally, Sage development policy is that every function and method should have a docstring which includes an EXAMPLES block. Please add those to both instances of `_find_library`.
> 
> `_find_library` is an internal detail--it would only make sense on the public `find_library`.  That said, while I don't mind doing so, I'm not really sure that should apply here.  

There is nothing in the Sage developer's guide about exceptions for internal details, and many such details are documented, with doctests. The documentation is not just for users, but for developers: ease of maintenance, etc. Same with doctests: it is extremely useful to know if something internal breaks.

> In any case, the doctest that's already in there serves as example enough, so would it just be a matter of changing its heading to "EXAMPLE:"?

I'm not sure what you mean, since the heading is already "EXAMPLES:", which is perfect. For the two `_find_library` functions, you could add exactly the same doctest or something else ('gap', for example).


---

Comment by embray created at 2017-05-05 18:29:49

> many such details are documented, with doctests

Yes, but not all, so you can't claim this is followed consistently. Sure there are cases where that might make sense but this is clearly not one of them. You're asking here to add a test for functions that are there _just_ to be wrapped, whereas the wrapper function provides the interface, documentation, and tests all in one place.  Otherwise all you have is two completely redundant tests.


---

Comment by jhpalmieri created at 2017-05-05 18:42:48

The Sage policy is that all functions should be documented and doctested. It is not a good thing that this policy has not always been followed. Just doctest the things and stop arguing about it.


---

Comment by tscrim created at 2017-05-06 15:44:04

I would say here that it does not make sense to doctest the individual functions because they would be duplicating the doctest of the actual function that is called. Moreover, these functions are machine specific. With that being said, I think the functions should have some docstrings, in particular, the comments that precede them, as this is the convention for documenting functions.


---

Comment by jhpalmieri created at 2017-05-07 18:28:51

The Sage developer's guide says that every function should be doctested, it does not leave it up to the discretion of the authors or the reviewers. Travis, you are pretty picky about, for example, using `.. NOTE::` instead of `.. note::` because that is Sage's policy. If we can't use our discretion regarding capitalization, I really don't think we can use it to decide to omit doctests.

If you really want to allow people to skip doctests, that has to be discussed on sage-devel.


---

Comment by tscrim created at 2017-05-08 13:48:24

How I am seeing these functions is really as a granulized form of

```
def foo():
    if case1:
         do_case1
    elif case2:
         do_case2
```

I'm not sure why it should/must be how Erik implemented it this way, but testing each individual function does not make sense to me because they only work on certain machines. At least the only way I see to add tests is to duplicate the test of `find_library`. So I feel like this is an exceptional case. Do you have any suggestions about how to doctest these functions?


---

Comment by jhpalmieri created at 2017-05-08 15:38:26

I think that there are libraries we only install on cygwin, which would make it clear how to test that branch. With darwin, we can at least check that some library that we find ends in '.dylib'.

I've written lots of doctests, and some of them duplicate others. Sometimes that is unavoidable.

But this is ridiculous: we should never make exceptions to the docstring and doctest rule unless sage-devel weighs in. I don't see a compelling case for it here. It's not like adding doctests is hard here: it would have taken 30 seconds to add them, but you and Erik seem intent on wasting lots of time debating it. Do whatever you want, I'm not interested in anymore. I'm also not interested in reviewing tickets if I'm going to get this level of resistance to what I think are reasonable suggestions.


---

Comment by tscrim created at 2017-05-08 16:42:02

John, I am sorry to have upset you. I value and respect your opinion, and I hope that you will continue to review tickets. I completely agree that your suggestion of having doctests is reasonable, but I'm just not fully convinced the same doctest would be meaningful. However, I do not have any objections to adding such doctests. Erik, could you add them?


---

Comment by embray created at 2017-05-09 12:13:57

"Every function needs to be doctested" does not mean "every def statement".


---

Comment by embray created at 2017-05-09 12:17:17

This is getting silly--the ticket already had positive review, but then needed to be worked for OSX.  I have no done that, and am grateful for the confirmation that it's been fixed on OSX--given that confirmation, I will set it back to positive review.


---

Comment by embray created at 2017-05-09 12:17:17

Changing status from needs_review to positive_review.


---

Comment by git created at 2017-05-09 13:20:40

Changing status from positive_review to needs_review.


---

Comment by git created at 2017-05-09 13:20:40

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by jdemeyer created at 2017-05-27 12:05:30

I think your latest commit broke OS X again: `_orig_find_library` is gone.


---

Comment by jdemeyer created at 2017-05-27 12:05:30

Changing status from needs_review to needs_work.


---

Comment by embray created at 2017-05-29 09:32:22

Right. I fixed that a while ago.  Might have forgotten to push.


---

Comment by git created at 2017-05-29 13:33:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-05-29 15:27:10

Needs review?


---

Comment by embray created at 2017-05-29 16:01:11

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-06-26 13:35:20

Sorry for the delay, but some details of the OS X implementation are still wrong:

1. Try `try` block is too small: anything changing `os.environ['DYLD_LIBRARY_PATH']` should be inside the try.

2. The `finally` does not remove the environment variable `DYLD_LIBRARY_PATH` if it was unset before.


---

Comment by jdemeyer created at 2017-06-26 13:35:20

Changing status from needs_review to needs_work.


---

Comment by embray created at 2017-06-26 13:46:51

I don't agree that it's "wrong".  In fact, it's much more common to take actions with state-changing side-effects outside a try statement, and then the purpose of the try/finally is to restore the previous state assuming that it was successfully changed.  An exception somehow occurring during changing os.environ is completely unrelated and doesn't even necessarily indicate a sensible previous state to return to.


---

Comment by git created at 2017-06-26 13:53:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2017-06-26 13:53:38

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-06-26 13:54:44

In Python, you should assume that exceptions can occur at any time for any reason. For example, depending on the implementation of `os.environ`, it could be that the actual environment variable is changed but then changing the dict `os.environ` raises a `MemoryError`. In that case, you need the `finally` clause. Or, there could be some signal arriving with the signal handler raising an exception.

By changing state inside the `try`, you are safe from such race conditions.


---

Comment by jdemeyer created at 2017-06-26 14:48:09

There is also a style issue:

with code of the form

```
change_state()

try:
    ...
finally:
    reset_state()
```

it is more likely that people will write code between `change_state()` and the `try` statement:

```
change_state()

code_added_here_by_mistake()

try:
    ...
finally:
    reset_state()
```

When everything is inside the `try`, this is much less likely to happen.


---

Comment by embray created at 2017-06-26 15:37:54

These are all extremely pathological hypotheticals that will lead to broken code anyways.  

A more common example is something like this:


```
prev_dir = os.getcwd()
os.chdir(somewhere)
try:
    something()
finally:
    os.chdir(prev_dir)
```


It's written this way because you wouldn't `chdir(prev_dir)` unless the previous `chdir()` succeeded in the first place (which is much less a pathological situation--`chdir()` can fail for reasons as simple as a permission error).  If you want to handle exceptions in `chdir()` itself you put a try/except around that.  Likewise with setting an `os.environ` key; in fact that's even worse because if that somehow failed then the code in the `finally:` block needs to be written to account for any possible state `os.environ` is in.

In fact PEP 8 recommends (for good reasons) putting the minimal possible code in a `try:` statement.  This applies more to try/except than for try/finally I admit, but even with try/finally the intent is more clear in exactly which code you're anticipating the possibility of an exception.


---

Comment by embray created at 2017-06-26 15:41:08

To be clear it's not necessarily wrong to do it the other way around either, but ultimately it's splitting hairs.


---

Comment by jdemeyer created at 2017-06-27 11:55:04

Replying to [comment:61 embray]:
> These are all extremely pathological hypotheticals that will lead to broken code anyways.

Please elaborate...

I have fixed many race conditions in Sage. They may be unlikely, but not hypothetical.

For me, it's a simple discussion: the code that I propose is more correct than the code that you propose (for example: my code will deal correctly with a `KeyboardInterrupt` between the `chdir()` system call and the entering of the `try` block).

So you need to explain either why I'm wrong, or why, despite my code being more correct, your code is still better anyway (and correctness of code beats PEP 8 hands down).


---

Comment by jdemeyer created at 2017-06-27 12:05:22

Replying to [comment:61 embray]:
> you wouldn't `chdir(prev_dir)` unless the previous `chdir()` succeeded in the first place

The problem is that you are confusing the `os.chdir()` Python function with the `chdir(2)` system call.

Your statement is correct when interpreting it as the system call. Unfortunately, in Python, it is possible that the Python function raises an exception even if the system call succeeded (and this isn't hypothetical, I have managed to reproduce exactly this with `os.fork()`).

PS 1: Even the Python standard library suffers from such issues. I remember debugging a race condition in the Sage Notebook which was traced to the Python `tempfile` module.

PS 2: This is exactly why I prefer to use Cython for anything involving system calls. It doesn't suffer from these issues because you can call the system call directly.


---

Comment by jdemeyer created at 2017-06-27 12:14:18

Replying to [comment:61 embray]:
> Likewise with setting an `os.environ` key; in fact that's even worse because if that somehow failed then the code in the `finally:` block needs to be written to account for any possible state `os.environ` is in.

What do you mean with "any possible state"? I think that there are only 2 possibilities: either the value in the dict was updated, or it wasn't. If you are worrying about deleting a key which may not exist, you can use `os.environ.pop(key, None)`.


---

Comment by embray created at 2017-06-27 12:46:45

First of all, is a signal is delivered during the call of a _python_ function like `os.chdir()` it doesn't matter if the signal is delivered before or after the system call.  Python will note it and call the Python-level signal handler _after_ the completion of that call instruction, before executing the next Python instruction.  So actually it doesn't matter whether or not the system call failed because the keyboard interrupt will always be raised after (and if it did succeed then you do have a point, though only if some code higher up is catching the `KeyboardInterrupt`).  These details are also probably CPython-specific but that's the only Python implementation we care about.

I don't think it's particularly more or less correct.

For example, if you _really_ wanted to handle the possibility of an exception occurring in `os.environ.__setter__` the most correct way would actually be something like:


```
old_foo = os.environ['FOO']  # Also, where should this go??
try:
    try:
        os.environ['FOO'] = bar
        cleanup = True
    except:
        cleanup = False
        raise

     do_stuff()
finally:
    if cleanup:
        os.environ['FOO'] = old_foo
```


And even this is less than perfect because if an exception occurs during `os.environ['FOO']` you can't say for sure if the system call itself succeeded unless you handle specific exceptions like `MemoryError` versus `KeyboardInterrupt` separately.  Also in my example above an exception could occur between `os.environ['FOO'] = bar` and `cleanup = True`.  Even `cleanup = True` might not work correctly, albeit due to [a bug in Python](http://bugs.python.org/issue30744) :)  I suppose that during the cleanup you could check `os.environ['FOO'] != old_foo` but my point is that if you're at that level of micro-optimisation for exceptional conditions you probably shouldn't be writing it in Python in the first place.  

In fact if you just read the Python documentation the vast majority of similar examples are _not_ written like this.  For example a very common idiom is with locks:


```
    lock.acquire()
    try:
        do_something()
    finally:
        lock.release()
```


Same if you use `with lock:` since the above is essentially the pseudo-code for how the `with` statement is implemented.  At the level of the Python interpreter there are two separate instructions `SETUP_WITH` and `WITH_CLEANUP`.  If an exception occurs after the `SETUP_WITH` but before `WITH_CLEANUP` it will always jump to `WITH_CLEANUP` before raising.  However, if an exception occurs inside the context-manager's `__enter__` then `__enter__` never returns (sucessfully) and the block inside the `with` statement is not set up (and hence the "finally" block that calls the `__exit__` is never set up either).  So the end result is the same as the above pseudo-code.

If what you're describing is really a problem then code like, when using locks this could lead to deadlocks.  But at the same time it's not appropriate to try to call `lock.release()` unless `lock.acquire()` _definitely_ succeeded, in which case you need extra exception handling around `lock.acquire()`.

So with all that said, I think if you're really convinced that this order of doing things is "wrong" this is the wrong place to split hairs about it, and you should bring it up with python-ideas.  Honestly I'd probably even support you there if you demonstrated a good example of it.


---

Comment by embray created at 2017-06-27 12:48:07

Replying to [comment:64 jdemeyer]:
> Replying to [comment:61 embray]:
> > you wouldn't `chdir(prev_dir)` unless the previous `chdir()` succeeded in the first place
> 
> The problem is that you are confusing the `os.chdir()` Python function with the `chdir(2)` system call.

I'm not sure what makes you think that.


---

Comment by jdemeyer created at 2017-06-27 20:23:06

Replying to [comment:66 embray]:
> {{{
> old_foo = os.environ['FOO']  # Also, where should this go??
> try:
>     try:
>         os.environ['FOO'] = bar
>         cleanup = True
>     except:
>         cleanup = False
>         raise
> 
>      do_stuff()
> finally:
>     if cleanup:
>         os.environ['FOO'] = old_foo
> }}}

I don't think that it is important to know whether the system call succeeded or not. I would just reset `os.environ['FOO'] = old_foo` unconditionally and then the code becomes no more complicated than your alternative.


---

Comment by jdemeyer created at 2017-06-28 08:43:15

Replying to [comment:66 embray]:
> Same if you use `with lock:` since the above is essentially the pseudo-code for how the `with` statement is implemented.

This is not actually true. I actually tested this and the `__exit__` in a `with` block _is_ called, even if an interrupt occurs during `__enter__`.

In other words, this Python code

```
lock.__enter__()
try:
    ...
finally:
    lock.__exit__()
```

is unsafe while

```
with lock:
    ...
```

is safe from this race condition.

Of course, this is only really true if `__enter__` is implemented in C or Cython. In pure Python, `__enter__` itself could raise a `KeyboardInterrupt`. But `threading.Lock` is implemented in C, so that example would work.


---

Comment by jdemeyer created at 2017-06-28 08:55:55

Replying to [comment:66 embray]:
> In fact if you just read the Python documentation the vast majority of similar examples are _not_ written like this.

I don't see how that is relevant to the current discussion. Why should it matter whether or not other people make the same mistake?

Now, back to this ticket. Concretely, I propose to

1. Move all code which changes `os.environ` _inside_ the `try` block.

2. Replace `del os.environ['DYLD_LIBRARY_PATH']` by `os.environ.pop('DYLD_LIBRARY_PATH', None)`

As far as I can tell, this is 100% safe and no more complicated than the current code.


---

Comment by jdemeyer created at 2017-06-28 09:03:27

Replying to [comment:66 embray]:
> So with all that said, I think if you're really convinced that this order of doing things is "wrong" this is the wrong place to split hairs about it, and you should bring it up with python-ideas.  Honestly I'd probably even support you there if you demonstrated a good example of it.

I mentioned before that this kind of bug did occur with some SageNB code involving the `tempfile` module. I don't remember the exact bug, but this was real non-pathological code (if you care a lot, I could probably find the bug again). Since `tempfile` is written in pure Python, it could not easily be fixed so I never bothered reporting it as a bug. In the end, we changed the SageNB code to work around this bug.


---

Comment by jdemeyer created at 2017-06-28 09:38:37

If you are interested, this test code shows the difference between `try`/`finally` and `with` for `threading.Lock`:

```python
from cysignals.tests import interrupt_after_delay
from time import sleep
from threading import Lock


def try_release(lock):
    try:
        lock.release()
    except Exception:
        return False
    return True


def test_lock1(lock, ms):
    try:
        interrupt_after_delay(ms)
        with lock:
            while True:
                sleep(1)
    except KeyboardInterrupt:
        pass

    
def test_lock2(lock, ms):
    try:
        interrupt_after_delay(ms)
        lock.acquire()
        try:
            while True:
                sleep(1)
        finally:
            lock.release()
    except KeyboardInterrupt:
        pass


lock = Lock()

for a in range(1000):
    for t in range(8):
        test_lock1(lock, t)
        if try_release(lock):
            print("test_lock1 #{}: lock was held (t={})".format(a, t))

        test_lock2(lock, t)        
        if try_release(lock):
            print("test_lock2 #{}: lock was held (t={})".format(a, t))

print("DONE")
```


It is not hard to reproduce the situation where the lock ends up being locked after calling `test_lock2`. With `test_lock1`, this never happens.


---

Comment by jdemeyer created at 2017-06-28 10:00:57

In order to truly fix this in Python, there should be a way to temporarily disable interrupts. Similar to `gc.disable()`, there could be `signal.disable()`.


---

Comment by embray created at 2017-06-28 10:02:10

I'll get back to you but absolutely none of this is relevant to this ticket.  Please just set it to "positive review" and we can continue this discussion elsewhere.  The amount of stress I've had to put up with for this relatively trivial code addition has honestly turned me off from ever trying to do anything on this project.


---

Comment by embray created at 2017-06-28 10:06:24

You're welcome to do what you want. I want nothing more to do with this ticket.


---

Comment by embray created at 2017-06-28 10:16:19

Replying to [comment:69 jdemeyer]:
> Replying to [comment:66 embray]:
> > Same if you use `with lock:` since the above is essentially the pseudo-code for how the `with` statement is implemented.
> This is not actually true. I actually tested this and the `__exit__` in a `with` block _is_ called, even if an interrupt occurs during `__enter__`.

It is true _in general_.  If an exception is raised inside `__enter__` it will never execute the `__exit__`.

> Of course, this is only really true if `__enter__` is implemented in C or Cython. In pure Python, `__enter__` itself could raise a `KeyboardInterrupt`. But `threading.Lock` is implemented in C, so that example would work.

Exactly, but that's an implementation detail.  It works out that way if `__enter__` is written in C because there are no Python opcodes executed by the function, so the interrupt isn't handled and the exception is not raised until after the C function has returned and the frame for the `with` statement block has been set up.

As far as the Python documentation and language design go, however, this distinction does not exist.  However, you do have a good point here--it might be worth bringing up to the Python folks.

My point is that you're obsessing over implementation details about CPython in order to make sweeping statements about actually pretty standard patterns being "wrong".


---

Comment by jdemeyer created at 2017-06-28 10:29:53

Replying to [comment:74 embray]:
> The amount of stress I've had to put up with for this relatively trivial code addition has honestly turned me off from ever trying to do anything on this project.

Come on Erik, I think that's not very fair. On [comment:70], I made a very concrete suggestion for a small and simple fix. I still don't get why you refuse to make that change. I just pushed that change myself.

I hope that we can still resolve this discussion in friendliness...
----
New commits:


---

Comment by embray created at 2017-06-28 11:50:45

What's not very fair is John and now you browbeating me for _months_ over a fairly small amount of perfectly idiomatic Python code that is shown (other than minor but undeniable bugs that have been fixed) to work.  I think almost anyone would reach their limit at a certain point, and I definitely want nothing to do with it anymore.

The technical argument I'm not upset about, and while I think it's unfair of you to broadly declare something "wrong" when from a Pythonic standpoint it isn't, I think you do raise an interesting point.  As a gesture of good will (I hope) I've made a post to Python-Ideas describing it; hopefully I've represented your view accurately and fairly.  Feel free to chime in either way: https://mail.python.org/pipermail/python-ideas/2017-June/046227.html


---

Comment by jdemeyer created at 2017-06-28 12:02:11

Replying to [comment:80 embray]:
> What's not very fair is John and now you browbeating me for _months_ over a fairly small amount of perfectly idiomatic Python code that is shown (other than minor but undeniable bugs that have been fixed) to work.

I agree with this and understand your frustration. Let's just say that you were unlucky that you got hit by several people insisting strongly on a minor issue.

To be 100% honest, I do think that you could have avoided some trouble here by just doing what the reviewers (John and me) asked you to change instead of going into a lengthy discussion. For example, even if you think that my most recent change wasn't required, it doesn't hurt either.

Anyway, as far as I'm concerned, this ticket is good to go.


---

Comment by jdemeyer created at 2017-06-28 12:02:53

PS: nothing personal!


---

Comment by embray created at 2017-06-28 13:11:13

Replying to [comment:82 jdemeyer]:
> PS: nothing personal!

Same (though my frustration is real)!


---

Comment by embray created at 2017-06-28 14:38:04

Let me ask you this though: Say I had explicitly implemented a context manager for setting/restoring an environment variable (something I feel like I've done dozens of times before in writing test suites).  Would you have raised an objection in that case?  Because all I'm doing here is hand-writing the context manager protocol out of laziness.  It also turns out, assuming [this code](https://github.com/python/cpython/blob/e82cf8675bacd7a03de508ed11865fc2701dcef5/Python/ceval.c#L1067-L1071) is correct (I'm not 100% convinced it is though) that a signal handler can't be executed between the last statement before a try, and the try block.  

In other words (and I didn't know this) if I have:


```
os.environ['FOO'] = 'a'
try:
    ...
```


the disassembly looks like


```
STORE_SUBSCR
SETUP_FINALLY
```


so this is actually atomic.  But it's not perfect--my actual code was like:


```
if something:
    os.environ['FOO'] = 1
else:
    os.environ['FOO'] = 2
try:
    ...
```


In this case, in one of the branches (probably the second one) the `STORE_SUBSCR` will be atomic with `SETUP_FINALLY`, whereas in the first branch there's a `JUMP_FORWARD` first.  Really it would need to be smarter, either by following jumps to see what the next instruction would be, or perhaps better something more like Nick Coghlan's idea of having a generic way to make all ops up to a particular instruction atomic w.r.t. signals.


---

Comment by embray created at 2017-06-28 14:49:08

Ah, I just finished reading njs's [blog post](https://vorpus.org/blog/control-c-handling-in-python-and-trio/) and he confirms my suspicion that the `SETUP_FINALLY` special case doesn't really actually work, especially in the case of a function call just before the `try:`.


---

Comment by jdemeyer created at 2017-06-28 14:55:29

Replying to [comment:84 embray]:
> Let me ask you this though: Say I had explicitly implemented a context manager for setting/restoring an environment variable.  Would you have raised an objection in that case?

It's hard to answer such hypothetical questions.

Anyway, the Python bug made me realize that it's simply very hard (if not impossible) to write 100% interrupt-safe Python code. So I do feel a bit stupid now for insisting so much.


---

Comment by embray created at 2017-06-28 15:02:35

That's okay, you still raised some specific points I hadn't considered before, even if I was sure there was nothing you could really guarantee about what's right/wrong here.  This is what I meant when I wrote, perhaps inarticulately:

> if you're at that level of micro-optimisation for exceptional conditions you probably shouldn't be writing it in Python in the first place


---

Comment by charpent created at 2017-07-01 06:09:55

On a Virtulbox running Windows10 professional, I compiled 8.0.rc0 + #23339 + #21233 + #23097 + #21399 (present ticket) with the options :

```
export PREREQ_OPTIONS=--with-blas=atlas
export SAGE_ATLAS_LIB=/usr/lib
export MAKE="make -j4"
```


This passes ptestlong with no failures.

==> positive_review

Note : I have no advice on the contents of the patches (I do not know Cygwin well enough to undetstand what they are supposed to do) ; I just checked that this leads to a functional Sage.


---

Comment by charpent created at 2017-07-01 06:12:18

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-07-02 17:16:28

Resolution: fixed
