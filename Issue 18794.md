# Issue 18794: New Algorithm for Top-K Closeness Centralities

archive/issues_018794.json:
```json
{
    "body": "CC:  @nathanncohen @dcoudert\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/19031\n\n",
    "created_at": "2015-08-14T12:26:21Z",
    "labels": [
        "component: please change"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.9",
    "title": "New Algorithm for Top-K Closeness Centralities",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18794",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```
CC:  @nathanncohen @dcoudert



Issue created by migration from https://trac.sagemath.org/ticket/19031





---

archive/issue_comments_256625.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2015-08-14T12:29:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256625",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_256626.json:
```json
{
    "body": "Changing keywords from \"\" to \"Closeness Centrality, top-k\".",
    "created_at": "2015-08-14T12:29:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256626",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing keywords from "" to "Closeness Centrality, top-k".



---

archive/issue_comments_256627.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to graph theory.",
    "created_at": "2015-08-14T12:29:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256627",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing component from PLEASE CHANGE to graph theory.



---

archive/issue_comments_256628.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-08-17T16:37:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256628",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_256629.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-08-17T16:40:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256629",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_256630.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-08-17T16:42:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256630",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_256631.json:
```json
{
    "body": "Hello!\n\nThis is the first draft of this new closeness centrality algorithm. It is able to conclude in reasonable time even on very big graphs, with millions of nodes and billions of edges. The new algorithm is in the last commit (while all previous commits simply merge with dependent tickets).\n\nSee you,\n\nMichele",
    "created_at": "2015-08-17T16:42:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256631",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Hello!

This is the first draft of this new closeness centrality algorithm. It is able to conclude in reasonable time even on very big graphs, with millions of nodes and billions of edges. The new algorithm is in the last commit (while all previous commits simply merge with dependent tickets).

See you,

Michele



---

archive/issue_comments_256632.json:
```json
{
    "body": "A first round of comments.\n\nIn method `_estimate_reachable_vertices_dir`\n- `The lower bound is stored in reachableL[v]` -> `The lower bound is stored in reachL[v]`\n- Although the method will not be tested, could you please add an `INPUT` section specifying the type and expected size of arrays. You could also briefly document the algorithm implemented in the method.\n- please improve the presentation of the block with all variable declarations. It is hard to read since it constains lots of important calls to various methods. For instance avoid `cdef int i, nscc = tarjan_strongly_connected_components_C`and prefer `cdef int nscc = tarjan_strongly_connected_components_C`\n- What's the need for using type `uint64_t` instead of `int`? the corresponding variables are later cast to `int`.\n- You could use `maxscc = max(scc_sizes[i] for i in range(nscc)`\n\nFor method `_compute_reachable_vertices_undir`, you should add some documentation at the beginning of the method.\n\nMethod counting sort: no comment, but in the future we should certainly create a method somewhere.\n\nIn method `def centrality_closeness_top_k(G, int k=1, int verb=0)`\n- `verb` -> `verbose`\n- the tests for the validity of the results are excessive. There is no need for the loop `range(1000)`. Testing for *one* randomly chosen graph with say `n=20` nodes and `random.randint(1, n*(n-1) / 2)` edges is sufficient.\n- we can do that `for x in sorted_vert[:n]:` when `sorted_vert` is an array of ints ???\n- `if directed: gamma = 0  else: gamma = 1 ` -> `gamma = 0 if directed else 1`\n- when `stopped == True` you don't quit the `for j in range(layer_current_beginning,layer_current_end):`. May be you should replace this loop with a while.\n- you set `gamma = 0`. So you need `gamma==1` only once for undirected graphs. Correct?\n\nDavid.",
    "created_at": "2015-08-18T12:16:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256632",
    "user": "https://github.com/dcoudert"
}
```

A first round of comments.

In method `_estimate_reachable_vertices_dir`
- `The lower bound is stored in reachableL[v]` -> `The lower bound is stored in reachL[v]`
- Although the method will not be tested, could you please add an `INPUT` section specifying the type and expected size of arrays. You could also briefly document the algorithm implemented in the method.
- please improve the presentation of the block with all variable declarations. It is hard to read since it constains lots of important calls to various methods. For instance avoid `cdef int i, nscc = tarjan_strongly_connected_components_C`and prefer `cdef int nscc = tarjan_strongly_connected_components_C`
- What's the need for using type `uint64_t` instead of `int`? the corresponding variables are later cast to `int`.
- You could use `maxscc = max(scc_sizes[i] for i in range(nscc)`

For method `_compute_reachable_vertices_undir`, you should add some documentation at the beginning of the method.

Method counting sort: no comment, but in the future we should certainly create a method somewhere.

In method `def centrality_closeness_top_k(G, int k=1, int verb=0)`
- `verb` -> `verbose`
- the tests for the validity of the results are excessive. There is no need for the loop `range(1000)`. Testing for *one* randomly chosen graph with say `n=20` nodes and `random.randint(1, n*(n-1) / 2)` edges is sufficient.
- we can do that `for x in sorted_vert[:n]:` when `sorted_vert` is an array of ints ???
- `if directed: gamma = 0  else: gamma = 1 ` -> `gamma = 0 if directed else 1`
- when `stopped == True` you don't quit the `for j in range(layer_current_beginning,layer_current_end):`. May be you should replace this loop with a while.
- you set `gamma = 0`. So you need `gamma==1` only once for undirected graphs. Correct?

David.



---

archive/issue_comments_256633.json:
```json
{
    "body": "Replying to [comment:6 dcoudert]:\n\n> A first round of comments.\n> \n> In method `_estimate_reachable_vertices_dir`\n> - `The lower bound is stored in reachableL[v]` -> `The lower bound is stored in reachL[v]`\n\nDone!\n\n> - Although the method will not be tested, could you please add an `INPUT` section specifying the type and expected size of arrays. You could also briefly document the algorithm implemented in the method.\n\nDone!\n\n> - please improve the presentation of the block with all variable declarations. It is hard to read since it constains lots of important calls to various methods. For instance avoid `cdef int i, nscc = tarjan_strongly_connected_components_C`and prefer `cdef int nscc = tarjan_strongly_connected_components_C`\n\nDone!\n\n> - What's the need for using type `uint64_t` instead of `int`? the corresponding variables are later cast to `int`.\n\nWell, it's a bit tricky. The point is that in the recursion for `reachU_scc` I might find values that are much bigger than `g.n`. Since I did not want to test at each step if this occurs, I used `uint64_t` in order to avoid overflow (these values are smaller than `g.n^2`). Then, only at the end, I use min (so that now the values do not overflow), and I set `reachU[i] = <int> min(reachU_scc[scc[i]], g.n)`. However, you are right with `reachL`, and I modified it.\n\n> - You could use `maxscc = max(scc_sizes[i] for i in range(nscc)`\n\nI don't think so, `maxscc` is not the maximum size of a SCC, but it is the SCC with maximum size. In other words, your instruction outputs `scc_sizes[maxscc]`, not `maxscc`. Am I missing something?\n\n> For method `_compute_reachable_vertices_undir`, you should add some documentation at the beginning of the method.\n\nDone\n\n> Method counting sort: no comment, but in the future we should certainly create a method somewhere.\n\nAgree!\n\n> In method `def centrality_closeness_top_k(G, int k=1, int verb=0)`\n> - `verb` -> `verbose`\n\nDone!\n\n> - the tests for the validity of the results are excessive. There is no need for the loop `range(1000)`. Testing for *one* randomly chosen graph with say `n=20` nodes and `random.randint(1, n*(n-1) / 2)` edges is sufficient.\n\nDone! I left it because I had to test it 100,000 times to find the last bug...\n\n> - we can do that `for x in sorted_vert[:n]:` when `sorted_vert` is an array of ints ???\n\nYep: !http://docs.cython.org/src/reference/language_basics.html\n\n> - `if directed: gamma = 0  else: gamma = 1 ` -> `gamma = 0 if directed else 1`\n\nDone!\n\n> - when `stopped == True` you don't quit the `for j in range(layer_current_beginning,layer_current_end):`. May be you should replace this loop with a while.\n\nI added an 'if' at the end of the loop.\n\n> - you set `gamma = 0`. So you need `gamma==1` only once for undirected graphs. Correct?\n\nHmm, correct, but I realized that I could do a little better by slightly changing the implementation. So this does not apply anymore.",
    "created_at": "2015-08-18T15:46:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256633",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Replying to [comment:6 dcoudert]:

> A first round of comments.
> 
> In method `_estimate_reachable_vertices_dir`
> - `The lower bound is stored in reachableL[v]` -> `The lower bound is stored in reachL[v]`

Done!

> - Although the method will not be tested, could you please add an `INPUT` section specifying the type and expected size of arrays. You could also briefly document the algorithm implemented in the method.

Done!

> - please improve the presentation of the block with all variable declarations. It is hard to read since it constains lots of important calls to various methods. For instance avoid `cdef int i, nscc = tarjan_strongly_connected_components_C`and prefer `cdef int nscc = tarjan_strongly_connected_components_C`

Done!

> - What's the need for using type `uint64_t` instead of `int`? the corresponding variables are later cast to `int`.

Well, it's a bit tricky. The point is that in the recursion for `reachU_scc` I might find values that are much bigger than `g.n`. Since I did not want to test at each step if this occurs, I used `uint64_t` in order to avoid overflow (these values are smaller than `g.n^2`). Then, only at the end, I use min (so that now the values do not overflow), and I set `reachU[i] = <int> min(reachU_scc[scc[i]], g.n)`. However, you are right with `reachL`, and I modified it.

> - You could use `maxscc = max(scc_sizes[i] for i in range(nscc)`

I don't think so, `maxscc` is not the maximum size of a SCC, but it is the SCC with maximum size. In other words, your instruction outputs `scc_sizes[maxscc]`, not `maxscc`. Am I missing something?

> For method `_compute_reachable_vertices_undir`, you should add some documentation at the beginning of the method.

Done

> Method counting sort: no comment, but in the future we should certainly create a method somewhere.

Agree!

> In method `def centrality_closeness_top_k(G, int k=1, int verb=0)`
> - `verb` -> `verbose`

Done!

> - the tests for the validity of the results are excessive. There is no need for the loop `range(1000)`. Testing for *one* randomly chosen graph with say `n=20` nodes and `random.randint(1, n*(n-1) / 2)` edges is sufficient.

Done! I left it because I had to test it 100,000 times to find the last bug...

> - we can do that `for x in sorted_vert[:n]:` when `sorted_vert` is an array of ints ???

Yep: !http://docs.cython.org/src/reference/language_basics.html

> - `if directed: gamma = 0  else: gamma = 1 ` -> `gamma = 0 if directed else 1`

Done!

> - when `stopped == True` you don't quit the `for j in range(layer_current_beginning,layer_current_end):`. May be you should replace this loop with a while.

I added an 'if' at the end of the loop.

> - you set `gamma = 0`. So you need `gamma==1` only once for undirected graphs. Correct?

Hmm, correct, but I realized that I could do a little better by slightly changing the implementation. So this does not apply anymore.



---

archive/issue_comments_256634.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-18T15:48:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256634",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256635.json:
```json
{
    "body": "> > - What's the need for using type `uint64_t` instead of `int`? the corresponding variables are later cast to `int`.\n> \n> Well, it's a bit tricky. The point is that in the recursion for `reachU_scc` I might find values that are much bigger than `g.n`. Since I did not want to test at each step if this occurs, I used `uint64_t` in order to avoid overflow (these values are smaller than `g.n^2`). Then, only at the end, I use min (so that now the values do not overflow), and I set `reachU[i] = <int> min(reachU_scc[scc[i]], g.n)`. However, you are right with `reachL`, and I modified it.\nIs it mentioned somewhere?\n  \n> > - You could use `maxscc = max(scc_sizes[i] for i in range(nscc)`\n> \n> I don't think so, `maxscc` is not the maximum size of a SCC, but it is the SCC with maximum size. In other words, your instruction outputs `scc_sizes[maxscc]`, not `maxscc`. Am I missing something?\nRight, it should be `maxscc = max((scc_sizes[i],i) for i in range(nscc))[1]`, but this is ugly.\n  \n> > - the tests for the validity of the results are excessive. There is no need for the loop `range(1000)`. Testing for *one* randomly chosen graph with say `n=20` nodes and `random.randint(1, n*(n-1) / 2)` edges is sufficient.\n> \n> Done! I left it because I had to test it 100,000 times to find the last bug...\nThat's a lot!\nHowever, I don't like the `n = random.randint(2,20)`. You could safely let `n=20`, no?\n  \n> > - we can do that `for x in sorted_vert[:n]:` when `sorted_vert` is an array of ints ???\n> \n> Yep: !http://docs.cython.org/src/reference/language_basics.html\nThat's funny.\n \nCan we always assume that `farness[v]>0`? This is for the `return sorted([(1.0/farness[v],...`. \n\nInstead of `G.vertices()[v]`, you should add a line like `cdef list V = G.vertices()` before the return statement and then use `V[v]`. \n\n\nAbout the behavior when `k>=n`. What you propose is in fact to return the centrality closeness (as a list of couples (centrality,vertex) ). \n- Is your method faster than `centrality_closeness` in this case?\n- This behavior should be documented for the parameter `k`\n\nThat's all for now ;)\n\nDavid.",
    "created_at": "2015-08-18T16:57:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256635",
    "user": "https://github.com/dcoudert"
}
```

> > - What's the need for using type `uint64_t` instead of `int`? the corresponding variables are later cast to `int`.
> 
> Well, it's a bit tricky. The point is that in the recursion for `reachU_scc` I might find values that are much bigger than `g.n`. Since I did not want to test at each step if this occurs, I used `uint64_t` in order to avoid overflow (these values are smaller than `g.n^2`). Then, only at the end, I use min (so that now the values do not overflow), and I set `reachU[i] = <int> min(reachU_scc[scc[i]], g.n)`. However, you are right with `reachL`, and I modified it.
Is it mentioned somewhere?
  
> > - You could use `maxscc = max(scc_sizes[i] for i in range(nscc)`
> 
> I don't think so, `maxscc` is not the maximum size of a SCC, but it is the SCC with maximum size. In other words, your instruction outputs `scc_sizes[maxscc]`, not `maxscc`. Am I missing something?
Right, it should be `maxscc = max((scc_sizes[i],i) for i in range(nscc))[1]`, but this is ugly.
  
> > - the tests for the validity of the results are excessive. There is no need for the loop `range(1000)`. Testing for *one* randomly chosen graph with say `n=20` nodes and `random.randint(1, n*(n-1) / 2)` edges is sufficient.
> 
> Done! I left it because I had to test it 100,000 times to find the last bug...
That's a lot!
However, I don't like the `n = random.randint(2,20)`. You could safely let `n=20`, no?
  
> > - we can do that `for x in sorted_vert[:n]:` when `sorted_vert` is an array of ints ???
> 
> Yep: !http://docs.cython.org/src/reference/language_basics.html
That's funny.
 
Can we always assume that `farness[v]>0`? This is for the `return sorted([(1.0/farness[v],...`. 

Instead of `G.vertices()[v]`, you should add a line like `cdef list V = G.vertices()` before the return statement and then use `V[v]`. 


About the behavior when `k>=n`. What you propose is in fact to return the centrality closeness (as a list of couples (centrality,vertex) ). 
- Is your method faster than `centrality_closeness` in this case?
- This behavior should be documented for the parameter `k`

That's all for now ;)

David.



---

archive/issue_comments_256636.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-19T09:26:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256636",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256637.json:
```json
{
    "body": "> > > - What's the need for using type `uint64_t` instead of `int`? the corresponding variables are later cast to `int`.\n> > > \n> > > \n> > > \n> > > \n> > \n> > Well, it's a bit tricky. The point is that in the recursion for `reachU_scc` I might find values that are much bigger than `g.n`. Since I did not want to test at each step if this occurs, I used `uint64_t` in order to avoid overflow (these values are smaller than `g.n^2`). Then, only at the end, I use min (so that now the values do not overflow), and I set `reachU[i] = <int> min(reachU_scc[scc[i]], g.n)`. However, you are right with `reachL`, and I modified it.\n> > \n> > \n> > \n> > \n> Is it mentioned somewhere?\n> \n\nI added two inline comments to explain it.\n\n> > > - the tests for the validity of the results are excessive. There is no need for the loop `range(1000)`. Testing for *one* randomly chosen graph with say `n=20` nodes and `random.randint(1, n*(n-1) / 2)` edges is sufficient.\n> > > \n> > > \n> > > \n> > > \n> > \n> > Done! I left it because I had to test it 100,000 times to find the last bug...\n> > \n> > \n> > \n> > \n> That's a lot!\n> However, I don't like the `n = random.randint(2,20)`. You could safely let `n=20`, no?\n\nDone!\n\n> Can we always assume that farness[v]>0? This is for the return sorted([(1.0/farness[v],....\n\nYep.\n\nThe only instructions that modify the farness are `farness[x] = n` (if a visit is stopped) and `farness[x] = ((<double> f) * (n-1)) / (<double>(nd-1) * (nd-1))`, where `f` is a (positive) sum of distances, `nd-1` is positive because `nd` is the number of reachable vertices from a vertex `x`. If `nd==1`, it means that the out-degree of `x` is 0, and we skip the analysis of `x`, so this case never occurs. Then, `n>=nd`, and hence also `n-1` is positive.\n\n> Instead of `G.vertices()[v]`, you should add a line like `cdef list V = G.vertices()` before the return statement and then use `V[v]`.\n\nDone!\n\n> About the behavior when `k>=n`. What you propose is in fact to return the centrality closeness (as a list of couples (centrality,vertex) ). \n> - Is your method faster than `centrality_closeness` in this case?\n\nNo, it should be the same (actually, a bit slower because we make some computations during the BFSes).\n\n> - This behavior should be documented for the parameter `k`\n\nDone!",
    "created_at": "2015-08-19T09:37:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256637",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

> > > - What's the need for using type `uint64_t` instead of `int`? the corresponding variables are later cast to `int`.
> > > 
> > > 
> > > 
> > > 
> > 
> > Well, it's a bit tricky. The point is that in the recursion for `reachU_scc` I might find values that are much bigger than `g.n`. Since I did not want to test at each step if this occurs, I used `uint64_t` in order to avoid overflow (these values are smaller than `g.n^2`). Then, only at the end, I use min (so that now the values do not overflow), and I set `reachU[i] = <int> min(reachU_scc[scc[i]], g.n)`. However, you are right with `reachL`, and I modified it.
> > 
> > 
> > 
> > 
> Is it mentioned somewhere?
> 

I added two inline comments to explain it.

> > > - the tests for the validity of the results are excessive. There is no need for the loop `range(1000)`. Testing for *one* randomly chosen graph with say `n=20` nodes and `random.randint(1, n*(n-1) / 2)` edges is sufficient.
> > > 
> > > 
> > > 
> > > 
> > 
> > Done! I left it because I had to test it 100,000 times to find the last bug...
> > 
> > 
> > 
> > 
> That's a lot!
> However, I don't like the `n = random.randint(2,20)`. You could safely let `n=20`, no?

Done!

> Can we always assume that farness[v]>0? This is for the return sorted([(1.0/farness[v],....

Yep.

The only instructions that modify the farness are `farness[x] = n` (if a visit is stopped) and `farness[x] = ((<double> f) * (n-1)) / (<double>(nd-1) * (nd-1))`, where `f` is a (positive) sum of distances, `nd-1` is positive because `nd` is the number of reachable vertices from a vertex `x`. If `nd==1`, it means that the out-degree of `x` is 0, and we skip the analysis of `x`, so this case never occurs. Then, `n>=nd`, and hence also `n-1` is positive.

> Instead of `G.vertices()[v]`, you should add a line like `cdef list V = G.vertices()` before the return statement and then use `V[v]`.

Done!

> About the behavior when `k>=n`. What you propose is in fact to return the centrality closeness (as a list of couples (centrality,vertex) ). 
> - Is your method faster than `centrality_closeness` in this case?

No, it should be the same (actually, a bit slower because we make some computations during the BFSes).

> - This behavior should be documented for the parameter `k`

Done!



---

archive/issue_comments_256638.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-19T09:43:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256638",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256639.json:
```json
{
    "body": "> > About the behavior when `k>=n`. What you propose is in fact to return the centrality closeness (as a list of couples (centrality,vertex) ). \n> > - Is your method faster than `centrality_closeness` in this case?\n> \n> No, it should be the same (actually, a bit slower because we make some computations during the BFSes).\nSo you should add a test `if k>=n` at the beginning of the method and if True call the other method and format the result. You could also add a test `n==0` and/or `n==1` where the result is obvious.",
    "created_at": "2015-08-19T11:29:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256639",
    "user": "https://github.com/dcoudert"
}
```

> > About the behavior when `k>=n`. What you propose is in fact to return the centrality closeness (as a list of couples (centrality,vertex) ). 
> > - Is your method faster than `centrality_closeness` in this case?
> 
> No, it should be the same (actually, a bit slower because we make some computations during the BFSes).
So you should add a test `if k>=n` at the beginning of the method and if True call the other method and format the result. You could also add a test `n==0` and/or `n==1` where the result is obvious.



---

archive/issue_comments_256640.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:",
    "created_at": "2015-08-19T13:43:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256640",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:



---

archive/issue_comments_256641.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-19T14:09:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256641",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256642.json:
```json
{
    "body": "Helloooooooo!\n\nAfter we moved `centrality_closeness` back to `generic_graph`, I had to rebase this ticket. The new algorithm is still in file `centrality.pyx`, but it is not available in `generic_graph` (that is, `g.centrality_closeness_top_k()` does not work anymore). However, I don't think this is a serious issue, because this algorithm in used in very specialized cases, and the standard Sage user does not need it, in my opinion.\n\nCheers,\n\nMichele",
    "created_at": "2015-08-19T14:12:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256642",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Helloooooooo!

After we moved `centrality_closeness` back to `generic_graph`, I had to rebase this ticket. The new algorithm is still in file `centrality.pyx`, but it is not available in `generic_graph` (that is, `g.centrality_closeness_top_k()` does not work anymore). However, I don't think this is a serious issue, because this algorithm in used in very specialized cases, and the standard Sage user does not need it, in my opinion.

Cheers,

Michele



---

archive/issue_comments_256643.json:
```json
{
    "body": "Is not such a big deal to do\n\n```\nsage: from sage.graphs.centrality import centrality_closeness_top_k\nsage: centrality_closeness_top_k(graphs.PetersenGraph(), 3)\n[(0.6, 2), (0.6, 1), (0.6, 0)]\n```\n\nand it's documented. Other methods such as hyperbolicity, pathwidth, etc. must be imported for similar reasons. As soon as we will find a reasonable solution for lazy import, we may add it in another ticket.\n\nI set this patch to positive review.\n\nDavid.",
    "created_at": "2015-08-20T06:41:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256643",
    "user": "https://github.com/dcoudert"
}
```

Is not such a big deal to do

```
sage: from sage.graphs.centrality import centrality_closeness_top_k
sage: centrality_closeness_top_k(graphs.PetersenGraph(), 3)
[(0.6, 2), (0.6, 1), (0.6, 0)]
```

and it's documented. Other methods such as hyperbolicity, pathwidth, etc. must be imported for similar reasons. As soon as we will find a reasonable solution for lazy import, we may add it in another ticket.

I set this patch to positive review.

David.



---

archive/issue_comments_256644.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-08-20T06:41:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256644",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_256645.json:
```json
{
    "body": "On 32-bit Linux:\n\n```\nsage -t --long src/sage/graphs/centrality.pyx\n**********************************************************************\nFile \"src/sage/graphs/centrality.pyx\", line 588, in sage.graphs.centrality.centrality_closeness_top_k\nFailed example:\n    centrality_closeness_top_k(g, 5, 1)\nExpected:\n    Final performance ratio: 0.766666666667\n    [(0.36, 5),\n     (0.36, 4),\n     (0.3333333333333333, 6),\n     (0.3333333333333333, 3),\n     (0.29032258064516125, 2)]\nGot:\n    Final performance ratio: 0.805555555556\n    [(0.36, 5),\n     (0.36, 4),\n     (0.3333333333333333, 6),\n     (0.3333333333333333, 3),\n     (0.29032258064516125, 7)]\n**********************************************************************\n1 item had failures:\n   1 of  40 in sage.graphs.centrality.centrality_closeness_top_k\n    [51 tests, 1 failure, 0.16 s]\n```\n",
    "created_at": "2015-08-20T17:01:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256645",
    "user": "https://github.com/vbraun"
}
```

On 32-bit Linux:

```
sage -t --long src/sage/graphs/centrality.pyx
**********************************************************************
File "src/sage/graphs/centrality.pyx", line 588, in sage.graphs.centrality.centrality_closeness_top_k
Failed example:
    centrality_closeness_top_k(g, 5, 1)
Expected:
    Final performance ratio: 0.766666666667
    [(0.36, 5),
     (0.36, 4),
     (0.3333333333333333, 6),
     (0.3333333333333333, 3),
     (0.29032258064516125, 2)]
Got:
    Final performance ratio: 0.805555555556
    [(0.36, 5),
     (0.36, 4),
     (0.3333333333333333, 6),
     (0.3333333333333333, 3),
     (0.29032258064516125, 7)]
**********************************************************************
1 item had failures:
   1 of  40 in sage.graphs.centrality.centrality_closeness_top_k
    [51 tests, 1 failure, 0.16 s]
```




---

archive/issue_comments_256646.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2015-08-20T17:01:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256646",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_256647.json:
```json
{
    "body": "Michele,\n\nin this tests, nodes 2 and 7 are both correct answers since we have:\n- on a 64bit machine (i.e. my laptop)\n\n```\nsage: from sage.graphs.centrality import centrality_closeness_top_k\nsage: g = graphs.PathGraph(10)\nsage: centrality_closeness_top_k(g, 5, 1)\nFinal performance ratio: 0.766666666667\n[(0.36, 5),\n (0.36, 4),\n (0.3333333333333333, 6),\n (0.3333333333333333, 3),\n (0.29032258064516125, 2)]\nsage: g.centrality_closeness()\n{0: 0.2,\n 1: 0.24324324324324326,\n 2: 0.2903225806451613,\n 3: 0.3333333333333333,\n 4: 0.36,\n 5: 0.36,\n 6: 0.3333333333333333,\n 7: 0.2903225806451613,\n 8: 0.24324324324324326,\n 9: 0.2}\n```\n\n- on a 32 bits computer (old desktop)\n\n```\nsage: from sage.graphs.centrality import centrality_closeness_top_k\nsage: g = graphs.PathGraph(10)\nsage: centrality_closeness_top_k(g, 5, 1)\nFinal performance ratio: 0.805555555556\n[(0.36, 5),\n (0.36, 4),\n (0.3333333333333333, 6),\n (0.3333333333333333, 3),\n (0.29032258064516125, 7)]\nsage: g.centrality_closeness()\n{0: 0.2,\n 1: 0.24324324324324326,\n 2: 0.2903225806451613,\n 3: 0.3333333333333333,\n 4: 0.36,\n 5: 0.36,\n 6: 0.3333333333333333,\n 7: 0.2903225806451613,\n 8: 0.24324324324324326,\n 9: 0.2}\n```\n\nThe good point is that the numbers are the same on both machines ;)\n\nOne part of the solution is to call `centrality_closeness_top_k(g, 4, 1)`.\n\nHowever, for the performance ratio it is more difficult.\nIn fact, we have `visited=138` on my mac, and `visited=145` on the 32 bits computer. So we have to understand what could change the number of visited nodes depending on 32-64 bits.\n\nDavid.",
    "created_at": "2015-08-20T22:40:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256647",
    "user": "https://github.com/dcoudert"
}
```

Michele,

in this tests, nodes 2 and 7 are both correct answers since we have:
- on a 64bit machine (i.e. my laptop)

```
sage: from sage.graphs.centrality import centrality_closeness_top_k
sage: g = graphs.PathGraph(10)
sage: centrality_closeness_top_k(g, 5, 1)
Final performance ratio: 0.766666666667
[(0.36, 5),
 (0.36, 4),
 (0.3333333333333333, 6),
 (0.3333333333333333, 3),
 (0.29032258064516125, 2)]
sage: g.centrality_closeness()
{0: 0.2,
 1: 0.24324324324324326,
 2: 0.2903225806451613,
 3: 0.3333333333333333,
 4: 0.36,
 5: 0.36,
 6: 0.3333333333333333,
 7: 0.2903225806451613,
 8: 0.24324324324324326,
 9: 0.2}
```

- on a 32 bits computer (old desktop)

```
sage: from sage.graphs.centrality import centrality_closeness_top_k
sage: g = graphs.PathGraph(10)
sage: centrality_closeness_top_k(g, 5, 1)
Final performance ratio: 0.805555555556
[(0.36, 5),
 (0.36, 4),
 (0.3333333333333333, 6),
 (0.3333333333333333, 3),
 (0.29032258064516125, 7)]
sage: g.centrality_closeness()
{0: 0.2,
 1: 0.24324324324324326,
 2: 0.2903225806451613,
 3: 0.3333333333333333,
 4: 0.36,
 5: 0.36,
 6: 0.3333333333333333,
 7: 0.2903225806451613,
 8: 0.24324324324324326,
 9: 0.2}
```

The good point is that the numbers are the same on both machines ;)

One part of the solution is to call `centrality_closeness_top_k(g, 4, 1)`.

However, for the performance ratio it is more difficult.
In fact, we have `visited=138` on my mac, and `visited=145` on the 32 bits computer. So we have to understand what could change the number of visited nodes depending on 32-64 bits.

David.



---

archive/issue_comments_256648.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-21T19:01:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256648",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256649.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-21T20:01:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256649",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256650.json:
```json
{
    "body": "Hello!\n\nI have installed Sage on a 32bit Virtual Machine: the problem was a comparison between (equal) doubles, and probably due to roundings the error popped out. Indeed, both results were correct. \n\nBy asking only top-4 in the doctest, we avoid such comparisons, and everything works.\n\nThank you very much!\n\nMichele",
    "created_at": "2015-08-21T20:04:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256650",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Hello!

I have installed Sage on a 32bit Virtual Machine: the problem was a comparison between (equal) doubles, and probably due to roundings the error popped out. Indeed, both results were correct. 

By asking only top-4 in the doctest, we avoid such comparisons, and everything works.

Thank you very much!

Michele



---

archive/issue_comments_256651.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-08-21T20:05:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256651",
    "user": "https://trac.sagemath.org/admin/accounts/users/borassi"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_256652.json:
```json
{
    "body": "The patch passes all tests on both my mac (64bits) and a 32bits linux PC.\nFor me the patch is ok, but is is certainly better to rebase on 9.3.\nDavid.",
    "created_at": "2015-08-21T20:27:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256652",
    "user": "https://github.com/dcoudert"
}
```

The patch passes all tests on both my mac (64bits) and a 32bits linux PC.
For me the patch is ok, but is is certainly better to rebase on 9.3.
David.



---

archive/issue_comments_256653.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-08-22T17:11:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256653",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_256654.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-08-22T17:22:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256654",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_256655.json:
```json
{
    "body": "Thanks.",
    "created_at": "2015-08-22T17:22:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256655",
    "user": "https://github.com/dcoudert"
}
```

Thanks.



---

archive/issue_comments_256656.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-08-23T23:31:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18794",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18794#issuecomment-256656",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
