# Issue 15638: Add is_subposet

Issue created by migration from Trac.

Original creator: csar

Original creation time: 2014-02-27 19:40:51

CC:  kdilks ncohen tscrim

Add is_subposet method to Posets to check if a subposet is an (induced) subposet of another.


---

Comment by csar created at 2014-03-03 15:47:55

I'm not positive this works. I think I've stumbled across an example where you have equality of the results of `hasse_diagram()`, but not of `_hasse_diagram`.


---

Comment by jmantysalo created at 2014-10-02 18:45:58

You don't have to say `Poset(DiGraph({1:[2,3],2:[4],3:[4]}))`, just `Poset({1:[2,3],2:[4],3:[4]})`.

See also #16892, it relates to this one. I think that you can look the code of it for you.


---

Comment by jmantysalo created at 2015-07-28 06:26:34

How are other "containing"-functions made? For a poset `A` to be a subposet of `B` it should be that for every cover relation `u, v` in `A` there is `u' < v'` in B, where `u == u'` (and `v == v'`). How to define `==`, for example if `u` is `int(42)`and `u'` is `Integer(42)`?


---

Comment by jmantysalo created at 2015-08-09 06:37:42

At least


```
g1 = DiGraph({13:[14]})
g2 = DiGraph({13r:[14r]})
g1.is_subgraph(g2), g2.is_subgraph(g1)
```


outputs `(True, True)`. Is there examples of `sub*` function with different behaviour? If not, then also `is_subposet()` should be like `is_subgraph()`. CC to ncohen for this question.


---

Comment by ncohen created at 2015-08-09 07:02:45

Since a long time, graphs have been converting all 'integer' labels into 'int'. That was long before I came. I expect that the reason is that you "pay for labels" when you deal with graphs, and that was probably a way to avoid that.


---

Comment by jmantysalo created at 2015-08-09 07:36:05

Replying to [comment:9 ncohen]:
> Since a long time, graphs have been converting all 'integer' labels into 'int'. That was long before I came. I expect that the reason is that you "pay for labels" when you deal with graphs, and that was probably a way to avoid that.

This was an answer to different question... (on sage-devel). To clarify, here is another example of `is_sub*`-function:


```
r1=2.0-1.0
r2=3.0-1.0
i1=1
i2=2
{i1, i2}.issubset({r1, r2})
```


This also outputs `True`. Hence it seems that `Poset({r1:[r2]}).is_subposet(Poset({i1:[i2]}))` should also return `True`. But I would like someone to confirm this.


---

Comment by ncohen created at 2015-08-09 07:41:50

That would be because `Integer(5) == int(5)` returns True, then. Would you expect them to be handled any differently by posets?


---

Comment by jmantysalo created at 2015-08-10 09:21:09

Replying to [comment:11 ncohen]:
> That would be because `Integer(5) == int(5)` returns True, then. Would you expect them to be handled any differently by posets?

Well, no. So, in principle `P.is_subposet(Q)` can be implemented like `set([frozenset(x) for x in P.relations()]).issubset(set([frozenset(x) for x in Q.relations()]))`. Or course there is better ways to do it in reality.

Is there any graph function already to wrap for this? Something about reachability in digraphs?


---

Comment by ncohen created at 2015-08-10 09:53:12

> Is there any graph function already to wrap for this? Something about reachability in digraphs?

Hmmmm... I don't think so. If there was, you could probably expect the Poset (Directed Acyclic Graph) case to be much faster to solve, so it's really Poset code in the end.

Nathann


---

Comment by jmantysalo created at 2015-08-10 20:22:16

Would implementing `P.is_subposet(Q)` as `P.hasse_diagram().is_subgraph(Q.hasse_diagram().transitive_closure())` be too slow? I am not sure if I can make faster version by manually calling digraph functions in a loop. But of course it is much faster to get `False` if some element of `P` is not an element of `Q` at all by first checking for that. But will `transitive_closure())` eat memory?


---

Comment by ncohen created at 2015-08-10 20:35:00

Replying to [comment:14 jmantysalo]:
> Would implementing `P.is_subposet(Q)` as `P.hasse_diagram().is_subgraph(Q.hasse_diagram().transitive_closure())` be too slow?

"depends". It means a copy of Q's graph even if `P` is only one vertex. In other cases it will be optimal.

> I am not sure if I can make faster version by manually calling digraph functions in a loop. But of course it is much faster to get `False` if some element of `P` is not an element of `Q` at all by first checking for that. But will `transitive_closure())` eat memory?

It will eat some memory indeed, but it will be freed then. Ideally, we would need a dense representation for Q's transitive closure and a sparse representation of P. We can iterate over all edges of `P`, and check every time that it is an edge of Q's transitive closure.

The most costly part of it will probably be the vertex labelling.

Nathann


---

Comment by jmantysalo created at 2015-08-11 06:46:19

Changing status from new to needs_review.


---

Comment by jmantysalo created at 2015-08-11 06:46:19

Done this as an oneline-wrapper. I think that faster versions are easier to do when we already have a docstring and maybe see how this will be used.

This is intentionally left out from index of functions, as I am still waiting for #18534 to get accepted (or rejected).
----
New commits:


---

Comment by jmantysalo created at 2015-08-11 06:46:19

Changing priority from minor to major.


---

Comment by jmantysalo created at 2015-08-11 06:46:19

Changing keywords from "" to "posets".


---

Comment by jmantysalo created at 2015-08-27 05:26:26

Travis, what you think about this one-line-wrapper?

I am asking this because of `is_sublattice()`. If this gets accepted, I will make that behave like this one. (And, maybe, later will think about `isomorphic_sublattices_iterator()` etc.)


---

Comment by tscrim created at 2015-09-05 00:26:36

What about using the backend `_hasse_diagram` rather than the labeled `hasse_diagram()`?

(FYI - a one-line patch since "one" is pronounced most similar to "won".)


---

Comment by jmantysalo created at 2015-09-05 04:45:03

Replying to [comment:19 tscrim]:
> What about using the backend `_hasse_diagram` rather than the labeled `hasse_diagram()`?

Then `Poset({1:[2]})` would be a subposet of `Poset({2:[1]})`. This is not about isomorphic subposets.


---

Comment by tscrim created at 2015-09-05 15:40:09

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2015-09-05 15:40:09

However it is a subposet, but yes, up to isomorphism (which, IMO, is what most mathematicians care about; I think of `2+2` and `1+3` freeness). However my impression of the docstring was the difference between the methods was if the diamond is considered as a subposet inside 

```
     1
    / \
   2   3
  /     \
 4       5
  \     /
   6   7
    \ /
     8
```

I don't like the fact that `is_subposet`, which is likely to be the first encountered method for this type of behavior, is caring about the element labels. Even more so that there is not any part of the documentation which suggests that it looks at labels. So you need to rework the documentation.


---

Comment by jmantysalo created at 2015-09-05 16:55:09

Replying to [comment:21 tscrim]:

> I don't like the fact that `is_subposet`, which is likely to be the first encountered method for this type of behavior, is caring about the element labels. Even more so that there is not any part of the documentation which suggests that it looks at labels. So you need to rework the documentation.

?? There is a note-block that says just that, and it is direct copy from `is_subgraph()` in (generic) graphs.


---

Comment by tscrim created at 2015-09-06 18:46:46

This is not at all clear from the note-block (and the `is_subgraph` and "induced" in graph theory might carry a slightly different meaning than I'm used to when looking at posets). If this is to respect the labels (which I think will be unexpected behavior to the average user), you should explicitly state this and give examples comparing the two methods.


---

Comment by ncohen created at 2015-09-06 19:03:38

> This is not at all clear from the note-block

I cannot say that I agree with you, though there is a mistake in the note. The first sentence should be changed to: "This method does not check whether the poset is *isomorphic* to a subposet of ``other``, but only if [...]".

> (and the `is_subgraph` and "induced" in graph theory might carry a slightly different meaning than I'm used to when looking at posets)

The meaning is the same. Though this function should *not* check by default that it is an *induced* subposet. It should check whether it is a subposet, e.g.: the antichain is a subposet of any poset with the same elements.

Futhermore:


```
sage: A = posets.ChainPoset(5)
sage: A.is_subposet(A)
False
```


Nathann


---

Comment by jmantysalo created at 2015-09-06 20:02:44

Nathann, thanks for noticing my error. Of course the function must be `...is_subgraph(..., induced=True)`.

I think that `induced` means slightly different thing in graphs than in posets. Or that poset just is a different way to see DAG than looking it as a digraph.

Travis, you mean an `EXAMPLE` block with `has_isomorphic_subposet` shown for reference?


---

Comment by ncohen created at 2015-09-06 20:09:04

> I think that `induced` means slightly different thing in graphs than in posets. Or that poset just is a different way to see DAG than looking it as a digraph.

Perhaps. But to make sure that we agree on the meaning: A is an induced subposet of B if (the transitive closure of A) is an induced subgraph of (the transitive closure of B).


---

Comment by jmantysalo created at 2015-09-07 07:42:27

Travis, should it then be something like


```
Return ``True`` if the poset is a subposet of ``other``, and ``False`` otherwise.

A Poset `P` is an (induced) subposet of `Q` if every element of `P` is an element of `Q`,
and `x \le_P y` iff `x \le_Q y`.
```


? And then continue with `NOTE`-block and examples?


---

Comment by git created at 2015-09-08 14:47:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-08 14:53:18

I was stupid. This can not be done with one-line wrapper to some graph function. The Hasse diagram of `Poset({1:[2, 3]})` is a subgraph of transitive closure of the Hasse diagram of `Poset({1:[2, 4], 2:[3]})`.

I pushed one possible solution. (Later I must think how to make `subposet()` faster.)

But we have a question. Should `Poset({1:[2]})` be a subposet of `Poset({1:[2]}, facade=False)`?


---

Comment by tscrim created at 2015-09-08 15:15:53

The current docstring is much more clear than previously. Thank you. Could you also add something about the elements/labels to the `NOTE::` block too, something like `(i.e., up to relabeling)` after the `*isomorphic*` to further emphasize this?

You should add some more examples contrasting the two methods. In particular, one where the `subposet` returns `False` as the isomorphism one returns `True`. Also you have some `$` in the docstring.

I think because they are the same elements and because facade is more specific to use in Sage, we should have the subposet not depend on being a facade.


---

Comment by ncohen created at 2015-09-08 15:54:35

What you implemented is an *induced* subposet. In particular, a poset P from which you remove an edge is not a subposet of P anymore.

Nathann


---

Comment by ncohen created at 2015-09-08 15:56:49

> But we have a question. Should `Poset({1:[2]})` be a subposet of `Poset({1:[2]}, facade=False)`?

I love this facade thing.

```
sage: 1 in Poset({1:[2]},facade=False)
True
sage: 1 in list(Poset({1:[2]},facade=False))
False
```


As unreliable as it gets.

Nathann


---

Comment by jmantysalo created at 2015-09-08 15:58:26

Replying to [comment:31 ncohen]:
> What you implemented is an *induced* subposet. In particular, a poset P from which you remove an edge is not a subposet of P anymore.

True. But that is defined and documented. At least Enumerative Combinatoric p. 279 says "By a subposet of P, we will always mean an _induced_ subposet."


---

Comment by git created at 2015-09-08 15:59:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-09-08 16:03:10

> True. But that is defined and documented. At least Enumerative Combinatoric p. 279 says "By a subposet of P, we will always mean an _induced_ subposet."

Hmmm... Well, the first two papers I got by typing subposet in google say differently.
http://arxiv.org/pdf/1408.0899v5.pdf
http://arxiv.org/pdf/1106.2315v1.pdf

Actually, the third too (it even appears in the abstract)
http://www.combinatorics.org/ojs/index.php/eljc/article/download/v16i1r142/pdf

Now, well.. Sure Enumeratve Combinatorics is famous and stuff but well...

Honestly, I would make the mistake. Especially when the standard is different for graphs.

Nathann


---

Comment by jmantysalo created at 2015-09-08 16:04:21

Replying to [comment:30 tscrim]:

> The current docstring is much more clear than previously. Thank you. Could you also add something about the elements/labels to the `NOTE::` block too, something like `(i.e., up to relabeling)` after the `*isomorphic*` to further emphasize this?

Done.

> You should add some more examples contrasting the two methods. In particular, one where the `subposet` returns `False` as the isomorphism one returns `True`. Also you have some `$` in the docstring.

?? First example is already like that. `Q.has_isomorphic_subposet(P)` returns `True`. Removed `$`.

> I think because they are the same elements and because facade is more specific to use in Sage, we should have the subposet not depend on being a facade.

OK. This patch fixes it to other direction, but needs more work:


```
sage: P = Poset({1:[2]}, facade=True)
sage: Q = Poset({1:[2]}, facade=False)
sage: P.is_subposet(Q)
True
sage: Q.is_subposet(P)
 . . .
ValueError: <class 'sage.combinat.posets.elements.FinitePoset_with---
 . . .
```



---

Comment by jmantysalo created at 2015-09-08 16:06:07

Replying to [comment:35 ncohen]:

> Honestly, I would make the mistake. Especially when the standard is different for graphs.

OK. I'll try to clarify this.


---

Comment by jmantysalo created at 2015-09-08 16:16:34

Replying to [comment:32 ncohen]:

> I love this facade thing.
> {{{
> sage: 1 in Poset({1:[2]},facade=False)
> True
> sage: 1 in list(Poset({1:[2]},facade=False))
> False
> }}}

Uh... Should we open a ticket from this? I guess this it because `__contains__()`. But I have no idea about how to correct it. Basically this is because


```
P=Poset({1:[2]},facade=False)
1 in P, 1==P[0], 1==P[1]
```


--> `(True, False, False)`.


---

Comment by ncohen created at 2015-09-08 17:12:57

> Uh... Should we open a ticket from this? I guess this it because `__contains__()`. But I have no idea about how to correct it.

I suspect that they see it as a "feature". If you want to see it changed, you should probably ask on sage-devel first.

Nathann


---

Comment by git created at 2015-09-08 20:45:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-08 20:47:00

Replying to [comment:39 ncohen]:

> I suspect that they see it as a "feature".

OK. I'll forget that. Another thing: Why `Poset({1:[2]}).subposet([3])` gives error message "ValueError: <type 'sage.rings.integer.Integer'> is not an element of this poset"?

I made a blind commit, have no machine to test it just now. Going to continue tomorrow.
----
New commits:


---

Comment by git created at 2015-09-09 05:08:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-09 05:16:27

How about now? "Induced" is said more than once.


---

Comment by jmantysalo created at 2015-09-09 05:16:27

Changing status from needs_work to needs_review.


---

Comment by ncohen created at 2015-09-09 06:41:41

How exactly is the meaning of "induced" different of the meaning of "induced" for graphs?...


---

Comment by ncohen created at 2015-09-09 06:45:53

Hey nonononnoo why would you convert everything to facade? These non-facade posets are not something I would ever want to work with, but the reason for them is that these people want the elements to BELONG to this specific poset, and to be different from anything that does not belong to the same poset.

This may be a stupid idea but you should not go against it in this specific function. Either they are removed or they stay, but their specifications should be respected.


---

Comment by ncohen created at 2015-09-09 06:47:24


```
sage: P1 = Poset({1:[2]},facade=False)
sage: P2 = Poset({1:[]},facade=False)
sage: [x in P1 for x in P2]
[False]
```


So P2 should not be a subposet of P1.

Nathann


---

Comment by jmantysalo created at 2015-09-09 06:58:50

Changing status from needs_review to needs_info.


---

Comment by jmantysalo created at 2015-09-09 06:58:50

tscrim: "we should have the subposet not depend on being a facade", ncohen: "people want the elements to BELONG to this specific poset, and to be different from anything that does not belong to the same poset"  --> We need a third opinion, I guess.

Or should we raise something with facade posets? That way we would add functionality and the decision can be made later.


---

Comment by ncohen created at 2015-09-09 07:37:08

> tscrim: "we should have the subposet not depend on being a facade", ncohen: "people want the elements to BELONG to this specific poset, and to be different from anything that does not belong to the same poset"  --> We need a third opinion, I guess.

Ask on sage-devel. To me, what you are doing is this: the elements of a non-facade poset have a different `.__eq__` method (which makes them different when they belong to different posets), and by casting everything to facade you say that you want to use the *normal* notion of equality.

That is what the non-facade posets are defined *for*: so that the `.__eq__` of their elements has this property. If we workaround it, when is it gonna stop? Are we suppoed to write non-facade-specific code in each of the poset functions to avoid this senseless equality?

> Or should we raise something with facade posets?

To me it is very simple: do not write any non-facade-specific code, and let them deal with the consequences of this poor design, without forcing us to write additional code. On a personal level, if we have to deal with this hell every time we work on posets, I do not plan to touch its code again.

Nathann


---

Comment by git created at 2015-09-10 12:39:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-10 12:43:30

How about this? At least now this adds a new functionality to Sagemath, and it could be later expanded to non-facade posets.

Not in needs_review, as I am still compiling this myself.


---

Comment by ncohen created at 2015-09-10 12:58:48

What about naming it `.is_induced_subposet`? That would clear any doubt.


---

Comment by jmantysalo created at 2015-09-10 19:12:57

The tests were succesfull, so I guess this can be reviewed, apart from the naming issue:

Replying to [comment:51 ncohen]:
> What about naming it `.is_induced_subposet`? That would clear any doubt.

This is one possibility. I am just wondering about existing `is_subgraph()` and planned `is_sublattice()`; naming convention should be unified. Also this definition is logical in a sense that from `Q=P.subposet(...whatever...)` you will always get `Q.is_subset(P)` returning `True`.

The link ​http://www.combinatorics.org/ojs/index.php/eljc/article/download/v16i1r142/pdf seems to talk about isomorphic subposets.

Maybe we should write `.extensions()` and have `.is_weak_subposet()` be a poset that is induced subposet of some extension? That is the terminology used by _Enumerative Combinatorics_.

Travis, comments? At least I must think over a night about this.


---

Comment by git created at 2015-09-11 06:04:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-11 06:09:43

I asked from a professor, and he said that he would have guessed that this means weak subposet. Hence I changed the name.

I am not sure about right place for this in the index of functions. In any case, I wait #19113 to get reviewed (Travis? Simple one again.) before thinkig more about that.


---

Comment by jmantysalo created at 2015-09-11 06:09:43

Changing status from needs_info to needs_review.


---

Comment by jmantysalo created at 2015-09-11 06:15:49

But now


```
sage: P1 = Poset({1.5:[3]})
sage: P2 = Poset({1+1/2:[]})
sage: P3 = Poset({1.5:[]})
sage: P2.is_induced_subposet(P1), P3.is_induced_subposet(P1)
(False, True)
```


However, this is consistent with `==` operator on posets.


---

Comment by jmantysalo created at 2015-09-28 17:41:01

Ping...


---

Comment by ncohen created at 2015-09-28 18:44:15

Works for me, but weren't you waiting for #19113?


---

Comment by ncohen created at 2015-09-28 18:50:16

If you don't, then you can set it to `positive_review` on my behalf.

Nathann


---

Comment by jmantysalo created at 2015-09-28 19:10:08

Replying to [comment:57 ncohen]:
> Works for me, but weren't you waiting for #19113?

Sorry, I was very unclear. I meant that I will think about best place for the function after getting this and #19113 done.

Marked as positive review as you suggested on comment 58.


---

Comment by jmantysalo created at 2015-09-28 19:10:08

Changing status from needs_review to positive_review.


---

Comment by jmantysalo created at 2015-10-01 10:43:13

Does not work:


```
P = Poset({1:[2]})
Q1 = Poset({1:[]})
Q2 = LatticePoset({1:[]})
Q1.is_induced_subposet(P), Q2.is_induced_subposet(P)
```


outputs `(True, False)`.


---

Comment by jmantysalo created at 2015-10-01 10:43:13

Changing status from positive_review to needs_work.


---

Comment by git created at 2015-10-27 08:24:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-10-27 08:26:04

Changing status from needs_work to needs_review.


---

Comment by jmantysalo created at 2015-10-27 08:26:04

Resolved a conflict, made to work with lattices also. Should be OK now.


---

Comment by ncohen created at 2015-10-27 08:33:35

Hello Jori,

I do not understand the point of the line `if not hasattr(other, 'hasse_diagram'):`. Given that you call `subposet` and `.hasse_diagram` on `other` anyway your code will raise an exception whenever those methods are not available.

Nathann


---

Comment by git created at 2015-10-27 08:53:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-10-27 08:56:52

Replying to [comment:63 ncohen]:

> I do not understand the point of the line `if not hasattr(other, 'hasse_diagram'):`. Given that you call `subposet` and `.hasse_diagram` on `other` anyway your code will raise an exception whenever those methods are not available.

As you wish, changed that.

Now `P.is_induced_subposet('junk')` will say `AttributeError: 'str' object has no attribute '_is_facade'`. A slightly confusing to a user, but should not be that hard to track the error.

(Quite many Sage functions give strange errors from wrong input... At least this won't be first one.)


---

Comment by ncohen created at 2015-10-27 09:28:45

Hello Jori,

As you seem to care about this message, I pused a commit at public/15875 that will raise a slightly more meaningful error message when the input is bad. Add it if you like it, ignore it if you do not.

The probability of users giving this function bad input would be much lower if the function you add had an 'INPUT' section explaining what exactly it expects.

Nathann


---

Comment by git created at 2015-10-27 10:12:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-10-27 10:15:00

Replying to [comment:66 ncohen]:

> As you seem to care about this message, I pused a commit at public/15875 that will raise a slightly more meaningful error message when the input is bad. Add it if you like it, ignore it if you do not.

Thanks. Added that.

> The probability of users giving this function bad input would be much lower if the function you add had an 'INPUT' section explaining what exactly it expects.

Hmm... Maybe I should go through functions and add `INPUT` sections.

This patch contains a non-relating line that corrects an indentation bug in `dilworth_decomposition()`. OK to add here?


---

Comment by ncohen created at 2015-10-27 10:22:06

Yo,

> Hmm... Maybe I should go through functions and add `INPUT` sections.

Could you add one at least in this function that you add here?

> This patch contains a non-relating line that corrects an indentation bug in `dilworth_decomposition()`. OK to add here?

No prob.

About the commit: [please do not change anything as it is not important], but notice that instead of adding my commit on your branch (with cherry-pick, for instance) you apparently applied the changes manually (or did something else that I cannot guess), which has as a side-effect that you became the committer+author of my changes.

Please don't change anything as it is not important, I am just giving you a side-effect of the procedure you followed to use my commit.

Nathann


---

Comment by git created at 2015-10-27 11:39:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-10-27 11:40:20

Replying to [comment:69 ncohen]:

> > Hmm... Maybe I should go through functions and add `INPUT` sections.
> 
> Could you add one at least in this function that you add here?

Done.

> About the commit: [please do not change anything as it is not important], but notice that instead of adding my commit on your branch (with cherry-pick, for instance) you apparently applied the changes manually (or did something else that I cannot guess), which has as a side-effect that you became the committer+author of my changes.

True. I'll try to remember that in the future.


---

Comment by ncohen created at 2015-10-27 11:41:30

Changing status from needs_review to positive_review.


---

Comment by ncohen created at 2015-10-27 11:41:30

Thanks,

Nathann


---

Comment by vbraun created at 2015-10-28 17:59:45

Resolution: fixed
