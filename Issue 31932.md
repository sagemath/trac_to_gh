# Issue 31932: Bug in edge disjoint spanning trees

Issue created by migration from https://trac.sagemath.org/ticket/32169

Original creator: @kliem

Original creation time: 2021-07-09 18:15:57

CC:  dcoudert

Keywords: graph, spanning trees

Timeout when creating edge disjoint spanning trees:


```
sage: dig6_string = '[E_S?_hKIH@eos[BSg???Q@FShGC?hTHUGM?IPug?'
sage: dig6_string += 'JOEYCdOzdkQGo@ADA@AAg?GAQW?'
sage: dig6_string += '[aIaSwHYcD@qQb@Dd?\hJTI@OHlJ_?C_OEIKoeCR@_BC?Q?'
sage: dig6_string += '?YBFosqITEA?IvCU_'
sage: G = DiGraph(dig6_string)
sage: G.edge_connectivity(5)
5
sage: G.edge_disjoint_spanning_trees(5)  # timeout
```


Also I'm getting a bunch of Deprecation warning, when parsing the `dig6_string`: `DeprecationWarning: invalid escape sequence \h`.


---

Comment by dcoudert created at 2021-07-09 22:40:31

I get the answer very quickly with `cplex` and in a few seconds with `coin`. However, with `glpk` it takes ages (although it gets quickly the right LP bound).

```
sage: %time G.edge_disjoint_spanning_trees(5, solver='Cplex')                                                                                      
CPU times: user 2.74 s, sys: 67.5 ms, total: 2.81 s
Wall time: 663 ms
[Digraph on 28 vertices,
 Digraph on 28 vertices,
 Digraph on 28 vertices,
 Digraph on 28 vertices,
 Digraph on 28 vertices]
sage: %time G.edge_disjoint_spanning_trees(5, solver='Coin')                                                                                       
CPU times: user 3.52 s, sys: 76.7 ms, total: 3.6 s
Wall time: 3.61 s
[Digraph on 28 vertices,
 Digraph on 28 vertices,
 Digraph on 28 vertices,
 Digraph on 28 vertices,
 Digraph on 28 vertices]
```


Concerning the `\h`,  if I replace it in the string with `\\h`, then I don't get the warning anymore. Not sure how to fix this issue.


---

Comment by @DaveWitteMorris created at 2021-07-10 00:35:14

Another option for the `\h` (which I think is better) would be to use raw strings (put an 'r' before each of them, or before the one that is giving an error, at least).  As I understand it, dig6 strings can include any visible ascii character, including a backslash.


---

Comment by @kliem created at 2021-07-10 06:42:04

Replying to [comment:3 gh-DaveWitteMorris]:
> Another option for the `\h` (which I think is better) would be to use raw strings (put an 'r' before each of them, or before the one that is giving an error, at least).  As I understand it, dig6 strings can include any visible ascii character, including a backslash.

Thanks for the info. So this was a usage error from my side. I fixed the description.


---

Comment by dcoudert created at 2021-07-10 08:26:23

The current method is based on integer linear programming and is very slow.

For undirected graphs, we can try to implement one of the existing polynomial time algorithm such as the one described in https://doi.org/10.1287/moor.10.4.701. I don't know yet if there is a simpler algorithms.

I don't know the algorithms for directed graphs.


---

Comment by dcoudert created at 2021-07-10 13:21:56

Changing status from new to needs_review.


---

Comment by dcoudert created at 2021-07-10 13:21:56

At first, I propose an alternative ILP formulation based on the Miller-Tucker-Zemlin subtour elimination constraints to replace the current formulation which is based on the maximum average degree. I obtain the solution for the reported digraph with `glpk` in 1.4s on a macbook air.

```
sage: d6 = r'[E_S?_hKIH@eos[BSg???Q@FShGC?hTHUGM?IPug?JOEYCdOzdkQGo@ADA@AAg?GAQW?[aIaSwHYcD@qQb@Dd?\hJTI@OHlJ_?C_OEIKoeCR@_BC?Q??YBFosqITEA?IvCU_' 
sage: G = DiGraph(d6)                                                                                                                              
sage: %time F = G.edge_disjoint_spanning_trees(5, solver='Cplex')                                                                                  
CPU times: user 4.83 s, sys: 97.1 ms, total: 4.93 s
Wall time: 825 ms
sage: F                                                                                                                                            
[Digraph on 28 vertices,
 Digraph on 28 vertices,
 Digraph on 28 vertices,
 Digraph on 28 vertices,
 Digraph on 28 vertices]
sage: %time F = G.edge_disjoint_spanning_trees(5, solver='Coin')                                                                                   
CPU times: user 2.3 s, sys: 65.2 ms, total: 2.37 s
Wall time: 2.38 s
sage: %time F = G.edge_disjoint_spanning_trees(5, solver='GLPK')                                                                                   
CPU times: user 1.36 s, sys: 7.96 ms, total: 1.36 s
Wall time: 1.37 s
```


Of course, it would be better to implement the polynomial time algorithms.
----
New commits:


---

Comment by git created at 2021-07-10 13:32:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2021-07-10 13:34:56

I get slightly better running time when I force equality for the number of incoming edges. 

```
sage: %time F = G.edge_disjoint_spanning_trees(5, solver='Cplex')                                                                                  
CPU times: user 2.2 s, sys: 84.2 ms, total: 2.28 s
Wall time: 506 ms
sage: %time F = G.edge_disjoint_spanning_trees(5, solver='Coin')                                                                                   
CPU times: user 2.36 s, sys: 53.2 ms, total: 2.41 s
Wall time: 2.44 s
sage: %time F = G.edge_disjoint_spanning_trees(5, solver='GLPK')                                                                                   
CPU times: user 1.22 s, sys: 8.05 ms, total: 1.22 s
Wall time: 1.23 s
```

However, if I remove the constraint ensuring that each vertex is incident to a selected edge, the program is way slower to solve.


---

Comment by tscrim created at 2021-07-12 00:52:43

Do you want to keep trying to improve the speed on this ticket or go with this current version and work on further improvements later?


---

Comment by dcoudert created at 2021-07-12 05:24:22

I prefer to work on further improvements later. I had a look at a paper from Roskind and Tarjan for undirected graphs and it is already quite involved (I don't know if better / simpler algorithms have been proposed since 1985) and I have not seen any proposal for directed graphs yet.


---

Comment by tscrim created at 2021-07-12 06:15:24

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2021-07-12 06:15:24

Okay, LGTM.


---

Comment by @kliem created at 2021-07-15 07:12:17

With this ticket our claim is still way above that what sage can do. For those three graphs with 12 vertices, this ticket fails:


```
sage: g1 = DiGraph(r'KAGBiSahR?D?Hw@jFDbLyTWAE')
sage: g2 = DiGraph(r'KW?ACPRIJh_AKPCk_KAORC`Bw') 
sage: g3 = DiGraph(r'KOOB?R?@G_IGc_U}`NEMjE@CE') 
```


Even worse, it seems to work find on the develop branch. However, on the develop branch I'm getting `UnboundedLocalError`, because `classes` are referenced before assignment.

Anyway, while this resolved the one particular case I reported, it seems to have created various other problems.


---

Comment by @kliem created at 2021-07-15 07:32:21

E.g.


```
g = DiGraph(r'SKwrQo`?DpS?hP@OaOYABAYP`OO[_JekGGPI?O_?bKG?IB?B@[BDGiKBCQMGoTp?GGC_') 
```


is resolved now, but didn't work before.


---

Comment by dcoudert created at 2021-07-15 08:21:31

Can you be more specific on the errors you get ?  I can try to improve the formulation, and with more time to implement the polynomial time algorithms.


---

Comment by dcoudert created at 2021-07-15 08:21:31

Changing status from positive_review to needs_work.


---

Comment by git created at 2021-07-15 12:57:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2021-07-15 12:59:50

I added some strengthening constraints to speed up the resolution of the problem. Is it better now ?


---

Comment by @kliem created at 2021-07-15 13:13:44

Whenever I say a graph `g` is not working, I mean that:


```
sage: k = G.edge_connectivity(5)
sage: G.edge_disjoint_spanning_trees(k)
```


does not terminate in reasonable time.

Before this ticket, there was an `UnboundedLocalError`, whenever `k` was `0`.


---

Comment by git created at 2021-07-15 15:09:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2021-07-15 15:10:28

added some tests to deal with small cases (k=0 or 1, n=0).


---

Comment by dcoudert created at 2021-07-15 15:10:28

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2021-07-15 16:28:33

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2021-07-15 16:28:33


```
+        edges = p.get_values(edge)
+        for (e, c), val in edges.items():
+            if val == 1:
+                classes[c].add_edge(e)
```

see #32197.


---

Comment by @kliem created at 2021-07-16 12:01:09

Replying to [comment:17 dcoudert]:
> I added some strengthening constraints to speed up the resolution of the problem. Is it better now ?

It seems to be an improvement. It takes way longer until I find a `DiGraph` with 12 vertices that does not work. And those do work in up to 40 seconds.


```
sage: g1 = DiGraph(r'KO_@OThwDWWCSAMOj_tCIa`DA')      
sage: g2 = DiGraph(r'KGGdZEaQEOyEBZU?DO@O`wKBk')           
sage: g3 = DiGraph(r'KH?cpUuwpp{AOH^SAEEDaWCbW')        
sage: g4 = DiGraph(r'K?IJHENIUh[_ODPCD_@Tr{Wxg')
```


There is more. This is how I find them:


```
sage: def foo(n): 
....:     try: 
....:         alarm(20) 
....:         g = digraphs.RandomDirectedGNP(n, .3) 
....:         k = Integer(g.edge_connectivity()) 
....:         arborescences = g.edge_disjoint_spanning_trees(k) 
....:     except AlarmInterrupt: 
....:         print(g.dig6_string()) 
....:     finally: 
....:         cancel_alarm() 
....:  
sage: while True:
....:     foo(12)
```



---

Comment by dcoudert created at 2021-07-16 14:44:43

With the new formulation and `glpk`, I get the solution for g1, g2, g3 in less than 1s and for g4 in 5s. I'm on a Intel MacBook air.

But for sure it would be much better to get a proper implementation of the polynomial time algorithms.


---

Comment by dcoudert created at 2021-07-17 10:32:58

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2021-07-17 10:32:58

I have rebased the branch on #32197 (hope I did it correctly...) and now use the `integrality_tolerance`.
----
Last 10 new commits:


---

Comment by mkoeppe created at 2021-07-21 03:53:49

The use of `get_values` looks fine. I have not looked at the details of the formulation used


---

Comment by dcoudert created at 2021-07-21 07:43:26

The proposed formulation is clearly not best possible. The constraints I have used have been proposed for solving tsp, steiner tree, and simple path problems in graphs with negative weight cycles.We can certainly do better, but I'm not aware of the good formulations for this problem.

For undirected graphs, I plan to implement a polynomial time algorithm (e.g., Roskind-Tarjan). It will take some time.


---

Comment by @kliem created at 2021-08-09 15:21:37

This seems to be an improvement. However, there are still examples of very slow graphs with 12 vertices (one minute) and things get worse with more vertices, e.g.


```
sage: g = DiGraph(r'KAGHM`U`acCqHKEPmH@IHQdOy') 
```


I don't know if this can be improved at all. I'm just stating this.


---

Comment by @kliem created at 2021-10-04 10:01:47


```
sage: g = Graph(r'M_IkGr`_QCwWDk?E?')
sage: g
Graph on 14 vertices
sage: k = Integer(g.edge_connectivity()) // 2
sage: %time trees = g.edge_disjoint_spanning_trees(k)
CPU times: user 11.7 s, sys: 18.2 ms, total: 11.7 s
Wall time: 11.7 s
```


Hence we lower the number of vertices in 
 ||[2609cb5](https://git.sagemath.org/sage.git/commit/?id=2609cb529eeb3ce1d3c5c4be41c54dff0f2f03dc)||`edge disjoint spanning tree not as fast as claimed, see #32169`||
in #29935.


---

Comment by dcoudert created at 2021-10-12 17:50:28

I now have an implementation of the [Roskind-Tarjan](https://pubsonline.informs.org/doi/abs/10.1287/moor.10.4.701) algorithm for finding minimum-cost edge-disjoint spanning trees in undirected simple graphs. 
However, I don't have any code for directed graphs (and I have not found any reference yet).

Which solution do you prefer:
- remove the ILP for undirected graphs and replace it with my code
- keep the ILP and add new code.

Note that the ILP is not needed if only for comparison purpose. I can add a method to check the validity of the solution.


---

Comment by tscrim created at 2021-10-13 05:32:31

Since the ILP part is going to have to stay (at least for now) for the directed graphs, I propose we keep it so there is more uniformity between directed and undirected graphs. Plus I always like having comparison options.


---

Comment by git created at 2021-10-14 10:48:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2021-10-14 10:59:36

I have added the `Roskind-Tarjan` algorithm for undirected graphs.

test with `graphs.RandomGNP(50, .4)` and `cplex`, I get:

```
sage: g = Graph('qeOuOHJ?Ua?hkiwmAFDuDh|]ICoCrNTNKCLBmE]JH?s~{\\??mRR@sF_Ox@mUo|jAoh_A[]gh?@I}nGNRLUSNME]I{`kE@Q?eM?o\\^JOKpBcGbr_LCSGCpPPOo?CixnJ_
....: _ekpG@T[A^fEikLaAPcOhWqS_IWROGhB\\TiCaexPXrQHZBxjREuapmPPXIIccRVRMwHq}FR?G?Gqs?')
sage: k = Integer(g.edge_connectivity()) // 2
sage: k
7
sage: %time g.edge_disjoint_spanning_trees(k, algorithm="MILP")
CPU times: user 19.4 s, sys: 918 ms, total: 20.3 s
Wall time: 3.81 s
[Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices]
sage: %time g.edge_disjoint_spanning_trees(k, algorithm="Roskind-Tarjan")
CPU times: user 113 ms, sys: 1.98 ms, total: 115 ms
Wall time: 115 ms
[Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices,
 Graph on 50 vertices]
```


I'm still looking for an algorithm for directed graphs. Any pointer is more than welcome (please avoid papers saying that "the argument directly translates to an efficient algorithm"...).


---

Comment by git created at 2021-10-14 16:59:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2021-10-14 17:00:02

may be `EmptySetError` could be loaded at module level since it is used in several methods ?


---

Comment by @DaveWitteMorris created at 2021-10-14 19:18:46

Perhaps this paper will help.  It claims to provide "a simple algorithm which does find k disjoint branchings, if they exist, in polynomial time".

```
Robert Endre Tarjan
A good algorithm for edge-disjoint branching
Information Processing Letters
Volume 3, Issue 2, November 1974, Pages 51-53
https://doi.org/10.1016/0020-0190(74)90024-6
```

(When a branching is rooted at a single vertex, I think it is a directed tree that is rooted at that vertex.)


---

Comment by dcoudert created at 2021-10-14 20:23:26

Actually, the good ones seems to be
- Harold N. Gabow: A Matroid Approach to Finding Edge Connectivity and Packing Arborescences. J. Comput. Syst. Sci. 50(2): 259-273 (1995) https://doi.org/10.1006/jcss.1995.1022
- Loukas Georgiadis, Dionysios Kefallinos, Luigi Laura, Nikos Parotsidis: An Experimental Study of Algorithms for Computing the Edge Connectivity of a Directed Graph. ALENEX 2021: 85-97 https://epubs.siam.org/doi/10.1137/1.9781611976472.7

It seems that the algorithm of Gabow is not so hard to implement (but not easy).If I understand well, the algorithm computes k-spanning-trees assuming (k-1) spanning trees are given as input (the trees might be modified). So it's incremental. Several steps are similar to the `Roskind-Tarjan` algorithms I implemented for undirected graphs. I will give it a try asap.


---

Comment by dcoudert created at 2021-11-19 12:41:25

If you agree, I propose to move the code of the `Roskind-Tarjan` algorithm to a separate ticket. This way, it might be reviewed and possibly added to sagemath soon.

I'm working on the Gabow algorithm. Lukas Georgiadis kindly seeded me some C code, and I'm currently writing a Cython version. It requires careful checking, test and a lot of comments. It's a long and not easy code, so it takes time.


---

Comment by dcoudert created at 2021-11-20 14:13:53

I have moved the `Roskind-Tarjan` algorithm in #32911 and restart this ticket over #32911.
----
New commits:


---

Comment by dcoudert created at 2021-12-08 12:38:42

FYI: thanks to the Loukas Georgiadis and his co-authors (see #comment:37), I now have a working implementation of the algorithm of Gabow for computing the edge connectivity of a digraph. They gave me a pure C code that I turned into an easier to read Cython code. It still lacks comments and doctests... 

I'm still working on the second part of the paper of Gabow for extracting the k-edge-disjoint spanning trees (not obvious). I will not push code before it's done as I may have to refactor some parts of the first algorithm that are also used in the second part.


---

Comment by tscrim created at 2021-12-09 00:31:59

No problem. Just let me know when you're ready for a review.


---

Comment by dcoudert created at 2022-05-11 14:39:12

Replying to [comment:40 dcoudert]:
> FYI: thanks to the Loukas Georgiadis and his co-authors (see #comment:37), I now have a working implementation of the algorithm of Gabow for computing the edge connectivity of a digraph. They gave me a pure C code that I turned into an easier to read Cython code. It still lacks comments and doctests... 

This is now #33839.


---

Comment by tscrim created at 2022-05-14 22:44:16

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-05-14 22:44:16

Then positive review.


---

Comment by vbraun created at 2022-05-18 22:18:58

Resolution: fixed


---

Comment by arojas created at 2022-05-22 20:52:53

This makes the test suite hang with certain random seeds:

```
sage -t --long --random-seed=226966935809951887489348852629671397336 /usr/lib/python3.10/site-packages/sage/graphs/generic_graph.py
    Timed out
**********************************************************************
Tests run before process (pid=581821) timed out:
[...]
sage: trees = g.edge_disjoint_spanning_trees(k, algorithm="MILP") ## line 6579 ##
------------------------------------------------------------------------
/usr/lib/python3.10/site-packages/cysignals/signals.cpython-310-x86_64-linux-gnu.so(+0x76fd)[0x7fdff2caa6fd]
/usr/lib/python3.10/site-packages/cysignals/signals.cpython-310-x86_64-linux-gnu.so(+0x77bc)[0x7fdff2caa7bc]
/usr/lib/python3.10/site-packages/cysignals/signals.cpython-310-x86_64-linux-gnu.so(+0xa4e2)[0x7fdff2cad4e2]
/usr/lib/libc.so.6(+0x3e8e0)[0x7fdff42788e0]
/usr/lib/libglpk.so.40(glp_get_mat_col+0x4b)[0x7fdf7d591dfb]
/usr/lib/libglpk.so.40(glp_eval_tab_row+0x198)[0x7fdf7d5b3328]
/usr/lib/libglpk.so.40(+0x43ed5)[0x7fdf7d5b7ed5]
/usr/lib/libglpk.so.40(+0x49950)[0x7fdf7d5bd950]
/usr/lib/libglpk.so.40(+0x3be63)[0x7fdf7d5afe63]
/usr/lib/libglpk.so.40(glp_intopt+0xd2c)[0x7fdf7d5b108c]
/usr/lib/python3.10/site-packages/sage/numerical/backends/glpk_backend.cpython-310-x86_64-linux-gnu.so(+0x1f618)[0x7fdf7d6be618]
/usr/lib/python3.10/site-packages/sage/numerical/mip.cpython-310-x86_64-linux-gnu.so(+0x2bc83)[0x7fdf84e5ac83]
/usr/lib/libpython3.10.so.1.0(+0x154be1)[0x7fdff459bbe1]
/usr/lib/libpython3.10.so.1.0(_PyObject_MakeTpCall+0x2ab)[0x7fdff45954bb]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x5aaf)[0x7fdff4590b9f]
/usr/lib/libpython3.10.so.1.0(+0x1603f6)[0x7fdff45a73f6]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x149a)[0x7fdff458c58a]
/usr/lib/libpython3.10.so.1.0(+0x143080)[0x7fdff458a080]
/usr/lib/libpython3.10.so.1.0(PyEval_EvalCode+0x94)[0x7fdff463cbb4]
/usr/lib/libpython3.10.so.1.0(+0x1fb9cb)[0x7fdff46429cb]
/usr/lib/libpython3.10.so.1.0(+0x15528f)[0x7fdff459c28f]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x346)[0x7fdff458b436]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(_PyObject_FastCallDictTstate+0xdb)[0x7fdff45947ab]
/usr/lib/libpython3.10.so.1.0(_PyObject_Call_Prepend+0x6d)[0x7fdff45a4c5d]
/usr/lib/libpython3.10.so.1.0(+0x22d462)[0x7fdff4674462]
/usr/lib/libpython3.10.so.1.0(_PyObject_MakeTpCall+0x2ab)[0x7fdff45954bb]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x5164)[0x7fdff4590254]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(+0x1603f6)[0x7fdff45a73f6]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x149a)[0x7fdff458c58a]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(_PyObject_FastCallDictTstate+0xdb)[0x7fdff45947ab]
/usr/lib/libpython3.10.so.1.0(+0x15d08d)[0x7fdff45a408d]
/usr/lib/libpython3.10.so.1.0(_PyObject_MakeTpCall+0x283)[0x7fdff4595493]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x5164)[0x7fdff4590254]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x4ebf)[0x7fdff458ffaf]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x4ebf)[0x7fdff458ffaf]
/usr/lib/libpython3.10.so.1.0(+0x1603f6)[0x7fdff45a73f6]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x4ebf)[0x7fdff458ffaf]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(_PyFunction_Vectorcall+0x79)[0x7fdff459c099]
/usr/lib/libpython3.10.so.1.0(_PyEval_EvalFrameDefault+0x77a)[0x7fdff458b86a]
/usr/lib/libpython3.10.so.1.0(+0x143080)[0x7fdff458a080]
/usr/lib/libpython3.10.so.1.0(PyEval_EvalCode+0x94)[0x7fdff463cbb4]
/usr/lib/libpython3.10.so.1.0(+0x205103)[0x7fdff464c103]
/usr/lib/libpython3.10.so.1.0(+0x200a9a)[0x7fdff4647a9a]
/usr/lib/libpython3.10.so.1.0(+0xa183c)[0x7fdff44e883c]
/usr/lib/libpython3.10.so.1.0(_PyRun_SimpleFileObject+0x3cc)[0x7fdff44e84ed]
/usr/lib/libpython3.10.so.1.0(_PyRun_AnyFileObject+0x89)[0x7fdff44e8ea0]
/usr/lib/libpython3.10.so.1.0(Py_RunMain+0x3dd)[0x7fdff46586fd]
/usr/lib/libpython3.10.so.1.0(Py_BytesMain+0x3b)[0x7fdff462e19b]
/usr/lib/libc.so.6(+0x29290)[0x7fdff4263290]
/usr/lib/libc.so.6(__libc_start_main+0x8a)[0x7fdff426334a]
/usr/bin/python(_start+0x25)[0x5642f4693045]
------------------------------------------------------------------------
```



---

Comment by dcoudert created at 2022-05-22 22:29:15

outch :(

This is for

```
g = Graph(']sLa{AZZs?fCoOOPAqJaO_byp|e?w[U@cObCktCSsAO]b{cndeJIT`G~dcaXWEBwUk_kLar@sg')
```

It's a too hard instance for this formulation with `GLPK`.

I see 2 solutions here: use a much smaller instance (10 nodes ?) or deprecate the `ILP` formulation. We have the polynomial time  `Roskind-Tarjan` algorithm for undirected graphs and we should soon have an algorithm for directed graphs (GSoC project).


---

Comment by tscrim created at 2022-05-22 22:34:17

I would make the number of nodes for the test smaller as it is less invasive of a fix.


---

Comment by dcoudert created at 2022-05-22 22:49:05

I opened #33884.
