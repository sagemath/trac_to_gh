# Issue 32060: Abel-Jacobi map on Riemann surfaces

Issue created by migration from https://trac.sagemath.org/ticket/32297

Original creator: @DisneyHogg

Original creation time: 2021-07-29 09:45:30

CC:  nbruin




---

Comment by @DisneyHogg created at 2021-07-29 09:53:25

Changing type from PLEASE CHANGE to enhancement.


---

Comment by @DisneyHogg created at 2021-07-29 09:53:25

Changing component from PLEASE CHANGE to algebraic geometry.


---

Comment by @DisneyHogg created at 2021-07-29 09:53:25

Changing priority from major to minor.


---

Comment by @DisneyHogg created at 2021-07-29 09:53:25

Set assignee to @DisneyHogg.


---

Comment by @DisneyHogg created at 2021-08-12 09:23:12

Ticket #32289 is no longer a depdency due to the structure of the code.
----
Last 10 new commits:


---

Comment by git created at 2021-08-12 13:05:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-12 13:30:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-13 09:35:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-13 16:11:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2021-08-13 16:13:55

Changing status from new to needs_review.


---

Comment by nbruin created at 2021-08-13 17:51:24

I noticed on some examples that the new code introduces a *lot* of "branch" points. I'm a little concerned this may affects performance adversely in various cases:
 - the present code computes homotopy continuations along *all* edges, so we have to compute much more of them
 - the newly introduced points may push paths much closer to problematic points than they previously were, so it may make some continuations take longer than they did before.

Usually, integration takes more function evaluations than the homotopy continuations, so in many cases the penalty will not be so severe, but I don't know to what extent that will hold true.

I see several options to mitigate this issue:
 - we could refactor the class so that the branch locus selection mechanism is more easily customizable and then subclass a separate "RiemannSurfaceForAbelJacobiMap" which can then implement the additional integration techniques required for computing, and initialize this richer skeleton
 - we could put specify (with a flag) what kind of branch locus should be used and, based on that, the code later can choose what features are available (roughly equivalent to the solution above, but solved with a different software technique)
 - we could extract a subgraph that is sufficient to support the full homology: just cycles around the *actual* branch points. That's enough to for our purpose. The other points are just there to avoid unfortunate behaviour.

In the last one, we'd have more upfront work, because we're extracting our graph from a larger Voronoi graph (but that's fairly cheap to compute) and our integration paths may be pushed and broken up (and hence be less optimal? are they optimal now?). If we could come up with a good estimated cost function (length over sum of distances of branch points to line segment?) we could try and select "shortest cycles". Otherwise perhaps just take the voronoi cells that belong to the actual branch points, with possibly some extra edges to make the thing connected.

There is something to say to equip the path builder with the general infrastructure to specify the points we must have cycles around, together with other points that are to be avoided. 

The main part is: there are plenty of applications of Riemann matrices that do not involve computing Abel-Jacobi maps, so we should not deteriorate the performance of that (without choice) in favour of Abel-Jacobi maps.


---

Comment by @DisneyHogg created at 2021-08-14 00:48:31

Replying to [comment:10 nbruin]:
I had noticed the additional strain having a larger skeleton caused. A simpler solution might be to revert to the previous case of not including ramification points of the differentials in the branch locus, as a quick test shows that this doesn't stop the Abel-Jacobi map from working on any of the current cases. One would then need to just put in a check, analogous to the one currently around line 3110, that makes sure that if the path to the currently chosen vertex would pass too close to a ramification point, another vertex is chosen.


---

Comment by nbruin created at 2021-08-14 04:34:51

Replying to [comment:11 gh-DisneyHogg]:
> Replying to [comment:10 nbruin]:
> I had noticed the additional strain having a larger skeleton caused. A simpler solution might be to revert to the previous case of not including ramification points of the differentials in the branch locus, as a quick test shows that this doesn't stop the Abel-Jacobi map from working on any of the current cases. One would then need to just put in a check, analogous to the one currently around line 3110, that makes sure that if the path to the currently chosen vertex would pass too close to a ramification point, another vertex is chosen. 

That seems like a good idea. I assume you'll actually be using this code, so refining such strategies if necessary later is a good idea. First getting a basic, functional version in is a good first step.


---

Comment by git created at 2021-08-16 10:19:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-16 10:24:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-21 11:32:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-30 13:49:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-09-08 14:11:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2021-09-08 14:12:25

Replying to [comment:18 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[c449417](https://git.sagemath.org/sage.git/commit/?id=c44941741db4edbf488fa8d72af6a5481dab34b5)||`Error bound improved.`||

See comments 57, 58 and 60 of #31996 for context.


---

Comment by git created at 2021-10-26 10:14:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-11-03 16:13:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2021-11-08 16:56:58

The code is currently not reliable when integrating out to infinity. Consider the following code doing the AJ integral to the point above infinity where the fibre coordinate tends to infinity on Klein's curve

```
R.<x,y> = QQ[]
f = x^3*y + y^3 + x
S = RiemannSurface(f)
for i in [0,2]:
    AJ, _ = S._integrate_differentials_iteratively(([Infinity, i], S._CC(2-I)), True)
    print(AJ, "\n")
```

The fibre values above the path on these two integrals has the opposite sign, hence as the cohomology basis is `[1, y, x]` with denominator `x<sup>3+3*y</sup>2`, we expect the `0,2` elements of the two values `AJ` to be the same (which is what we see) and the `1` element to have opposite sign (which isn't true). The error is of about 0.02%. 
One can check that this is numerical instability, for example by considering the case where we take `S._prec=100`, and then the output of `initialise(z, i)` is not the same (up to sign) for the two integrals. Perhaps the method for computing the AJ map to infinity needs to be rethought, or a method to mitigate these instabilities needs to be devised.


---

Comment by git created at 2021-12-02 12:27:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-03-02 11:42:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-04-07 06:26:21

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2022-04-07 06:26:21

Needs rebase.


---

Comment by git created at 2022-04-13 11:16:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2022-04-13 12:01:10

Rebased, and tests passing.


---

Comment by @DisneyHogg created at 2022-04-13 12:01:10

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2022-04-13 18:16:18

please fix the patchbot red plugins


---

Comment by git created at 2022-04-14 09:44:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2022-04-14 10:08:40

Patchbot plugin now passing


---

Comment by chapoton created at 2022-04-14 11:02:00

not yet:

```
+src/sage/schemes/riemann_surfaces/riemann_surface.py:3327:25 undefined name 'g'
+src/sage/schemes/riemann_surfaces/riemann_surface.py:3464:9 local variable 'Pz' is assigned to but never used
+src/sage/schemes/riemann_surfaces/riemann_surface.py:3465:9 local variable 'Pw' is assigned to but never used
```

and

```
++        Returns a representative of the Abel-Jacobi map of a divisor with basepoint
++        Returns a list of the of places above the branch locus. This must be
```

where Returns should be Return


---

Comment by git created at 2022-04-14 11:15:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2022-04-14 11:17:11

Made those changes, how did you discover these errors? I am using `tox -- sage/schemes/riemann_surfaces/riemann_surface.py` to run the tests, should I be using something else?


---

Comment by chapoton created at 2022-04-14 11:19:29

they are displayed when you click on the round icon for the patchbot reports (here, top left). Then there are smaller round icons on the right of each reports.


---

Comment by chapoton created at 2022-04-16 10:05:38

50 seconds is not a reasonable time for a doctest


---

Comment by git created at 2022-04-27 11:19:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2022-04-27 15:16:53

Build and test is failing, but seemingly only because of test in `parallel/map_reduce.py`, but running `sage -t --random-seed=21747910571368870053030460862137931549 sage/parallel/map_reduce.py` ony my machine doesn't reproduce the errors.


---

Comment by tscrim created at 2022-05-01 23:46:21

`@`nbruin What else mathematically needs to be checked with this code. I can do the remaining technical stuff, but I don't know the math here.


---

Comment by chapoton created at 2022-05-31 09:59:30

needs rebase

and what about comment:36 ?


---

Comment by chapoton created at 2022-05-31 09:59:30

Changing status from needs_review to needs_work.


---

Comment by git created at 2022-08-18 12:38:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2022-08-19 07:13:48

Code rebased and all checks passing, so needs review.


---

Comment by @DisneyHogg created at 2022-08-19 07:13:48

Changing status from needs_work to needs_review.


---

Comment by nbruin created at 2022-08-23 00:57:13

(this is a longer comment concerning ideas that should probably be transferred to follow-up tickets)

This largely looks great! I envision that this code would mainly be used "the other way around" as far as curves and riemann surfaces are concerned:

```
R.<x,y> = QQ[]
f = (y^2- (x-1)*(x-3)*(x-4)*(x-6)*(x-11))
C = Curve(f)
KC= C.function_field()
S = C.riemann_surface(prec=100)
KC = Curve(S.f).function_field()
Dx=KC(x).divisor()
Dxm1=KC(x-1).divisor()
v=S.abel_jacobi(S.divisor_to_divisor_list(Dx-Dxm1))
```

but that works just fine. I think we'll need a better error message for problems with support at infinity, though:

```
sage: S.divisor_to_divisor_list(Dx)
TypeError: Could not find a mapping of the passed element to this ring.
```

that should be a `ValueError: conversion of places at infinity not implemented yet`.

The extended example at the top of the file illustrates all the main features of the current implementation, though: that should allow anyone to get started with this.

I do think that in the near future it would be really desirable that `S.abel_jacobi` also accepts "function field divisors" itself, where it can then just call `divisor_to_divisor_list` itself: it's pretty clear that in the near-to-medium future, function field divisors are going to be the most functional data type (perhaps "curve" divisors develop, but we need Cartier divisors here, so the function field is not a bad place to park them), so it would be good if `abel_jacobi` accepted that.

There are presently some `Curve(self.f)` calls in `places_at_branch_locus`, `strong_approximation`, `divisor_to_divisor_list` [notably, NOT in the actual workhorse routines!]. That's possibly a quite costly thing to call and, interestingly, it's not `UniqueRepresentation`!. So

```
sage: C1=Curve(f)
sage: C2=Curve(f)
sage: C1 is C2
False
```

so I suspect that a riemann surface should have a possibility of linking back to a curve, which could be just Curve(self.f). However, when called via `C.riemann_surface()`, it should probably link back to the original curve; meaning that `C.riemann_surface` should do some post-processing (or riemann_surface would need to sprout yet another technical optional argument to pass it the curve to link back to)

Interestingly enough, the function field ARE `UniqueRepresentation`, so

```
sage: C1.function_field() is C2.function_field()
True
```

but I think that by just linking back to the curve, we'll not be creating reference cycles that make objects immortal (which is always a real risk with a `UniqueRepresentation` object that links to an object that (even weakly!) links back to it.


---

Comment by nbruin created at 2022-08-23 01:02:43

Math review:

I've done some basic checks and it looks like the implementation is fundamentally OK. There could of course be numerical stability problems lurking somewhere, but the only chance of getting these out is by exposing the code. So: positive review from me.

Also, considering doctest times:

```
$ sage -t src/sage/schemes/riemann_surfaces/riemann_surface.pyAll tests passed!
----------------------------------------------------------------------
Total time for all tests: 13.3 seconds
    cpu time: 12.6 seconds
    cumulative wall time: 13.2 seconds
$ sage -t --long src/sage/schemes/riemann_surfaces/riemann_surface.py
----------------------------------------------------------------------
Total time for all tests: 23.6 seconds
    cpu time: 22.9 seconds
    cumulative wall time: 23.5 seconds
```

I think the tests for `long` are still quite decent, so I'd be in favour of dropping the `long` modifier on (many of) the tests, so that regular coverage is a bit better.


---

Comment by tscrim created at 2022-08-23 01:16:26

Replying to [comment:44 nbruin]:
> that should be a `ValueError: conversion of places at infinity not implemented yet`.

Seems like a textbook `NotImplementedError`. `;)`


---

Comment by nbruin created at 2022-08-23 21:57:51

OK, made some minor edits addressing most of the comments in [comment:46]
----
New commits:


---

Comment by git created at 2022-08-27 19:40:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-30 18:29:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2022-08-30 18:32:33

Changing priority from minor to major.


---

Comment by nbruin created at 2022-08-30 18:32:33

Ticket looks like it's really ready for review now and since it adds significant functionality, reset priority to the (default) "major". I hope we can get it in!


---

Comment by tscrim created at 2022-08-31 00:31:38

A bit [xkcd style commits](https://xkcd.com/1296/) there. `:P`

Some code comments (I don't know the math; I will leave that to Nils):


```diff
-the literature.::
+the literature::
```

as it displays as `the literature.:` in the compiled doc.

Spacing would be nice here (but not required): ``2D=K`::` -> ``2D = K`::`


```diff
     INPUT:
 
-    - ``item`` -- value to minimise the distance to over the list.
-
-    - ``List`` -- list. List to look for closest element in.
+    - ``item`` -- value to minimize the distance to over the list
+    - ``lst`` -- list to look for closest element in
```

We generally have American spelling within Sage doc; inputs items are generally not sentences; Python naming conventions say variable names should (generally) follow `lower_case`; and we should not use `list` as a variable. Similar changes elsewhere in the doc; e.g.,

```diff
-    - ``minpoly`` -- a polynomial in two variables, where the first variables
-       corresponds to the base coordinate on the Riemann surface.
-
-    - ``z0`` -- complex number of infinity. The point about which to
-      reparameterise.
+    - ``minpoly`` -- a polynomial in two variables, where the first variables
+       corresponds to the base coordinate on the Riemann surface
+    - ``z0`` -- complex number of infinity; the point about which to
+      reparameterize
```


```diff
-        - ``upstairs_edge`` -- tuple. ``((z_start, sb), (z_end,))`` giving the
-          start and end values of the base coordinate along the straight-line
-          path and the starting branch.
-
-        - ``initial_continuation`` -- list (default: None).  Output of
-          ``homotopy_continuation`` initialising the continuation data.
+        - ``upstairs_edge`` -- tuple ``((z_start, sb), (z_end,))`` giving the
+          start and end values of the base coordinate along the straight-line
+          path and the starting branch
+        - ``initial_continuation`` -- list (optional); output of
+          ``homotopy_continuation`` initialising the continuation data
```


This seems wasteful with creating the transient list:

```python
    dists = [(item-l).abs() for l in List]
    return dists.index(min(dists))
```

Although probably implementing the check manually using a `for` loop might be slower because of Python's general speed.

PEP8 and variable name:

```diff
-Inf = bool(z0==z0.parent()(Infinity))
+is_inf = bool(z0 == z0.parent()(Infinity))
```

although I would normally expect `is_inf = (z0 == Infinity)` to work more generally because of coercion (maybe even be marginally faster).

``self._dfdw`` -> ```self._dfdw```


```diff
-        ONE = self._RR(1)
-        LAMBDA = self._RR.pi()/2
+        one = self._RR.one()
+        la = self._RR.pi() / 2
```


Why is this a function:

```python
            def error_handle(out):
                raise ConvergenceError("Newton iteration fails to converge")
```

It seems like everything you do when `error_handle` is set to this will result in an error. I think the code logic around this for `_integrate_differentials_iteratively` needs to be improved to make it clear when errors should happen (or at least provide some comments).

Some general PEP8 stuff (like noted about) with spaces around various operators.


```diff
-if not K==QQ:
+ if K is not QQ:
```


Not necessary, but it is faster:

```diff
-if D==0:
+if not D:
```

(If not changed, PEP8 spacing around `==`.)


```diff
-            print(dl)
-            raise ValueError("Numerical instability, list of wrong degree")
+            raise ValueError("numerical instability, list of wrong degree")
```

It is not good to print stuff (what if someone wants to catch this error then do something?) -- if you want to include it, then add it to the error message; we follow Python's convention for error messages starting with a lower case letter.

I think this is faster:

```diff
-                        ys += [ny[0] for ny in nys]
-                        rys += [(v*m*n, (r, y)) for y, n in nys]
+                        ys.extend(ny[0] for ny in nys)
+                        rys.extend((v*m*n, (r, y)) for y, n in nys)
```

at least it seems more explicitly to not create a temporary list to me.

When returning something from a (public) ``@`cached_method`, it should be immutable. In particular, pass `immutable=True` to the graph constructor.

No need to build a transient list:

```diff
-            epsilon = min([abs(self._wvalues[i1][i] - self._wvalues[i1][n-j-1])
-                           for i in range(n) for j in range(n-i-1)])/3
+            val = self._wvalues[i1]
+            epsilon = min(abs(val[i] - val[n-j-1])
+                          for i in range(n) for j in range(n-i-1)) / 3
```

This also avoids the additional lookups to `self._wvalues` (which while quick, they can really add up).

I might have more later, but this should be most of them I think.


---

Comment by nbruin created at 2022-08-31 23:13:05

Replying to [comment:52 tscrim]:
> A bit [xkcd style commits](https://xkcd.com/1296/) there. `:P`
:-? I thought that last commit fully documented the change that was made :-)

> {{{
> +    - ``minpoly`` -- a polynomial in two variables, where the first variables
> +       corresponds to the base coordinate on the Riemann surface
> +    - ``z0`` -- complex number of infinity; the point about which to
> +      reparameterize
> }}}
AND `number of infinity` -> `number or infinity`

Thanks Travis!


---

Comment by tscrim created at 2022-09-01 09:14:46

Replying to [comment:53 nbruin]:

> > {{{
> > +    - ``minpoly`` -- a polynomial in two variables, where the first variables
> > +       corresponds to the base coordinate on the Riemann surface
> > +    - ``z0`` -- complex number of infinity; the point about which to
> > +      reparameterize
> > }}}
> AND `number of infinity` -> `number or infinity`

I was wondering about that, but I figured it was my naïveté with the topic.

> Thanks Travis!

No problem.


---

Comment by @DisneyHogg created at 2022-09-01 13:48:07

Think I addressed all the comments from Travis, anything I've missed?


---

Comment by tscrim created at 2022-09-01 23:09:26

The doc of `find_closest_element` is now wrong (`List` -> `lst`).

`homotopy_continuation` and `simple_vector_line_integral` have a period at the end of their `INPUT:`. Many others (e.g., `_bounding_data`) also should be changed following my comment above.

There are still a lot of PEP8 spacing things to fix (in particular around operators).

You’ve not addressed the `error_handle` question.


---

Comment by nbruin created at 2022-09-02 00:23:17

Replying to [comment:57 tscrim]:

> There are still a lot of PEP8 spacing things to fix (in particular around operators).

Tip for Linden: run the code through [black](https://black.readthedocs.io/en/stable/) and be done with it. It transfers all code-formatting taste questions to whatever the writer of `black` has converged on and the rule set there is fairly acceptable to quite a few people.

I've just checked what it does to `riemann_surface.py` and it looks acceptable. It improves a bunch of formatting that's really hard to find otherwise. It does change a few things for the worse, but not to an unacceptable level to me (`a**2` is really better to me than `a ** 2`, but the latter can be what PEP-8 recommends) -- and it gets the PEP-8 crowd of your back! (that's the main design reason of black in the first place: to obviate the need for formatting style discussions)

> You’ve not addressed the `error_handle` question.

I've looked at that and it seems like a reasonable coding solution to me. The alternative is to write out, in all four places where it's called:

```
if raise_error:
    raise ConvergenceError("Newton iteration fails to converge")
else:
    outg.append(newg) #or whatever statement is required
```

You can probably argue a long time about the merits and drawbacks of the different solutions (or the functionality in the first place), but given that it's used in four different places, I don't think it counts as egregiously bad/smart coding style. It could even be argued to be elegant.

In general, I'd be a little reticent in imposing coding styles on our contributors, so I'd leave it to the author in this case.

On option for reviewers would be, if they have trouble understanding the logic of code that may be acceptable, they could ask for additional comments on the mechanism? That could entice the author to abandon the apparently convoluted paradigm or at least lead to better documented code.


---

Comment by tscrim created at 2022-09-02 06:08:40

Replying to [comment:58 nbruin]:
> Replying to [comment:57 tscrim]:
> 
> > There are still a lot of PEP8 spacing things to fix (in particular around operators).
>
> (`a**2` is really better to me than `a ** 2`, but the latter can be what PEP-8 recommends)

This one really bugs me too.

There are some things where you don’t need to add spaces; in particular, anytime you are not the out-most operator (which technically includes `()` and `[]` brackets). So something like `(x+y) * z` is fine by PEP8.

> > You’ve not addressed the `error_handle` question.
> 
> I've looked at that and it seems like a reasonable coding solution to me. The alternative is to write out, in all four places where it's called:
> {{{
> if raise_error:
>     raise ConvergenceError("Newton iteration fails to converge")
> else:
>     outg.append(newg) #or whatever statement is required
> }}}
> You can probably argue a long time about the merits and drawbacks of the different solutions (or the functionality in the first place), but given that it's used in four different places, I don't think it counts as egregiously bad/smart coding style. It could even be argued to be elegant.

The most confusing one for me is at the very end, when all of the computation is done, if `raise_error` is `True`, then you will just raise an error. It seems like the function should be doing something, but in one case it just raises an error, in the other it is an no-op. (The name is also misleading as it suggests that it is meant to handle an error.) Of course, it should never get to the end and return in the earlier `for` loop when `raise_errors=True`, but it is less clear that this is the intended behavior.

An unrelated thing, but you can use an `else:` statement after the `for` loop to handle the case when it runs through without an issue (this means less needless checks if you reach the end of the list).

> In general, I'd be a little reticent in imposing coding styles on our contributors, so I'd leave it to the author in this case.

I agree with this statement in general.

> On option for reviewers would be, if they have trouble understanding the logic of code that may be acceptable, they could ask for additional comments on the mechanism? That could entice the author to abandon the apparently convoluted paradigm or at least lead to better documented code.

It would be nice to have some more comments for this.


---

Comment by git created at 2022-09-04 15:10:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-04 15:26:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2022-09-04 15:27:28

Added a bit more explanation about `raise_error` use at the end

> (The name is also misleading as it suggests that it is meant to handle an error.) 

Happy to use another name if you have one in mind. The name was more to explain that in the event the function is called really a failure to converge has occurred, and so this should raise an error, unless the user explicitly gives the flag not to in which case the computation can continue.


---

Comment by tscrim created at 2022-09-05 00:39:22

IMO the function should be something that takes no inputs named something list `check_raise_error()` that is called before you proceed. (At which point, I would wonder why not just put the `if` statement in directly.) The function doesn’t do anything with its input, which is a code smell IMO. For example, would you find the argument in this function strange?

```python
def two_two(foo):
    return 2 + 2
```

(Of course, there can be reasons, mainly compatibility with other functions.) Another sign that something could be improved is that you have to have such a long comment to explain a short and simple function.

Anyways, as Nils said, this is basically bikeshedding and I’ve said my piece. It’s not worth holding up your (very good) work over this.


---

Comment by nbruin created at 2022-09-05 16:41:25

I guess Travis would rather not pass the argument through the (configurable) error handler, so you'd end up with

```
    outg.append( raise_convergence_error_if_requested() or newg)
```

where we have (if no error needs to be raised)

```
    def raise_convergence_error_if_requested():
        return False
```

but since `raise_convergence_error_if_requested` is only used in this phrase, it makes sense to define

```
    def raise_convergence_error_if_requested_or_return_value(out):
        if raise_error:
            raise ConvergenceError()
        else
            return out
```

and then you see that `raise_error` is constant per invocation, so you can pull the branching through the def. Indeed in the `raise_error` branch, the value of out isn't used, but that's due a refactoring operation. You could write `def ...(*args)` and then `return args[0]` to avoid the "code smell" (which is properly explained with the refactoring), but that is ugly in its own way.

I guess one issue is that scoped function definitions aren't generally covered in a 1st year programming course, so if your target audience is people with an understanding of programming equivalent to that, they can probably not easily read your code. That would be one reason to only use such a refactoring when it gives you a clear advantage. In this case: if statements are quite fast in python, particularly for a variable like `raise_error` that ends up as a closure variable. Function calls, on the other hand, have a LOT of overhead. So the refactoring probably doesn't really save you much (it's not a time-critical code path anyway)

I think the main draw-back of wrapping up the error raising in a function call is that it pollutes the backtrace: there's an extra level, so you have to look one level up to see the true raise location. So there's a benefit to not wrapping the raise at all (plus saving function call overhead -- in a non-time-critical path, though)

Oh and it looks like the branch needs rebasing.


---

Comment by tscrim created at 2022-09-07 04:30:51

That’s a good point about the traceback from a user viewpoint, as I was thinking mostly as a developer reading the code on its own. Putting the `if` statement in the function would alleviate this as it would be clear that there was a logic statement involved. It would also dissipate the code smell as well.

The rebase needs to be done before I do a final check.


---

Comment by git created at 2022-09-07 09:12:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2022-09-07 09:13:48

Rebased, and edited to use separate `if` statements at each point where `error_handle` was being used previously. All tox checks passing.


---

Comment by git created at 2022-09-07 10:51:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-08 01:35:39

Thank you for the changes. Just a few last little things:

To make it a little more readable and nicer display (to me, so you can ignore the ones you disagree with):

```diff
-    On the curve given by `w^2-z^3+1=0`, we have differential
+    On the curve given by `w^2 - z^3 + 1 = 0`, we have differential
     `\frac{dz}{2w} = \frac{dz}{2\sqrt{z^3-1}}`
-    with minimal polynomial `g^2(z^3-1)-1/4=0`. We can make the substitution
-    `\bar{z}=z^{-1}` to parameterise the differential about `z=\Infty` as
-    `\frac{-\bar{z}^{-2} d\bar{z}}{2\sqrt{\bar{z}^{-3}-1}} = \frac{-d\bar{z}}{2\sqrt{\bar{z}(1-\bar{z}^3)}}`.
+    with minimal polynomial `g^2(z^3-1) - 1/4 = 0`. We can make the substitution
+    `\bar{z} = z^{-1}` to parameterize the differential about `z = \infty` as
+
+    .. MATH::
+
+        \frac{-\bar{z}^{-2} d\bar{z}}{2\sqrt{\bar{z}^{-3} - 1}} = \frac{-d\bar{z}}{2\sqrt{\bar{z} (1 - \bar{z}^3)}}.
+
     Hence the transformed differential should have minimal polynomial
-    `\bar{g}^2\bar{z}(1-\bar{z}^3)-1/4=0`, and we can check this::
+    `\bar{g}^2 \bar{z} (1 - \bar{z}^3) - 1/4 = 0`, and we can check this::
```


PEP8:

```diff
-        sage: reparameterize_differential_minpoly(minpoly, 0)(*minpoly.parent().gens())==minpoly
+        sage: reparameterize_differential_minpoly(minpoly, 0)(*minpoly.parent().gens()) == minpoly
         True
```


```diff
-        sage: q = 1/10
-        sage: f = y^2-(x^2-2*x+1+q^2)*(x^2+2*x+1+q^2)
+        sage: q = 1 / 10
+        sage: f = y^2 - (x^2 - 2*x + 1 + q^2) * (x^2 + 2*x + 1 + q^2)
         sage: p = 500
```


PEP8 allows things like this:

```diff
-        mt = F(minpoly(F.gen(0) ** (-1), -F.gen(0) ** (+2) * F.gen(1)))
+        mt = F(minpoly(F.gen(0)**(-1), -F.gen(0)**2 * F.gen(1)))
```


This test is either worthless or extremely brittle:

```
         sage: ct2/ct1  # random
         0.19453288941244148
```

Marking it as random doesn't mean much to a user (your documentation already does that) or as a test (to a developer checking for regressions). Now you could test that this was `< 1` if you mark it `# long time`, but depends on system load. I would just get rid of the timing aspects of this and just do

```
        sage: q = 1 / 10
        sage: f = y^2 - (x^2 - 2*x + 1 + q^2) * (x^2 + 2*x + 1 + q^2)
        sage: p = 500
        sage: Sh = RiemannSurface(f, prec=p, integration_method='heuristic')
        sage: Sr = RiemannSurface(f, prec=p, integration_method='rigorous')
        sage: Rh = Sh.riemann_matrix()  # long time (8 seconds)
        sage: nodes.cache.clear()
        sage: Rr = Sr.riemann_matrix()  # long time (1 seconds)
```


Trivial thing: Your last argument in `def __init__(` has a comma.


```diff
+        if not (integration_method == "heuristic" or integration_method == "rigorous"):
-            raise ValueError("Invalid integration method")
+            raise ValueError("invalid integration method")
         self._integration_method = integration_method
         self._R = f.parent()
         if len(self._R.gens()) != 2:
-            raise ValueError("only bivariate polynomials supported.")
+            raise ValueError('only bivariate polynomials supported')
         if f.degree() <= 1:
-            raise ValueError("equation must be of degree at least 2.")
+            raise ValueError('equation must be of degree at least 2')
```

(The last two are reverting to what was there before.)

It is okay to have things longer than 80 chars/line, especially when it significantly improves readability:

```diff
-            self.branch_locus += self._CCz(fac(self._CCz.gen(), 0)).roots(
-                multiplicities=False
-            )
+            self.branch_locus += self._CCz(fac(self._CCz.gen(), 0)).roots(multiplicities=False)
```

I also find this more readable before:

```diff
-            epsilon = (
-                min([abs(currw[i] - currw[j]) for i in range(1, n) for j in range(i)])
-                / 3
-            )
+            epsilon = min(abs(currw[i] - currw[j]) for i in range(1,n) for j in range(i)) / 3
```

(Note also the remove of the unnecessary inner list and the PEP8 space around `/`.)
Similarly

```diff
-        loops = [
-            self.voronoi_diagram.regions[i][:]
-            for i in self.voronoi_diagram.point_region
-        ]
+        loops = [self.voronoi_diagram.regions[i][:]
+                 for i in self.voronoi_diagram.point_region]
```

There are lots of these (some of this might be my C++ background and wanting to think of them as code blocks).


```diff
         - ``edge`` -- a tuple ``(z_start, z_end)`` indicating the straight line
-          over which to perform the homotopy continutation.
+          over which to perform the homotopy continutation
```



```diff
-        - ``exact`` -- logical (default: False). Whether to return the minimal
-          polynomials over the exact base ring, or whether to return them over
-          ``self._CC``.
+        - ``exact`` -- boolean (default: ``False``); whether to return the
+          minimal polynomials over the exact base ring or over ``self._CC``
```



```diff
     def curve(self):
         r"""
-        Return the curve from which this Riemann surface is obtained
+        Return the curve from which this Riemann surface is obtained.
```



```diff
         - ``divisor`` -- an element of ``Curve(self.f).function_field().divisor_group()``
-
-        - ``S`` -- list. A list of places to avoid.
+        - ``S`` -- list of places to avoid
```


Of course, it probably isn't worth too much of your time to change too many of these code readability things. It just creates a much larger diff that makes it harder to see what changes you made for this ticket. However, it isn't code I particularly care about (or expect to read/maintain much). So I think you can feel free to ignore many of those comments.


---

Comment by git created at 2022-09-08 12:24:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-09 10:17:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @DisneyHogg created at 2022-09-12 16:38:46

Now passing all checks, remaining errors in Lint are from different modules, ready to be reviewed and accepted.


---

Comment by tscrim created at 2022-09-12 23:25:22

Honestly, I am not sure you fully understand the PEP8 style guidelines as you have introduced some violations of it with your readability changes (nor do they fix some of the IMO most egregious things in pursuit of 80 chars/line, which should not be viewed so strictly, especially nowadays). However, it’s not such a big deal for me, and if Nils is fine with them, then we can make this a positive review.

One question, is #32289 actually a dependency? You have a discrepancy between the ticket description and the listed dependencies.


---

Comment by nbruin created at 2022-09-13 01:12:44

Changing status from needs_review to positive_review.


---

Comment by nbruin created at 2022-09-13 01:12:44

Cool! The line I remember best from PEP-8 is "A Foolish Consistency is the Hobgoblin of Little Minds", so ... fine with me! I think at this point we're better off with the code and it is in an eminently readable form, where further moving of whitespace is not going to make a considerable difference in maintainability. For perfect compliance, we should just run it through "black".


---

Comment by @DisneyHogg created at 2022-09-13 08:17:43

Cheers for the positive review, Travis perhaps if code style may slow down other tickets in the future, is it worth us opening a ticket in order to add more detail to https://doc.sagemath.org/html/en/developer/coding_basics.html, maybe linking to black or some other python code formatter?


---

Comment by tscrim created at 2022-09-13 11:43:44

Well, most of it is located right there with more detailed in the (albeit slightly long) PEP8 link.

It is one of those things that getting into the coding style habits makes it go a lot faster.

When I first started out, I complained about not being able to put any comments signifying the end of code blocks. I had to remove them all, even though I had a few 7 deep nests of functions, for-loops, and if-statements dropping back many steps. It was really very helpful to have them, and I wish they could have stayed. I really dislike Python’s lack of brackets…


---

Comment by vbraun created at 2022-09-19 22:52:25

Merge failure on top of:

12756f654c7 Trac #29619: Matrix and Components should have a sparse iterator

cb51da16e9b Trac #17965: Uniformize the API to compute the inverse of an element

a833b0e9c81 Trac #34491: Upgrade igraph to 0.9.10

7747f43b0d1 Trac #34467: fix random doctest failure in EllipticCurveHom_velusqrt

cba244ef373 Trac #34466: fix various linter errors

5d89d36f1f9 Trac #34228: tox -e docker-...-incremental

627b2bdfe92 Updated [SageMath](SageMath) version to 9.7



reviewer '' does not look right


---

Comment by vbraun created at 2022-09-19 22:52:25

Changing status from positive_review to needs_work.


---

Comment by nbruin created at 2022-09-19 23:38:01

`@`linden: you got caught in Volker's merge queue: he's working on a branch that's not quite available. Eventually his queue will be pushed an be available as a `develop` and then you can rebase. I don't think a good solution for this lag has been found yet.

`@`travis: I guess the reviewer field needs to be filled in. Given the history on the ticket I assume it's OK if your name is entered there? You did a lot of checking and gave a lot of feedback to get this ticket into shape. Ideally you'd fill it in yourself :-).


---

Comment by tscrim created at 2022-09-20 02:50:05

Done.


---

Comment by nbruin created at 2022-09-21 20:57:39

Actually, it looks like the sole reason for the "Merge Failure" was "reviewer does not look right". That's been fixed now, so putting it back to positive review.


---

Comment by nbruin created at 2022-09-21 20:57:39

Changing status from needs_work to positive_review.


---

Comment by @DisneyHogg created at 2022-09-22 09:04:58

Replying to [comment:79 Nils Bruin]:

Thanks for looking at this, if the ticket needs any more work do highlight it to me, but it seems to all be ok now


---

Comment by vbraun created at 2022-09-25 16:34:24

Resolution: fixed
