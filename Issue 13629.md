# Issue 13629: ModuleMorphismByLinearity doesn't coerce input arguments

Issue created by migration from Trac.

Original creator: cnassau

Original creation time: 2012-12-15 10:14:49

Assignee: nthiery

A linear map really should know about `f(0)==0`:


```python
   sage: C=CombinatorialFreeModule(ZZ,(1,2,3))
   sage: f = C.module_morphism(codomain=C,on_basis=lambda i:C.monomial(i))
   sage: f(0)
   ---------------------------------------------------------------------------
   AssertionError                            Traceback (most recent call last)
   ...
   /waste/cn/sage-5.5.rc0/local/lib/python2.7/site-packages/sage/categories/modules_with_basis.pyc in __call__(self, *args)
      1385         after = args[self._position+1:len(args)]
      1386         x = args[self._position]
   -> 1387         assert(x.parent() is self.domain())
      1388 
      1389         if self._is_module_with_basis_over_same_base_ring:

   AssertionError: 
```


Here `ModuleMorphismByLinearity.__call__` should only complain if it cannot coerce its input into `self.domain()` 


---

Comment by nthiery created at 2012-12-16 10:46:35

Hi Christian!

Replying to [ticket:13833 cnassau]:
> A linear map really should know about `f(0)==0`:
> 
> {{{#!python
>    sage: C=CombinatorialFreeModule(ZZ,(1,2,3))
>    sage: f = C.module_morphism(codomain=C,on_basis=lambda i:C.monomial(i))
> }}}
> 
> Here `ModuleMorphismByLinearity.__call__` should only complain if it cannot coerce its input into `self.domain()` 

Well, a linear map from V to W should really know that f(V.zero()) ==
W.zero(), and it does! Whether that should extend by coercion to 0 is
quite questionable. I for myself would not want to depend on this
feature in my own code.

In any cases, the ``automatic coercion to self.domain()'' feature will
come for free once ModuleMorphism won't override anymore __call__. See
the comment in sage/categories/modules_with_basis.py, close to the
implementation of _call_. That's the right thing to work on, if any.
I personally deem the feature not worth the trouble temporarily
messing up with the implementation of _call_ in ModuleMorphism.

Cheers!
                               Nicolas


---

Comment by cnassau created at 2012-12-16 15:15:36

Replying to [comment:1 nthiery]:
> Well, a linear map from V to W should really know that f(V.zero()) ==
> W.zero(), and it does! Whether that should extend by coercion to 0 is
> quite questionable. I for myself would not want to depend on this
> feature in my own code.

My background is this: I'm working on an optional package for Steenrod algebra cohomology, and I have just implemented kernels of maps between modules. Now I would like to have

```python
f(kernel(f).an_element()) == 0
```

But this fails, because `f` cannot be evaluated on elements of `kernel(f)` - even though I have registered a canonical coercion map from `kernel(f)` into `f.domain()` (all of the modules are `CombinatorialFreeModules`).

Well, I can live with this deficiency in my code because I'm just patching Sage in my startup file. But it would be simple to fix this in Sage by changing the 
   {{{
   assert(x.parent() is self.domain())
   }}} 
into a cast
   {{{
   x = self.domain()(x)
   }}}
Whether it's worth doing this now depends on the timeframe of the other patch that you mentioned.

Cheers,\\
Christian


---

Comment by nthiery created at 2012-12-16 16:56:05

Replying to [comment:2 cnassau]:
> My background is this: I'm working on an optional package for Steenrod algebra cohomology, and I have just implemented kernels of maps between modules.

Nice! We will need such tools as well. Is the domain of f graded or finite dimensional?

> Now I would like to have
> {{{#!python
> f(kernel(f).an_element()) == 0
> }}}
> But this fails, because `f` cannot be evaluated on elements of `kernel(f)` - even though I have registered a canonical coercion map from `kernel(f)` into `f.domain()` (all of the modules are `CombinatorialFreeModules`).

I see. It would be natural to go from f.kernel() to f.codomain() using
a lift method (see S.Subquotients? for S=Sets()). So the above could
be written without coercion using:

	f(kernel(f).an_element().lift()).is_zero()

Which is not so bad. Actually, the is_zero test is better since it
expresses more precisely the intention which opens the door for more
optimizations from the system (and indeed is_zero is faster than ==0).

> Whether it's worth doing this now depends on the timeframe of the other patch that you mentioned.

Which, honestly, I have no idea about ... sorry.  I have a patch for
multi-morphisms but it's been lying around for a while.

Cheers,
                             Nicolas


---

Comment by cnassau created at 2012-12-17 11:55:27

Replying to [comment:3 nthiery]:
> Replying to [comment:2 cnassau]:
> > My background is this: I'm working on an optional package for Steenrod algebra cohomology, and I have just implemented kernels of maps between modules.
> 
> Nice! We will need such tools as well. Is the domain of f graded or finite dimensional?

The modules are all tri-graded: they have two internal degrees (because the Steenrod algebra is bigraded) and one homological degree (because I'm really trying to implement _differential_ graded modules). 

The framework for multi-graded objects is of my own making and still quite experimental; I once had a look at some grading patches in the combinat queue [years ago] but decided that I probably needed something different. Of course, whether my own approach leads to something workable is not clear yet... I hope to arrive at something publishable at some point in the next year.

> > Now I would like to have
> > {{{#!python
> > f(kernel(f).an_element()) == 0
> > }}}
> > But this fails, because `f` cannot be evaluated on elements of `kernel(f)` - even though I have registered a canonical coercion map from `kernel(f)` into `f.domain()` (all of the modules are `CombinatorialFreeModules`).
> 
> I see. It would be natural to go from f.kernel() to f.codomain() using
> a lift method (see S.Subquotients? for S=Sets()). So the above could
> be written without coercion using:
> 
> 	f(kernel(f).an_element().lift()).is_zero()
> 
> Which is not so bad. Actually, the is_zero test is better since it
> expresses more precisely the intention which opens the door for more
> optimizations from the system (and indeed is_zero is faster than ==0).

My kernels do follow the `SubQuotients` protocol, so this would indeed work. But I doubt that this syntax would be very appealing to users of the package.

Anyway, I can patch Sage in my package, so this is not an urgent problem for me.

Cheers, \\
Christian
