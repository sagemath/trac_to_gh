# Issue 12797: Coercion failures in symmetric functions

archive/issues_012797.json:
```json
{
    "body": "Assignee: sage-combinat\n\nCC:  sage-combinat @saliola @zabrocki\n\nKeywords: symmetric functions, coercion\n\nThe following code triggers a coercion failure in the symmetric function code\n\n\n```\n    sage: H = MacdonaldPolynomialsH(QQ)\n    sage: P = MacdonaldPolynomialsP(QQ)\n    sage: m = SFAMonomial(P.base_ring())\n    sage: Ht = MacdonaldPolynomialsHt(QQ)\n    sage: m(P.one())\n    m[]\n    sage: Ht(P.one())\n```\n\n\nThe coercion path does exist, however!\n\nThis can also be checked with the new syntax using the patches in the sage-combinat queue as follows:\n\n\n```\n    sage: R = QQ['q,t'].fraction_field()\n    sage: Sym = sage.combinat.sf.sf.SymmetricFunctions(R)\n    sage: H = Sym.macdonald().H();\n    sage: P = Sym.macdonald().P();\n    sage: m = Sym.monomial();\n    sage: Ht = Sym.macdonald().Ht();\n    sage: m(P.one())\n    sage: Ht(P.one())\n```\n\n\nThe bug is in the coercion system. Sage does\nnot find a path from P to Ht, whereas there definitely is one:\n\n\n```\n    def coercion_graph(self, G = None):\n\tif G is None:\n\t    G = DiGraph()\n\tif self not in G.vertices():\n\t    G.add_vertex(self)\n\t    for h in self._introspect_coerce()['_coerce_from_list']:\n\t\tcoercion_graph(h.domain(), G)\n\t\tG.add_edge(h.domain(), self)\n\treturn G\n\n    R = QQ['q,t'].fraction_field()\n    R.rename(\"R\")\n    Sym = sage.combinat.sf.sf.SymmetricFunctions(R); Sym.rename(\"Sym\")\n    p = Sym.p();               p.rename(\"p\")\n    s = Sym.schur();           s.rename(\"s\")\n    e = Sym.elementary();      e.rename(\"e\")\n    m = Sym.monomial();        m.rename(\"m\")\n    h = Sym.complete();        h.rename(\"h\")\n    H = Sym.macdonald().H();   H.rename(\"H\")\n    P = Sym.macdonald().P();   P.rename(\"P\")\n    J = Sym.macdonald().J();   J.rename(\"J\")\n    S = Sym.macdonald().S();   S.rename(\"S\")\n    Ht = Sym.macdonald().Ht(); Ht.rename(\"Ht\")\n    m.coerce_map_from(P);\n    print Ht.coerce_map_from(P)\n    G = coercion_graph(Ht)\n    G.show()\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/12969\n\n",
    "created_at": "2012-05-18T08:42:01Z",
    "labels": [
        "component: combinatorics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.3",
    "title": "Coercion failures in symmetric functions",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/12797",
    "user": "https://github.com/anneschilling"
}
```
Assignee: sage-combinat

CC:  sage-combinat @saliola @zabrocki

Keywords: symmetric functions, coercion

The following code triggers a coercion failure in the symmetric function code


```
    sage: H = MacdonaldPolynomialsH(QQ)
    sage: P = MacdonaldPolynomialsP(QQ)
    sage: m = SFAMonomial(P.base_ring())
    sage: Ht = MacdonaldPolynomialsHt(QQ)
    sage: m(P.one())
    m[]
    sage: Ht(P.one())
```


The coercion path does exist, however!

This can also be checked with the new syntax using the patches in the sage-combinat queue as follows:


```
    sage: R = QQ['q,t'].fraction_field()
    sage: Sym = sage.combinat.sf.sf.SymmetricFunctions(R)
    sage: H = Sym.macdonald().H();
    sage: P = Sym.macdonald().P();
    sage: m = Sym.monomial();
    sage: Ht = Sym.macdonald().Ht();
    sage: m(P.one())
    sage: Ht(P.one())
```


The bug is in the coercion system. Sage does
not find a path from P to Ht, whereas there definitely is one:


```
    def coercion_graph(self, G = None):
	if G is None:
	    G = DiGraph()
	if self not in G.vertices():
	    G.add_vertex(self)
	    for h in self._introspect_coerce()['_coerce_from_list']:
		coercion_graph(h.domain(), G)
		G.add_edge(h.domain(), self)
	return G

    R = QQ['q,t'].fraction_field()
    R.rename("R")
    Sym = sage.combinat.sf.sf.SymmetricFunctions(R); Sym.rename("Sym")
    p = Sym.p();               p.rename("p")
    s = Sym.schur();           s.rename("s")
    e = Sym.elementary();      e.rename("e")
    m = Sym.monomial();        m.rename("m")
    h = Sym.complete();        h.rename("h")
    H = Sym.macdonald().H();   H.rename("H")
    P = Sym.macdonald().P();   P.rename("P")
    J = Sym.macdonald().J();   J.rename("J")
    S = Sym.macdonald().S();   S.rename("S")
    Ht = Sym.macdonald().Ht(); Ht.rename("Ht")
    m.coerce_map_from(P);
    print Ht.coerce_map_from(P)
    G = coercion_graph(Ht)
    G.show()
```


Issue created by migration from https://trac.sagemath.org/ticket/12969





---

archive/issue_comments_153414.json:
```json
{
    "body": "Just for the record: My impression was that solving this ticket could also help with a couple of coercion-related memory leaks considered in #715, #12215, #12313 and so on.",
    "created_at": "2012-07-20T06:17:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153414",
    "user": "https://github.com/simon-king-jena"
}
```

Just for the record: My impression was that solving this ticket could also help with a couple of coercion-related memory leaks considered in #715, #12215, #12313 and so on.



---

archive/issue_comments_153415.json:
```json
{
    "body": "I can confirm that the problem occurs with vanilla sage-5.2.rc0, namely resulting in this error:\n\n```\nTypeError: do not know how to make x (= McdP[]) an element of self (=Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field)\n```\n",
    "created_at": "2012-07-20T20:15:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153415",
    "user": "https://github.com/simon-king-jena"
}
```

I can confirm that the problem occurs with vanilla sage-5.2.rc0, namely resulting in this error:

```
TypeError: do not know how to make x (= McdP[]) an element of self (=Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field)
```




---

archive/issue_comments_153416.json:
```json
{
    "body": "Observation: When starting with your example, one gets\n\n```\nsage: from sage.structure.element import get_coercion_model\nsage: cm = get_coercion_model()\nsage: Ht.has_coerce_map_from(P)\nFalse\nsage: cm.discover_coercion(P,Ht)\n(None, Composite map:\n  From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n  To:   Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n  Defn:   Composite map:\n          From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n          To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n          Defn:   Generic morphism:\n                  From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                then\n                  Generic morphism:\n                  From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                  To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n        then\n          Generic morphism:\n          From: Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n          To:   Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field)\nsage: Ht.has_coerce_map_from(P)\nFalse\nsage: cm.discover_coercion(Ht,P)\n(Composite map:\n  From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n  To:   Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n  Defn:   Composite map:\n          From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n          To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n          Defn:   Generic morphism:\n                  From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                then\n                  Generic morphism:\n                  From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                  To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n        then\n          Generic morphism:\n          From: Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n          To:   Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, None)\nsage: Ht.has_coerce_map_from(P)\nFalse\n```\n\nThus, apparently the problem is that \"coerce_map_from\" does not call discover_coercion when it should. Broken cache, apparently. Non-unique parents?",
    "created_at": "2012-07-21T08:17:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153416",
    "user": "https://github.com/simon-king-jena"
}
```

Observation: When starting with your example, one gets

```
sage: from sage.structure.element import get_coercion_model
sage: cm = get_coercion_model()
sage: Ht.has_coerce_map_from(P)
False
sage: cm.discover_coercion(P,Ht)
(None, Composite map:
  From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
  To:   Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
  Defn:   Composite map:
          From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
          To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
          Defn:   Generic morphism:
                  From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                then
                  Generic morphism:
                  From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                  To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
        then
          Generic morphism:
          From: Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
          To:   Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field)
sage: Ht.has_coerce_map_from(P)
False
sage: cm.discover_coercion(Ht,P)
(Composite map:
  From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
  To:   Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
  Defn:   Composite map:
          From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
          To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
          Defn:   Generic morphism:
                  From: Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                then
                  Generic morphism:
                  From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                  To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
        then
          Generic morphism:
          From: Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
          To:   Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, None)
sage: Ht.has_coerce_map_from(P)
False
```

Thus, apparently the problem is that "coerce_map_from" does not call discover_coercion when it should. Broken cache, apparently. Non-unique parents?



---

archive/issue_comments_153417.json:
```json
{
    "body": "In sage.structure.parent.Parent.coerce_map_from, I see the lines\n\n```python\n            mor = self.discover_coerce_map_from(S)\n            #if mor is not None:\n            #    # Need to check that this morphism doesn't connect previously unconnected parts of the coercion diagram\n            #    if self._embedding is not None and not self._embedding.codomain().has_coerce_map_from(S):\n            #        # The following if statement may call this function with self and S.  If so, we want to return None,\n            #        # so that it doesn't use this path for the existence of a coercion path.\n            #        # We disable this for now because it is too strict\n            #        pass\n            #        # print \"embed problem: the following morphisms connect unconnected portions of the coercion graph\\n%s\\n%s\"%(self._embedding, mor)\n            #        # mor = None\n            if mor is not None:\n                # NOTE: this line is what makes the coercion detection stateful\n                # self._coerce_from_list.append(mor)\n                pass\n            self._coerce_from_hash[S] = mor\n```\n\nLooks suspicious to me. A lot of commented-out code, and an empty special case when the coercion is not None.",
    "created_at": "2012-07-21T08:22:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153417",
    "user": "https://github.com/simon-king-jena"
}
```

In sage.structure.parent.Parent.coerce_map_from, I see the lines

```python
            mor = self.discover_coerce_map_from(S)
            #if mor is not None:
            #    # Need to check that this morphism doesn't connect previously unconnected parts of the coercion diagram
            #    if self._embedding is not None and not self._embedding.codomain().has_coerce_map_from(S):
            #        # The following if statement may call this function with self and S.  If so, we want to return None,
            #        # so that it doesn't use this path for the existence of a coercion path.
            #        # We disable this for now because it is too strict
            #        pass
            #        # print "embed problem: the following morphisms connect unconnected portions of the coercion graph\n%s\n%s"%(self._embedding, mor)
            #        # mor = None
            if mor is not None:
                # NOTE: this line is what makes the coercion detection stateful
                # self._coerce_from_list.append(mor)
                pass
            self._coerce_from_hash[S] = mor
```

Looks suspicious to me. A lot of commented-out code, and an empty special case when the coercion is not None.



---

archive/issue_comments_153418.json:
```json
{
    "body": "\n```\nsage: Ht._coerce_map_from_??\nType:           builtin_function_or_method\nBase Class:     <type 'builtin_function_or_method'>\nString Form:    <built-in method _coerce_map_from_ of MacdonaldPolynomials_ht_with_category object at 0x4686c50>\nNamespace:      Interactive\nDefinition:     Ht._coerce_map_from_(self, S)\nSource:\n    cpdef _coerce_map_from_(self, S):\n        \"\"\"\n        Override this method to specify coercions beyond those specified \n        in coerce_list. \n        \n        If no such coercion exists, return None or False. Otherwise, it may \n        return either an actual Map to use for the coercion, a callable\n        (in which case it will be wrapped in a Map), or True (in which case\n        a generic map will be provided). \n        \"\"\"\n        return None\n```\n\nQuestion: Why is that method not overridden for the different realisations of `MacdonaldPolynomials`?",
    "created_at": "2012-07-21T10:43:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153418",
    "user": "https://github.com/simon-king-jena"
}
```


```
sage: Ht._coerce_map_from_??
Type:           builtin_function_or_method
Base Class:     <type 'builtin_function_or_method'>
String Form:    <built-in method _coerce_map_from_ of MacdonaldPolynomials_ht_with_category object at 0x4686c50>
Namespace:      Interactive
Definition:     Ht._coerce_map_from_(self, S)
Source:
    cpdef _coerce_map_from_(self, S):
        """
        Override this method to specify coercions beyond those specified 
        in coerce_list. 
        
        If no such coercion exists, return None or False. Otherwise, it may 
        return either an actual Map to use for the coercion, a callable
        (in which case it will be wrapped in a Map), or True (in which case
        a generic map will be provided). 
        """
        return None
```

Question: Why is that method not overridden for the different realisations of `MacdonaldPolynomials`?



---

archive/issue_comments_153419.json:
```json
{
    "body": "If I understand correctly, the coercion maps are supposed to go via Schur basis. But while one has\n\n```\nsage: H = MacdonaldPolynomialsH(QQ)\nsage: P = MacdonaldPolynomialsP(QQ)\nsage: m = SFAMonomial(P.base_ring())\nsage: Ht = MacdonaldPolynomialsHt(QQ)\nsage: Ht._s\nSymmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\nsage: Ht._s.has_coerce_map_from(P)\nTrue\n```\n\none has (or does in fact *not* have)\n\n```\nsage: P._s\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n\n/home/simon/SAGE/prerelease/sage-5.2.rc0/<ipython console> in <module>()\n\n/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/structure/parent.so in sage.structure.parent.Parent.__getattr__ (sage/structure/parent.c:5967)()\n\n/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/structure/misc.so in sage.structure.misc.getattr_from_other_class (sage/structure/misc.c:1427)()\n\nAttributeError: 'MacdonaldPolynomials_p_with_category' object has no attribute '_s'\nsage: P._self_to_s(P.one())\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n\n/home/simon/SAGE/prerelease/sage-5.2.rc0/<ipython console> in <module>()\n\n/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/combinat/sf/macdonald.pyc in _self_to_s(self, x)\n    421             (3*q-6)*s[1, 1, 1] + (-4*q+1)*s[2, 1]\n    422         \"\"\"\n--> 423         return self._s._from_cache(x, self._s_cache, self._self_to_s_cache, q = self.q, t = self.t) # do we want this t = self.t?\n    424 \n    425     def c1(self, part):\n\n/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/structure/parent.so in sage.structure.parent.Parent.__getattr__ (sage/structure/parent.c:5967)()\n\n/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/structure/misc.so in sage.structure.misc.getattr_from_other_class (sage/structure/misc.c:1427)()\n\nAttributeError: 'MacdonaldPolynomials_p_with_category' object has no attribute '_s'\n```\n",
    "created_at": "2012-07-21T11:13:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153419",
    "user": "https://github.com/simon-king-jena"
}
```

If I understand correctly, the coercion maps are supposed to go via Schur basis. But while one has

```
sage: H = MacdonaldPolynomialsH(QQ)
sage: P = MacdonaldPolynomialsP(QQ)
sage: m = SFAMonomial(P.base_ring())
sage: Ht = MacdonaldPolynomialsHt(QQ)
sage: Ht._s
Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
sage: Ht._s.has_coerce_map_from(P)
True
```

one has (or does in fact *not* have)

```
sage: P._s
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)

/home/simon/SAGE/prerelease/sage-5.2.rc0/<ipython console> in <module>()

/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/structure/parent.so in sage.structure.parent.Parent.__getattr__ (sage/structure/parent.c:5967)()

/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/structure/misc.so in sage.structure.misc.getattr_from_other_class (sage/structure/misc.c:1427)()

AttributeError: 'MacdonaldPolynomials_p_with_category' object has no attribute '_s'
sage: P._self_to_s(P.one())
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)

/home/simon/SAGE/prerelease/sage-5.2.rc0/<ipython console> in <module>()

/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/combinat/sf/macdonald.pyc in _self_to_s(self, x)
    421             (3*q-6)*s[1, 1, 1] + (-4*q+1)*s[2, 1]
    422         """
--> 423         return self._s._from_cache(x, self._s_cache, self._self_to_s_cache, q = self.q, t = self.t) # do we want this t = self.t?
    424 
    425     def c1(self, part):

/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/structure/parent.so in sage.structure.parent.Parent.__getattr__ (sage/structure/parent.c:5967)()

/home/simon/SAGE/prerelease/sage-5.2.rc0/local/lib/python2.7/site-packages/sage/structure/misc.so in sage.structure.misc.getattr_from_other_class (sage/structure/misc.c:1427)()

AttributeError: 'MacdonaldPolynomials_p_with_category' object has no attribute '_s'
```




---

archive/issue_comments_153420.json:
```json
{
    "body": "Looking at sage/combinat/sf/macdonald.py, there is a cache from different realisations (bases) to Schur basis. There are two exceptions: The P-basis and the Q-basis. Why? Perhaps that is the culprit?",
    "created_at": "2012-07-21T11:18:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153420",
    "user": "https://github.com/simon-king-jena"
}
```

Looking at sage/combinat/sf/macdonald.py, there is a cache from different realisations (bases) to Schur basis. There are two exceptions: The P-basis and the Q-basis. Why? Perhaps that is the culprit?



---

archive/issue_comments_153421.json:
```json
{
    "body": "Adding\n\n```\n    def _coerce_map_from_(self,S):\n        if not hasattr(self,'_s'):\n            return None\n        try:\n            S_to_s = self._s.coerce_map_from(S)\n        except:\n            return None\n        if S_to_s is None:\n            return None\n        return self.coerce_map_from(self._s)*S_to_s\n```\n\nto `MacdonaldPolynomials_generic` solves the problem. But I first have to check whether the original coercion from P to Ht (which exists if one does *not* do `m(P.one())`) is the same.",
    "created_at": "2012-07-21T12:13:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153421",
    "user": "https://github.com/simon-king-jena"
}
```

Adding

```
    def _coerce_map_from_(self,S):
        if not hasattr(self,'_s'):
            return None
        try:
            S_to_s = self._s.coerce_map_from(S)
        except:
            return None
        if S_to_s is None:
            return None
        return self.coerce_map_from(self._s)*S_to_s
```

to `MacdonaldPolynomials_generic` solves the problem. But I first have to check whether the original coercion from P to Ht (which exists if one does *not* do `m(P.one())`) is the same.



---

archive/issue_comments_153422.json:
```json
{
    "body": "Helas. It is *not* the same. Doing the above, one gets an awfully complicated composition of maps, probably rather inefficient.\n\n```\nsage: H = MacdonaldPolynomialsH(QQ)\nsage: P = MacdonaldPolynomialsP(QQ)\nsage: m = SFAMonomial(P.base_ring())\nsage: Ht = MacdonaldPolynomialsHt(QQ)\nsage: Ht.coerce_map_from(P)\nComposite map:\n  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n  To:   Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n  Defn:   Composite map:\n          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n          Defn:   Composite map:\n                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                  To:   Macdonald polynomials in the H basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                  Defn:   Composite map:\n                          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                          Defn:   Composite map:\n                                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                  To:   Macdonald polynomials in the J basis with q=q and t=t over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                  Defn:   Composite map:\n                                          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                                          Defn:   Composite map:\n                                                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                                  To:   Macdonald polynomials in the S basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                                  Defn:   Composite map:\n                                                          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                                          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                                                          Defn:   Generic morphism:\n                                                                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                                                  To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                                                then\n                                                                  Generic morphism:\n                                                                  From: Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                                                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                                                        then\n                                                          Generic morphism:\n                                                          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                                                          To:   Macdonald polynomials in the S basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                                then\n                                                  Generic morphism:\n                                                  From: Macdonald polynomials in the S basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                                        then\n                                          Generic morphism:\n                                          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                                          To:   Macdonald polynomials in the J basis with q=q and t=t over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                then\n                                  Generic morphism:\n                                  From: Macdonald polynomials in the J basis with q=q and t=t over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                        then\n                          Generic morphism:\n                          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n                          To:   Macdonald polynomials in the H basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                then\n                  Generic morphism:\n                  From: Macdonald polynomials in the H basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n        then\n          Generic morphism:\n          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n          To:   Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n```\n",
    "created_at": "2012-07-21T12:27:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153422",
    "user": "https://github.com/simon-king-jena"
}
```

Helas. It is *not* the same. Doing the above, one gets an awfully complicated composition of maps, probably rather inefficient.

```
sage: H = MacdonaldPolynomialsH(QQ)
sage: P = MacdonaldPolynomialsP(QQ)
sage: m = SFAMonomial(P.base_ring())
sage: Ht = MacdonaldPolynomialsHt(QQ)
sage: Ht.coerce_map_from(P)
Composite map:
  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
  To:   Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
  Defn:   Composite map:
          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
          Defn:   Composite map:
                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                  To:   Macdonald polynomials in the H basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                  Defn:   Composite map:
                          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                          Defn:   Composite map:
                                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                  To:   Macdonald polynomials in the J basis with q=q and t=t over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                  Defn:   Composite map:
                                          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                                          Defn:   Composite map:
                                                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                                  To:   Macdonald polynomials in the S basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                                  Defn:   Composite map:
                                                          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                                          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                                                          Defn:   Generic morphism:
                                                                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                                                  To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                                                then
                                                                  Generic morphism:
                                                                  From: Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                                                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                                                        then
                                                          Generic morphism:
                                                          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                                                          To:   Macdonald polynomials in the S basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                                then
                                                  Generic morphism:
                                                  From: Macdonald polynomials in the S basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                                        then
                                          Generic morphism:
                                          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                                          To:   Macdonald polynomials in the J basis with q=q and t=t over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                then
                                  Generic morphism:
                                  From: Macdonald polynomials in the J basis with q=q and t=t over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                        then
                          Generic morphism:
                          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
                          To:   Macdonald polynomials in the H basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                then
                  Generic morphism:
                  From: Macdonald polynomials in the H basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
        then
          Generic morphism:
          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
          To:   Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
```




---

archive/issue_comments_153423.json:
```json
{
    "body": "I added\n\n```python\n    def test_coercions(self):\n        return self._coerce_from_hash\n```\n\nto self.structure.parent.Parent, and obtain\n\n```\nsage: H = MacdonaldPolynomialsH(QQ)\nsage: P = MacdonaldPolynomialsP(QQ)\nsage: m = SFAMonomial(P.base_ring())\nsage: Ht = MacdonaldPolynomialsHt(QQ)\nsage: P in Ht.test_coercions()\nFalse\nsage: P.one()\nMcdP[]\nsage: P in Ht.test_coercions()\nFalse\nsage: phi = m.coerce_map_from(P)\nsage: P in Ht.test_coercions()\nTrue\nsage: Ht.test_coercions()[P] is None\nTrue\n```\n\n\nIn other words, trying to find the coercion from P to m changes the coercion cache of Ht. Funny.",
    "created_at": "2012-07-21T14:20:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153423",
    "user": "https://github.com/simon-king-jena"
}
```

I added

```python
    def test_coercions(self):
        return self._coerce_from_hash
```

to self.structure.parent.Parent, and obtain

```
sage: H = MacdonaldPolynomialsH(QQ)
sage: P = MacdonaldPolynomialsP(QQ)
sage: m = SFAMonomial(P.base_ring())
sage: Ht = MacdonaldPolynomialsHt(QQ)
sage: P in Ht.test_coercions()
False
sage: P.one()
McdP[]
sage: P in Ht.test_coercions()
False
sage: phi = m.coerce_map_from(P)
sage: P in Ht.test_coercions()
True
sage: Ht.test_coercions()[P] is None
True
```


In other words, trying to find the coercion from P to m changes the coercion cache of Ht. Funny.



---

archive/issue_comments_153424.json:
```json
{
    "body": "Hi Simon!\n\nThank you for investigating this. I should mention that Mike Zabrocki and I just finished a patch in [http://trac.sagemath.org/sage_trac/ticket/5457](http://trac.sagemath.org/sage_trac/ticket/5457) which changes the syntax for symmetric functions. As far as I know the coercion also breaks in that set-up.\n\nAt the Sage Days in Minneapolis last week, Franco Saliola also told me that he was hit by the coercion bug in their code on quasisymmetric functions [http://trac.sagemath.org/sage_trac/ticket/8899](http://trac.sagemath.org/sage_trac/ticket/8899). Franco, could you post your precise failure?\n\nAnne",
    "created_at": "2012-07-21T15:53:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153424",
    "user": "https://github.com/anneschilling"
}
```

Hi Simon!

Thank you for investigating this. I should mention that Mike Zabrocki and I just finished a patch in [http://trac.sagemath.org/sage_trac/ticket/5457](http://trac.sagemath.org/sage_trac/ticket/5457) which changes the syntax for symmetric functions. As far as I know the coercion also breaks in that set-up.

At the Sage Days in Minneapolis last week, Franco Saliola also told me that he was hit by the coercion bug in their code on quasisymmetric functions [http://trac.sagemath.org/sage_trac/ticket/8899](http://trac.sagemath.org/sage_trac/ticket/8899). Franco, could you post your precise failure?

Anne



---

archive/issue_comments_153425.json:
```json
{
    "body": "Replying to [comment:14 aschilling]:\n \n> At the Sage Days in Minneapolis last week, Franco Saliola also told me that he was hit by the coercion bug in their code on quasisymmetric functions [http://trac.sagemath.org/sage_trac/ticket/8899](http://trac.sagemath.org/sage_trac/ticket/8899). Franco, could you post your precise failure?\n\nIf I recall correctly, we didn't hit upon the problem with the current code, but with new bases that we implemented on top of it. These new bases are not going in to Sage as part of #8899 (we are only implementing the \"classical\" bases in this first stage).\n\nFranco",
    "created_at": "2012-07-22T01:28:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153425",
    "user": "https://github.com/saliola"
}
```

Replying to [comment:14 aschilling]:
 
> At the Sage Days in Minneapolis last week, Franco Saliola also told me that he was hit by the coercion bug in their code on quasisymmetric functions [http://trac.sagemath.org/sage_trac/ticket/8899](http://trac.sagemath.org/sage_trac/ticket/8899). Franco, could you post your precise failure?

If I recall correctly, we didn't hit upon the problem with the current code, but with new bases that we implemented on top of it. These new bases are not going in to Sage as part of #8899 (we are only implementing the "classical" bases in this first stage).

Franco



---

archive/issue_comments_153426.json:
```json
{
    "body": "Replying to [comment:10 SimonKing]:\n> Helas. It is *not* the same. Doing the above, one gets an awfully complicated composition of maps, probably rather inefficient.\n\nYes that's the well know issue (#8878) of the current coercion model implementation: it does a depth first search rather than a breath first.",
    "created_at": "2012-07-22T08:01:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153426",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:10 SimonKing]:
> Helas. It is *not* the same. Doing the above, one gets an awfully complicated composition of maps, probably rather inefficient.

Yes that's the well know issue (#8878) of the current coercion model implementation: it does a depth first search rather than a breath first.



---

archive/issue_comments_153427.json:
```json
{
    "body": "> Question: Why is that method not overridden for the different realisations of `MacdonaldPolynomials`?\n\nBecause the coercions are registered explicitly during the initialization of Sym / macdonald polynomials. This is better because it leaves maximal freedom to the coercion model (e.g. the coercion model can't do transitivity with _coerce_map_from).\n\nCheers,\n                          Nicolas",
    "created_at": "2012-07-22T08:04:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153427",
    "user": "https://github.com/nthiery"
}
```

> Question: Why is that method not overridden for the different realisations of `MacdonaldPolynomials`?

Because the coercions are registered explicitly during the initialization of Sym / macdonald polynomials. This is better because it leaves maximal freedom to the coercion model (e.g. the coercion model can't do transitivity with _coerce_map_from).

Cheers,
                          Nicolas



---

archive/issue_comments_153428.json:
```json
{
    "body": "I think I can explain (and thus, solve) the problem!\n\nThe bug is in the backtracking algorithm for finding a coercion path.\n\nEvery parent A has a list of other parents B1, B2, ... such that a coercion from B1, B2 to A is registered. When searching for a coercion from parent X to A, and a direct coercion is not registered, then a coercion from X to B1, B2, ... is (in that order!) is searched. But of course one must avoid infinite recursions, and thus any coercion path from X to B1, B2, via X is disregarded. Disregarding one node in the backtracking algorithm is the purpose of _register_pair in sage.structure.parent.\n\nNow consider the following situation, where arrows denote registered coercions (partially the coercions are registered in *both* directions - that's what happening in the symmetric functions code):\n\n```\n  X -> B2 <-> A <-> B1\n```\n\n\nWe first ask for a coercion from X to A.\n\nThere is no coercion from X to A found in the cache. Thus, we disregard (X,A) in our backtracking algorithm, and search for a coercion from X to B1. The only coercion path from X to B1 would be via A, but that is disregarded in the backtracking algorithm. The absence of a coercion from X to B1 is cached. In the next step, a coercion from X to A via B2 is found, cached and returned.\n\nBut when later asking for a coercion from X to B1, the cache states that there is no coercion!\n\nHere's the bug: The absence of a coercion from X to B1 must *only* be cached if X is not the starting point of any disregarded search path (such as (X,A) in the example above), with the only exception of (X,B1).",
    "created_at": "2012-07-22T08:23:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153428",
    "user": "https://github.com/simon-king-jena"
}
```

I think I can explain (and thus, solve) the problem!

The bug is in the backtracking algorithm for finding a coercion path.

Every parent A has a list of other parents B1, B2, ... such that a coercion from B1, B2 to A is registered. When searching for a coercion from parent X to A, and a direct coercion is not registered, then a coercion from X to B1, B2, ... is (in that order!) is searched. But of course one must avoid infinite recursions, and thus any coercion path from X to B1, B2, via X is disregarded. Disregarding one node in the backtracking algorithm is the purpose of _register_pair in sage.structure.parent.

Now consider the following situation, where arrows denote registered coercions (partially the coercions are registered in *both* directions - that's what happening in the symmetric functions code):

```
  X -> B2 <-> A <-> B1
```


We first ask for a coercion from X to A.

There is no coercion from X to A found in the cache. Thus, we disregard (X,A) in our backtracking algorithm, and search for a coercion from X to B1. The only coercion path from X to B1 would be via A, but that is disregarded in the backtracking algorithm. The absence of a coercion from X to B1 is cached. In the next step, a coercion from X to A via B2 is found, cached and returned.

But when later asking for a coercion from X to B1, the cache states that there is no coercion!

Here's the bug: The absence of a coercion from X to B1 must *only* be cached if X is not the starting point of any disregarded search path (such as (X,A) in the example above), with the only exception of (X,B1).



---

archive/issue_comments_153429.json:
```json
{
    "body": "And while we are at it: _register_pair uses a dictionary in order to implement a set. I think it would be more efficient to use a set right away.",
    "created_at": "2012-07-22T08:25:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153429",
    "user": "https://github.com/simon-king-jena"
}
```

And while we are at it: _register_pair uses a dictionary in order to implement a set. I think it would be more efficient to use a set right away.



---

archive/issue_comments_153430.json:
```json
{
    "body": "Replying to [comment:19 SimonKing]:\n> And while we are at it: _register_pair uses a dictionary in order to implement a set. I think it would be more efficient to use a set right away.\n\nNo, to my surprise, it isn't:\n\n```\nsage: cython(\"\"\"\n....: def testD(dict D):\n....:     cdef int i\n....:     for i from 0<=i<10000:\n....:         b = (i in D)\n....: def testS(set S):\n....:     cdef int i\n....:     for i from 0<=i<10000:\n....:         b = (i in S)\n....: \"\"\")\nsage: D = dict([(i,1) for i in range(5000)])\nsage: S = set(range(5000))\nsage: %timeit testD(D)\n625 loops, best of 3: 495 \u00b5s per loop\nsage: %timeit testS(S)\n625 loops, best of 3: 520 \u00b5s per loop\nsage: %timeit testD(D)\n625 loops, best of 3: 496 \u00b5s per loop\nsage: %timeit testS(S)\n625 loops, best of 3: 520 \u00b5s per loop\n```\n\nSets seem slower than dictionaries by 5%.",
    "created_at": "2012-07-22T08:31:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153430",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:19 SimonKing]:
> And while we are at it: _register_pair uses a dictionary in order to implement a set. I think it would be more efficient to use a set right away.

No, to my surprise, it isn't:

```
sage: cython("""
....: def testD(dict D):
....:     cdef int i
....:     for i from 0<=i<10000:
....:         b = (i in D)
....: def testS(set S):
....:     cdef int i
....:     for i from 0<=i<10000:
....:         b = (i in S)
....: """)
sage: D = dict([(i,1) for i in range(5000)])
sage: S = set(range(5000))
sage: %timeit testD(D)
625 loops, best of 3: 495 µs per loop
sage: %timeit testS(S)
625 loops, best of 3: 520 µs per loop
sage: %timeit testD(D)
625 loops, best of 3: 496 µs per loop
sage: %timeit testS(S)
625 loops, best of 3: 520 µs per loop
```

Sets seem slower than dictionaries by 5%.



---

archive/issue_comments_153431.json:
```json
{
    "body": "Replying to [comment:16 nthiery]:\n> Yes that's the well know issue (#8878) of the current coercion model implementation: it does a depth first search rather than a breath first.\n\nOK. I think #8878 would involve a considerable amount of work. So, for simplicity, I suggest to fix the cache bug in the current implementation of depth first search *here*. And if in future someone will tackle #8878, he/she should do so on top of that fix.",
    "created_at": "2012-07-22T08:39:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153431",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:16 nthiery]:
> Yes that's the well know issue (#8878) of the current coercion model implementation: it does a depth first search rather than a breath first.

OK. I think #8878 would involve a considerable amount of work. So, for simplicity, I suggest to fix the cache bug in the current implementation of depth first search *here*. And if in future someone will tackle #8878, he/she should do so on top of that fix.



---

archive/issue_comments_153432.json:
```json
{
    "body": "Replying to [comment:21 SimonKing]:\n> OK. I think #8878 would involve a considerable amount of work. So, for simplicity, I suggest to fix the cache bug in the current implementation of depth first search *here*. And if in future someone will tackle #8878, he/she should do so on top of that fix.\n\nI actually have an implementation for #8878 in the queue I had written two years ago; however it's disabled because there remained quite some work cleaning up Sage here and there for things to work smoothly.\n\nSo, yes, if you have a quick fix to the depth first search, please go ahead; my patch certainly needs a lot of rebasing anyway.\n\nCheers,\n                             Nicolas",
    "created_at": "2012-07-22T09:00:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153432",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:21 SimonKing]:
> OK. I think #8878 would involve a considerable amount of work. So, for simplicity, I suggest to fix the cache bug in the current implementation of depth first search *here*. And if in future someone will tackle #8878, he/she should do so on top of that fix.

I actually have an implementation for #8878 in the queue I had written two years ago; however it's disabled because there remained quite some work cleaning up Sage here and there for things to work smoothly.

So, yes, if you have a quick fix to the depth first search, please go ahead; my patch certainly needs a lot of rebasing anyway.

Cheers,
                             Nicolas



---

archive/issue_comments_153433.json:
```json
{
    "body": "Question: Is #5457 very close to being positively reviewed? Namely, we must decide whether we use the old syntax for the to-be-written doctest (in that case, this ticket would be a dependency for #5457), or use the new syntax (in that case, due to deprecation warnings, #5457 would become a dependency for this ticket).\n\nFor now, I will use the old syntax.",
    "created_at": "2012-07-22T09:06:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153433",
    "user": "https://github.com/simon-king-jena"
}
```

Question: Is #5457 very close to being positively reviewed? Namely, we must decide whether we use the old syntax for the to-be-written doctest (in that case, this ticket would be a dependency for #5457), or use the new syntax (in that case, due to deprecation warnings, #5457 would become a dependency for this ticket).

For now, I will use the old syntax.



---

archive/issue_comments_153434.json:
```json
{
    "body": "The attached patch seems to fix the problem.\n\nQuestions:\n\n__Is there a speed regression? __\n\nWith my patch, the absence of a coercion from X to Y is *only* cached, if no coercion path from X to Z (with Z different from Y) is temporarily disabled. But if there *really* is no coercion from X to Y, then the fix might involve a speed regression. Potential solution: If the old buggy depth first algorithm would cache the absence of a coercion from X to Y, while the new fixed version wouldn't, then we might investigate the paths from X to Y again, right after re-enabling the other paths starting from X.\n\n__What about #5457__\n\nI did not run the tests, yet. But the new test in my patch would fail because of the deprecation warnings introduced by #5457. So, we must decide whether making #5457 depend on this ticket or the other way around?\n\nFor the record: Without #5457, I now get\n\n```\nsage: H = MacdonaldPolynomialsH(QQ)\nsage: P = MacdonaldPolynomialsP(QQ)\nsage: m = SFAMonomial(P.base_ring())\nsage: Ht = MacdonaldPolynomialsHt(QQ)\nsage: m(P.one())\nm[]\nsage: Ht(P.one())\nMcdHt[]\n```\n\nand\n\n```\nsage: Ht.coerce_map_from(P)\nComposite map:\n  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n  To:   Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n  Defn:   Composite map:\n          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n          Defn:   Generic morphism:\n                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                  To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                then\n                  Generic morphism:\n                  From: Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n        then\n          Generic morphism:\n          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis\n          To:   Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field\n```\n\n(the latter being the same as in vanilla sage)",
    "created_at": "2012-07-22T09:24:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153434",
    "user": "https://github.com/simon-king-jena"
}
```

The attached patch seems to fix the problem.

Questions:

__Is there a speed regression? __

With my patch, the absence of a coercion from X to Y is *only* cached, if no coercion path from X to Z (with Z different from Y) is temporarily disabled. But if there *really* is no coercion from X to Y, then the fix might involve a speed regression. Potential solution: If the old buggy depth first algorithm would cache the absence of a coercion from X to Y, while the new fixed version wouldn't, then we might investigate the paths from X to Y again, right after re-enabling the other paths starting from X.

__What about #5457__

I did not run the tests, yet. But the new test in my patch would fail because of the deprecation warnings introduced by #5457. So, we must decide whether making #5457 depend on this ticket or the other way around?

For the record: Without #5457, I now get

```
sage: H = MacdonaldPolynomialsH(QQ)
sage: P = MacdonaldPolynomialsP(QQ)
sage: m = SFAMonomial(P.base_ring())
sage: Ht = MacdonaldPolynomialsHt(QQ)
sage: m(P.one())
m[]
sage: Ht(P.one())
McdHt[]
```

and

```
sage: Ht.coerce_map_from(P)
Composite map:
  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
  To:   Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
  Defn:   Composite map:
          From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
          To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
          Defn:   Generic morphism:
                  From: Macdonald polynomials in the P basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                  To:   Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                then
                  Generic morphism:
                  From: Macdonald polynomials in the J basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
                  To:   Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
        then
          Generic morphism:
          From: Symmetric Function Algebra over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field, Schur symmetric functions as basis
          To:   Macdonald polynomials in the Ht basis over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field
```

(the latter being the same as in vanilla sage)



---

archive/issue_comments_153435.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2012-07-22T09:24:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153435",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_153436.json:
```json
{
    "body": "For the record: With my patch, all tests pass on bsd.math. However, with the patch, it takes 6403.9 seconds, but it is 6106.7 seconds without the patch. Hence, it could be that we have a serious regression, but of course it could also be due to the machine being busy. Should be investigated.",
    "created_at": "2012-07-22T12:02:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153436",
    "user": "https://github.com/simon-king-jena"
}
```

For the record: With my patch, all tests pass on bsd.math. However, with the patch, it takes 6403.9 seconds, but it is 6106.7 seconds without the patch. Hence, it could be that we have a serious regression, but of course it could also be due to the machine being busy. Should be investigated.



---

archive/issue_comments_153437.json:
```json
{
    "body": "Another data point: On my laptop, the tests for sage/schemes/elliptic_curves took 431.4 seconds without the patch, but 441.4 seconds with the patch. That means a regression of 2.3%, which probably isn't significant. But I'd feel better if the reviewer did some timings as well.",
    "created_at": "2012-07-22T12:52:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153437",
    "user": "https://github.com/simon-king-jena"
}
```

Another data point: On my laptop, the tests for sage/schemes/elliptic_curves took 431.4 seconds without the patch, but 441.4 seconds with the patch. That means a regression of 2.3%, which probably isn't significant. But I'd feel better if the reviewer did some timings as well.



---

archive/issue_comments_153438.json:
```json
{
    "body": "Replying to [comment:23 SimonKing]:\n> Question: Is #5457 very close to being positively reviewed? Namely, we must decide whether we use the old syntax for the to-be-written doctest (in that case, this ticket would be a dependency for #5457), or use the new syntax (in that case, due to deprecation warnings, #5457 would become a dependency for this ticket).\n> \n> For now, I will use the old syntax.\n\nMike and I already cross reviewed 5457. We are just waiting for green light from Dan Bump or Franco Saliola. So hopefully (!?) 5457 will go in soon.\n\nAnne",
    "created_at": "2012-07-23T07:30:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153438",
    "user": "https://github.com/anneschilling"
}
```

Replying to [comment:23 SimonKing]:
> Question: Is #5457 very close to being positively reviewed? Namely, we must decide whether we use the old syntax for the to-be-written doctest (in that case, this ticket would be a dependency for #5457), or use the new syntax (in that case, due to deprecation warnings, #5457 would become a dependency for this ticket).
> 
> For now, I will use the old syntax.

Mike and I already cross reviewed 5457. We are just waiting for green light from Dan Bump or Franco Saliola. So hopefully (!?) 5457 will go in soon.

Anne



---

archive/issue_comments_153439.json:
```json
{
    "body": "Replying to [comment:27 aschilling]:\n> Replying to [comment:23 SimonKing]:\n> > Question: Is #5457 very close to being positively reviewed? Namely, we must decide whether we use the old syntax for the to-be-written doctest (in that case, this ticket would be a dependency for #5457), or use the new syntax (in that case, due to deprecation warnings, #5457 would become a dependency for this ticket).\n> > \n> > For now, I will use the old syntax.\n> \n> Mike and I already cross reviewed 5457. We are just waiting for green light from Dan Bump or Franco Saliola. So hopefully (!?) 5457 will go in soon.\n\nOK. The only problem related with #5457 is the syntax in one new doctest. I suggest that I provide a second optional patch (like: if #5457 is in then use both patches, otherwise only use one patch).",
    "created_at": "2012-07-23T08:20:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153439",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:27 aschilling]:
> Replying to [comment:23 SimonKing]:
> > Question: Is #5457 very close to being positively reviewed? Namely, we must decide whether we use the old syntax for the to-be-written doctest (in that case, this ticket would be a dependency for #5457), or use the new syntax (in that case, due to deprecation warnings, #5457 would become a dependency for this ticket).
> > 
> > For now, I will use the old syntax.
> 
> Mike and I already cross reviewed 5457. We are just waiting for green light from Dan Bump or Franco Saliola. So hopefully (!?) 5457 will go in soon.

OK. The only problem related with #5457 is the syntax in one new doctest. I suggest that I provide a second optional patch (like: if #5457 is in then use both patches, otherwise only use one patch).



---

archive/issue_comments_153440.json:
```json
{
    "body": "Attachment [trac12969_fix_coercion_cache.patch](tarball://root/attachments/some-uuid/ticket12969/trac12969_fix_coercion_cache.patch) by @simon-king-jena created at 2012-07-23 11:30:58\n\nUsing the old syntax for symmetric function algebras (pre-#5457)",
    "created_at": "2012-07-23T11:30:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153440",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac12969_fix_coercion_cache.patch](tarball://root/attachments/some-uuid/ticket12969/trac12969_fix_coercion_cache.patch) by @simon-king-jena created at 2012-07-23 11:30:58

Using the old syntax for symmetric function algebras (pre-#5457)



---

archive/issue_comments_153441.json:
```json
{
    "body": "I have slightly updated the patch. Only difference: A dictionary, that previously was declared as \"cdef object\", is now \"cdef dict\".\n\nI repeated timings for `sage -t devel/sage/sage/schemes/elliptic_curves/`. I did three runs, the time is in seconds:\n\n__Vanilla sage-5.2.rc0__\n\n442.5, 441.9, 442.3\n\n__sage-5.2.rc0 plus the patch__\n\n443.3, 440.8, 442.1\n\nSo, apparently the 2.3% regression that I found earlier has been random noise.",
    "created_at": "2012-07-23T11:33:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153441",
    "user": "https://github.com/simon-king-jena"
}
```

I have slightly updated the patch. Only difference: A dictionary, that previously was declared as "cdef object", is now "cdef dict".

I repeated timings for `sage -t devel/sage/sage/schemes/elliptic_curves/`. I did three runs, the time is in seconds:

__Vanilla sage-5.2.rc0__

442.5, 441.9, 442.3

__sage-5.2.rc0 plus the patch__

443.3, 440.8, 442.1

So, apparently the 2.3% regression that I found earlier has been random noise.



---

archive/issue_comments_153442.json:
```json
{
    "body": "Attachment [trac12969_rel_5457.patch](tarball://root/attachments/some-uuid/ticket12969/trac12969_rel_5457.patch) by @simon-king-jena created at 2012-07-23 11:39:02\n\nRewrite one doctest to use the syntax introduced in #5457",
    "created_at": "2012-07-23T11:39:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153442",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac12969_rel_5457.patch](tarball://root/attachments/some-uuid/ticket12969/trac12969_rel_5457.patch) by @simon-king-jena created at 2012-07-23 11:39:02

Rewrite one doctest to use the syntax introduced in #5457



---

archive/issue_comments_153443.json:
```json
{
    "body": "I have attached a second patch. It is *only* needed if #5457 is applied.\n\nSince there seems to be no regression, I think it can now be reviewed.\n\nFor the release manager: Use the second patch on top of that, as soon as #5457 is merged.\n\nFor the patchbot:\n\nApply trac12969_fix_coercion_cache.patch",
    "created_at": "2012-07-23T11:42:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153443",
    "user": "https://github.com/simon-king-jena"
}
```

I have attached a second patch. It is *only* needed if #5457 is applied.

Since there seems to be no regression, I think it can now be reviewed.

For the release manager: Use the second patch on top of that, as soon as #5457 is merged.

For the patchbot:

Apply trac12969_fix_coercion_cache.patch



---

archive/issue_comments_153444.json:
```json
{
    "body": "The patch seems to work. But meanwhile I wonder whether my fix is really correct.\n\nThe aim is: Find a coercion from X to Y.\n\nBacktracking means: We know some B1,B2,... that coerce into Y. Hence, we try to find a coercion from X to B1,B2,... but avoiding Y, so that there is no infinite loop. That's why the pair (X,Y) is temporarily disregarded when searching for a coerce path.\n\nIn particular, the recursive search will always start at X.\n\nHence, it was my understanding that all temporarily disregarded paths start at X. That's why I wrote\n\n```python\ncdef bint _may_cache_none(x, y, tag) except -1:\n    # Are we allowed to cache the absence of a coercion\n    # from y to x? We are only allowed, if y is *not*\n    # part of any coerce path that is temporarily disregarded,\n    # with the only exception of the path from y to x.\n    # See #12969.\n    cdef EltPair P\n    for P in _coerce_test_dict.iterkeys():\n        if (P.y is y) and (P.x is not x) and (P.tag is tag):\n            return 0\n    return 1\n```\n\n\nHowever, to be on the safe side, I tested whether I drew the correct conclusion. Apparently I didn't.\n\nNamely, when Sage starts and a coercion from the complex double field into, say, the integer ring is sought, then the path from the complex lazy field to the complex double field is disregarded. Also, while trying to find a coercion from the complex lazy field to the integers, the search path from \"Number Field in I with defining polynomial x<sup>2</sup> + 1\" to the rational field is temporarily disregarded.\n\nEven weirder: When doing `m(P.one())` in the example from the ticket description, the coercion from \"<type 'str'>\" to Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field is disregarded, while searching for a coerce path from None (sic!) to the ring of integers.\n\nI wonder how this can possibly happen, given how backtracking works. And what does that mean for the patch? I guess the cleanest solution would be to find out why the wrong paths are temporarily disregarded, and why the heck a coercion from None to anything is requested.",
    "created_at": "2012-07-24T07:01:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153444",
    "user": "https://github.com/simon-king-jena"
}
```

The patch seems to work. But meanwhile I wonder whether my fix is really correct.

The aim is: Find a coercion from X to Y.

Backtracking means: We know some B1,B2,... that coerce into Y. Hence, we try to find a coercion from X to B1,B2,... but avoiding Y, so that there is no infinite loop. That's why the pair (X,Y) is temporarily disregarded when searching for a coerce path.

In particular, the recursive search will always start at X.

Hence, it was my understanding that all temporarily disregarded paths start at X. That's why I wrote

```python
cdef bint _may_cache_none(x, y, tag) except -1:
    # Are we allowed to cache the absence of a coercion
    # from y to x? We are only allowed, if y is *not*
    # part of any coerce path that is temporarily disregarded,
    # with the only exception of the path from y to x.
    # See #12969.
    cdef EltPair P
    for P in _coerce_test_dict.iterkeys():
        if (P.y is y) and (P.x is not x) and (P.tag is tag):
            return 0
    return 1
```


However, to be on the safe side, I tested whether I drew the correct conclusion. Apparently I didn't.

Namely, when Sage starts and a coercion from the complex double field into, say, the integer ring is sought, then the path from the complex lazy field to the complex double field is disregarded. Also, while trying to find a coercion from the complex lazy field to the integers, the search path from "Number Field in I with defining polynomial x<sup>2</sup> + 1" to the rational field is temporarily disregarded.

Even weirder: When doing `m(P.one())` in the example from the ticket description, the coercion from "<type 'str'>" to Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field is disregarded, while searching for a coerce path from None (sic!) to the ring of integers.

I wonder how this can possibly happen, given how backtracking works. And what does that mean for the patch? I guess the cleanest solution would be to find out why the wrong paths are temporarily disregarded, and why the heck a coercion from None to anything is requested.



---

archive/issue_comments_153445.json:
```json
{
    "body": "I found that a coercion from None is sought when asking the following:\n\n```\nsage: P = QQ['x','y','a']\nsage: P.has_coerce_map_from(str)\n```\n\n\nI suggest to fix that *here*, unless it is too complicated.",
    "created_at": "2012-07-24T07:42:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153445",
    "user": "https://github.com/simon-king-jena"
}
```

I found that a coercion from None is sought when asking the following:

```
sage: P = QQ['x','y','a']
sage: P.has_coerce_map_from(str)
```


I suggest to fix that *here*, unless it is too complicated.



---

archive/issue_comments_153446.json:
```json
{
    "body": "Got it. In sage/structure/parent_old.pyx, which unfortunately is still involved in `MPolynomialRing_libsingular`, there is line 152:\n\n```\n            sage_type = py_scalar_parent(S)\n```\n\nHowever, is S is `<type 'str'>` then its py_scalar_parent is None (which seems wrong, or if it isn't wrong then one should at least catch the special case None). The function py_scalar_parent is in sage/structure/coerce.pyx.",
    "created_at": "2012-07-24T07:51:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153446",
    "user": "https://github.com/simon-king-jena"
}
```

Got it. In sage/structure/parent_old.pyx, which unfortunately is still involved in `MPolynomialRing_libsingular`, there is line 152:

```
            sage_type = py_scalar_parent(S)
```

However, is S is `<type 'str'>` then its py_scalar_parent is None (which seems wrong, or if it isn't wrong then one should at least catch the special case None). The function py_scalar_parent is in sage/structure/coerce.pyx.



---

archive/issue_comments_153447.json:
```json
{
    "body": "It turns out: When making a special case when py_scalar_parent is None, then indeed *in our example* it is always the case that the starting point of a coerce path we are looking for is the same as the starting point of any path we temporarily disregard. This is how it should be. I will update my patch a bit later.\n\nHowever, when starting Sage, it is still the case that the path from `Number Field in I with defining polynomial x^2 + 1` to `Rational Field` is blocked while searching for a path from `Complex Lazy Field` to `Integer Ring`, or `Algebraic Field` to `Real Field with 53 bits of precision` is blocked while searching for `<type 'float'>` to `Algebraic Field`.\n\nBut I think I understand that as well: When searching for a coercion from P to, e.g., the complex field CC, the first thing the coercion model does is to temporarily disregard (P,CC) for the backtracking algorithm. Then, `CC._coerce_map_from_(P)` is called at some point. But the last line of that method calls `CC._coerce_map_via([CLF],P)`. Hence, while (P,CC) is still disregarded, not only a coerce path from P to CLF but also a coerce path from CLF to CC is sought.\n\nI tend to say that it is the responsibility of the person writing `_coerce_map_from_` for a parent to avoid ill effects.\n\nTherefore, I still think that the solution of my patch (\"do not cache the absence of a coerce path from A to B if there is any temporarily disregarded path that stars at A\") is fine. If the reviewer disagrees then we may consider a very strict solution: \"do not cache the absence of a coerce path from A to B if there is any temporarily disregarded path besides (A,B) itself.\"\n\nThoughts?",
    "created_at": "2012-07-24T08:43:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153447",
    "user": "https://github.com/simon-king-jena"
}
```

It turns out: When making a special case when py_scalar_parent is None, then indeed *in our example* it is always the case that the starting point of a coerce path we are looking for is the same as the starting point of any path we temporarily disregard. This is how it should be. I will update my patch a bit later.

However, when starting Sage, it is still the case that the path from `Number Field in I with defining polynomial x^2 + 1` to `Rational Field` is blocked while searching for a path from `Complex Lazy Field` to `Integer Ring`, or `Algebraic Field` to `Real Field with 53 bits of precision` is blocked while searching for `<type 'float'>` to `Algebraic Field`.

But I think I understand that as well: When searching for a coercion from P to, e.g., the complex field CC, the first thing the coercion model does is to temporarily disregard (P,CC) for the backtracking algorithm. Then, `CC._coerce_map_from_(P)` is called at some point. But the last line of that method calls `CC._coerce_map_via([CLF],P)`. Hence, while (P,CC) is still disregarded, not only a coerce path from P to CLF but also a coerce path from CLF to CC is sought.

I tend to say that it is the responsibility of the person writing `_coerce_map_from_` for a parent to avoid ill effects.

Therefore, I still think that the solution of my patch ("do not cache the absence of a coerce path from A to B if there is any temporarily disregarded path that stars at A") is fine. If the reviewer disagrees then we may consider a very strict solution: "do not cache the absence of a coerce path from A to B if there is any temporarily disregarded path besides (A,B) itself."

Thoughts?



---

archive/issue_comments_153448.json:
```json
{
    "body": "I haven't checked the detail, but the music sounds good. In any cases, we are just looking for a temporary fix that improves the situation until we rewrite completely the search algorithm; if it's not perfect, so be it. So I would say: if all tests pass, go for it.\n\nThanks!",
    "created_at": "2012-07-24T08:48:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153448",
    "user": "https://github.com/nthiery"
}
```

I haven't checked the detail, but the music sounds good. In any cases, we are just looking for a temporary fix that improves the situation until we rewrite completely the search algorithm; if it's not perfect, so be it. So I would say: if all tests pass, go for it.

Thanks!



---

archive/issue_comments_153449.json:
```json
{
    "body": "Shortcut when searching for a coercion from a type that is no parent (e.g., <str>)",
    "created_at": "2012-07-24T10:22:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153449",
    "user": "https://github.com/simon-king-jena"
}
```

Shortcut when searching for a coercion from a type that is no parent (e.g., <str>)



---

archive/issue_comments_153450.json:
```json
{
    "body": "Changing component from combinatorics to coercion.",
    "created_at": "2012-07-24T10:44:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153450",
    "user": "https://github.com/simon-king-jena"
}
```

Changing component from combinatorics to coercion.



---

archive/issue_comments_153451.json:
```json
{
    "body": "Attachment [trac_12969-avoid_coercion_from_none.patch](tarball://root/attachments/some-uuid/ticket12969/trac_12969-avoid_coercion_from_none.patch) by @simon-king-jena created at 2012-07-24 10:44:24\n\nI added another patch. Its purpose:\n\nPython types are sometimes considered as parents. There is a function sage.structure.coerce.py_scalar_parent returning a parent that corresponds to a type. Some types, e.g., `<type 'str'>`, do not correspond to a parent, hence py_scalar_parent(str) returns None.\n\nStill, the code in sage.structure.parent_old would try to construct a coercion from None (the non-existing parent) to self. The result is clear a-priori: There is no such coercion. The new patch establishes a short-cut.\n\nFor the reviewer: \n\nHere is a summary of how the main patch trac12969_fix_coercion_cache.patch works.\n\n1. When searching for a coerce path from A to B by back-tracking, it is vital that it is not attempted to construct a path from A to B in the inner parts of the recursion. Hence, the path from A to B is temporarily disregarded, by calling `_register_pair(B,A,\"coerce\")` -- that's existing code.\n2. When a coercion from A to B is found, then it is cached. When a coercion from A to B is not found, then the unpatched code would cache that as well. With the patch, the absence of a coercion from A to B is only cached, if `_register_pair(C,A,\"coerce\")` has not been called for any C different from B.\n\nHere is a discussion of how it is justified.\n\n* In a pure back-tracking algorithm searching for a path from A to B, *any* temporarily disregarded path starts in A. Hence, it is correct to focus on such paths in 2. above.\n* There are cases in which a `_coerce_map_from_` method breaks the pure back-tracking algorithm. So, theoretically, the following can happen: i) We search a path from A to B, which is temporarily disregarded in back-tracking. ii) While searching, a `_coerce_map_from_` method is called that internally searches a path from C to D. iii) There is a path from C to D, but it would involve a path from A to B. iv) Since that path is disregarded and since \"A is not C\", we would cache the absence of a coercion from C to D in 2. above - which may be wrong.\n* While the preceding point is a theoretical possibility, it is the responsibility of the author of _coerce_map_from_ that it does not occur in reality.\n\nIf the reviewer disagrees and believes that we must exclude the theoretical possibility of a failure, we could modify 2. above, as follows:\n\n2'. When a coercion from A to B is found, then it is cached. When a coercion from A to B is not found, then the unpatched code would cache that as well. With the patch, the absence of a coercion from A to B is only cached, if `_register_pair(D,C,\"coerce\")` has not been called for any (C,D) different from (A,B).\n\nAnyway. Since tests pass and since (even better) the sporadic errors with #715, #12215, #11521 and #12313 seem to vanish with the patch, I would suggest to keep the patch as it is now.\n\nPS: I am changing the component, since it isn't about combinatorics but about coercion.\n\nApply trac12969_fix_coercion_cache.patch trac_12969-avoid_coercion_from_none.patch",
    "created_at": "2012-07-24T10:44:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153451",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_12969-avoid_coercion_from_none.patch](tarball://root/attachments/some-uuid/ticket12969/trac_12969-avoid_coercion_from_none.patch) by @simon-king-jena created at 2012-07-24 10:44:24

I added another patch. Its purpose:

Python types are sometimes considered as parents. There is a function sage.structure.coerce.py_scalar_parent returning a parent that corresponds to a type. Some types, e.g., `<type 'str'>`, do not correspond to a parent, hence py_scalar_parent(str) returns None.

Still, the code in sage.structure.parent_old would try to construct a coercion from None (the non-existing parent) to self. The result is clear a-priori: There is no such coercion. The new patch establishes a short-cut.

For the reviewer: 

Here is a summary of how the main patch trac12969_fix_coercion_cache.patch works.

1. When searching for a coerce path from A to B by back-tracking, it is vital that it is not attempted to construct a path from A to B in the inner parts of the recursion. Hence, the path from A to B is temporarily disregarded, by calling `_register_pair(B,A,"coerce")` -- that's existing code.
2. When a coercion from A to B is found, then it is cached. When a coercion from A to B is not found, then the unpatched code would cache that as well. With the patch, the absence of a coercion from A to B is only cached, if `_register_pair(C,A,"coerce")` has not been called for any C different from B.

Here is a discussion of how it is justified.

* In a pure back-tracking algorithm searching for a path from A to B, *any* temporarily disregarded path starts in A. Hence, it is correct to focus on such paths in 2. above.
* There are cases in which a `_coerce_map_from_` method breaks the pure back-tracking algorithm. So, theoretically, the following can happen: i) We search a path from A to B, which is temporarily disregarded in back-tracking. ii) While searching, a `_coerce_map_from_` method is called that internally searches a path from C to D. iii) There is a path from C to D, but it would involve a path from A to B. iv) Since that path is disregarded and since "A is not C", we would cache the absence of a coercion from C to D in 2. above - which may be wrong.
* While the preceding point is a theoretical possibility, it is the responsibility of the author of _coerce_map_from_ that it does not occur in reality.

If the reviewer disagrees and believes that we must exclude the theoretical possibility of a failure, we could modify 2. above, as follows:

2'. When a coercion from A to B is found, then it is cached. When a coercion from A to B is not found, then the unpatched code would cache that as well. With the patch, the absence of a coercion from A to B is only cached, if `_register_pair(D,C,"coerce")` has not been called for any (C,D) different from (A,B).

Anyway. Since tests pass and since (even better) the sporadic errors with #715, #12215, #11521 and #12313 seem to vanish with the patch, I would suggest to keep the patch as it is now.

PS: I am changing the component, since it isn't about combinatorics but about coercion.

Apply trac12969_fix_coercion_cache.patch trac_12969-avoid_coercion_from_none.patch



---

archive/issue_comments_153452.json:
```json
{
    "body": "Replying to [comment:35 nthiery]:\n> In any cases, we are just looking for a temporary fix that improves the situation until we rewrite completely the search algorithm; if it's not perfect, so be it. So I would say: if all tests pass, go for it.\n\nI agree. The main purpose is a fix of the existing algorithm, so that the memleak fixes in #715, #12215, #11521 and #12313 work reliably. I am confident that a fix relying on a new algorithm should work as well.",
    "created_at": "2012-07-24T10:50:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153452",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:35 nthiery]:
> In any cases, we are just looking for a temporary fix that improves the situation until we rewrite completely the search algorithm; if it's not perfect, so be it. So I would say: if all tests pass, go for it.

I agree. The main purpose is a fix of the existing algorithm, so that the memleak fixes in #715, #12215, #11521 and #12313 work reliably. I am confident that a fix relying on a new algorithm should work as well.



---

archive/issue_comments_153453.json:
```json
{
    "body": "Thanks, Simon, for fixing this bug! Your solution looks ok to me, though I strongly recommend that someone reprograms the coercion algorithm in the future.\n\nI ran all tests on top of 5457 and all tests passed! So I am giving this a positive review. Hopefully it can be merged together with 5457 (but if 5457 gets held up, this can go in nonetheless).\n\nAnne",
    "created_at": "2012-07-25T02:15:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153453",
    "user": "https://github.com/anneschilling"
}
```

Thanks, Simon, for fixing this bug! Your solution looks ok to me, though I strongly recommend that someone reprograms the coercion algorithm in the future.

I ran all tests on top of 5457 and all tests passed! So I am giving this a positive review. Hopefully it can be merged together with 5457 (but if 5457 gets held up, this can go in nonetheless).

Anne



---

archive/issue_comments_153454.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-07-25T02:16:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153454",
    "user": "https://github.com/anneschilling"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_153455.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2012-08-01T12:11:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12797",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12797#issuecomment-153455",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed
