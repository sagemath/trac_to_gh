# Issue 14735: charpoly name clashes with matrix content

archive/issues_014735.json:
```json
{
    "body": "*This is a spin-off from #14403, to get that one landed and have a discussion with a wider scope here.*\n\n## Problem\n\n`matrix.charpoly()` will return a polynomial in a polynomial ring over `x`. That variable name is always used, unless overridden by an argument provided by the user. This is OK in many cases, but can become confusing or outright dangerous in cases where `x` already occursd inside the matrix, since in those cases there would be two occurrences of `x` with different semantics:\n\n\n```\nsage: x = var('x')                      \nsage: R = SR                            \nsage: matrix(R,2,2,[x,1,1,x]).charpoly()\nx^2 - 2*x*x + x^2 - 1\nsage: R.<x> = QQ[]                        \nsage: matrix(R,2,2,[x,1,1,x]).charpoly()\nx^2 - 2*x*x + x^2 - 1\nsage: R.<x> = FiniteField(4)              \nsage: matrix(R,2,2,[x,1,1,x]).charpoly()\nx^2 + x\nsage: R.<x> = PowerSeriesRing(QQ)         \nsage: matrix(R,2,2,[x,1,1,x]).charpoly()\nx^2 - 2*x*x - 1 + x^2\n```\n\n\nIt is easy to see that this kind of result can be confusing to say the least. The data structure returned is a polynomial over the ring of the matrix, so the coefficients are all right. Any piece of code only interested in the list of coefficients shouldn't have to bother. But even code could encounter trouble if it were to pass this to some other application or library using a string-like representation, like this:\n\n\n```\nsage: R.<x> = QQ[]                      \nsage: y = var('y')                        \nsage: (matrix(R,2,2,[x,1,1,x]).charpoly()*(1 + y))            \n-y - 1\nsage: (matrix(R,2,2,[x,1,1,x]).charpoly('t')*(1 + y))         \n(y + 1)*((t - 2*x)*t + x^2 - 1)\n```\n\n\nAs you can see, the distinction between the two flavours of `x` can easily get lost, e.g. by (deliberate or accidential) coercion into the symbolic ring. The real problem here is not so much the fact that this does not work (after all, the user *could* have chosen a different variable name in the first place), but rather that this will seem to work but will yield wrong results.\n\n## Proposal\n\nFor this reason, I am of the strong opinion that `charpoly` (and perhaps other polynomial-returning functions as well, so if you know any, please point them out) should take some care to choose a non-clashing name.\n\nTo implement this, we'd need a general method to recursively enumerate all names occuring in a set of values from a given ring. For most rings a complete list of generators would probably be appropriate, no matter whether they actually occur. For the symbolic ring I'd prefer to only use those which actually occur, since otherwise the current default of `x` would probably never be chosen for symbolic matrices, causing an unexpected difference in behavior.\n\nGiven a list of symbol names, we could then try to come up with a non-clashing one. The most elaborate scheme would try some well-known symbols first, like `['x', 'y', 'z', 't', 'u', 'mu']`, before using indexed ones like `['x1', 'x2', \u2026]`, until a locally unique one has been found. Of course one could omit the former, and use `SR.symbol()` instead of the latter, but the consequence would be that the default charpoly of a given matrix would not depend on this matrix alone, but also on which other computations have been done before. Plus those names are harder to read. So I'd rather avoid this approach.\n\n## Unsatisfied expectations\n\nSome users might be confused by the unexpected and perhaps unintuitive name of the variable. Compared with the confusion caused by the clashing names, I consider this acceptable.\n\nIn comment:10:ticket:14403, nbruin pointed out that one might expect\n\n\n```\ncharpoly(A)*charpoly(B) == charpoly(block_diagonal(A,B))\n```\n\n\nbut this would no longer be universally true after this change. I consider this acceptable, since the result would not be an incorrect computation but instead an exception thrown due to a multiplication between incompatible rings. Faced with this, users could always augment their calls to\n\n\n```\ncharpoly(A,'t')*charpoly(B,'t') == charpoly(block_diagonal(A,B),'t')\n```\n\n\nfor some non-clashing variable name `t`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/14972\n\n",
    "created_at": "2013-07-25T19:29:13Z",
    "labels": [
        "linear algebra",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "charpoly name clashes with matrix content",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14735",
    "user": "gagern"
}
```
*This is a spin-off from #14403, to get that one landed and have a discussion with a wider scope here.*

## Problem

`matrix.charpoly()` will return a polynomial in a polynomial ring over `x`. That variable name is always used, unless overridden by an argument provided by the user. This is OK in many cases, but can become confusing or outright dangerous in cases where `x` already occursd inside the matrix, since in those cases there would be two occurrences of `x` with different semantics:


```
sage: x = var('x')                      
sage: R = SR                            
sage: matrix(R,2,2,[x,1,1,x]).charpoly()
x^2 - 2*x*x + x^2 - 1
sage: R.<x> = QQ[]                        
sage: matrix(R,2,2,[x,1,1,x]).charpoly()
x^2 - 2*x*x + x^2 - 1
sage: R.<x> = FiniteField(4)              
sage: matrix(R,2,2,[x,1,1,x]).charpoly()
x^2 + x
sage: R.<x> = PowerSeriesRing(QQ)         
sage: matrix(R,2,2,[x,1,1,x]).charpoly()
x^2 - 2*x*x - 1 + x^2
```


It is easy to see that this kind of result can be confusing to say the least. The data structure returned is a polynomial over the ring of the matrix, so the coefficients are all right. Any piece of code only interested in the list of coefficients shouldn't have to bother. But even code could encounter trouble if it were to pass this to some other application or library using a string-like representation, like this:


```
sage: R.<x> = QQ[]                      
sage: y = var('y')                        
sage: (matrix(R,2,2,[x,1,1,x]).charpoly()*(1 + y))            
-y - 1
sage: (matrix(R,2,2,[x,1,1,x]).charpoly('t')*(1 + y))         
(y + 1)*((t - 2*x)*t + x^2 - 1)
```


As you can see, the distinction between the two flavours of `x` can easily get lost, e.g. by (deliberate or accidential) coercion into the symbolic ring. The real problem here is not so much the fact that this does not work (after all, the user *could* have chosen a different variable name in the first place), but rather that this will seem to work but will yield wrong results.

## Proposal

For this reason, I am of the strong opinion that `charpoly` (and perhaps other polynomial-returning functions as well, so if you know any, please point them out) should take some care to choose a non-clashing name.

To implement this, we'd need a general method to recursively enumerate all names occuring in a set of values from a given ring. For most rings a complete list of generators would probably be appropriate, no matter whether they actually occur. For the symbolic ring I'd prefer to only use those which actually occur, since otherwise the current default of `x` would probably never be chosen for symbolic matrices, causing an unexpected difference in behavior.

Given a list of symbol names, we could then try to come up with a non-clashing one. The most elaborate scheme would try some well-known symbols first, like `['x', 'y', 'z', 't', 'u', 'mu']`, before using indexed ones like `['x1', 'x2', â€¦]`, until a locally unique one has been found. Of course one could omit the former, and use `SR.symbol()` instead of the latter, but the consequence would be that the default charpoly of a given matrix would not depend on this matrix alone, but also on which other computations have been done before. Plus those names are harder to read. So I'd rather avoid this approach.

## Unsatisfied expectations

Some users might be confused by the unexpected and perhaps unintuitive name of the variable. Compared with the confusion caused by the clashing names, I consider this acceptable.

In comment:10:ticket:14403, nbruin pointed out that one might expect


```
charpoly(A)*charpoly(B) == charpoly(block_diagonal(A,B))
```


but this would no longer be universally true after this change. I consider this acceptable, since the result would not be an incorrect computation but instead an exception thrown due to a multiplication between incompatible rings. Faced with this, users could always augment their calls to


```
charpoly(A,'t')*charpoly(B,'t') == charpoly(block_diagonal(A,B),'t')
```


for some non-clashing variable name `t`.

Issue created by migration from https://trac.sagemath.org/ticket/14972





---

archive/issue_comments_187790.json:
```json
{
    "body": "I think always requiring a variable name (or a polynomial ring or something similar) is the \"right\" thing to do: in sage, there is no such thing as \"the\" polynomial ring over a given ring, so there is no way to choose a canonical default. Variable names are an essential ingredient for a polynomial ring and since a characteristic polynomial has to live in one, this name has to be specified somehow.\n\nIt might be that the \"right\" thing is considered too pedantic for general use, though (certainly now that people have gotten used to not having to specify a variable).\n\nTrying to come up with a non-clashing name would be a kludge and makes me think of one of the rules of the Zen of Python: \"in the face of ambiguity, refuse the temptation to guess\", which tends to be a pretty good guideline for interface design.\n\nOne would hope that the polynomial ring in which the charpol is returned would be at least a function of the parent of the matrix, but as we see, that is already not possible for SR.\n\nIf it is deemed a default choice for varname is necessary to keep the sage interface bearable then I would be in favour of making a very cheap choice: just \"x\" or \"t\" or some other reasonable looking name (\"lambda\" is painful because it's a keyword in python).",
    "created_at": "2013-07-26T12:41:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14735",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14735#issuecomment-187790",
    "user": "nbruin"
}
```

I think always requiring a variable name (or a polynomial ring or something similar) is the "right" thing to do: in sage, there is no such thing as "the" polynomial ring over a given ring, so there is no way to choose a canonical default. Variable names are an essential ingredient for a polynomial ring and since a characteristic polynomial has to live in one, this name has to be specified somehow.

It might be that the "right" thing is considered too pedantic for general use, though (certainly now that people have gotten used to not having to specify a variable).

Trying to come up with a non-clashing name would be a kludge and makes me think of one of the rules of the Zen of Python: "in the face of ambiguity, refuse the temptation to guess", which tends to be a pretty good guideline for interface design.

One would hope that the polynomial ring in which the charpol is returned would be at least a function of the parent of the matrix, but as we see, that is already not possible for SR.

If it is deemed a default choice for varname is necessary to keep the sage interface bearable then I would be in favour of making a very cheap choice: just "x" or "t" or some other reasonable looking name ("lambda" is painful because it's a keyword in python).
