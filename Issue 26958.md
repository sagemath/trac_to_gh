# Issue 26958: slightly faster highest_weight_vectors_iterator

archive/issues_026958.json:
```json
{
    "body": "CC:  @tscrim @anneschilling\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/27195\n\n",
    "created_at": "2019-01-31T23:48:23Z",
    "labels": [],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.9",
    "title": "slightly faster highest_weight_vectors_iterator",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/26958",
    "user": "https://github.com/mantepse"
}
```
CC:  @tscrim @anneschilling



Issue created by migration from https://trac.sagemath.org/ticket/27195





---

archive/issue_comments_378851.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2019-02-01T00:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378851",
    "user": "https://github.com/mantepse"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_378852.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-02-01T00:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378852",
    "user": "https://github.com/mantepse"
}
```

New commits:



---

archive/issue_comments_378853.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2019-02-01T00:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378853",
    "user": "https://github.com/mantepse"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_378854.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to combinatorics.",
    "created_at": "2019-02-01T00:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378854",
    "user": "https://github.com/mantepse"
}
```

Changing component from PLEASE CHANGE to combinatorics.



---

archive/issue_comments_378855.json:
```json
{
    "body": "I have now a much faster version, obtained by replacing the the test for highest weight by what's necessary.  Still need to polish.",
    "created_at": "2019-02-01T06:11:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378855",
    "user": "https://github.com/mantepse"
}
```

I have now a much faster version, obtained by replacing the the test for highest weight by what's necessary.  Still need to polish.



---

archive/issue_comments_378856.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-02-01T10:57:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378856",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378857.json:
```json
{
    "body": "I am now down to roughly a third of the time for 10-fold products:\n\n```\nsage: n = 3; C = crystals.Spins([\"B\", n])\nsage: r = 10; T = crystals.TensorProduct(*([C]*r))\nsage: %time len(T.highest_weight_vectors())\nCPU times: user 18.3 s, sys: 196 ms, total: 18.5 s\nWall time: 18.5 s\n731808\nsage: %time len(list(T.highest_weight_vectors_iterator()))\nCPU times: user 5.69 s, sys: 76 ms, total: 5.76 s\nWall time: 5.76 s\n731808\n```\n",
    "created_at": "2019-02-01T11:01:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378857",
    "user": "https://github.com/mantepse"
}
```

I am now down to roughly a third of the time for 10-fold products:

```
sage: n = 3; C = crystals.Spins(["B", n])
sage: r = 10; T = crystals.TensorProduct(*([C]*r))
sage: %time len(T.highest_weight_vectors())
CPU times: user 18.3 s, sys: 196 ms, total: 18.5 s
Wall time: 18.5 s
731808
sage: %time len(list(T.highest_weight_vectors_iterator()))
CPU times: user 5.69 s, sys: 76 ms, total: 5.76 s
Wall time: 5.76 s
731808
```




---

archive/issue_comments_378858.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-02-01T12:08:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378858",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378859.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2019-02-01T12:18:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378859",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_378860.json:
```json
{
    "body": "I believe you get a decent amount of speedup through the fact that you are not pushing/popping from a list. This is generally much slower (even if it is acting at the end) than if you are doing assignments in a fixed length list.\n\nAll crystals must have the same Cartan type in a tensor product, so they must have the same `index_set`. So that is redundant.\n\nYour method is larger in memory usage because it lists every crystal element rather than iterating over them. So it is a trade-off, one which I am split on. I probably fall on the side of making the list since in principle, but the old code worked for infinite crystals (but would run forever). If anything, we probably want to run `C.list()` instead of `list(C)` as the former is cached.\n\nI was going to say above that we should keep using `is_highest_weight`, but there is a fairly strong connection with the element class for the `TensorProductOfCrystals`. Moreover, you must compute `phi(i)` and `epsilon(i)` for every element and `i \\in I`. Thus you should keep track of the running `phi` and apply the 2-fold tensor product formulas to change that by using the `epsilon`/`phi` of each element. Also, I think you should add another function\n\n```python\n# in the general tensor category\ndef _check_i_highest_weight(self, i, epsilon):\n    return self.e(i) is None\n\n# in the tensor product of regular crystals category\ndef _check_i_highest_weight(self, i, epsilon):\n    return epsilon == 0\n```\n\nto avoid some extra `e(i)` computations in a large number of cases. This might be a minor slowdown in the general category, but I think it will be negligible.\n\nPlease give more descriptive variable names, e.g., `it_pos` makes it seem like it is the position of the iterator, not the data at `pos` in `it`. It might be better to unroll the `it` and use individual variables to avoid a bunch of list lookups (IIRC, it is faster to do this). Also maybe put a comment about your check (or if you go with the code change I suggested above).\n\nI am not sure about manually keeping track of the positions compared to keeping iterators (and catching the `StopIteration`) for speed. Did you try both? Maybe it will be better with more descriptive variable names.\n\nI am still not convinced that we should have an iterator method for this. I have never been too big of a fan of having two methods, where the first just runs a list of the second. Nevertheless, the `highest_weight_vectors` should use this implementation.",
    "created_at": "2019-02-01T16:54:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378860",
    "user": "https://github.com/tscrim"
}
```

I believe you get a decent amount of speedup through the fact that you are not pushing/popping from a list. This is generally much slower (even if it is acting at the end) than if you are doing assignments in a fixed length list.

All crystals must have the same Cartan type in a tensor product, so they must have the same `index_set`. So that is redundant.

Your method is larger in memory usage because it lists every crystal element rather than iterating over them. So it is a trade-off, one which I am split on. I probably fall on the side of making the list since in principle, but the old code worked for infinite crystals (but would run forever). If anything, we probably want to run `C.list()` instead of `list(C)` as the former is cached.

I was going to say above that we should keep using `is_highest_weight`, but there is a fairly strong connection with the element class for the `TensorProductOfCrystals`. Moreover, you must compute `phi(i)` and `epsilon(i)` for every element and `i \in I`. Thus you should keep track of the running `phi` and apply the 2-fold tensor product formulas to change that by using the `epsilon`/`phi` of each element. Also, I think you should add another function

```python
# in the general tensor category
def _check_i_highest_weight(self, i, epsilon):
    return self.e(i) is None

# in the tensor product of regular crystals category
def _check_i_highest_weight(self, i, epsilon):
    return epsilon == 0
```

to avoid some extra `e(i)` computations in a large number of cases. This might be a minor slowdown in the general category, but I think it will be negligible.

Please give more descriptive variable names, e.g., `it_pos` makes it seem like it is the position of the iterator, not the data at `pos` in `it`. It might be better to unroll the `it` and use individual variables to avoid a bunch of list lookups (IIRC, it is faster to do this). Also maybe put a comment about your check (or if you go with the code change I suggested above).

I am not sure about manually keeping track of the positions compared to keeping iterators (and catching the `StopIteration`) for speed. Did you try both? Maybe it will be better with more descriptive variable names.

I am still not convinced that we should have an iterator method for this. I have never been too big of a fan of having two methods, where the first just runs a list of the second. Nevertheless, the `highest_weight_vectors` should use this implementation.



---

archive/issue_comments_378861.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-02-01T17:03:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378861",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_378862.json:
```json
{
    "body": "This improvement is not all that interesting without having it as an iterator, because I do not have enough memory to store all the highest weight vectors in a list for the cases I am interested in: arbitrary finite crystal, large tensor power.\n\nIt's mainly important for me to have this as a trac ticket, so I can share it easily with the people I am working with.\n\nThus, if you insist on not having an iterator, I'd rather not invest much more time for now - except for your confirmation that the index set is always the same (I wasn't absolutely sure if that's always true, thanks!) and except that I indeed would like to keep track of phi, but I am not skilled enough to do that efficiently and to be sure that what I am doing is correct.\n\nI admit that I do not understand your code snippet.  Please elaborate - I am by no means a crystal expert!\n\nConcerning the decisions I took: I tried about 10 different versions.  I think the biggest speedup comes from not using `is_highest_weight`, because that saves a lot of unneccessary computation.  The second largest chunk of time was to get rid of the iterators.\n\nThe amount of time spent for the setup code at the beginning is absolutely negligible.\n\nI tried to unroll `it`, in several different ways.  The current version turned out to be the fastest.  I guess this will be even better by removing the index set, thanks again.",
    "created_at": "2019-02-01T18:12:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378862",
    "user": "https://github.com/mantepse"
}
```

This improvement is not all that interesting without having it as an iterator, because I do not have enough memory to store all the highest weight vectors in a list for the cases I am interested in: arbitrary finite crystal, large tensor power.

It's mainly important for me to have this as a trac ticket, so I can share it easily with the people I am working with.

Thus, if you insist on not having an iterator, I'd rather not invest much more time for now - except for your confirmation that the index set is always the same (I wasn't absolutely sure if that's always true, thanks!) and except that I indeed would like to keep track of phi, but I am not skilled enough to do that efficiently and to be sure that what I am doing is correct.

I admit that I do not understand your code snippet.  Please elaborate - I am by no means a crystal expert!

Concerning the decisions I took: I tried about 10 different versions.  I think the biggest speedup comes from not using `is_highest_weight`, because that saves a lot of unneccessary computation.  The second largest chunk of time was to get rid of the iterators.

The amount of time spent for the setup code at the beginning is absolutely negligible.

I tried to unroll `it`, in several different ways.  The current version turned out to be the fastest.  I guess this will be even better by removing the index set, thanks again.



---

archive/issue_comments_378863.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-02-01T18:34:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378863",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378864.json:
```json
{
    "body": "With your observation concerning the index set I am down to 4.3 seconds!  That's wonderful!\n\nIf you elaborate a bit (I have a rough picture) on your comments concerning the computation of phi, I'll do that too.",
    "created_at": "2019-02-01T18:42:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378864",
    "user": "https://github.com/mantepse"
}
```

With your observation concerning the index set I am down to 4.3 seconds!  That's wonderful!

If you elaborate a bit (I have a rough picture) on your comments concerning the computation of phi, I'll do that too.



---

archive/issue_comments_378865.json:
```json
{
    "body": "One further question, since you mentioned infinite crystals.  Consider\n\n```\nsage: B = crystals.infinity.Tableaux(\"A1\")\nsage: T = B.tensor(B)\n```\n\nNow, after the natural naive adaptation of the code, I can do\n\n```\nsage: it = T.highest_weight_vectors_iterator()\nsage: next(it)\n[[[1]], [[1]]]\n```\n\nHowever, apparently in this tensor product, the highest weight words are\n\n```\n[[[1]], [[1, 2]]]\n[[[1]], [[1, 2, 2]]]\n[[[1]], [[1, 2, 2, 2]]]\n```\n\nrather than\n\n```\n[[[1, 2]], [[1]]]\n[[[1, 2, 2]], [[1]]]\n[[[1, 2, 2, 2]], [[1]]]\n```\n\nIs this a bug?\n\nBug or not, it implies that the iterator would not return, because it modifies left most positions first.",
    "created_at": "2019-02-01T19:31:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378865",
    "user": "https://github.com/mantepse"
}
```

One further question, since you mentioned infinite crystals.  Consider

```
sage: B = crystals.infinity.Tableaux("A1")
sage: T = B.tensor(B)
```

Now, after the natural naive adaptation of the code, I can do

```
sage: it = T.highest_weight_vectors_iterator()
sage: next(it)
[[[1]], [[1]]]
```

However, apparently in this tensor product, the highest weight words are

```
[[[1]], [[1, 2]]]
[[[1]], [[1, 2, 2]]]
[[[1]], [[1, 2, 2, 2]]]
```

rather than

```
[[[1, 2]], [[1]]]
[[[1, 2, 2]], [[1]]]
[[[1, 2, 2, 2]], [[1]]]
```

Is this a bug?

Bug or not, it implies that the iterator would not return, because it modifies left most positions first.



---

archive/issue_comments_378866.json:
```json
{
    "body": "I think I figured out how to keep track of `phi`, see below.  Unfortunately, this doesn't quite work.  For example\n\n```\nsage: B = crystals.Tableaux(['A',2], shape=[1])\nsage: La = RootSystem(['A',2]).weight_lattice().fundamental_weights()\nsage: T = crystals.elementary.T(['A',2], La[2])\nsage: Bp = T.tensor(B)\nsage: Bp.highest_weight_vector()\n```\n\nfails when trying to compute `b1_phi` with `b1 = self.element_class(self, [])`, in the first line of `tensor_product_element.TensorProductOfCrystalsElement.phi`:\n\n```\n    def phi(self, i):\n        P = self._list[-1].parent().weight_lattice_realization()\n        h = P.simple_coroots()\n        omega = P(self.weight()).scalar(h[i])\n        return max(omega + self._sig(i, k) for k in range(1, len(self._list)+1))\n```\n\nIn fact, I don't think it is correct to use `self` also as parent for shorter paths.  Ideally, I guess, it would be best not to call `b1.phi` at all, but to do so I have to figure out how to compute `phi(b1)` given `phi((b2, b1))`.\n \n\n```\n            def highest_weight_vectors_iterator(self, i):\n                I = self.index_set()\n                T_data = list(self.crystals[:-1]) + [self.crystals[-1].highest_weight_vectors()]\n                T_data = [[0, len(elts), list(elts)] for elts, C in zip(T_data, self.crystals)]\n                n = len(self.crystals)\n                path = [None]*n\n                b1 = None\n                T_pos = n-1\n                while T_pos < n:\n                    C_data = T_data[T_pos]\n                    if C_data[0] == C_data[1]:\n                        T_pos += 1\n                        b1 = None\n                        C_data[0] = 0\n                    else:\n                        if b1 is None:\n                            b1 = self.element_class(self, path[T_pos+1:])\n                            b1_phi = {i: b1.phi(i) for i in I}\n                        b2 = C_data[2][C_data[0]]\n                        C_data[0] += 1\n                        if all(b2.e(i) is None or b2.epsilon(i) <= b1_phi[i] for i in I):\n                            path[T_pos] = b2\n                            if T_pos:\n                                b1 = self.element_class(self, path[T_pos:])\n                                b1_phi = {i: b2.phi(i) + max(0, b1_phi[i] - b2.epsilon(i))\n                                          for i in I}\n                                T_pos -= 1\n                            else:\n                                yield self.element_class(self, path)\n```\n",
    "created_at": "2019-02-02T20:17:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378866",
    "user": "https://github.com/mantepse"
}
```

I think I figured out how to keep track of `phi`, see below.  Unfortunately, this doesn't quite work.  For example

```
sage: B = crystals.Tableaux(['A',2], shape=[1])
sage: La = RootSystem(['A',2]).weight_lattice().fundamental_weights()
sage: T = crystals.elementary.T(['A',2], La[2])
sage: Bp = T.tensor(B)
sage: Bp.highest_weight_vector()
```

fails when trying to compute `b1_phi` with `b1 = self.element_class(self, [])`, in the first line of `tensor_product_element.TensorProductOfCrystalsElement.phi`:

```
    def phi(self, i):
        P = self._list[-1].parent().weight_lattice_realization()
        h = P.simple_coroots()
        omega = P(self.weight()).scalar(h[i])
        return max(omega + self._sig(i, k) for k in range(1, len(self._list)+1))
```

In fact, I don't think it is correct to use `self` also as parent for shorter paths.  Ideally, I guess, it would be best not to call `b1.phi` at all, but to do so I have to figure out how to compute `phi(b1)` given `phi((b2, b1))`.
 

```
            def highest_weight_vectors_iterator(self, i):
                I = self.index_set()
                T_data = list(self.crystals[:-1]) + [self.crystals[-1].highest_weight_vectors()]
                T_data = [[0, len(elts), list(elts)] for elts, C in zip(T_data, self.crystals)]
                n = len(self.crystals)
                path = [None]*n
                b1 = None
                T_pos = n-1
                while T_pos < n:
                    C_data = T_data[T_pos]
                    if C_data[0] == C_data[1]:
                        T_pos += 1
                        b1 = None
                        C_data[0] = 0
                    else:
                        if b1 is None:
                            b1 = self.element_class(self, path[T_pos+1:])
                            b1_phi = {i: b1.phi(i) for i in I}
                        b2 = C_data[2][C_data[0]]
                        C_data[0] += 1
                        if all(b2.e(i) is None or b2.epsilon(i) <= b1_phi[i] for i in I):
                            path[T_pos] = b2
                            if T_pos:
                                b1 = self.element_class(self, path[T_pos:])
                                b1_phi = {i: b2.phi(i) + max(0, b1_phi[i] - b2.epsilon(i))
                                          for i in I}
                                T_pos -= 1
                            else:
                                yield self.element_class(self, path)
```




---

archive/issue_comments_378867.json:
```json
{
    "body": "Never mind, I figured it out.  Nice speedup, I'll push after polishing.",
    "created_at": "2019-02-02T20:37:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378867",
    "user": "https://github.com/mantepse"
}
```

Never mind, I figured it out.  Nice speedup, I'll push after polishing.



---

archive/issue_comments_378868.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-02-02T20:52:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378868",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_378869.json:
```json
{
    "body": "We can now iterate over the highest weight vectors in the 10-th tensor power of Spin(7) in about two seconds vs. 18 seconds before!\n\nThank you, Travis, for your very valuable hints!",
    "created_at": "2019-02-02T20:59:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378869",
    "user": "https://github.com/mantepse"
}
```

We can now iterate over the highest weight vectors in the 10-th tensor power of Spin(7) in about two seconds vs. 18 seconds before!

Thank you, Travis, for your very valuable hints!



---

archive/issue_comments_378870.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-02-02T21:21:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378870",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_378871.json:
```json
{
    "body": "The following would be still quite a bit faster, but comes at the cost of some readability.\n\nOf course, if computing `epsilon` is expensive, this will make a lot of difference.\n\nFor example, I get\n\n```\nsage: n = 6; C = crystals.Spins([\"B\", n])\nsage: r = 7; T = crystals.TensorProduct(*([C]*r))\nsage: %timeit for _ in T.highest_weight_vectors_iterator(): pass\n1 loop, best of 3: 2.87 s per loop\n```\n\nvs. 4 seconds with the current branch.\n\n\n\n```diff\n    diff --git a/src/sage/categories/highest_weight_crystals.py b/src/sage/categories/highest_weight_crystals.py\nindex cf41774830..e5694cd5bb 100644\n--- a/src/sage/categories/highest_weight_crystals.py\n+++ b/src/sage/categories/highest_weight_crystals.py\n@@ -770,11 +770,19 @@ class HighestWeightCrystals(Category_singleton):\n                         b2 = C_data[2][C_data[0]]\n                         C_data[0] += 1\n                         b1_phi = T_phi[T_pos]\n-                        if all(b2.e(i) is None or b2.epsilon(i) <= b1_phi[i] for i in I):\n+                        b1_phi_minus_b2_epsilon = {}\n+                        for i in I:\n+                            if b2.e(i) is not None:\n+                                d = b1_phi[i] - b2.epsilon(i)\n+                                if d < 0:\n+                                    break\n+                                b1_phi_minus_b2_epsilon[i] = d\n+                        else:\n                             path[T_pos] = b2\n                             if T_pos:\n                                 T_pos -= 1\n-                                T_phi[T_pos] = {i: b2.phi(i) + max(0, b1_phi[i] - b2.epsilon(i))\n+                                T_phi[T_pos] = {i: b2.phi(i) + \\\n+                                                max(0, b1_phi_minus_b2_epsilon.get(i, b1_phi[i] - b2.epsilon(i)))\n                                                 for i in I}\n                             else:\n                                 yield self.element_class(self, path)\n```\n",
    "created_at": "2019-02-03T00:25:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378871",
    "user": "https://github.com/mantepse"
}
```

The following would be still quite a bit faster, but comes at the cost of some readability.

Of course, if computing `epsilon` is expensive, this will make a lot of difference.

For example, I get

```
sage: n = 6; C = crystals.Spins(["B", n])
sage: r = 7; T = crystals.TensorProduct(*([C]*r))
sage: %timeit for _ in T.highest_weight_vectors_iterator(): pass
1 loop, best of 3: 2.87 s per loop
```

vs. 4 seconds with the current branch.



```diff
    diff --git a/src/sage/categories/highest_weight_crystals.py b/src/sage/categories/highest_weight_crystals.py
index cf41774830..e5694cd5bb 100644
--- a/src/sage/categories/highest_weight_crystals.py
+++ b/src/sage/categories/highest_weight_crystals.py
@@ -770,11 +770,19 @@ class HighestWeightCrystals(Category_singleton):
                         b2 = C_data[2][C_data[0]]
                         C_data[0] += 1
                         b1_phi = T_phi[T_pos]
-                        if all(b2.e(i) is None or b2.epsilon(i) <= b1_phi[i] for i in I):
+                        b1_phi_minus_b2_epsilon = {}
+                        for i in I:
+                            if b2.e(i) is not None:
+                                d = b1_phi[i] - b2.epsilon(i)
+                                if d < 0:
+                                    break
+                                b1_phi_minus_b2_epsilon[i] = d
+                        else:
                             path[T_pos] = b2
                             if T_pos:
                                 T_pos -= 1
-                                T_phi[T_pos] = {i: b2.phi(i) + max(0, b1_phi[i] - b2.epsilon(i))
+                                T_phi[T_pos] = {i: b2.phi(i) + \
+                                                max(0, b1_phi_minus_b2_epsilon.get(i, b1_phi[i] - b2.epsilon(i)))
                                                 for i in I}
                             else:
                                 yield self.element_class(self, path)
```




---

archive/issue_comments_378872.json:
```json
{
    "body": "I would probably replace\n\n```diff\n-if all(b2.e(i) is None or b2.epsilon(i) <= b1_phi[i] for i in I):\n+if all(_check_highest_weight(i, b2_ep[i]) is None or b2_ep[i] <= b1_phi[i] for i in I):\n```\n\nSee comment:8. This should further improve for objects in `RegularCrystals` (which means `b.epsilon(i)` counts the number of `b.e(i)`'s you can do) in addition to your changes above.\n\nI think readability concerns are somewhat gone at this point, and some code comments will help at they will explain what is going on in the code.",
    "created_at": "2019-02-03T21:25:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378872",
    "user": "https://github.com/tscrim"
}
```

I would probably replace

```diff
-if all(b2.e(i) is None or b2.epsilon(i) <= b1_phi[i] for i in I):
+if all(_check_highest_weight(i, b2_ep[i]) is None or b2_ep[i] <= b1_phi[i] for i in I):
```

See comment:8. This should further improve for objects in `RegularCrystals` (which means `b.epsilon(i)` counts the number of `b.e(i)`'s you can do) in addition to your changes above.

I think readability concerns are somewhat gone at this point, and some code comments will help at they will explain what is going on in the code.



---

archive/issue_comments_378873.json:
```json
{
    "body": "OK, I see the idea now - will try tomorrow.  For testing purposes: is there a finite non-regular crystal available in sage?\n\n\nCould you comment briefly on comment:13?\n\nThanks again for your input!",
    "created_at": "2019-02-03T22:05:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378873",
    "user": "https://github.com/mantepse"
}
```

OK, I see the idea now - will try tomorrow.  For testing purposes: is there a finite non-regular crystal available in sage?


Could you comment briefly on comment:13?

Thanks again for your input!



---

archive/issue_comments_378874.json:
```json
{
    "body": "The code looks best when restricting to tensor products of regular highest weight crystals.  I am guessing that this is the most important case, but it seems we do not have a category for that, do we?\n\n```python\n\n            def highest_weight_vectors_iterator(self):\n                I = self.index_set()\n                T_data = list(self.crystals[:-1]) + [self.crystals[-1].highest_weight_vectors()]\n                T_data = [[0, len(elts), list(elts)] for elts, C in zip(T_data, self.crystals)]\n                n = len(self.crystals)\n                path = [None]*n\n                T_phi = [None]*(n-1) + [{i: 0 for i in I}]\n                T_pos = n-1\n                while T_pos < n:\n                    C_data = T_data[T_pos]\n                    if C_data[0] == C_data[1]:\n                        T_pos += 1\n                        C_data[0] = 0\n                    else:\n                        b2 = C_data[2][C_data[0]]\n                        C_data[0] += 1\n                        b1_phi = T_phi[T_pos]\n                        b1_phi_minus_b2_epsilon = {}\n                        for i in I:\n                            d = b1_phi[i] - b2.epsilon(i)\n                            if d < 0:\n                                break\n                            b1_phi_minus_b2_epsilon[i] = d\n                        else:\n                            path[T_pos] = b2\n                            if T_pos:\n                                T_pos -= 1\n                                T_phi[T_pos] = {i: b2.phi(i) + b1_phi_minus_b2_epsilon[i]\n                                                for i in I}\n                            else:\n                                yield self.element_class(self, path)\n\n```\n",
    "created_at": "2019-02-04T21:57:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378874",
    "user": "https://github.com/mantepse"
}
```

The code looks best when restricting to tensor products of regular highest weight crystals.  I am guessing that this is the most important case, but it seems we do not have a category for that, do we?

```python

            def highest_weight_vectors_iterator(self):
                I = self.index_set()
                T_data = list(self.crystals[:-1]) + [self.crystals[-1].highest_weight_vectors()]
                T_data = [[0, len(elts), list(elts)] for elts, C in zip(T_data, self.crystals)]
                n = len(self.crystals)
                path = [None]*n
                T_phi = [None]*(n-1) + [{i: 0 for i in I}]
                T_pos = n-1
                while T_pos < n:
                    C_data = T_data[T_pos]
                    if C_data[0] == C_data[1]:
                        T_pos += 1
                        C_data[0] = 0
                    else:
                        b2 = C_data[2][C_data[0]]
                        C_data[0] += 1
                        b1_phi = T_phi[T_pos]
                        b1_phi_minus_b2_epsilon = {}
                        for i in I:
                            d = b1_phi[i] - b2.epsilon(i)
                            if d < 0:
                                break
                            b1_phi_minus_b2_epsilon[i] = d
                        else:
                            path[T_pos] = b2
                            if T_pos:
                                T_pos -= 1
                                T_phi[T_pos] = {i: b2.phi(i) + b1_phi_minus_b2_epsilon[i]
                                                for i in I}
                            else:
                                yield self.element_class(self, path)

```




---

archive/issue_comments_378875.json:
```json
{
    "body": "In regards to comment:13. The `B(\\infty)` crystal is very different than the highest weight crystals: it is only upper-regular, so `b.phi(i)` can be negative. Subsequently the tensor products are very different and quite wild (they have multiple highest weight vectors in a single component). This is a reflection in that category O is not closed under tensor products (e.g., the tensor product of 2 Verma modules is not in category O).\n\nIt is easy to create this category as it is just a `Category_singleton` with highest weight and regular crystals as super categories. The tensor category is also easy.\n\nIt is relatively simple to create a finite non-regular (irregular?) crystal. Take a finite subcrystal of, say, `B(\\infty)`. There are also lots of 1-element crystals that are not regular, e.g., the `crystals.elementary.T`. Perhaps just for the sake of clarity we use the code you are proposing in comment:22. It is somewhat of a premature optimization for the non-regular crystals, and I don't expect such an optimization to be necessary in that case.",
    "created_at": "2019-02-05T03:08:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378875",
    "user": "https://github.com/tscrim"
}
```

In regards to comment:13. The `B(\infty)` crystal is very different than the highest weight crystals: it is only upper-regular, so `b.phi(i)` can be negative. Subsequently the tensor products are very different and quite wild (they have multiple highest weight vectors in a single component). This is a reflection in that category O is not closed under tensor products (e.g., the tensor product of 2 Verma modules is not in category O).

It is easy to create this category as it is just a `Category_singleton` with highest weight and regular crystals as super categories. The tensor category is also easy.

It is relatively simple to create a finite non-regular (irregular?) crystal. Take a finite subcrystal of, say, `B(\infty)`. There are also lots of 1-element crystals that are not regular, e.g., the `crystals.elementary.T`. Perhaps just for the sake of clarity we use the code you are proposing in comment:22. It is somewhat of a premature optimization for the non-regular crystals, and I don't expect such an optimization to be necessary in that case.



---

archive/issue_comments_378876.json:
```json
{
    "body": "I (locally) added a category `RegularHighestWeightCrystals` and put the crystals that belong to both categories in, for example\n\n```diff\n@@ -75,7 +75,7 @@ class ClassicalCrystals(Category_singleton):\n              Category of finite crystals,\n              Category of highest weight crystals]\n         \"\"\"\n-        return [RegularCrystals(), FiniteCrystals(), HighestWeightCrystals()]\n+        return [RegularHighestWeightCrystals(), FiniteCrystals()]\n```\n\n\nIn principle, this seems to work.\n\nMain questions:\n\n* does my approach look correct in principle?\n\n* should I create a new file `regular_highest_weight_crystals.py`, or should I put the new category into `regular_crystals.py`?\n\n* in `highest_weight_crystals.py`, should I\n\n  a) keep the old code, or\n\n  b) provide the most readable version of the new iterator - whatever that is?",
    "created_at": "2019-02-05T20:13:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378876",
    "user": "https://github.com/mantepse"
}
```

I (locally) added a category `RegularHighestWeightCrystals` and put the crystals that belong to both categories in, for example

```diff
@@ -75,7 +75,7 @@ class ClassicalCrystals(Category_singleton):
              Category of finite crystals,
              Category of highest weight crystals]
         """
-        return [RegularCrystals(), FiniteCrystals(), HighestWeightCrystals()]
+        return [RegularHighestWeightCrystals(), FiniteCrystals()]
```


In principle, this seems to work.

Main questions:

* does my approach look correct in principle?

* should I create a new file `regular_highest_weight_crystals.py`, or should I put the new category into `regular_crystals.py`?

* in `highest_weight_crystals.py`, should I

  a) keep the old code, or

  b) provide the most readable version of the new iterator - whatever that is?



---

archive/issue_comments_378877.json:
```json
{
    "body": "Replying to [comment:23 tscrim]:\n> In regards to comment:13. The `B(\\infty)` crystal is very different than the highest weight crystals: it is only upper-regular, so `b.phi(i)` can be negative. Subsequently the tensor products are very different and quite wild (they have multiple highest weight vectors in a single component). This is a reflection in that category O is not closed under tensor products (e.g., the tensor product of 2 Verma modules is not in category O).\n\nThe documentation of `HighestWeightCrystals` says:\n\n    A crystal is highest weight if it is acyclic; in particular, every\n    connected component has a unique highest weight element, and that\n    element generates the component.\n\nIsn't then\n\n```\nsage: B = crystals.infinity.Tableaux(\"A3\")\nsage: T = B.tensor(B)\nsage: T in HighestWeightCrystals\nTrue\n```\n\nin contradiction to what you wrote?",
    "created_at": "2019-02-06T13:27:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378877",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:23 tscrim]:
> In regards to comment:13. The `B(\infty)` crystal is very different than the highest weight crystals: it is only upper-regular, so `b.phi(i)` can be negative. Subsequently the tensor products are very different and quite wild (they have multiple highest weight vectors in a single component). This is a reflection in that category O is not closed under tensor products (e.g., the tensor product of 2 Verma modules is not in category O).

The documentation of `HighestWeightCrystals` says:

    A crystal is highest weight if it is acyclic; in particular, every
    connected component has a unique highest weight element, and that
    element generates the component.

Isn't then

```
sage: B = crystals.infinity.Tableaux("A3")
sage: T = B.tensor(B)
sage: T in HighestWeightCrystals
True
```

in contradiction to what you wrote?



---

archive/issue_comments_378878.json:
```json
{
    "body": "I would appreciate it if you were less accusatory in your questions.\n\nYes, it is a bit of a contradiction, but that documentation is out of date. We didn't have many of the crystals that we have now when that was written. It is generally true, but mostly we should remove the \"unique\" part of that sentence. The statement in the category does hold true for objects in category O<sup>int</sup>. There is no bug here, just outdated documentation.",
    "created_at": "2019-02-06T15:32:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378878",
    "user": "https://github.com/tscrim"
}
```

I would appreciate it if you were less accusatory in your questions.

Yes, it is a bit of a contradiction, but that documentation is out of date. We didn't have many of the crystals that we have now when that was written. It is generally true, but mostly we should remove the "unique" part of that sentence. The statement in the category does hold true for objects in category O<sup>int</sup>. There is no bug here, just outdated documentation.



---

archive/issue_comments_378879.json:
```json
{
    "body": "Please excuse me, I had no idea that I sound accusatory!  I am just not familiar with these more exotic crystals - most of my knowledge is from the documentation of sage - so I was really just asking a question.\n\nIn any case, the category `HighestWeightCrystals` is closed under tensor products, right?\n\nI'll have to look up what the category `O` is, I'll do this right now.",
    "created_at": "2019-02-06T15:52:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378879",
    "user": "https://github.com/mantepse"
}
```

Please excuse me, I had no idea that I sound accusatory!  I am just not familiar with these more exotic crystals - most of my knowledge is from the documentation of sage - so I was really just asking a question.

In any case, the category `HighestWeightCrystals` is closed under tensor products, right?

I'll have to look up what the category `O` is, I'll do this right now.



---

archive/issue_comments_378880.json:
```json
{
    "body": "Could you direct me to a definition of O?  Hong and Kang (the only book I have available) define O in 2.3, page 28 as follows:\n\n    Its objects consist of weight modules V over 0 with finite dimensional weight spaces for which there exists a finite number of elements ... such that ... The morphisms are g-module homomorphisms. Note that the category O is closed under taking the finite direct sum or finite tensor product of objects from the category O.",
    "created_at": "2019-02-06T15:58:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378880",
    "user": "https://github.com/mantepse"
}
```

Could you direct me to a definition of O?  Hong and Kang (the only book I have available) define O in 2.3, page 28 as follows:

    Its objects consist of weight modules V over 0 with finite dimensional weight spaces for which there exists a finite number of elements ... such that ... The morphisms are g-module homomorphisms. Note that the category O is closed under taking the finite direct sum or finite tensor product of objects from the category O.



---

archive/issue_comments_378881.json:
```json
{
    "body": "The main category of representations we study with crystals is O<sup>int</sup>, where strings all have finite length. B(infty) lives in the bigger category O, which I believe has things that do not have crystal bases, but I might be wrong about that.  I am not sure of a good reference offhand.",
    "created_at": "2019-02-06T18:13:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378881",
    "user": "https://github.com/tscrim"
}
```

The main category of representations we study with crystals is O<sup>int</sup>, where strings all have finite length. B(infty) lives in the bigger category O, which I believe has things that do not have crystal bases, but I might be wrong about that.  I am not sure of a good reference offhand.



---

archive/issue_comments_378882.json:
```json
{
    "body": "OK, thank you! Let's get back to the ticket at hand :-)\n\nIf you want to, I can simply push my proposal so you can have a look.",
    "created_at": "2019-02-06T18:27:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378882",
    "user": "https://github.com/mantepse"
}
```

OK, thank you! Let's get back to the ticket at hand :-)

If you want to, I can simply push my proposal so you can have a look.



---

archive/issue_comments_378883.json:
```json
{
    "body": "I will not be able to look properly for a few hours or so. Although thinking a bit more, we still probably should have essentially the same implementation for both the regular and non regular cases. It just makes things better in the bigger picture.",
    "created_at": "2019-02-06T18:29:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378883",
    "user": "https://github.com/tscrim"
}
```

I will not be able to look properly for a few hours or so. Although thinking a bit more, we still probably should have essentially the same implementation for both the regular and non regular cases. It just makes things better in the bigger picture.



---

archive/issue_comments_378884.json:
```json
{
    "body": "No problem - it is almost bed time for me.  Here is my current code for the iterator, assuming finiteness.  There are only two lines which differ in the regular case, as indicated.  To accommodate infinite crystals, we could replace the list `T_elts` with a list of iterators, but as B(oo) shows, this is not enough. \n\nI don't really know why computing `self.e` is expensive, possibly because an element of the crystal has to be created?  Anyway, as you essentially proposed we could simply have a function that returns `True` is the crystal is regular and `self.e(i) is not None` otherwise.  I don't know what the best name for this is.  One problem might be that this occurs in the innermost loop.  I think the `max` is not very expensive anymore.\n\n\n```python\n            def highest_weight_vectors_iterator(self):\n                I = self.index_set()\n                n = len(self.crystals)\n                T_elts = map(list, list(self.crystals[:-1])) + [list(self.crystals[-1].highest_weight_vectors())]\n                T_cur = [0]*n\n                T_len = [len(elts) for elts in T_elts]\n                T_phi = [None]*(n-1) + [{i: 0 for i in I}]\n                T_pos = n-1\n                path = [None]*n\n                while T_pos < n:\n                    if T_cur[T_pos] == T_len[T_pos]:\n                        T_cur[T_pos] = 0\n                        T_pos += 1\n                    else:\n                        b2 = T_elts[T_pos][T_cur[T_pos]]\n                        T_cur[T_pos] += 1\n                        b1_phi = T_phi[T_pos]\n                        b1_phi_minus_b2_epsilon = {}\n                        for i in I:\n                            d = b1_phi[i] - b2.epsilon(i)\n                            # in the regular case, the next line is simply\n                            # if d < 0:\n                            if b2.e(i) is not None and d < 0:\n                                break\n                            b1_phi_minus_b2_epsilon[i] = d\n                        else:\n                            path[T_pos] = b2\n                            if T_pos:\n                                T_pos -= 1\n                                # in the regular case, the next line is simply\n                                # T_phi[T_pos] = {i: b2.phi(i) + b1_phi_minus_b2_epsilon[i]\n                                #                for i in I}\n                                T_phi[T_pos] = {i: b2.phi(i) + max(0, b1_phi_minus_b2_epsilon[i])\n                                                for i in I}\n\n                            else:\n                                yield self.element_class(self, path)\n```\n",
    "created_at": "2019-02-06T19:52:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378884",
    "user": "https://github.com/mantepse"
}
```

No problem - it is almost bed time for me.  Here is my current code for the iterator, assuming finiteness.  There are only two lines which differ in the regular case, as indicated.  To accommodate infinite crystals, we could replace the list `T_elts` with a list of iterators, but as B(oo) shows, this is not enough. 

I don't really know why computing `self.e` is expensive, possibly because an element of the crystal has to be created?  Anyway, as you essentially proposed we could simply have a function that returns `True` is the crystal is regular and `self.e(i) is not None` otherwise.  I don't know what the best name for this is.  One problem might be that this occurs in the innermost loop.  I think the `max` is not very expensive anymore.


```python
            def highest_weight_vectors_iterator(self):
                I = self.index_set()
                n = len(self.crystals)
                T_elts = map(list, list(self.crystals[:-1])) + [list(self.crystals[-1].highest_weight_vectors())]
                T_cur = [0]*n
                T_len = [len(elts) for elts in T_elts]
                T_phi = [None]*(n-1) + [{i: 0 for i in I}]
                T_pos = n-1
                path = [None]*n
                while T_pos < n:
                    if T_cur[T_pos] == T_len[T_pos]:
                        T_cur[T_pos] = 0
                        T_pos += 1
                    else:
                        b2 = T_elts[T_pos][T_cur[T_pos]]
                        T_cur[T_pos] += 1
                        b1_phi = T_phi[T_pos]
                        b1_phi_minus_b2_epsilon = {}
                        for i in I:
                            d = b1_phi[i] - b2.epsilon(i)
                            # in the regular case, the next line is simply
                            # if d < 0:
                            if b2.e(i) is not None and d < 0:
                                break
                            b1_phi_minus_b2_epsilon[i] = d
                        else:
                            path[T_pos] = b2
                            if T_pos:
                                T_pos -= 1
                                # in the regular case, the next line is simply
                                # T_phi[T_pos] = {i: b2.phi(i) + b1_phi_minus_b2_epsilon[i]
                                #                for i in I}
                                T_phi[T_pos] = {i: b2.phi(i) + max(0, b1_phi_minus_b2_epsilon[i])
                                                for i in I}

                            else:
                                yield self.element_class(self, path)
```




---

archive/issue_comments_378885.json:
```json
{
    "body": "I am very sorry, but I just realised that the code above is very likely incorrect for non-regular crystals: I was assuming that `phi(i)` of an empty tensor product is `0`.",
    "created_at": "2019-02-06T22:03:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378885",
    "user": "https://github.com/mantepse"
}
```

I am very sorry, but I just realised that the code above is very likely incorrect for non-regular crystals: I was assuming that `phi(i)` of an empty tensor product is `0`.



---

archive/issue_comments_378886.json:
```json
{
    "body": "I am not sure how to interpret the tensor rule for non-regular crystals.  It says\n`phi_i((b2,b1) = max(phi_i(b2), phi_i(b1) + phi_i(b2) - epsilon_i(b2))`.  However, what are the rules if some of these are infinities?",
    "created_at": "2019-02-06T22:53:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378886",
    "user": "https://github.com/mantepse"
}
```

I am not sure how to interpret the tensor rule for non-regular crystals.  It says
`phi_i((b2,b1) = max(phi_i(b2), phi_i(b1) + phi_i(b2) - epsilon_i(b2))`.  However, what are the rules if some of these are infinities?



---

archive/issue_comments_378887.json:
```json
{
    "body": "They are never `oo`, but possibly `-oo`.",
    "created_at": "2019-02-06T23:06:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378887",
    "user": "https://github.com/tscrim"
}
```

They are never `oo`, but possibly `-oo`.



---

archive/issue_comments_378888.json:
```json
{
    "body": "What happens if `epsilon_i(b2) == -oo` and `phi_i(b2)` and `phi_i(b1)` are finite?  How can we be sure that this doesn't happen?",
    "created_at": "2019-02-07T07:32:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378888",
    "user": "https://github.com/mantepse"
}
```

What happens if `epsilon_i(b2) == -oo` and `phi_i(b2)` and `phi_i(b1)` are finite?  How can we be sure that this doesn't happen?



---

archive/issue_comments_378889.json:
```json
{
    "body": "Sorry, I think I got it.  The difference between `phi_i` and `epsilon_i` must be finite, because it is `<alpha^v_i, wt(b)>`...\n\nSo, I guess for the non-regular case I have to check this separately - currently, it may happen that `d = b1_phi[i] - b2.epsilon(i)` is `nan`.",
    "created_at": "2019-02-07T07:54:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378889",
    "user": "https://github.com/mantepse"
}
```

Sorry, I think I got it.  The difference between `phi_i` and `epsilon_i` must be finite, because it is `<alpha^v_i, wt(b)>`...

So, I guess for the non-regular case I have to check this separately - currently, it may happen that `d = b1_phi[i] - b2.epsilon(i)` is `nan`.



---

archive/issue_comments_378890.json:
```json
{
    "body": "The following should be correct for finite crystals.  Is there a simple (!) way to make `highest_weight_vectors` unavailable for infinite crystals (apart from creating categories `FiniteRegularHighestWeightCrystals`, etc.)?\n\n```python\n            def highest_weight_vectors_iterator(self):\n                I = self.index_set()\n                T_elts = map(list, list(self.crystals[:-1]))\n                T_len = [len(elts) for elts in T_elts]\n                m = len(self.crystals)-1\n                for b in self.crystals[-1].highest_weight_vectors():\n                    T_pos = m-1  # current tensor position\n                    T_cur = [0]*m  # index of current element for each tensor position\n                    path = [None]*m + [b]\n                    # cache phi for path up to current tensor position\n                    T_phi = [None]*(m-1) + [{i: b.phi(i) for i in I}]\n                    while T_pos < m:\n                        if T_cur[T_pos] == T_len[T_pos]:\n                            T_cur[T_pos] = 0\n                            T_pos += 1\n                        else:\n                            b2 = T_elts[T_pos][T_cur[T_pos]]\n                            T_cur[T_pos] += 1\n                            b1_phi = T_phi[T_pos]\n                            b1_phi_minus_b2_epsilon = {}\n                            # break if (b2, b1) is not highest weight\n                            for i in I:\n                                d = b1_phi[i] - b2.epsilon(i)\n                                # In the non-regular case, d may be nan.\n                                # In this case b2.e(i) is None,\n                                # and we may rely on max(0, nan) == 0.\n                                # In the regular case, the next line is simply\n                                # if d < 0:\n                                if b2.e(i) is not None and d < 0:\n                                    break\n                                b1_phi_minus_b2_epsilon[i] = d\n                            else:\n                                path[T_pos] = b2\n                                if T_pos:\n                                    T_pos -= 1\n                                    # in the regular case, the next line is simply\n                                    # T_phi[T_pos] = {i: b2.phi(i) + b1_phi_minus_b2_epsilon[i]\n                                    #                for i in I}\n                                    T_phi[T_pos] = {i: b2.phi(i) + max(0, b1_phi_minus_b2_epsilon[i])\n                                                    for i in I}\n                                else:\n                                    yield self.element_class(self, path)\n```\n",
    "created_at": "2019-02-07T10:20:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378890",
    "user": "https://github.com/mantepse"
}
```

The following should be correct for finite crystals.  Is there a simple (!) way to make `highest_weight_vectors` unavailable for infinite crystals (apart from creating categories `FiniteRegularHighestWeightCrystals`, etc.)?

```python
            def highest_weight_vectors_iterator(self):
                I = self.index_set()
                T_elts = map(list, list(self.crystals[:-1]))
                T_len = [len(elts) for elts in T_elts]
                m = len(self.crystals)-1
                for b in self.crystals[-1].highest_weight_vectors():
                    T_pos = m-1  # current tensor position
                    T_cur = [0]*m  # index of current element for each tensor position
                    path = [None]*m + [b]
                    # cache phi for path up to current tensor position
                    T_phi = [None]*(m-1) + [{i: b.phi(i) for i in I}]
                    while T_pos < m:
                        if T_cur[T_pos] == T_len[T_pos]:
                            T_cur[T_pos] = 0
                            T_pos += 1
                        else:
                            b2 = T_elts[T_pos][T_cur[T_pos]]
                            T_cur[T_pos] += 1
                            b1_phi = T_phi[T_pos]
                            b1_phi_minus_b2_epsilon = {}
                            # break if (b2, b1) is not highest weight
                            for i in I:
                                d = b1_phi[i] - b2.epsilon(i)
                                # In the non-regular case, d may be nan.
                                # In this case b2.e(i) is None,
                                # and we may rely on max(0, nan) == 0.
                                # In the regular case, the next line is simply
                                # if d < 0:
                                if b2.e(i) is not None and d < 0:
                                    break
                                b1_phi_minus_b2_epsilon[i] = d
                            else:
                                path[T_pos] = b2
                                if T_pos:
                                    T_pos -= 1
                                    # in the regular case, the next line is simply
                                    # T_phi[T_pos] = {i: b2.phi(i) + b1_phi_minus_b2_epsilon[i]
                                    #                for i in I}
                                    T_phi[T_pos] = {i: b2.phi(i) + max(0, b1_phi_minus_b2_epsilon[i])
                                                    for i in I}
                                else:
                                    yield self.element_class(self, path)
```




---

archive/issue_comments_378891.json:
```json
{
    "body": "`T_elts = map(list, list(self.crystals[:-1]))` will fail for infinite crystals. The other option would be to put a test if `self in Sets().Infinite()` and raise a `NotImplementedError`.\n\nAs you surmised in comment:37, `phi = -oo` if and only if `epsilon == -oo`. However, in the general case you should not use `phi - epsilon` but instead `<h_i, wt>`, where `h_i` is the `i`-th simple coroot. Hmmm...it seems like having two close copies might be best, although it is a bit annoying code duplication, which is why I want to put those differences as little helper functions.",
    "created_at": "2019-02-07T14:05:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378891",
    "user": "https://github.com/tscrim"
}
```

`T_elts = map(list, list(self.crystals[:-1]))` will fail for infinite crystals. The other option would be to put a test if `self in Sets().Infinite()` and raise a `NotImplementedError`.

As you surmised in comment:37, `phi = -oo` if and only if `epsilon == -oo`. However, in the general case you should not use `phi - epsilon` but instead `<h_i, wt>`, where `h_i` is the `i`-th simple coroot. Hmmm...it seems like having two close copies might be best, although it is a bit annoying code duplication, which is why I want to put those differences as little helper functions.



---

archive/issue_comments_378892.json:
```json
{
    "body": "Hong and Kang have `phi_i(b) = epsilon_i(b) + <h^v_i, wt(b)>` as their first axiom (on page 86).  Are there crystals where this is not valid?\n\nThe problem with a helper function is that the two differences (as noted in the code above) are executed extremely often, so every function call seems to come with an immense cost.   Of course, we could probably even cythonize... I tried this, and simply doing `cdef int m, T_pos, d` had quite a noticeable effect - but of course this relies even more on regularity, because for non-regular crystals `d` is a `float`.",
    "created_at": "2019-02-07T14:26:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378892",
    "user": "https://github.com/mantepse"
}
```

Hong and Kang have `phi_i(b) = epsilon_i(b) + <h^v_i, wt(b)>` as their first axiom (on page 86).  Are there crystals where this is not valid?

The problem with a helper function is that the two differences (as noted in the code above) are executed extremely often, so every function call seems to come with an immense cost.   Of course, we could probably even cythonize... I tried this, and simply doing `cdef int m, T_pos, d` had quite a noticeable effect - but of course this relies even more on regularity, because for non-regular crystals `d` is a `float`.



---

archive/issue_comments_378893.json:
```json
{
    "body": "Replying to [comment:40 mantepse]:\n> Hong and Kang have `phi_i(b) = epsilon_i(b) + <h^v_i, wt(b)>` as their first axiom (on page 86).  Are there crystals where this is not valid?\n\nNo, that is always valid, but `-oo - (-oo)` is not well-defined. So you have to be ever so slightly more careful when `-oo` is possible by always using the axiom version and not an \"equivalent\" version, like phi<sub>i</sub>(b) - epsilon<sub>i</sub>(b) = <h<sub>i</sub>, wt(b)>`.\n\n> The problem with a helper function is that the two differences (as noted in the code above) are executed extremely often, so every function call seems to come with an immense cost.   Of course, we could probably even cythonize... I tried this, and simply doing `cdef int m, T_pos, d` had quite a noticeable effect - but of course this relies even more on regularity, because for non-regular crystals `d` is a `float`.\n\nBut not everything should be ultra-optimized in distributed code is what I am saying. Ideally we could write things in Cython and make the helper function an inline, but we are mostly stuck (at least without some hacking) using Python. However, what I am saying now is that the code is starting to diverge enough for the two cases to justify (IMO) having two functions with mostly similar code.\n\nThere is perhaps also the question of rather than having a new category and instead Cythonizing the important class by creating a new element class for the regular highest weight tensor products that just contains this method. Since this is mostly working with the very basic data structures (lists, tuples, dicts, ints), there should be another good speed bump for that (especially when working with cythonized crystals). Although for that we get into a bit of duplicating the category framework at the element level, but maybe in this case, since we would have to create a new category anyways, it is not such a big deal.",
    "created_at": "2019-02-07T15:12:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378893",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:40 mantepse]:
> Hong and Kang have `phi_i(b) = epsilon_i(b) + <h^v_i, wt(b)>` as their first axiom (on page 86).  Are there crystals where this is not valid?

No, that is always valid, but `-oo - (-oo)` is not well-defined. So you have to be ever so slightly more careful when `-oo` is possible by always using the axiom version and not an "equivalent" version, like phi<sub>i</sub>(b) - epsilon<sub>i</sub>(b) = <h<sub>i</sub>, wt(b)>`.

> The problem with a helper function is that the two differences (as noted in the code above) are executed extremely often, so every function call seems to come with an immense cost.   Of course, we could probably even cythonize... I tried this, and simply doing `cdef int m, T_pos, d` had quite a noticeable effect - but of course this relies even more on regularity, because for non-regular crystals `d` is a `float`.

But not everything should be ultra-optimized in distributed code is what I am saying. Ideally we could write things in Cython and make the helper function an inline, but we are mostly stuck (at least without some hacking) using Python. However, what I am saying now is that the code is starting to diverge enough for the two cases to justify (IMO) having two functions with mostly similar code.

There is perhaps also the question of rather than having a new category and instead Cythonizing the important class by creating a new element class for the regular highest weight tensor products that just contains this method. Since this is mostly working with the very basic data structures (lists, tuples, dicts, ints), there should be another good speed bump for that (especially when working with cythonized crystals). Although for that we get into a bit of duplicating the category framework at the element level, but maybe in this case, since we would have to create a new category anyways, it is not such a big deal.



---

archive/issue_comments_378894.json:
```json
{
    "body": "Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)",
    "created_at": "2019-03-25T10:56:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378894",
    "user": "https://github.com/embray"
}
```

Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)



---

archive/issue_events_067518.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-03-25T10:56:15Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "milestone": "sage-8.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/26958#event-67518"
}
```



---

archive/issue_events_067519.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-07-03T11:37:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "milestone": "sage-8.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/26958#event-67519"
}
```



---

archive/issue_events_067520.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-07-03T11:37:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "milestone": "sage-8.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/26958#event-67520"
}
```



---

archive/issue_comments_378895.json:
```json
{
    "body": "Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).",
    "created_at": "2019-07-03T11:37:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378895",
    "user": "https://github.com/embray"
}
```

Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).



---

archive/issue_comments_378896.json:
```json
{
    "body": "Bot still seems to be morally green. Maybe this ticket could be easily resurrected ?",
    "created_at": "2019-10-29T13:55:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378896",
    "user": "https://github.com/fchapoton"
}
```

Bot still seems to be morally green. Maybe this ticket could be easily resurrected ?



---

archive/issue_comments_378897.json:
```json
{
    "body": "I actually do not know what I am supposed to do.  In particular, I do not remember what is wrong with the proposed code.  Perhaps Travis remembers?",
    "created_at": "2019-10-30T10:53:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378897",
    "user": "https://github.com/mantepse"
}
```

I actually do not know what I am supposed to do.  In particular, I do not remember what is wrong with the proposed code.  Perhaps Travis remembers?



---

archive/issue_comments_378898.json:
```json
{
    "body": "One definite problem is that this will fail if one of the crystals is infinite (see comment:39). The second is we were trying to avoid repeated calls to `epsilon(i)`/`phi(i)` when in the case of tensor product of regular crystals. This object exists in Cython, so we might want to do a special version there, where we can also take advantage of it being Cython too.",
    "created_at": "2019-10-31T01:03:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378898",
    "user": "https://github.com/tscrim"
}
```

One definite problem is that this will fail if one of the crystals is infinite (see comment:39). The second is we were trying to avoid repeated calls to `epsilon(i)`/`phi(i)` when in the case of tensor product of regular crystals. This object exists in Cython, so we might want to do a special version there, where we can also take advantage of it being Cython too.



---

archive/issue_comments_378899.json:
```json
{
    "body": "Thank you Travis! Since I cannot work on this in detail now, and the speedup with this patch is significant, would there be some quick fix?\n\nI don't quite understand the problem with one of the crystals being infinite, because in this case the current algorithm fails too, doesn't it?",
    "created_at": "2019-10-31T09:02:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378899",
    "user": "https://github.com/mantepse"
}
```

Thank you Travis! Since I cannot work on this in detail now, and the speedup with this patch is significant, would there be some quick fix?

I don't quite understand the problem with one of the crystals being infinite, because in this case the current algorithm fails too, doesn't it?



---

archive/issue_comments_378900.json:
```json
{
    "body": "Replying to [comment:47 mantepse]:\n> Thank you Travis! Since I cannot work on this in detail now, and the speedup with this patch is significant, would there be some quick fix?\n\nYes, it is more of a question of what to do in terms of implementation. However, I think I should be able to do it today.\n\n> I don't quite understand the problem with one of the crystals being infinite, because in this case the current algorithm fails too, doesn't it?\n\nYes, but for a different reason (it does not terminate because it wants to find all highest weight elements). It just needs a check or a restriction to finite crystals. I will think about the best way to do this.",
    "created_at": "2019-10-31T21:35:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378900",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:47 mantepse]:
> Thank you Travis! Since I cannot work on this in detail now, and the speedup with this patch is significant, would there be some quick fix?

Yes, it is more of a question of what to do in terms of implementation. However, I think I should be able to do it today.

> I don't quite understand the problem with one of the crystals being infinite, because in this case the current algorithm fails too, doesn't it?

Yes, but for a different reason (it does not terminate because it wants to find all highest weight elements). It just needs a check or a restriction to finite crystals. I will think about the best way to do this.



---

archive/issue_comments_378901.json:
```json
{
    "body": "Using a modified version from your comment:38, I now get\n\n```\nsage: n = 3; C = crystals.Spins([\"B\", n])\nsage: r = 10; T = crystals.TensorProduct(*([C]*r))\nsage: %time len(T.highest_weight_vectors())\nCPU times: user 2.11 s, sys: 31.5 ms, total: 2.14 s\nWall time: 2.14 s\n731808\n```\n\nvs your branch:\n\n```\nCPU times: user 2.38 s, sys: 35.7 ms, total: 2.42 s\nWall time: 2.42 s\n731808\n```\n\nIf I cut out storing each of the crystal factors in memory, I get roughly a 2x slowdown. However, I figure most crystals will be \"small\" so this is okay.\n\nI also now better handle the infinite crystal case.\n\nSo if my changes are okay, then positive review.\n----\nNew commits:",
    "created_at": "2019-11-06T02:48:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378901",
    "user": "https://github.com/tscrim"
}
```

Using a modified version from your comment:38, I now get

```
sage: n = 3; C = crystals.Spins(["B", n])
sage: r = 10; T = crystals.TensorProduct(*([C]*r))
sage: %time len(T.highest_weight_vectors())
CPU times: user 2.11 s, sys: 31.5 ms, total: 2.14 s
Wall time: 2.14 s
731808
```

vs your branch:

```
CPU times: user 2.38 s, sys: 35.7 ms, total: 2.42 s
Wall time: 2.42 s
731808
```

If I cut out storing each of the crystal factors in memory, I get roughly a 2x slowdown. However, I figure most crystals will be "small" so this is okay.

I also now better handle the infinite crystal case.

So if my changes are okay, then positive review.
----
New commits:



---

archive/issue_comments_378902.json:
```json
{
    "body": "Wonderful, thank you!",
    "created_at": "2019-11-06T09:40:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378902",
    "user": "https://github.com/mantepse"
}
```

Wonderful, thank you!



---

archive/issue_comments_378903.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-11-06T09:40:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378903",
    "user": "https://github.com/mantepse"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_067521.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2019-11-08T20:31:48Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/26958#event-67521"
}
```



---

archive/issue_comments_378904.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-11-08T20:31:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26958",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26958#issuecomment-378904",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
