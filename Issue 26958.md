# Issue 26958: slightly faster highest_weight_vectors_iterator

Issue created by migration from https://trac.sagemath.org/ticket/27195

Original creator: mantepse

Original creation time: 2019-01-31 23:48:23

CC:  tscrim aschilling




---

Comment by mantepse created at 2019-02-01 00:01:42

Changing status from new to needs_info.


---

Comment by mantepse created at 2019-02-01 00:01:42

New commits:


---

Comment by mantepse created at 2019-02-01 00:01:42

Changing type from PLEASE CHANGE to enhancement.


---

Comment by mantepse created at 2019-02-01 00:01:42

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by mantepse created at 2019-02-01 06:11:03

I have now a much faster version, obtained by replacing the the test for highest weight by what's necessary.  Still need to polish.


---

Comment by git created at 2019-02-01 10:57:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-02-01 11:01:47

I am now down to roughly a third of the time for 10-fold products:

```
sage: n = 3; C = crystals.Spins(["B", n])
sage: r = 10; T = crystals.TensorProduct(*([C]*r))
sage: %time len(T.highest_weight_vectors())
CPU times: user 18.3 s, sys: 196 ms, total: 18.5 s
Wall time: 18.5 s
731808
sage: %time len(list(T.highest_weight_vectors_iterator()))
CPU times: user 5.69 s, sys: 76 ms, total: 5.76 s
Wall time: 5.76 s
731808
```



---

Comment by git created at 2019-02-01 12:08:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-02-01 12:18:09

Changing status from needs_info to needs_review.


---

Comment by tscrim created at 2019-02-01 16:54:41

I believe you get a decent amount of speedup through the fact that you are not pushing/popping from a list. This is generally much slower (even if it is acting at the end) than if you are doing assignments in a fixed length list.

All crystals must have the same Cartan type in a tensor product, so they must have the same `index_set`. So that is redundant.

Your method is larger in memory usage because it lists every crystal element rather than iterating over them. So it is a trade-off, one which I am split on. I probably fall on the side of making the list since in principle, but the old code worked for infinite crystals (but would run forever). If anything, we probably want to run `C.list()` instead of `list(C)` as the former is cached.

I was going to say above that we should keep using `is_highest_weight`, but there is a fairly strong connection with the element class for the `TensorProductOfCrystals`. Moreover, you must compute `phi(i)` and `epsilon(i)` for every element and `i \in I`. Thus you should keep track of the running `phi` and apply the 2-fold tensor product formulas to change that by using the `epsilon`/`phi` of each element. Also, I think you should add another function

```python
# in the general tensor category
def _check_i_highest_weight(self, i, epsilon):
    return self.e(i) is None

# in the tensor product of regular crystals category
def _check_i_highest_weight(self, i, epsilon):
    return epsilon == 0
```

to avoid some extra `e(i)` computations in a large number of cases. This might be a minor slowdown in the general category, but I think it will be negligible.

Please give more descriptive variable names, e.g., `it_pos` makes it seem like it is the position of the iterator, not the data at `pos` in `it`. It might be better to unroll the `it` and use individual variables to avoid a bunch of list lookups (IIRC, it is faster to do this). Also maybe put a comment about your check (or if you go with the code change I suggested above).

I am not sure about manually keeping track of the positions compared to keeping iterators (and catching the `StopIteration`) for speed. Did you try both? Maybe it will be better with more descriptive variable names.

I am still not convinced that we should have an iterator method for this. I have never been too big of a fan of having two methods, where the first just runs a list of the second. Nevertheless, the `highest_weight_vectors` should use this implementation.


---

Comment by tscrim created at 2019-02-01 17:03:10

Changing status from needs_review to needs_work.


---

Comment by mantepse created at 2019-02-01 18:12:48

This improvement is not all that interesting without having it as an iterator, because I do not have enough memory to store all the highest weight vectors in a list for the cases I am interested in: arbitrary finite crystal, large tensor power.

It's mainly important for me to have this as a trac ticket, so I can share it easily with the people I am working with.

Thus, if you insist on not having an iterator, I'd rather not invest much more time for now - except for your confirmation that the index set is always the same (I wasn't absolutely sure if that's always true, thanks!) and except that I indeed would like to keep track of phi, but I am not skilled enough to do that efficiently and to be sure that what I am doing is correct.

I admit that I do not understand your code snippet.  Please elaborate - I am by no means a crystal expert!

Concerning the decisions I took: I tried about 10 different versions.  I think the biggest speedup comes from not using `is_highest_weight`, because that saves a lot of unneccessary computation.  The second largest chunk of time was to get rid of the iterators.

The amount of time spent for the setup code at the beginning is absolutely negligible.

I tried to unroll `it`, in several different ways.  The current version turned out to be the fastest.  I guess this will be even better by removing the index set, thanks again.


---

Comment by git created at 2019-02-01 18:34:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-02-01 18:42:19

With your observation concerning the index set I am down to 4.3 seconds!  That's wonderful!

If you elaborate a bit (I have a rough picture) on your comments concerning the computation of phi, I'll do that too.


---

Comment by mantepse created at 2019-02-01 19:31:57

One further question, since you mentioned infinite crystals.  Consider

```
sage: B = crystals.infinity.Tableaux("A1")
sage: T = B.tensor(B)
```

Now, after the natural naive adaptation of the code, I can do

```
sage: it = T.highest_weight_vectors_iterator()
sage: next(it)
[[[1]], [[1]]]
```

However, apparently in this tensor product, the highest weight words are

```
[[[1]], [[1, 2]]]
[[[1]], [[1, 2, 2]]]
[[[1]], [[1, 2, 2, 2]]]
```

rather than

```
[[[1, 2]], [[1]]]
[[[1, 2, 2]], [[1]]]
[[[1, 2, 2, 2]], [[1]]]
```

Is this a bug?

Bug or not, it implies that the iterator would not return, because it modifies left most positions first.


---

Comment by mantepse created at 2019-02-02 20:17:02

I think I figured out how to keep track of `phi`, see below.  Unfortunately, this doesn't quite work.  For example

```
sage: B = crystals.Tableaux(['A',2], shape=[1])
sage: La = RootSystem(['A',2]).weight_lattice().fundamental_weights()
sage: T = crystals.elementary.T(['A',2], La[2])
sage: Bp = T.tensor(B)
sage: Bp.highest_weight_vector()
```

fails when trying to compute `b1_phi` with `b1 = self.element_class(self, [])`, in the first line of `tensor_product_element.TensorProductOfCrystalsElement.phi`:

```
    def phi(self, i):
        P = self._list[-1].parent().weight_lattice_realization()
        h = P.simple_coroots()
        omega = P(self.weight()).scalar(h[i])
        return max(omega + self._sig(i, k) for k in range(1, len(self._list)+1))
```

In fact, I don't think it is correct to use `self` also as parent for shorter paths.  Ideally, I guess, it would be best not to call `b1.phi` at all, but to do so I have to figure out how to compute `phi(b1)` given `phi((b2, b1))`.
 

```
            def highest_weight_vectors_iterator(self, i):
                I = self.index_set()
                T_data = list(self.crystals[:-1]) + [self.crystals[-1].highest_weight_vectors()]
                T_data = [[0, len(elts), list(elts)] for elts, C in zip(T_data, self.crystals)]
                n = len(self.crystals)
                path = [None]*n
                b1 = None
                T_pos = n-1
                while T_pos < n:
                    C_data = T_data[T_pos]
                    if C_data[0] == C_data[1]:
                        T_pos += 1
                        b1 = None
                        C_data[0] = 0
                    else:
                        if b1 is None:
                            b1 = self.element_class(self, path[T_pos+1:])
                            b1_phi = {i: b1.phi(i) for i in I}
                        b2 = C_data[2][C_data[0]]
                        C_data[0] += 1
                        if all(b2.e(i) is None or b2.epsilon(i) <= b1_phi[i] for i in I):
                            path[T_pos] = b2
                            if T_pos:
                                b1 = self.element_class(self, path[T_pos:])
                                b1_phi = {i: b2.phi(i) + max(0, b1_phi[i] - b2.epsilon(i))
                                          for i in I}
                                T_pos -= 1
                            else:
                                yield self.element_class(self, path)
```



---

Comment by mantepse created at 2019-02-02 20:37:29

Never mind, I figured it out.  Nice speedup, I'll push after polishing.


---

Comment by git created at 2019-02-02 20:52:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2019-02-02 20:59:17

We can now iterate over the highest weight vectors in the 10-th tensor power of Spin(7) in about two seconds vs. 18 seconds before!

Thank you, Travis, for your very valuable hints!


---

Comment by mantepse created at 2019-02-02 21:21:14

Changing status from needs_work to needs_review.


---

Comment by mantepse created at 2019-02-03 00:25:43

The following would be still quite a bit faster, but comes at the cost of some readability.

Of course, if computing `epsilon` is expensive, this will make a lot of difference.

For example, I get

```
sage: n = 6; C = crystals.Spins(["B", n])
sage: r = 7; T = crystals.TensorProduct(*([C]*r))
sage: %timeit for _ in T.highest_weight_vectors_iterator(): pass
1 loop, best of 3: 2.87 s per loop
```

vs. 4 seconds with the current branch.



```diff
    diff --git a/src/sage/categories/highest_weight_crystals.py b/src/sage/categories/highest_weight_crystals.py
index cf41774830..e5694cd5bb 100644
--- a/src/sage/categories/highest_weight_crystals.py
+++ b/src/sage/categories/highest_weight_crystals.py
@@ -770,11 +770,19 @@ class HighestWeightCrystals(Category_singleton):
                         b2 = C_data[2][C_data[0]]
                         C_data[0] += 1
                         b1_phi = T_phi[T_pos]
-                        if all(b2.e(i) is None or b2.epsilon(i) <= b1_phi[i] for i in I):
+                        b1_phi_minus_b2_epsilon = {}
+                        for i in I:
+                            if b2.e(i) is not None:
+                                d = b1_phi[i] - b2.epsilon(i)
+                                if d < 0:
+                                    break
+                                b1_phi_minus_b2_epsilon[i] = d
+                        else:
                             path[T_pos] = b2
                             if T_pos:
                                 T_pos -= 1
-                                T_phi[T_pos] = {i: b2.phi(i) + max(0, b1_phi[i] - b2.epsilon(i))
+                                T_phi[T_pos] = {i: b2.phi(i) + \
+                                                max(0, b1_phi_minus_b2_epsilon.get(i, b1_phi[i] - b2.epsilon(i)))
                                                 for i in I}
                             else:
                                 yield self.element_class(self, path)
```



---

Comment by tscrim created at 2019-02-03 21:25:25

I would probably replace

```diff
-if all(b2.e(i) is None or b2.epsilon(i) <= b1_phi[i] for i in I):
+if all(_check_highest_weight(i, b2_ep[i]) is None or b2_ep[i] <= b1_phi[i] for i in I):
```

See comment:8. This should further improve for objects in `RegularCrystals` (which means `b.epsilon(i)` counts the number of `b.e(i)`'s you can do) in addition to your changes above.

I think readability concerns are somewhat gone at this point, and some code comments will help at they will explain what is going on in the code.


---

Comment by mantepse created at 2019-02-03 22:05:12

OK, I see the idea now - will try tomorrow.  For testing purposes: is there a finite non-regular crystal available in sage?


Could you comment briefly on comment:13?

Thanks again for your input!


---

Comment by mantepse created at 2019-02-04 21:57:18

The code looks best when restricting to tensor products of regular highest weight crystals.  I am guessing that this is the most important case, but it seems we do not have a category for that, do we?

```python

            def highest_weight_vectors_iterator(self):
                I = self.index_set()
                T_data = list(self.crystals[:-1]) + [self.crystals[-1].highest_weight_vectors()]
                T_data = [[0, len(elts), list(elts)] for elts, C in zip(T_data, self.crystals)]
                n = len(self.crystals)
                path = [None]*n
                T_phi = [None]*(n-1) + [{i: 0 for i in I}]
                T_pos = n-1
                while T_pos < n:
                    C_data = T_data[T_pos]
                    if C_data[0] == C_data[1]:
                        T_pos += 1
                        C_data[0] = 0
                    else:
                        b2 = C_data[2][C_data[0]]
                        C_data[0] += 1
                        b1_phi = T_phi[T_pos]
                        b1_phi_minus_b2_epsilon = {}
                        for i in I:
                            d = b1_phi[i] - b2.epsilon(i)
                            if d < 0:
                                break
                            b1_phi_minus_b2_epsilon[i] = d
                        else:
                            path[T_pos] = b2
                            if T_pos:
                                T_pos -= 1
                                T_phi[T_pos] = {i: b2.phi(i) + b1_phi_minus_b2_epsilon[i]
                                                for i in I}
                            else:
                                yield self.element_class(self, path)

```



---

Comment by tscrim created at 2019-02-05 03:08:11

In regards to comment:13. The `B(\infty)` crystal is very different than the highest weight crystals: it is only upper-regular, so `b.phi(i)` can be negative. Subsequently the tensor products are very different and quite wild (they have multiple highest weight vectors in a single component). This is a reflection in that category O is not closed under tensor products (e.g., the tensor product of 2 Verma modules is not in category O).

It is easy to create this category as it is just a `Category_singleton` with highest weight and regular crystals as super categories. The tensor category is also easy.

It is relatively simple to create a finite non-regular (irregular?) crystal. Take a finite subcrystal of, say, `B(\infty)`. There are also lots of 1-element crystals that are not regular, e.g., the `crystals.elementary.T`. Perhaps just for the sake of clarity we use the code you are proposing in comment:22. It is somewhat of a premature optimization for the non-regular crystals, and I don't expect such an optimization to be necessary in that case.


---

Comment by mantepse created at 2019-02-05 20:13:31

I (locally) added a category `RegularHighestWeightCrystals` and put the crystals that belong to both categories in, for example

```diff
@@ -75,7 +75,7 @@ class ClassicalCrystals(Category_singleton):
              Category of finite crystals,
              Category of highest weight crystals]
         """
-        return [RegularCrystals(), FiniteCrystals(), HighestWeightCrystals()]
+        return [RegularHighestWeightCrystals(), FiniteCrystals()]
```


In principle, this seems to work.

Main questions:

* does my approach look correct in principle?

* should I create a new file `regular_highest_weight_crystals.py`, or should I put the new category into `regular_crystals.py`?

* in `highest_weight_crystals.py`, should I

  a) keep the old code, or

  b) provide the most readable version of the new iterator - whatever that is?


---

Comment by mantepse created at 2019-02-06 13:27:15

Replying to [comment:23 tscrim]:
> In regards to comment:13. The `B(\infty)` crystal is very different than the highest weight crystals: it is only upper-regular, so `b.phi(i)` can be negative. Subsequently the tensor products are very different and quite wild (they have multiple highest weight vectors in a single component). This is a reflection in that category O is not closed under tensor products (e.g., the tensor product of 2 Verma modules is not in category O).

The documentation of `HighestWeightCrystals` says:

    A crystal is highest weight if it is acyclic; in particular, every
    connected component has a unique highest weight element, and that
    element generates the component.

Isn't then

```
sage: B = crystals.infinity.Tableaux("A3")
sage: T = B.tensor(B)
sage: T in HighestWeightCrystals
True
```

in contradiction to what you wrote?


---

Comment by tscrim created at 2019-02-06 15:32:29

I would appreciate it if you were less accusatory in your questions.

Yes, it is a bit of a contradiction, but that documentation is out of date. We didn't have many of the crystals that we have now when that was written. It is generally true, but mostly we should remove the "unique" part of that sentence. The statement in the category does hold true for objects in category O<sup>int</sup>. There is no bug here, just outdated documentation.


---

Comment by mantepse created at 2019-02-06 15:52:05

Please excuse me, I had no idea that I sound accusatory!  I am just not familiar with these more exotic crystals - most of my knowledge is from the documentation of sage - so I was really just asking a question.

In any case, the category `HighestWeightCrystals` is closed under tensor products, right?

I'll have to look up what the category `O` is, I'll do this right now.


---

Comment by mantepse created at 2019-02-06 15:58:29

Could you direct me to a definition of O?  Hong and Kang (the only book I have available) define O in 2.3, page 28 as follows:

    Its objects consist of weight modules V over 0 with finite dimensional weight spaces for which there exists a finite number of elements ... such that ... The morphisms are g-module homomorphisms. Note that the category O is closed under taking the finite direct sum or finite tensor product of objects from the category O.


---

Comment by tscrim created at 2019-02-06 18:13:16

The main category of representations we study with crystals is O<sup>int</sup>, where strings all have finite length. B(infty) lives in the bigger category O, which I believe has things that do not have crystal bases, but I might be wrong about that.  I am not sure of a good reference offhand.


---

Comment by mantepse created at 2019-02-06 18:27:54

OK, thank you! Let's get back to the ticket at hand :-)

If you want to, I can simply push my proposal so you can have a look.


---

Comment by tscrim created at 2019-02-06 18:29:50

I will not be able to look properly for a few hours or so. Although thinking a bit more, we still probably should have essentially the same implementation for both the regular and non regular cases. It just makes things better in the bigger picture.


---

Comment by mantepse created at 2019-02-06 19:52:42

No problem - it is almost bed time for me.  Here is my current code for the iterator, assuming finiteness.  There are only two lines which differ in the regular case, as indicated.  To accommodate infinite crystals, we could replace the list `T_elts` with a list of iterators, but as B(oo) shows, this is not enough. 

I don't really know why computing `self.e` is expensive, possibly because an element of the crystal has to be created?  Anyway, as you essentially proposed we could simply have a function that returns `True` is the crystal is regular and `self.e(i) is not None` otherwise.  I don't know what the best name for this is.  One problem might be that this occurs in the innermost loop.  I think the `max` is not very expensive anymore.


```python
            def highest_weight_vectors_iterator(self):
                I = self.index_set()
                n = len(self.crystals)
                T_elts = map(list, list(self.crystals[:-1])) + [list(self.crystals[-1].highest_weight_vectors())]
                T_cur = [0]*n
                T_len = [len(elts) for elts in T_elts]
                T_phi = [None]*(n-1) + [{i: 0 for i in I}]
                T_pos = n-1
                path = [None]*n
                while T_pos < n:
                    if T_cur[T_pos] == T_len[T_pos]:
                        T_cur[T_pos] = 0
                        T_pos += 1
                    else:
                        b2 = T_elts[T_pos][T_cur[T_pos]]
                        T_cur[T_pos] += 1
                        b1_phi = T_phi[T_pos]
                        b1_phi_minus_b2_epsilon = {}
                        for i in I:
                            d = b1_phi[i] - b2.epsilon(i)
                            # in the regular case, the next line is simply
                            # if d < 0:
                            if b2.e(i) is not None and d < 0:
                                break
                            b1_phi_minus_b2_epsilon[i] = d
                        else:
                            path[T_pos] = b2
                            if T_pos:
                                T_pos -= 1
                                # in the regular case, the next line is simply
                                # T_phi[T_pos] = {i: b2.phi(i) + b1_phi_minus_b2_epsilon[i]
                                #                for i in I}
                                T_phi[T_pos] = {i: b2.phi(i) + max(0, b1_phi_minus_b2_epsilon[i])
                                                for i in I}

                            else:
                                yield self.element_class(self, path)
```



---

Comment by mantepse created at 2019-02-06 22:03:01

I am very sorry, but I just realised that the code above is very likely incorrect for non-regular crystals: I was assuming that `phi(i)` of an empty tensor product is `0`.


---

Comment by mantepse created at 2019-02-06 22:53:42

I am not sure how to interpret the tensor rule for non-regular crystals.  It says
`phi_i((b2,b1) = max(phi_i(b2), phi_i(b1) + phi_i(b2) - epsilon_i(b2))`.  However, what are the rules if some of these are infinities?


---

Comment by tscrim created at 2019-02-06 23:06:37

They are never `oo`, but possibly `-oo`.


---

Comment by mantepse created at 2019-02-07 07:32:34

What happens if `epsilon_i(b2) == -oo` and `phi_i(b2)` and `phi_i(b1)` are finite?  How can we be sure that this doesn't happen?


---

Comment by mantepse created at 2019-02-07 07:54:43

Sorry, I think I got it.  The difference between `phi_i` and `epsilon_i` must be finite, because it is `<alpha^v_i, wt(b)>`...

So, I guess for the non-regular case I have to check this separately - currently, it may happen that `d = b1_phi[i] - b2.epsilon(i)` is `nan`.


---

Comment by mantepse created at 2019-02-07 10:20:27

The following should be correct for finite crystals.  Is there a simple (!) way to make `highest_weight_vectors` unavailable for infinite crystals (apart from creating categories `FiniteRegularHighestWeightCrystals`, etc.)?

```python
            def highest_weight_vectors_iterator(self):
                I = self.index_set()
                T_elts = map(list, list(self.crystals[:-1]))
                T_len = [len(elts) for elts in T_elts]
                m = len(self.crystals)-1
                for b in self.crystals[-1].highest_weight_vectors():
                    T_pos = m-1  # current tensor position
                    T_cur = [0]*m  # index of current element for each tensor position
                    path = [None]*m + [b]
                    # cache phi for path up to current tensor position
                    T_phi = [None]*(m-1) + [{i: b.phi(i) for i in I}]
                    while T_pos < m:
                        if T_cur[T_pos] == T_len[T_pos]:
                            T_cur[T_pos] = 0
                            T_pos += 1
                        else:
                            b2 = T_elts[T_pos][T_cur[T_pos]]
                            T_cur[T_pos] += 1
                            b1_phi = T_phi[T_pos]
                            b1_phi_minus_b2_epsilon = {}
                            # break if (b2, b1) is not highest weight
                            for i in I:
                                d = b1_phi[i] - b2.epsilon(i)
                                # In the non-regular case, d may be nan.
                                # In this case b2.e(i) is None,
                                # and we may rely on max(0, nan) == 0.
                                # In the regular case, the next line is simply
                                # if d < 0:
                                if b2.e(i) is not None and d < 0:
                                    break
                                b1_phi_minus_b2_epsilon[i] = d
                            else:
                                path[T_pos] = b2
                                if T_pos:
                                    T_pos -= 1
                                    # in the regular case, the next line is simply
                                    # T_phi[T_pos] = {i: b2.phi(i) + b1_phi_minus_b2_epsilon[i]
                                    #                for i in I}
                                    T_phi[T_pos] = {i: b2.phi(i) + max(0, b1_phi_minus_b2_epsilon[i])
                                                    for i in I}
                                else:
                                    yield self.element_class(self, path)
```



---

Comment by tscrim created at 2019-02-07 14:05:36

`T_elts = map(list, list(self.crystals[:-1]))` will fail for infinite crystals. The other option would be to put a test if `self in Sets().Infinite()` and raise a `NotImplementedError`.

As you surmised in comment:37, `phi = -oo` if and only if `epsilon == -oo`. However, in the general case you should not use `phi - epsilon` but instead `<h_i, wt>`, where `h_i` is the `i`-th simple coroot. Hmmm...it seems like having two close copies might be best, although it is a bit annoying code duplication, which is why I want to put those differences as little helper functions.


---

Comment by mantepse created at 2019-02-07 14:26:27

Hong and Kang have `phi_i(b) = epsilon_i(b) + <h^v_i, wt(b)>` as their first axiom (on page 86).  Are there crystals where this is not valid?

The problem with a helper function is that the two differences (as noted in the code above) are executed extremely often, so every function call seems to come with an immense cost.   Of course, we could probably even cythonize... I tried this, and simply doing `cdef int m, T_pos, d` had quite a noticeable effect - but of course this relies even more on regularity, because for non-regular crystals `d` is a `float`.


---

Comment by tscrim created at 2019-02-07 15:12:38

Replying to [comment:40 mantepse]:
> Hong and Kang have `phi_i(b) = epsilon_i(b) + <h^v_i, wt(b)>` as their first axiom (on page 86).  Are there crystals where this is not valid?

No, that is always valid, but `-oo - (-oo)` is not well-defined. So you have to be ever so slightly more careful when `-oo` is possible by always using the axiom version and not an "equivalent" version, like phi<sub>i</sub>(b) - epsilon<sub>i</sub>(b) = <h<sub>i</sub>, wt(b)>`.

> The problem with a helper function is that the two differences (as noted in the code above) are executed extremely often, so every function call seems to come with an immense cost.   Of course, we could probably even cythonize... I tried this, and simply doing `cdef int m, T_pos, d` had quite a noticeable effect - but of course this relies even more on regularity, because for non-regular crystals `d` is a `float`.

But not everything should be ultra-optimized in distributed code is what I am saying. Ideally we could write things in Cython and make the helper function an inline, but we are mostly stuck (at least without some hacking) using Python. However, what I am saying now is that the code is starting to diverge enough for the two cases to justify (IMO) having two functions with mostly similar code.

There is perhaps also the question of rather than having a new category and instead Cythonizing the important class by creating a new element class for the regular highest weight tensor products that just contains this method. Since this is mostly working with the very basic data structures (lists, tuples, dicts, ints), there should be another good speed bump for that (especially when working with cythonized crystals). Although for that we get into a bit of duplicating the category framework at the element level, but maybe in this case, since we would have to create a new category anyways, it is not such a big deal.


---

Comment by embray created at 2019-03-25 10:56:15

Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)


---

Comment by embray created at 2019-07-03 11:37:56

Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).


---

Comment by chapoton created at 2019-10-29 13:55:11

Bot still seems to be morally green. Maybe this ticket could be easily resurrected ?


---

Comment by mantepse created at 2019-10-30 10:53:13

I actually do not know what I am supposed to do.  In particular, I do not remember what is wrong with the proposed code.  Perhaps Travis remembers?


---

Comment by tscrim created at 2019-10-31 01:03:33

One definite problem is that this will fail if one of the crystals is infinite (see comment:39). The second is we were trying to avoid repeated calls to `epsilon(i)`/`phi(i)` when in the case of tensor product of regular crystals. This object exists in Cython, so we might want to do a special version there, where we can also take advantage of it being Cython too.


---

Comment by mantepse created at 2019-10-31 09:02:11

Thank you Travis! Since I cannot work on this in detail now, and the speedup with this patch is significant, would there be some quick fix?

I don't quite understand the problem with one of the crystals being infinite, because in this case the current algorithm fails too, doesn't it?


---

Comment by tscrim created at 2019-10-31 21:35:23

Replying to [comment:47 mantepse]:
> Thank you Travis! Since I cannot work on this in detail now, and the speedup with this patch is significant, would there be some quick fix?

Yes, it is more of a question of what to do in terms of implementation. However, I think I should be able to do it today.

> I don't quite understand the problem with one of the crystals being infinite, because in this case the current algorithm fails too, doesn't it?

Yes, but for a different reason (it does not terminate because it wants to find all highest weight elements). It just needs a check or a restriction to finite crystals. I will think about the best way to do this.


---

Comment by tscrim created at 2019-11-06 02:48:46

Using a modified version from your comment:38, I now get

```
sage: n = 3; C = crystals.Spins(["B", n])
sage: r = 10; T = crystals.TensorProduct(*([C]*r))
sage: %time len(T.highest_weight_vectors())
CPU times: user 2.11 s, sys: 31.5 ms, total: 2.14 s
Wall time: 2.14 s
731808
```

vs your branch:

```
CPU times: user 2.38 s, sys: 35.7 ms, total: 2.42 s
Wall time: 2.42 s
731808
```

If I cut out storing each of the crystal factors in memory, I get roughly a 2x slowdown. However, I figure most crystals will be "small" so this is okay.

I also now better handle the infinite crystal case.

So if my changes are okay, then positive review.
----
New commits:


---

Comment by mantepse created at 2019-11-06 09:40:28

Wonderful, thank you!


---

Comment by mantepse created at 2019-11-06 09:40:28

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2019-11-08 20:31:48

Resolution: fixed
