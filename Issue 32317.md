# Issue 32317: Add derivative operator

Issue created by migration from https://trac.sagemath.org/ticket/32554

Original creator: @spaghettisalat

Original creation time: 2021-09-23 16:20:24

Currently, the output of a derivative of a symbolic function has the annoying property that sagemath cannot read it back as input, for example the following does not work because `D` is not defined.


```
sage: function('f'); var('x y')                                                                                                                                                                                                
sage: diff(f(x+y),x)                                                                                                                                                                                               
D[0](f)(x + y)
sage: D[0](f)(x + 2*y)
```


This ticket implements such a derivative operator that fixes this inconsistency.


---

Comment by @spaghettisalat created at 2021-09-23 16:20:33

Changing status from new to needs_review.


---

Comment by nbruin created at 2021-09-23 17:35:49

It may be worth comparing with 

https://groups.google.com/g/sage-devel/c/xBHw11qUARg/m/0eqj3eUFsFkJ


```
from sage.symbolic.operators import FDerivativeOperator
class Doperator:
    def __init__(self, vars=None):
        self.vars = [] if vars is None else vars

    def __call__(self, f):
        return FDerivativeOperator(f, self.vars)

    def __getitem__(self, i):
        if isinstance(i, tuple):
            newvars = self. vars+list(i)
        else:
            newvars = self.vars+[i]
        return Doperator(newvars)

D=Doperator() 
```

which allows the bracket notation that is also output:

```
sage: var('x,y')
sage: D[0](f)(x, y)/x + D[0, 1](f)(x, y)
D[0](f)(x, y)/x + D[0, 1](f)(x, y) 
```

It also avoids an extra class definition, but that's probably more a matter of taste.


---

Comment by @spaghettisalat created at 2021-09-23 19:28:19

Replying to [comment:2 nbruin]:
> It may be worth comparing with 
> 
> https://groups.google.com/g/sage-devel/c/xBHw11qUARg/m/0eqj3eUFsFkJ
> 
> {{{
> from sage.symbolic.operators import FDerivativeOperator
> class Doperator:
>     def __init__(self, vars=None):
>         self.vars = [] if vars is None else vars
> 
>     def __call__(self, f):
>         return FDerivativeOperator(f, self.vars)
> 
>     def __getitem__(self, i):
>         if isinstance(i, tuple):
>             newvars = self. vars+list(i)
>         else:
>             newvars = self.vars+[i]
>         return Doperator(newvars)
> 
> D=Doperator() 
> }}}
> which allows the bracket notation that is also output:
> {{{
> sage: var('x,y')
> sage: D[0](f)(x, y)/x + D[0, 1](f)(x, y)
> D[0](f)(x, y)/x + D[0, 1](f)(x, y) 
> }}}
> It also avoids an extra class definition, but that's probably more a matter of taste.


My solution is a bit stricter with the syntax and doesn't allow things like `D(f)` or `D[0][0](f)`, which is why I need two separate classes. But I don't mind the other solution either. The important thing for me is that input and output are consistent.


---

Comment by nbruin created at 2021-09-23 22:55:28

OK. I don't think it matters much which version is included. As you can see in the discussion from 2012, the tricky bit is where this code should go and whether we can actually claim D in the global namespace for it.


---

Comment by @spaghettisalat created at 2021-09-24 15:20:54

Replying to [comment:4 nbruin]:
> OK. I don't think it matters much which version is included. As you can see in the discussion from 2012, the tricky bit is where this code should go

I don't understand this. Is there a problem with putting the definition in `sage/symbolic/operators.py`?

> and whether we can actually claim D in the global namespace for it.

I don't think having `D` in the global namespace is a big problem; already we have several single letter functions predefined in the global namespace even for pretty exotic things (such as `r` and `R` for the R programming language interpreter or `E` for the function returning the n-th root of unity as an element of the universal cyclotomic field). And `var('D')` will simply overwrite the newly introduced derivative operator, so existing code which uses variables called `D` will continue to work.


---

Comment by mkoeppe created at 2021-12-18 19:53:12

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.
