# Issue 22865: Support __richcmp__ in Python classes

Issue created by migration from https://trac.sagemath.org/ticket/23102

Original creator: jdemeyer

Original creation time: 2017-05-30 08:25:08

CC:  chapoton tscrim embray

Sage has a lot of functionality to deal with "rich comparisons" using `__richcmp__` in Cython or `_richcmp_` in Python/Cython for subclasses of `Element`. However, we are still missing rich comparison support for Python classes which are not subclasses from `Element`.

A good example of this is `RealSet` in `src/sage/sets/real_set.py`. Currently, comparison is implement using `__cmp__`. Changing this to Python 3 comparisons would normally require 6 methods (`__eq__`, `__ne__`, `__lt__`, `__le__`, `__gt__`, `__ge__`). It would be convenient to support this with just one `__richcmp__` method like in Cython.

This ticket proposes:

1. Add a decorator `richcmp_method` which adds support for `__richcmp__` to a Python class.

2. Implement `RealSet.__richcmp__` using this.


---

Comment by tscrim created at 2017-05-30 14:05:01

What about using ``@`total_ordering` to reduce the number of rich comparison methods? I know this is an abuse of terminology, but it does mean we only need to define `__eq__` and `__lt__`. However, I generally do like the idea of having a consistent API.


---

Comment by jdemeyer created at 2017-05-30 15:00:10

Replying to [comment:2 tscrim]:
> What about using ``@`total_ordering` to reduce the number of rich comparison methods?

1. ``@`total_ordering` reduces the number of rich comparison methods from 6 to 2. This ticket reduces it from 6 to 1.

2. ``@`total_ordering` is less efficient (if you only have `==` and `<`, you might need two calls to determine `<=`)
----
New commits:


---

Comment by jdemeyer created at 2017-05-30 15:01:00

Changing status from new to needs_review.


---

Comment by chapoton created at 2017-05-31 06:07:54

Note that from #22828, there is

```
def richcmp_by_eq_and_lt(left, right, op):
```

in

```
src/sage/rings/asymptotic/misc.py
```

that should also be moved to the common new place.


---

Comment by jdemeyer created at 2017-05-31 07:38:25

Replying to [comment:8 chapoton]:
> Note that from #22828, there is
> {{{
> def richcmp_by_eq_and_lt(left, right, op):
> }}}
> in
> {{{
> src/sage/rings/asymptotic/misc.py
> }}}
> that should also be moved to the common new place.

Makes sense. I created #23109 for that.


---

Comment by tscrim created at 2017-06-01 05:20:36

Typo in `richcmp_method`: `mtehod`. Have you run some timings to compare how this works versus direct implementation versus ``@`total_ordering` in Python classes? I can do this, but not for 2-3 days because I will be traveling.


---

Comment by jdemeyer created at 2017-06-01 08:20:59

Replying to [comment:10 tscrim]:
> Have you run some timings to compare how this works versus direct implementation versus ``@`total_ordering` in Python classes? I can do this, but not for 2-3 days because I will be traveling.

I just did that, see [attachment:cmp-timing.py]

First of all, for a plain equality check (``@`total_ordering` is not involved in this), the timing is almost the same for `__eq__` and `__richcmp__`, the latter being just slightly slower:

```
sage: load("cmp-timing.py")
sage: timeit('A1 == A2', number=1000000, repeat=100)
1000000 loops, best of 100: 281 ns per loop
sage: timeit('B1 == B2', number=1000000, repeat=100)
1000000 loops, best of 100: 293 ns per loop
```


Now, comparisons involving ``@`total_ordering` take almost twice or three times as much time:

```
sage: load("cmp-timing.py")
sage: timeit('A1 > A2', number=1000000, repeat=20)   # calls A2.__lt__(A1)
1000000 loops, best of 20: 557 ns per loop
sage: timeit('B1 > B2', number=1000000, repeat=20)
1000000 loops, best of 20: 292 ns per loop
```


```
sage: load("cmp-timing.py")
sage: timeit('A2 <= A1', number=1000000, repeat=20)  # Calls A2.__lt__(A1) and A2.__eq__(A1)
1000000 loops, best of 20: 820 ns per loop
sage: timeit('B2 <= B1', number=1000000, repeat=20)
1000000 loops, best of 20: 293 ns per loop
```

As one might expect, the time is roughly linear in the number of Python method calls.


---

Attachment

Small script to test timing


---

Comment by tscrim created at 2017-06-01 08:25:50

Thank you for running those timings. That is more than enough to convince me. If tests pass, you can set a positive review on my behalf. Sleepy time for me now. :)


---

Comment by git created at 2017-06-01 09:30:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-06-01 09:31:21

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-06-07 20:13:21

Resolution: fixed


---

Comment by vbraun created at 2017-06-09 18:37:06

Resolution changed from fixed to 


---

Comment by vbraun created at 2017-06-09 18:37:06

This happened randomly:

```
sage -t --long src/sage/sets/real_set.py
**********************************************************************
File "src/sage/sets/real_set.py", line 701, in sage.sets.real_set.RealSet.__richcmp__
Failed example:
    cmp(I1, I2)
Expected:
    1
Got:
    -1
**********************************************************************
File "src/sage/sets/real_set.py", line 703, in sage.sets.real_set.RealSet.__richcmp__
Failed example:
    sorted([I1, I2])
Expected:
    [(0, 5], (1, 3]]
Got:
    [(1, 3], (0, 5]]
**********************************************************************
1 item had failures:
   2 of   6 in sage.sets.real_set.RealSet.__richcmp__
    [203 tests, 2 failures, 0.55 s]
```



---

Comment by vbraun created at 2017-06-09 18:37:06

Changing status from closed to new.


---

Comment by jdemeyer created at 2017-06-12 13:32:18

Confirmed. It seems that the category framework gets in the way. Commenting out this line fixes the problem

```
Parent.__init__(self, category = Sets())
```



---

Comment by tscrim created at 2017-06-12 13:35:12

I really would not want to go backwards in category initalization for parents. Although the category methods should not be interfering. I don't see how they would cause problems...


---

Comment by jdemeyer created at 2017-06-12 13:42:59

Replying to [comment:18 tscrim]:
> I really would not want to go backwards in category initalization for parents.

Sorry, I didn't say that we should remove that line. Just that removing that line fixes this specific problem that `__richcmp__` doesn't work.


---

Comment by jdemeyer created at 2017-06-12 13:46:23

OK, the real problem is that the `richcmp_method` decorator doesn't work with subclassing. It only works on the class where it is defined, not on subclasses. Given that the category framework creates a `RealSet_with_category` subclass, this breaks.


---

Comment by tscrim created at 2017-06-12 13:57:38

Replying to [comment:19 jdemeyer]:
> Replying to [comment:18 tscrim]:
> > I really would not want to go backwards in category initalization for parents.
> 
> Sorry, I didn't say that we should remove that line. Just that removing that line fixes this specific problem that `__richcmp__` doesn't work.

I didn't mean to imply you were. I just wanted to make it clear that we didn't want to do this in case someone else came along and saw this.


---

Comment by tscrim created at 2017-06-12 14:07:35

Replying to [comment:20 jdemeyer]:
> OK, the real problem is that the `richcmp_method` decorator doesn't work with subclassing. It only works on the class where it is defined, not on subclasses. Given that the category framework creates a `RealSet_with_category` subclass, this breaks.

Perhaps the way to go would be to bind `__eq__` and friends to a particular class that compare with the `__richcmp__`?


---

Comment by jdemeyer created at 2017-06-12 15:10:25

OK, I think the problem is that my trick doesn't add slot wrappers (attributes like `__eq__` on the class). I'll try to add those wrappers and see if that works.


---

Comment by jdemeyer created at 2017-06-14 08:33:01

New commits:


---

Comment by jdemeyer created at 2017-06-14 08:33:01

Changing status from new to needs_review.


---

Comment by tscrim created at 2017-06-14 12:18:28

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2017-06-14 12:18:28

If I understand correctly what is going on, then yes, this should work in general. So I'm going to set it to a positive review since it works AFAIK.

Erik, I'm cc-ing you in case you know something about the inner workings of Python and can confirm the code looks proper. If you don't, then no need to respond.


---

Comment by jdemeyer created at 2017-06-14 12:23:33

Of course, none of this slot stuff is documented anywhere in the Python docs... the only way to figure it out is to read the Python source code.


---

Comment by embray created at 2017-06-15 08:44:47

Why


```
if type(slotwrapper).__name__ != 'wrapper_descriptor':
```


and not explicitly something like


```
if type(slotwrapper) != PyWrapperDescr_Type:
```

?


---

Comment by embray created at 2017-06-15 08:44:47

Changing status from positive_review to needs_info.


---

Comment by embray created at 2017-06-15 09:34:14

One other minor concern:  If a class has both `__richcmp__` and, say, `__lt__`, this will just silently override the `__lt__`.  For consistency with Cython, I'd say having both should be an outright error (with Cython it will just raise a compiler error if you try to define `__lt__` in a `cdef` class).  So maybe it should raise a `RuntimeError` if a class tries to define both.

But that also raises the question of what to do with subclasses.  If you subclass a class with `__richcmp__` and add an `__lt__` in the subclass, the subclass's `__lt__` should take over.  I _think_ that's what will happen anyways.

But what if you subclass a class that has `__lt__` and add `__richcmp__` in the subclass?


---

Comment by embray created at 2017-06-15 09:37:38

> But what if you subclass a class that has `__lt__` and add `__richcmp__` in the subclass?

To answer my own question, this wouldn't be a concern I guess since this will just override the parent class's `__lt__` and that's to be expected.

It would be good to have a test of subclassing and overriding one of the comparison operators though.


---

Comment by vbraun created at 2017-06-15 16:45:28

Resolution: fixed


---

Comment by vbraun created at 2017-06-15 16:52:30

Resolution changed from fixed to 


---

Comment by vbraun created at 2017-06-15 16:52:30

Changing status from closed to new.


---

Comment by vbraun created at 2017-06-15 16:52:30

ready to merge == positive review != let somebody else look at it first, Travis


---

Comment by jdemeyer created at 2017-06-15 19:59:42

So, is it merged or not? I think Erik's comments make sense, but they could easily be addressed in a follow-up ticket.


---

Comment by vbraun created at 2017-06-15 22:07:32

Not merged


---

Comment by embray created at 2017-06-16 08:07:14

They could definitely be addressed in a followup ticket (if indeed my comments need addressing at all).


---

Comment by embray created at 2017-06-16 08:11:53

As an aside, I wonder if there's ever been a proposal to actually support `__richcmp__` in user-defined classes (in a manner similar to this, such that it would automatically implment the individual comparison methods).  And if it has been proposed I wonder why it was rejected.  I'm going to search around a bit for answers...


---

Comment by embray created at 2017-06-16 08:23:47

A close reading of PEP-207 reveals:

> The choice of six special methods was made over a single (e.g. `__richcmp__`) method to allow the dispatching on the opcode to be performed at the level of the C implementation rather than the user-defined method.

which makes perfect sense. But, if as Sage demonstrates, there's a usecase for a single user-defined `__richcmp__` I don't see why it shouldn't be an option...


---

Comment by tscrim created at 2017-06-16 13:16:41

Changing status from new to needs_info.


---

Comment by tscrim created at 2017-06-16 13:16:41

As Jeroen and Erik said, I felt it could be merged into Sage and further changes could be handled on followup tickets.
----
New commits:


---

Comment by jdemeyer created at 2017-06-16 13:29:37

I'll work on it right now.


---

Comment by git created at 2017-06-16 13:31:09

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-06-16 13:41:01

Travis: you put back the wrong branch. This is the original branch, rebased to 8.0.beta11.


---

Comment by tscrim created at 2017-06-16 13:46:05

Ah, sorry; I had thought `u/jdemeyer/acfd0aaea4de51b64c21fdd1a7a8d6e9174448de` was just a trac formatting error.


---

Comment by jdemeyer created at 2017-06-16 14:11:14

Replying to [comment:28 embray]:
> {{{
> if type(slotwrapper) != PyWrapperDescr_Type:
> }}}

Good point. It didn't occur to me to use the C/API for this. Python doesn't expose this type anywhere AFAIK, but the C/API does.


---

Comment by git created at 2017-06-16 15:03:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-06-16 15:04:21

Changing status from needs_info to needs_review.


---

Comment by jdemeyer created at 2017-06-16 15:04:21

I think this addresses all Erik's concerns.


---

Comment by embray created at 2017-06-16 15:33:59

Replying to [comment:43 jdemeyer]:
> Replying to [comment:28 embray]:
> > {{{
> > if type(slotwrapper) != PyWrapperDescr_Type:
> > }}}
> 
> Good point. It didn't occur to me to use the C/API for this. Python doesn't expose this type anywhere AFAIK, but the C/API does.

You can get at it in Python, for example, with `type(bytes.__lt__)`, but in Cython you might as well just use the type directly since it's exposed by the C API.


---

Comment by chapoton created at 2017-06-19 17:14:53

is this ready to go ?


---

Comment by jdemeyer created at 2017-06-20 08:19:29

Erik?


---

Comment by embray created at 2017-06-20 08:21:31

Yep, perfect--thanks.


---

Comment by embray created at 2017-06-20 08:21:31

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-06-22 07:24:28

Resolution: fixed
