# Issue 15481: Implement the __init_extra__ protocol of categories for Cython classes.

Issue created by migration from https://trac.sagemath.org/ticket/15718

Original creator: nthiery

Original creation time: 2014-01-23 17:20:20




---

Comment by SimonKing created at 2014-01-23 18:02:16

It would probably be rather easy:

Currently, we only look into the mro of the class; if the class is a Python class, then it is a subclass of the category's parent class (since the quest for `__init_extra__` takes place after category initialisation). But in the case of Cython class, we simply need to look explicitly into _both_ the class' mro and the category's parent class' mro.

It would detect a lot of Cython classes in which the call to `Parent.__init__` happens too early for `__init_extra__` to work... But these would be exactly the classes that currently do not allow Python subclasses.


---

Comment by nthiery created at 2014-01-24 09:53:42

Replying to [comment:1 SimonKing]:
> It would probably be rather easy:
> 
> Currently, we only look into the mro of the class; if the class is a Python class, then it is a subclass of the category's parent class (since the quest for `__init_extra__` takes place after category initialisation). But in the case of Cython class, we simply need to look explicitly into _both_ the class' mro and the category's parent class' mro.

+1!

For the record: this will require calling
sage.misc.structure.getattr_from_other_class, to emulate the parent
being an instance of the category's parent class.


---

Comment by SimonKing created at 2014-01-24 10:25:23

Replying to [comment:2 nthiery]:
> For the record: this will require calling
> sage.misc.structure.getattr_from_other_class, to emulate the parent
> being an instance of the category's parent class.

I disagree. If I recall correctly, we look up the _whole_ class hierarchy and execute _all_ `__init_extra__` methods that we can find. `getattr_from_other_class` would only return _one_ `__init_extra__`, but we want all, and thus we need to go up both the Cython class' and the category's parent class' mro.


---

Comment by nthiery created at 2014-01-24 10:35:25

Replying to [comment:3 SimonKing]:
> If I recall correctly, we look up the _whole_ class hierarchy and execute _all_ `__init_extra__` methods that we can find.

Yes!

Still, some magic will be needed to bind each such method to the
object and call it (by default Python refuses to bind a method of a
class to a non-instance of that class); that's were
`getattr_from_other_class` (or some subpiece thereof) will come into
play.


---

Comment by SimonKing created at 2014-01-24 10:51:50

Replying to [comment:4 nthiery]:
> Still, some magic will be needed to bind each such method to the
> object and call it (by default Python refuses to bind a method of a
> class to a non-instance of that class); that's were
> `getattr_from_other_class` (or some subpiece thereof) will come into
> play.

Do we need to bind it? We just want to _call_ it.


---

Comment by SimonKing created at 2014-01-24 12:09:00

Replying to [comment:5 SimonKing]:
> Do we need to bind it? We just want to _call_ it.

Such as:

```
sage: R.<x,y> = ZZ[]
sage: C = Algebras(ZZ).parent_class
sage: C.__init_extra__.__func__(R)
```



---

Comment by SimonKing created at 2014-01-24 12:13:01

I just tested: When one empties the coercion cache and the coerce_from_list, then calling `C.__init_extra__.__func__(R)` will fill it again, which is its purpose. So, it works without binding.


---

Comment by nbruin created at 2014-01-24 15:32:46

Replying to [comment:7 SimonKing]:
> I just tested: When one empties the coercion cache and the coerce_from_list, then calling `C.__init_extra__.__func__(R)` will fill it again, which is its purpose. So, it works without binding.

Well ... that works when `C.__init_extra__` is an unbound method that has a `__func__` attribute. Likely all unbound methods do, so you've probably dealt with the case that `__init_extra__` is an unbound method. But attributes aren't necessarily! I think only unbound methods bind when called as attributes on instances. Other objects just get called. But that's a case you should test for if you want this to be properly compatible with python's inheritance. Unbound methods aren't the only things that lead to callable attributes on instances.


---

Comment by nthiery created at 2014-01-25 11:05:36

I guess it's fair enough to write in the specifications of the protocol that __init_extra__ shall be a method. And if some day we have a serious use case (which I kind of doubt), it will always be time to generalize the protocol.


---

Comment by nbruin created at 2014-01-25 19:08:12

Replying to [comment:9 nthiery]:
> I guess it's fair enough to write in the specifications of the protocol that __init_extra__ shall be a method.

You'll have to be careful how you formulate that: `cdef` classes can have methods too (some custom cython object of course) and their unbound versions specifically call themselves "method" and have no `__func__` attribute. They are callable, though, further suggesting one should probably check if the attribute is callable and if not, see if there is a __func__ attribute that is callable (or some safe permutation of this that performs better)

> And if some day we have a serious use case (which I kind of doubt), it will always be time to generalize the protocol.

Famous last words... I've seen many cases happen in sage where little design issues (which, at the time perpetrated seemed perfectly reasonable) lead to weird, unforseen and silent failures. The problem this ticket is trying to fix is one of them.


---

Comment by SimonKing created at 2014-01-25 21:43:29

Replying to [comment:10 nbruin]:
> You'll have to be careful how you formulate that: `cdef` classes can have methods too (some custom cython object of course) and their unbound versions specifically call themselves "method" and have no `__func__` attribute.

Note that the idea is to go up `self.__class__.mro()` on the one hand, and `self.category().parent_class.mro()`, on the other hand. The former is no problem, since self is an instance of its class and thus we don't need the `__func__` attribute. The latter is (currently, at least) no problem, since parent classes of categories are Python classes and thus have `__func__` on their methods. Or am I mistaken?


---

Comment by nbruin created at 2014-01-26 04:56:59

Replying to [comment:11 SimonKing]:
> Note that the idea is to go up `self.__class__.mro()` on the one hand, and `self.category().parent_class.mro()`, on the other hand. The former is no problem, since self is an instance of its class and thus we don't need the `__func__` attribute. The latter is (currently, at least) no problem, since parent classes of categories are Python classes and thus have `__func__` on their methods. Or am I mistaken?
Well, anything can be assigned to attributes in principle, regardless of whether something is a python class or not. Should we ever migrate to Python 3 then there are no unbound instancemethods at all: they are just plain functions there.

So I'd say:
 * check if `__init_extra__.im_func` exists (this indicates an `instancemethod` object). If so, perhaps check if `__init_extra__.im_self` is None (unbound method). If it does, then call `im_func`.
 * otherwise, just call `__init_extra__`.
It's hardly more coding work and should be far more robust.


---

Comment by nthiery created at 2014-01-26 08:08:45

Replying to [comment:12 nbruin]:
> So I'd say:
>  * check if `__init_extra__.im_func` exists (this indicates an `instancemethod` object).

or use inspect.ismethod.


---

Comment by SimonKing created at 2015-07-23 15:01:03

Ping to myself. I think the `__init_extra__` can be called similar to what I did in #18756/#18758.


---

Comment by SimonKing created at 2015-07-23 16:08:57

Very strange. The following does not work, even in Python:

```
            sage: from sage.structure.element import RingElement
            sage: class E(RingElement):
            ....:     def __init__(self, P, n):
            ....:         self.n = n
            ....:         RingElement.__init__(self, P)
            ....:     def _repr_(self):
            ....:         return "<{}>".format(self.n)
            ....:     def _mul_(self, other):
            ....:         return self.parent()(self.n*other.n)
            ....:     def _add_(self, other):
            ....:         return self.parent()(self.n+other.n)
            ....:     def _lmul_(self, other):
            ....:         return self.parent()(self.n*other)
            sage: class P(Parent):
            ....:     Element = E
            sage: p = P(base=ZZ, category=Algebras(ZZ))
            sage: p.has_coerce_map_from(ZZ)
            False
```

I found that `UnitalAlgebras.ParentMethods.__init_extra__` is called. However, it is claimed that the (absence of a) coerce map from ZZ has already been cached, which means that the clearly existing coercion via multiplication with `p.one()` is not registered.

At what point is a coercion from ZZ requested *before* calling `__init_extra__`?


---

Comment by SimonKing created at 2015-07-23 16:17:28

Shoot! One needs to do

```
            ....:     def _lmul_(self, other):
            ....:         return self.parent().element_class(self.parent(),self.n*other)
```

since `self.parent()(something)` apparently tries to find a coercion from `something.parent()` to `self.parent()`.


---

Comment by SimonKing created at 2015-07-23 16:43:43

To make sage start, it was also needed to declare that `MPolynomialRing_libsingular` uses a custom coercion from the base ring. Oops, I just note that the new doctest doesn't pass. Sorry.
----
New commits:


---

Comment by git created at 2015-07-23 16:45:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-23 16:46:17

With the additional commit, tests in sage.structure.parent pass, and I hope they do elsewhere, too.


---

Comment by SimonKing created at 2015-07-23 16:46:17

Changing status from new to needs_review.


---

Comment by SimonKing created at 2015-07-24 09:47:41

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2015-07-24 09:47:41

Oops:

```
sage -t src/sage/algebras/free_algebra.py  # Killed due to segmentation fault
sage -t src/sage/algebras/letterplace/letterplace_ideal.pyx  # Killed due to segmentation fault
sage -t src/sage/algebras/letterplace/free_algebra_element_letterplace.pyx  # Killed due to segmentation fault
sage -t src/sage/algebras/letterplace/free_algebra_letterplace.pyx  # Killed due to segmentation fault
sage -t src/sage/categories/pushout.py  # 5 doctests failed
sage -t src/sage/categories/homset.py  # 4 doctests failed
sage -t src/sage/rings/quotient_ring_element.py  # Killed due to segmentation fault
sage -t src/sage/rings/ring.pyx  # Killed due to segmentation fault
sage -t src/sage/rings/quotient_ring.py  # Killed due to segmentation fault
sage -t src/sage/rings/polynomial/polynomial_quotient_ring.py  # 35 doctests failed
sage -t src/sage/rings/polynomial/polynomial_quotient_ring_element.py  # 6 doctests failed
```

Sorry, I am currently unable to continue work on this. I suppose the solution is to either change the point at which `Parent.__init__` is called (since it tests whether `self.one()` works and multiplication works, it needs to be done rather late), or to indicate that there is a custom coercion that is better than the default coerce map (which is what I did in the case of multivariate polynomial rings).


---

Comment by SimonKing created at 2015-07-24 14:18:29

I couldn't resist working on it.

In some cases, the problem is that a parent has not been given a base(ring), however it is initialised in the category of unital algebras, which means that it *has* a base(ring).

Should we perhaps modify `CategoryObject.__init__`, which currently just defines `self._base` and then initialises the category? It could additionally define a base for the parent, if the given category has a base.


---

Comment by SimonKing created at 2015-07-24 14:54:07

Replying to [comment:25 SimonKing]:
> Should we perhaps modify `CategoryObject.__init__`, which currently just defines `self._base` and then initialises the category? It could additionally define a base for the parent, if the given category has a base.

It looks like a good idea, but would break an awful lot of things. `:-(`.


---

Comment by git created at 2015-07-24 15:41:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-24 15:47:54

Now things should work.

Changes:
- For letterplace rings, one has to call the parent init later, so that the conversions that occur in `__init_extra__` work.
- In pushout.py, there is one test where a class is defined as a subclass of a parent-class-with-category. By consequence, an instance of that class is not correctly category-initialised.
- I just realise that I forgot some fixes for tests in homset.py. Here is problematic what I mentioned above: The base ring is not given, but the category has a base ring, and because of the missing base ring, `__init_extra__` fails. Fixing it now...


---

Comment by git created at 2015-07-24 15:49:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-24 15:50:42

Done! Now tests should pass (at least the previously failed tests should now be fixed...). Needs review!


---

Comment by SimonKing created at 2015-07-24 15:50:42

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2015-07-25 05:21:06

Replying to [comment:30 SimonKing]:
> Now tests should pass

They do, on my machine at least.


---

Comment by saraedum created at 2016-10-19 04:16:41

Build fails.


---

Comment by saraedum created at 2016-10-19 04:16:41

Changing status from needs_review to needs_work.


---

Comment by saraedum created at 2016-10-19 04:21:41

The changes look fine to me. It can be set to positive review once the build errors are fixed.


---

Comment by jdemeyer created at 2016-10-19 14:44:47

It would be nice to have an explanation of what this branch does and which problem it solves.

I would like to know why traversing the `mro()` this way is a reasonable solution. I don't know anything else in Python which does that. Why not use more standard Python idioms like `super()` calls?


---

Comment by jdemeyer created at 2016-10-19 14:47:54

Also: since this code seems to involve categories, why is it in `Parent` and not `CategoryObject`?


---

Comment by mkoeppe created at 2020-07-08 20:17:06

Rebased on 9.2.beta3
----
New commits:


---

Comment by mkoeppe created at 2020-07-08 20:17:06

Changing status from needs_work to needs_info.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by mkoeppe created at 2021-07-19 00:44:56

Setting a new milestone for this ticket based on a cursory review.


---

Comment by mkoeppe created at 2021-12-18 19:53:12

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.
