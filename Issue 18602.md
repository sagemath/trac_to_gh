# Issue 18602: Boost Dominator Tree

Issue created by migration from Trac.

Original creator: borassi

Original creation time: 2015-07-02 08:16:52

CC:  ncohen dcoudert




---

Comment by borassi created at 2015-07-02 08:20:14

Changing component from PLEASE CHANGE to graph theory.


---

Comment by borassi created at 2015-07-02 08:20:14

Changing type from PLEASE CHANGE to enhancement.


---

Comment by borassi created at 2015-07-02 08:20:14

Changing keywords from "" to "Dominator tree, Boost".


---

Comment by borassi created at 2015-07-02 10:48:45

Changing status from new to needs_review.


---

Comment by borassi created at 2015-07-02 10:48:45

This is the first draft of the Boost algorithm for computing dominator trees (see https://en.wikipedia.org/wiki/Dominator_%28graph_theory%29 for the definition of dominator tree).

----
New commits:



---

Comment by dcoudert created at 2015-07-03 17:08:38

Nicely done.

May be you could combine methods  `dominator_tree_dictionary` and `dominator_tree` using an optional parameter (e.g., `return_dict=False`) ?

Actually I don't know which is the most useful: the tree or the dictionary.

Also, I suggest

```
- edges = [This is the Trac macro *v,dom_tree_dict[v* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#v,dom_tree_dict[v-macro) for v in dom_tree_dict.keys() if dom_tree_dict[v] is not None]
+ edges = [[v,dom_v] for v,dom_v in dom_tree_dict.iteritems() if not dom_v is None]
```



---

Comment by ncohen created at 2015-07-03 17:12:17

> May be you could combine methods  `dominator_tree_dictionary` and `dominator_tree` using an optional parameter (e.g., `return_dict=False`) ?
+1

Also, you do not need to write two functions (with doc+test) when everything it does is call another function defined outside, in a module. You will find many such examples at the bottom of `generic_graph.py`.

Nathann


---

Comment by git created at 2015-07-06 07:43:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-07-06 07:44:08

Done everything!


---

Comment by dcoudert created at 2015-07-06 15:18:15

Install OK, docbuild OK, doc looks good.

However, I have questions on the expected behavior:
- with 1-vertex graph:

```
sage: G = graphs.PathGraph(1)
sage: G.dominator_tree(0)
{0: None}
sage: G.dominator_tree(0, return_dict=False)
Graph on 0 vertices
```

- With disconnected graphs

```
sage: G = 2 * graphs.PathGraph(1)
sage: G.dominator_tree(0)
{0: None, 1: None}
sage: G = 2 * graphs.PathGraph(2)
sage: G.dominator_tree(0)
{0: None, 1: 0, 2: None, 3: None}
```

If this is effectively what we expect, then I will finalize the review.


---

Comment by git created at 2015-07-06 15:29:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-07-06 15:33:26

Helloooooo again,

Is there any reason why you kept two functions with the same name (dominator_tree)? If you moved the 'graph output' to the one defined in `boost_graph.pyx`, you would only have to import it in the `GenericGraph` object. No duplication of doc/doctest.

Nathann


---

Comment by borassi created at 2015-07-06 15:40:47

> However, I have questions on the expected behavior:
> - with 1-vertex graph:
> {{{
> sage: G = graphs.[This is the Trac macro *PathGraph* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#PathGraph-macro)(1)
> sage: G.dominator_tree(0)
> {0: None}
> sage: G.dominator_tree(0, return_dict=False)
> Graph on 0 vertices
> }}}

You are right, if the dominator tree is empty (that is, if from the root we cannot reach any other vertex) it is better to output a 1-vertex graph containing the root, not an empty graph. For the dictionary, I think the behavior is correct.

> - With disconnected graphs
> {{{
> sage: G = 2 * graphs.[This is the Trac macro *PathGraph* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#PathGraph-macro)(1)
> sage: G.dominator_tree(0)
> {0: None, 1: None}
> sage: G = 2 * graphs.[This is the Trac macro *PathGraph* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#PathGraph-macro)(2)
> sage: G.dominator_tree(0)
> {0: None, 1: 0, 2: None, 3: None}
> }}}
> If this is effectively what we expect, then I will finalize the review.

Here, the behavior is correct, in my opinion. I have changed the doc to better explain this case, by adding an "OUTPUT" block.


---

Comment by git created at 2015-07-06 15:41:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-07-06 15:53:26

You mean that I should move all the code in boost_graph.pyx, and then import this function through something like

`GenericGraph.dominator_tree = types.MethodType(sage.graphs.base.boost_graph.dominator_tree(GenericGraph, ???))`

Could you tell me the exact command? The three examples I have found in `generic_graph.py` do not have arguments...

Replying to [comment:12 ncohen]:


> Helloooooo again,
> 
> Is there any reason why you kept two functions with the same name (dominator_tree)? If you moved the 'graph output' to the one defined in `boost_graph.pyx`, you would only have to import it in the `GenericGraph` object. No duplication of doc/doctest.
> 
> Nathann


---

Comment by dcoudert created at 2015-07-06 17:18:07

A good example is  `GenericGraph.diameter = types.MethodType(sage.graphs.distances_all_pairs.diameter, None, GenericGraph)`.
It has several arguments (e.g. `method='iFUB'`).


---

Comment by borassi created at 2015-07-06 19:21:28

Hellooooooo!

I have done it, but there is a problem: in order to obtain this result, `generic_graph` should import `boost_graph`, which imports `directed_graph`, which imports `generic_graph`, and I have cyclic dependencies. I tried to put


```
import types
from sage.graphs.generic_graph import GenericGraph
GenericGraph.dominator_tree = types.MethodType(dominator_tree, None, GenericGraph)
```

inside boost_graph, but it is not imported when Sage starts, so I have to import boost_graph before running dominator_tree (and I don't like it). Any suggestion?

Replying to [comment:16 dcoudert]:


> A good example is  `GenericGraph.diameter = types.MethodType(sage.graphs.distances_all_pairs.diameter, None, GenericGraph)`.
> It has several arguments (e.g. `method='iFUB'`).


---

Comment by dcoudert created at 2015-07-06 20:16:52

This is weird since for instance the `distances_all_pairs` module imports `Graph` many times.

Could you try the following: in the `boost_graph.pyx` file, move the `from sage.graphs.graph import Graph` statement inside all the methods using it. Same for `DiGraph` etc.

David.


---

Comment by git created at 2015-07-06 20:40:18

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by borassi created at 2015-07-06 20:43:35

Helloooooo!

Thank you very much: it worked! Now, I have rebased all my commits, so that the history of generic_graph is correct, and I have moved everything to boost_graph.

Replying to [comment:18 dcoudert]:


> This is weird since for instance the `distances_all_pairs` module imports `Graph` many times.
> 
> Could you try the following: in the `boost_graph.pyx` file, move the `from sage.graphs.graph import Graph` statement inside all the methods using it. Same for `DiGraph` etc.
> 
> David.


---

Comment by dcoudert created at 2015-07-06 20:48:10

Something goes wrong with your last commits, some conflicts. I don't know how to solve that (not git expert).


---

Comment by borassi created at 2015-07-06 20:50:20

Strange, in my computer it works correctly... Maybe you have to perform a forced pull, since I had to perform a forced push, or try to remove your local branch and re-download it... Nathann?


---

Comment by ncohen created at 2015-07-07 06:46:21

I also see conflicts. And the branch's name of thi ticket appears in red, which is a sign too.

Nathann


---

Comment by ncohen created at 2015-07-07 06:56:42

Michele: are you running beta7? If not, that's the reason.

Nathann


---

Comment by git created at 2015-07-07 12:16:55

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by borassi created at 2015-07-07 12:18:22

Now it should work: I have downloaded beta7, and I have added the missing parts.


---

Comment by dcoudert created at 2015-07-07 18:28:22

Now it's working and I'm trying to understand the expected behavior of the method.

- is it normal that the resulting tree is always a star ?

```
sage: G = graphs.RandomBarabasiAlbert(1000,2)
sage: H = G.dominator_tree(0, return_dict=False)
sage: H.is_tree() and H.diameter()<=2
True
sage: H = G.dominator_tree(193, return_dict=False)
sage: H.is_tree() and H.diameter()<=2
True
```



- I suggest to set parameter `return_dict=False` by default. Well I don't know which is the most useful

- There is a labeling problem with the root.

```
sage: G = graphs.Grid2dGraph(4,4)
sage: G.dominator_tree((0,0), return_dict=False).vertices()
[0,
 (0, 1),
 (0, 2),
 (0, 3),
 (1, 0),
 (1, 1),
 (1, 2),
 (1, 3),
 (2, 0),
 (2, 1),
 (2, 2),
 (2, 3),
 (3, 0),
 (3, 1),
 (3, 2),
 (3, 3)]
sage: G.dominator_tree((1,1), return_dict=False).vertices()
[5,
 (0, 0),
 (0, 1),
 (0, 2),
 (0, 3),
 (1, 0),
 (1, 2),
 (1, 3),
 (2, 0),
 (2, 1),
 (2, 2),
 (2, 3),
 (3, 0),
 (3, 1),
 (3, 2),
 (3, 3)]
```


- Try also this. The output digraph is not connected and you have some labeling problems.

```
sage: D = digraphs.DeBruijn(2,4)
sage: D.dominator_tree('0000', return_dict=False).show()
```


David.


---

Comment by dcoudert created at 2015-07-07 18:28:22

Changing status from needs_review to needs_info.


---

Comment by git created at 2015-07-07 20:46:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-07-07 21:00:40

Replying to [comment:27 dcoudert]:

> Now it's working and I'm trying to understand the expected behavior of the method.
> 
> - is it normal that the resulting tree is always a star ?
> {{{
> sage: G = graphs.[This is the Trac macro *RandomBarabasiAlbert* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#RandomBarabasiAlbert-macro)(1000,2)
> sage: H = G.dominator_tree(0, return_dict=False)
> sage: H.is_tree() and H.diameter()<=2
> True
> sage: H = G.dominator_tree(193, return_dict=False)
> sage: H.is_tree() and H.diameter()<=2
> True
> }}}

Yes, it is: if the input is undirected, the dominator tree is a star if and only the if the graph is biconnected. In a Barabasi-Albert graph, the minimum degree is 2, so I believe it is.

> 
> - I suggest to set parameter `return_dict=False` by default. Well I don't know which is the most useful

Done!

> - There is a labeling problem with the root.
> {{{
> sage: G = graphs.Grid2dGraph(4,4)
> sage: G.dominator_tree((0,0), return_dict=False).vertices()
> [0,
> (0, 1),
> (0, 2),
> (0, 3),
> (1, 0),
> (1, 1),
> (1, 2),
> (1, 3),
> (2, 0),
> (2, 1),
> (2, 2),
> (2, 3),
> (3, 0),
> (3, 1),
> (3, 2),
> (3, 3)]
> sage: G.dominator_tree((1,1), return_dict=False).vertices()
> [5,
> (0, 0),
> (0, 1),
> (0, 2),
> (0, 3),
> (1, 0),
> (1, 2),
> (1, 3),
> (2, 0),
> (2, 1),
> (2, 2),
> (2, 3),
> (3, 0),
> (3, 1),
> (3, 2),
> (3, 3)]
> }}}
> 
> - Try also this. The output digraph is not connected and you have some labeling problems.
> {{{
> sage: D = digraphs.[This is the Trac macro *DeBruijn* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#DeBruijn-macro)(2,4)
> sage: D.dominator_tree('0000', return_dict=False).show()
> }}}

Yes, you are right, I did not "translate" properly the Boost vertices into Sage labels. I have corrected that line and I have added a test to check that the translation is correct. The new line is:


```
edges = [This is the Trac macro *int_to_vertex[result[vertex_to_int[v* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#int_to_vertex[result[vertex_to_int[v-macro)], v] for v in g.vertices() if result[vertex_to_int[v]] != no_parent]
```

Thank you very much!


---

Comment by borassi created at 2015-07-07 21:00:40

Changing status from needs_info to needs_review.


---

Comment by dcoudert created at 2015-07-08 07:43:58

> Yes, it is: if the input is undirected, the dominator tree is a star if and only the if the graph is biconnected. In a Barabasi-Albert graph, the minimum degree is 2, so I believe it is.

So for undirected graphs, we can first test if is it connected. If true, then we can directly construct and return the star (or the dict) without using boost, right? If False, then what's the output ?

What for directed graphs?

David.


---

Comment by borassi created at 2015-07-08 08:22:56

Hellooooo!

Replying to [comment:30 dcoudert]:

> So for undirected graphs, we can first test if is it connected. If true, then we can directly construct and return the star (or the dict) without using boost, right? If False, then what's the output ?

Well, not connected but biconnected. In any case, probably the dominator tree in the undirected case can be found by computing biconnected components and cut vertices. There is a linear algorithm for biconnected components, but it is not very easy to implement, and the Boost algorithm is O(m log m), which is not much worse than O(m). Is the linear algorithm for BCC implemented in the hyperbolicity algorithm?

> 
> What for directed graphs?

Well, it is more complicated... I heard that finding linear algorithms for this problem is an open issue, and the Boost algorithm should be optimal. For more information, see the Boost help page http://www.boost.org/doc/libs/1_58_0/libs/graph/doc/lengauer_tarjan_dominator.htm.

Michele


---

Comment by dcoudert created at 2015-07-08 09:33:30

Replying to [comment:31 borassi]:
> Hellooooo!
> 
> Replying to [comment:30 dcoudert]:
> 
> > So for undirected graphs, we can first test if is it connected. If true, then we can directly construct and return the star (or the dict) without using boost, right? If False, then what's the output ?
> 
> Well, not connected but biconnected. 

OK, I see. Could you mention this in the description of the method? and perhaps add a simple example of a graph with 2 biconnected components. For Instance

```
sage: G = 2*graphs.CycleGraph(3)
sage: G.add_edge(0,3)
sage: G.dominator_tree(0, return_dict=True)
{0: None, 1: 0, 2: 0, 3: 0, 4: 3, 5: 3}
```


> In any case, probably the dominator tree in the undirected case can be found by computing biconnected components and cut vertices. There is a linear algorithm for biconnected components, but it is not very easy to implement, and the Boost algorithm is O(m log m), which is not much worse than O(m). Is the linear algorithm for BCC implemented in the hyperbolicity algorithm?

For undirected graphs, we have `B,C = G.blocks_and_cut_vertices()`, where `B` is the list of blocks (list of vertices of each biconnected component) and `C` is the list of cut vertices. It's a Python implementation, but it's efficient. We use it for the hyperbolicity and many other algorithms.

However, now that I have a better understanding of the method, I think it is better to let it as it is. So improve the doc and it should be ok.

David.


---

Comment by git created at 2015-07-08 13:48:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-07-08 13:51:59

> However, now that I have a better understanding of the method, I think it is better to let it as it is. So improve the doc and it should be ok.

Done!


---

Comment by dcoudert created at 2015-07-08 14:00:14

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2015-07-08 14:00:14

For me the patch is now good to go!


---

Comment by vbraun created at 2015-07-08 22:38:53

Fails on 32-bit

```
sage -t --long src/sage/graphs/base/boost_graph.pyx
**********************************************************************
File "src/sage/graphs/base/boost_graph.pyx", line 101, in sage.graphs.base.boost_graph.edge_connectivity
Failed example:
    edge_connectivity(g)
Expected:
    [4, [(0, 1), (0, 2), (0, 3), (0, 4)]]
Got:
    [4L, [(0L, 1L), (0L, 2L), (0L, 3L), (0L, 4L)]]
**********************************************************************
1 item had failures:
```



---

Comment by vbraun created at 2015-07-08 22:38:53

Changing status from positive_review to needs_work.


---

Comment by git created at 2015-07-09 07:37:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-07-09 07:39:46

I think the problem is that on 32bit the C++ unsigned int is converted to a long. I replaced unsigned int with int for vertices, and now it should work. How can I test it on 32bit?


---

Comment by borassi created at 2015-07-09 07:39:46

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2015-07-09 20:53:09

To test on 32bits, you need a 32bits cpu. 
May be one of the machines of the patchbot is 32bits and so you will get the answer soon.
D.


---

Comment by git created at 2015-07-10 08:18:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by borassi created at 2015-07-10 08:21:53

Helloooooo!

I have made a small modification in the Boost interface: now the Boost graph "knows" (through a vertex_property) the number associated to each vertex. This way, if the result is an vector, where in position i there is a property of vertex i, this vector is generated directly from Boost, without conversion.

However, after this modification, I think this patch needs a new review, at least for this part.

Thank you very much!

Michele

PS: I still have no idea on how to test 32bit Sagemath, and I hope modifying the vertex name from unsigned int to int worked! Anyone is able to test it?


---

Comment by dcoudert created at 2015-07-11 14:13:50

For me the patch is good to go.
I tried the patch successfully using an old computer on which I can only use cplex 32bits and not cplex 64bits. So I assume it is 32bits... 
I cannot do better test.


---

Comment by dcoudert created at 2015-07-11 14:13:50

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-07-12 13:00:57

Resolution: fixed
