# Issue 13049: Limit should not depend on dummy variable.

Issue created by migration from https://trac.sagemath.org/ticket/13221

Original creator: kcrisman

Original creation time: 2012-07-10 15:24:12

Assignee: burcin

CC:  novoselt

See #12438 as well.

Somewhere between Sage 4.4.4 and 4.8 we changed behavior - not correctly, I'd say.

```

$ Downloads/sage-4.8/sage
----------------------------------------------------------------------
----------------------------------------------------------------------
sage: f(x) = x^2
sage: limit(f,x=1)
x |--> 1
sage: limit(f(x),x=1)
1
sage: 
Exiting Sage (CPU time 0m1.15s, Wall time 0m10.57s).
karl-dieter-crismans-powerbook-g4-15:~ karl-dietercrisman$ Desktop/sage-4.4.4-mcbc/sage
----------------------------------------------------------------------
----------------------------------------------------------------------
Loading Sage library. Current Mercurial branch is: hackbranch
sage: f(x) = x^2
sage: limit(f,x=1)
1
sage: limit(f(x),x=1)
1
```



---

Comment by novoselt created at 2012-11-01 02:31:31

The problem is that `limit` ends with

```
return ex.parent()(l)
```

and functions depending on certain variables have limits depending on the same variables. I wonder where else such a behaviour may pop-up and what would be a good generic way to handle it.


---

Comment by rws created at 2015-02-01 15:47:21

I don't see this behaviour anymore. Please confirm and close.


---

Comment by rws created at 2015-02-01 15:47:21

Changing status from new to needs_review.


---

Comment by nbruin created at 2015-02-01 18:01:47

Changing status from needs_review to needs_work.


---

Comment by nbruin created at 2015-02-01 18:01:47

I do get the reported behaviour in 6.5beta

```
sage: f(x) = x^2
sage: limit(f,x=1)
x |--> 1
```

This is coming from the fact that sage does this transformation (well, it's a side-effect of the implementation above):

```
limit( E.function(t), t=1) ---> E.limit(t=1).function(t)
```

That transformation really has no merit whatsoever. The thing that's hard about this is that the type of `E.function(t)` is just `SymbolicExpression`. The callable bit is entirely stored in the parent.

Another way would be to subclass to CallableSymbolicExpression and override things like `limit` and `integral` to produce errors instead (or do something useful if there is a reasonable choice).

Arithmetic on callable expressions in general seems pretty sane:

```
sage: f(x)=x^2
sage: g(y)=1+y
sage: f+g
(x, y) |--> x^2 + y + 1
```



---

Comment by novoselt created at 2015-02-02 18:57:37

And why should it be `(x,y)` instead of `(y,x)`? What if one depends on `(a, b)` and the other on `(alpha, beta)`, what should the result be? I think that in such cases the result should be a symbolic expression (which is unambiguous), but without any default order of variables. This is why polynomials in different variables cannot be added - ordering is non-canonical.
