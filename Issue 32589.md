# Issue 32589: scalar-multiplication endomorphisms of elliptic curves

Issue created by migration from https://trac.sagemath.org/ticket/32826

Original creator: lorenz

Original creation time: 2021-11-05 06:14:29

CC:  defeo cremona tscrim vdelecroix chapoton klee

This ticket will add `EllipticCurveHom_scalar`, a new class encapsulating scalar multiplications on elliptic curves. This serves two main purposes:

1. It solves one of the motivations behind #8014 (faster `multiplication_by_m_isogeny`).
2. Wrapping scalar multiplications as an `EllipticCurveHom` is an important step towards implementing endomorphism rings (see #7368).


---

Comment by lorenz created at 2021-11-05 06:33:45

Changing status from new to needs_review.


---

Comment by lorenz created at 2021-11-05 06:33:45

Last 10 new commits:


---

Comment by cremona created at 2021-11-05 09:29:13

This is a great idea.  Why not just call these endomorphisms, i.e. call the class something like EllipticCurveEndomorphism instead of EllipticCurveHom_scalar?  I don' know if there is a plan to late include more general endomorphisms (CM in char. 0, and both the ordinary and supersingular possibilities in char.p), but even if we are not going to implement those now, we could set it up to that the class EllipticCurveEndomorphism exists and (say) EllipticCurveScalarEndomorphism is a subclass doing what this class EllipticCurveHom_scalar does.


---

Comment by lorenz created at 2021-11-05 15:53:52

Thank you, that's a very good remark! I can see that there are several ways to "slice up" the space of objects we're trying to model here. My reasoning was the following (very much up for discussion):

- There's no real reason to separate isogenies and endomorphisms at this level — they can all be child classes of `EllipticCurveHom` with a common interface. Some `EllipticCurveHom`s are of course endomorphisms, but we don't have to treat them specially. (Note: `.is_endomorphism()` already works.)
- On the level of those maps, we can easily implement formal compositions (#32744) and sums (to be done). Multiplication in the endomorphism ring "just works", as does composing endomorphisms with isogenies (thus, we prevent incompatibilities like we've been having with isomorphisms; cf. #32388, #32502).
- The parent object of any `EllipticCurveHom` should be a hom-module that knows about the domain and codomain curve, regardless of what kind of `EllipticCurveHom` implementation it is. Of course, some of those hom-modules will be closed under composition, but again we don't have to do anything special here. (Side effect: Composing isogenies `E -> E' -> E` won't require any special treatment either.)
- Now, none of these objects knows a lot about its own structure. This mandates the last ingredient: An `EndomorphismRing` object that encapsulates both the algebraic view of an endomorphism ring (i.e., a quadratic order or a quaternion order) _and_ a mapping of the generators of that abstract ring to explicit `EllipticCurveHom`s. With that, we can first use all the tools available for quadratic fields and quaternion algebras in the abstract world, then "project down" the situation to the corresponding maps on curves. (At least in principle, it should be possible to handle these translations almost seamlessly by overloading some methods.)
- Note that such a ring of endomorphisms need not be _the_ (full) ring of endomorphisms: Subrings that could prove useful (especially for big instances where we cannot always compute the full endomorphism ring) include the Frobenius order, or some rank-2 subring of a quaternionic endomorphism ring.

I imagine that this design will make it _relatively_ straightforward to implement things like computing endomorphism rings (#31851), or embedding a bunch of explicitly given `EllipticCurveHom`s into an abstract quadratic or quaternionic order to see the relations between them.

Let me know if this makes sense. :-)


---

Comment by cremona created at 2021-11-05 16:22:09

It makes perfect sense -- I am very happy to see all this being implemented (or at least some of it), and not by me!


---

Comment by mkoeppe created at 2021-12-18 19:53:12

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.


---

Comment by git created at 2022-01-21 08:07:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-01-21 11:20:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-01-26 05:36:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-02-21 05:54:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-17 07:28:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-05-23 08:33:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-26 14:10:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-09-25 10:22:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-10-17 15:59:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-10-17 21:26:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-11-08 14:53:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-12-21 08:30:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-12-22 05:39:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2022-12-22 05:55:45

I've been constantly rebasing this branch for more than a year now — not trying to be annoying, but is there a chance we could finally get it merged?

I'd like to build more functionality on top of this (and #33915), but dragging around a bunch of unmerged tickets as dependencies slows down any development effort considerably.


---

Comment by cremona created at 2022-12-22 09:02:57

I see that I looked at this in some detail a year ago, so I will do so again.


---

Comment by cremona created at 2022-12-22 09:19:47

Some minor (and quick) suggestions, as this looks very good.

In the `scaling_factor()` method you return `self._m` which is an integer (in ZZ), but I think you should coerce it into the base field.

Having done this you can simplify `is_separable()` and `is_injective()` to a check that `scaling_factor()` is nonzero.  For this reason it might be a good idea to store the image of m in the base field as well as m itself, on construction.

Do this and you'll get a positive review!


---

Comment by git created at 2022-12-22 09:45:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2022-12-22 10:00:50

Changing status from needs_review to positive_review.


---

Comment by lorenz created at 2022-12-22 10:06:25

Thanks a lot for reviewing this (indeed rather long) patch!

Replying to [comment:26 John Cremona]:
> In the `scaling_factor()` method you return `self._m` which is an integer (in ZZ), but I think you should coerce it into the base field.

Indeed, well spotted.

> Having done this you can simplify `is_separable()` and `is_injective()` to a check that `scaling_factor()` is nonzero.

I agree for `.is_separable()`, but it seems that `.is_injective()` is not expressible in terms of the scaling factor alone: For supersingular curves `[p]` is purely inseparable (i.e., injective), but `[kp]` has nontrivial kernel whenever `k>1` is not a power of `p`, while of course every multiple of `[p]` has the same scaling factor `0`. So I kept the previous implementation of `.is_injective()`.


---

Comment by cremona created at 2022-12-22 11:17:10

You are right, of course.  When we have `separable_degree()` and `inseparable_degree()` we can just return `separable_degree()==1` for `is_injective()`, since the size of the kernel (over the algebraic closure and not meaning the fancy scheme-theoretic kernel!) is the separable degree.
