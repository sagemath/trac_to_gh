# Issue 16599: __neg__ fails in CartesianProduct of CombinatorialFreeModule

Issue created by migration from https://trac.sagemath.org/ticket/16836

Original creator: cnassau

Original creation time: 2014-08-16 05:47:25

CC:  nthiery


```
sage: X=CombinatorialFreeModule(ZZ,ZZ)
sage: Y=cartesian_product((X,X))
sage: -Y.an_element()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-11-189fa298bf84> in <module>()
----> 1 -Y.an_element()

/waste/cn/sage-git/local/lib/python2.7/site-packages/sage/categories/additive_magmas.pyc in __neg__(self)
    920                     """
    921                     return self.parent()(
--> 922                         -x for x in self.cartesian_factors())
    923 
    924         class Algebras(AlgebrasCategory):

/waste/cn/sage-git/local/lib/python2.7/site-packages/sage/structure/parent.so in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:8902)()

/waste/cn/sage-git/local/lib/python2.7/site-packages/sage/structure/coerce_maps.so in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4203)()

/waste/cn/sage-git/local/lib/python2.7/site-packages/sage/structure/coerce_maps.so in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4110)()

/waste/cn/sage-git/local/lib/python2.7/site-packages/sage/combinat/free_module.pyc in _element_constructor_(self, x)
   1527                 except TypeError:
   1528                     pass
-> 1529             raise TypeError("do not know how to make x (= %s) an element of self (=%s)"%(x,self))
   1530 
   1531     def _an_element_impl(self):

TypeError: do not know how to make x (= <generator object <genexpr> at 0x7fd385148050>) an element of self (=Free module generated by Integer Ring over Integer Ring (+) Free module generated by Integer Ring over Integer Ring)
```



---

Comment by cnassau created at 2014-08-16 06:34:52

The fix appears to be quite simple:


```diff
--- a/src/sage/categories/additive_magmas.py
+++ b/src/sage/categories/additive_magmas.py
@@ -918,8 +918,8 @@ class AdditiveMagmas(Category_singleton):
                             ...
                             AssertionError
                     """
-                    return self.parent()(
-                        -x for x in self.cartesian_factors())
+                    return self.parent()._cartesian_product_of_elements(
+                       [-x for x in self.cartesian_factors()])
```


This breaks a doctest, however:

```
File "src/sage/categories/additive_magmas.py", line 903, in sage.categories.additive_magmas.AdditiveMagmas.AdditiveUnital.CartesianProducts.ElementMethods.__neg__
Failed example:
    -c
Expected:
    Traceback (most recent call last):
    ...
    ValueError: Value -42 in not in Non negative integers.
Got:
    (-1, -42, -1.00000000000000)
```


The fix for that doctest would be to move a sanity check from `_neg_` to `CartesianProduct._cartesian_product_of_elements`. That then breaks a design-comment in the latter routine about being optimized for speed. 

Alternatively, the doctest could be removed (my choice). We don't want an implicit sanity-check whenever we negate an element of a cartesian product.

This is therefore the sort of code/bug that only the original author can fix.


---

Comment by cnassau created at 2014-08-16 19:03:10

the attached patch fixes the problem in the indicated way: the offending doctest has been removed.

after all, the offendig behaviour (x in N, but -x not in N) is well known from the natural numbers, and not much of a problem.
----
New commits:


---

Comment by cnassau created at 2014-08-16 19:03:10

Changing status from new to needs_review.


---

Comment by cnassau created at 2014-09-10 07:12:40

I've changed the priority to make sure this issue gets addressed in the next release.


---

Comment by cnassau created at 2014-09-10 07:12:40

Changing priority from major to blocker.


---

Comment by tscrim created at 2014-09-10 07:53:12

Not a blocker, but this has been on my todo list. I hope to get to this next week.


---

Comment by tscrim created at 2014-09-10 07:53:12

Changing priority from blocker to major.


---

Comment by vdelecroix created at 2015-04-18 12:42:28

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-04-18 12:42:28

Hello,

Could you change

```
sage: F = CombinatorialFreeModule(ZZ, ['a','b'])
sage: FF = cartesian_product((F,F))
sage: -FF.an_element() # random - only test that negative can be taken
```

to something explicit like

```
sage: F = CombinatorialFreeModule(ZZ, ['a','b'])
sage: a,b = F.gens()
sage: c = cartesian_product([a,b-2*a]) + cartesian_product([a,a])
sage: c
2*B[(0, 'a')] - B[(1, 'a')] + B[(1, 'b')]
sage: FF = cartesian_product((F,F))
sage: c.parent() == FF
True
sage: -c
-2*B[(0, 'a')] + B[(1, 'a')] - B[(1, 'b')]
```


IMHO, the following fails but should work

```
sage: FF([a,b])
Traceback (most recent call last)
...

TypeError: do not know how to make x (= [B['a'], B['b']])
an element of self (=Free module generated by {'a', 'b'} over Integer Ring
(+) Free module generated by {'a', 'b'} over Integer Ring)
```


Vincent


---

Comment by cnassau created at 2015-04-19 09:43:22

New commits:


---

Comment by cnassau created at 2015-04-19 09:49:57

Replying to [comment:5 vdelecroix]:
> Could you change
> {{{
> sage: F = CombinatorialFreeModule(ZZ, ['a','b'])
> sage: FF = cartesian_product((F,F))
> sage: -FF.an_element() # random - only test that negative can be taken
> }}}
> to something explicit like
> {{{
> sage: F = CombinatorialFreeModule(ZZ, ['a','b'])
> sage: a,b = F.gens()
> sage: c = cartesian_product([a,b-2*a]) + cartesian_product([a,a])
> sage: c
> 2*B[(0, 'a')] - B[(1, 'a')] + B[(1, 'b')]
> sage: FF = cartesian_product((F,F))
> sage: c.parent() == FF
> True
> sage: -c
> -2*B[(0, 'a')] + B[(1, 'a')] - B[(1, 'b')]
> }}}

I have followed these suggestions; the doctest is now more explicit.
 
> IMHO, the following fails but should work
> {{{
> sage: FF([a,b])
> Traceback (most recent call last)
> ...
> 
> TypeError: do not know how to make x (= [B['a'], B['b']])
> an element of self (=Free module generated by {'a', 'b'} over Integer Ring
> (+) Free module generated by {'a', 'b'} over Integer Ring)
> }}}

I agree that this looks like a reasonable expectation, but I'm afraid that this might be a bit contentious since it would involve changes in the combinatorial heartland. I'd prefer to keep such matters out of this ticket which is essentially just a simple bugfix.

Thanks for taking the time to look into this ticket!

Cheers,
Christian


---

Comment by cnassau created at 2015-04-19 09:50:07

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-04-19 10:25:38

Hello Christian,

I made a small commit which forces a cast of each factor. In that case you get a `ValueError` when you try to negate `(1, 42, 1.)` in `ZZ x NN x RR`. Actually, wouldn't it be better that doing a negation convert it to an element of `ZZ x ZZ x RR`. What do you think?

Best,
Vincent

PS: it would be cool if you worked on the last beta release (now `6.7.beta1`). It helps preventing merge conflicts and it avoids switching between Sage versions. Do not change it now! But when you restart the implementation like you did, just start it on the last beta.
----
New commits:


---

Comment by git created at 2015-04-19 15:40:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cnassau created at 2015-04-19 15:45:39

Hi Vincent,

> I made a small commit which forces a cast of each factor. In that case you get a `ValueError` when you try to negate `(1, 42, 1.)` in `ZZ x NN x RR`. Actually, wouldn't it be better that doing a negation convert it to an element of `ZZ x ZZ x RR`. What do you think?

I think getting an error when using `-42` or `-(42,whatever)` would definitely be misguided - these days that level of "rigor" is only appreciated by a small and diminishing group of mostly white-bearded Bourbakistas... 

Changing the parent, OTOH, might be a good idea. I have now changed the line again to choose the parent automatically. I'm not sure whether there's an impact on performance, though. For that reason I have also added a new `__neg__` for elements of the cartesian product of semigroups with guaranteed inverses; here the parent is clear and the old code seems appropriate. 

> PS: it would be cool if you worked on the last beta release (now `6.7.beta1`). It helps preventing merge conflicts and it avoids switching between Sage versions. Do not change it now! But when you restart the implementation like you did, just start it on the last beta.

Your warning came to late, I was already in the process of changing branches, athough not entirely deliberately. The new patch is now based on 6.7.beta1 ...  it seems.


---

Comment by vdelecroix created at 2015-04-19 16:00:12

Not sure the old code is appropriate:

```
sage: NNSemiring = NonNegativeIntegerSemiring()
sage: C = cartesian_product([ZZ,NNSemiring,RR])
sage: -C([2,0,.4])
(-2, 0, -0.400000000000000)
sage: parent(_)
The cartesian product of (Integer Ring, Integer Ring,
 Real Field with 53 bits of precision)
```

The problem is that `NN` is a facade (i.e. its elements are Integer whose with parent the Integer Ring). But when `NN` is a factor of a cartesian product it is not considered as being one. I would just remove completely this `__neg__` for magma elements or adopt my version. That would avoid many problems!

The good way to do it is to implement a `negation_parent` in the coercion model similar to the `division_parent` that we have right now. This does choose for you the right parent when you do `x / y`.

```
sage: from sage.structure.element import get_coercion_model
sage: cm = get_coercion_model()
sage: cm.division_parent(ZZ)
Rational Field
sage: cm.division_parent(QQ)
Rational Field
sage: cm.division_parent(Zmod(14))
Ring of integers modulo 14
```

But it is out of the scope of this ticket I guess.

Vincent


---

Comment by git created at 2015-04-19 16:21:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cnassau created at 2015-04-19 16:23:48

Replying to [comment:12 vdelecroix]:
> Not sure the old code is appropriate:
> {{{
> sage: NNSemiring = NonNegativeIntegerSemiring()
> sage: C = cartesian_product([ZZ,NNSemiring,RR])
> sage: -C([2,0,.4])
> (-2, 0, -0.400000000000000)
> sage: parent(_)
> The cartesian product of (Integer Ring, Integer Ring,
>  Real Field with 53 bits of precision)
> }}}
> The problem is that `NN` is a facade (i.e. its elements are Integer whose with parent the Integer Ring). But when `NN` is a factor of a cartesian product it is not considered as being one. I would just remove completely this `__neg__` for magma elements or adopt my version. That would avoid many problems!

Getting rid of it sounds like a clean solution. The latest commit now only implements a `__neg__` if all factors are guaranteed to have inverses.

Cheers,
Christian


---

Comment by vdelecroix created at 2015-04-19 16:25:14

Looks good. Could you get rid of this line

```
+from sage.categories.cartesian_product import cartesian_product
```


And if you don't mind, you can clean the history by making all of this only one commit above 6.7.beta1.

Then it should be ok.

Vincent


---

Comment by cnassau created at 2015-04-19 16:51:53

Replying to [comment:15 vdelecroix]:
> Looks good. Could you get rid of this line
> {{{
> +from sage.categories.cartesian_product import cartesian_product
> }}}
> 
> And if you don't mind, you can clean the history by making all of this only one commit above 6.7.beta1.

Alright, I've cleaned up the branch and removed that line. 

Thanks for your time & Cheers,
Christian


---

Comment by cnassau created at 2015-04-19 16:52:14

New commits:


---

Comment by vdelecroix created at 2015-04-19 18:00:43

Let it go!


---

Comment by vdelecroix created at 2015-04-19 18:00:52

Changing status from needs_review to positive_review.


---

Comment by nthiery created at 2015-04-20 19:37:24

Hi!

Sorry for dropping in so late; this issue dropped out of my mailbox.

Thanks for the fix and for the type-checking-free version for
cartesian products of inverse additive magmas.

That being said, I'd like to keep the previous implementation (with
the fix) for unital magmas. There are cases where this feature can be
useful! This ticket is about a fix, not an API change.

Also, whenever possible:

- Please keep existing doctests.
- Please keep existing TODO's.

Given that it's late in the process, reinstating those can be in a
follow up ticket if you prefer. But before next release.

Two notes:

- `an_element` is *not* random. I don't know why the test was marked
  as such. But in any cases, using `an_element` is usually a nice
  concise idiom to construct an element on which to do tests.

- I am usually not a big fan of "coercing silently to a larger
  universe". But don't have a strong opinion either. Anyway, this is
  not directly related to this ticket.

- About `F((xxx,xxx))`: converting from indices of the basis is a nice
  syntactic sugar indeed. It can't be defined in full generality,
  because in certain cases there can be ambiguity with coercion from
  the base ring. For cartesian products, I guess there is no such
  risk, so that's ok. In any cases that's for user interaction only;
  in code, one should always use F.term((...)) for genericity and
  speed.

Thanks again!
                             Nicolas


---

Comment by vdelecroix created at 2015-04-20 20:03:14

Hi,

Replying to [comment:20 nthiery]:
> That being said, I'd like to keep the previous implementation (with
> the fix) for unital magmas. There are cases where this feature can be
> useful! This ticket is about a fix, not an API change.

It was completely wrong with several respects that were discussed here... (the least being not working).

> Also, whenever possible:
> 
> - Please keep existing doctests.
> - Please keep existing TODO's.

True. I was a bit fast on that #18263.

> Two notes:
> 
> - `an_element` is *not* random. I don't know why the test was marked
>   as such. But in any cases, using `an_element` is usually a nice
>   concise idiom to construct an element on which to do tests.

It is! Concrete examples: #18239. After modifying the `.list()` of the `PermutationGroup` and the `__hash__` of `PermutationGroupElement` it gets changed in a lot of places (`algebras/group_algebra.py`, `categories/enumerated_sets.py`, `categories/modules_with_basis.py`, ...). But I agree with you that it would have been simpler if they did not. Perhaps by not random you meant that it depends on the hash or on a particular order of something that does not have to be ordered.

> - About `F((xxx,xxx))`: converting from indices of the basis is a nice
>   syntactic sugar indeed. It can't be defined in full generality,
>   because in certain cases there can be ambiguity with coercion from
>   the base ring. For cartesian products, I guess there is no such
>   risk, so that's ok. In any cases that's for user interaction only;
>   in code, one should always use F.term((...)) for genericity and
>   speed.

What is this `term` feature? What is the difference with `_cartesian_product_of_elements`? Why not using `P.element_class(...)` for speed?

Vincent


---

Comment by nthiery created at 2015-04-20 20:19:25

Replying to [comment:21 vdelecroix]:
> It was completely wrong with several respects that were discussed here... (the least being not working).

It was indeed broken for cartesian products of free modules, but
working smoothly and with a well defined behaviour for the other
cartesian products.

Note by the way that `_neg_` was working smoothly:

```
    sage: X=CombinatorialFreeModule(ZZ,ZZ)
    sage: sage: Y=cartesian_product((X,X))
    sage: x = Y.an_element()
    sage: x._neg_()
    -3*B[(0, -1)] - 2*B[(0, 0)] - 2*B[(0, 1)]
```


Probably we should be consistent, and either use `__neg__` in all
cases or `_neg_` (which one does not really matter since anyway there
is no real reason to involve coercion here).


> It is! Concrete examples: #18239. After modifying the `.list()` of the `PermutationGroup` and the `__hash__` of `PermutationGroupElement` it gets changed in a lot of places (`algebras/group_algebra.py`, `categories/enumerated_sets.py`, `categories/modules_with_basis.py`, ...). But I agree with you that it would have been simpler if they did not. Perhaps by not random you meant that it depends on the hash or on a particular order of something that does not have to be ordered.

So, apparently `an_element` was not implemented properly in
`PermutationGroup`. By not random, I mean that the result of
`an_element` is supposed to be reasonably stable over time, in
particular so that we can use it in tests. Maybe this should be made
more explicit in the specs of `an_element`. And progressively fixed
where it not stable enough.

> > - About `F((xxx,xxx))`: converting from indices of the basis is a nice
> >   syntactic sugar indeed. It can't be defined in full generality,
> >   because in certain cases there can be ambiguity with coercion from
> >   the base ring. For cartesian products, I guess there is no such
> >   risk, so that's ok. In any cases that's for user interaction only;
> >   in code, one should always use F.term((...)) for genericity and
> >   speed.
> 
> What is this `term` feature? What is the difference with `_cartesian_product_of_elements`? Why not using `P.element_class(...)` for speed?

Sorry, I should have been specific: I was speaking about [comment:7],
with `F` being a free module, not the cartesian product indexing its
basis.

Amitiés,
                             Nicolas


---

Comment by vbraun created at 2015-04-21 00:10:59

Resolution: fixed


---

Comment by vdelecroix created at 2015-04-21 10:34:28

Salut Nicolas,

Replying to [comment:22 nthiery]:
> Replying to [comment:21 vdelecroix]:
> > It was completely wrong with several respects that were discussed here... (the least being not working).
> 
> It was indeed broken for cartesian products of free modules, but
> working smoothly and with a well defined behaviour for the other
> cartesian products.
> 
> Note by the way that `_neg_` was working smoothly:
> {{{
>     sage: X=CombinatorialFreeModule(ZZ,ZZ)
>     sage: Y=cartesian_product((X,X))
>     sage: x = Y.an_element()
>     sage: x._neg_()
>     -3*B[(0, -1)] - 2*B[(0, 0)] - 2*B[(0, 1)]
> }}}

This is indeed a bug! `_neg_` should be called but it wasn't!

> Probably we should be consistent, and either use `__neg__` in all
> cases or `_neg_` (which one does not really matter since anyway there
> is no real reason to involve coercion here).

I would just use `__neg__` everywhere. It is faster and consistent with Python.

> > It is! Concrete examples: #18239. After modifying the `.list()` of the `PermutationGroup` and the `__hash__` of `PermutationGroupElement` it gets changed in a lot of places (`algebras/group_algebra.py`, `categories/enumerated_sets.py`, `categories/modules_with_basis.py`, ...). But I agree with you that it would have been simpler if they did not. Perhaps by not random you meant that it depends on the hash or on a particular order of something that does not have to be ordered.
> 
> So, apparently `an_element` was not implemented properly in
> `PermutationGroup`.

It was. The problems were in `modules_with_basis`, `group_algebras`, etc

> By not random, I mean that the result of
> `an_element` is supposed to be reasonably stable over time, in
> particular so that we can use it in tests. Maybe this should be made
> more explicit in the specs of `an_element`. And progressively fixed
> where it not stable enough.

I am not sure I like example looking like

```
sage: F = MyBeautifulParent()
sage: e = F.an_element()
sage: ... play with e ...
```

It is much more useful to document how to create elements! Nobody want to play with `.an_element`. It is useful in doctests but I would say only in the section `TESTS`.

Vincent
