# Issue 24394: Faster jump number for posets

Issue created by migration from Trac.

Original creator: jmantysalo

Original creation time: 2018-02-01 07:09:28

CC:  tscrim chapoton

Every poset has at least one _greedy_ linear extension with optimal number of jumps. Use this to make a faster function.



---

Comment by git created at 2018-02-01 08:10:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2018-02-01 08:12:16

The speedup is enormous, try to compute the jump number of `posets.BooleanLattice(4)` or something similar.


---

Comment by jmantysalo created at 2018-02-01 08:12:38

Changing status from new to needs_review.


---

Comment by tscrim created at 2018-02-02 05:59:27

Isn't this just a backtracking algorithm? I think you should put a little more into the algorithm description (essentially explaining what "greedy" means in this context).

Instead of your `nonlocals`, why not just return the result, which will propagate up? In a similar vein, it is usually better to manually do the backtracking rather than use recursion (faster, and in Python, no [artificial] depth limit), but that is not something I will hold this ticket up for.


---

Comment by git created at 2018-02-02 07:18:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2018-02-02 07:23:38

Replying to [comment:5 tscrim]:
> Isn't this just a backtracking algorithm? I think you should put a little more into the algorithm description (essentially explaining what "greedy" means in this context).

Added that.

> Instead of your `nonlocals`, why not just return the result, which will propagate up? In a similar vein, it is usually better to manually do the backtracking rather than use recursion (faster, and in Python, no [artificial] depth limit), but that is not something I will hold this ticket up for.

Recursion depth can not be a problem here; we can propably never compute jump number of 100-element posets, unless it has very small width (and if so, we should optimize by doing series-parallel decomposition). But yes, it would be faster not to use recursion.

Returning a result is not enought if we want to cut the computation based on earlier result.


---

Comment by tscrim created at 2018-02-02 07:34:51

Okay. LGTM.


---

Comment by tscrim created at 2018-02-02 07:34:51

Changing status from needs_review to positive_review.


---

Comment by jmantysalo created at 2018-02-02 07:35:25

Thanks Ã— 3.


---

Comment by vbraun created at 2018-02-03 17:50:00

Resolution: fixed
