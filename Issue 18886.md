# Issue 18886: LatticePoset: add is_vertically_decomposable

Issue created by migration from https://trac.sagemath.org/ticket/19123

Original creator: jmantysalo

Original creation time: 2015-09-01 14:52:35

CC:  ncohen tscrim kdilks

This patch adds a function `is_vertically_decomposable` to finite lattices.


---

Comment by jmantysalo created at 2015-09-01 14:56:46

Changing status from new to needs_review.


---

Comment by jmantysalo created at 2015-09-01 14:56:46

Quite easy one. Nathann selected as a random victim for a possible reviewer. `:=)`
----
New commits:


---

Comment by ncohen created at 2015-09-01 18:25:09

Sounds good, but don't you think it may be useful to *know* where the poset splits? Also, why is it only defined for lattices? The algorithm works in all cases.

I did not test it, but from the code's look I am not sure that it works for the chain of length 2, as the docstring indicates. Could you add a doctest for that?

Nathann


---

Comment by jmantysalo created at 2015-09-01 18:39:40

Changing status from needs_review to needs_work.


---

Comment by jmantysalo created at 2015-09-01 18:39:40

Replying to [comment:3 ncohen]:

> Sounds good, but don't you think it may be useful to *know* where the poset splits?

Yes, I think that will be usefull. For posets we have `is_connected()`, `connected_components()` and `disjoint_union()`. I guess we should have `is_vertically_decomposable()`, `vertically_indecomposable_parts()` and `vertical_sum()` for lattices.

There are of course other options, like having a function (this one, with an argument?) returning list of "decomposition elements". The user could then run `interval()` on them to get parts.

> Also, why is it only defined for lattices? The algorithm works in all cases.

How should it be defined on non-connected posets? And I am not sure if this works with non-bounded posets; I thinked about bounded ones when writing this.

> I did not test it, but from the code's look I am not sure that it works for the chain of length 2, as the docstring indicates. Could you add a doctest for that?

Arghs! You are right, of course. I forget the special case when writing the code. I'll correct it.

(Btw, this would be nice exercise of (totally unneeded) optimization. One should not need to look for all edged of Hasse diagram to see that a poset is indecomposable.)


---

Comment by ncohen created at 2015-09-01 18:45:13

> There are of course other options, like having a function (this one, with an argument?) returning list of "decomposition elements". 

+1 to that.

> How should it be defined on non-connected posets? And I am not sure if this works with non-bounded posets; I thinked about bounded ones when writing this.

Hmmm, okay okay... I attempted to write a definition, but indeed for non-lattices you have 1000 different corner-cases, and th definition would be a mess.

> (Btw, this would be nice exercise of (totally unneeded) optimization. One should not need to look for all edged of Hasse diagram to see that a poset is indecomposable.)

What do you mean? Your algorithm looks very reliable. I do not see it waste much.

Nathann


---

Comment by jmantysalo created at 2015-09-01 20:02:42

Replying to [comment:5 ncohen]:
> > There are of course other options, like having a function (this one, with an argument?) returning list of "decomposition elements". 
> 
> +1 to that.

OK. What should be the name of the argument? `certificate`? `give_me_the_list=True`?

> > How should it be defined on non-connected posets? And I am not sure if this works with non-bounded posets; I thinked about bounded ones when writing this.
> 
> Hmmm, okay okay... I attempted to write a definition, but indeed for non-lattices you have 1000 different corner-cases, and th definition would be a mess.

Except for the 2-element lattice there is one simple definition that generalizes this:


```
any(P.cover_relations_graph().is_cut_vertex(e) for e in P)
```


But in any case, it is easy to move this to posets later if we want so.

> > (Btw, this would be nice exercise of (totally unneeded) optimization. One should not need to look for all edged of Hasse diagram to see that a poset is indecomposable.)
> 
> What do you mean? Your algorithm looks very reliable. I do not see it waste much.

If the poset has coverings `2 -> 6` and `4 -> 9`, then no element `3..8` can be a decomposition element. After founding, say, `2 -> 6` we could check `5 ->`, `4 ->` and so on. But after founding `4 -> 9` we should have a somewhat complicated stack to skip re-checking biggest covers of `4` and `5`. I guess that the algorithm would be slower in reality, but I am quite sure that it would be better in some theoretical meaning.


---

Comment by ncohen created at 2015-09-01 20:25:25

> OK. What should be the name of the argument? `certificate`? `give_me_the_list=True`?

Isn't there a terminology for those points? If it is only for lattices, maybe you could have `return_cutvertices=True` or something?

> Except for the 2-element lattice there is one simple definition that generalizes this:
> 
> {{{
> any(P.cover_relations_graph().is_cut_vertex(e) for e in P)
> }}}

Wouldn't work for a poset on three elements, one being greater than the two others (which are incomparable).

> If the poset has coverings `2 -> 6` and `4 -> 9`, then no element `3..8` can be a decomposition element. After founding, say, `2 -> 6` we could check `5 ->`, `4 ->` and so on. But after founding `4 -> 9` we should have a somewhat complicated stack to skip re-checking biggest covers of `4` and `5`. I guess that the algorithm would be slower in reality, but I am quite sure that it would be better in some theoretical meaning.

HMmm... Skipping some edges without additional assumption on the order in which they are returned? I do not know... This is not so bad, for the moment `:-)`

Nathann


---

Comment by git created at 2015-09-02 06:44:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-09-02 06:46:44

You don't have to write this algorithm twice to make it work in all situations. Once is enough. And if you are worried of the cost of a 'if' inside of the loop, then you should not be writing Python code.

Furthermore, be careful with '::' as they are not needed after an INPUT block. Build the doc to check it.

Nathann


---

Comment by jmantysalo created at 2015-09-02 06:56:04

Now it should work with empty lattice, 1-element lattice and 2-element lattice. There is backend ready for extending the function in `lattices.py`. I may modify it as suggested by Nathann at comment 9. But the more important question:

How should we exactly define "decomposing elements"? Let's start with


```
Posets.ChainPoset(2).ordinal_sum(Posets.BooleanLattice(3), labels='integers')
```


Is `0` a decomposing element? What are "components" for the lattice? Maybe `0-1`, `1-2` and `2-9`. But then, what are components of 2-element lattice?

Replying to [comment:7 ncohen]:
> > If the poset has coverings `2 -> 6` and `4 -> 9`, then no element `3..8` can be a decomposition element. After founding, say, `2 -> 6` we could check `5 ->`, `4 ->` and so on. But after founding `4 -> 9` we should have a somewhat complicated stack to skip re-checking biggest covers of `4` and `5`. I guess that the algorithm would be slower in reality, but I am quite sure that it would be better in some theoretical meaning.
> 
> HMmm... Skipping some edges without additional assumption on the order in which they are returned?

I dont' mean that. If the lattice has `100` elements, then `0` is the bottom and `99` is the top. If the lattice has coverings `0 -> 37`, `34 -> 88` and `77 -> 99`, then it is not vertically decomposable. There might be faster way to find those coverings than going throught all elements. But the code would be much more complicated.


---

Comment by ncohen created at 2015-09-02 07:11:14

Could you also add to your docstring a reference toward a textbook that defines this notion?


---

Comment by git created at 2015-09-02 10:47:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-02 11:12:13

Replying to [comment:11 ncohen]:
> Could you also add to your docstring a reference toward a textbook that defines this notion?

Duh. Counting Finite Lattices by Heitzig and Reinhold defines it "- - contains an element which is neither the greatest not the least element of L but comparable to every element of L." On the other hand, On the number of distributive lattices by ErnÃ© and (same) Heitzig and Reinhold says "- - if it is either a singleton or the vertical sum of two nonempty posets - -", and vertical sum on two two-element lattice by their definition is the two-element lattice.

I select tscrim as another random victim. Travis, should we define the two-element lattice to be vertically decomposable or indecomposable?

(Or raise `OtherError("developers don't know how to define this")`? `:=)`)


---

Comment by jmantysalo created at 2015-09-09 07:05:57

OEIS uses the definition where the two-element lattice is vertically indecomposable: https://oeis.org/A058800. Does this suffice as a base for the definition?


---

Comment by ncohen created at 2015-09-09 07:45:53

Helloooooooo !

Yeah yeah I guess. Could you just add a link in the doc toward a textbook/paper that defines it the way you use it?

> (Or raise OtherError("developers don't know how to define this")?

We have had very non-enlightening debates here about whether the empty graph is connected or not. In such a situation, I would add such a warning rather than have those stupid conversations `:-P`
Nathann


---

Comment by git created at 2015-09-09 12:21:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-09 12:29:54

This code should now work.

I still don't know how to make the user interface... For posets we have boolean-valued `is_connected()` and subposets-valued `connected_components()`. But what should then be the function returning only "decomposing elements". I will ask in sage-devel.

Comments on documentation are welcome.


---

Comment by ncohen created at 2015-09-09 12:39:16

return_type vs return_elements.


---

Comment by git created at 2015-09-09 12:43:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-09 12:46:07

Replying to [comment:18 ncohen]:
> return_type vs return_elements.

But they are different things. "Internal" function in `hasse_diagram.py` has only one yes/no -argument, so a Boolean seems right. "Interface" function in `lattices.py` has three possible inputs.


---

Comment by ncohen created at 2015-09-09 12:48:41

> But they are different things. "Internal" function in `hasse_diagram.py` has only one yes/no -argument, so a Boolean seems right. "Interface" function in `lattices.py` has three possible inputs.

Sorry, I removed my comment on the argument's type right after I posted it, it was a mistake. The one I left, however, is about the fact that the argument that appears in the doc is not the one that appears in the function's definition.

Nathann


---

Comment by git created at 2015-09-10 11:03:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-10 11:09:11

I will wait until #17226 gets to beta, and then rebase this. (Forgot that it was not there yet.) This will also categorize the index of functions.

I split the function to two parts. I will also wait if somebody comments this on sage-devel. I don't know what should be the name of argument for `vertical_decomposition()`.

So this is open for comments and _de facto_ ready for review, but not _de iure_ in needs_review -phase.


---

Comment by git created at 2015-09-11 07:25:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-11 07:28:20

OK, here is one possible way to split the functionality. Ready for review.


---

Comment by jmantysalo created at 2015-09-11 07:28:20

Changing status from needs_work to needs_review.


---

Comment by git created at 2015-09-14 05:00:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-14 05:04:53

Changing status from needs_review to needs_work.


---

Comment by jmantysalo created at 2015-09-14 05:04:53

Replying to [comment:9 ncohen]:
> You don't have to write this algorithm twice to make it work in all situations. Once is enough.

Done this. Compiling, will change to needs_review if this seems to work.


---

Comment by git created at 2015-09-14 05:42:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-09-14 05:44:30

Changing status from needs_work to needs_review.


---

Comment by jmantysalo created at 2015-09-14 05:44:30

And yes, there was a bug. Now at last this should be ready for review.

(Thematic index of functions might look unnecessary for now. However, see #19197, #19197 etc.)


---

Comment by jmantysalo created at 2015-09-19 12:41:29

Nathann, what about this. You already read the code and the 2-element lattice case is now documented. Hence there is two questions left:

- Is the thematic index of functions OK in lattices?
- Is this splitting of functionality OK?


---

Comment by ncohen created at 2015-09-20 11:33:08

Jori,

I thought a bit before answering your email, because the reason I had not done
anything on the ticket during the last 6 days is that I had chosen to not work
on it anymore. I do not often "forget" things like tickets in needs_review: my
mail inbox contains all the things I must attend to, and they all remain there
until I do what I think I should do with them.

Among the reasons that led me there is that nothing specific makes your code
invalid, and I have no reason to ask you to change it just because it does not
suit my taste. I like things short, simple, concise. Three functions for only
one feature is beyond me, it angers me by itself.

If I were to write it, you would have one Lattice method which would directly
work on the hasse diagram, with a `return_recomposition` boolean flag to return
lists instead of boolean answers. One function, 20 lines, end of the story.

Right now, the Lattice method `vertical_decomposition` contains around 20 lines
of code, none of which has the slightest interest to me. It's just wrapping
things into other things, and testing things that are already tested elsewhere.

What I know, however, is that it is impossible for you to get any kind of code
into Sage and to work with it unless you have somebody to review your code. I
surely know that. Depending on what I work on, depending on the times, it is
either easy or hard to get anything in there, and from time to time I think that
it would be better if you were allowed to put any code that you like into Sage
without needing reviewers like me who drag their feet at every occasion.

Also, I admit that I do not have the energy to discuss the implementation
details endlessly, and I also hate that this process may require you to
implement code only because the only reviewer you have has a different taste.

Truth is, I don't want to be the reason why you cannot work properly on Sage's
code, and I don't have a lot of ways out as not many would do the reviewing job
otherwise. So I will try this: I will implement this as is the most natural to
me, and you can feel free to not use it if you do not like it. Let's see how it
works.

Sorry for the painful reviews.

Nathann

P.S.: the code is at u/ncohen/19123


---

Comment by jmantysalo created at 2015-09-20 15:55:09

Hmm... I continue to think. Or hope that somebody else reviews this.

I hope that having this on `hasse_diagram.py` is useful later - it can be a quick optimization before `frattini_sublattice`.


---

Comment by chapoton created at 2015-09-28 16:58:26

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2015-09-28 16:58:26

does not apply, needs rebase


---

Comment by git created at 2015-09-28 17:34:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-09-28 17:37:15

Err. Terminology nazi here: what you did is a 'merge'. A rebase is a difference operation which moves the commits around.

Nathann


---

Comment by jmantysalo created at 2015-09-28 17:38:33

Merged. Sorry for wrong term.


---

Comment by jmantysalo created at 2015-09-28 17:38:33

Changing status from needs_work to needs_review.


---

Comment by jmantysalo created at 2015-09-30 17:45:56

Kevin, if you are interested in docs, you might want to review this. It does some polishing together with adding little new functionality.


---

Comment by kdilks created at 2015-10-10 20:56:02

I still think that formal definitions should come first, without being labelled as formal definitions, and then informal definitions can come after.


---

Comment by kdilks created at 2015-10-10 21:10:31

I'm not sure if I like the backend code living in `hasse_diagram.py`. Even if the code  applies to more than lattices, you seem to still be making assumptions about the poset being bounded. Plus the initial docstring there is written in a way that implies it only works for lattices.


---

Comment by jmantysalo created at 2015-10-12 08:46:25

Replying to [comment:40 kdilks]:
> I still think that formal definitions should come first, without being labelled as formal definitions, and then informal definitions can come after.

OK, I can change that.

Replying to [comment:41 kdilks]:
> I'm not sure if I like the backend code living in `hasse_diagram.py`. Even if the code  applies to more than lattices, you seem to still be making assumptions about the poset being bounded. Plus the initial docstring there is written in a way that implies it only works for lattices.

I think that all code in `hasse_diagram.py` is "internal", i.e. it is user's fault if something break for direct call to it.

If this is not in `hasse_diagram.py`, then I guess it must be copied if I want to optimize `frattini_sublattice()` with it. Or `linear_extensions_number()` maybe?


---

Comment by git created at 2015-10-21 04:56:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-10-21 04:57:51

Better docstring now?

If this seems hard one to decide, then I can split the (non-relating) part that rearranges the index of functions.


---

Comment by jmantysalo created at 2015-11-01 19:15:16

`ping -c 1 Kevin`. This could be nice to have before #18511, as this modifies the index of function.

(Funny. I have a poset of dependencies between poset-related tickets.)


---

Comment by jmantysalo created at 2015-12-04 19:42:01

Replying to [comment:3 ncohen]:
> Also, why is it only defined for lattices? The algorithm works in all cases.

Here is a kind of followup: #19659. I think that it is most natural generalization to all posets.


---

Comment by jmantysalo created at 2016-01-11 16:12:13

Changing status from needs_review to needs_work.


---

Comment by jmantysalo created at 2016-01-11 16:12:13

Documentation part (i.e. index of functions) done in #19854, so this one needs work.

Also this should be thinked about. There is also #19659 waiting, and in principle it is same thing as this one; a poset that is also a lattice can be expressed as an ordinal sum of two posets only if it vertically decomposable. At least http://users.cecs.anu.edu.au/~bdm/papers/posets.pdf by Brinkmann and McKay uses term "vertically decomposable" with non-lattice posets.

(Actually after #19659 it is easy to make a simple function for #19215, and then use it as a "precompiler" for #14126. But that's another story.)


---

Comment by chapoton created at 2016-03-14 19:33:10

New commits:


---

Comment by chapoton created at 2016-03-14 19:33:10

Changing status from needs_work to needs_review.


---

Comment by kdilks created at 2016-03-29 22:44:12

Minor grammatical corrections:

* In `vertical_decomposition()`, 'Let `d_1, \ldots , d_n` be elements comparable to every element of the lattice, excluding the top and bottom elements.' Should be rephrased as 'Let `d_1, \ldots, d_n` be elements (excluding the top and bottom elements) comparable to every element of the lattice.' The original version makes it sound like the top and bottom elements are being excluded from the set of things that `d_1...d_n` need to be comparable to, instead of being excluded from the set `d_1...d_n` itself.


* Immediately following that, 'Let `b` be THE bottom element and `t` be the top element.'

* 'Informally said, this returns the lattice SPLIT INTO parts AT every single-element "cutting point".'

* Under `INPUT:`, 'return the list OF decomposing elements'.

* In the definition of `is_vertically_decomposable()`, 'A lattice is vertically decomposable if it has an element that is comparable to all elements and is NEITHER the bottom NOR the top element.'

Besides that, I think I'm happy with it. I'll just need to check the rendered documentation once those changes are made.


---

Comment by git created at 2016-03-30 04:34:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-03-30 04:39:09

Replying to [comment:49 kdilks]:
> Minor grammatical corrections:

Thanks! Done those.

> * 'Informally said, this returns the lattice SPLIT INTO parts AT every single-element "cutting point".'

These are hard ones... In Finnish 'hila'='lattice', 'hilassani'='in my lattice' etc.


---

Comment by kdilks created at 2016-03-30 18:04:55

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-03-31 18:41:46

Resolution: fixed
