# Issue 16083: Handle finite slices for infinite enumerate sets

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2014-05-10 02:16:37

Assignee: sage-combinat

CC:  sage-combinat nthiery darij

Keywords: infinite enumerated set slices

Given an infinite enumerated set `I`, I'd still expect this to work (and it's very handy):

```
sage: Partitions()[:5]
[[], [1], [2], [1, 1], [3]]
```



---

Comment by tscrim created at 2014-05-10 02:25:08

Changing status from new to needs_review.


---

Comment by tscrim created at 2014-05-10 02:25:08

New commits:


---

Comment by ncohen created at 2014-05-10 11:28:28

Hellooooooo Travis !!

Okay, this looks very cool but I have two questions:

1) Right now, if an infinite enumerated sets wants to implement `__getitem__` differently (as unrank can be VERY slow) then the slicing feature will be overwritten. Is there a way to avoid that ?

2) To me, computing the slice [:15] should call `__iter__`, which may have been overwritten too. What d you think ?

Those are probems I see with how this is implemented in your branch, but I do not know how to make it better, so I just ask. I am running all tests right now, and if they pass this branch can be set to `positive_review` if we cannot solve any of the problems above `:-)`

Nathann


---

Comment by git created at 2014-05-10 17:10:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-05-10 17:10:59

1) This is a generic implementation (i.e. think in an abstract class), so I can't do anything about when it's overwritten except possibly adding it in in each of those classes directly (which I don't want to do). I would instead recommend having those classes implement `unrank`, if also to avoid ambiguity with things like `ZZ['x']`.

2) Done.


---

Comment by nthiery created at 2014-05-11 18:26:05

This kind of slices can indeed come up handy; thanks for implementing
them!

Could we put it instead in `EnumeratedSets`? This would just require updating
a bit the bound checks, possibly testing if ``self in
Sets().Infinite()``, right?

Also please make the doc read along the following lines::

```
Return the `i`-th element of ``self``, or the slice ...

INPUT:
...

.. WARNING::

    This method is only meant as a convenience shorthand for
    ``self.unrank(i)`` and ``self.foo(...)`` respectively, for casual
    use (e.g. in interactive sessions). Subclasses are hereby
    explicitly permitted to overload ``__getitem__`` with a different
    semantic, typically for enumerated sets that are naturally indexed
    by some `I` not of the form `\{0,1,...\}`.

    ... EXAMPLE HERE, typically with an infinite family ...

    In particular, generic code *should not* use this shorthand.
```


Any suggestion for the name `foo` we should use for the analog of
unrank for slices?

Cheers,
                        Nicolas


---

Comment by tscrim created at 2014-05-11 19:12:34

How about we just use `unrank`? Alternatively perhaps `slice` or `range`?


---

Comment by nthiery created at 2014-05-11 20:21:24

Replying to [comment:7 tscrim]:
> How about we just use `unrank`? Alternatively perhaps `slice` or `range`?

Using `unrank` puts more burden on subclasses that implement `unrank`: they would also need to take care of slices. Having a separate method for slices makes it easy to, e.g. provide default implementations for `slice` in term of `unrank` (or in term of `unrank` and `next` or ...).

Other than this, I have no particular preference yet. Another possibility: `unrank_range`.

Cheers,


---

Comment by ncohen created at 2014-05-12 09:08:02

Helloooooooo !!!

> 1) This is a generic implementation (i.e. think in an abstract class), so I can't do anything about when it's overwritten except possibly adding it in in each of those classes directly (which I don't want to do). I would instead recommend having those classes implement `unrank`, if also to avoid ambiguity with things like `ZZ['x']`.
> 
> 2) Done.

Okayokay, then the result is good to me.. Too bad we cannot solve this once and for all `:-)`

Nathann


---

Comment by tscrim created at 2014-05-12 21:57:37

Grr...polymorphism would be nice. `unrank_range` would be okay for me; want me to implement that Nicolas?


---

Comment by nthiery created at 2014-05-12 22:01:39

Replying to [comment:10 tscrim]:
> Grr...polymorphism would be nice.

You bet ...

> `unrank_range` would be okay for me; want me to implement that Nicolas?

If that's ok with you, please go ahead!


---

Comment by git created at 2014-05-12 22:55:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-05-12 22:56:08

Done.


---

Comment by nthiery created at 2014-05-13 13:12:30

Thanks Travis!

The logic is broken for finite enumerated sets:

```
sage: F = FiniteEnumeratedSet([1,2,3])
sage: F[1:]
...
TypeError: range() integer end argument expected, got NoneType.
```

(in the current examples, `.list()` has already been called, so this piece of the code was not exercised). It might be an option to call `__getitem__` from `EnumeratedSets` to avoid duplicating the logic.

Please also add the warnings along the lines of [comment:6].


---

Comment by git created at 2014-05-13 17:51:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-05-13 17:52:05

Fixed, added, and updated.


---

Comment by nthiery created at 2014-05-13 20:19:36

Thanks. ``__getitem__`` is no more needed in finite enumerated sets, right?

Ah, and I just thought: if it's easy to add functional crosslinks to ``unrank`` and ``unrank_range``, that would be a nice addition.

Cheers,
                             Nicolas


---

Comment by tscrim created at 2014-05-13 20:56:43

The `__getitem__` I have for finite enumerated sets should be faster than calling through `unrank()`. I can't add crosslinks because there is no explicitly defined function `unrank` (at least that I could find).


---

Comment by nthiery created at 2014-05-13 21:51:17

> The `__getitem__` I have for finite enumerated sets should be faster than calling through unrank().

It seems to just duplicate the code of `unrank_range` for finite enumerated sets (which you made fast), and the `__getitem__` of enumerated sets will call that `unrank_range` anyway.

> I can't add crosslinks because there is no explicitly defined function unrank (at least that I could find). 

Too bad, we really should have an optional abstract method for `unrank` ...


---

Comment by tscrim created at 2014-05-13 22:44:58

It's an extra function call (plus some extra logic); so it's a micro optimization but still some speed:

```
sage: def foo():
....:     return 5
....: 
sage: def bar():
....:     return foo()
....: 
sage: %timeit foo()
1000000 loops, best of 3: 504 ns per loop
sage: %timeit bar()
1000000 loops, best of 3: 773 ns per loop
```

plus it's only a few lines, so I don't see much harm.


---

Comment by nthiery created at 2014-05-14 22:23:47

Replying to [comment:20 tscrim]:
> It's an extra function call (plus some extra logic); so it's a micro optimization but still some speed:
> {{{
> sage: def foo():
> ....:     return 5
> ....: 
> sage: def bar():
> ....:     return foo()
> ....: 
> sage: %timeit foo()
> 1000000 loops, best of 3: 504 ns per loop
> sage: %timeit bar()
> 1000000 loops, best of 3: 773 ns per loop
> }}}
> plus it's only a few lines, so I don't see much harm.

Not much I agree. Yet, in general, unless when we really are in a critical path/section, I'd rather not start manually inlining method calls. If you add the extra slice and so on the optimization does not make such a big difference, and it still introduces some duplication: you have to explicitly look at the code to see that it's doing the same thing. And if someone has a better `unrank_range` (granted, this is unlikely), you don't beneficiate from it automatically.

Cheers,
                                                    Nicolas


---

Comment by git created at 2014-05-15 21:33:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-05-15 21:39:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-05-15 21:40:42

Changed (under slight protest). However I did uncover other bugs, in that we needed to better handle negative values and larger than len stopping conditions.


---

Comment by git created at 2014-05-26 03:59:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2015-04-08 06:29:54

some failing doctests, see patchbot report


---

Comment by chapoton created at 2015-04-08 06:29:54

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-03-10 23:52:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-10 23:53:52

Ah, the little tidbits I've forgotten...


---

Comment by tscrim created at 2016-03-10 23:53:52

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-03-11 20:35:40

What about an iterator counterpart?

```
def iterator(self, start=None, end=None, backward=False):
    r"""
    Iterates over the item in this set between the rank ``start`` and ``end``.
    """
```

that would even be more useful (e.g. parallel loops).

Then we can make a cross implementation in the `ParentMethods` (i.e. `__iter__` calling `iterator` and `iterator` calling `__iter__`). Or possibly using `unrank`.

What do you think?


---

Comment by tscrim created at 2016-03-11 23:01:56

This breaks several doctests, some of which indicate things we definitely should support, specifically negative indices. Probably should try `self.list()[i]` first in `__getitem__` for enumerated sets and for finite enumerated sets, we should do `self.list()[i]` if `i < 0`.

We probably should also rewrite the iterator and listing methods for (finite?) enumerated sets to use a lazy list, but I think that is best on a follow-up.

For an `iterator` method, I would call it `iterator_range` for consistency, but I'm not opposed to it. Moreover, the logic from `unrank_range` could probably all be moved there and `unrank_range` just returns a list constructed from `iterator_range`.


---

Comment by tscrim created at 2016-03-11 23:01:56

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-03-12 00:57:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-12 01:04:11

Alright, so I tried to allow the iterator to go over the infinite sets if `stop` was not specified. I also had to implement some methods for Galois groups `G` as they did not have `list(G) == G.list()`, but they will be faster than the generic implementation this way too.

I'm slightly worried we will see a speed regression on finite enumerated sets because it will be repeatedly calling `unrank`, which is asymptotically significantly slower than created the full list of elements and pulling from that (i.e., it is implicitly using a cache). My intuition tells me that this will not likely be used in practice (well, at least doing something like `P[i]` in a tight loop), but perhaps your experience/intuition says different?


---

Comment by tscrim created at 2016-03-12 01:04:11

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2016-05-15 13:58:37

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2016-05-15 13:58:37

you should use "next(it)" and not "it.next()" (for python3 compatibility)


---

Comment by tscrim created at 2016-05-26 10:22:48

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2016-05-26 10:22:48

Fixed. I also rebased the branch (hence the new name) to clean up the history slightly.
----
Last 10 new commits:


---

Comment by git created at 2016-10-06 17:22:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-10-06 17:26:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-10-06 17:27:53

The code is good, but can we be sure that the new `__getitem__` on `EnumeratedSets` does not override an older, better `__getitem__` on `EnumeratedSets` or one of its subclasses? (I suppose the change to Galois groups was an instance of precisely this problem.)


---

Comment by git created at 2016-10-06 17:29:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-10-07 19:23:45

Setting positive_review, but tagging a couple more people for the case the changes trigger some landmine somwehere far away (the new `__getitem__` on `EnumeratedSets` seems to override the more hands-off `__getitem__` on `Parent`; I might imagine that for some subclasses of `EnumeratedSets`, the latter gives better results or is faster).


---

Comment by darij created at 2016-10-07 19:23:45

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-10-21 07:04:39

Resolution: fixed
