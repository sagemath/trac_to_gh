# Issue 20145: Replace is_package_installed with Features

Issue created by migration from https://trac.sagemath.org/ticket/20382

Original creator: saraedum

Original creation time: 2016-04-07 17:03:13

CC:  mkoeppe jdemeyer leif embray defeo isuruf slelievre




---

Comment by fbissey created at 2016-04-07 23:06:41

Indeed same kind of work. Much more sophisticated on your part I must say. Do I understand well that you need an executable class for any external binaries that you want to call?

It could also solve the issue that I was thinking about executables and other files requirement. You should be able to find and use something already installed in a standard location. `theta` being already present in `/usr/local/bin` instead of `$SAGE_LOCAL/bin` (which resolves to `/usr/bin` in sage-on-gentoo) or anywhere in the `PATH`. Similarly you can install `gap` packages in `~/.gap/pkg` and there is no reasons why you shouldn't be able to use those.
----
New commits:


---

Comment by git created at 2016-04-07 23:26:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-04-07 23:31:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by fbissey created at 2016-04-07 23:37:03

Handling of `database_gap` will be delicate. The spkg includes bits removed stuff from `gap` that are expected by default (no need to load if present) and one "real" gap package that one would need to load (`tomlib`). 

That may require special consideration.


---

Comment by saraedum created at 2016-04-07 23:57:06

Thanks for the pointer about database_gap. I should have a complete proposal up on the other ticket in the next 24 hours.


---

Comment by fbissey created at 2016-04-08 00:03:15

I think this ticket should replace the other one unless you have a plan. I am making a list of stuff that needs to come from the other ticket and stuff that should use your feature detection. I guess we could split it along those lines.


---

Comment by fbissey created at 2016-04-08 00:13:22

Going through the files that I have changed in #20377 which this ticket should supersede:
 * `sage/databases/cremona.py` we need to check the real presence of a file in a specific location in this case. Adding something to feature may be overkill for that particular case.
 * `sage/game_theory/normal_form_game.py` + `sage/geometry/polyhedron/base.py` look for the `lrs` executable
 * `sage/graphs/generators/classical_geometries.py` already covered in this ticket
 * `sage/graphs/generic_graph.py` I think my stuff should stay. It is mostly straight `try...expect` whether or not a python module is available.
 * `sage/graphs/graph_generators.py` 3 different executables to detect
 * `sage/graphs/lovasz_theta.py` covered here
 * `sage/groups/generic.py` possibly detect if gap package tomlib is present
 * `sage/groups/perm_gps/permgroup.py` again dodgy database_gap detection in one part. The part using the gap `hap` package would need a nice rework not just migration. I'd like to pick the mind of the person who wrote this.
 * `sage/misc/all.py` my stuff should stay. It is removal of `import` no one uses.
 * `sage/rings/polynomial/multi_polynomial_sequence.py` finding one executable


---

Comment by jhpalmieri created at 2016-04-08 15:09:48

Is there overlap with #20182? Should #20182 be rewritten to use this?
----
New commits:


---

Comment by nthiery created at 2016-04-10 05:03:36

Hi Julian,

Just some rambling, thinking about use cases for this ticket or some follow up:

While discussing with the Debian people, it was stressed out that we
will eventually want to be able to support simultaneously a stable
version of software X (as provided by distributions), and a devel
version of it (e.g. for our researchers that need the very latest
features). Therefore we probably will want to have code that could
look like:


```
        def latest_feature():
            """
            ...

            EXAMPLES::

                sage: X = ...
                sage: X.latest_feature()    # optional gap >= 3.5
            """
            GAP(min_version=3.5).require()      # or some better syntax
            ...
            return gap.latest_feature()
```


To support this use case we would need:

- support for version checking in the Feature code (probably in a follow up ticket).

  Probably not much can be written generically, except possibly for Executables,
  trying to pass the --version and scanning the output for something that looks
  like a version number

- some updates to the doctesting framework to support version
  annotations (definitely in another ticket)

- mapping feature names appearing in the #optional annotations to actual Feature's
  (it's going in this direction in #20182).


Not directly related to this ticket, but building on the discussion we had while walking in Cernay, we may want to be able to write the annotation as::


```
        def latest_feature():
            """
            ...

            .. REQUIRES:: gap >= 3.5

            EXAMPLES::

                sage: X = ...
                sage: X.latest_feature()
            """
```


Cheers,
                           Nicolas


---

Comment by git created at 2016-04-11 02:29:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2016-04-11 02:36:13

nthiery: About version checks. I think it would be easy to add this in the current setup. However, I would recommend to follow the philosophy of autoconf here. I.e., we should not check for a version because you need to keep track which version range supportes the feature you are looking for (and often things are heavily patched so the version might be misleading.) Instead, we should check for the actual feature/interface required. It is a bit more work of course but usually better and much easier to maintain.


---

Comment by nthiery created at 2016-04-11 07:16:05

Yep there is value in the autoconf approach. On the other hand, since this is mostly about doctests at this point, a version information is more useful for the user: "oh, I need to upgrade to 3.5" is simpler than "oh, I need to upgrade to a recent enough version that supports method xxx on object yyy". We could do both: make a feature check, and provide a version number for user reporting; but that's more work. Another advantage of version checking is that you just need to fetch the version once, and don't need to relaunch, e.g a GAP command, each time you want to check another feature.


---

Comment by vdelecroix created at 2016-04-12 13:06:00

I like more the centralized approach in this ticket rather than the one in #20377 in which each feature needs a special care. Though many things looks very complicated and the related #20182 is much more readable (though using inheritance from this ticket would save some efforts). Moreover #20182 implements some _database of available features_ which is not discussed here. The latter has the advantage of minimizing the requests time after the first call. With the architecture proposed here, each check involves a `Feature` class creation and some associated test...

Some more specific remarks:

- Do we really care about the class `FeatureTestResult`? If the result is `True` then we mostly don't care about explanation and if it is `False` we likely want an error (with an explicit error message). Similarly, I would get rid of `FeatureNotPresentError`. Instead, I would add an `error` and a `message` arguments in the `require` method (with of course some reasonable default which would mimic the current behavior using the standard `RuntimeError`).

- Are you sure `CSDP` is better inside the file `lovasz_theta.py`? Do we want to spread the `Features` all around the modules or should they be centralized?

- Finally class names might be confusing. `GapPackage` is not a handle on a gap package nor something describing what is inside a given package (what I would guess from the name). Similarly, with having `CSDP` has a class when `CSDP` is the name of the program. It would be fine if all of them belong to a fixed module.


---

Comment by vdelecroix created at 2016-04-12 13:11:19

And last but not the least: what about having the "packages" part directly attached to executable?

```
sage.interfaces.gap.gap.require_package('grape')
```

instead of

```
sage.misc.features.GapPackage('grape').require()
```



---

Comment by git created at 2016-04-12 13:41:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2016-04-12 13:51:13

Replying to [comment:17 vdelecroix]:
> And last but not the least: what about having the "packages" part directly attached to executable?
Sure. A followup ticket could define `gap.require_package` as a call out
to `GapPackage().require`.


---

Comment by saraedum created at 2016-04-12 13:51:29

Replying to [comment:16 vdelecroix]:
>  Moreover #20182 implements some _database of available features_ which
>  is not discussed here. The latter has the advantage of minimizing the
>  requests time after the first call. With the architecture proposed here,
>  each check involves a `Feature` class creation and some associated test...
The docstring tells you that you might want to cache the result if you think it
is a performance problem. Most of the time you are going to call out to a
binary anyway so I do not see the point of caching it as a default. "Premature
optimization is the root of all evilâ€¦"
We could centralize the checks. I do not really have an opinion on that.

>  - Do we really care about the class `FeatureTestResult`? If the result is
>  `True` then we mostly don't care about explanation and if it is `False` we
>  likely want an error (with an explicit error message).
That's what `is_present` vs `require` is about. There are places where the default algorithm is chosen depending on the
presence of some feature.

>  Similarly, I would
>  get rid of `FeatureNotPresentError`. Instead, I would add an `error` and a
>  `message` arguments in the `require` method (with of course some
>  reasonable default which would mimic the current behavior using the
>  standard `RuntimeError`).
So you have to catch whatever RuntimeError instead of being able to catch
something specific? I do not see the advantage of that. Also, if I understand
your proposal, each caller has to cook up their own error message. I think it
is nice to have a central place where these error messages and resolutions
live.
Finally, with your approach you do not get the granularity between `abc is not
on the path` vs `abc is there but does not work`. That's something that some
people requested.

>  - Are you sure `CSDP` is better inside the file `lovasz_theta.py`? Do we
>  want to spread the `Features` all around the modules or should they be
>  centralized?
See above.

>  - Finally class names might be confusing. `GapPackage` is not a handle on
>  a gap package nor something describing what is inside a given package
>  (what I would guess from the name).
GapPackage lives in sage.misc.feature. So it should be clear that this is not
the actual package. We can suffix everything with Feature if that is preferred.
I prefer short class names if possible.

>  Similarly, with having `CSDP` has a
>  class when `CSDP` is the name of the program. It would be fine if all of
>  them belong to a fixed module.
See above. (Sorry if I misunderstood you. It seems you are raising the
centralization vs localization issue several times in your comment.)


---

Comment by saraedum created at 2016-04-12 13:52:58

Replying to [comment:15 nthiery]:
> Yep there is value in the autoconf approach. On the other hand, since this is mostly about doctests at this point, a version information is more useful for the user: "oh, I need to upgrade to 3.5" is simpler than "oh, I need to upgrade to a recent enough version that supports method xxx on object yyy". We could do both: make a feature check, and provide a version number for user reporting; but that's more work. Another advantage of version checking is that you just need to fetch the version once, and don't need to relaunch, e.g a GAP command, each time you want to check another feature.
> 
Sure. Both options are valid. They are not in the scope of this ticket I
think. In either case, such "features" can easily be added to Feature.


---

Comment by git created at 2016-04-13 21:25:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by slabbe created at 2016-04-15 21:32:50

If I do `ls` in `sage/misc` directory and I see the file `feature.py` listed, I would never be able to guess its content. Can the filename be more verbose maybe `package_feature.py`?


---

Comment by vdelecroix created at 2016-04-16 12:40:53

Replying to [comment:24 slabbe]:
> If I do `ls` in `sage/misc` directory and I see the file `feature.py` listed, I would never be able to guess its content. Can the filename be more verbose maybe `package_feature.py`?

Would not make sense. It is not only about packages but also system softwares and libraries on the system. However, it could contains the words `dependencies` or `requirement`. I am not sure what would be the clearest.


---

Comment by nthiery created at 2016-04-18 00:25:02

Maybe something like ``feature_test``? This seems to be consistent with autoconf's vocabulary.


---

Comment by saraedum created at 2016-04-21 09:05:21

I like `feature_test`. I will rename it to that.


---

Comment by vdelecroix created at 2016-04-27 01:05:29

Hello,

This code is mostly Sage agnostic right? Would it be possible to move this code out of Sage source code? It would better be in `sage/src/sage_setup/` or whatever appropriate (even possibly an external python module). We might want to use it outside of Sage or before Sage is built to track possible dependencies.


---

Comment by fbissey created at 2016-04-27 01:30:05

As far as I am concerned `sage_setup` is only used at install time and shouldn't be used at runtime. But spinning it as a separate python package sounds like an interesting idea. Other packages could probably benefits from those mechanism.


---

Comment by saraedum created at 2016-04-27 13:31:35

I already thought about moving parts of this out of the source tree. I have not really reached a conclusion yet. It certainly needs to be used during build time. Currently, we have `sage_setup/optional_extension.py` which calls `sage.misc.package.is_package_installed`. So, at least in a first version, I would certainly mimic this behaviour and check for a feature (in this case, whether Cython can build against a library) at build time.

Replying to [comment:28 vdelecroix]:
> This code is mostly Sage agnostic right?
The idea is Sage agnostic. The features it checks for are of course relatively Sage specific.

> Would it be possible to move this code out of Sage source code? It would better be in `sage/src/sage_setup/` or whatever appropriate (even possibly an external python module). We might want to use it outside of Sage or before Sage is built to track possible dependencies.
I am not sure about moving it to `sage_setup`. We need this at runtime. Can we (and should we?) access things in `sage_setup` at runtime?
It is an interesting idea to make it a separate package. There seems to be no python package around which does anything similar. I would be happy to pursue such a path but would like to postpone this to a followup ticket.


---

Comment by git created at 2016-07-08 23:11:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-07-09 00:19:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-07-15 01:10:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-07-20 02:42:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2016-07-20 02:45:22

This seems to be essentially complete now. Some docstrings are still missing and I also need to do some testing but I replaced all occurrences of `is_package_installed` if the code is just checking whether an optional package is installed.
Any feedback is already very welcome until I find the time to polish all the docstrings.


---

Comment by fbissey created at 2016-07-20 02:52:25

That's really cool. I will give it a good look. I may even try it in sage-on-gentoo.


---

Comment by saraedum created at 2016-07-20 04:37:20

I was actually a little confused that `is_package_installed` gets used in so few places. (Or maybe `search_src` is lying about it.)


---

Comment by fbissey created at 2016-07-20 10:54:51

Looks good to me. There is one last thing that I think should be done, but I wouldn't hold the ticket for it, is remove

```
from .package import (install_package,
        installed_packages, is_package_installed,
        standard_packages, optional_packages, experimental_packages,
        upgrade, package_versions)
```

from `sage/misc/all.py` we don't really want those to be directly exposed in my opinion - and they are/were always called explicitly in sage itself.


---

Comment by fbissey created at 2016-07-21 11:08:47

My wish above may be best served by different ticket. Can you put this one in "need review".


---

Comment by vdelecroix created at 2016-07-22 20:34:08

Checking availability of a Python module as you did has consequences

```
sage: def is_present(module):
....:    import importlib
....:    try:
....:        importlib.import_module(module)
....:        return True
....:    except ImportError:
....:        return False
sage: print len(sys.modules), 'numpy' in sys.modules
2625 False
sage: is_present('numpy')
True
sage: print len(sys.modules), 'numpy' in sys.modules
2710 True
```

This would better be documented.


---

Comment by vdelecroix created at 2016-08-01 14:54:13

I would be very happy to use this ticket to solve #21135 where I need to set the octave parameters for its Sage interface depending on its version... hence I am asking whether it would be possible to have a `version` method on `Features` (or at least on `Executable`)? For executable it is reasonable to just have an attribute `_version_cmd_option` (that would generally be `-v` or `--version` or `--dumpversion`) with a default implementation that runs the command with the option `_version_cmd_option`. What do you think?


---

Comment by vdelecroix created at 2016-08-01 15:03:14

Note also that for interfaces we allow remote programs with possibly subtle commands (see #20388 and the file `sage/interfaces/expect.py`). For example, I can access magma and get it work within sage by doing

```
$ SAGE_MAGMA_COMMAND="module load magma/2.11.13; magma"
$ SAGE_MAGMA_SERVER="plafrim"
$ export SAGE_MAGMA_COMMAND SAGE_MAGMA_SERVER
$ sage -q
sage: magma('1+1')
2
```

Does a magma feature should take care of this?


---

Comment by saraedum created at 2016-08-01 22:32:24

Replying to [comment:41 vdelecroix]:
> I would be very happy to use this ticket to solve #21135 where I need to set the octave parameters for its Sage interface depending on its version...
It would be great to see somebody use this interface already :)
I have completing this Ticket high on my priority list. I hope I find the time to do this soon.

> hence I am asking whether it would be possible to have a `version` method on `Features` (or at least on `Executable`)? For executable it is reasonable to just have an attribute `_version_cmd_option` (that would generally be `-v` or `--version` or `--dumpversion`) with a default implementation that runs the command with the option `_version_cmd_option`. What do you think?

Sometimes version checking is a good thing to do but I generally follow the autoconf tradition here that sees version numbers as something very unreliable. I think you should check whether the executable provides the interface that you need.

So, I would be reluctant to provide a general interface for version checks. I should certainly add a comment about this somewhere. Anyway, you can extend any Feature. To check for a version you might want to roughly do something like what I did for `StaticFile.absolute_path`.


---

Comment by saraedum created at 2016-08-01 22:33:49

Replying to [comment:42 vdelecroix]:
> Note also that for interfaces we allow remote programs with possibly subtle commands (see #20388 and the file `sage/interfaces/expect.py`). For example, I can access magma and get it work within sage by doing
> {{{
> $ SAGE_MAGMA_COMMAND="module load magma/2.11.13; magma"
> $ SAGE_MAGMA_SERVER="plafrim"
> $ export SAGE_MAGMA_COMMAND SAGE_MAGMA_SERVER
> $ sage -q
> sage: magma('1+1')
> 2
> }}}
> Does a magma feature should take care of this?

Sorry, but I am not sure whether I understand your question. Do you mean whether a `Magma` Feature should look at `SAGE_MAGMA_COMMAND` and `SAGE_MAGMA_SERVER`? Yes, absolutely.


---

Comment by vdelecroix created at 2016-08-01 22:36:17

Replying to [comment:44 saraedum]:
> Replying to [comment:42 vdelecroix]:
> > Note also that for interfaces we allow remote programs with possibly subtle commands (see #20388 and the file `sage/interfaces/expect.py`). For example, I can access magma and get it work within sage by doing
> > {{{
> > $ SAGE_MAGMA_COMMAND="module load magma/2.11.13; magma"
> > $ SAGE_MAGMA_SERVER="plafrim"
> > $ export SAGE_MAGMA_COMMAND SAGE_MAGMA_SERVER
> > $ sage -q
> > sage: magma('1+1')
> > 2
> > }}}
> > Does a magma feature should take care of this?
> 
> Sorry, but I am not sure whether I understand your question. Do you mean whether a `Magma` Feature should look at `SAGE_MAGMA_COMMAND` and `SAGE_MAGMA_SERVER`? Yes, absolutely.

Yes. That was mostly the question ;-) There are some interferences between the branch provided here and how software are detected (and configured) in `sage/interfaces/`. This should be done in one place and I guess features is the right one.


---

Comment by vdelecroix created at 2016-08-01 22:39:40

Replying to [comment:43 saraedum]:
> Replying to [comment:41 vdelecroix]:
> > [...]
> 
> Sometimes version checking is a good thing to do but I generally follow the autoconf tradition here that sees version numbers as something very unreliable. I think you should check whether the executable provides the interface that you need.

Argh. I do not see how I can check that `octave` does not launch the GUI... I can check whether `octave --no-gui` is available. If octave does not exist I got a `OSError` and if it does not accept `--no-gui` I get a `1` return code. Is that what I should do? Does that should be part of an `Octave` feature?


---

Comment by git created at 2016-08-04 05:25:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-08-17 04:41:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-08-17 04:52:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-08-18 03:39:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2016-08-18 03:44:16

Replying to [comment:2 fbissey]:
> [...] Do I understand well that you need an executable class for any external binaries that you want to call?
Its up to you. You can create a new class and make it easier for others to use or you could just write `Executable(...).require()` to check for an executable in one place.


---

Comment by saraedum created at 2016-08-18 03:46:31

Replying to [comment:6 fbissey]:
> Handling of `database_gap` will be delicate. The spkg includes bits removed stuff from `gap` that are expected by default (no need to load if present) and one "real" gap package that one would need to load (`tomlib`). 
I tried to check for the package that was actually needed whenever the old code queried the `gap_packages` SPKG. I am not sure I fully understand your comment here. Could you point me to an example in the code where this is a problem?


---

Comment by saraedum created at 2016-08-18 03:54:59

Replying to [comment:9 fbissey]:
> Going through the files that I have changed in #20377 which this ticket should supersede:
>  * `sage/databases/cremona.py` we need to check the real presence of a file in a specific location in this case. Adding something to feature may be overkill for that particular case.
`sage/databases/cremona.py` loads the cremona DB from a very specific place, namely `SAGE_SHARE`. This is certainly not ideal. But making that code more flexible should imho go into a followup ticket. Should I create one?
>  * `sage/game_theory/normal_form_game.py` + `sage/geometry/polyhedron/base.py` look for the `lrs` executable
Addressed with the `Lrs` feature.
>  * `sage/graphs/generators/classical_geometries.py` already covered in this ticket
>  * `sage/graphs/generic_graph.py` I think my stuff should stay. It is mostly straight `try...expect` whether or not a python module is available.
I am checking this now with a `PythonModule` feature.
>  * `sage/graphs/graph_generators.py` 3 different executables to detect
I am checking for these executables (and run them on trivial inputs.)
>  * `sage/graphs/lovasz_theta.py` covered here
>  * `sage/groups/generic.py` possibly detect if gap package tomlib is present
I am checking for the presence of the small groups library. Is that the same somehow?
>  * `sage/groups/perm_gps/permgroup.py` again dodgy database_gap detection in one part. The part using the gap `hap` package would need a nice rework not just migration. I'd like to pick the mind of the person who wrote this.
I am checking for the hap package here. Is there anything else that should happen?
>  * `sage/misc/all.py` my stuff should stay. It is removal of `import` no one uses.
Sure. But I am not addressing this here.
>  * `sage/rings/polynomial/multi_polynomial_sequence.py` finding one executable
Actually you need to check for the presence of the fes library. Not only that but also whether the sage interface to that library has been built (which only happens if sage can find the library, i.e., SPKG at build time.)


---

Comment by saraedum created at 2016-08-18 04:00:00

Replying to [comment:15 nthiery]:
> Yep there is value in the autoconf approach. On the other hand, since this is mostly about doctests at this point, a version information is more useful for the user: "oh, I need to upgrade to 3.5" is simpler than "oh, I need to upgrade to a recent enough version that supports method xxx on object yyy". We could do both: make a feature check, and provide a version number for user reporting; but that's more work.
That's the approach I would like to follow. Currently there is no code like this in here because I am just replacing `is_package_installed` which also did not do any version checks. But, yes, people should check for a certain feature of a package and then the `reason` of a test failure should say "Your X does not support Y." and the `resolution` should say "You need at least version Z of X. Try sage -i X to fix this." or something along these lines.


---

Comment by git created at 2016-08-18 04:13:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2016-08-18 04:14:53

Replying to [comment:40 vdelecroix]:
> Checking availability of a Python module as you did has consequences
> {{{
> sage: def is_present(module):
> ....:    import importlib
> ....:    try:
> ....:        importlib.import_module(module)
> ....:        return True
> ....:    except ImportError:
> ....:        return False
> sage: print len(sys.modules), 'numpy' in sys.modules
> 2625 False
> sage: is_present('numpy')
> True
> sage: print len(sys.modules), 'numpy' in sys.modules
> 2710 True
> }}}
> This would better be documented.
You are right. I documented that.


---

Comment by saraedum created at 2016-08-18 04:21:13

Replying to [comment:46 vdelecroix]:
> Replying to [comment:43 saraedum]:
> > Replying to [comment:41 vdelecroix]:
> > > [...]
> > 
> > Sometimes version checking is a good thing to do but I generally follow the autoconf tradition here that sees version numbers as something very unreliable. I think you should check whether the executable provides the interface that you need.
> 
> Argh. I do not see how I can check that `octave` does not launch the GUI... I can check whether `octave --no-gui` is available. If octave does not exist I got a `OSError` and if it does not accept `--no-gui` I get a `1` return code. Is that what I should do? Does that should be part of an `Octave` feature?
I have a feeling that I already answered this one. But apparently I have not.
I would write an `Octave` feature that checks whether there is an `octave` binary and then checks whether it accepts `--no-gui`. Sort of like `StaticFile` has an `absolute_path()` that tells you something about how this feature works, `Octave` could expose information about which parameters are needed to actually invoke it so it reads from stdin.


---

Comment by saraedum created at 2016-08-18 04:23:19

I hope I addressed all comments on this ticket. I did not have a chance to run all doctests yet (my sage 7.4 is still building) but essentially this is ready for review now.


---

Comment by git created at 2016-08-18 04:40:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2016-08-18 04:40:46

New commits:
----
New commits:


---

Comment by saraedum created at 2016-08-18 04:40:46

Changing status from new to needs_review.


---

Comment by git created at 2016-08-25 18:55:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2016-08-25 19:02:13

Since `is_package_installed` is very sage (the distribution) specific, it causes trouble for package managers which would like to refer to check whether a package is available on the local system instead of whether it has been installed with `sage -i` (or similar.)
This replaces all occurrences of `is_package_installed` (which are not part of sage the distribution) with a "feature" check which is performed much in the spirit of autoconf: check for the presence of the features needed, not for version numbers.
These checks are certainly not perfect yet and will need to evolve over time.


---

Comment by git created at 2016-08-25 19:50:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2016-08-26 11:43:34

Needs to be merged with Sage 7.4.beta2.


---

Comment by jdemeyer created at 2016-08-26 11:43:34

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2016-08-26 11:53:06

For `OptionalModule`, you should separate the library check from the Python module check. They really are independent things. It just happens that there is essentially a one-to-one correspondence in Sage, but that doesn't have to be the case.

And once you do this, you can use the library check in `src/sage_setup/optional_extension.py` to decide which optional extensions to build.


---

Comment by jdemeyer created at 2016-08-26 12:13:25

The changes to `src/sage/misc/cython.py` might make sense but do not belong to this ticket.


---

Comment by fbissey created at 2016-08-26 12:14:30

I must say to me in sage-on-gentoo the fact that the current `OptionalModule` only require presence to build the extension is problematic but I don't expect a solution to that particular aspect in the near future.
In effect the fact that you only check for presence/availability as a signal for building is introducing automagic dependencies.

I currently have a variable mechanism to signal that the dependency should be present and I want to build. A `setup.cfg` could be a viable solution. I realise that it would be a burden in the current sage model in the short term.


---

Comment by jdemeyer created at 2016-08-26 12:16:27

Replying to [comment:71 fbissey]:
> I must say to me in sage-on-gentoo the fact that the current `OptionalModule` only require presence to build the extension is problematic but I don't expect a solution to that particular aspect in the near future.

Ideally, Sage should have something like Gentoo's `USE` flags for optional dependencies...


---

Comment by git created at 2016-09-01 20:11:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2016-09-01 20:19:03

Replying to [comment:69 jdemeyer]:
> For `OptionalModule`, you should separate the library check from the Python module check. They really are independent things. It just happens that there is essentially a one-to-one correspondence  in Sage, but that doesn't have to be the case.
Ok. I am splitting this up.

> And once you do this, you can use the library check in `src/sage_setup/optional_extension.py` to decide which optional extensions to build.
That would be a followup ticket I believe.


---

Comment by saraedum created at 2016-09-01 21:21:08

Replying to [comment:70 jdemeyer]:
> The changes to `src/sage/misc/cython.py` might make sense but do not belong to this ticket.
I'd prefer to sneak this change in here. The shared library test code in here actually tests that this does the right thing and I'd prefer not to write some constructed doctest for something like this.


---

Comment by git created at 2016-09-01 21:22:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2016-09-01 21:28:19

Changing status from needs_work to needs_review.


---

Comment by fbissey created at 2016-09-01 21:36:45

Changing status from needs_review to needs_work.


---

Comment by fbissey created at 2016-09-01 21:36:45

Sorry, but it will need rebasing against #21289 which is already merged for the next beta.


---

Comment by jdemeyer created at 2016-09-02 12:24:12

Replying to [comment:75 saraedum]:
> Replying to [comment:69 jdemeyer]:
> > For `OptionalModule`, you should separate the library check from the Python module check. They really are independent things. It just happens that there is essentially a one-to-one correspondence  in Sage, but that doesn't have to be the case.
> Ok. I am splitting this up.

Well, I meant _really_ splitting those it up: get rid of `OptionalModule` altogether and replace it by `Module`. And remove the dependencies: if the dependencies are not satisfied, the module will not import. There is no need for an additional check.

> > And once you do this, you can use the library check in `src/sage_setup/optional_extension.py` to decide which optional extensions to build.
> That would be a followup ticket I believe.

Fair enough.


---

Comment by saraedum created at 2016-09-08 01:28:49

Replying to [comment:80 jdemeyer]:
> Replying to [comment:75 saraedum]:
> > Replying to [comment:69 jdemeyer]:
> > > For `OptionalModule`, you should separate the library check from the Python module check. They really are independent things. It just happens that there is essentially a one-to-one correspondence  in Sage, but that doesn't have to be the case.
> > Ok. I am splitting this up.
> 
> Well, I meant _really_ splitting those it up: get rid of `OptionalModule` altogether and replace it by `Module`. And remove the dependencies: if the dependencies are not satisfied, the module will not import. There is no need for an additional check.
Sure, the check is not necessary. But I would like to tell people what is the problem here. In that particular case, the module also would not import but that's more obscure than telling people that the required library is missing. More generally, an `OptionalModule` checks whether the module imports and is functional. Running some tests to make sure that the underlying library is working properly is a reasonable thing to do imho.


---

Comment by jdemeyer created at 2016-09-08 06:10:12

Replying to [comment:81 saraedum]:
> But I would like to tell people what is the problem here.

The problem is that they need to install the optional Sage package. That's what you should tell.

> In that particular case, the module also would not import but that's more obscure than telling people that the required library is missing.

But the `OptionalModule` machine checks whether the optional Sage package is installed. Having the library available from the OS would not help.

> Running some tests to make sure that the underlying library is working properly is a reasonable thing to do imho.

I don't like to put the same information in different places. That way, you will eventually end up with inconsistencies. The information that the module needs the library should be in exactly one place, namely the build system which decides when the module is compiled.


---

Comment by fbissey created at 2016-09-08 07:28:51

Replying to [comment:82 jdemeyer]:
> Replying to [comment:81 saraedum]:
> > But I would like to tell people what is the problem here.
> 
> The problem is that they need to install the optional Sage package. That's what you should tell.
> 
> > In that particular case, the module also would not import but that's more obscure than telling people that the required library is missing.
> 
> But the `OptionalModule` machine checks whether the optional Sage package is installed. Having the library available from the OS would not help.
> 

Indeed. The current build system assumes that if the package is installed it is because I explicitly want it in sage. It is a long standing convention which from where I sit on the outside is called automagic detection. The reality is that it belongs to configuration space (with availability checking - autoconf style). Sure it is possibly more risky to use an outside package but if it satisfy the availability checking, why not?

After all, at least some of us want to push sage down that way. 

Also note that for executables `Features` only cares about availability in the path, from sage or not (as it should as far as I am concerned). So not caring whether it is from sage or not is in spirit. 

I'll admit to have a bias since I want most of `sage/misc/package.py` to be gone with a top priority on `is_package_installed` in particular.


---

Comment by jdemeyer created at 2016-09-08 07:33:34

Replying to [comment:83 fbissey]:
> The reality is that it belongs to configuration space (with availability checking - autoconf style). Sure it is possibly more risky to use an outside package but if it satisfy the availability checking, why not?

I'm not disagreeing with that. However, it is besides the point. This ticket should implement the current reality, not some future plan.


---

Comment by fbissey created at 2016-09-08 07:42:13

I don't think `feature` can replace the current reality of what happens in `OptionalExtension`. It should be strictly future work. I am OK for it to be left as is until we decide it is time to move.


---

Comment by fbissey created at 2016-09-08 08:11:12

I guess if building and possibly documentation are the only place left using stuff from `package.py` it could be moved to `sage_setup` where things not needed at run-time belongs in my opinion.


---

Comment by fbissey created at 2016-09-08 08:11:29

documentation -> doctesting


---

Comment by jdemeyer created at 2016-09-16 08:31:19

I think I have not made my point clear in [comment:82]

What I wanted to say: you should remove the check for libraries from the `OptionalModule` features. It is _currently_ (whether you like it or not) the job of `OptionalExtension` in `sage_setup` to decide whether or not to build the Python module. I don't see the point of the redundant check in `OptionalModule`. It needlessly complicates things and it is actually wrong (`OptionalModule` requires a Sage package, not a system package).


---

Comment by fbissey created at 2016-10-02 09:01:36

Rebasing on current develop. Someone else should check that I did everything right. One worry when building in parallel building of documentation kept on failing on `:module:` in `package.py`. When I built serial it just worked.
----
New commits:


---

Comment by saraedum created at 2016-11-28 10:00:37

Replying to [comment:88 jdemeyer]:
> I think I have not made my point clear in [comment:82]
> 
> What I wanted to say: you should remove the check for libraries from the `OptionalModule` features. It is _currently_ (whether you like it or not) the job of `OptionalExtension` in `sage_setup` to decide whether or not to build the Python module. I don't see the point of the redundant check in `OptionalModule`. It needlessly complicates things and it is actually wrong (`OptionalModule` requires a Sage package, not a system package).
I don't understand. I meant to write this so it works for a sage that has not been installed through sage-the-distribution. So, for the module to work, I have to check that it has been compiled and that the library it uses actually works. For sage-the-distribution the second part is redundant for other distributions it may not be.


---

Comment by jdemeyer created at 2017-01-05 16:47:00

Replying to [comment:90 saraedum]:
> So, for the module to work, I have to check that it has been compiled and that the library it uses actually works.

No, you don't need to check anything. The module is linked against the library. If the library didn't work, the module probably wouldn't even compile and it certainly wouldn't be importable. If you can import the module, then surely the library works.


---

Comment by embray created at 2017-01-12 09:44:25

Something I don't quite get about this:  It seems to be purely for runtime feature checks, which is fine and a good thing to have.  But is there also any intention or thought put into making this usable for build-time feature checks when building Sage?  Is there any way this could be used to check the system for features during `./configure` (i.e. as a replacement for a m4 scripts to do the same)?


---

Comment by saraedum created at 2017-01-12 17:02:25

When we originally discussed this during Sage days the idea was to eventually use it for both, build and compile time. For that it would have to be moved out of the sage library probably. So yes, we thought about this as a possible second step.


---

Comment by embray created at 2017-01-13 11:07:34

Thanks for clarifying that.  Yes, for that reason alone it would make sense to have as a stand-alone package of sorts.

Is there anything I can do to help move this forward?  I think getting this to a state where it can also detect already installed dependencies will help massively speed up development time in some cases.


---

Comment by fbissey created at 2017-01-14 09:37:23

I am quite happy to have it for run-time only in the first instance. One issue for building is that we are not quite ready to use non sage installed optional package at this stage (i.e. finding optional package not installed by sage).

Fixing runtime would remove a burden from sage-on-distro, especially the bits depending on `is_package_installed` that we don't want to use in a distro. Build time can be fixed if the distro decides to support a particular option. But ideally we would want something more fine grained. Ideally it would tie up with a proper configuration phase.


---

Comment by embray created at 2017-01-16 13:14:54

Replying to [comment:97 fbissey]:
> I am quite happy to have it for run-time only in the first instance. One issue for building is that we are not quite ready to use non sage installed optional package at this stage (i.e. finding optional package not installed by sage).

I'm not sure what you mean exactly by this.  Why should optional packages be a problem as long as this can be useful for non-optional packages?

> Fixing runtime would remove a burden from sage-on-distro, especially the bits depending on `is_package_installed` that we don't want to use in a distro. Build time can be fixed if the distro decides to support a particular option. But ideally we would want something more fine grained. Ideally it would tie up with a proper configuration phase.

Yes, that work is going on in #21566 and other associated tickets.

To be clear, I think we're in agreement that _this ticket_ should not handle any tasks directly related to enabling build-time detection of dependencies.  I agree that's a separate issue.  My point is that we should keep that use-case in mind for this ticket insofar as the checks its provides don't depend on having a fully working Sage install already, and that it exists outside the main Sage package.

In other words, this ticket could remain focused on fixing the `is_package_installed` issue, but just keep in mind the other use case that this code could help resolve.


---

Comment by saraedum created at 2017-03-13 22:35:22

After some discussion with jdemeyer, I'll remove the current checks OptionalModule. I'll leave the possibility for such checks in though.


---

Comment by saraedum created at 2017-03-13 22:41:42

Changing status from needs_work to needs_review.


---

Comment by saraedum created at 2017-03-13 23:00:00

New commits:


---

Comment by saraedum created at 2017-03-14 16:12:20

Changing keywords from "" to "days85".


---

Comment by jdemeyer created at 2017-03-14 16:34:23

Shouldn't _all_ feature checks be cached?


---

Comment by jdemeyer created at 2017-03-14 16:35:10

Copy-paste typo:

```python
class Bliss(OptionalModule):
    r"""
    A :class:`Feature` which describes whether the ;module:`sage.graphs.bliss`
    module has been enabled for this build of Sage and is functional.

    .. NOTE::

------> This module does not depend on :class:`LibFESLibrary`. If the module
        imports we just assume that the library is working.
```



---

Comment by jdemeyer created at 2017-03-14 16:44:57

I don't like `_test_code`: you define the attribute `_test_code`, pass it through `__init__` and then assign it as the `test_code` attribute. Why so convoluted, you might as well assign `test_code` directly.


---

Comment by jdemeyer created at 2017-03-14 16:46:50

Speaking of test code, wouldn't it be cleaner to move the test code snippets to separate files? Right now, I find it a bit distracting to have the Cython test code in between the Python code implementing the testing logic.


---

Comment by jdemeyer created at 2017-03-14 16:47:51

Typo: `;module:`sage.libs.fes``


---

Comment by jdemeyer created at 2017-03-14 16:49:44

Replying to [comment:100 saraedum]:
> After some discussion with jdemeyer, I'll remove the current checks OptionalModule.

Given that `OptionalModule` and `Module` essentially do the same thing, can you just get rid of the `OptionalModule` class completely?


---

Comment by jdemeyer created at 2017-03-14 16:50:56

I don't really like the names `LibFES` and `Bliss`. I would prefer something which clearly reminds that this is just about the module: I would call them `FESModule` and `BlissModule`.


---

Comment by jdemeyer created at 2017-03-14 16:55:36

Another suggestion: split this one big file `src/sage/misc/feature_test.py` up. It would be good to separate the abstract base classes (like `Executable`, `SharedLibrary`,...) from the actual concrete tests.

Personally, I would even have one file for each package, for example `src/sage/misc/feature_test/bliss.py` for `BlissLibrary` and `BlissModule`. In this case, you can define the Cython test code as module global, which would solve [comment:109] too.


---

Comment by saraedum created at 2017-03-14 19:22:42

Except for the typos, we do not fully agree on whether the above should be changed or not. jdemeyer agreed to split up the module, introduce caching, and do the renamings himself.


---

Comment by saraedum created at 2017-03-14 19:22:42

Changing status from needs_review to needs_work.


---

Comment by saraedum created at 2017-03-14 19:22:54

Set assignee to jdemeyer.


---

Comment by embray created at 2017-04-03 07:06:16

This is a minor nit, but is there a reason this isn't using `super().__init__` for calling the base-class `__init__`s?


---

Comment by saraedum created at 2018-01-31 15:13:32

What should we do about this issue? I had put a lot of work into this and I would like to get this merged.

Jeroen: Would you agree to merge this as is now (after fixing patchbot errors)? Or can I expect a patch anytime soon?


---

Comment by saraedum created at 2018-01-31 15:13:32

Changing status from needs_work to needs_review.


---

Comment by embray created at 2018-01-31 15:48:10

I've in the meantime started moving in a different direction for build-time feature dependency checks, so to me at least my earlier questions about using this for that purpose are moot.  But I'm still +1 on having it for runtime feature checks.

It looks like the patch does not apply so I think you'll have to set this back to needs_work.  I'd be happy to help rebasing your patch if need be.


---

Comment by jdemeyer created at 2018-02-12 14:37:39

I'll clean this up.
----
New commits:


---

Comment by jdemeyer created at 2018-02-12 14:37:39

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2018-02-12 14:40:43

In some cases, bigger changes were made than just using this new `Features` framework. I'll split those off as separate tickets.


---

Comment by git created at 2018-02-12 14:43:00

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-02-12 15:05:28

It seems that `SharedLibrary` is not checking for libraries at all: it just tries to compile some Cython code. So it would be better to rename it as `CythonFeature` or whatever better name I can come up with...


---

Comment by jdemeyer created at 2018-02-12 15:11:09

Replying to [comment:111 jdemeyer]:
> Given that `OptionalModule` and `Module` essentially do the same thing, can you just get rid of the `OptionalModule` class completely?

I will remove `OptionalModule` and also rename `Module` -> `PythonModule`.


---

Comment by jdemeyer created at 2018-02-12 15:31:53

I just found a problem which is not easy to fix: there is no way as far as I can tell to silence compiler error in distutils. This means that feature checks will show messages like

```
/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.4/../../../../x86_64-pc-linux-gnu/bin/ld: cannot find -lxxxxxxxx
collect2: error: ld returned 1 exit status
```



---

Comment by embray created at 2018-02-12 16:02:23

I could take a look at that. I feel like that's a problem I've solved once before, also when using distutils for feature checks (even if it means temporarily redirecting stdio or something).


---

Comment by git created at 2018-02-12 16:11:58

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-02-12 16:17:28

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-02-12 16:21:35

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-02-12 16:22:23

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2018-02-12 16:22:23

I'm setting this to needs_review mainly for patchbot testing. It's probably going to break somewhere, but it should mostly work.


---

Comment by git created at 2018-02-12 20:30:13

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-02-12 20:48:01

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-02-12 20:48:15

Changing status from needs_review to needs_work.


---

Comment by git created at 2018-02-12 21:33:58

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-02-12 21:35:10

I now consider this finished, apart from #24720.


---

Comment by git created at 2018-02-12 21:36:44

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-02-12 21:40:06

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-02-12 21:52:05

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by fbissey created at 2018-02-12 22:09:10

It looks really good. There are a few files remaining to migrate to "features" not covered here but that's good for a first iteration and will prove that the concept work. One more file should be migrated in this ticket I think, `databases/cremona.py`  because it is the only file that would use `features/databases.py` as it currently stands.

For info the following files have stuff to convert
* coding/linear_code.py
* coding/guava.py
* coding/databases.py
* graphs/generators/smallgraphs.py
* groups/abelian_gps/abelian_group.py
All of these are about some gap packages.


---

Comment by jdemeyer created at 2018-02-13 06:25:02

Replying to [comment:142 fbissey]:
> One more file should be migrated in this ticket I think, `databases/cremona.py`  because it is the only file that would use `features/databases.py` as it currently stands.

I split that off as #24718.


---

Comment by jdemeyer created at 2018-02-13 15:41:40

If you care about this ticket, please review #24722, #24724, #24720 which all deal with improving `sage.misc.cython` to allow for silent operation.


---

Comment by fbissey created at 2018-02-25 22:23:40

OK I think it is time to move this ticket further.


---

Comment by fbissey created at 2018-02-25 22:23:40

Changing status from needs_work to positive_review.


---

Comment by jdemeyer created at 2018-02-26 08:55:31

I never set this to needs_review.


---

Comment by jdemeyer created at 2018-02-26 08:55:31

Changing status from positive_review to needs_work.


---

Comment by jdemeyer created at 2018-02-26 08:56:43

There is one issue remaining: this shouldn't use `cython_import()` but a direct `cython()` call. For simplicity, I plan to do that once all dependencies are merged.


---

Comment by fbissey created at 2018-02-26 09:21:06

Ok, at #20382#comment:138 you said you considered this done. So I assumed too much out of that. Works well as far as I am concerned.


---

Comment by jdemeyer created at 2018-02-26 21:01:22

I guess I meant more broadly "apart from issues with Cython".


---

Comment by fbissey created at 2018-02-26 21:05:55

It looks like the dependencies that you listed will be in the next beta - which could turn out to be a rc at this stage. Are there any more tickets that need to go in prior to this one in your opinion?


---

Comment by jdemeyer created at 2018-02-26 21:27:51

#24764 would be nice because it touches the same code.


---

Comment by slelievre created at 2018-03-13 09:18:49

#24764 is in.


---

Comment by git created at 2018-03-13 14:49:00

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2018-03-13 14:50:46

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2018-03-13 14:50:46

Setting milestone to sage-pending because I think that this ticket should *not* be merged in Sage 8.2. The reason is that this ticket has a lot of potential to break stuff because it involves optional packages and those are tested poorly. This would be an ideal ticket to merge in 8.3.beta0.


---

Comment by saraedum created at 2018-03-23 21:42:36

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-05-08 17:27:34

Resolution: fixed


---

Comment by vdelecroix created at 2018-05-19 08:18:22

Replying to [comment:155 jdemeyer]:
> Setting milestone to sage-pending because I think that this ticket should *not* be merged in Sage 8.2. The reason is that this ticket has a lot of potential to break stuff because it involves optional packages and those are tested poorly. This would be an ideal ticket to merge in 8.3.beta0.

Indeed... help for fixing the consequences in: #25332

And one question: the LattE feature from #25400 needs to check for two executables. Should I introduce an abstract class feature "Executables" (whose constructor argument would be a list of `Executable` classes)?
