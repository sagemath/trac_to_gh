# Issue 17846: Stop using old_style_globals

archive/issues_017846.json:
```json
{
    "body": "\n\nIssue created by migration from https://trac.sagemath.org/ticket/18083\n\n",
    "created_at": "2015-03-29T17:19:09Z",
    "labels": [
        "cython",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.6",
    "title": "Stop using old_style_globals",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17846",
    "user": "jdemeyer"
}
```


Issue created by migration from https://trac.sagemath.org/ticket/18083





---

archive/issue_comments_239324.json:
```json
{
    "body": "New commits:",
    "created_at": "2015-03-29T19:50:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239324",
    "user": "jdemeyer"
}
```

New commits:



---

archive/issue_comments_239325.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-30T12:45:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239325",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239326.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-30T13:45:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239326",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239327.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-30T15:06:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239327",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_239328.json:
```json
{
    "body": "Just an idea:\n\nLogically, we can't really ask an object to inject itself into \"the\" globals namespace, because the object doesn't really have access to what that namespace is in the relevant situation.\n\nInstead what one *can* do from the REPL is to bind an object to its print name, which is what injection usually does. Then one actually doesn't need any special machinery on objects. See:\n[http://trac.sagemath.org/ticket/17958#comment:54](http://trac.sagemath.org/ticket/17958#comment:54)\n\nIn principle then one can spell:\n\n```\nsage: x = SR.var('x')\nsage: inject(x)\n```\n\nwhere `inject` could be defined in the \"global scope\" (by injecting its definition into the start-up, like `.sage`):\n\n```\ndef inject(a):\n    globals[str(a)]=a\n```\n\nexcept that we'd want to do some validation on `str(a)` before we do that.\nIt can also be shortened to `inject(SR.var('x'))` to avoid repetition.\n\nOf course to *type* this is very inconvenient, so we'd need some further wrappers to make the syntax more palatable (the `%var` directive seems like a good step), but the simplicity of the implementation and the flexibility of the construction leads me to believe that this is the right way of providing injection capability.",
    "created_at": "2015-04-13T15:35:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239328",
    "user": "nbruin"
}
```

Just an idea:

Logically, we can't really ask an object to inject itself into "the" globals namespace, because the object doesn't really have access to what that namespace is in the relevant situation.

Instead what one *can* do from the REPL is to bind an object to its print name, which is what injection usually does. Then one actually doesn't need any special machinery on objects. See:
[http://trac.sagemath.org/ticket/17958#comment:54](http://trac.sagemath.org/ticket/17958#comment:54)

In principle then one can spell:

```
sage: x = SR.var('x')
sage: inject(x)
```

where `inject` could be defined in the "global scope" (by injecting its definition into the start-up, like `.sage`):

```
def inject(a):
    globals[str(a)]=a
```

except that we'd want to do some validation on `str(a)` before we do that.
It can also be shortened to `inject(SR.var('x'))` to avoid repetition.

Of course to *type* this is very inconvenient, so we'd need some further wrappers to make the syntax more palatable (the `%var` directive seems like a good step), but the simplicity of the implementation and the flexibility of the construction leads me to believe that this is the right way of providing injection capability.



---

archive/issue_comments_239329.json:
```json
{
    "body": "Replying to [comment:7 nbruin]:\n> where `inject` could be defined in the \"global scope\" (by injecting its definition into the start-up, like `.sage`):\n> {{{\n> def inject(a):\n>     globals[str(a)]=a\n> }}}\n\nSo instead of calling `initialize_globals()` at global scope, you define `inject()` at global scope. That doesn't seem more simple or flexible.\n\nAnd I don't understand how you would implement `cython()` using your approach.",
    "created_at": "2015-04-13T15:49:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239329",
    "user": "jdemeyer"
}
```

Replying to [comment:7 nbruin]:
> where `inject` could be defined in the "global scope" (by injecting its definition into the start-up, like `.sage`):
> {{{
> def inject(a):
>     globals[str(a)]=a
> }}}

So instead of calling `initialize_globals()` at global scope, you define `inject()` at global scope. That doesn't seem more simple or flexible.

And I don't understand how you would implement `cython()` using your approach.



---

archive/issue_comments_239330.json:
```json
{
    "body": "Replying to [comment:8 jdemeyer]:\n> So instead of calling `initialize_globals()` at global scope, you define `inject()` at global scope. That doesn't seem more simple or flexible.\n\nNo, it doesn't make much practical difference. You're basically storing the dictionary on `inject.func_globals` instead of a custom store. I think it's useful to see that there's a \"natural\" way of expressing the concept in pure python. What the actual implementation underneath is, is another matter. I think it's worthwhile to give some consideration to using an implementation that is \"natural\" to python. The \"natural\" place for an inject to live is in the user scope, not as a method on various objects.\n \n> And I don't understand how you would implement `cython()` using your approach.\n\nThat's a matter of import, isn't it? Compiling cython normally gives a module `tmp_cython_module` and with `cython` you basically do a `from tmp_cython_module import *`.",
    "created_at": "2015-04-13T16:57:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239330",
    "user": "nbruin"
}
```

Replying to [comment:8 jdemeyer]:
> So instead of calling `initialize_globals()` at global scope, you define `inject()` at global scope. That doesn't seem more simple or flexible.

No, it doesn't make much practical difference. You're basically storing the dictionary on `inject.func_globals` instead of a custom store. I think it's useful to see that there's a "natural" way of expressing the concept in pure python. What the actual implementation underneath is, is another matter. I think it's worthwhile to give some consideration to using an implementation that is "natural" to python. The "natural" place for an inject to live is in the user scope, not as a method on various objects.
 
> And I don't understand how you would implement `cython()` using your approach.

That's a matter of import, isn't it? Compiling cython normally gives a module `tmp_cython_module` and with `cython` you basically do a `from tmp_cython_module import *`.



---

archive/issue_comments_239331.json:
```json
{
    "body": "Replying to [comment:9 nbruin]:\n> That's a matter of import, isn't it? Compiling cython normally gives a module `tmp_cython_module` and with `cython` you basically do a `from tmp_cython_module import *`.\nSo the one-liner `cython(\"foo\")` is going to change to looking at the output of `cython()` plus a manual `import`, probably with some `sys.path` manipulation thrown in?",
    "created_at": "2015-04-13T18:03:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239331",
    "user": "jdemeyer"
}
```

Replying to [comment:9 nbruin]:
> That's a matter of import, isn't it? Compiling cython normally gives a module `tmp_cython_module` and with `cython` you basically do a `from tmp_cython_module import *`.
So the one-liner `cython("foo")` is going to change to looking at the output of `cython()` plus a manual `import`, probably with some `sys.path` manipulation thrown in?



---

archive/issue_comments_239332.json:
```json
{
    "body": "Replying to [comment:10 jdemeyer]:\n> So the one-liner `cython(\"foo\")` is going to change to looking at the output of `cython()` plus a manual `import`, probably with some `sys.path` manipulation thrown in?\nNo, I wasn't proposing to change the user interface of `cython` at all. Internally it should be doing the `import` or at least the equivalent of it.\n\nMy observation is just that in the architecture of python, it is more natural to ask the REPL to inject a binding than to ask an object to inject itself into the global scope of the REPL. Hence, we might end up with simpler, easier to maintain code if we follow that design and use as a fundamental building block a service provided by the REPL.\n\nFor things like `var` and `cython` the interface is already so nice (modulo some other issues) that we should probably not change the spelling. But for\n\n```\nQQ['x','y'].inject_generators()\n```\n\nit might be nicer (and easier to implement!) to spell it as\n\n```\ninject(Q['x','y'].gens())\n```\n",
    "created_at": "2015-04-13T18:24:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239332",
    "user": "nbruin"
}
```

Replying to [comment:10 jdemeyer]:
> So the one-liner `cython("foo")` is going to change to looking at the output of `cython()` plus a manual `import`, probably with some `sys.path` manipulation thrown in?
No, I wasn't proposing to change the user interface of `cython` at all. Internally it should be doing the `import` or at least the equivalent of it.

My observation is just that in the architecture of python, it is more natural to ask the REPL to inject a binding than to ask an object to inject itself into the global scope of the REPL. Hence, we might end up with simpler, easier to maintain code if we follow that design and use as a fundamental building block a service provided by the REPL.

For things like `var` and `cython` the interface is already so nice (modulo some other issues) that we should probably not change the spelling. But for

```
QQ['x','y'].inject_generators()
```

it might be nicer (and easier to implement!) to spell it as

```
inject(Q['x','y'].gens())
```




---

archive/issue_comments_239333.json:
```json
{
    "body": "Replying to [comment:11 nbruin]:\n> Replying to [comment:10 jdemeyer]:\n> > So the one-liner `cython(\"foo\")` is going to change to looking at the output of `cython()` plus a manual `import`, probably with some `sys.path` manipulation thrown in?\n> Internally it should be doing the `import` or at least the equivalent of it.\nThat was exactly my question: how?",
    "created_at": "2015-04-13T18:31:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239333",
    "user": "jdemeyer"
}
```

Replying to [comment:11 nbruin]:
> Replying to [comment:10 jdemeyer]:
> > So the one-liner `cython("foo")` is going to change to looking at the output of `cython()` plus a manual `import`, probably with some `sys.path` manipulation thrown in?
> Internally it should be doing the `import` or at least the equivalent of it.
That was exactly my question: how?



---

archive/issue_comments_239334.json:
```json
{
    "body": "Replying to [comment:12 jdemeyer]:\n> That was exactly my question: how?\nLogically the (very thin!) wrapper `cython` might be injected into the same global scope as inject is written in.\n\nAlternatively, once \"inject\" has been defined, we could inject it:\n\n```\nsage.misc.cython.inject = inject #we don't need cython_c anymore\n```\n\nready for use there. Or one could access the dictionary there via inject.func_globals (which wouldn't be so clean).\n\nAdmittedly, this is all not so much cleaner than what happens now. The central \"cleaner\" principle is that there is a way of capturing a \"globals\" dictionary: define a function there. That should be a portable principle (accessing func_globals directly is probably not strictly portable).\n\nI'm not suggesting that we should absolutely implement it like this, but I think it might be useful to design the underlying code in a way that it *might* have been implemented in this way, simply to stay close to \"the python way\" of doing things. I don't think the python way is sacred, but since we're basing things on python, we should have good reasons every time we do deviate from it. And I'm not so sure that for injection we do have such a good reason.\n\nOne \"python way\" would be to define in, say, sage.misc.inject\n\n\n```\ndef inject(...):\n    raise RuntimeError(\"injecting code in an environment where injection isn't properly defined\")\n```\n\n\nand then have the different interfaces/REPLs monkey patch an appropriate \"inject\" into sage.misc.inject.inject.\n\nI'm not so sure how clean monkey patching is and how robust this is against `from sage.misc.inject import inject`, but at least it's an entirely python solution.",
    "created_at": "2015-04-13T22:03:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239334",
    "user": "nbruin"
}
```

Replying to [comment:12 jdemeyer]:
> That was exactly my question: how?
Logically the (very thin!) wrapper `cython` might be injected into the same global scope as inject is written in.

Alternatively, once "inject" has been defined, we could inject it:

```
sage.misc.cython.inject = inject #we don't need cython_c anymore
```

ready for use there. Or one could access the dictionary there via inject.func_globals (which wouldn't be so clean).

Admittedly, this is all not so much cleaner than what happens now. The central "cleaner" principle is that there is a way of capturing a "globals" dictionary: define a function there. That should be a portable principle (accessing func_globals directly is probably not strictly portable).

I'm not suggesting that we should absolutely implement it like this, but I think it might be useful to design the underlying code in a way that it *might* have been implemented in this way, simply to stay close to "the python way" of doing things. I don't think the python way is sacred, but since we're basing things on python, we should have good reasons every time we do deviate from it. And I'm not so sure that for injection we do have such a good reason.

One "python way" would be to define in, say, sage.misc.inject


```
def inject(...):
    raise RuntimeError("injecting code in an environment where injection isn't properly defined")
```


and then have the different interfaces/REPLs monkey patch an appropriate "inject" into sage.misc.inject.inject.

I'm not so sure how clean monkey patching is and how robust this is against `from sage.misc.inject import inject`, but at least it's an entirely python solution.



---

archive/issue_comments_239335.json:
```json
{
    "body": "Replying to [comment:13 nbruin]:\n> Replying to [comment:12 jdemeyer]:\n> > That was exactly my question: how?\n> Logically the (very thin!) wrapper `cython` might be injected into the same global scope as inject is written in.\nSorry, I don't understand this sentence.\n\n> Alternatively, once \"inject\" has been defined, we could inject it:\n> {{{\n> sage.misc.cython.inject = inject #we don't need cython_c anymore\n> }}}\nSo everybody's Sage code should start with the boilerplate\n\n```\nsage.calculus.var.inject = inject\nsage.calculus.function.inject = inject\nsage.calculus.desolver.inject = inject\nsage.misc.cython.inject = inject\nsage.misc.fortran.inject = inject\n```\n\nNot an elegant solution. Of course you could say \"let's define `inject` in just one place\" and call it from there, which is essentially my proposal.",
    "created_at": "2015-04-14T05:56:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239335",
    "user": "jdemeyer"
}
```

Replying to [comment:13 nbruin]:
> Replying to [comment:12 jdemeyer]:
> > That was exactly my question: how?
> Logically the (very thin!) wrapper `cython` might be injected into the same global scope as inject is written in.
Sorry, I don't understand this sentence.

> Alternatively, once "inject" has been defined, we could inject it:
> {{{
> sage.misc.cython.inject = inject #we don't need cython_c anymore
> }}}
So everybody's Sage code should start with the boilerplate

```
sage.calculus.var.inject = inject
sage.calculus.function.inject = inject
sage.calculus.desolver.inject = inject
sage.misc.cython.inject = inject
sage.misc.fortran.inject = inject
```

Not an elegant solution. Of course you could say "let's define `inject` in just one place" and call it from there, which is essentially my proposal.



---

archive/issue_comments_239336.json:
```json
{
    "body": "Replying to [comment:13 nbruin]:\n> to stay close to \"the python way\" of doing things.\nThe closest Python statement to what we're doing is `import` and I don't know how one would implement `import` in pure Python. So I would say there is really no Python equivalent...",
    "created_at": "2015-04-14T06:02:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239336",
    "user": "jdemeyer"
}
```

Replying to [comment:13 nbruin]:
> to stay close to "the python way" of doing things.
The closest Python statement to what we're doing is `import` and I don't know how one would implement `import` in pure Python. So I would say there is really no Python equivalent...



---

archive/issue_comments_239337.json:
```json
{
    "body": "Replying to [comment:13 nbruin]:\n> I'm not so sure how clean monkey patching is and how robust this is against `from sage.misc.inject import inject`, but at least it's an entirely python solution.\n\nAre you implying with this sentence that #12446 isn't \"entirely Python\"?",
    "created_at": "2015-04-14T12:15:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239337",
    "user": "jdemeyer"
}
```

Replying to [comment:13 nbruin]:
> I'm not so sure how clean monkey patching is and how robust this is against `from sage.misc.inject import inject`, but at least it's an entirely python solution.

Are you implying with this sentence that #12446 isn't "entirely Python"?



---

archive/issue_comments_239338.json:
```json
{
    "body": "Replying to [comment:16 jdemeyer]:\n> Are you implying with this sentence that #12446 isn't \"entirely Python\"?\n\nNo, it is. I originally thought that \"capturing\" the correct `globals()` by defining a function in the relevant scope was cleaner than calling `sage.repl.user_globals.initialize_globals(...)`, but that's not really the case.\n\nIn fact, one way a REPL could initialize globals is by injecting `sage.repl.user_globals.initialize_globals(globals())` into its \"user input stream\" at the start, which should work across REPLs. So I think your implementation is fine.\n\nI do think that `sage.repl.user_globals` is a dirty module, because its super-global side effects (that's its point--it's scribbling in a scope it shouldn't really have access to by normal python semantics) and hence should be used in as few places as possible in the library. So I'm still of the opinion that we'd be better off deprecating the `.inject_generators()` methods on various parents, in favour of a global scope function `inject(QQ['x,y'].gens)`.\n\nThe function `inject` would then normally not be available in library modules: it would need an explicit import.",
    "created_at": "2015-04-14T14:46:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239338",
    "user": "nbruin"
}
```

Replying to [comment:16 jdemeyer]:
> Are you implying with this sentence that #12446 isn't "entirely Python"?

No, it is. I originally thought that "capturing" the correct `globals()` by defining a function in the relevant scope was cleaner than calling `sage.repl.user_globals.initialize_globals(...)`, but that's not really the case.

In fact, one way a REPL could initialize globals is by injecting `sage.repl.user_globals.initialize_globals(globals())` into its "user input stream" at the start, which should work across REPLs. So I think your implementation is fine.

I do think that `sage.repl.user_globals` is a dirty module, because its super-global side effects (that's its point--it's scribbling in a scope it shouldn't really have access to by normal python semantics) and hence should be used in as few places as possible in the library. So I'm still of the opinion that we'd be better off deprecating the `.inject_generators()` methods on various parents, in favour of a global scope function `inject(QQ['x,y'].gens)`.

The function `inject` would then normally not be available in library modules: it would need an explicit import.



---

archive/issue_comments_239339.json:
```json
{
    "body": "Just discovered the existence of `old_style_globals` after some headscratching...\nAny thoughts about the status of this ticket?  In the meantime I'll add `old_style_globals` to this module that needs it...",
    "created_at": "2018-04-12T15:03:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239339",
    "user": "embray"
}
```

Just discovered the existence of `old_style_globals` after some headscratching...
Any thoughts about the status of this ticket?  In the meantime I'll add `old_style_globals` to this module that needs it...



---

archive/issue_comments_239340.json:
```json
{
    "body": "Just ran into this old ticket myself, looking at how we can work around `sage/calculus/var.pyx`:\n\n```\n    G = globals()  # this is the reason the code must be in Cython.\n```\n\nThere is a way to write such code in python directly. Something like:\n\n```\n    G = sys._getframe(1).f_globals\n```\n\nshould do the trick in most cases (if the caller's \"globals\" is a read-only dict itself, as a cython module \"globals\" would be, then one shouldn't be injecting variables in it anyway). I suspect that with `old_style_globals=False` the same line should work in cython code as well.",
    "created_at": "2019-08-14T22:45:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239340",
    "user": "nbruin"
}
```

Just ran into this old ticket myself, looking at how we can work around `sage/calculus/var.pyx`:

```
    G = globals()  # this is the reason the code must be in Cython.
```

There is a way to write such code in python directly. Something like:

```
    G = sys._getframe(1).f_globals
```

should do the trick in most cases (if the caller's "globals" is a read-only dict itself, as a cython module "globals" would be, then one shouldn't be injecting variables in it anyway). I suspect that with `old_style_globals=False` the same line should work in cython code as well.



---

archive/issue_comments_239341.json:
```json
{
    "body": "Cython doesn't generate a stack frame, so `sys._getframe(1).f_globals` is wrong, it should be `sys._getframe(0).f_globals`. But that's a complicated way to write the builtin `globals()`, so we might as well use that.\n\nIndeed, using `old_style_globals` is basically equivalent to doing\n\n```\nfrom builtins import globals\n```\n\n\nThis makes a difference because this overrides the Cython-specific `globals()`.",
    "created_at": "2019-08-19T10:55:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17846#issuecomment-239341",
    "user": "jdemeyer"
}
```

Cython doesn't generate a stack frame, so `sys._getframe(1).f_globals` is wrong, it should be `sys._getframe(0).f_globals`. But that's a complicated way to write the builtin `globals()`, so we might as well use that.

Indeed, using `old_style_globals` is basically equivalent to doing

```
from builtins import globals
```


This makes a difference because this overrides the Cython-specific `globals()`.
