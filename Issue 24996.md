# Issue 24996: gcd() of stacked polynomial rings broken with repeated variable names

archive/issues_024996.json:
```json
{
    "body": "\n```\nsage: p = QQ['x']['x'].one()\nsage: p.gcd(p)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-10-dc64a434c240> in <module>()\n----> 1 p.gcd(p)\n\nsage/structure/element.pyx in sage.structure.element.coerce_binop.new_method (build/cythonized/sage/structure/element.c:27055)()\n\nsage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.gcd (build/cythonized/sage/rings/polynomial/polynomial_element.c:43278)()\n\n/usr/lib/python2.7/dist-packages/sage/rings/polynomial/polynomial_ring_constructor.pyc in PolynomialRing(base_ring, *args, **kwds)\n    566             raise TypeError(\"you must specify the names of the variables\")\n    567 \n--> 568     names = normalize_names(n, names)\n    569 \n    570     # At this point, we have only handled the \"names\" keyword if it was\n\nsage/structure/category_object.pyx in sage.structure.category_object.normalize_names (build/cythonized/sage/structure/category_object.c:9519)()\n\nsage/structure/category_object.pyx in sage.structure.category_object.normalize_names (build/cythonized/sage/structure/category_object.c:9368)()\n\nsage/structure/category_object.pyx in sage.structure.category_object.certify_names (build/cythonized/sage/structure/category_object.c:10035)()\n\nValueError: variable name 'x' appears more than once\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/25233\n\n",
    "created_at": "2018-04-23T16:03:41Z",
    "labels": [
        "algebra",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.3",
    "title": "gcd() of stacked polynomial rings broken with repeated variable names",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/24996",
    "user": "@mezzarobba"
}
```

```
sage: p = QQ['x']['x'].one()
sage: p.gcd(p)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-10-dc64a434c240> in <module>()
----> 1 p.gcd(p)

sage/structure/element.pyx in sage.structure.element.coerce_binop.new_method (build/cythonized/sage/structure/element.c:27055)()

sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.gcd (build/cythonized/sage/rings/polynomial/polynomial_element.c:43278)()

/usr/lib/python2.7/dist-packages/sage/rings/polynomial/polynomial_ring_constructor.pyc in PolynomialRing(base_ring, *args, **kwds)
    566             raise TypeError("you must specify the names of the variables")
    567 
--> 568     names = normalize_names(n, names)
    569 
    570     # At this point, we have only handled the "names" keyword if it was

sage/structure/category_object.pyx in sage.structure.category_object.normalize_names (build/cythonized/sage/structure/category_object.c:9519)()

sage/structure/category_object.pyx in sage.structure.category_object.normalize_names (build/cythonized/sage/structure/category_object.c:9368)()

sage/structure/category_object.pyx in sage.structure.category_object.certify_names (build/cythonized/sage/structure/category_object.c:10035)()

ValueError: variable name 'x' appears more than once
```


Issue created by migration from https://trac.sagemath.org/ticket/25233





---

archive/issue_comments_351733.json:
```json
{
    "body": "I guess the natural fix would be to add support for repeated variables (renaming some automatically if necessary) in `FlatteningMorphism`, and use that in `Polynomial.gcd()` and `MPolynomial.gcd())`.",
    "created_at": "2018-04-23T16:07:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351733",
    "user": "@mezzarobba"
}
```

I guess the natural fix would be to add support for repeated variables (renaming some automatically if necessary) in `FlatteningMorphism`, and use that in `Polynomial.gcd()` and `MPolynomial.gcd())`.



---

archive/issue_comments_351734.json:
```json
{
    "body": "not finished yet\n----\nNew commits:",
    "created_at": "2018-04-23T19:25:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351734",
    "user": "@mezzarobba"
}
```

not finished yet
----
New commits:



---

archive/issue_comments_351735.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-04-24T07:38:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351735",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_351736.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-04-24T08:57:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351736",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_351737.json:
```json
{
    "body": "Changing priority from minor to major.",
    "created_at": "2018-04-24T08:57:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351737",
    "user": "@mezzarobba"
}
```

Changing priority from minor to major.



---

archive/issue_comments_351738.json:
```json
{
    "body": "New commits:",
    "created_at": "2018-04-24T08:57:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351738",
    "user": "@mezzarobba"
}
```

New commits:



---

archive/issue_comments_351739.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-04-24T08:57:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351739",
    "user": "@mezzarobba"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_351740.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-04-24T09:10:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351740",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_351741.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-04-24T09:41:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351741",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_351742.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2018-05-11T18:21:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351742",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_351743.json:
```json
{
    "body": "Moving the last two commits (plus further improvements) to a separate ticket #25346.",
    "created_at": "2018-05-11T18:23:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351743",
    "user": "@mezzarobba"
}
```

Moving the last two commits (plus further improvements) to a separate ticket #25346.



---

archive/issue_comments_351744.json:
```json
{
    "body": "A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace\n\n```\nif hasattr(a, 'f'):\n    return a.f()\nelse:\n    raise NotImplementedError\n```\n\nby\n\n```\ntry:\n    return a.f()\nexcept AttributeError:\n    raise NotImplementedError\n```\n",
    "created_at": "2018-05-12T19:24:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351744",
    "user": "@videlec"
}
```

A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace

```
if hasattr(a, 'f'):
    return a.f()
else:
    raise NotImplementedError
```

by

```
try:
    return a.f()
except AttributeError:
    raise NotImplementedError
```




---

archive/issue_comments_351745.json:
```json
{
    "body": "(rest looks good)",
    "created_at": "2018-05-12T19:25:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351745",
    "user": "@videlec"
}
```

(rest looks good)



---

archive/issue_comments_351746.json:
```json
{
    "body": "Replying to [comment:10 vdelecroix]:\n> A small performance notice: `hasattr` should be avoided as much as possible\n\nNot in Cython, in think, but I would need to double check.",
    "created_at": "2018-05-12T19:28:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351746",
    "user": "@mezzarobba"
}
```

Replying to [comment:10 vdelecroix]:
> A small performance notice: `hasattr` should be avoided as much as possible

Not in Cython, in think, but I would need to double check.



---

archive/issue_comments_351747.json:
```json
{
    "body": "adding my comment on #25346 here as this is where that error was added.\n\n\n\nI've run a few tests on this and haven't come up with anything that does not work correctly.\n\nHowever, I'd like to know what prompted the addition of ArithmeticError? to the gcd check in dehomomgenize for affine morphisms.\n\nIt is likely that whatever this is will also occur in normalize_coordinates for projective morphisms.",
    "created_at": "2018-05-12T20:25:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351747",
    "user": "@bhutz"
}
```

adding my comment on #25346 here as this is where that error was added.



I've run a few tests on this and haven't come up with anything that does not work correctly.

However, I'd like to know what prompted the addition of ArithmeticError? to the gcd check in dehomomgenize for affine morphisms.

It is likely that whatever this is will also occur in normalize_coordinates for projective morphisms.



---

archive/issue_comments_351748.json:
```json
{
    "body": "Replying to [comment:12 mmezzarobba]:\n> Replying to [comment:10 vdelecroix]:\n> > A small performance notice: `hasattr` should be avoided as much as possible\n> \n> Not in Cython, in think, but I would need to double check.\n\nActually it looks like you are right, Cython doesn't seem to be able to optimize these two lines as well as I'd thought.",
    "created_at": "2018-05-13T08:29:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351748",
    "user": "@mezzarobba"
}
```

Replying to [comment:12 mmezzarobba]:
> Replying to [comment:10 vdelecroix]:
> > A small performance notice: `hasattr` should be avoided as much as possible
> 
> Not in Cython, in think, but I would need to double check.

Actually it looks like you are right, Cython doesn't seem to be able to optimize these two lines as well as I'd thought.



---

archive/issue_comments_351749.json:
```json
{
    "body": "Replying to [comment:13 bhutz]:\n> However, I'd like to know what prompted the addition of ArithmeticError? to the gcd check in dehomomgenize for affine morphisms.\n\nI don't really remember. Here's what I'm getting without it:\n\n```\nFile \"src/sage/schemes/affine/affine_morphism.py\", line 519, in sage.schemes.affine.affine_morphism.SchemeMorphism_polynomial_affine_space.homogenize\nFailed example:\n    F.homogenize(1)\nException raised:\n    Traceback (most recent call last):\n      File \"/home/marc/co/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 562, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/home/marc/co/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 972, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.schemes.affine.affine_morphism.SchemeMorphism_polynomial_affine_space.homogenize[47]>\", line 1, in <module>\n        F.homogenize(Integer(1))\n      File \"/home/marc/co/sage/local/lib/python2.7/site-packages/sage/schemes/affine/affine_morphism.py\", line 561, in homogenize\n        g = gcd(F)\n      File \"/home/marc/co/sage/local/lib/python2.7/site-packages/sage/arith/misc.py\", line 1604, in gcd\n        return __GCD_sequence(seq, **kwargs)\n      File \"/home/marc/co/sage/local/lib/python2.7/site-packages/sage/arith/misc.py\", line 1652, in __GCD_sequence\n        g = vi.gcd(g, **kwargs)\n      File \"sage/rings/polynomial/multi_polynomial.pyx\", line 1872, in sage.rings.polynomial.multi_polynomial.MPolynomial.gcd (build/cythonized/sage/rings/polynomial/multi_polynomial.c:20533)\n        return self._parent(unibase._gcd_univariate_polynomial(uniself, other.polynomial(x)))\n      File \"/home/marc/co/sage/local/lib/python2.7/site-packages/sage/categories/unique_factorization_domains.py\", line 185, in _gcd_univariate_polynomial\n        B = B // b\n      File \"sage/rings/polynomial/polynomial_element.pyx\", line 10566, in sage.rings.polynomial.polynomial_element.Polynomial_generic_dense.__floordiv__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:97097)\n        cdef Polynomial_generic_dense res = (<Polynomial_generic_dense>self)._new_c([c // d for c in (<Polynomial_generic_dense>self).__coeffs], P)\n      File \"sage/rings/polynomial/polynomial_element.pyx\", line 10563, in sage.rings.polynomial.polynomial_element.Polynomial_generic_dense.__floordiv__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:96973)\n        return (<Polynomial_generic_dense>self)._floordiv_(<Polynomial_generic_dense>right)\n      File \"sage/rings/polynomial/polynomial_element.pyx\", line 2700, in sage.rings.polynomial.polynomial_element.Polynomial._floordiv_ (build/cythonized/sage/rings/polynomial/polynomial_element.c:29855)\n        Q, _ = self.quo_rem(right)\n      File \"sage/structure/element.pyx\", line 4260, in sage.structure.element.coerce_binop.new_method (build/cythonized/sage/structure/element.c:28282)\n        return method(self, other, *args, **kwargs)\n      File \"sage/rings/polynomial/polynomial_element.pyx\", line 10812, in sage.rings.polynomial.polynomial_element.Polynomial_generic_dense.quo_rem (build/cythonized/sage/rings/polynomial/polynomial_element.c:100180)\n        raise ArithmeticError(\"Division non exact (consider coercing to polynomials over the fraction field)\")\n    ArithmeticError: Division non exact (consider coercing to polynomials over the fraction field)\n```\n\nI guess that, since this was the only failure of this kind, I thought it would be best to catch the `ArithmeticError` there (instead of keeping a `try/catch` block in `gcd()`). But if you're saying the same issue will occur elsewhere, I'm not sure what to do. Opinions anyone?",
    "created_at": "2018-05-13T09:07:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351749",
    "user": "@mezzarobba"
}
```

Replying to [comment:13 bhutz]:
> However, I'd like to know what prompted the addition of ArithmeticError? to the gcd check in dehomomgenize for affine morphisms.

I don't really remember. Here's what I'm getting without it:

```
File "src/sage/schemes/affine/affine_morphism.py", line 519, in sage.schemes.affine.affine_morphism.SchemeMorphism_polynomial_affine_space.homogenize
Failed example:
    F.homogenize(1)
Exception raised:
    Traceback (most recent call last):
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 562, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 972, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.schemes.affine.affine_morphism.SchemeMorphism_polynomial_affine_space.homogenize[47]>", line 1, in <module>
        F.homogenize(Integer(1))
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/schemes/affine/affine_morphism.py", line 561, in homogenize
        g = gcd(F)
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/arith/misc.py", line 1604, in gcd
        return __GCD_sequence(seq, **kwargs)
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/arith/misc.py", line 1652, in __GCD_sequence
        g = vi.gcd(g, **kwargs)
      File "sage/rings/polynomial/multi_polynomial.pyx", line 1872, in sage.rings.polynomial.multi_polynomial.MPolynomial.gcd (build/cythonized/sage/rings/polynomial/multi_polynomial.c:20533)
        return self._parent(unibase._gcd_univariate_polynomial(uniself, other.polynomial(x)))
      File "/home/marc/co/sage/local/lib/python2.7/site-packages/sage/categories/unique_factorization_domains.py", line 185, in _gcd_univariate_polynomial
        B = B // b
      File "sage/rings/polynomial/polynomial_element.pyx", line 10566, in sage.rings.polynomial.polynomial_element.Polynomial_generic_dense.__floordiv__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:97097)
        cdef Polynomial_generic_dense res = (<Polynomial_generic_dense>self)._new_c([c // d for c in (<Polynomial_generic_dense>self).__coeffs], P)
      File "sage/rings/polynomial/polynomial_element.pyx", line 10563, in sage.rings.polynomial.polynomial_element.Polynomial_generic_dense.__floordiv__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:96973)
        return (<Polynomial_generic_dense>self)._floordiv_(<Polynomial_generic_dense>right)
      File "sage/rings/polynomial/polynomial_element.pyx", line 2700, in sage.rings.polynomial.polynomial_element.Polynomial._floordiv_ (build/cythonized/sage/rings/polynomial/polynomial_element.c:29855)
        Q, _ = self.quo_rem(right)
      File "sage/structure/element.pyx", line 4260, in sage.structure.element.coerce_binop.new_method (build/cythonized/sage/structure/element.c:28282)
        return method(self, other, *args, **kwargs)
      File "sage/rings/polynomial/polynomial_element.pyx", line 10812, in sage.rings.polynomial.polynomial_element.Polynomial_generic_dense.quo_rem (build/cythonized/sage/rings/polynomial/polynomial_element.c:100180)
        raise ArithmeticError("Division non exact (consider coercing to polynomials over the fraction field)")
    ArithmeticError: Division non exact (consider coercing to polynomials over the fraction field)
```

I guess that, since this was the only failure of this kind, I thought it would be best to catch the `ArithmeticError` there (instead of keeping a `try/catch` block in `gcd()`). But if you're saying the same issue will occur elsewhere, I'm not sure what to do. Opinions anyone?



---

archive/issue_comments_351750.json:
```json
{
    "body": "Looking at that example failure, here is what is boils down to: the following gets the ArithmeticError\n\n\n```\nR.<d,c>=QQbar[]\nS.<x0,x1>=R[]\nf=d*x0^2+x0;g=S(x0^2)\ngcd(f,g)\n```\n\n\nIt used to return\n\n```\n  File \"/home/ben/sage/sage-release/local/lib/python2.7/site-packages/sage/arith/misc.py\", line 1584, in gcd\n    raise TypeError(\"unable to find gcd\")\nTypeError: unable to find gcd\n```\n\n\nSo if this is just a case of gcd returning an error in an uncomputable case, then adding to the try/except in homogenize is the right thing to do. Homogenize is still perfectly valid without removing the gcd and that try/except is exactly to catch the failures from gcd.\n\nnormalize_coordinates for projective morphisms and points must have the gcd removed (that is their whole point) so they don't do a try/except and just throw the error from gcd. But similar examples should fail here as well (and this one does).\n\n\nLooking at little further into the example, it is interesting that if you make either R or S a univariate polynomial ring, then the gcd computes\n\n```\nR.<d,c>=QQbar[]\nS.<x0>=R[]\nf=d*x0^2+d*x0;g=S(c*d*x0^2)\ngcd(f,g)\n```\n\nThat seems to say to me that there may still be an underlying issue with gcd here since if you are using Flattening to take the gcd, I don't see how this change should affect anything.",
    "created_at": "2018-05-13T11:57:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351750",
    "user": "@bhutz"
}
```

Looking at that example failure, here is what is boils down to: the following gets the ArithmeticError


```
R.<d,c>=QQbar[]
S.<x0,x1>=R[]
f=d*x0^2+x0;g=S(x0^2)
gcd(f,g)
```


It used to return

```
  File "/home/ben/sage/sage-release/local/lib/python2.7/site-packages/sage/arith/misc.py", line 1584, in gcd
    raise TypeError("unable to find gcd")
TypeError: unable to find gcd
```


So if this is just a case of gcd returning an error in an uncomputable case, then adding to the try/except in homogenize is the right thing to do. Homogenize is still perfectly valid without removing the gcd and that try/except is exactly to catch the failures from gcd.

normalize_coordinates for projective morphisms and points must have the gcd removed (that is their whole point) so they don't do a try/except and just throw the error from gcd. But similar examples should fail here as well (and this one does).


Looking at little further into the example, it is interesting that if you make either R or S a univariate polynomial ring, then the gcd computes

```
R.<d,c>=QQbar[]
S.<x0>=R[]
f=d*x0^2+d*x0;g=S(c*d*x0^2)
gcd(f,g)
```

That seems to say to me that there may still be an underlying issue with gcd here since if you are using Flattening to take the gcd, I don't see how this change should affect anything.



---

archive/issue_comments_351751.json:
```json
{
    "body": "Replying to [comment:10 vdelecroix]:\n> A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace\n> {{{\n> if hasattr(a, 'f'):\n>     return a.f()\n> else:\n>     raise NotImplementedError\n> }}}\n> by\n> {{{\n> try:\n>     return a.f()\n> except AttributeError:\n>     raise NotImplementedError\n> }}}\n\nYes and no in Python, it depends on what you expect to happen more often:\n\n```sage\nsage: class Foo(object):\n....:     def bar(self):\n....:         return\n....:\nsage: def test1(F):\n....:     if hasattr(F, 'bar'):\n....:         return F.bar()\n....:     return\nsage: def test2(F):\n....:     try:\n....:         return F.bar()\n....:     except AttributeError:\n....:         return\nsage: class Baz(object):\n....:     pass\n```\n\n\n```\nsage: F = Foo()\nsage: B = Baz()\nsage: %timeit test1(F)\nThe slowest run took 15.48 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000000 loops, best of 3: 323 ns per loop\nsage: %timeit test2(F)\nThe slowest run took 9.63 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000000 loops, best of 3: 198 ns per loop\n\nsage: %timeit test1(B)\nThe slowest run took 8.00 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000000 loops, best of 3: 506 ns per loop\nsage: %timeit test2(B)\nThe slowest run took 6.16 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000000 loops, best of 3: 1.28 \u00b5s per loop\n```\n\nIt is clearly faster to do the `try-except` when the object has the method by about 50%, but when it does not, it is 2x slower and needs over a microsecond on my laptop to do said test. Considering the slowdown for doing the `hasattr` check is modest compared to the raising and catching of an exception, unless you expect the method to typically be there, I think the `hasattr` is a better way to go. Plus, it usually makes the logic easier to follow.",
    "created_at": "2018-05-13T12:53:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351751",
    "user": "@tscrim"
}
```

Replying to [comment:10 vdelecroix]:
> A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace
> {{{
> if hasattr(a, 'f'):
>     return a.f()
> else:
>     raise NotImplementedError
> }}}
> by
> {{{
> try:
>     return a.f()
> except AttributeError:
>     raise NotImplementedError
> }}}

Yes and no in Python, it depends on what you expect to happen more often:

```sage
sage: class Foo(object):
....:     def bar(self):
....:         return
....:
sage: def test1(F):
....:     if hasattr(F, 'bar'):
....:         return F.bar()
....:     return
sage: def test2(F):
....:     try:
....:         return F.bar()
....:     except AttributeError:
....:         return
sage: class Baz(object):
....:     pass
```


```
sage: F = Foo()
sage: B = Baz()
sage: %timeit test1(F)
The slowest run took 15.48 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 323 ns per loop
sage: %timeit test2(F)
The slowest run took 9.63 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 198 ns per loop

sage: %timeit test1(B)
The slowest run took 8.00 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 506 ns per loop
sage: %timeit test2(B)
The slowest run took 6.16 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.28 µs per loop
```

It is clearly faster to do the `try-except` when the object has the method by about 50%, but when it does not, it is 2x slower and needs over a microsecond on my laptop to do said test. Considering the slowdown for doing the `hasattr` check is modest compared to the raising and catching of an exception, unless you expect the method to typically be there, I think the `hasattr` is a better way to go. Plus, it usually makes the logic easier to follow.



---

archive/issue_comments_351752.json:
```json
{
    "body": "Replying to [comment:17 tscrim]:\n> Replying to [comment:10 vdelecroix]:\n> > A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace\n> > {{{\n> > if hasattr(a, 'f'):\n> >     return a.f()\n> > else:\n> >     raise NotImplementedError\n> > }}}\n> > by\n> > {{{\n> > try:\n> >     return a.f()\n> > except AttributeError:\n> >     raise NotImplementedError\n> > }}}\n> \n> <SNIP>\n> It is clearly faster to do the `try-except` when the object has the method by about 50%\n> <SNIP>\n\nThis is precisely the point here. When the method is not there an error is triggered anyway.",
    "created_at": "2018-05-13T21:12:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351752",
    "user": "@videlec"
}
```

Replying to [comment:17 tscrim]:
> Replying to [comment:10 vdelecroix]:
> > A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace
> > {{{
> > if hasattr(a, 'f'):
> >     return a.f()
> > else:
> >     raise NotImplementedError
> > }}}
> > by
> > {{{
> > try:
> >     return a.f()
> > except AttributeError:
> >     raise NotImplementedError
> > }}}
> 
> <SNIP>
> It is clearly faster to do the `try-except` when the object has the method by about 50%
> <SNIP>

This is precisely the point here. When the method is not there an error is triggered anyway.



---

archive/issue_comments_351753.json:
```json
{
    "body": "Replying to [comment:18 vdelecroix]:\n> Replying to [comment:17 tscrim]:\n> > Replying to [comment:10 vdelecroix]:\n> > > A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace\n> > > {{{\n> > > if hasattr(a, 'f'):\n> > >     return a.f()\n> > > else:\n> > >     raise NotImplementedError\n> > > }}}\n> > > by\n> > > {{{\n> > > try:\n> > >     return a.f()\n> > > except AttributeError:\n> > >     raise NotImplementedError\n> > > }}}\n> > \n> > <SNIP>\n> > It is clearly faster to do the `try-except` when the object has the method by about 50%\n> > <SNIP>\n> \n> This is precisely the point here. When the method is not there an error is triggered anyway.\n\nYou're missing my point about a rebuttal against your comment about avoiding `hasattr` as much as possible. In this case it is less important because the other code is to raise an error. In general where there can be two genuine code paths, there are other factors to consider.",
    "created_at": "2018-05-13T21:38:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351753",
    "user": "@tscrim"
}
```

Replying to [comment:18 vdelecroix]:
> Replying to [comment:17 tscrim]:
> > Replying to [comment:10 vdelecroix]:
> > > A small performance notice: `hasattr` should be avoided as much as possible (it costs a dictionary lookup). It is better to replace
> > > {{{
> > > if hasattr(a, 'f'):
> > >     return a.f()
> > > else:
> > >     raise NotImplementedError
> > > }}}
> > > by
> > > {{{
> > > try:
> > >     return a.f()
> > > except AttributeError:
> > >     raise NotImplementedError
> > > }}}
> > 
> > <SNIP>
> > It is clearly faster to do the `try-except` when the object has the method by about 50%
> > <SNIP>
> 
> This is precisely the point here. When the method is not there an error is triggered anyway.

You're missing my point about a rebuttal against your comment about avoiding `hasattr` as much as possible. In this case it is less important because the other code is to raise an error. In general where there can be two genuine code paths, there are other factors to consider.



---

archive/issue_comments_351754.json:
```json
{
    "body": "Replying to [comment:16 bhutz]:\n> Looking at little further into the example, it is interesting that if you make either R or S a univariate polynomial ring, then the gcd computes\n> {{{\n> R.<d,c>=QQbar[]\n> S.<x0>=R[]\n> f=d*x0<sup>2+d*x0;g=S(c*d*x0</sup>2)\n> gcd(f,g)\n> }}}\n> That seems to say to me that there may still be an underlying issue with gcd here since if you are using Flattening to take the gcd, I don't see how this change should affect anything.\n\nThe difference\u2014I think\u2014is that the new code for multivariate polynomials checks whether the flattened polynomial ring \u201c`_has_singular`\u201d before trying to call `gcd` on the flattened polynomials. In you example, this is not the case, and hence it continues with the original polynomial and ends up doing\n\n```\n        x = self._parent.gens()[-1]\n        uniself = self.polynomial(x)\n        unibase = uniself.base_ring()\n        if hasattr(unibase, \"_gcd_univariate_polynomial\"):\n            return self._parent(unibase._gcd_univariate_polynomial(uniself, other.polynomial(x)))\n```\n\nwith `uniself` in QQbar[c,d][x\u2080][x\u2081], which fails with an `ArithmeticError`. In contrast, the previous version would call itself recursively on a polynomial in QQbar[c,d,x\u2080,x\u2081], which would then be turned into an element of QQbar[c,d,x\u2080][x\u2081] during the recursive call, and fail with a different error.",
    "created_at": "2018-05-14T09:25:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351754",
    "user": "@mezzarobba"
}
```

Replying to [comment:16 bhutz]:
> Looking at little further into the example, it is interesting that if you make either R or S a univariate polynomial ring, then the gcd computes
> {{{
> R.<d,c>=QQbar[]
> S.<x0>=R[]
> f=d*x0<sup>2+d*x0;g=S(c*d*x0</sup>2)
> gcd(f,g)
> }}}
> That seems to say to me that there may still be an underlying issue with gcd here since if you are using Flattening to take the gcd, I don't see how this change should affect anything.

The difference—I think—is that the new code for multivariate polynomials checks whether the flattened polynomial ring “`_has_singular`” before trying to call `gcd` on the flattened polynomials. In you example, this is not the case, and hence it continues with the original polynomial and ends up doing

```
        x = self._parent.gens()[-1]
        uniself = self.polynomial(x)
        unibase = uniself.base_ring()
        if hasattr(unibase, "_gcd_univariate_polynomial"):
            return self._parent(unibase._gcd_univariate_polynomial(uniself, other.polynomial(x)))
```

with `uniself` in QQbar[c,d][x₀][x₁], which fails with an `ArithmeticError`. In contrast, the previous version would call itself recursively on a polynomial in QQbar[c,d,x₀,x₁], which would then be turned into an element of QQbar[c,d,x₀][x₁] during the recursive call, and fail with a different error.



---

archive/issue_comments_351755.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-14T10:07:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351755",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_351756.json:
```json
{
    "body": "Replying to [comment:16 bhutz]:\n> it is interesting that if you make either R or S a univariate polynomial ring, then the gcd computes\n\nOf course, this also means that it should be possible to make gcds over QQbar[c,d][x\u2080,x\u2081] work too... But I'd prefer to keep that for another ticket.\n\nOn a related note, I doubt that the code path of MPolynomial.gcd() that reduces to a univariate gcd is actually used in any successful computation. It may be possible to simplify the method to something like\n\n```\nflatten = self._parent.flattening_morphism()\ntgt = flatten.codomain()\nif not tgt._has_singular:\n    raise NotImplementedError(\"GCD is not implemented for multivariate polynomials over {}\".format(self._parent._mpoly_base_ring()))\nself, other = flatten(self), flatten(other)\ntgt._singular_().set_ring()\ng = self._singular_().gcd(other._singular_())\nreturn flatten.section()(tgt(g))\n```\n\nwithout losing any functionality...",
    "created_at": "2018-05-14T10:20:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351756",
    "user": "@mezzarobba"
}
```

Replying to [comment:16 bhutz]:
> it is interesting that if you make either R or S a univariate polynomial ring, then the gcd computes

Of course, this also means that it should be possible to make gcds over QQbar[c,d][x₀,x₁] work too... But I'd prefer to keep that for another ticket.

On a related note, I doubt that the code path of MPolynomial.gcd() that reduces to a univariate gcd is actually used in any successful computation. It may be possible to simplify the method to something like

```
flatten = self._parent.flattening_morphism()
tgt = flatten.codomain()
if not tgt._has_singular:
    raise NotImplementedError("GCD is not implemented for multivariate polynomials over {}".format(self._parent._mpoly_base_ring()))
self, other = flatten(self), flatten(other)
tgt._singular_().set_ring()
g = self._singular_().gcd(other._singular_())
return flatten.section()(tgt(g))
```

without losing any functionality...



---

archive/issue_comments_351757.json:
```json
{
    "body": "Replying to [comment:11 vdelecroix]:\n> (rest looks good)\n\nDoes it mean that we can set this ticket to positive_review now that this issue is solved?",
    "created_at": "2018-05-19T08:57:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351757",
    "user": "@mezzarobba"
}
```

Replying to [comment:11 vdelecroix]:
> (rest looks good)

Does it mean that we can set this ticket to positive_review now that this issue is solved?



---

archive/issue_comments_351758.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2018-05-29T06:10:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351758",
    "user": "@videlec"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_351759.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-05-30T19:19:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24996",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24996#issuecomment-351759",
    "user": "@vbraun"
}
```

Resolution: fixed
